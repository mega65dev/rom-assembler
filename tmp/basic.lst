
; ******** Source: basic.asm

; ******** Source: system/header.asm
     1                          
     2                          
     3                          
     4                          ;  ***************************************************************************
     5                          ;  *                               //                                        *
     6                          ;  *              CCCCCCC         //    6666666     555555555                *
     7                          ;  *             CCC   CCC       //    666   666    555                      *
     8                          ;  *            CCC             //    666           555                      *
     9                          ;  *            CCC            //     666 6666      55555555                 *
    10                          ;  *            CCC           //      6666   666          555                *
    11                          ;  *            CCC          //       666     666          555               *
    12                          ;  *             CCC   CCC  //         666   666    555   555                *
    13                          ;  *              CCCCCCC  //           6666666      5555555                 *
    14                          ;  *                      //                                                 *
    15                          ;  *                                                                         *
    16                          ;  *          BBBBBBBBB      AAAA      SSSSSSSS   III    CCCCCCC             *
    17                          ;  *          BBB    BBB   AAA  AAA   SSS    SSS  III   CCC   CCC            *
    18                          ;  *          BBB    BBB  AAA    AAA  SSS         III  CCC                   *
    19                          ;  *          BBBBBBBBB   AAAAAAAAAA   SSSSSSSS   III  CCC                   *
    20                          ;  *          BBB    BBB  AAA    AAA         SSS  III  CCC                   *
    21                          ;  *          BBB    BBB  AAA    AAA  SSS    SSS  III   CCC   CCC            *
    22                          ;  *          BBBBBBBBB   AAA    AAA   SSSSSSSS   III    CCCCCCC             *
    23                          ;  *                                                                         *
    24                          ;  *                       V E R S I O N   1 0 . 0                           *
    25                          ;  *              *
    26                          ;  *        Copyright (C)1991  by   Commodore Business Machines, Inc.        *
    27                          ;  *              *
    28                          ;  *       All  Rights  Reserved        *
    29                          ;  *              *
    30                          ;  ***************************************************************************
    31                          
    32                          ;   ROM VERSION  911115  (ver 0.9B)
    33                          
    34                          ; ******************************************************************
    35                          ; *                                                                *
    36                          ; * This listing contains confidential and proprietary information *
    37                          ; * of CBM, Inc.  The reproduction, dissemination or disclosure to *
    38                          ; * others without express written permission is prohibited.  This *
    39                          ; * software is for use in prototype Commodore C/65 systems only.  *
    40                          ; *                                                                *
    41                          ; *  The information in this document will change without notice.  *
    42                          ; *                                                                *
    43                          ; *  No  responsibility  is  assumed  for the reliability of this  *
    44                          ; *                          software.                             *
    45                          ; *                                                                *
    46                          ; ******************************************************************
    47                          
    48                          
    49                          
    50                          ; This version written and assembled by Fred Bowen using BSO format.
    51                          
    52                          ; Adapted from the following C128 files, ROM part numbers 318018-04, 3180194-04:
    53                          ;
    54                          ; disclaim  resume   hexfunc
    55                          ; declare   doloop   rgr
    56                          ; entries   key   rclr
    57                          ; header   paint   joy
    58                          ; init   box   penpot
    59                          ; indjumps  sshape   pointer
    60                          ; crunch   gshape   rsprite
    61                          ; tokens1   circle   rspcolor
    62                          ; tokens2   draw   bump
    63                          ; disptable  char   rsppos
    64                          ; errmsgs   locate   xor
    65                          ; errprint  scale   rwindow
    66                          ; execute   color   rnd
    67                          ; functions  scnclr   code12
    68                          ; code0   graphic   stringfns
    69                          ; rtstack   bank   code17
    70                          ; findline  sleep   code18
    71                          ; lineget   wait   code19
    72                          ; list   sprite   code21
    73                          ; newclr   movspr   code22
    74                          ; return   play   code23
    75                          ; remdata   filter   code24
    76                          ; if   envelope  code26
    77                          ; ongoto   collision  grbcol
    78                          ; let   sprcolor  trig
    79                          ; print   width   using
    80                          ; input   volume   instring
    81                          ; next   sound   graphic3
    82                          ; dim   window   rdot
    83                          ; sys   boot   graphic7
    84                          ; trontroff  sprdef   graphic8
    85                          ; rreg   sprsav   graphic9
    86                          ; midequal  fast   graphic10
    87                          ; auto   slow   graphic11
    88                          ; help   checkval  sethires
    89                          ; gosubgoto  formeval  clrhires
    90                          ; go   variables  dos1
    91                          ; continue  getpointr  dos2
    92                          ; run   array   dos3
    93                          ; restore   patcheslo  dos4
    94                          ; renumber  fre   overflow
    95                          ; for   val   irq
    96                          ; delete   dec   stash
    97                          ; pudef   peekpoke  fetch
    98                          ; trap   errfunc   swap
    99                          ; patcheshi  jumptable  def
   100                          ; strings
   101                          
   102                          
   103                          
   104                          
   105                          
   106                          
   107                          

; ******** Source: basic.asm

; ******** Source: data/constants.asm
     1                          ; General assignments and equates
     2                          
     3                          doslfn           = 0                                      ; DOS' private logical file number
     4                          dosffn           = 8                                      ; DOS' default drive number
     5                          
     6                          strsiz           = 3                                      ; string descriptor size in temps. and arrays
     7                          lengos           = 5                                      ; length of a GOSUB entry on the runtime stack
     8                          lenfor           = 18                                     ; length of a FOR entry in the runtime stack
     9                          
    10                          ; maxchr = 80  ;misc. command equates
    11                          ; llen  = 40
    12                          ; nlines = 25
    13                          column_width     = 10                                     ; print comma spacing
    14                          
    15                          beats_pal        = 1200                                   ; whole note (4/4 time = 2sec.)    [910724]
    16                          beats_ntsc       = 1440                                   ;
    17                          
    18                          lf               = $0a                                    ; line feed
    19                          cr               = $0d                                    ; carriage return
    20                          esc              = $1b                                    ; escape
    21                          pi               = $ff
    22                          
    23                          basbgn           = $2000                                  ; bottom of BASIC text bank
    24                          baswrk           = basbgn+1                               ; where BASIC text starts
    25                          varbgn           = $2000                                  ; bottom of BASIC data bank (C65: DOS RAM below $12000)
    26                          bank_0_top       = $8000                                  ; top of BASIC text bank ($FF00)    [910528]
    27                          bank_1_top       = $8000                                  ; top of BASIC data bank ($f800, VIC attributes)  [910528]
    28                          
    29                          ; graphic_base = $2000
    30                          ; color_ram_lo = $1c00
    31                          ; color_ram_hi = $d800
    32                          
    33                          vic              = $d000                                  ; Video controller
    34                          
    35                          fdc              = $d080                                  ; Built-in floppy disk controller
    36                          
    37                          sid1             = $d400                                  ; Audio processors (right)
    38                          sid2             = $d420                                  ; (left)
    39                          
    40                          d1_6526          = $dc00                                  ; Ports, peripheral control
    41                          d1pra            = d1_6526
    42                          d2_6526          = $dd00
    43                          d2pra            = d2_6526
    44                          
    45                          dma_ctlr         = $d700                                  ; DMA Controller
    46                          
    47                          

; ******** Source: basic.asm

; ******** Source: data/zeropage.asm
     1                          
     2                                           * = $0000
     3                          
     4  0000 0000                                !fill 2                                  ; '4510' registers (not used in C65 mode)
     5  0002 00                 srchtk           !fill 1                                  ; token 'search' looks for (run-time stack) / SYS 'bank#'
     6                          
     7                                           * = $000a                                ; skip over SYS address, status, a/x/y/z registers
     8                          
     9                          integr                                                    ; used by math routines (this & following location)
    10  000a 00                 charac           !fill 1
    11  000b 00                 endchr           !fill 1
    12  000c 00                 verck            !fill 1                                  ; LOAD/VERIFY flag
    13  000d 00                 count            !fill 1                                  ; temp used all over
    14  000e 00                 dimflg           !fill 1                                  ; DIM flag used by variable search
    15  000f 00                 valtyp           !fill 1                                  ; 0=numeric, $FF=string
    16  0010 00                 intflg           !fill 1                                  ; b7: (0=float,1=integer), b6: (1=get flag)
    17                          garbfl                                                    ; garbage collection temporary
    18  0011 00                 dores            !fill 1                                  ; b7: P1LINE quote flag
    19  0012 00                 subflg           !fill 1                                  ; b7: subscript flag (set to disallow subscripts() & integers%)
    20  0013 00                 input_flag       !fill 1                                  ; READ($98), GET($40), or INPUT($00)
    21                          domask
    22  0014 00                 tansgn           !fill 1
    23  0015 00                 channl           !fill 1                                  ; active I/O channel
    24                          poker                                                     ; temp used all over
    25  0016 0000               linnum           !fill 2                                  ; line number
    26                          
    27  0018 00                 temppt           !fill 1                                  ; pointer to next temporary descriptor in tempst
    28  0019 0000               lastpt           !fill 2                                  ; pointer to last used temporary string
    29  001b 0000000000000000...tempst           !fill 9                                  ; temporary descriptor pointers (3 at 3 bytes each)
    30                          
    31                          index
    32  0024 0000               index1           !fill 2
    33  0026 0000               index2           !fill 2
    34                          
    35                          multiplicand                                              ; 2 bytes wide, for unsigned integer multiply
    36  0028 00                 resho            !fill 1
    37  0029 00                 resmoh           !fill 1
    38                          product                                                   ; 3 bytes wide, for unsigned integer multiply
    39                          addend
    40  002a 00                 resmo            !fill 1
    41  002b 00                 reslo            !fill 1
    42  002c 00                                  !fill 1
    43  002d 0000               txttab           !fill 2                                  ; where BASIC program begins   (text_bank)
    44  002f 0000               vartab           !fill 2                                  ; where variable descriptors begin  (var_bank)
    45  0031 0000               arytab           !fill 2                                  ; where array table begins   (var_bank)
    46  0033 0000               strend           !fill 2                                  ; where arrays table ends   (var_bank)
    47  0035 0000               fretop           !fill 2                                  ; bottom of string storage   (var_bank)
    48  0037 0000               frespc           !fill 2                                  ; where temporary strings begin   (var_bank)
    49  0039 0000               max_mem_1        !fill 2                                  ; highest address available to BASIC in RAM 1 (var_bank)
    50  003b 0000               curlin           !fill 2
    51  003d 0000               txtptr           !fill 2                                  ; pointer to BASIC text used by CHRGET, etc.
    52                          form                                                      ; used by print using
    53  003f 0000               fndpnt           !fill 2                                  ; pointer to item found by search
    54  0041 0000               datlin           !fill 2
    55  0043 0000               datptr           !fill 2
    56  0045 0000               inpptr           !fill 2
    57  0047 0000               varnam           !fill 2
    58                          fdecpt
    59  0049 0000               varpnt           !fill 2
    60                          lstpnt
    61                          andmsk
    62  004b 0000               forpnt           !fill 2
    63                          eormsk           =forpnt+1
    64                          vartxt
    65  004d 0000               opptr            !fill 2
    66  004f 00                 opmask           !fill 1
    67                          grbpnt
    68                          tempf3
    69  0050 0000               defpnt           !fill 2
    70  0052 0000               dscpnt           !fill 2
    71                          token_saver                                               ; temp used by P1LINE/HELPSB (was spare????) [910628]
    72  0054 00                 trmpos           !fill 1                                  ; temp used by SPC(), TAB()   [910628]
    73                          
    74  0055 00                 helper           !fill 1                                  ; P1LINE flag b7: HELP vs. LIST
    75                          ;  b6: memory vs. file
    76                          ;  b5: FIND/CHANGE
    77                          ;  b4: highlight tokens
    78                          ;  b3: highlight REM
    79                          ;  b1: LINGET flag for AUTOSCROLL
    80                          ;  b0: token in progress
    81                          
    82  0056 00                 jmper            !fill 1                                  ; 3 locations used by Function handler
    83  0057 00                                  !fill 1                                  ;
    84  0058 00                 oldov            !fill 1                                  ;
    85                          
    86  0059 00                 tempf1           !fill 1                                  ; used by math routines
    87                          ptarg1           =tempf1                                  ; multiply defined for INSTR thru FACexp
    88                          ptarg2           =tempf1+2                                ; (also used by Monitor Utility, thru lowtr)
    89                          str1             =tempf1+4
    90                          str2             =tempf1+7
    91                          positn           =tempf1+10
    92                          match            =tempf1+11
    93                          
    94                          arypnt
    95  005a 0000               highds           !fill 2
    96  005c 0000               hightr           !fill 2
    97                          
    98  005e 00                 tempf2           !fill 1                                  ; used by math routines
    99  005f 0000               deccnt           !fill 2
   100                          tenexp           = deccnt+1
   101                          grbtop
   102                          dptflg
   103  0061 00                 lowtr            !fill 1
   104  0062 00                 expsgn           !fill 1
   105                          
   106                          fac                                                       ; Floating point accumulator (primary) FAC1
   107                          dsctmp
   108  0063 00                 facexp           !fill 1
   109  0064 00                 facho            !fill 1
   110  0065 00                 facmoh           !fill 1
   111                          indice
   112  0066 00                 facmo            !fill 1
   113  0067 00                 faclo            !fill 1
   114  0068 00                 facsgn           !fill 1
   115                          degree
   116  0069 00                 sgnflg           !fill 1
   117                          
   118  006a 00                 argexp           !fill 1                                  ; Floating point accumulator (secondary) FAC2
   119  006b 00                 argho            !fill 1
   120  006c 00                 argmoh           !fill 1
   121  006d 00                 argmo            !fill 1
   122  006e 00                 arglo            !fill 1
   123  006f 00                 argsgn           !fill 1
   124                          
   125                          strng1
   126  0070 00                 arisgn           !fill 1
   127  0071 00                 facov            !fill 1
   128                          
   129                          strng2
   130                          polypt
   131                          curtol
   132  0072 0000               fbufpt           !fill 2
   133                          
   134  0074 0000               autinc           !fill 2                                  ; incremental value for AUTO (0=off)
   135                          
   136  0076 00                 z_p_temp_1       !fill 1                                  ; USING's leading zero counter
   137                          ;GET, RENUMBER, KEY temporary
   138                          ;MOVSPR, SPRITE, PLAY, VOL temporary
   139                          ;MID$= temporary
   140                          
   141                          hulp                                                      ; counter
   142  0077 00                 keysiz           !fill 1
   143                          
   144  0078 00                 syntmp           !fill 1                                  ; used as temp all over the place
   145  0079 000000             dsdesc           !fill 3                                  ; descriptor for DS$
   146  007c 0000               tos              !fill 2                                  ; top of run time stack
   147  007e 00                 runmod           !fill 1                                  ; flags run/direct(b7), load(b6), trace(b5), edit(b4) modes
   148                          ; autoboot wedge (b0)
   149                          point                                                     ; USING's pointer to decimal point, 2 bytes used by AutoScroll
   150  007f 00                 parsts           !fill 1                                  ; DOS parser status word
   151  0080 00                 parstx           !fill 1                                  ; DOS parser status extensions
   152                          
   153  0081 00                 oldstk           !fill 1                                  ; BASIC saves uP stack pointer here
   154                          
   155  0082 0000               text_top         !fill 2                                  ; top of BASIC text pointer  (in text_bank)
   156  0084 00                 text_bank        !fill 1                                  ; where BASIC text lives   (RAM0 default)
   157  0085 00                 var_bank         !fill 1                                  ; where BASIC vars live   (RAM1 default)
   158                          sys_bank         = 0                                      ; where system space is  ???? (RAM0, make this a var?)
   159                          
   160  0086 00                 sid_speed_flag   !fill 1                                  ; saves system speed during SID ops (used during IRQ)
   161                          
   162                          time                                                      ; temporaries for TI, TI$, SLEEP (4 bytes)
   163                          grapnt                                                    ; used by SPRSAV, RMOUSE, RCOLOR
   164                          op
   165  0087 00                 column           !fill 1                                  ; temporaries for FIND/CHANGE, [L]INPUT, [L]READ, CURSOR
   166                          srow
   167  0088 000000             fstr1            !fill 3                                  ;
   168  008b 000000             fstr2            !fill 3                                  ;
   169                          

; ******** Source: basic.asm

; ******** Source: system/stackdata.asm
     1                          
     2                                           * = $00ff
     3                          
     4  00ff 00                 lofbuf           !fill 1
     5  0100 0000000000000000...fbuffr           !fill 16                                 ; MathPack builds numbers here, USING, RENUMBER
     6                          
     7                          ;  Kernel MAP configurations & DMA lists
     8                          
     9  0110 0000000000000000...                 !fill 16+36                              ; (4 configs + 3 DMA lists)
    10                          
    11                          ;  BASIC DMA lists  (2 @ 12bytes each = 24 bytes)
    12                          
    13  0144 00                 dma1_cmd         !fill 1                                  ; This list is used by BASIC OS
    14  0145 00                 dma1_cnt_lo      !fill 1
    15  0146 00                 dma1_cnt_hi      !fill 1
    16  0147 00                 dma1_src_lo      !fill 1
    17  0148 00                 dma1_src_hi      !fill 1
    18  0149 00                 dma1_src_bank    !fill 1
    19  014a 00                 dma1_dest_lo     !fill 1
    20  014b 00                 dma1_dest_hi     !fill 1
    21  014c 00                 dma1_dest_bank   !fill 1
    22  014d 00                 dma1_subcmd      !fill 1                                  ; (from here on not supported until F018A) [910520] F018A
    23  014e 00                 dma1_mod_lo      !fill 1
    24  014f 00                 dma1_mod_hi      !fill 1
    25                          
    26  0150 00                 dma2_cmd         !fill 1                                  ; This list is used by DMA command & Graphics
    27  0151 00                 dma2_cnt_lo      !fill 1
    28  0152 00                 dma2_cnt_hi      !fill 1
    29  0153 00                 dma2_src_lo      !fill 1
    30  0154 00                 dma2_src_hi      !fill 1
    31  0155 00                 dma2_src_bank    !fill 1
    32  0156 00                 dma2_dest_lo     !fill 1
    33  0157 00                 dma2_dest_hi     !fill 1
    34  0158 00                 dma2_dest_bank   !fill 1
    35  0159 00                 dma2_subcmd      !fill 1                                  ; (from here on not supported until F018A) [910520] F018A
    36  015a 00                 dma2_mod_lo      !fill 1
    37  015b 00                 dma2_mod_hi      !fill 1
    38                          
    39  015c 00                                  !fill 1                                  ; Kernel's dma_byte
    40                          
    41                          sysstk                                                    ; bottom of system stack
    42                          stkend           = $1fb                                   ; top of system stack

; ******** Source: basic.asm

; ******** Source: data/memory.asm
     1                          
     2                          
     3                                           * = $0200
     4                          
     5                          buflen           = 161                                    ; input buffer size (2 80-column lines + 1)
     6  0200 0000000000000000...buf              !fill buflen                             ; BASIC/Monitor line input buffer
     7                          buf_txtptr       = buf-1
     8                          
     9                          
    10                                           * = $02c0
    11                          ; BASIC RAM code  (RAM code not needed- following moved to ROM)
    12                          ;
    13                          ; chrget *=*+42  ;get byte from text bank after incrementing TXTPTR
    14                          ; chrgot = chrget+2 ;get byte from text bank at TXTPTR
    15                          ; qnum  = chrget+27 ;evaluate byte as a number & set flags accordingly
    16                          
    17  02c0 0000               adray1           !fill 2                                  ; ptr to routine:  convert float -> integer ???? why keep
    18  02c2 0000               adray2           !fill 2                                  ; ptr to routine:  convert integer -> float ???? why keep
    19  02c4 000000             zero             !fill 3                                  ; numeric constant for BASIC, downloaded from ROM
    20                          
    21  02c7 00                 errnum           !fill 1                                  ; used by error trapping routine-last error number
    22  02c8 0000               errlin           !fill 2                                  ; line # of last error ($FFFF if no error)
    23  02ca 0000               trapno           !fill 2                                  ; line to go to on error ($FFxx if none set)
    24  02cc 00                 tmptrp           !fill 1                                  ; hold trap # temporary
    25  02cd 0000               errtxt           !fill 2                                  ; pointer to statement causing last error
    26  02cf 0000               max_mem_0        !fill 2                                  ; highest address available to BASIC in RAM 0 (text bank)
    27                          
    28  02d1 00                 current_bank     !fill 1                                  ; context for PEEK,POKE,BOOT,SYS,WAIT,BLOAD/SAVE set by BANK.
    29  02d2 00                 fin_bank         !fill 1                                  ; bank pointer for string->number conversion routine FIN
    30  02d3 00000000           tmpdes           !fill 4                                  ; pointers to temporary descriptors for INSTR
    31  02d7 00                 bits             !fill 1                                  ; flag for math bit/byte shifter
    32  02d8 00                 highlight_color  !fill 1                                  ; color for highlighting text
    33  02d9 00                 highlight_save   !fill 1                                  ; saves normal color during highlighting, msb=flag
    34  02da 00                 find_count       !fill 1                                  ; count for LIST to highlight FIND text
    35                          
    36                          ; Interrupt stuff
    37                          
    38  02db 00                 irq_wrap_flag    !fill 1                                  ; used by BASIC_IRQ to block all but one IRQ call
    39  02dc 00                 intval           !fill 1                                  ; BASIC interrupts enabled (via collision command)
    40  02dd 000000             int_trip_flag    !fill 3                                  ; flags which interrupts occurred
    41  02e0 000000             int_adr_lo       !fill 3                                  ; where to go for each type of collision (line number)
    42  02e3 000000             int_adr_hi       !fill 3                                  ;
    43  02e6 0000               collisions       !fill 2                                  ; sprite collisions, s/s and s/bgnd, recorded during IRQ
    44  02e8 00                 lightpen_xpos    !fill 1                                  ; lightpen position recorded during IRQ
    45  02e9 00                 lightpen_ypos    !fill 1
    46                          
    47                          ; dejavu *=*+1  ;'cold' or 'warm' reset status (must be in page 5!)????
    48                          
    49                          ; nmi_wrap_flag *=*+1  ;used by BASIC_NMI to block all but one NMI call [910523]
    50                          ;    ; (removed)      [910826]
    51                          ;(leaving 12 bytes)
    52                          
    53                          ; BASIC indirect vectors
    54                          
    55                                           * = $02f7
    56                          
    57  02f7 000000             usrpok           !fill 3                                  ; USR vector (must be set by application)
    58                          
    59                          vectors_begin
    60  02fa 0000               iAutoScroll      !fill 2                                  ; AutoScroll vector
    61  02fc 0000               esc_fn_vec       !fill 2                                  ; Escape Function vector
    62  02fe 0000               graphic_vector   !fill 2                                  ; Graphic Kernel vector (was 'bnkvec')
    63  0300 0000               ierror           !fill 2                                  ; indirect error (output error in .x)
    64  0302 0000               imain            !fill 2                                  ; indirect main (system direct loop)
    65  0304 0000               icrnch           !fill 2                                  ; indirect crunch (tokenization routine)
    66  0306 0000               iqplop           !fill 2                                  ; indirect list (char list)
    67  0308 0000               igone            !fill 2                                  ; indirect gone (char dispatch)
    68  030a 0000               ieval            !fill 2                                  ; indirect eval (symbol evaluation)
    69  030c 0000               iesclk           !fill 2                                  ; escape token crunch
    70  030e 0000               iescpr           !fill 2                                  ; escape token list
    71  0310 0000               iescex           !fill 2                                  ; escape token execute
    72  0312 0000               itime            !fill 2                                  ; 60Hz interrupt vector (before jiffy)
    73  0314 0000               cinv             !fill 2                                  ; IRQ RAM vector
    74  0316 0000               cbinv            !fill 2                                  ; BRK RAM vector
    75                          
    76                          ; Remainder of this area reserved for Kernel indirects & Kernel RAM code
    77                          
    78                          
    79                                           * = $0400                                ; BASIC's run-time stack (2 pages)
    80                          stktop                                                    ; (also used by BOOT SYS and Monitor)
    81                          stkbot           = $05ff
    82                          
    83                          
    84                                           * = $0600                                ; Sprite definitions (2 pages, must be below $1000)
    85                          sprite_base
    86                          
    87                          
    88                                           * = $0800
    89                          screen_start                                              ; Text display screen
    90                                           * = *+2000
    91                          
    92                          sprite_ptrs_40   = screen_start+$3f8
    93                          sprite_ptrs_80   = screen_start+$7f8
    94                          
    95                          
    96                                           * = $1170                                ; previous to this used by Kernel
    97                          
    98  1170 0000               oldlin           !fill 2                                  ; BASIC storage
    99  1172 0000               oldtxt           !fill 2                                  ; BASIC storage
   100  1174 0000000000         rndx             !fill 5                                  ; Floating Point representation of last random #
   101                          
   102                          
   103                          ; Yet more temporaries shared by various routines
   104                          
   105                          window_temp                                               ; window  (4 bytes)
   106                          t3                                                        ; dcat  (1 byte)
   107                          renum_tmp_1                                               ; renumber (2 bytes)
   108  1179 0000               tmptxt           !fill 2                                  ; do/loop (2 bytes)
   109                          
   110                          t4                                                        ; dcat  (2 bytes)
   111                          renum_tmp_2                                               ; renumber (2 bytes)
   112  117b 0000               tmplin           !fill 2                                  ; do/loop (2 bytes)
   113                          
   114                          
   115                          ;  BASIC/DOS interface vars  (20 bytes)
   116                          
   117  117d 0000               dosofl           !fill 2                                  ; BLOAD/BSAVE starting addr
   118  117f 0000               dosofh           !fill 2                                  ; BSAVE ending addr
   119  1181 00                 dosla            !fill 1                                  ; DOS logical addr
   120  1182 00                 dosfa            !fill 1                                  ; DOS physical addr
   121  1183 00                 dossa            !fill 1                                  ; DOS secondary addr
   122                          
   123  1184 00                 xcnt             !fill 1                                  ; DOS loop counter------ this area zeroed-out each DOS call -----
   124  1185 00                 dosf1l           !fill 1                                  ; DOS filename 1 len
   125  1186 00                 dosds1           !fill 1                                  ; DOS disk drive 1
   126  1187 00                 dosf2l           !fill 1                                  ; DOS filename 2 len
   127  1188 00                 dosds2           !fill 1                                  ; DOS disk drive 2
   128  1189 0000               dosf2a           !fill 2                                  ; DOS filename 2 addr
   129  118b 00                 dosrcl           !fill 1                                  ; DOS record length
   130  118c 00                 dosbnk           !fill 1                                  ; DOS load/save bank
   131  118d 0000               dosdid           !fill 2                                  ; DOS ID identifier
   132  118f 00                 dosflags         !fill 1                                  ; DOS flags  7:ID,  6:recover
   133  1190 00                 dossa_temp       !fill 1                                  ; temp storage for file's sa during RECORD command
   134                          dosspc           = *-xcnt                                 ; space used by DOS routines-------------------------------------
   135                          
   136  1191 0000000000000000...savram           !fill 67                                 ; buffer used by MOVSPR, SPRDEF, SAVSPR, and DOS parser
   137                          
   138                          xabs             = savram                                 ; movspr_line calculations   [910809]
   139                          yabs             = savram+2
   140                          xsgn             = savram+4
   141                          ysgn             = savram+6
   142                          fct              = savram+8
   143                          errval           = savram+12
   144                          
   145                          
   146                          ; PRINT USING definitions & storage  (24 bytes)
   147                          
   148                          puchrs                                                    ; Declarations for PRINT USING...
   149  11d4 00                 pufill           !fill 1                                  ; print using fill symbol
   150  11d5 00                 pucoma           !fill 1                                  ; print using comma symbol
   151  11d6 00                 pudot            !fill 1                                  ; print using decimal point symbol
   152  11d7 00                 pumony           !fill 1                                  ; print using monetary symbol
   153                          
   154  11d8 00                 bnr              !fill 1                                  ; pointer to begin #
   155  11d9 00                 enr              !fill 1                                  ; pointer to end #
   156  11da 00                 dolr             !fill 1                                  ; dollar flag
   157  11db 00                 flag             !fill 1                                  ; comma flag (also used by PLAY)????
   158  11dc 00                 swe              !fill 1                                  ; counter
   159  11dd 00                 usgn             !fill 1                                  ; sign exponent
   160  11de 00                 uexp             !fill 1                                  ; pointer to exponent
   161  11df 00                 vn               !fill 1                                  ; # of digits before decimal point
   162  11e0 00                 chsn             !fill 1                                  ; justify flag
   163  11e1 00                 vf               !fill 1                                  ; # of positions before decimal point (field)
   164  11e2 00                 nf               !fill 1                                  ; # of positions after decimal point (field)
   165  11e3 00                 posp             !fill 1                                  ; +/- flag (field)
   166  11e4 00                 fesp             !fill 1                                  ; exponent flag (field)
   167  11e5 00                 etof             !fill 1                                  ; switch
   168  11e6 00                 cform            !fill 1                                  ; char counter (field)
   169  11e7 00                 sno              !fill 1                                  ; sign no
   170  11e8 00                 blfd             !fill 1                                  ; blank/star flag
   171  11e9 00                 begfd            !fill 1                                  ; pointer to begin of field
   172  11ea 00                 lfor             !fill 1                                  ; length of format
   173  11eb 00                 endfd            !fill 1                                  ; pointer to end of field
   174                          
   175                          
   176                          ;  * = $1200 ;BASIC Graphic, Sprite, Music, & Sound storage
   177                          
   178                          ;  The following 24 bytes are multiply defined...
   179                          ;
   180                          ; params = *
   181                          
   182                          ;  Circle drawing variables  (multiply defined).
   183                          ;
   184                          ; xcircl *=*+2  ;circle center, x coordinate
   185                          ; ycircl *=*+2  ;circle center, y coordinate
   186                          ; xradus *=*+2  ;x radius
   187                          ; yradus *=*+2  ;y radius
   188                          ; rotang *=*+4  ;rotation angle
   189                          ; angbeg *=*+2  ;arc angle start
   190                          ; angend *=*+2  ;arc angle end
   191                          ; xrcos  *=*+2  ;x radius * cos(rotation angle)
   192                          ; yrsin  *=*+2  ;y radius * sin(rotation angle)
   193                          ; xrsin  *=*+2  ;x radius * sin(rotation angle)
   194                          ; yrcos  *=*+2  ;y radius * cos(rotation angle)
   195                          
   196                          ; parend = *
   197                          
   198                          ;  Box drawing variables  (multiply defined).
   199                          ;
   200                          ;  *=params
   201                          ; xcord1 *=*+2  ;point 1 x-coord.
   202                          ; ycord1 *=*+2  ;point 1 y-coord.
   203                          ; boxang *=*+2  ;rotation angle
   204                          ; xcount *=*+2
   205                          ; ycount *=*+2
   206                          ; bxleng *=*+2  ;length of a side
   207                          ; xcord2 *=*+2
   208                          ; ycord2 *=*+2
   209                          
   210                          
   211                          ;  Shape variables  (multiply defined).
   212                          ;
   213                          ;  *=params
   214                          ;  *=*+1  ;placeholder
   215                          ; keylen *=*+1
   216                          ; keynxt *=*+1
   217                          ; strsz  *=*+1  ;string len
   218                          ; gettyp *=*+1  ;replace shape mode
   219                          ; strptr *=*+1  ;string pos'n counter
   220                          ; oldbyt *=*+1  ;old bit map byte
   221                          ; newbyt *=*+1  ;new string or bit map byte
   222                          ;  *=*+1  ;placeholder
   223                          ; xsize  *=*+2  ;shape column length
   224                          ; ysize  *=*+2  ;shape row length
   225                          ; xsave  *=*+2  ;temp for column length
   226                          ; stradr *=*+2  ;save shape string descriptor
   227                          ; bitidx *=*+1  ;bit index into byte
   228                          
   229                          ;  General use parameters  (multiply defined).
   230                          ;
   231                          ;  *=params
   232                          ; xcentr *=*+2
   233                          ; ycentr *=*+2
   234                          ; xdist1 *=*+2
   235                          ; ydist1 *=*+2
   236                          ; xdist2 *=*+2
   237                          ; ydist2 *=*+2
   238                          ; disend
   239                          ;  *=*+2  ;placeholder
   240                          ; colcnt *=*+1  ;char's col. counter
   241                          ; rowcnt *=*+1
   242                          ; strcnt *=*+1
   243                          
   244                          
   245                          ;  General  graphic & sound  buffers & assignments
   246                          ;
   247                          ;  * = parend
   248                          
   249                          ;  General graphic storage (used by C128-type sprite routines in C65)
   250                          
   251                          vwork                                                     ; graphics & sprite vars
   252  11ec 0000               xpos             !fill 2                                  ; current x position
   253  11ee 0000               ypos             !fill 2                                  ; current y position
   254  11f0 0000               xdest            !fill 2                                  ; x-coordinate destination
   255  11f2 0000               ydest            !fill 2                                  ; y-coordinate destination
   256                          
   257  11f4 00                 numcnt           !fill 1                                  ; temp, usually coordinate type
   258  11f5 00                 vtemp1           !fill 1                                  ; used by sprite math stuff ????was base page
   259  11f6 00                 vtemp2           !fill 1                                  ; ????was base page
   260  11f7 00                 vtemp3           !fill 1                                  ; misc. graphic temp storage
   261  11f8 00                 vtemp4           !fill 1
   262  11f9 00                 vtemp5           !fill 1
   263                          
   264                          ; mvdflg *=*+1  ;flag if 10k hires allocated ???? this stuff was base page
   265                          ; colsel *=*+1  ;current color selected
   266                          ; multicolor_1 *=*+1
   267                          ; multicolor_2 *=*+1
   268                          ; foreground *=*+1
   269                          ; scalem *=*+1  ;scale mode flag
   270                          ; scale_x *=*+2  ;scale factor in x
   271                          ; scale_y *=*+2  ;scale factor in y
   272                          ; stopnb *=*+1  ;stop paint if not background/not same color
   273                          ; fg_bg  *=*+1  ;packed foreground/background color nybbles
   274                          ; fg_mc1 *=*+1  ;packed foreground/multicolor 1 color nybbles
   275                          
   276                          ; bitcnt *=*+1  ;temp for gshape
   277                          ; width  *=*+1  ;double width flag
   278                          ; filflg *=*+1  ;box fill flag
   279                          ; circle_segment *=*+1  ;degrees per circle segment
   280                          ; bitmsk *=*+1  ;temp for bit mask
   281                          
   282                          ; character_rom *=*+1  ;high byte of address of char rom for 'char' command
   283                          ; upper_lower *=*+1  ;pointer to upper/lower case for char command
   284                          ; upper_graphic *=*+1  ;   "       upper/graphic
   285                          
   286                          ;  DrawLine stuff
   287                          ;
   288                          ; xabs  *=*+2  ;16 bytes
   289                          ; yabs  *=*+2
   290                          ; xsgn  *=*+2
   291                          ; ysgn  *=*+2
   292                          ; fct  *=*+4
   293                          ; errval *=*+2
   294                          ; lesser *=*+1
   295                          ; greatr *=*+1
   296                          
   297                          ;  Angle stuff (used by sprites)
   298                          
   299  11fa 00                 angsgn           !fill 1                                  ; sign of angle
   300  11fb 0000               sinval           !fill 2                                  ; sine of value of angle
   301  11fd 0000               cosval           !fill 2                                  ; cosine of value of angle
   302                          ; angcnt *=*+2  ;temps for angle distance routines
   303                          
   304                          
   305                          ; Sprite stuff
   306                          
   307  11ff 00000000           savsiz           !fill 4                                  ; temp work locations for SSHAPE, SPRSAV, MOVSPR_TO
   308                          lesser
   309  1203 00                 sprtmp_1         !fill 1                                  ; temp for SPRSAV
   310                          greatr
   311  1204 00                 sprtmp_2         !fill 1
   312                          
   313  1205 0000000000000000...sprite_data      !fill 88                                 ; speed/direction tables for 8 sprites, 11 bytes each
   314                          ;   move ang/dist move line
   315                          ; offset= 0 b7=0+speed b7=1+speed
   316                          ;  1 counter  counter lo
   317                          ;  2 angle sign         hi
   318                          ;  3,4 delta-X  dir+min/max
   319                          ;  5,6 delta-Y  fct1
   320                          ;  7,8 total-X  fct2
   321                          ;  9,10 total-Y  error
   322                          
   323                          init_as_0        = *-sprite_data-1
   324                          
   325                          ; vic_save *=*+21  ;copy of VIC reg's, used to update chip during retrace
   326                          
   327                          ; defmod *=*+1  ;for SPRDEF
   328                          ; lincnt *=*+1  ; "
   329                          ; sprite_number *=*+1  ; "
   330                          
   331                          
   332                          ; Music stuff driving stereo SIDs, 3 voices each
   333                          
   334  125d 0000000000000000...voices           !fill 12                                 ; Voice counters (activity flags)  [910612] stereo
   335  1269 000000000000       waveform         !fill 6                                  ; Waveforms for each voice   [910612] stereo
   336                          
   337  126f 00                 voice            !fill 1                                  ; Play note parameters
   338  1270 00                 octave           !fill 1
   339  1271 00                 sharp            !fill 1
   340  1272 00                 dnote            !fill 1
   341  1273 00                 tempo_rate       !fill 1                                  ; duration of whole note 4/4 time = 24/rate
   342  1274 0000               pitch            !fill 2
   343  1276 0000               ntime            !fill 2
   344                          
   345  1278 00000000           filters1         !fill 4                                  ; Volume & Filter parameters   [910612] was 5
   346  127c 00000000           filters2         !fill 4                                  ; [910612] stereo
   347  1280 00000000           fltsav           !fill 4                                  ; temps
   348  1284 00                 fltflg           !fill 1                                  ; temp
   349                          
   350  1285 00                 tonnum           !fill 1                                  ; Tune Envelope stuff
   351  1286 000000             tonval           !fill 3
   352                          
   353  1289 0000000000000000...atktab           !fill 10                                 ; Tune Envelopes
   354  1293 0000000000000000...sustab           !fill 10
   355  129d 0000000000000000...wavtab           !fill 10
   356  12a7 0000000000000000...pulslw           !fill 10
   357  12b1 0000000000000000...pulshi           !fill 10
   358                          
   359  12bb 00                 parcnt           !fill 1                                  ; temp: envelope
   360  12bc 00                 nibble           !fill 1                                  ; temp: envelope, filter
   361                          
   362                          
   363                          ; SOUND command stuff
   364                          
   365  12bd 00                 sound_voice      !fill 1
   366  12be 000000000000       sound_time_lo    !fill 3+3                                ; [910612] stereo
   367  12c4 000000000000       sound_time_hi    !fill 3+3                                ; [910612] stereo
   368  12ca 000000000000       sound_max_lo     !fill 3+3                                ; [910612] stereo
   369  12d0 000000000000       sound_max_hi     !fill 3+3                                ; [910612] stereo
   370  12d6 000000000000       sound_min_lo     !fill 3+3                                ; [910612] stereo
   371  12dc 000000000000       sound_min_hi     !fill 3+3                                ; [910612] stereo
   372  12e2 000000000000       sound_direction  !fill 3+3                                ; [910612] stereo
   373  12e8 000000000000       sound_step_lo    !fill 3+3                                ; [910612] stereo
   374  12ee 000000000000       sound_step_hi    !fill 3+3                                ; [910612] stereo
   375  12f4 000000000000       sound_freq_lo    !fill 3+3                                ; [910612] stereo
   376  12fa 000000000000       sound_freq_hi    !fill 3+3                                ; [910612] stereo
   377                          
   378                          ;above must end before $1300
   379                                           * = $1160
   380                          ;below must end before $1170
   381                          
   382  1160 00                 temp_time_lo     !fill 1
   383  1161 00                 temp_time_hi     !fill 1
   384  1162 00                 temp_max_lo      !fill 1
   385  1163 00                 temp_max_hi      !fill 1
   386  1164 00                 temp_min_lo      !fill 1
   387  1165 00                 temp_min_hi      !fill 1
   388  1166 00                 temp_direction   !fill 1
   389  1167 00                 temp_step_lo     !fill 1
   390  1168 00                 temp_step_hi     !fill 1
   391  1169 00                 temp_freq_lo     !fill 1
   392  116a 00                 temp_freq_hi     !fill 1
   393  116b 00                 temp_pulse_lo    !fill 1
   394  116c 00                 temp_pulse_hi    !fill 1
   395  116d 00                 temp_waveform    !fill 1
   396                          
   397  116e 00                 pot_temp_1       !fill 1                                  ; temporaries for 'POT' function
   398  116f 00                 pot_temp_2       !fill 1
   399                          
   400                          
   401                                           * = $1300
   402                          
   403  1300 0000000000000000...dosstr           !fill 256                                ; DOS input/output string buffer
   404                          
   405                          
   406                                           * = $1f00                                ; Graphics Kernel Interface
   407                          
   408  1f00 00                 GKI__parm1       !fill 1                                  ; ml interface parm values
   409  1f01 00                 GKI__parm2       !fill 1
   410  1f02 00                 GKI__parm3       !fill 1
   411  1f03 00                 GKI__parm4       !fill 1
   412  1f04 00                 GKI__parm5       !fill 1
   413  1f05 00                 GKI__parm6       !fill 1
   414  1f06 00                 GKI__parm7       !fill 1
   415  1f07 00                 GKI__parm8       !fill 1
   416  1f08 00                 GKI__parm9       !fill 1
   417  1f09 00                 GKI__parm10      !fill 1
   418  1f0a 00                 GKI__parm11      !fill 1
   419  1f0b 00                 GKI__parm12      !fill 1
   420  1f0c 00                 GKI__parm13      !fill 1
   421  1f0d 00                 GKI__parm14      !fill 1
   422  1f0e 00                 GKI__parm15      !fill 1
   423  1f0f 00                 GKI__parm16      !fill 1
   424  1f10 00                 GKI__parm17      !fill 1
   425                          
   426  1f11 00                 GKI__subparm1    !fill 1                                  ; subroutine parm values
   427  1f12 00                 GKI__subparm2    !fill 1
   428  1f13 00                 GKI__subparm3    !fill 1
   429  1f14 00                 GKI__subparm4    !fill 1
   430  1f15 00                 GKI__subparm5    !fill 1
   431                          
   432  1f16 00                 GKI__temp1       !fill 1                                  ; local variables within subroutines
   433  1f17 00                 GKI__temp2       !fill 1
   434  1f18 00                 GKI__temp3       !fill 1
   435  1f19 00                 GKI__temp4       !fill 1
   436  1f1a 00                 GKI__temp5       !fill 1
   437  1f1b 00                 GKI__temp6       !fill 1
   438  1f1c 00                 GKI__temp7       !fill 1
   439  1f1d 00                 GKI__temp8       !fill 1
   440  1f1e 00                 GKI__temp9       !fill 1
   441  1f1f 00                 GKI__temp10      !fill 1
   442  1f20 00                 GKI__temp11      !fill 1
   443  1f21 00                 GKI__temp12      !fill 1
   444  1f22 00                 GKI__temp13      !fill 1
   445  1f23 00                 GKI__temp14      !fill 1
   446  1f24 00                 GKI__temp15      !fill 1
   447  1f25 00                 GKI__temp16      !fill 1
   448  1f26 00                 GKI__temp17      !fill 1
   449                          
   450                          ;.end
   451                          

; ******** Source: basic.asm

; ******** Source: data/kernal.asm
     1                          ; Addresses of OS parameters referenced by BASIC:
     2                          
     3                          _6510_data_reg   = $01
     4                          _bank            = $02                                    ; reg's for Kernel xxx_FAR routines (used by SYS)
     5                          _pchi            = $03
     6                          _pclo            = $04
     7                          _s_reg           = $05
     8                          _a_reg           = $06
     9                          _x_reg           = $07
    10                          _y_reg           = $08
    11                          _z_reg           = $09
    12                          
    13                          _vicIRQ          = $a0                                    ; VIC IRQ flag register at time of IRQ
    14                          _starting_addr   = $ac                                    ; address BLOAD loaded to
    15                          _sa              = $b9                                    ; I/O channel secondary address
    16                          _fa              = $ba                                    ; I/O channel device number
    17                          _ndx             = $d0                                    ; number of characters in keyboard buffer
    18                          _kyndx           = $d1                                    ; fkey active flag
    19                          _mode            = $d7                                    ; 40/80 mode
    20                          _graphm          = $d8                                    ; graphic mode switch (multi/hires/split)
    21                          _pnt             = $e0                                    ; Editor screen address at cursor
    22                          
    23                          _screen_bottom   = $e4                                    ; these describe the current window
    24                          _screen_top      = $e5
    25                          _screen_left     = $e6
    26                          _screen_right    = $e7
    27                          
    28                          _color           = $f1                                    ; text color      [910722]
    29                          _autoinsert      = $f6                                    ; enable/disable auto insert mode
    30                          _locks           = $f7                                    ; Editor keyboard locks     [910722]
    31                          
    32                          _keyd            = $02b0                                  ; keyboard buffer     [910710]
    33                          ;_split = $0a34  ;line to start split at
    34                          
    35                          number_fkeys     = 16                                     ; max of 14 prog. fn. keys
    36                          _pky_lengths     = $1000                                  ; table of prog. fn. key sizes
    37                          _pky_buffer      = _pky_lengths+number_fkeys              ; actual buffer
    38                          
    39                          _restart_vector  = $1100                                  ; Kernel restart vector
    40                          _pal_ntsc        = $1103                                  ; PAL=$ff, NTSC=$00 indicator    [910107]
    41                          _init_status     = $1104                                  ; msb set tells Kernel to let BASIC have IRQs
    42                          _default_drive   = $1106                                  ; system default disk drive
    43                          _expansion       = $1107                                  ; expansion RAM (# banks????)    [910107]
    44                          _sleep_counter   = $110c                                  ; binary frame counter maintained by Kernel  [910730]
    45                          _mouse_enable    = $1135                                  ; port# used by mouse (b7=port2, b6=port1, or both) [910107]
    46                          _mouse_pointer   = $1136                                  ; sprite pointer (sprite*2) by Kernel mouse driver "
    47                          _mouse_top       = $113b                                  ; margins for mouse pointer    "
    48                          _mouse_bottom    = $113c                                  ; "
    49                          _mouse_left      = $113d                                  ; "
    50                          _mouse_right     = $113e                                  ; "
    51                          
    52                          ; Addresses of I/O areas referenced by BASIC:
    53                          
    54                          _red             = $d100                                  ; VIC palette (I/O block)
    55                          _green           = $d200
    56                          _blue            = $d300
    57                          
    58                          ; Addresses of Kernel entry points referenced by BASIC:
    59                          
    60                          _print           = $e00c
    61                          _mouse           = $e01b                                  ; [910122]
    62                          _set_window      = $e02d
    63                          _palette_init    = $e027
    64                          _cursor          = $e030                                  ; [910228]
    65                          ;_ldtb2 = $e033
    66                          ;_ldtb1 = $e04c
    67                          
    68                          _close_all       = $ff50                                  ; close all channels assigned to device .a
    69                          _go_64           = $ff53                                  ; C64 mode
    70                          _monitor         = $ff56                                  ; ML Monitor
    71                          _bootsys         = $ff59                                  ; Boot alternate OS     [910110]
    72                          _phoenix         = $ff5c                                  ; jump to 'post-BASIC initialize' routine
    73                          _lkupla          = $ff5f                                  ; find an available Logical Address
    74                          _lkupsa          = $ff62                                  ; find an available Secondary Address
    75                          _swapper         = $ff65                                  ; switch 80/40 column
    76                          _doakey          = $ff68                                  ; add/remove a definition from the p.f. key table
    77                          _setbank         = $ff6b                                  ; set bank for load/save/verify/open
    78                          _jsr_far         = $ff6e                                  ; call a subroutine in any bank
    79                          _jmp_far         = $ff71                                  ; jump to code in any bank
    80                          _lda_far         = $ff74                                  ; write a byte to any bank
    81                          _sta_far         = $ff77                                  ; read a byte from any bank
    82                          _cmp_far         = $ff7a                                  ; compare a byte to any bank
    83                          _primm           = $ff7d                                  ; print immediate
    84                          
    85                          _setmsg          = $ff90
    86                          _readst          = $ffb7
    87                          _setlfs          = $ffba
    88                          _setnam          = $ffbd
    89                          _open            = $ffc0
    90                          _close           = $ffc3
    91                          _chkin           = $ffc6
    92                          _chkout          = $ffc9
    93                          _clrch           = $ffcc
    94                          _basin           = $ffcf
    95                          _bsout           = $ffd2
    96                          _loadsp          = $ffd5
    97                          _savesp          = $ffd8
    98                          _SetTime         = $ffdb
    99                          _ReadTime        = $ffde
   100                          _stop            = $ffe1
   101                          _getin           = $ffe4
   102                          _clall           = $ffe7
   103                          _screen_org      = $ffed
   104                          _plot            = $fff0
   105                          
   106                          ;.end
   107                          
   108                          

; ******** Source: basic.asm

; ******** Source: initialise/initialise.asm
     1                          ; ***************************************************************************************************************
     2                          ; ***************************************************************************************************************
     3                          ;
     4                          ;      Name:       patch.asm
     5                          ;      Purpose:    Fixes
     6                          ;      Created:    4th January 2020
     7                          ;      Author:     Paul Robson (paul@robsons.org.uk)
     8                          ;
     9                          ; ***************************************************************************************************************
    10                          ; ***************************************************************************************************************
    11                          
    12                          ; ***************************************************************************************************************
    13                          ;
    14                          ;				At present ACME does not support BRA opcode $83. BRL replaces this.
    15                          ;
    16                          ; ***************************************************************************************************************
    17                          
    18                          !macro lbra addr {
    19                          	!byte $83
    20                          	!word (addr-*-1) & $FFFF
    21                          }
    22                          
    23                          !macro lbcc addr {
    24                          	!byte $93
    25                          	!word (addr-*-1) & $FFFF
    26                          }
    27                          
    28                          !macro lbcs addr {
    29                          	!byte $B3
    30                          	!word (addr-*-1) & $FFFF
    31                          }
    32                          
    33                          !macro lbne addr {
    34                          	!byte $D3
    35                          	!word (addr-*-1) & $FFFF
    36                          }
    37                          
    38                          !macro lbeq addr {
    39                          	!byte $F3
    40                          	!word (addr-*-1) & $FFFF
    41                          }
    42                          
    43                          !macro lbpl addr {
    44                          	!byte $13
    45                          	!word (addr-*-1) & $FFFF
    46                          }
    47                          
    48                          !macro lbmi addr {
    49                          	!byte $33
    50                          	!word (addr-*-1) & $FFFF
    51                          }
    52                          
    53                          !macro lbvs addr {
    54                          	!byte $73
    55                          	!word (addr-*-1) & $FFFF
    56                          }
    57                          
    58                          !macro lbvc addr {
    59                          	!byte $53
    60                          	!word (addr-*-1) & $FFFF
    61                          }
    62                                           * = $2000
    63                          
    64                          basic
    65  2000 4c2520                              jmp hard_reset
    66  2003 4c0c20                              jmp soft_reset
    67  2006 4c7579                              jmp basic_irq
    68  2009 4c06bf                              jmp basic_nmi                            ; (removed)    [910523] audio
    69                          
    70                          soft_reset                                                ; warm start BASIC...
    71  200c 20b438                              jsr release_channels                     ; restore default terminal I/O channels
    72  200f a900                                lda #doslfn                              ; restore reserved disk channel
    73  2011 38                                  sec                                      ; not a real close
    74  2012 20c3ff                              jsr _close
    75  2015 208278                              jsr Clear_DS                             ; zap DS$ just in case
    76                          ; (might have been in Monitor or building DS$)
    77  2018 200d21                              jsr init_sound_sprites                   ; init interrupt & dma stuff   [910523]
    78  201b 200935                              jsr init_stack                           ; restore stack
    79  201e a901                                lda #1
    80  2020 0c0411                              tsb _init_status                         ; tell Kernel to give BASIC a call at IRQ time
    81  2023 802e                                bra go_ready                             ; enable IRQ, print READY, and go MAIN
    82                          
    83                          
    84                          hard_reset
    85  2025 205f22                              jsr init_vectors                         ; init vectors
    86  2028 205720                              jsr init_storage                         ; init variables, voices,  & download RAM code
    87  202b 203321                              jsr signon_message                       ; print initialization message
    88                          
    89  202e a900                                lda #0                                   ; init bank pointers   [900509]
    90  2030 8584                                sta text_bank
    91  2032 8555                                sta helper                               ; reset all LIST flags
    92  2034 a901                                lda #1
    93  2036 8585                                sta var_bank
    94  2038 a902                                lda #2
    95  203a 8dd802                              sta highlight_color                      ; set highlight color (2=red)
    96  203d a203                                ldx #<basic+3
    97  203f 8e0011                              stx _restart_vector                      ; point system restart vector at warm start entry
    98  2042 200935                              jsr init_stack                           ; initialize system stack pointer
    99  2045 a901                                lda #1
   100  2047 0c0411                              tsb _init_status                         ; tell Kernel to give BASIC a call at IRQ time
   101  204a 220080                              jsr ($8000)                              ; initialize graphics
   102  204d 205cff                              jsr _phoenix                             ; call cartridges, check out expansion card
   103  2050 20a467                              jsr autobootCSG                          ; attempt to boot program from disk
   104                          
   105                          go_ready
   106  2053 58                                  cli                                      ; enable IRQ
   107  2054 83f70d                              +lbra ready
   108                          
   109                          
   110                          init_storage
   111  2057 a94c                                lda #76                                  ; 'jmp' opcode
   112  2059 8556                                sta jmper
   113  205b 8df702                              sta usrpok
   114                          
   115  205e a9e8                                lda #<errguf                             ; init USR vector to 'undef'd function'  [910226] FAB
   116  2060 a058                                ldy #>errguf
   117  2062 8df802                              sta usrpok+1
   118  2065 8cf902                              sty usrpok+2
   119                          
   120  2068 a99f                                lda #<flpint                             ; ???? why keep
   121  206a a058                                ldy #>flpint
   122  206c 8dc002                              sta adray1
   123  206f 8cc102                              sty adray1+1
   124                          
   125  2072 a93f                                lda #<givayf                             ; ???? why keep
   126  2074 a04e                                ldy #>givayf
   127  2076 8dc202                              sta adray2
   128  2079 8cc302                              sty adray2+1
   129                          
   130                          ; Download CHRGET (and INDSUB code????) to RAM
   131                          ;
   132                          ; ldx #endmov-chrget_pattern
   133                          ;1$ lda chrget_pattern-1,x
   134                          ; sta chrget-1,x
   135                          ; dex
   136                          ; bne 1$
   137                          
   138  207c a200                                ldx #0
   139  207e 8ec402                              stx zero                                 ; zero constant
   140  2081 8ec502                              stx zero+1
   141  2084 8ec602                              stx zero+2
   142  2087 8ed702                              stx bits                                 ; reset bit/byte shifter
   143  208a 8615                                stx channl                               ; default channels
   144  208c 867e                                stx runmod                               ; direct mode
   145  208e 861a                                stx lastpt+1
   146  2090 8674                                stx autinc                               ; turn off auto increment
   147  2092 8675                                stx autinc+1
   148  2094 8e7411                              stx rndx                                 ; zero-ing MSB will guarantee a legal value
   149                          ; stx dosfa  ;zero device number     [910429]
   150                          
   151  2097 8edc02                              stx intval                               ; reset all BASIC IRQ stuff
   152  209a 8edd02                              stx int_trip_flag                        ; (BASIC IRQ enabled in init_voices)
   153  209d 8ede02                              stx int_trip_flag+1
   154  20a0 8edf02                              stx int_trip_flag+2
   155  20a3 8ee802                              stx lightpen_xpos
   156  20a6 8ee902                              stx lightpen_ypos
   157                          
   158                          ; stx mvdflg  ;flag '8k graphics screen not allocated'
   159                          ; stx width  ;init to single-width lines
   160                          ; stx scalem  ;turn off scaleing
   161                          ; stx filflg
   162                          
   163                          ; inx   ;.x=1 ???? why init stack with $0101 ????
   164                          ; stx buf-3
   165                          ; stx buf-4
   166                          
   167                          ; ldy #88   ;zero out sprite information area
   168                          ;2$ sta sprite_data,y ;???? this is done later at init_as_0
   169                          ; dey
   170                          ; bpl 2$
   171                          
   172                          ; ldx #13
   173                          ; stx foreground  ;init bit map's fg color to light green
   174                          ; ldx #1
   175                          ; stx multicolor_1 ;init mc1 to white
   176                          ; ldx #2
   177                          ; stx multicolor_2 ;init mc2 to red
   178                          ; jsr set_packed_color ;set up packed fg/bg and fg/mc1 bytes
   179                          
   180  20a9 ae0611                              ldx _default_drive
   181  20ac 8e8211                              stx dosfa                                ; init device number to system default   [910429]
   182                          
   183  20af a280                                ldx #$80                                 ; bank 0 with I/O????
   184  20b1 8ed102                              stx current_bank                         ; set default bank for PEEK,POKE,BOOT,SYS,WAIT,BLOAD/SAVE
   185                          
   186  20b4 a21b                                ldx #tempst
   187  20b6 8618                                stx temppt                               ; init temp descriptor pointer
   188                          
   189  20b8 a201                                ldx #<baswrk                             ; set up bottom of bank 0 (text area)
   190  20ba a020                                ldy #>baswrk
   191  20bc 862d                                stx txttab
   192  20be 842e                                sty txttab+1
   193                          
   194  20c0 a900                                lda #<varbgn                             ; set up bottom of bank 1 (storage area)
   195  20c2 a020                                ldy #>varbgn
   196  20c4 852f                                sta vartab
   197  20c6 8430                                sty vartab+1
   198                          
   199  20c8 a900                                lda #<bank_0_top                         ; set up top of bank 0
   200  20ca a080                                ldy #>bank_0_top
   201  20cc 8dcf02                              sta max_mem_0
   202  20cf 8cd002                              sty max_mem_0+1
   203                          
   204  20d2 a900                                lda #<bank_1_top                         ; set up  top of bank 1
   205  20d4 a080                                ldy #>bank_1_top
   206  20d6 8539                                sta max_mem_1
   207  20d8 843a                                sty max_mem_1+1
   208                          
   209  20da a900                                lda #0                                   ; init text input buffer  (these are for autoboot)
   210  20dc 8d0002                              sta buf
   211  20df 3a                                  dec
   212  20e0 853c                                sta curlin+1                             ; init line pointer
   213  20e2 a2ff                                ldx #<buf_txtptr                         ; init txtptr
   214  20e4 a001                                ldy #>buf_txtptr
   215  20e6 863d                                stx txtptr
   216  20e8 843e                                sty txtptr+1
   217                          
   218                          ; Set up sprite pointers
   219                          
   220  20ea a91f                                lda #sprite_base/64+7
   221  20ec a007                                ldy #7
   222  20ee 7fd705             l1_1             bbr7 _mode,l1_2
   223  20f1 99f80b                              sta sprite_ptrs_40,y                     ; 40 col screen
   224  20f4 8003                                bra l1_3
   225  20f6 99f80f             l1_2             sta sprite_ptrs_80,y                     ; 80 col screen
   226  20f9 3a                 l1_3             dec
   227  20fa 88                                  dey
   228  20fb 10f1                                bpl l1_1
   229                          
   230                          ; Zero out sprite movement stuff and some VIC stuff too
   231                          
   232  20fd a900                                lda #0
   233  20ff a257                                ldx #init_as_0
   234  2101 9d0512             l1_4             sta sprite_data,x
   235  2104 ca                                  dex
   236  2105 10fa                                bpl l1_4
   237                          
   238  2107 200d21                              jsr init_sound_sprites                   ; init misc. interrupt & dma stuff
   239                          
   240                          ; lda #$d0  ;initialize pointers to character ROM
   241                          ; sta upper_graphic
   242                          ; lda #$d8
   243                          ; sta upper_lower
   244                          
   245  210a 836c13                              +lbra init_text                          ; go to 'new'
   246                          
   247                          
   248                          init_sound_sprites                                          ; [910523]
   249                          ;; init_voices   ;Initialize music stuff
   250                          ; bit _pal_ntsc  ;determine if PAL or NTSC system  [910724]
   251                          ; bmi 1$   ;...branch if PAL
   252                          ; lda #<beats_ntsc/4 ;set beat to quarter note (4/4 time = .5 sec)
   253                          ; ldy #>beats_ntsc/4
   254                          ; bra 2$
   255                          ;1$ lda #<beats_pal/4
   256                          ; ldy #>beats_pal/4
   257                          ;2$ sta ntime
   258                          ; sty ntime+1
   259                          ;
   260                          ; lda #4   ;set default octave
   261                          ; sta octave
   262                          ;
   263                          ; lda #12   ;set default tempo    [910220]
   264                          ; sta tempo_rate  ; 12 makes whole note in 4/4 time last 2 seconds
   265                          ;----
   266                          ;; jsr go_slow  ;      [910716] 4567R7A
   267                          ; lda #0   ;make sure all gates are off
   268                          ; sta sid1+4
   269                          ; sta sid1+11
   270                          ; sta sid1+18
   271                          ; sta sid2+4
   272                          ; sta sid2+11
   273                          ; sta sid2+18
   274                          ; sta filters1+2  ;set filters off, volume to max????  [910612]
   275                          ; sta filters2+2
   276                          ;
   277                          ; lda #8
   278                          ; sta sid1+24
   279                          ; sta sid2+24
   280                          ; sta filters1+3
   281                          ; sta filters2+3  ;      [910612]
   282                          ;; sta filters+4  ;why?      [910612]
   283                          ;; jsr go_fast  ;      [910716] 4567R7A
   284                          ;----
   285                          ; ldy #29   ;initialize music tables
   286                          ;10$ lda atkmus,y
   287                          ; sta atktab,y
   288                          ; dey
   289                          ; bpl 10$
   290                          ;
   291                          ; ldx #9   ;initialize pulse widths
   292                          ;20$ lda pwhmus,x
   293                          ; sta pulshi,x
   294                          ; dex
   295                          ; bpl 20$
   296                          ;
   297                          ; stx sound_time_hi ;turn all SOUND counters off (.X = $ff)
   298                          ; stx sound_time_hi+1
   299                          ; stx sound_time_hi+2
   300                          ; stx sound_time_hi+3 ;stereo SIDs     [910612]
   301                          ; stx sound_time_hi+4
   302                          ; stx sound_time_hi+5
   303                          ; stx voices+1  ;turn all PLAY counters off
   304                          ; stx voices+3
   305                          ; stx voices+5
   306                          ; stx voices+7  ;stereo SIDs     [910612]
   307                          ; stx voices+9
   308                          ; stx voices+11
   309                          ;
   310                          ; ldy #6-1  ;set default envelope (piano) for all voices (6)
   311                          ; sty voice
   312                          ;30$ ldx #0
   313                          ; jsr set_envelope_1
   314                          ; dec voice
   315                          ; bpl 30$
   316                          ; inc voice  ;set default voice (0)
   317                          ;-----
   318  210d 2058be                              jsr Sound_CLR_1                          ; [910724]
   319                          
   320  2110 a9e7                                lda #%11100111                           ; [910626]
   321  2112 1455                                trb helper                               ; reset LIST/HELP/FIND flags
   322  2114 0cd902                              tsb highlight_save                       ; mark saved color as invalid
   323                          
   324  2117 a900                                lda #0                                   ; [910523] F018A
   325  2119 a217                                ldx #12+12-1                             ; init DMA lists
   326  211b 9d4401             l2_1             sta dma1_cmd,x
   327  211e ca                                  dex
   328  211f 10fa                                bpl l2_1
   329                          
   330                          ; stop_sprites   ;Stop all moving sprites (a=0)   [910523]
   331  2121 a007                                ldy #7                                   ; for sprites 0...7
   332  2123 befeb7             l2_2             ldx sproff,y                             ; get table offset
   333  2126 9d0512                              sta sprite_data,x                        ; reset speed for this sprite
   334  2129 88                                  dey
   335  212a 10f7                                bpl l2_2                                 ; loop until done
   336                          
   337  212c 8d15d0                              sta vic+21                               ; Turn off all sprites    [910717]
   338                          
   339  212f 8ddb02                              sta irq_wrap_flag                        ; enable BASIC IRQ handler
   340                          ; sta nmi_wrap_flag ;enable BASIC NMI handler   [910523]
   341  2132 60                                  rts                                      ; (removed)    [910826]
   342                          
   343                          
   344                          signon_message
   345  2133 207dff             l3_1             jsr _primm
   346  2136 93121c2020202020...                 !text 147,18,028,"                     ",146,169
   347  2150 0509202020202020...                 !text 5,9,"       THE COMMODORE C65 DEVELOPMENT SYSTEM",cr
   348  217e 1296202020202020...                 !text 18,150,"                  ",146,169,cr
   349  2195 129e202020202020...                 !text 18,158,"               ",146,169
   350  21a8 0509202020434f50...                 !text 5,9,"   COPYRIGHT  1991  COMMODORE ELECTRONICS, LTD.",cr
   351  21da 121e202020202020...                 !text 18,030,"            ",146,169
   352  21ea 0509090920202020...                 !text 5,9,9,9,"    COPYRIGHT  1977  MICROSOFT",cr
   353  220d 129a202020202020...                 !text 18,154,"          ",146,169,cr
   354  221c 129c202020202020...                 !text 18,156,"        ",146,169
   355  2228 0509092042415349...                 !text 5,9,9," BASIC 10.0   V0.9B.911119    ALL RIGHTS RESERVED",cr,0
   356                          
   357  225e 60                                  rts
   358                          
   359                          
   360                          init_vectors
   361  225f a217                                ldx #l4_3-l4_2-1
   362  2261 bd6b22             l4_1             lda l4_2,x
   363  2264 9dfa02                              sta vectors_begin,x
   364  2267 ca                                  dex
   365  2268 10f7                                bpl l4_1
   366                          
   367  226a 60                                  rts
   368                          
   369                          
   370  226b c37d               l4_2             !word AutoScroll                         ; autoscroll vector
   371  226d 8f2d                                !word n_esc_fn_vec                       ; escape function vector
   372  226f cd7f                                !word graphic_kernel                     ; graphic extension vector
   373  2271 522e0a2f2223be33...                 !word nerror,nmain,ncrnch,nqplop,ngone,neval ; traditional vectors
   374  227d 32234e34c02c                        !word nesclk,nescpr,nescex               ; escape command vectors
   375                          l4_3
   376                          
   377                          
   378                          ;; CHRGET/CHRGOT code.  It is downloaded to RAM.
   379                          ;;
   380                          ;chrget_pattern
   381                          ; inw txtptr ;CHRGET entry
   382                          ; phz  ;CHRGOT entry (chrget+2)
   383                          ; phx
   384                          ; lda #0
   385                          ; ldx #$f0
   386                          ; ldy #0
   387                          ; ldz #$f0
   388                          ; map
   389                          ; ldy #0
   390                          ; lda (txtptr),y
   391                          ; phy
   392                          ; pha
   393                          ; jsr _restore_sys
   394                          ; nop  ;unmap
   395                          ; pla
   396                          ; ply
   397                          ; plx
   398                          ; plz
   399                          ;
   400                          ; cmp #':' ;QNUM entry (chrget+27)
   401                          ; bcs l4_2
   402                          ; cmp #' '
   403                          ; beq chrget_pattern
   404                          ; sec
   405                          ; sbc #'0'
   406                          ; sec
   407                          ; sbc #$d0
   408                          ;l4_2 rts  ;(42 bytes to here)
   409                          ;
   410                          ;
   411                          ;
   412                          ;; Constants which must be moved to RAM
   413                          ;
   414                          ; .byte   0,0,0 ;zero, of course!
   415                          ;
   416                          ;endmov   ;(45 bytes to here)
   417                          
   418                          
   419                          ; CHRGET/CHRGOT code.
   420                          ;
   421                          
   422  2283 e33d               chrget           inw txtptr                               ; get next character from text
   423  2285 a000               chrgot           ldy #0                                   ; re-get current character from text
   424  2287 20c522                              jsr indtxt                               ; lda (txtptr),y from RAM0
   425  228a c920               qnum             cmp #' '
   426  228c f0f5                                beq chrget                               ; skip spaces
   427  228e c93a               chrtst           cmp #':'                                 ; [910513]
   428  2290 b006                                bcs l5_1                                 ; eol
   429  2292 38                                  sec
   430  2293 e930                                sbc #'0'                                 ; alpha or numeric?
   431  2295 38                                  sec
   432  2296 e9d0                                sbc #$d0
   433  2298 60                 l5_1             rts
   434                          
   435                          

; ******** Source: basic.asm

; ******** Source: system/indirection.asm
     1                          
     2                          ; C65 BASIC Indirect Load Subroutines
     3                          
     4                          
     5                          inddef
     6  2299 a950                                lda #defpnt
     7  229b 803a                                bra lda_far_ram1
     8                          
     9                          indfrm
    10  229d a93f                                lda #form
    11  229f 8036                                bra lda_far_ram1
    12                          
    13                          inddpt
    14  22a1 a952                                lda #dscpnt
    15  22a3 8032                                bra lda_far_ram1
    16                          
    17                          ;indhtr
    18                          ; lda #hightr
    19                          ; bra lda_far_ram0
    20                          
    21                          indhtr_ram1
    22  22a5 a95c                                lda #hightr
    23  22a7 802e                                bra lda_far_ram1
    24                          
    25                          indfmo
    26  22a9 a966                                lda #facmo
    27  22ab 802a                                bra lda_far_ram1
    28                          
    29                          indlow
    30  22ad a961                                lda #lowtr
    31  22af 8016                                bra lda_far_ram0
    32                          
    33                          indst1
    34  22b1 a970                                lda #strng1
    35  22b3 8012                                bra lda_far_ram0
    36                          
    37                          indst1_ram1
    38  22b5 a970                                lda #strng1
    39  22b7 801e                                bra lda_far_ram1
    40                          
    41                          indgrb
    42  22b9 a950                                lda #grbpnt
    43  22bb 801a                                bra lda_far_ram1
    44                          
    45                          indlow_ram1
    46  22bd a961                                lda #lowtr
    47  22bf 8016                                bra lda_far_ram1
    48                          
    49                          indin1
    50  22c1 a924                                lda #index1
    51  22c3 8002                                bra lda_far_ram0
    52                          
    53                          ;indin2
    54                          ; lda #index2
    55                          ; bra lda_far_ram0
    56                          
    57                          indtxt
    58  22c5 a93d                                lda #txtptr
    59                          ; bra lda_far_ram0
    60                          
    61                          
    62                          ; C65 BASIC Indirect Load Subroutines
    63                          
    64                          lda_far_ram0
    65  22c7 db                                  phz                                      ; save registers
    66  22c8 da                                  phx
    67  22c9 aa                                  tax                                      ; pointer
    68  22ca ab8400                              ldz text_bank                            ; RAM0
    69  22cd 2074ff                              jsr _lda_far                             ; LDA (.x),Y from bank .z
    70  22d0 fa                                  plx
    71  22d1 fb                                  plz
    72  22d2 29ff                                and #$ff                                 ; set processor status per byte fetched
    73  22d4 60                                  rts
    74                          
    75                          
    76                          
    77                          indin1_ram1
    78  22d5 a924                                lda #index1
    79                          ; bra lda_far_ram1
    80                          
    81                          lda_far_ram1
    82  22d7 08                                  php                                      ; save .c
    83  22d8 db                                  phz                                      ; save registers
    84  22d9 da                                  phx
    85  22da aa                                  tax                                      ; pointer
    86  22db ab8500                              ldz var_bank                             ; RAM1
    87  22de b501                                lda 1,x                                  ; check to see if pointer points to "common"
    88  22e0 c920                                cmp #$20
    89  22e2 b003                                bcs l6_1                                 ; branch if not
    90  22e4 ab8400                              ldz text_bank                            ; else select RAM0
    91                          
    92  22e7 2074ff             l6_1             jsr _lda_far                             ; LDA (.x),Y from bank .z
    93  22ea fa                                  plx
    94  22eb fb                                  plz
    95  22ec 28                                  plp                                      ; restore .c
    96  22ed 29ff                                and #$ff                                 ; set processor status per byte fetched
    97  22ef 60                                  rts
    98                          
    99                          
   100                          ; C65 BASIC Indirect Save Subroutines
   101                          
   102                          sta_far_ram1
   103  22f0 08                                  php                                      ; save registers
   104  22f1 db                                  phz
   105  22f2 48                                  pha
   106  22f3 ab8500                              ldz var_bank                             ; RAM1
   107  22f6 b501                                lda 1,x                                  ; check to see if pointer points to "common"
   108  22f8 c920                                cmp #$20
   109  22fa b003                                bcs l7_1                                 ; branch if not
   110  22fc ab8400                              ldz text_bank                            ; else select RAM0
   111                          
   112  22ff 68                 l7_1             pla
   113  2300 2077ff                              jsr _sta_far                             ; STA (.x),Y to bank .z
   114  2303 fb                                  plz
   115  2304 28                                  plp
   116  2305 60                                  rts
   117                          
   118                          
   119                          sta_far_in1                                               ; [910624]
   120  2306 a224                                ldx #index1
   121  2308 8002                                bra sta_far_ram0
   122                          
   123                          sta_far_txt
   124  230a a23d                                ldx #txtptr
   125                          
   126                          sta_far_ram0
   127  230c 08                                  php                                      ; save registers
   128  230d db                                  phz
   129  230e ab8400                              ldz text_bank                            ; RAM0
   130  2311 2077ff                              jsr _sta_far                             ; STA (.x),Y to bank .z
   131  2314 fb                                  plz
   132  2315 28                                  plp
   133  2316 60                                  rts
   134                          
   135                          
   136                          indcmp_in1                                                ; [910620]
   137  2317 a224                                ldx #index1
   138  2319 ab8400                              ldz text_bank                            ; RAM0
   139  231c 4c7aff                              jmp _cmp_far                             ; STA (.x),Y to bank .z
   140                          
   141                          ;.end
   142                          
   143                          

; ******** Source: basic.asm

; ******** Source: system/tokeniser.asm
     1                          ;        CRUNCH
     2                          ;
     3                          ;  Entry:  TXTPTR points to start of text to crunch
     4                          ;  Exit:   TXTPTR points to start of crunched text
     5                          ;
     6                          ;  Calls:  CHRGET
     7                          ;          CHRGOT
     8                          ;          RESER
     9                          ;          KLOOP
    10                          ;          REM
    11                          ;          DATA
    12                          ;
    13                          ;  CRUNCH collapses all reserved words into tokens.  It removes all graphic
    14                          ;  characters (characters with msb set) not in quoted strings, DATA or REM
    15                          ;  statements.
    16                          ;
    17                          ;  An escape token is implemented as follows:
    18                          ;
    19                          ; As each character on a line of text to be crunched is scanned, an
    20                          ; indirect jump is performed.  Anyone wishing to scan for their own
    21                          ; commands should grab off this vector, saving the return vector.
    22                          ; On entry, if the carry flag is set, it is still up for grabs.
    23                          ; The current text pointer is at TXTPTR.  If the escape routine
    24                          ; recognizes the command, it should:
    25                          ;
    26                          ;  ) put the length of the reserved word in .y
    27                          ;  ) put the desired 'second' token in .a
    28                          ;  ) clear the carry flag
    29                          ;  ) put type of token in x: 0==>command, ff==>function
    30                          ;
    31                          ; If it is not your command, leave .a and the carry flag intact.
    32                          ; NOTE:  The reserved word must be >= 2 characters long.  Exit through
    33                          ; the old vector (for daisy chaining).  If the carry flag is clear on
    34                          ; entry it means someone else before you recognized this command.  In
    35                          ; this case, just pass control through the old vector.
    36                          
    37                          
    38  231f 6c0403             crunch           jmp (icrnch)
    39                          
    40                          
    41  2322 fc3d00             ncrnch           phw txtptr                               ; save old text pointer
    42                          
    43  2325 208522             crun05           jsr chrgot
    44  2328 8003                                bra crun20
    45                          
    46  232a 208322             crun10           jsr chrget
    47                          
    48                          
    49  232d 90fb               crun20           bcc crun10                               ; don't crunch numbers
    50  232f 6c0c03                              jmp (iesclk)                             ; give others a chance at this.  (carry is set)
    51                          
    52                          nesclk
    53  2332 938e00                              +lbcc l8_12                              ; carry clear if someone wanted it
    54  2335 c900                                cmp #0                                   ; end of line?
    55  2337 f078                                beq l8_10                                ; yes
    56  2339 c93a                                cmp #':'                                 ; multi-stmt char?
    57  233b f0ed                                beq crun10                               ; yes
    58  233d c93f                                cmp #'?'                                 ; print ('?') abreviation?
    59  233f d004                                bne l8_1                                 ; no
    60  2341 a999                                lda #print_token                         ; yes- substitute print token
    61  2343 8050                                bra l8_8
    62                          
    63  2345 c980               l8_1             cmp #$80                                 ; graphics?
    64  2347 900b                                bcc l8_2                                 ; no
    65  2349 c9ff                                cmp #pi                                  ; pi? (special case)
    66  234b f0dd                                beq crun10                               ; yes, leave alone
    67  234d a001                                ldy #1
    68  234f 20de23                              jsr kloop                                ; crunch out graphics
    69  2352 80d1                                bra crun05
    70                          
    71                          
    72  2354 c922               l8_2             cmp #'"'                                 ; quote string?
    73  2356 d00d                                bne l8_4                                 ; no- try escape token
    74                          
    75  2358 208322             l8_3             jsr chrget
    76  235b c900                                cmp #0                                   ; end of line?
    77  235d f052                                beq l8_10                                ; yes
    78  235f c922                                cmp #'"'                                 ; close quote?
    79  2361 f0c7                                beq crun10                               ; yes
    80  2363 80f3                                bra l8_3                                 ; no, continue skipping characters
    81                          
    82                          
    83                          ; Crunch escape token
    84                          
    85  2365 a926               l8_4             lda #>esc_command_list                   ; look for token in escape-command list
    86  2367 a029                                ldy #<esc_command_list
    87  2369 20f423                              jsr reser
    88  236c 9006                                bcc l8_5                                 ; not found
    89  236e a981                                lda #first_esc_command_token+$80-1       ; set up for common escape routine
    90  2370 a200                                ldx #0                                   ; ..flag 'cmd' type escape
    91  2372 804c                                bra l8_11                                ; ..and go to it.
    92                          
    93  2374 a927               l8_5             lda #>esc_function_list                  ; look for token in escape-function list
    94  2376 a09a                                ldy #<esc_function_list
    95  2378 20f423                              jsr reser
    96  237b 9006                                bcc l8_6                                 ; not found
    97  237d a981                                lda #first_esc_function_token+$80-1      ; set up for common escape routine
    98  237f a2ff                                ldx #$ff                                 ; ..flag 'function' type escape
    99  2381 803d                                bra l8_11                                ; ..and go to it
   100                          
   101  2383 a924               l8_6             lda #>keyword_list                       ; look for token in normal list
   102  2385 a03a                                ldy #<keyword_list
   103  2387 20f423                              jsr reser
   104  238a 909e                                bcc crun10                               ; not found
   105  238c c000                                cpy #0                                   ; anything to move?
   106  238e f003                                beq l8_7                                 ; no
   107  2390 20de23                              jsr kloop                                ; crunch it out
   108  2393 a50d               l8_7             lda count
   109                          
   110  2395 a000               l8_8             ldy #0
   111  2397 200a23                              jsr sta_far_txt                          ; put token into text  (bleed-thru)
   112  239a c98f                                cmp #rem_token
   113  239c f00d                                beq l8_9
   114  239e c983                                cmp #data_token
   115  23a0 d088                                bne crun10
   116  23a2 208322                              jsr chrget
   117  23a5 204835                              jsr data
   118  23a8 837bff                              +lbra crun05
   119                          
   120  23ab 208322             l8_9             jsr chrget
   121  23ae 205635                              jsr rem
   122                          
   123                          
   124                          ;  No other statements can follow a REM
   125                          
   126  23b1 a63d               l8_10            ldx txtptr
   127  23b3 68                                  pla
   128  23b4 853e                                sta txtptr+1
   129  23b6 68                                  pla
   130  23b7 853d                                sta txtptr
   131  23b9 38                                  sec                                      ; compute length of line
   132  23ba 8a                                  txa
   133  23bb e53d                                sbc txtptr
   134  23bd a8                                  tay
   135  23be c8                                  iny
   136  23bf 60                                  rts
   137                          
   138                          
   139                          ; Crunch out old text, install an escape token
   140                          
   141  23c0 650d               l8_11            adc count                                ; make pointer into a token
   142  23c2 48                 l8_12            pha                                      ; save second token
   143  23c3 88                                  dey                                      ; waste (# of chars) - 1
   144  23c4 20de23                              jsr kloop
   145                          
   146                          ; See if this is function (x=ff) or command (x=0)
   147                          
   148  23c7 a9fe                                lda #esc_command_token                   ; assume command
   149  23c9 e8                                  inx
   150  23ca d002                                bne l8_13                                ; branch if command
   151  23cc a9ce                                lda #esc_function_token                  ; ..else get correct token
   152                          
   153  23ce a000               l8_13            ldy #0
   154  23d0 200a23                              jsr sta_far_txt                          ; install escape token... (bleed-thru)
   155  23d3 c8                                  iny
   156  23d4 68                                  pla
   157  23d5 200a23                              jsr sta_far_txt                          ; ..and second token  (bleed-thru)
   158  23d8 208322                              jsr chrget                               ; skip over token,
   159  23db 834dff                              +lbra crun10                             ; ..and continue with line.
   160                          
   161                          
   162                          ;      KLOOP
   163                          ;
   164                          ;  Crunch loop.  Moves offset .y characters from txtptr to end of line.
   165                          ;  .x is preserved
   166                          
   167  23de 18                 kloop            clc                                      ; compute source address
   168  23df 98                                  tya
   169  23e0 653d                                adc txtptr
   170  23e2 8524                                sta index1
   171  23e4 a53e                                lda txtptr+1
   172  23e6 6900                                adc #0
   173  23e8 8525                                sta index1+1
   174  23ea a0ff                                ldy #$ff
   175                          
   176  23ec c8                 l9_1             iny
   177  23ed b124                                lda (index1),y                           ; move source..  ????assumes text in common area
   178  23ef 913d                                sta (txtptr),y                           ; to destination offset ????assumes text in common area
   179  23f1 d0f9                                bne l9_1                                 ; not end of line
   180  23f3 60                                  rts
   181                          
   182                          
   183                          ;      RESER
   184                          ;
   185                          ;  Search reserved word list for a match
   186                          ;
   187                          ;  Entry:  (txtptr) is first char of word to match
   188                          ;    (y,a) is start of table to check
   189                          ;
   190                          ;  Exit:   .y  length of word matched
   191                          ;    .c  success/fail (set/clear) flag
   192                          ;    count token value
   193                          
   194  23f4 8525               reser            sta index1+1
   195  23f6 8424                                sty index1
   196  23f8 a000                                ldy #0
   197  23fa 840d                                sty count
   198  23fc 88                                  dey
   199  23fd c8                 l10_1            iny
   200  23fe b13d               l10_2            lda (txtptr),y                           ; assumes common memory
   201  2400 3029                                bmi l10_7                                ; abrieviation    [900510]
   202  2402 38                                  sec
   203  2403 f124                                sbc (index1),y                           ; does letter match? (ind.ok)
   204  2405 f0f6                                beq l10_1                                ; yes...continue
   205  2407 c980                                cmp #$80                                 ; end of word?
   206  2409 f01b                                beq l10_6                                ; yes...c set...done
   207                          
   208                          
   209                          ;  find next word
   210                          
   211  240b b124               l10_3            lda (index1),y                           ; ind.ok
   212  240d 3003                                bmi l10_4                                ; found end of current
   213  240f c8                                  iny
   214  2410 d0f9                                bne l10_3
   215  2412 c8                 l10_4            iny                                      ; start of next
   216  2413 e60d                                inc count                                ; value of token
   217  2415 18                                  clc
   218  2416 98                                  tya
   219  2417 6524                                adc index1
   220  2419 8524                                sta index1
   221  241b 9002                                bcc l10_5
   222  241d e625                                inc index1+1
   223  241f 18                 l10_5            clc
   224  2420 a000                                ldy #0
   225  2422 b124                                lda (index1),y                           ; end of list? ind.ok
   226  2424 d0d8                                bne l10_2                                ; no
   227                          
   228                          
   229                          ;  yes...carry clear...fail
   230                          
   231  2426 050d               l10_6            ora count                                ; .a=$80 if match
   232  2428 850d                                sta count                                ; token is formed
   233  242a 60                                  rts
   234                          
   235                          
   236                          ; special case- last character is shifted (necessary for 'diR' compatibility)
   237                          
   238  242b 38                 l10_7            sec                                      ; allow last chr to be shifted   [900510]
   239  242c f124                                sbc (index1),y                           ; does letter match? (ind.ok)
   240  242e f006                                beq l10_8                                ; yes- end of word
   241  2430 c980                                cmp #$80                                 ; end of word?
   242  2432 f0f2                                beq l10_6                                ; yes
   243  2434 d0d5                                bne l10_3                                ; no- next word
   244                          
   245  2436 a980               l10_8            lda #$80                                 ; last chr is shifted & so is end of current word
   246  2438 80ec                                bra l10_6
   247                          
   248                          ;.end
   249                          
   250                          

; ******** Source: basic.asm

; ******** Source: tokeniser/keywords.asm
     1                          
     2                          keyword_list
     3  243a 454ec4                              !text "EN",'D'+$80                       ; $80
     4  243d 464fd2                              !text "FO",'R'+$80                       ; $81
     5  2440 4e4558d4                            !text "NEX",'T'+$80                      ; $82
     6  2444 444154c1                            !text "DAT",'A'+$80                      ; $83
     7  2448 494e505554a3                        !text "INPUT",'#'+$80                    ; $84
     8  244e 494e5055d4                          !text "INPU",'T'+$80                     ; $85
     9  2453 4449cd                              !text "DI",'M'+$80                       ; $86
    10  2456 524541c4                            !text "REA",'D'+$80                      ; $87
    11  245a 4c45d4                              !text "LE",'T'+$80                       ; $88
    12  245d 474f54cf                            !text "GOT",'O'+$80                      ; $89
    13  2461 5255ce                              !text "RU",'N'+$80                       ; $8A
    14  2464 49c6                                !text "I",'F'+$80                        ; $8B
    15  2466 524553544f52c5                      !text "RESTOR",'E'+$80                   ; $8C
    16  246d 474f5355c2                          !text "GOSU",'B'+$80                     ; $8D
    17  2472 5245545552ce                        !text "RETUR",'N'+$80                    ; $8E
    18  2478 5245cd                              !text "RE",'M'+$80                       ; $8F
    19  247b 53544fd0                            !text "STO",'P'+$80                      ; $90
    20  247f 4fce                                !text "O",'N'+$80                        ; $91
    21  2481 574149d4                            !text "WAI",'T'+$80                      ; $92
    22  2485 4c4f41c4                            !text "LOA",'D'+$80                      ; $93
    23  2489 534156c5                            !text "SAV",'E'+$80                      ; $94
    24  248d 5645524946d9                        !text "VERIF",'Y'+$80                    ; $95
    25  2493 4445c6                              !text "DE",'F'+$80                       ; $96
    26  2496 504f4bc5                            !text "POK",'E'+$80                      ; $97
    27  249a 5052494e54a3                        !text "PRINT",'#'+$80                    ; $98
    28  24a0 5052494ed4                          !text "PRIN",'T'+$80                     ; $99
    29  24a5 434f4ed4                            !text "CON",'T'+$80                      ; $9A
    30  24a9 4c4953d4                            !text "LIS",'T'+$80                      ; $9B
    31  24ad 434cd2                              !text "CL",'R'+$80                       ; $9C
    32  24b0 434dc4                              !text "CM",'D'+$80                       ; $9D
    33  24b3 5359d3                              !text "SY",'S'+$80                       ; $9E
    34  24b6 4f5045ce                            !text "OPE",'N'+$80                      ; $9F
    35  24ba 434c4f53c5                          !text "CLOS",'E'+$80                     ; $A0
    36  24bf 4745d4                              !text "GE",'T'+$80                       ; $A1
    37  24c2 4e45d7                              !text "NE",'W'+$80                       ; $A2
    38  24c5 544142a8                            !text "TAB",'('+$80                      ; $A3
    39  24c9 54cf                                !text "T",'O'+$80                        ; $A4
    40  24cb 46ce                                !text "F",'N'+$80                        ; $A5
    41  24cd 535043a8                            !text "SPC",'('+$80                      ; $A6
    42  24d1 544845ce                            !text "THE",'N'+$80                      ; $A7
    43  24d5 4e4fd4                              !text "NO",'T'+$80                       ; $A8
    44  24d8 535445d0                            !text "STE",'P'+$80                      ; $A9
    45  24dc ab                                  !text '+'+$80                            ; $AA operators
    46  24dd ad                                  !text '-'+$80                            ; $AB
    47  24de aa                                  !text '*'+$80                            ; $AC
    48  24df af                                  !text '/'+$80                            ; $AD
    49  24e0 de                                  !text '^'+$80                            ; $AE
    50  24e1 414ec4                              !text "AN",'D'+$80                       ; $AF
    51  24e4 4fd2                                !text "O",'R'+$80                        ; $B0
    52  24e6 be                                  !text '>'+$80                            ; $B1
    53  24e7 bd                                  !text '='+$80                            ; $B2
    54  24e8 bc                                  !text '<'+$80                            ; $B3
    55  24e9 5347ce                              !text "SG",'N'+$80                       ; $B4 first numeric function
    56  24ec 494ed4                              !text "IN",'T'+$80                       ; $B5
    57  24ef 4142d3                              !text "AB",'S'+$80                       ; $B6
    58  24f2 5553d2                              !text "US",'R'+$80                       ; $B7
    59  24f5 4652c5                              !text "FR",'E'+$80                       ; $B8
    60  24f8 504fd3                              !text "PO",'S'+$80                       ; $B9
    61  24fb 5351d2                              !text "SQ",'R'+$80                       ; $BA
    62  24fe 524ec4                              !text "RN",'D'+$80                       ; $BB
    63  2501 4c4fc7                              !text "LO",'G'+$80                       ; $BC
    64  2504 4558d0                              !text "EX",'P'+$80                       ; $BD
    65  2507 434fd3                              !text "CO",'S'+$80                       ; $BE
    66  250a 5349ce                              !text "SI",'N'+$80                       ; $BF
    67  250d 5441ce                              !text "TA",'N'+$80                       ; $C0
    68  2510 4154ce                              !text "AT",'N'+$80                       ; $C1
    69  2513 504545cb                            !text "PEE",'K'+$80                      ; $C2
    70  2517 4c45ce                              !text "LE",'N'+$80                       ; $C3
    71  251a 535452a4                            !text "STR",'$'+$80                      ; $C4
    72  251e 5641cc                              !text "VA",'L'+$80                       ; $C5
    73  2521 4153c3                              !text "AS",'C'+$80                       ; $C6 last numeric function
    74  2524 434852a4                            !text "CHR",'$'+$80                      ; $C7 last single-arg function
    75  2528 4c454654a4                          !text "LEFT",'$'+$80                     ; $C8
    76  252d 5249474854a4                        !text "RIGHT",'$'+$80                    ; $C9
    77  2533 4d4944a4                            !text "MID",'$'+$80                      ; $CA
    78  2537 47cf                                !text "G",'O'+$80                        ; $CB
    79                          ; beginning of new C128 keywords------------
    80  2539 52475241504849c3                    !text "RGRAPHI",'C'+$80                  ; $CC was 'rgr'   [910701]
    81  2541 52434f4c4fd2                        !text "RCOLO",'R'+$80                    ; $CD was 'rclr'   [910701]
    82  2547 80                                  !text $80                                ; $CE null to skip over escape_function token
    83  2548 4a4fd9                              !text "JO",'Y'+$80                       ; $CF
    84  254b 525045ce                            !text "RPE",'N'+$80                      ; $D0 (was rdot in c128)
    85  254f 4445c3                              !text "DE",'C'+$80                       ; $D1
    86  2552 484558a4                            !text "HEX",'$'+$80                      ; $D2
    87  2556 455252a4                            !text "ERR",'$'+$80                      ; $D3
    88  255a 494e5354d2                          !text "INST",'R'+$80                     ; $D4 last function
    89                          
    90  255f 454c53c5                            !text "ELS",'E'+$80                      ; $D5
    91  2563 524553554dc5                        !text "RESUM",'E'+$80                    ; $D6
    92  2569 545241d0                            !text "TRA",'P'+$80                      ; $D7
    93  256d 54524fce                            !text "TRO",'N'+$80                      ; $D8
    94  2571 54524f46c6                          !text "TROF",'F'+$80                     ; $D9
    95  2576 534f554ec4                          !text "SOUN",'D'+$80                     ; $DA
    96  257b 564fcc                              !text "VO",'L'+$80                       ; $DB
    97  257e 415554cf                            !text "AUT",'O'+$80                      ; $DC
    98  2582 50554445c6                          !text "PUDE",'F'+$80                     ; $DD
    99  2587 475241504849c3                      !text "GRAPHI",'C'+$80                   ; $DE
   100  258e 5041494ed4                          !text "PAIN",'T'+$80                     ; $DF
   101  2593 434841d2                            !text "CHA",'R'+$80                      ; $E0
   102  2597 424fd8                              !text "BO",'X'+$80                       ; $E1
   103  259a 434952434cc5                        !text "CIRCL",'E'+$80                    ; $E2
   104  25a0 50415354c5                          !text "PAST",'E'+$80                     ; $E3 (was gshape in C128)
   105  25a5 4355d4                              !text "CU",'T'+$80                       ; $E4 (was sshape in C128)
   106  25a8 4c494ec5                            !text "LIN",'E'+$80                      ; $E5 (was draw in C128)
   107  25ac 4c4f434154c5                        !text "LOCAT",'E'+$80                    ; $E6
   108  25b2 434f4c4fd2                          !text "COLO",'R'+$80                     ; $E7
   109  25b7 53434e434cd2                        !text "SCNCL",'R'+$80                    ; $E8
   110  25bd 5343414cc5                          !text "SCAL",'E'+$80                     ; $E9
   111  25c2 48454cd0                            !text "HEL",'P'+$80                      ; $EA
   112  25c6 44cf                                !text "D",'O'+$80                        ; $EB
   113  25c8 4c4f4fd0                            !text "LOO",'P'+$80                      ; $EC
   114  25cc 455849d4                            !text "EXI",'T'+$80                      ; $ED
   115  25d0 4449d2                              !text "DI",'R'+$80                       ; $EE
   116  25d3 44534156c5                          !text "DSAV",'E'+$80                     ; $EF
   117  25d8 444c4f41c4                          !text "DLOA",'D'+$80                     ; $F0
   118  25dd 4845414445d2                        !text "HEADE",'R'+$80                    ; $F1
   119  25e3 534352415443c8                      !text "SCRATC",'H'+$80                   ; $F2
   120  25ea 434f4c4c4543d4                      !text "COLLEC",'T'+$80                   ; $F3
   121  25f1 434f50d9                            !text "COP",'Y'+$80                      ; $F4
   122  25f5 52454e414dc5                        !text "RENAM",'E'+$80                    ; $F5
   123  25fb 4241434b55d0                        !text "BACKU",'P'+$80                    ; $F6
   124  2601 44454c4554c5                        !text "DELET",'E'+$80                    ; $F7
   125  2607 52454e554d4245d2                    !text "RENUMBE",'R'+$80                  ; $F8
   126  260f 4b45d9                              !text "KE",'Y'+$80                       ; $F9
   127  2612 4d4f4e49544fd2                      !text "MONITO",'R'+$80                   ; $FA
   128  2619 5553494ec7                          !text "USIN",'G'+$80                     ; $FB
   129  261e 554e5449cc                          !text "UNTI",'L'+$80                     ; $FC
   130  2623 5748494cc5                          !text "WHIL",'E'+$80                     ; $FD
   131  2628 00                                  !text 0                                  ; $FE skip over the escape_command token
   132                          
   133                          ;.end
   134                          
   135                          
   136                          

; ******** Source: basic.asm

; ******** Source: tokeniser/keyword/esc.asm
     1                          ; Escape Command Tokens
     2                          
     3                          esc_command_list
     4  2629 42414ecb                            !text "BAN",'K'+$80                      ; $02: set bank number
     5  262d 46494c5445d2                        !text "FILTE",'R'+$80                    ; $03: set up filter
     6  2633 504c41d9                            !text "PLA",'Y'+$80                      ; $04: play a tune
     7  2637 54454d50cf                          !text "TEMP",'O'+$80                     ; $05: set rate for playing
     8  263c 4d4f565350d2                        !text "MOVSP",'R'+$80                    ; $06: sprite position/movement
     9  2642 5350524954c5                        !text "SPRIT",'E'+$80                    ; $07: turn on/set up sprite
    10  2648 535052434f4c4fd2                    !text "SPRCOLO",'R'+$80                  ; $08: set sprite multicolor registers
    11  2650 525245c7                            !text "RRE",'G'+$80                      ; $09: retreive register values after 'SYS'
    12  2654 454e56454c4f50c5                    !text "ENVELOP",'E'+$80                  ; $0A: set up SID envelopes
    13  265c 534c4545d0                          !text "SLEE",'P'+$80                     ; $0B: delay
    14  2661 434154414c4fc7                      !text "CATALO",'G'+$80                   ; $0C: disk directory
    15  2668 444f5045ce                          !text "DOPE",'N'+$80                     ; $0D: open a disk file
    16  266d 415050454ec4                        !text "APPEN",'D'+$80                    ; $0E: open a disk file for appending
    17  2673 44434c4f53c5                        !text "DCLOS",'E'+$80                    ; $0F: close a file opened w/ DOPEN
    18  2679 42534156c5                          !text "BSAV",'E'+$80                     ; $10: binary (non-program) save
    19  267e 424c4f41c4                          !text "BLOA",'D'+$80                     ; $11: binary load
    20  2683 5245434f52c4                        !text "RECOR",'D'+$80                    ; $12:
    21  2689 434f4e4341d4                        !text "CONCA",'T'+$80                    ; $13: concatenate 2 files
    22  268f 445645524946d9                      !text "DVERIF",'Y'+$80                   ; $14: verify a saved program
    23  2696 44434c4541d2                        !text "DCLEA",'R'+$80                    ; $15: re-initialize a drive
    24  269c 5350525341d6                        !text "SPRSA",'V'+$80                    ; $16: sprite/string to sprite/string
    25  26a2 434f4c4c4953494f...                 !text "COLLISIO",'N'+$80                 ; $17: set traps for sprite & light pen collisions
    26  26ab 42454749ce                          !text "BEGI",'N'+$80                     ; $18: mark start of a b-block
    27  26b0 42454ec4                            !text "BEN",'D'+$80                      ; $19: ..and its end, too!
    28  26b4 57494e444fd7                        !text "WINDO",'W'+$80                    ; $1A: set screen window
    29  26ba 424f4fd4                            !text "BOO",'T'+$80                      ; $1B: load&run ML or autoboot a disk
    30  26be 57494454c8                          !text "WIDT",'H'+$80                     ; $1C: single/double width drawing
    31  26c3 5350524445c6                        !text "SPRDE",'F'+$80                    ; $1D: define a sprite
    32  26c9 515549d4                            !text "QUI",'T'+$80                      ; $1E: (UNIMPLEMENTED)
    33  26cd 444dc1                              !text "DM",'A'+$80                       ; $1F: access memory
    34  26d0 a0                                  !text ' '+$80                            ; $20: POISON - space character
    35  26d1 444dc1                              !text "DM",'A'+$80                       ; $21: access memory
    36  26d4 a0                                  !text ' '+$80                            ; $22: POISON - quote character
    37  26d5 444dc1                              !text "DM",'A'+$80                       ; $23: access memory
    38  26d8 4f46c6                              !text "OF",'F'+$80                       ; $24: KEY OFF
    39  26db 464153d4                            !text "FAS",'T'+$80                      ; $25: go to 2 MHz. mode
    40  26df 534c4fd7                            !text "SLO",'W'+$80                      ; $26: go to 1 MHz. mode
    41  26e3 545950c5                            !text "TYP",'E'+$80                      ; $27: type SEQ file
    42  26e7 425645524946d9                      !text "BVERIF",'Y'+$80                   ; $28: verify a saved program
    43  26ee 4543544f52d9                        !text "ECTOR",'Y'+$80                    ; $29: dirECTORY
    44  26f4 45524153c5                          !text "ERAS",'E'+$80                     ; $2A: alias for scratch
    45  26f9 46494ec4                            !text "FIN",'D'+$80                      ; $2B: find string
    46  26fd 4348414e47c5                        !text "CHANG",'E'+$80                    ; $2C: change string
    47  2703 5345d4                              !text "SE",'T'+$80                       ; $2D:
    48  2706 5343524545ce                        !text "SCREE",'N'+$80                    ; $2E:
    49  270c 504f4c59474fce                      !text "POLYGO",'N'+$80                   ; $2F:
    50  2713 454c4c495053c5                      !text "ELLIPS",'E'+$80                   ; $30:
    51  271a 56494557504f52d4                    !text "VIEWPOR",'T'+$80                  ; $31:
    52  2722 47434f50d9                          !text "GCOP",'Y'+$80                     ; $32:
    53  2727 5045ce                              !text "PE",'N'+$80                       ; $33:
    54  272a 50414c455454c5                      !text "PALETT",'E'+$80                   ; $34:
    55  2731 444d4f44c5                          !text "DMOD",'E'+$80                     ; $35:
    56  2736 445041d4                            !text "DPA",'T'+$80                      ; $36:
    57  273a 464f524d41d4                        !text "FORMA",'T'+$80                    ; $37: alias for HEADER command  [911017]
    58  2740 47454e4c4f43cb                      !text "GENLOC",'K'+$80                   ; $38:     [910108]
    59  2747 464f524547524f55...                 !text "FOREGROUN",'D'+$80                ; $39:     [910109]
    60  2751 a0                                  !text ' '+$80                            ; $3A: POISON - colon character  "
    61  2752 4241434b47524f55...                 !text "BACKGROUN",'D'+$80                ; $3B:     "
    62  275c 424f524445d2                        !text "BORDE",'R'+$80                    ; $3C:     "
    63  2762 484947484c494748...                 !text "HIGHLIGH",'T'+$80                 ; $3D:     "
    64  276b 4d4f5553c5                          !text "MOUS",'E'+$80                     ; $3E:     [910122]
    65  2770 524d4f5553c5                        !text "RMOUS",'E'+$80                    ; $3F: return coordinates of mouse [910123]
    66  2776 444953cb                            !text "DIS",'K'+$80                      ; $40:     [910123]
    67  277a 435552534fd2                        !text "CURSO",'R'+$80                    ; $41:     [910228]
    68  2780 52435552534fd2                      !text "RCURSO",'R'+$80                   ; $42: return cursor position  [910228]
    69  2787 4c4f41444946c6                      !text "LOADIF",'F'+$80                   ; $43: load IFF picture from disk [910402]
    70  278e 534156454946c6                      !text "SAVEIF",'F'+$80                   ; $44: save IFF picture to   disk [910402]
    71  2795 454449d4                            !text "EDI",'T'+$80                      ; $45: Edit mode on/off   [910620]
    72                          
    73  2799 00                                  !text 0                                  ; End marker
    74                          ;(don't forget to change last_command_token!)
    75                          
    76                          ; Escape Function Tokens
    77                          
    78                          esc_function_list
    79  279a 504fd4                              !text "PO",'T'+$80                       ; $02: return paddle value
    80  279d 42554dd0                            !text "BUM",'P'+$80                      ; $03: read sprite collision
    81  27a1 4c5045ce                            !text "LPE",'N'+$80                      ; $04: read light pen value
    82  27a5 525350504fd3                        !text "RSPPO",'S'+$80                    ; $05: read sprite position
    83  27ab 525350524954c5                      !text "RSPRIT",'E'+$80                   ; $06: read sprite value
    84  27b2 525350434f4c4fd2                    !text "RSPCOLO",'R'+$80                  ; $07: read sprite multicolor value
    85  27ba 584fd2                              !text "XO",'R'+$80                       ; $08: exclusive or
    86  27bd 5257494e444fd7                      !text "RWINDO",'W'+$80                   ; $09: read window size
    87  27c4 504f494e5445d2                      !text "POINTE",'R'+$80                   ; $0a: return address of descriptor
    88  27cb 4d4fc4                              !text "MO",'D'+$80                       ; $0b: modulus    [910402]
    89  27ce 50495845cc                          !text "PIXE",'L'+$80                     ; $0c: return BP data at pixel  [910820]
    90  27d3 5250414c455454c5                    !text "RPALETT",'E'+$80                  ; $0d: return RGB component of color [910820]
    91  27db 00                                  !text 0
    92                          

; ******** Source: basic.asm

; ******** Source: tokeniser/vectors.asm
     1                          
     2                          
     3                          stmdsp
     4  27dc dc2c                                !word end-1
     5  27de 5c41                                !word for-1
     6  27e0 743a                                !word next-1
     7  27e2 4735                                !word data-1
     8  27e4 a138                                !word inputn-1
     9  27e6 bf38                                !word input-1
    10  27e8 f33a                                !word dim-1
    11  27ea 0f39                                !word read-1
    12  27ec 7536                                !word let-1
    13  27ee fa3c                                !word goto-1
    14  27f0 b33d                                !word run-1
    15  27f2 7d35                                !word if-1
    16  27f4 e63d                                !word restor-1
    17  27f6 eb3c                                !word gosub-1
    18  27f8 2c35                                !word return-1
    19  27fa 5535                                !word rem-1
    20  27fc da2c                                !word stop-1
    21  27fe 5436                                !word ongoto-1
    22  2800 e654                                !word wait-1
    23  2802 8968                                !word load-1
    24  2804 6168                                !word save-1
    25  2806 8668                                !word verify-1
    26  2808 f458                                !word def-1
    27  280a ed55                                !word poke-1
    28  280c a737                                !word printn-1
    29  280e c837                                !word print-1
    30  2810 793d                                !word cont-1
    31  2812 8932                                !word list-1
    32  2814 a534                                !word clear-1
    33  2816 ad37                                !word cmd-1
    34  2818 fd3a                                !word sys-1
    35  281a 0069                                !word open-1
    36  281c 0869                                !word close-1
    37  281e 6638                                !word get-1
    38  2820 5434                                !word new-1
    39                          
    40  2822 4236                                !word else-1
    41  2824 6744                                !word resume-1
    42  2826 5544                                !word trap-1
    43  2828 993b                                !word tron-1
    44  282a 9c3b                                !word troff-1
    45  282c 7c4b                                !word sound-1
    46  282e 454b                                !word volume-1
    47  2830 593c                                !word auto-1
    48  2832 4144                                !word puctrl-1
    49  2834 bf7f                                !word graphic-1
    50                          
    51  2836 5ab3                                !word C65__paint-1
    52  2838 efb2                                !word C65__char-1
    53  283a 06b1                                !word C65__box-1
    54  283c 5ab1                                !word C65__circle-1
    55  283e 4fb4                                !word C65__paste-1                       ; gshape
    56  2840 4fb4                                !word C65__cut-1                         ; sshape
    57  2842 b1b0                                !word C65__line-1                        ; draw
    58                          
    59  2844 3a2e                                !word bad_command-1                      ; escape - SYSTEM - unimplemented command
    60                          ; .word  locate-1
    61                          
    62  2846 99b4                                !word color-1
    63  2848 34af                                !word scnclr-1
    64                          
    65  284a 3a2e                                !word bad_command-1                      ; escape - SYSTEM - unimplemented command
    66                          ; .word  scale-1
    67                          
    68  284c 683c                                !word help-1
    69  284e ec44                                !word do-1
    70  2850 8e45                                !word loop-1
    71  2852 4145                                !word exit-1
    72  2854 9f6f                                !word directory-1
    73  2856 4671                                !word dsave-1
    74  2858 6871                                !word dload-1
    75  285a 4a72                                !word header-1
    76  285c d372                                !word scratch-1
    77  285e 6473                                !word collect-1
    78  2860 7b73                                !word dcopy-1
    79  2862 c773                                !word rename-1
    80  2864 d973                                !word backup-1
    81  2866 e741                                !word delete-1
    82  2868 123e                                !word renumber-1
    83  286a d445                                !word key-1
    84  286c 55ff                                !word _monitor-1
    85  286e 4647                                !word bank-1                             ; escape
    86  2870 154a                                !word filter-1                           ; escape
    87  2872 4d47                                !word play-1                             ; escape
    88  2874 8449                                !word tempo-1                            ; escape
    89                          
    90  2876 bfb5                                !word movspr-1                           ; escape
    91  2878 28b5                                !word sprite-1                           ; escape
    92  287a 05b8                                !word sprcolor-1                         ; escape
    93                          
    94  287c 9f3b                                !word rreg-1                             ; escape
    95  287e a34a                                !word envelope-1                         ; escape
    96  2880 c054                                !word sleep-1                            ; escape
    97  2882 9f6f                                !word directory-1                        ; escape
    98  2884 d170                                !word dopen-1                            ; escape
    99  2886 e770                                !word append-1                           ; escape
   100  2888 2f71                                !word dclose-1                           ; escape
   101  288a 9071                                !word bsave-1                            ; escape
   102  288c e171                                !word bload-1                            ; escape
   103  288e 0a73                                !word record-1                           ; escape
   104  2890 b773                                !word concat-1                           ; escape
   105  2892 6571                                !word dverify-1                          ; escape
   106  2894 5473                                !word dclear-1                           ; escape
   107                          
   108  2896 1bb8                                !word sprsav-1                           ; escape
   109  2898 dbb8                                !word collision-1                        ; escape
   110                          
   111  289a 4735                                !word data-1                             ; escape - BEGIN
   112  289c 4735                                !word data-1                             ; escape - BEND
   113  289e 5f4c                                !word window-1                           ; escape
   114  28a0 4e67                                !word boot-1                             ; escape
   115                          
   116  28a2 3a2e                                !word bad_command-1
   117                          ; .word  set_width-1 ;escape - WIDTH
   118                          
   119  28a4 3a2e                                !word bad_command-1
   120                          ; .word  sprdef-1  ;escape - Sprite Definition mode
   121                          
   122  28a6 3a2e                                !word bad_command-1                      ; escape - QUIT - unimplemented command
   123  28a8 333b                                !word dma-1                              ; escape
   124  28aa 0000                                !word 0                                  ; placeholder to skip over the space character
   125  28ac 333b                                !word dma-1                              ; escape
   126  28ae 0000                                !word 0                                  ; placeholder to skip over the quote character
   127  28b0 333b                                !word dma-1                              ; escape
   128  28b2 3a2e                                !word bad_command-1                      ; escape - OFF - unimplemented command
   129  28b4 c54c                                !word fast-1                             ; escape
   130  28b6 ce4c                                !word slow-1                             ; escape
   131  28b8 166f                                !word type-1                             ; escape (C65: type SEQ file)
   132  28ba de71                                !word bverify-1                          ; escape (C65: verify BINary file)
   133  28bc 492e                                !word snerr-1                            ; escape (C65: kludge- dirECTORY)
   134  28be d372                                !word scratch-1                          ; escape (C65: erase alias for scratch)
   135  28c0 8842                                !word find-1                             ; escape (C65: find BASIC text)
   136  28c2 8b42                                !word change-1                           ; escape (C65: change BASIC text)
   137                          
   138  28c4 1ab2                                !word C65__set-1                         ; escape (C65: multi-purpose command)
   139  28c6 ffae                                !word Screen-1                           ; escape (C65: SCREEN)
   140  28c8 bbb1                                !word C65__polygon-1                     ; escape (C65: POLYGON)
   141  28ca 86b1                                !word C65__ellipse-1                     ; escape (C65: ELLIPSE)
   142  28cc 14b4                                !word C65__Viewport-1                    ; escape (C65: VIEWPORT)
   143  28ce 4fb4                                !word C65__copy-1                        ; escape (C65: GCOPY)
   144  28d0 b7af                                !word C65__setpen-1                      ; escape (C65: PEN)
   145  28d2 45b0                                !word C65__setpalette-1                  ; escape (C65: PALETTE)
   146  28d4 cbaf                                !word C65__setdmode-1                    ; escape (C65: DMODE)
   147  28d6 01b0                                !word C65__setdpat-1                     ; escape (C65: DPAT)
   148  28d8 4a72                                !word header-1                           ; format alias for header command [911017]
   149  28da 52b4                                !word genlock-1                          ; [910108]
   150                          
   151                          stmdsp2
   152  28dc dab4                                !word foreground-1                       ; this is the 128th command!  [910109]
   153  28de 0000                                !word 0                                  ; placeholder to skip over the colon character
   154  28e0 fbb4                                !word background-1
   155  28e2 02b5                                !word border-1
   156  28e4 e0b4                                !word highlight-1
   157  28e6 ef7b                                !word mouse-1                            ; [910122]
   158  28e8 8c7c                                !word rmouse-1                           ; [910123]
   159  28ea 796f                                !word disk-1                             ; [910123]
   160  28ec 277d                                !word cursor-1                           ; [910228]
   161  28ee 807d                                !word rcursor-1                          ; [910228]
   162  28f0 aeb3                                !word loadiff-1                          ; [910402]
   163  28f2 eab3                                !word saveiff-1                          ; [910930]
   164  28f4 c6bc                                !word edit-1                             ; [910620]
   165                          
   166                          
   167                          fundsp
   168  28f6 cf62                                !word sgn
   169  28f8 6363                                !word int
   170  28fa ee62                                !word abs
   171  28fc f702                                !word usrpok
   172  28fe 1355                                !word fre
   173  2900 ce58                                !word pos
   174  2902 bc65                                !word sqr
   175  2904 2358                                !word rnd
   176  2906 0e60                                !word log
   177  2908 0766                                !word exp
   178  290a 9e66                                !word cos
   179  290c a566                                !word sin
   180  290e ee66                                !word tan
   181  2910 1f67                                !word atn
   182  2912 c755                                !word peek
   183  2914 565a                                !word len
   184  2916 a559                                !word strd
   185  2918 4655                                !word val
   186  291a 655a                                !word asc
   187  291c b659                                !word chrd
   188  291e cc59                                !word leftd
   189  2920 ff59                                !word rightd
   190  2922 105a                                !word midd
   191  2924 26b9                                !word rgraphic                           ; [910701]
   192  2926 ffb8                                !word rcolor                             ; [910701]
   193  2928 0000                                !word 0                                  ; placeholder for escape function token
   194  292a ae56                                !word joy
   195  292c 9bb9                                !word rpen                               ; was rdot     [910820]
   196  292e 7855                                !word dcml                               ; dec
   197  2930 6f56                                !word hexd
   198  2932 1856                                !word errd
   199  2934 f356                                !word pot                                ; escape
   200  2936 9cba                                !word bump                               ; escape
   201  2938 5257                                !word lpen                               ; escape
   202  293a 5aba                                !word rsppos                             ; escape
   203  293c 0fba                                !word rsprite                            ; escape
   204  293e 45ba                                !word rspcolor                           ; escape
   205  2940 9557                                !word xor                                ; escape
   206  2942 fa57                                !word rwindow                            ; escape
   207  2944 7457                                !word pointer                            ; escape
   208  2946 b757                                !word mod                                ; escape c65     [910402]
   209  2948 76b9                                !word pixel                              ; escape c65     [910820]
   210  294a b8b9                                !word rpalette                           ; escape c65     [910820]
   211                          
   212                          
   213  294c 79                 optab            !text 121
   214  294d bd5d                                !word faddt-1
   215  294f 79                                  !text 121
   216  2950 a75d                                !word fsubt-1
   217  2952 7b                                  !text 123
   218  2953 6f60                                !word fmultt-1
   219  2955 7b                                  !text 123
   220  2956 8461                                !word fdivt-1
   221  2958 7f                                  !text 127
   222  2959 c565                                !word fpwrt-1
   223  295b 50                                  !text 80
   224  295c 9a2d                                !word andop-1
   225  295e 46                                  !text 70
   226  295f 972d                                !word orop-1
   227  2961 7d                 negtab           !text 125
   228  2962 fb65                                !word negop-1
   229  2964 5a                                  !text 90
   230  2965 324e                                !word notop-1
   231  2967 64                 ptdorl           !text 100
   232  2968 c72d                                !word dorel-1
   233                          
   234                          ;.end

; ******** Source: basic.asm

; ******** Source: tokeniser/const.asm
     1                          
     2                          
     3                          end_token        = $80                                    ; v2 commands
     4                          for_token        = $81
     5                          next_token       = $82
     6                          data_token       = $83
     7                          input_token      = $84
     8                          goto_token       = $89
     9                          run_token        = $8a
    10                          restore_token    = $8c
    11                          gosub_token      = $8d
    12                          rem_token        = $8f
    13                          on_token         = $91
    14                          load_token       = $93
    15                          save_token       = $94
    16                          verify_token     = $95
    17                          def_token        = $96
    18                          print_token      = $99
    19                          clr_token        = $9c
    20                          sys_token        = $9e
    21                          open_token       = $9f
    22                          close_token      = $a0
    23                          new_token        = $a2
    24                          tab_token        = $a3
    25                          to_token         = $a4
    26                          fn_token         = $a5
    27                          spc_token        = $a6
    28                          then_token       = $a7
    29                          not_token        = $a8
    30                          step_token       = $a9
    31                          plus_token       = $aa                                    ; operators
    32                          minus_token      = $ab
    33                          greater_token    = $b1
    34                          equal_token      = $b2
    35                          less_token       = $b3
    36                          first_function_token = $b4                                    ; v2 functions
    37                          left_token       = $c8
    38                          mid_token        = $ca
    39                          go_token         = $cb                                    ; kludges
    40                          rgraphic_token   = $cc                                    ; first new v7 token
    41                          esc_function_token = $ce
    42                          err_token        = $d3
    43                          instr_token      = $d4
    44                          last_function_token = $d4
    45                          else_token       = $d5
    46                          resume_token     = $d6
    47                          trap_token       = $d7
    48                          color_token      = $e7
    49                          do_token         = $eb
    50                          loop_token       = $ec
    51                          key_token        = $f9
    52                          monitor_token    = $fa
    53                          using_token      = $fb
    54                          until_token      = $fc
    55                          while_token      = $fd
    56                          esc_command_token = $fe
    57                          
    58                          first_esc_command_token = $02
    59                          collision_token  = $17
    60                          begin_token      = $18
    61                          bend_token       = $19
    62                          off_token        = $24
    63                          ectory_token     = $29
    64                          set_token        = $2d
    65                          pic_token        = $37
    66                          disk_token       = $40
    67                          last_esc_command_token = $45                                    ; <<<< last_command_token
    68                          
    69                          first_esc_function_token = $02
    70                          pointer_token    = $0a
    71                          last_esc_function_token = $0d                                    ; [910820]
    72                          

; ******** Source: basic.asm

; ******** Source: error/messages.asm
     1                          
     2                          
     3                          ok_error_message
     4  296a 4fcb                                !text "O",'K'+$80                        ; 0 for ERR$ [910911]
     5                          error_message_list
     6  296c 544f4f204d414e59...                 !text "TOO MANY FILE",'S'+$80            ; 1
     7  297a 46494c45204f5045...                 !text "FILE OPE",'N'+$80                 ; 2
     8  2983 46494c45204e4f54...                 !text "FILE NOT OPE",'N'+$80             ; 3
     9  2990 46494c45204e4f54...                 !text "FILE NOT FOUN",'D'+$80            ; 4
    10  299e 444556494345204e...                 !text "DEVICE NOT PRESEN",'T'+$80        ; 5
    11  29b0 4e4f5420494e5055...                 !text "NOT INPUT FIL",'E'+$80            ; 6
    12  29be 4e4f54204f555450...                 !text "NOT OUTPUT FIL",'E'+$80           ; 7
    13  29cd 4d495353494e4720...                 !text "MISSING FILE NAM",'E'+$80         ; 8
    14  29de 494c4c4547414c20...                 !text "ILLEGAL DEVICE NUMBE",'R'+$80     ; 9
    15  29f3 4e45585420574954...                 !text "NEXT WITHOUT FO",'R'+$80          ; 10
    16  2a03 53594e5441d8                        !text "SYNTA",'X'+$80                    ; 11
    17  2a09 52455455524e2057...                 !text "RETURN WITHOUT GOSU",'B'+$80      ; 12
    18  2a1d 4f5554204f462044...                 !text "OUT OF DAT",'A'+$80               ; 13
    19  2a28 494c4c4547414c20...                 !text "ILLEGAL QUANTIT",'Y'+$80          ; 14
    20  2a38 4f564552464c4fd7                    !text "OVERFLO",'W'+$80                  ; 15
    21  2a40 4f5554204f46204d...                 !text "OUT OF MEMOR",'Y'+$80             ; 16
    22  2a4d 554e444546274420...                 !text "UNDEF",$27,"D STATEMEN",'T'+$80   ; 17
    23  2a5e 4241442053554253...                 !text "BAD SUBSCRIP",'T'+$80             ; 18
    24  2a6b 524544494d274420...                 !text "REDIM",$27,"D ARRA",'Y'+$80       ; 19
    25  2a78 4449564953494f4e...                 !text "DIVISION BY ZER",'O'+$80          ; 20
    26  2a88 494c4c4547414c20...                 !text "ILLEGAL DIREC",'T'+$80            ; 21
    27  2a96 54595045204d4953...                 !text "TYPE MISMATC",'H'+$80             ; 22
    28  2aa3 535452494e472054...                 !text "STRING TOO LON",'G'+$80           ; 23
    29  2ab2 46494c4520444154...                 !text "FILE DAT",'A'+$80                 ; 24
    30  2abb 464f524d554c4120...                 !text "FORMULA TOO COMPLE",'X'+$80       ; 25
    31  2ace 43414e275420434f...                 !text "CAN",$27,"T CONTINU",'E'+$80      ; 26
    32  2adc 554e444546274420...                 !text "UNDEF'D FUNCTIO",'N'+$80          ; 27
    33  2aec 5645524946d9                        !text "VERIF",'Y'+$80                    ; 28
    34  2af2 4c4f41c4                            !text "LOA",'D'+$80                      ; 29
    35  2af6 42524541cb                          !text "BREA",'K'+$80                     ; 30 ???? null & space [910925]
    36  2afb 43414e2754205245...                 !text "CAN'T RESUM",'E'+$80              ; 31
    37  2b07 4c4f4f50204e4f54...                 !text "LOOP NOT FOUN",'D'+$80            ; 32
    38  2b15 4c4f4f5020574954...                 !text "LOOP WITHOUT D",'O'+$80           ; 33
    39  2b24 444952454354204d...                 !text "DIRECT MODE ONL",'Y'+$80          ; 34
    40                          ; .byte 'NO GRAPHICS ARE','A'+$80   ;35
    41  2b34 53435245454e204e...                 !text "SCREEN NOT OPE",'N'+$80           ; 35    [911001]
    42  2b43 42414420444953cb                    !text "BAD DIS",'K'+$80                  ; 36 ???? used for failed bootsys
    43  2b4b 42454e44204e4f54...                 !text "BEND NOT FOUN",'D'+$80            ; 37
    44  2b59 4c494e45204e554d...                 !text "LINE NUMBER TOO LARG",'E'+$80     ; 38
    45  2b6e 554e5245534f4c56...                 !text "UNRESOLVED REFERENC",'E'+$80      ; 39
    46  2b82 554e494d504c454d...                 !text "UNIMPLEMENTED COMMAN",'D'+$80     ; 40
    47  2b97 46494c4520524541...                 !text "FILE REA",'D'+$80                 ; 41
    48  2ba0 45444954204d4f44...                 !text "EDIT MOD",'E'+$80                 ; 42    [910620]
    49                          
    50                          

; ******** Source: basic.asm

; ******** Source: error/constants.asm
     1                          
     2                          errtmf           = 1
     3                          errfno           = 3
     4                          errfnf           = 4
     5                          err_missing_fname = 8
     6                          err_illegal_device = 9
     7                          errnf            = 10
     8                          errsn            = 11
     9                          errrg            = 12
    10                          errod            = 13
    11                          errfc            = 14
    12                          errov            = 15
    13                          errom            = 16
    14                          errus            = 17
    15                          errbs            = 18
    16                          errdd            = 19
    17                          errdvo           = 20
    18                          errid            = 21
    19                          errtm            = 22
    20                          errls            = 23
    21                          errbd            = 24
    22                          errst            = 25
    23                          errcn            = 26
    24                          erruf            = 27
    25                          ervfy            = 28
    26                          erload           = 29
    27                          erbrk            = 30
    28                          errcr            = 31
    29                          errlnf           = 32
    30                          errlwd           = 33
    31                          erroid           = 34
    32                          errng            = 35
    33                          errbdk           = 36
    34                          err_no_bend      = 37
    35                          err_too_large    = 38
    36                          err_ref          = 39
    37                          err_bad_command  = 40
    38                          err_file_read    = 41
    39                          edit_mode_error  = 42                                     ; [910620]
    40                          last_error_message = 42                                     ; # of last error msg
    41                          
    42                          ;.end

; ******** Source: basic.asm

; ******** Source: error/message.asm
     1                          
     2                          
     3                          ; Routine to translate error message # in .a
     4                          ; into address of string containing message in index2
     5                          
     6  2ba9 aa                 erstup           tax                                      ; error set up
     7  2baa a000                                ldy #0                                   ; start with address of first error message
     8  2bac a96c                                lda #<error_message_list
     9  2bae 8526                                sta index2
    10  2bb0 a929                                lda #>error_message_list
    11  2bb2 8527                                sta index2+1
    12                          
    13  2bb4 ca                 l11_1            dex
    14  2bb5 300a                                bmi l11_3                                ; finished when .x decrements out
    15                          
    16  2bb7 b126               l11_2            lda (index2),y                           ; look at msg, and find end (msb set) (ind.ok)
    17  2bb9 e326                                inw index2
    18  2bbb 29ff                                and #$ff                                 ; was msb set?
    19  2bbd 10f8                                bpl l11_2                                ; no, not end of message
    20  2bbf 80f3                                bra l11_1                                ; yes, tick off another msg
    21                          
    22  2bc1 60                 l11_3            rts
    23                          

; ******** Source: basic.asm

; ******** Source: system/dispatcher.asm
     1                          
     2                          
     3                          
     4                          ; Here for new statement. Character -> by txtptr is ':' or eol. The adr of
     5                          ; this loc is left on the stack when a statement is executed so that it can
     6                          ; merely do a rts when it is done.
     7                          ; Get char, exit via xeqcm3, and return to newstt.
     8                          
     9  2bc2 6c0803             xeqcm            jmp (igone)
    10                          
    11                          ; Check if there is an interrupt from VIC that needs to be serviced
    12                          
    13  2bc5 7f7e3f             ngone            bbr7 runmod,l12_3                        ; get off here if we are in direct mode
    14  2bc8 addc02                              lda intval                               ; check if there is an interrupt already in progress
    15  2bcb 303a                                bmi l12_3                                ; yes, don't go any further
    16                          
    17  2bcd a202                                ldx #2                                   ; check for 3 types of interrupts: s/s, s/b, & lp
    18  2bcf bddd02             l12_1            lda int_trip_flag,x
    19  2bd2 f030                                beq l12_2                                ; this wasn't set, go check next
    20                          
    21  2bd4 a900                                lda #0
    22  2bd6 9ddd02                              sta int_trip_flag,x                      ; reset this flag to show 'serviced'
    23  2bd9 bde002                              lda int_adr_lo,x                         ; install the trap address as linnum
    24  2bdc 8516                                sta linnum
    25  2bde bde302                              lda int_adr_hi,x
    26  2be1 8517                                sta linnum+1
    27  2be3 da                                  phx                                      ; save counter & text pointer
    28  2be4 fc3d00                              phw txtptr
    29  2be7 a980                                lda #$80                                 ; flag 'no other interrupt traps, please'
    30  2be9 0cdc02                              tsb intval
    31                          
    32  2bec 208322                              jsr chrget                               ; skip over 2nd byte of line number
    33  2bef 20393d                              jsr gosub_sub                            ; fake a 'gosub' from here, so trap rx can do a RETURN
    34  2bf2 20063d                              jsr goto_1
    35  2bf5 200d2c                              jsr newstt
    36                          
    37  2bf8 a980                                lda #$80
    38  2bfa 1cdc02                              trb intval
    39  2bfd 68                                  pla
    40  2bfe 853e                                sta txtptr+1
    41  2c00 68                                  pla
    42  2c01 853d                                sta txtptr
    43  2c03 fa                                  plx
    44                          
    45  2c04 ca                 l12_2            dex
    46  2c05 10c8                                bpl l12_1
    47                          
    48                          
    49  2c07 208322             l12_3            jsr chrget                               ; get statement type
    50  2c0a 20522c             xeqdir           jsr xeqcm3
    51                          
    52  2c0d 20cc2c             newstt           jsr is_stop_key_down
    53  2c10 7f7e06                              bbr7 runmod,l13_1                        ; branch if direct mode
    54                          
    55                          ; In run mode...save txtptr for CONTinue command
    56                          
    57  2c13 20472c                              jsr tto                                  ; transfer txtptr to oldtxt
    58  2c16 ba                                  tsx
    59  2c17 8681                                stx oldstk
    60                          
    61  2c19 a000               l13_1            ldy #0
    62  2c1b 20c522                              jsr indtxt                               ; end of the line?
    63  2c1e d3a500                              +lbne morsts                             ; no...out of statement
    64                          
    65  2c21 247e               l13_2            bit runmod                               ; in direct mode?
    66  2c23 132802                              +lbpl ready                              ; yes, go to ready
    67  2c26 a002                                ldy #2
    68  2c28 20c522                              jsr indtxt                               ; end of text?
    69  2c2b f32002                              +lbeq ready                              ; yes...finished
    70  2c2e c8                                  iny                                      ; y=3
    71  2c2f 20c522                              jsr indtxt                               ; extract line# lo byte
    72  2c32 853b                                sta curlin
    73  2c34 c8                                  iny
    74  2c35 20c522                              jsr indtxt                               ; extract line # hi byte
    75  2c38 853c                                sta curlin+1
    76  2c3a 98                                  tya                                      ; y=4
    77  2c3b 18                                  clc
    78  2c3c 653d                                adc txtptr                               ; point @ character before line start
    79  2c3e 853d                                sta txtptr
    80  2c40 9002                                bcc l13_3
    81  2c42 e63e                                inc txtptr+1
    82  2c44 837cff             l13_3            +lbra xeqcm                              ; execute new line
    83                          
    84                          
    85                          
    86  2c47 a53d               tto              lda txtptr
    87  2c49 a43e                                ldy txtptr+1
    88  2c4b 8d7211                              sta oldtxt
    89  2c4e 8c7311                              sty oldtxt+1
    90  2c51 60                 xeqrts           rts
    91                          
    92                          
    93                          ; Set up for command processing and set processor address on stack.
    94                          ; Exit via jmp to CHRGET
    95                          
    96  2c52 f0fd               xeqcm3           beq xeqrts                               ; nothing here...null statement
    97  2c54 5f7e12                              bbr5 runmod,xeqcm2                       ; trcflg. branch if trace not enabled
    98  2c57 7f7e0f                              bbr7 runmod,xeqcm2                       ; branch if direct mode- can't trace
    99                          
   100  2c5a 48                                  pha                                      ; save token
   101  2c5b a95b                                lda #'['                                 ; print '[line-number]'
   102  2c5d 203d68                              jsr outch                                ; outdo
   103  2c60 207b64                              jsr curprt                               ; print curlin
   104  2c63 a95d                                lda #']'
   105  2c65 203d68                              jsr outch                                ; outdo
   106  2c68 68                                  pla                                      ; restore token
   107                          
   108                          
   109  2c69 c9fe               xeqcm2           cmp #esc_command_token                   ; special case: escape token
   110  2c6b f03e                                beq xeqesc
   111  2c6d c9cb                                cmp #go_token                            ; special case: go to
   112  2c6f f3ed10                              +lbeq go_without_to
   113  2c72 c9ca                                cmp #mid_token                           ; special case: mid$()=
   114  2c74 f02c                                beq xeqmid
   115                          
   116                          ; Command can be in the range END...NEW (old BASIC) & ELSE...MONITOR
   117                          ; (new extensions).  Although there is a gap between these two blocks,
   118                          ; it will be quickest & easiest to collapse them into one continuous block.
   119                          
   120  2c76 c9fb                                cmp #monitor_token+1
   121  2c78 b048                                bcs snerr1
   122  2c7a c9a3                                cmp #new_token+1
   123  2c7c 9006                                bcc xeqcm4                               ; no need to collapse
   124  2c7e c9d5                                cmp #else_token
   125  2c80 9040                                bcc snerr1
   126  2c82 e932                                sbc #else_token-new_token-1
   127                          
   128  2c84 38                 xeqcm4           sec                                      ; convert adjusted token into an index into a jump table.
   129  2c85 e980                                sbc #end_token
   130  2c87 93ed09                              +lbcc let                                ; it wasn't a token after all!  assume an assignment
   131                          
   132  2c8a 0a                 xeqcm5           asl                                      ; *2 to convert into word pointer
   133  2c8b a8                                  tay
   134  2c8c b009                                bcs l14_1                                ; dispatch table 1 or 2?     [901212]
   135  2c8e b9dd27                              lda stmdsp+1,y                           ; one
   136  2c91 48                                  pha
   137  2c92 b9dc27                              lda stmdsp,y
   138  2c95 8007                                bra l14_2
   139                          
   140  2c97 b9dd28             l14_1            lda stmdsp2+1,y                          ; two      [901212]
   141  2c9a 48                                  pha
   142  2c9b b9dc28                              lda stmdsp2,y
   143                          
   144  2c9e 48                 l14_2            pha
   145  2c9f 4c8322                              jmp chrget                               ; execution will commence after chrget's RTS
   146                          
   147                          
   148                          
   149                          xeqmid                                                    ; handle special case of MID$= (what we call a kludge)
   150  2ca2 a93b                                lda #>midwrk                             ; midd2-1
   151  2ca4 48                                  pha
   152  2ca5 a9e1                                lda #<midwrk
   153  2ca7 48                                  pha
   154                          xeqchr
   155  2ca8 4c8322                              jmp chrget
   156                          
   157                          
   158                          
   159                          
   160                          xeqesc                                                    ; execute escape token
   161  2cab 208322                              jsr chrget                               ; let's have us a look at the second char
   162  2cae f012                                beq snerr1                               ; oops, there wasn't any!
   163  2cb0 c902                                cmp #first_esc_command_token             ; is it one of our esc tokens?
   164  2cb2 9008                                bcc l15_1                                ; no, foreign.
   165  2cb4 c946                                cmp #last_esc_command_token+1
   166  2cb6 b004                                bcs l15_1                                ; foreign
   167                          
   168                          ; It's one of our own.  Convert to index into command dispatch table
   169                          
   170  2cb8 6947                                adc #monitor_token-else_token+new_token-end_token-first_esc_command_token+2
   171  2cba 80ce                                bra xeqcm5                               ; always
   172                          
   173  2cbc 38                 l15_1            sec                                      ; set up flag for a trip into the users code
   174  2cbd 6c1003                              jmp (iescex)
   175                          
   176  2cc0 90e6               nescex           bcc xeqchr                               ; jmp chrget
   177                          
   178  2cc2 838601             snerr1           +lbra snerr
   179                          
   180  2cc5 c93a               morsts           cmp #':'
   181  2cc7 f3f9fe                              +lbeq xeqcm                              ; if ':', continue statement
   182  2cca 80f6                                bra snerr1
   183                          

; ******** Source: basic.asm

; ******** Source: command/set1.asm
     1                          ; STOP, STOP KEY, and END handlers
     2                          ;
     3                          
     4                          is_stop_key_down
     5  2ccc 20e1ff                              jsr _stop                                ; test stop key
     6  2ccf d03b                                bne do_rts                               ; not down, exit
     7                          
     8                          ; ldy trapno+1  ;test if trap on????   removed [910925]
     9                          ; iny
    10                          ; beq stop_1  ;no, do a normal stop
    11                          
    12                          
    13                          break_exit                                                ; STOP KEY:     [910104]
    14  2cd1 20e1ff             l16_1            jsr _stop                                ; wait for the user to release the key
    15  2cd4 f0fb                                beq l16_1
    16  2cd6 a21e                                ldx #erbrk                               ; take the vector thru error to ready
    17  2cd8 837501                              +lbra error
    18                          
    19                          
    20                          
    21  2cdb b001               stop             bcs stopc                                ; STOP: .c=1
    22                          
    23  2cdd 18                 end              clc                                      ; END: .c=0
    24  2cde d36a01             stopc            +lbne snerr                              ; error if args present   [910410]
    25                          
    26  2ce1 7f7e0d             stop_1           bbr7 runmod,l17_1                        ; branch if direct mode
    27  2ce4 20472c                              jsr tto                                  ; transfer txtptr to oldtxt
    28  2ce7 a53b                                lda curlin
    29  2ce9 a43c                                ldy curlin+1
    30  2ceb 8d7011                              sta oldlin
    31  2cee 8c7111                              sty oldlin+1
    32  2cf1 68                 l17_1            pla                                      ; .diris
    33  2cf2 68                                  pla
    34  2cf3 935801                              +lbcc ready                              ; say 'ready' if END, say 'break' if STOP
    35                          
    36                          
    37  2cf6 20b438             break            jsr release_channels                     ; make sure we're in text mode????  [910909]
    38  2cf9 2027af                              jsr RestoreTextScreen
    39  2cfc 20dc3c                              jsr highlight_text                       ; ????      [910624]
    40  2cff 207dff                              jsr _primm
    41  2d02 0d425245414b00                      !text cr,"BREAK",0
    42  2d09 83ce01                              +lbra errfin                             ; exit via 'in line #'
    43                          
    44  2d0c 60                 do_rts           rts
    45                          

; ******** Source: basic.asm

; ******** Source: function/dispatch.asm
     1                          
     2                          
     3                          
     4                          ; At this point, eval has determined that the token in a has to be a
     5                          ; function.  It must therefor be in the range SGN...MID$ (old BASIC),
     6                          ; or RGR...INSTR (new extensions).  We will collapse these two disjoint
     7                          ; blocks into one continuous range.
     8                          ;
     9                          ; On entry, we can assume the token is >= 'sgn'
    10                          
    11  2d0d c9ce               isfun            cmp #esc_function_token                  ; is this an escape function?
    12  2d0f f059                                beq do_esc_fn                            ; yes
    13  2d11 c9d5                                cmp #last_function_token+1
    14  2d13 b0ad                                bcs snerr1                               ; no- must be syntax error
    15  2d15 c9cb                                cmp #mid_token+1
    16  2d17 9002                                bcc l18_1                                ; no need to adjust
    17  2d19 e901                                sbc #rgraphic_token-mid_token-1
    18                          
    19  2d1b 48                 l18_1            pha                                      ; save token
    20  2d1c aa                                  tax
    21  2d1d 208322                              jsr chrget                               ; set up for synchk.
    22  2d20 e0d3                                cpx #instr_token-1                       ; look for (adjusted) instr token
    23  2d22 f00d                                beq l18_2                                ; yes
    24  2d24 e0cb                                cpx #rgraphic_token-1                    ; look for rgraphic which now takes 2 args [910801]
    25  2d26 f3fe8b                              +lbeq rgraphic                           ; yes
    26                          
    27  2d29 e0cb                                cpx #mid_token+1
    28  2d2b b024                                bcs oknorm                               ; LEFT$,RIGHT$,MID$ require multiple args
    29  2d2d e0c8                                cpx #left_token                          ; is it past last single-arg function?
    30  2d2f 9020                                bcc oknorm                               ; no, must be normal function
    31                          
    32                          
    33                          ; Most functions take a single argument.  The return address of these functions
    34                          ; is CHKNUM, which ascertains that VALTYP=0 (numeric).  Normal functions which
    35                          ; return string results (eg. CHR$) must pop off that return address and return
    36                          ; directly to FRMEVL.
    37                          ;
    38                          ; The so called "funny" functions can take more than one argument, the first
    39                          ; of which must be string and the second of which must be a number between 0
    40                          ; and 255.  The closed parenthesis must be checked and return is directly to
    41                          ; FRMEVL with the text pointer pointing beyond the ")".  The pointer to the
    42                          ; description of the string argument is stored on the stack underneath the
    43                          ; value of the integer argument.
    44                          
    45  2d31 20584e             l18_2            jsr chkopn                               ; check for an open parenthesis
    46  2d34 20ef4c                              jsr frmevl                               ; eat open paren and first argument
    47  2d37 205b4e                              jsr chkcom                               ; two args so comma must delimit
    48  2d3a 20dd4c                              jsr chkstr                               ; make sure first was string
    49                          
    50  2d3d 68                                  pla                                      ; check token
    51  2d3e c9d3                                cmp #instr_token-1                       ; special case: INSTR() bails out here
    52  2d40 f32b41                              +lbeq instr
    53  2d43 a667                                ldx facmo+1                              ; push address of string arg1
    54  2d45 da                                  phx
    55  2d46 a666                                ldx facmo
    56  2d48 da                                  phx
    57  2d49 48                                  pha                                      ; push token
    58  2d4a 206c5d                              jsr getbyt                               ; get arg2
    59  2d4d 68                                  pla                                      ; retrieve token
    60  2d4e da                                  phx                                      ; push value of arg2
    61  2d4f 8004                                bra fingo                                ; go set up to evaluate fn
    62                          
    63                          
    64                          
    65                          oknorm
    66  2d51 204f4e                              jsr parchk                               ; check for open parens, evaluate argument
    67  2d54 68                                  pla                                      ; restore token
    68                          
    69                          fingo
    70  2d55 38                                  sec                                      ; convert token to index into jump table
    71  2d56 e9b4                                sbc #first_function_token
    72  2d58 0a                                  asl
    73  2d59 a8                                  tay
    74  2d5a b9f728                              lda fundsp+1,y
    75  2d5d 8558                                sta jmper+2
    76  2d5f b9f628                              lda fundsp,y
    77  2d62 8557                                sta jmper+1
    78  2d64 205600                              jsr jmper                                ; dispatch
    79                          ;string functions remove this ret addr
    80  2d67 83721f                              +lbra chknum                             ; check for "numeric-ness" and return
    81                          
    82                          
    83                          ; Escape Function handler
    84                          
    85                          do_esc_fn
    86  2d6a 208322                              jsr chrget                               ; get second token
    87  2d6d f3db00                              +lbeq snerr                              ; error if no second token
    88  2d70 c90a                                cmp #pointer_token
    89  2d72 f00b                                beq l19_1                                ; skip pre-parse if 'POINTER()'
    90  2d74 48                                  pha
    91  2d75 208322                              jsr chrget                               ; should be '('
    92  2d78 20584e                              jsr chkopn
    93  2d7b 20ef4c                              jsr frmevl                               ; evaluate first argument
    94  2d7e 68                                  pla
    95  2d7f c902               l19_1            cmp #first_esc_function_token            ; see if this esc fn is one of ours
    96  2d81 9008                                bcc foreign_esc_fn                       ; nope.
    97  2d83 c90e                                cmp #last_esc_function_token+1
    98  2d85 b004                                bcs foreign_esc_fn                       ; nope
    99                          
   100                          ; Convert to index into the function dispatch table
   101                          
   102  2d87 69d1                                adc #last_function_token-first_esc_function_token-1
   103  2d89 80ca                                bra fingo                                ; always
   104                          
   105                          
   106                          foreign_esc_fn
   107  2d8b 38                                  sec                                      ; flag 'up for grabs'
   108  2d8c 20952d                              jsr go_foreign_esc_fn
   109                          n_esc_fn_vec
   110  2d8f b3b900                              +lbcs snerr                              ; it's unwanted. off to the refuse pile
   111  2d92 83471f                              +lbra chknum
   112                          
   113                          go_foreign_esc_fn
   114  2d95 6cfc02                              jmp (esc_fn_vec)
   115                          
   116                          
   117  2d98 a0ff               orop             ldy #255                                 ; must always complement
   118  2d9a 2c                                  !text $2c
   119                          
   120  2d9b a000               andop            ldy #0
   121  2d9d 840d                                sty count                                ; operator
   122  2d9f 20b458                              jsr ayint                                ; (facmo&lo)=int value and check size
   123  2da2 a566                                lda facmo                                ; use Demorgan's Law on high
   124  2da4 450d                                eor count
   125  2da6 850a                                sta integr
   126  2da8 a567                                lda faclo                                ; and low
   127  2daa 450d                                eor count
   128  2dac 850b                                sta integr+1
   129  2dae 209362                              jsr movfa
   130  2db1 20b458                              jsr ayint                                ; (facmo&lo)=int of arg
   131  2db4 a567                                lda faclo
   132  2db6 450d                                eor count
   133  2db8 250b                                and integr+1
   134  2dba 450d                                eor count                                ; finish out Demorgan
   135  2dbc a8                                  tay                                      ; save high
   136  2dbd a566                                lda facmo
   137  2dbf 450d                                eor count
   138  2dc1 250a                                and integr
   139  2dc3 450d                                eor count
   140  2dc5 837820                              +lbra givayf                             ; float (a,y) and return to user
   141                          

; ******** Source: basic.asm

; ******** Source: operator/relational.asm
     1                          
     2                          ; Time to perform a relational operator.
     3                          ; (domask) contains the bits as to which relational operator it was.
     4                          ; Carry bit on = string compare.
     5                          
     6                          
     7  2dc8 20de4c             dorel            jsr chkval                               ; check for match
     8  2dcb b012                                bcs strcmp                               ; is it a string?
     9  2dcd a56f                                lda argsgn                               ; pack argument for fcomp
    10  2dcf 097f                                ora #$7f
    11  2dd1 256b                                and argho
    12  2dd3 856b                                sta argho
    13  2dd5 a96a                                lda #<argexp
    14  2dd7 a000                                ldy #>argexp
    15  2dd9 20f162                              jsr fcomp
    16  2ddc aa                                  tax
    17  2ddd 8033                                bra qcomp
    18                          
    19                          
    20  2ddf a900               strcmp           lda #0
    21  2de1 850f                                sta valtyp
    22  2de3 c64f                                dec opmask
    23  2de5 206d5b                              jsr frefac                               ; free the faclo string
    24  2de8 8563                                sta dsctmp                               ; save it for later
    25  2dea 8664                                stx dsctmp+1
    26  2dec 8465                                sty dsctmp+2
    27  2dee a56d                                lda argmo                                ; get pointer to other string
    28  2df0 a46e                                ldy argmo+1
    29  2df2 20715b                              jsr fretmp                               ; frees first desc pointer
    30  2df5 866d                                stx argmo
    31  2df7 846e                                sty argmo+1
    32  2df9 aa                                  tax                                      ; copy count into x
    33  2dfa 38                                  sec
    34  2dfb e563                                sbc dsctmp                               ; which is greater. if 0, all set up
    35  2dfd f008                                beq stasgn                               ; just put sign of difference away
    36  2dff a901                                lda #1
    37  2e01 9004                                bcc stasgn                               ; sign is positive
    38  2e03 a663                                ldx dsctmp                               ; length of fac is shorter
    39  2e05 a9ff                                lda #$ff                                 ; get a minus one for negatives
    40  2e07 8568               stasgn           sta facsgn                               ; keep for later
    41  2e09 a0ff                                ldy #255                                 ; set pointer to first string. (arg)
    42  2e0b e8                                  inx                                      ; to loop properly
    43  2e0c c8                 nxtcmp           iny
    44  2e0d ca                                  dex                                      ; any characters left to compare?
    45  2e0e d007                                bne getcmp                               ; not done yet
    46  2e10 a668                                ldx facsgn                               ; use sign of length difference
    47                          ;since all characters are the same
    48  2e12 301b               qcomp            bmi docmp                                ; c is always set then
    49  2e14 18                                  clc
    50  2e15 8018                                bra docmp                                ; always branch
    51                          
    52                          
    53  2e17 a96d               getcmp           lda #argmo
    54  2e19 20d722                              jsr lda_far_ram1                         ; lda (argmo),y from RAM1
    55  2e1c 48                                  pha
    56  2e1d a964                                lda #dsctmp+1
    57  2e1f 20d722                              jsr lda_far_ram1                         ; lda (dsctmp+1),y from RAM1
    58  2e22 8578                                sta syntmp
    59  2e24 68                                  pla
    60  2e25 c578                                cmp syntmp
    61  2e27 f0e3                                beq nxtcmp
    62  2e29 a2ff                                ldx #$ff
    63  2e2b b002                                bcs docmp
    64  2e2d a201                                ldx #1
    65                          
    66                          
    67                          
    68                          docmp
    69  2e2f e8                                  inx                                      ; -1 to 1, 0 to 2, 1 to 4
    70  2e30 8a                                  txa
    71  2e31 2a                                  rol
    72  2e32 2514                                and domask
    73  2e34 f002                                beq l20_1
    74  2e36 a9ff                                lda #$ff                                 ; map 0 to 0, map all others to -1
    75  2e38 839834             l20_1            +lbra float                              ; float the one-byte result into FAC
    76                          
    77                          
    78                          ;.end

; ******** Source: basic.asm

; ******** Source: system/readyerror.asm
     1                          
     2                          
     3                          bad_command
     4  2e3b a228                                ldx #err_bad_command                     ; unimplemented command
     5  2e3d 2c                                  !text $2c
     6                          
     7  2e3e a211               userr            ldx #errus                               ; undefined statement
     8  2e40 2c                                  !text $2c
     9                          
    10  2e41 a210               omerr            ldx #errom                               ; out of memory
    11  2e43 2c                                  !text $2c
    12                          
    13  2e44 a214               doverr           ldx #errdvo                              ; division by zero
    14  2e46 2c                                  !text $2c
    15                          
    16  2e47 a20f               overr            ldx #errov                               ; overflow
    17  2e49 2c                                  !text $2c
    18                          
    19  2e4a a20b               snerr            ldx #errsn                               ; syntax error
    20  2e4c 2c                                  !text $2c
    21                          
    22  2e4d a280               ready            ldx #$80                                 ; no error
    23                          
    24  2e4f 6c0003             error            jmp (ierror)
    25                          
    26  2e52 8a                 nerror           txa
    27  2e53 338f00                              +lbmi ready_1                            ; ...branch if no error (from 'ready')
    28  2e56 8ec702                              stx errnum                               ; save error # for 'er'
    29  2e59 7f7e3c                              bbr7 runmod,errisd                       ; branch if direct mode- always display error
    30                          
    31  2e5c a001                                ldy #1                                   ; copy curlin to errlin, oldtxt to errtxt
    32  2e5e b93b00             l21_1            lda curlin,y
    33  2e61 99c802                              sta errlin,y                             ; line# where error occurred
    34  2e64 b97211                              lda oldtxt,y
    35  2e67 99cd02                              sta errtxt,y                             ; statement where error occured
    36  2e6a 88                                  dey
    37  2e6b 10f1                                bpl l21_1
    38  2e6d eecd02                              inc errtxt                               ; point to a token, not ':' for HELP
    39  2e70 d003                                bne l21_2
    40  2e72 eece02                              inc errtxt+1
    41                          
    42  2e75 accb02             l21_2            ldy trapno+1                             ; is trap set?
    43  2e78 c0ff                                cpy #$ff
    44  2e7a f01c                                beq errisd                               ; no
    45  2e7c 8417                                sty linnum+1
    46  2e7e 8ccc02                              sty tmptrp                               ; save until a resume is executed
    47  2e81 acca02                              ldy trapno
    48  2e84 8416                                sty linnum
    49                          
    50  2e86 a2ff                                ldx #$ff
    51  2e88 8ecb02                              stx trapno+1                             ; flag no more traps
    52  2e8b a21b                                ldx #tempst                              ; clear any accumulated string temps
    53  2e8d 8618                                stx temppt
    54  2e8f a681                                ldx oldstk
    55  2e91 9a                                  txs
    56  2e92 201f3d                              jsr luk4it
    57  2e95 8376fd                              +lbra newstt
    58                          

; ******** Source: basic.asm

; ******** Source: error/handler.asm
     1  2e98 ca                 errisd           dex
     2  2e99 8a                                  txa
     3  2e9a 20a92b                              jsr erstup                               ; set up address of error msg in .a in index2
     4                          
     5  2e9d ff7e08                              bbs7 runmod,l22_1                        ; reset error line if direct mode error
     6  2ea0 a9ff                                lda #$ff
     7  2ea2 8dc802                              sta errlin                               ;
     8  2ea5 8dc902                              sta errlin+1
     9                          
    10  2ea8 20b438             l22_1            jsr release_channels                     ; restore output to screen    [910909]
    11  2eab 2027af                              jsr RestoreTextScreen                    ; make sure we're in text mode    [910404]
    12  2eae 200935                              jsr init_stack
    13                          
    14  2eb1 20f737             l22_2            jsr crdo                                 ; Print error message- start a new line with '?'
    15  2eb4 20dc3c                              jsr highlight_text                       ; use highlight color????    [910624]
    16  2eb7 206238                              jsr outqst
    17  2eba a000                                ldy #0
    18  2ebc b126               l22_3            lda (index2),y                           ; Read error msg from ROM  (ind.ok????)
    19  2ebe 48                                  pha
    20  2ebf 297f                                and #$7f
    21  2ec1 203d68                              jsr outch                                ; Print it
    22  2ec4 c8                                  iny
    23  2ec5 68                                  pla
    24  2ec6 10f4                                bpl l22_3
    25  2ec8 aec702                              ldx errnum                               ; retrieve error #     [910925]
    26  2ecb e01e                                cpx #erbrk
    27  2ecd f00a                                beq errfin                               ; skip 'error' crap if 'break'
    28  2ecf 207dff                              jsr _primm
    29  2ed2 204552524f5200                      !text " ERROR",0
    30                          
    31  2ed9 a43c               errfin           ldy curlin+1                             ; direct mode?
    32  2edb c8                                  iny
    33  2edc f003                                beq l23_1                                ; yes...no line #
    34  2ede 207364                              jsr inprt
    35  2ee1 20cb3c             l23_1            jsr highlight_done                       ; restore normal text color????    [910624]

; ******** Source: basic.asm

; ******** Source: system/interface.asm
     1                          
     2                          
     3                          ready_1
     4  2ee4 a980                                lda #%10000000
     5  2ee6 2090ff                              jsr _setmsg                              ; turn Kernel messages on
     6  2ee9 a9c0                                lda #%11000000
     7  2eeb 147e                                trb runmod                               ; turn run modes off, leave trace mode on????
     8                          
     9                          ready_2
    10  2eed cf7e0e                              bbs4 runmod,l24_1                        ; print appropriate system prompt
    11  2ef0 207dff                              jsr _primm                               ; Program mode: print 'ready.'
    12  2ef3 0d52454144592e0d...                 !text cr,"READY.",cr,0
    13  2efc 8009                                bra main
    14                          
    15  2efe 207dff             l24_1            jsr _primm                               ; Edit mode: print 'ok.'
    16  2f01 0d4f4b2e0d00                        !text cr,"OK.",cr,0
    17                          
    18                          
    19  2f07 6c0203             main             jmp (imain)                              ; MAIN INPUT LOOP
    20                          
    21  2f0a a2ff               nmain            ldx #$ff                                 ; set direct mode flag
    22  2f0c 863c                                stx curlin+1
    23  2f0e 201c31                              jsr InputLine                            ; get a line of input & buffer it

; ******** Source: basic.asm

; ******** Source: system/execute.asm
     1                          
     2                          execute_a_line                                            ; EXECUTE PLAIN TEXT IN BUFFER
     3  2f11 863d                                stx txtptr                               ; init buffer pointer
     4  2f13 843e                                sty txtptr+1
     5  2f15 208322                              jsr chrget                               ; get first character of null-terminated string
     6  2f18 aa                                  tax
     7  2f19 f0ec                                beq main                                 ; got null input
     8  2f1b 9009                                bcc l25_1                                ; got line number
     9  2f1d 201f23                              jsr crunch                               ; got text- tokenize buffer,
    10  2f20 208522                              jsr chrgot                               ; get first command (token),
    11  2f23 83e5fc                              +lbra xeqdir                             ; and execute it
    12                          
    13                          
    14                          ;ADD or DELETE NEW LINE
    15  2f26 202e32             l25_1            jsr linget                               ; evaluate line number, put into into linnum
    16  2f29 4f7e05                              bbr4 runmod,l25_2
    17  2f2c 20e1bc                              jsr edit_crunch                          ; if edit mode, find end of input   [910620]
    18  2f2f 8003                                bra l25_3
    19                          
    20  2f31 201f23             l25_2            jsr crunch                               ; tokenize rest of input if not edit mode
    21  2f34 840d               l25_3            sty count                                ; save length
    22  2f36 20fa31                              jsr FindLine                             ; locate line in program
    23  2f39 938300                              +lbcc nodel                              ; not found, go insert line into program

; ******** Source: basic.asm

; ******** Source: edit/shift.asm
     1                          
     2                          ; Test: IF new line is longer than the line it replaces,
     3                          ;  THEN IF there isn't enough room in memory to add this new line,
     4                          ;   THEN out-of-memory error
     5                          ;
     6                          ; Before this fix, the old line was deleted BEFORE testing if the new line fit.
     7                          ;
     8                          ; N.B.: I am assuming that lines cannot be greater than 255 chars, as is the
     9                          ; case where the line was entered "normally", that is, using LINGET.  The only
    10                          ; consequence of this assumption is that lines > 255 will fall prey to the
    11                          ; pre-fix problem mentioned above.
    12                          
    13  2f3c a000                                ldy #0
    14  2f3e 20ad22                              jsr indlow                               ; get lsb of the next line's starting address
    15  2f41 38                                  sec
    16  2f42 e561                                sbc lowtr                                ; subtract lsb of this line's starting address
    17  2f44 38                                  sec                                      ; ignore borrow (gives abs. value)
    18  2f45 e904                                sbc #4                                   ; allow for link & line number
    19  2f47 e50d                                sbc count                                ; compare with new length
    20  2f49 b016                                bcs l25_5                                ; new line is shorter, no problem
    21  2f4b 42                                  neg                                      ; convert to positive delta
    22                          
    23  2f4c a483                                ldy text_top+1                           ; get msb of end of text (.c=0)
    24  2f4e 6582                                adc text_top                             ; add our calculated delta to end of text
    25  2f50 9001                                bcc l25_4
    26  2f52 c8                                  iny
    27  2f53 ccd002             l25_4            cpy max_mem_0+1
    28  2f56 9009                                bcc l25_5                                ; result is less than top-of-memory: ok
    29  2f58 d3e7fe                              +lbne omerr                              ; msb >  top, overflow
    30  2f5b cdcf02                              cmp max_mem_0                            ; msb's the same, test lsb's
    31  2f5e b3e1fe                              +lbcs omerr                              ; lsb >= top, overflow
    32                          
    33                          ; Using DMA device to move text downwards (to delete or replace a line)...
    34                          ;
    35                          ; lowtr     = destination
    36                          ; (lowtr)    = pointer to source (via link bytes of line to be removed)
    37                          ; text_top-(lowtr) = number of bytes to move (text_top points to old top of text)
    38                          ; new text_top     = text_top -( (lowtr)-lowtr )
    39                          
    40  2f61 a561               l25_5            lda lowtr                                ; set up DMA destination
    41  2f63 8d4a01                              sta dma1_dest_lo
    42  2f66 a562                                lda lowtr+1
    43  2f68 8d4b01                              sta dma1_dest_hi
    44  2f6b a000                                ldy #0
    45  2f6d 20ad22                              jsr indlow                               ; set up DMA source (& delta)
    46  2f70 8d4701                              sta dma1_src_lo
    47  2f73 38                                  sec
    48  2f74 e561                                sbc lowtr
    49  2f76 8524                                sta index1                               ; (delta lo)
    50  2f78 c8                                  iny
    51  2f79 20ad22                              jsr indlow
    52  2f7c 8d4801                              sta dma1_src_hi
    53  2f7f e562                                sbc lowtr+1
    54  2f81 8525                                sta index1+1                             ; (delta hi)
    55  2f83 38                                  sec
    56  2f84 a582                                lda text_top                             ; set up DMA count
    57  2f86 ed4701                              sbc dma1_src_lo
    58  2f89 8d4501                              sta dma1_cnt_lo
    59  2f8c a583                                lda text_top+1
    60  2f8e ed4801                              sbc dma1_src_hi
    61  2f91 8d4601                              sta dma1_cnt_hi
    62                          
    63  2f94 a584                                lda text_bank
    64                          ; and #%00001111  ;      [910102]
    65                          ; and #%01111111  ;      [910520] F018A
    66  2f96 8d4901                              sta dma1_src_bank
    67  2f99 8d4c01                              sta dma1_dest_bank
    68                          
    69  2f9c a900                                lda #0
    70  2f9e 8d4401                              sta dma1_cmd                             ; dma command (copy, source=start)
    71  2fa1 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
    72  2fa4 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
    73                          
    74  2fa7 a201                                ldx #>dma1_cmd                           ; dma_list
    75  2fa9 a944                                lda #<dma1_cmd
    76  2fab 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
    77  2fae 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
    78                          
    79  2fb1 38                                  sec                                      ; calculate & set new text_top
    80  2fb2 a582                                lda text_top
    81  2fb4 e524                                sbc index1
    82  2fb6 8582                                sta text_top                             ; lo
    83  2fb8 a583                                lda text_top+1
    84  2fba e525                                sbc index1+1
    85  2fbc 8583                                sta text_top+1                           ; hi
    86                          ;fall into routine to insert new line (if any)
    87                          
    88                          
    89  2fbe 200935             nodel            jsr init_stack                           ; 'clearc' removed since text changes don't require trashing variables
    90  2fc1 20b930                              jsr link_program                         ; fix links
    91  2fc4 20dc44                              jsr error_clear                          ; clear HELP/error flag, assuming he fixed whatever caused current error, if any
    92                          
    93  2fc7 a000                                ldy #0
    94  2fc9 b13d                                lda (txtptr),y                           ; delete line? ("common")
    95  2fcb f33aff                              +lbeq main                               ; yes
    96                          
    97  2fce 18                 l26_1            clc                                      ; no...something to insert
    98  2fcf a483                                ldy text_top+1
    99  2fd1 a582                                lda text_top
   100  2fd3 845d                                sty hightr+1                             ; top of block to move (old text_top)
   101  2fd5 855c                                sta hightr
   102  2fd7 650d                                adc count                                ; number of characters in line to be inserted
   103  2fd9 9001                                bcc l26_2
   104  2fdb c8                                  iny
   105  2fdc 18                 l26_2            clc
   106  2fdd 6904                                adc #4                                   ; plus link and line #
   107  2fdf 9001                                bcc l26_3                                ; gives us destination of move (new text_top)
   108  2fe1 c8                                  iny
   109                          
   110  2fe2 855a               l26_3            sta highds                               ; destination of top
   111  2fe4 845b                                sty highds+1
   112  2fe6 ccd002                              cpy max_mem_0+1                          ; make sure new top doesn't crash into top of available ram
   113  2fe9 9009                                bcc l26_4                                ; ok
   114  2feb d354fe                              +lbne omerr                              ; out of memory, don't insert
   115  2fee cdcf02                              cmp max_mem_0
   116  2ff1 b34efe                              +lbcs omerr                              ; out of memory, don't insert
   117                          
   118  2ff4 8582               l26_4            sta text_top                             ; set new top of text
   119  2ff6 8483                                sty text_top+1
   120  2ff8 38                                  sec                                      ; compute number of things to move up
   121  2ff9 a55c                                lda hightr
   122  2ffb e561                                sbc lowtr                                ; (old top) - (adr where new line goes)
   123  2ffd a8                                  tay                                      ; lowtr was setup previously by FindLine call
   124  2ffe a55d                                lda hightr+1
   125  3000 e562                                sbc lowtr+1
   126  3002 aa                                  tax
   127                          
   128                          ; Using DMA device to copy data upwards...
   129                          ;
   130                          ; (hightr)   = source  (old top)
   131                          ; (highds)   = destination (new top)
   132                          ; .y, .x     = number of bytes to move
   133                          ; (lowtr)    = where to insert new line (starting with link bytes)
   134                          
   135  3003 c35c                                dew hightr                               ; (text_top-1) points to actual last byte
   136  3005 c35a                                dew highds
   137                          
   138                          ; lda dma_ctlr+3  ;dma controller version    [910520] F018A
   139                          ; and #1
   140                          ; beq l26_5   ; F018    removed [910808] F018B
   141  3007 a930                                lda #%00110000                           ; F018A, B
   142  3009 8d4401             l26_5            sta dma1_cmd                             ; command=copy, source=endpt   [910102]
   143  300c 8c4501                              sty dma1_cnt_lo                          ; count
   144  300f 8e4601                              stx dma1_cnt_hi
   145  3012 98                                  tya
   146  3013 0d4601                              ora dma1_cnt_hi
   147  3016 f02e                                beq l26_7                                ; special case= nothing to move???? should not happen
   148                          
   149  3018 a55c                                lda hightr
   150  301a a45d                                ldy hightr+1
   151  301c 8d4701                              sta dma1_src_lo                          ; source
   152  301f 8c4801                              sty dma1_src_hi
   153  3022 a55a                                lda highds
   154  3024 a45b                                ldy highds+1
   155  3026 8d4a01                              sta dma1_dest_lo                         ; destination
   156  3029 8c4b01                              sty dma1_dest_hi
   157  302c a584                                lda text_bank                            ; [910520] F018A
   158                          ; ldx dma1_cmd  ;version?    removed [910808] F018B
   159                          ; bne l26_6   ; F018A
   160                          ; and #%00001111  ;      [910102]
   161                          ; ora #%01000000  ;(copy source=endpoint)    [910102]
   162  302e 8d4901             l26_6            sta dma1_src_bank                        ; banks
   163  3031 8d4c01                              sta dma1_dest_bank
   164  3034 a900                                lda #0
   165  3036 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
   166  3039 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
   167  303c a201                                ldx #>dma1_cmd                           ; dma_list
   168  303e a944                                lda #<dma1_cmd
   169  3040 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
   170  3043 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
   171                          
   172                          ; Make links non-null to fool 'chead'
   173                          
   174  3046 a000               l26_7            ldy #0
   175  3048 a901                                lda #1
   176  304a a261                                ldx #lowtr
   177  304c 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=0 (bleed-thru)
   178  304f c8                                  iny
   179  3050 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=1 (bleed-thru)
   180                          
   181                          ; Put line number in text
   182                          
   183  3053 c8                                  iny
   184  3054 a516                                lda linnum
   185  3056 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=2 (bleed-thru)
   186  3059 c8                                  iny
   187  305a a517                                lda linnum+1
   188  305c 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=3 (bleed-thru)
   189                          
   190                          ; Advance 'lowtr' to start of line (past link bytes & line #)
   191                          
   192  305f 18                                  clc
   193  3060 a561                                lda lowtr
   194  3062 6904                                adc #4
   195  3064 8561                                sta lowtr
   196  3066 9002                                bcc l26_8
   197  3068 e662                                inc lowtr+1
   198                          
   199                          
   200                          ; Block move line to text
   201                          
   202  306a a40d               l26_8            ldy count                                ; use dma ???? [910925]
   203  306c 88                                  dey
   204                          
   205  306d b13d               l26_9            lda (txtptr),y                           ; (from common area)
   206  306f 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y   (bleed-thru)
   207  3072 88                                  dey
   208  3073 c0ff                                cpy #$ff
   209  3075 d0f6                                bne l26_9
   210                          
   211                          ; beq l26_9   ;special case= nothing to move???? should not happen
   212                          ; lda #0   ; F018A, B
   213                          ; sta dma1_cmd  ;command=copy, source=start
   214                          ; sty dma1_cnt_lo  ;count
   215                          ; sta dma1_cnt_hi
   216                          ;
   217                          ; lda txtptr
   218                          ; ldy txtptr+1
   219                          ; sta dma1_src_lo  ;source
   220                          ; sty dma1_src_hi
   221                          ; lda lowtr
   222                          ; ldy lowtr+1
   223                          ; sta dma1_dest_lo ;destination
   224                          ; sty dma1_dest_hi
   225                          ; lda text_bank  ;banks
   226                          ; sta dma1_dest_bank
   227                          ; lda #sys_bank  ;????
   228                          ; sta dma1_src_bank
   229                          ; sta dma1_subcmd  ;      [910520] F018A
   230                          ; sta dma_ctlr+2  ;dma_list bank
   231                          ; ldx #>dma1_cmd  ;dma_list
   232                          ; lda #<dma1_cmd
   233                          ; stx dma_ctlr+1  ;dma_list hi
   234                          ; sta dma_ctlr  ;dma_list lo & trigger
   235                          ;l26_9
   236  3077 20b930                              jsr link_program
   237  307a 201f35                              jsr reset_txtptr                         ; set up txtptr (was jsr runc)
   238                          
   239                          ; Test if AUTO in effect
   240                          
   241  307d a574                                lda autinc                               ; if in auto mode, increment val <> 0
   242  307f 0575                                ora autinc+1
   243  3081 f033                                beq l26_12                               ; not in
   244                          
   245  3083 a516                                lda linnum                               ; yes, construct new line number
   246  3085 18                                  clc
   247  3086 6574                                adc autinc
   248  3088 8565                                sta facho+1
   249  308a a517                                lda linnum+1
   250  308c 6575                                adc autinc+1
   251  308e b026                                bcs l26_12                               ; no auto if wrapped
   252  3090 c9fa                                cmp #$fa                                 ; test if # >= 64000
   253  3092 b022                                bcs l26_12                               ; no auto if so.
   254  3094 8564                                sta facho
   255  3096 a290                                ldx #$90
   256  3098 38                                  sec
   257  3099 20df62                              jsr floatc                               ; float it
   258  309c 208f64                              jsr fout                                 ; make it into a string
   259                          
   260  309f 78                                  sei                                      ; [910710]
   261  30a0 a200                                ldx #0                                   ; move string into kbd buffer
   262  30a2 bd0101             l26_10           lda fbuffr+1,x                           ; copy number formed into buffer, ignoring leading space
   263  30a5 f006                                beq l26_11                               ; a null marks end
   264  30a7 9db002                              sta _keyd,x
   265  30aa e8                                  inx
   266  30ab d0f5                                bne l26_10                               ; always
   267                          
   268  30ad a91d               l26_11           lda #29                                  ; cursor right
   269  30af 9db002                              sta _keyd,x
   270  30b2 e8                                  inx
   271  30b3 86d0                                stx _ndx
   272  30b5 58                                  cli                                      ; [910710]
   273                          
   274  30b6 834ffe             l26_12           +lbra main

; ******** Source: basic.asm

; ******** Source: system/linkprogram.asm
     1                          
     2                          
     3                          link_program
     4  30b9 a52d                                lda txttab
     5  30bb a42e                                ldy txttab+1
     6  30bd 8524                                sta index
     7  30bf 8425                                sty index+1
     8  30c1 18                                  clc
     9                          
    10  30c2 a000               chead            ldy #0
    11  30c4 20c122                              jsr indin1                               ; lda (index),y .. check for null link
    12  30c7 d006                                bne l27_1
    13  30c9 c8                                  iny
    14  30ca 20c122                              jsr indin1                               ; lda (index),y
    15  30cd f042                                beq lnkrts
    16                          
    17  30cf a003               l27_1            ldy #3                                   ; [900524]
    18  30d1 c8                 l27_2            iny                                      ; ???? very expensive loop ????
    19  30d2 c0fe                                cpy #254
    20  30d4 b01f                                bcs link_error                           ; failsafe- program is mangled  [910103]
    21  30d6 20c122                              jsr indin1                               ; lda (index),y
    22  30d9 d0f6                                bne l27_2
    23  30db c8                                  iny
    24  30dc 98                                  tya
    25  30dd 6524                                adc index
    26  30df 48                                  pha
    27  30e0 a000                                ldy #0
    28  30e2 a224                                ldx #index
    29  30e4 200c23                              jsr sta_far_ram0                         ; sta (index),y   (bleed-thru)
    30  30e7 98                                  tya
    31  30e8 6525                                adc index+1
    32  30ea c8                                  iny
    33  30eb 200c23                              jsr sta_far_ram0                         ; sta (index),y   (bleed-thru)
    34  30ee fa                                  plx
    35  30ef 8624                                stx index
    36  30f1 8525                                sta index+1
    37  30f3 80cd                                bra chead                                ; always
    38                          
    39                          
    40                          link_error                                                ; [910103]
    41  30f5 20dc3c                              jsr highlight_text                       ; [911119]
    42  30f8 207dff                              jsr _primm
    43  30fb 0d3f50524f475241...                 !text cr,"?PROGRAM MANGLED",cr,0
    44  310e 20cb3c                              jsr highlight_done                       ; [911119]
    45                          
    46                          
    47  3111 60                 lnkrts           rts

; ******** Source: basic.asm

; ******** Source: command/input/handler.asm
     1                          
     2                          
     3                          ; Function to get a line one character at a time from the input
     4                          ; channel and build it in the input buffer.
     5                          ;
     6                          
     7                          PromptedInput                                             ; qinlin.
     8  3112 a515                                lda channl                               ; entry for things line INPUT, wanting a prompt
     9  3114 d006                                bne InputLine                            ; prompt only if terminal
    10  3116 206238                              jsr outqst                               ; yes- print '? '
    11  3119 205f38                              jsr realsp
    12                          
    13                          
    14                          InputLine                                                 ; inlin.
    15  311c a200                                ldx #0                                   ; read & buffer data until 'return' or buffer full
    16  311e 204368             l28_1            jsr inchr                                ; get a character
    17  3121 c900                                cmp #0
    18  3123 f00f                                beq l28_2
    19  3125 c90d                                cmp #cr                                  ; a carriage return?
    20  3127 f00b                                beq l28_2                                ; yes...done build
    21                          
    22  3129 9d0002                              sta buf,x                                ; no...buffer it
    23  312c e8                                  inx
    24  312d e0a1                                cpx #buflen                              ; buffer full?
    25  312f 90ed                                bcc l28_1                                ; no...continue
    26  3131 833d45                              +lbra errlen                             ; yes...string too long error
    27                          
    28                          
    29  3134 a900               l28_2            lda #0                                   ; fininl.  terminate input with a null
    30  3136 9d0002                              sta buf,x
    31  3139 a2ff                                ldx #<buf_txtptr                         ; set up pointer to start of buffer-1 (for chrget)
    32  313b a001                                ldy #>buf_txtptr
    33  313d a515                                lda channl                               ; print 'return' only if terminal
    34  313f f3b606                              +lbeq crdo
    35  3142 60                                  rts
    36                          
    37                          ;.end

; ******** Source: basic.asm

; ******** Source: system/stack.asm
     1                          
     2                          
     3                          
     4                          ; Find a specific token in the run-time stack. token to be found is in srchtk.
     5                          ;
     6                          ; If called by 'for' or 'next', scan entries in stack, looking for a specific
     7                          ; 'for-variable' (in (forpnt)).  If found, (fndpnt) will point to it, and z is
     8                          ; set.  Otherwise, (fndpnt) will point to either:
     9                          ;  1) the non-for token
    10                          ;  2) bottom-of-stack
    11                          ;
    12                          ; Special case: 'next' with no argument will match first 'for' entry on stack
    13                          ; found, if any.  This case is signaled by a (forpnt) with a msb of $ff (an
    14                          ; impossible value).
    15                          ;
    16                          ; All other calls to search will result in either:
    17                          ;  1) (success) z = 1, (fndpnt) = address
    18                          ;  2) (failure) z = 0
    19                          
    20                          
    21                          ; Set up temporary pointer with current top of stack
    22                          
    23  3143 8502               search           sta srchtk                               ; save token to search for
    24  3145 20dd31                              jsr movtos                               ; tos => fndpnt
    25                          
    26                          
    27                          ; Test if pointer is at bottom of stack.  If so, the item was not found.
    28                          
    29  3148 a53f               l29_1            lda fndpnt
    30  314a c9ff                                cmp #<stkbot
    31  314c d006                                bne l29_2                                ; (fndpnt) <> bottom, ok
    32  314e a540                                lda fndpnt+1                             ; lsb's the same, test msb's
    33  3150 c905                                cmp #>stkbot
    34  3152 f03d                                beq l29_6                                ; stack empty, rts
    35                          
    36  3154 a000               l29_2            ldy #0
    37  3156 a502                                lda srchtk                               ; what are we looking for?
    38  3158 c981                                cmp #for_token                           ; 'for' tokens are special cases
    39  315a d01b                                bne l29_4
    40                          
    41                          ; Looking for a 'for' token.  If next token examined is not a 'for' token,
    42                          ; return with z = 0.  Otherwise, check the pointer to its 'for' variable.
    43                          ; If the variable pointer = (forpnt) or if (forpnt) = $FFxx, return with z=1.
    44                          ; Otherwise, set up x with length of a 'for' entry, and use the usual
    45                          ; mechanisim for examining the next entry.
    46                          
    47  315c d13f                                cmp (fndpnt),y                           ; indirect ok- looking at runtime stack????
    48  315e d033                                bne l29_7                                ; not 'for', do rts with z = 0
    49  3160 a002                                ldy #2                                   ; point to msb of 'for' variable
    50  3162 a54c                                lda forpnt+1
    51  3164 c9ff                                cmp #$ff
    52  3166 f02b                                beq l29_7                                ; do rts with z = 1
    53  3168 d13f                                cmp (fndpnt),y
    54  316a d007                                bne l29_3                                ; not right variable, keep looking.
    55  316c 88                                  dey
    56  316d a54b                                lda forpnt                               ; test lsb
    57  316f d13f                                cmp (fndpnt),y
    58  3171 f020                                beq l29_7                                ; a hit! rts with z = 1
    59                          
    60  3173 a212               l29_3            ldx #lenfor
    61  3175 800e                                bra l29_5                                ; keep looking
    62                          
    63  3177 b13f               l29_4            lda (fndpnt),y
    64  3179 c502                                cmp srchtk                               ; is this the correct type of entry?
    65  317b f016                                beq l29_7                                ; rts with z = 1
    66                          
    67                          ; The entry on top of the run-time stack is not the entry we are looking for.
    68                          ; Find out what is there, and advance temp. pointer past it.
    69                          
    70  317d a212                                ldx #lenfor                              ; is it a 'for' entry?
    71  317f c981                                cmp #for_token
    72  3181 f002                                beq l29_5
    73  3183 a205                                ldx #5                                   ; must be gosub or do by default
    74                          
    75  3185 8a                 l29_5            txa
    76  3186 18                                  clc
    77  3187 653f                                adc fndpnt
    78  3189 853f                                sta fndpnt
    79  318b 90bb                                bcc l29_1
    80  318d e640                                inc fndpnt+1
    81  318f 80b7                                bra l29_1                                ; always
    82                          
    83  3191 a001               l29_6            ldy #1                                   ; clear z flag
    84  3193 60                 l29_7            rts
    85                          
    86                          
    87                          ; GETSTK
    88                          ;
    89                          ; Add (.A) elements to top of run-time stack.  Error if result exceeds tos.
    90                          
    91  3194 49ff               getstk           eor #$ff                                 ; make value 2's comp.
    92  3196 38                                  sec
    93  3197 657c                                adc tos
    94  3199 857c                                sta tos
    95  319b a47d                                ldy tos+1
    96  319d b001                                bcs l30_1
    97  319f 88                                  dey
    98  31a0 847d               l30_1            sty tos+1
    99  31a2 c004                                cpy #>stktop
   100  31a4 939bfc                              +lbcc omerr
   101  31a7 d005                                bne l30_2
   102  31a9 c57c                                cmp tos
   103  31ab 9394fc                              +lbcc omerr
   104  31ae 60                 l30_2            rts
   105                          
   106                          
   107                          ; (a,y) is a certain address.  REASON makes sure it is less than (fretop).
   108                          
   109  31af c436               reason           cpy fretop+1
   110  31b1 9029                                bcc l31_4
   111  31b3 d004                                bne l31_1                                ; go garbage collect
   112  31b5 c535                                cmp fretop
   113  31b7 9023                                bcc l31_4
   114                          
   115  31b9 48                 l31_1            pha
   116  31ba a209                                ldx #9                                   ; if tempf2 has zero in between
   117  31bc 98                                  tya
   118                          
   119  31bd 48                 l31_2            pha
   120  31be b559                                lda highds-1,x                           ; save highds on stack
   121  31c0 ca                                  dex
   122  31c1 10fa                                bpl l31_2                                ; put 8 of them on stack
   123  31c3 20335c                              jsr garba2                               ; go garbage collect
   124  31c6 a2f7                                ldx #$f7
   125                          
   126  31c8 68                 l31_3            pla
   127  31c9 9563                                sta highds+9,x                           ; restore after garbage collect
   128  31cb e8                                  inx
   129  31cc 30fa                                bmi l31_3
   130  31ce 7a                                  ply
   131  31cf 68                                  pla                                      ; restore .a and .y
   132  31d0 c436                                cpy fretop+1                             ; compare highs
   133  31d2 9008                                bcc l31_4
   134  31d4 d36bfc                              +lbne omerr                              ; higher is bad
   135  31d7 c535                                cmp fretop                               ; compare the lows
   136  31d9 b366fc                              +lbcs omerr
   137  31dc 60                 l31_4            rts
   138                          
   139                          
   140                          
   141                          ;  Utilities involved in the operation of the BASIC run-time stack.
   142                          
   143                          
   144                          ; Move top-of-stack pointer to (fndpnt)
   145                          
   146  31dd a57c               movtos           lda tos
   147  31df 853f                                sta fndpnt
   148  31e1 a57d                                lda tos+1
   149  31e3 8540                                sta fndpnt+1
   150  31e5 60                                  rts
   151                          
   152                          
   153                          
   154                          ; move (fndpnt) to (tos)
   155                          
   156  31e6 a53f               movfnd           lda fndpnt
   157  31e8 857c                                sta tos
   158  31ea a540                                lda fndpnt+1
   159  31ec 857d                                sta tos+1
   160  31ee 60                                  rts
   161                          
   162                          ; Reduce size of run-time stack by (y).  No error checking performed!
   163                          
   164  31ef 98                 rlsstk           tya
   165  31f0 18                                  clc
   166  31f1 657c                                adc tos
   167  31f3 857c                                sta tos
   168  31f5 9002                                bcc l32_1
   169  31f7 e67d                                inc tos+1
   170  31f9 60                 l32_1            rts
   171                          

; ******** Source: basic.asm

; ******** Source: system/linesearch.asm
     1                          
     2                          
     3                          
     4                          
     5                          ; FindLine
     6                          ; Searches the program text for the line whose number is passed in "linnum".
     7                          ; There are two possible returns:
     8                          ;
     9                          ; 1) carry set.
    10                          ;  Line found.  (lowtr) points to the link bytes of line sought.
    11                          ;
    12                          ; 2) carry clear.
    13                          ;  Line not found.  (lowtr) points to the link bytes of the next
    14                          ;  line greater than the one sought.
    15                          
    16                          FindLine
    17  31fa a52d                                lda txttab                               ; init pointer to beginning of program
    18  31fc a62e                                ldx txttab+1
    19                          
    20                          FindLink
    21  31fe 8561                                sta lowtr                                ; current position in program
    22  3200 8662                                stx lowtr+1
    23  3202 a001                                ldy #1
    24  3204 20ad22                              jsr indlow                               ; end of program (null link)?
    25  3207 f023                                beq l33_3                                ; yes, exit with .c=0 (not found)
    26  3209 c8                                  iny
    27  320a c8                                  iny
    28  320b 20ad22                              jsr indlow                               ; get line number of this line (high byte first)
    29                          ; sta syntmp
    30                          ; lda linnum+1 ;is this the line we're looking for?
    31                          ; cmp syntmp
    32                          ; bcc l33_4  ; no- too high, so the line does not exist, exit
    33                          ; beq l33_1
    34                          ; dey  ; no- too low, so get link to next line
    35                          ; bra l33_2
    36  320e c517                                cmp linnum+1                             ; is this the line we're looking for?   [910925]
    37  3210 f005                                beq l33_1                                ; maybe
    38  3212 b018                                bcs l33_3                                ; no- too high, so the line does not exist, exit with .c=0
    39  3214 88                                  dey                                      ; no- too low, so get link to next line
    40  3215 800a                                bra l33_2
    41                          
    42  3217 88                 l33_1            dey                                      ; maybe- have to check low byte
    43  3218 20ad22                              jsr indlow
    44                          ; sta syntmp
    45                          ; lda linnum
    46                          ; cmp syntmp
    47                          ; bcc l33_4  ; no- too high, exit
    48                          ; beq l33_4  ; yes- got it, exit
    49  321b c516                                cmp linnum                               ; is this the line we're looking for?   [910925]
    50  321d f00e                                beq l33_4                                ; yes- got it, exit with .c=1
    51  321f b00b                                bcs l33_3                                ; no- too high, so the line does not exist, exit with .c=0
    52                          
    53  3221 88                 l33_2            dey                                      ; get link to next line
    54  3222 20ad22                              jsr indlow
    55  3225 aa                                  tax
    56  3226 88                                  dey
    57  3227 20ad22                              jsr indlow
    58  322a 80d2                                bra FindLink                             ; continue looking
    59                          
    60                          
    61  322c 18                 l33_3            clc                                      ; exit, line not found (.c=0)
    62  322d 60                 l33_4            rts                                      ; exit, line found (.c=1)
    63                          

; ******** Source: basic.asm

; ******** Source: command/line/get.asm
     1                          
     2                          
     3                          
     4                          
     5                          ; LINGET  Reads a line # from the current txtptr position
     6                          ;   and stores it in linnum  (valid range is 0-63999).
     7                          ;
     8                          ;   On exit txtptr is pointing to the terminating char
     9                          ;   which is in .a with condition codes set.
    10                          ;   Endchr will be =0 if no digit input, else >0.  Use it
    11                          ;   to distinguish between line # 0 & null input.
    12                          
    13  322e a200               linget           ldx #0                                   ; enter with CHRGET flags set
    14  3230 860b                                stx endchr                               ; flags line # input
    15  3232 8616                                stx linnum                               ; init line # to 0
    16  3234 8617                                stx linnum+1
    17                          
    18  3236 b04b               l34_1            bcs l34_5                                ; it's not a digit, do rts
    19  3238 e60b               l34_2            inc endchr                               ; indicate line # input
    20  323a e92f                                sbc #$2f                                 ; '0'-1 since .c=0
    21  323c 850a                                sta charac                               ; save for later
    22  323e a517                                lda linnum+1
    23  3240 8524                                sta index
    24  3242 c919                                cmp #25                                  ; line number will be < 64000?
    25  3244 9006                                bcc l34_3                                ; yes, continue
    26  3246 9f553a                              bbs1 helper,l34_5                        ; no, if called by AutoScroll it's okay
    27  3249 83fffb                              +lbra snerr                              ; else syntax error
    28                          
    29  324c a516               l34_3            lda linnum
    30  324e 0a                                  asl                                      ; multiply by 10
    31  324f 2624                                rol index
    32  3251 0a                                  asl
    33  3252 2624                                rol index
    34  3254 6516                                adc linnum
    35  3256 8516                                sta linnum
    36  3258 a524                                lda index
    37  325a 6517                                adc linnum+1
    38  325c 8517                                sta linnum+1
    39  325e 0616                                asl linnum
    40  3260 2617                                rol linnum+1
    41  3262 a516                                lda linnum
    42  3264 650a                                adc charac                               ; add in digit
    43  3266 8516                                sta linnum
    44  3268 9002                                bcc l34_4
    45  326a e617                                inc linnum+1
    46                          l34_4
    47                          ; jsr chrget  ;ALLOW SPACES to terminate number  [910620]
    48                          ; bra l34_1
    49  326c e33d                                inw txtptr                               ; get next character from text
    50  326e a000                                ldy #0                                   ; re-get current character from text
    51  3270 20c522                              jsr indtxt                               ; lda (txtptr),y from RAM0
    52  3273 c920                                cmp #' '                                 ; space=eol    [910708]
    53  3275 f00d                                beq l34_6
    54  3277 c93a                                cmp #':'                                 ;
    55  3279 b008                                bcs l34_5                                ; eol
    56  327b 38                                  sec
    57  327c e930                                sbc #'0'                                 ; alpha or numeric?
    58  327e 38                                  sec
    59  327f e9d0                                sbc #$d0
    60  3281 90b5                                bcc l34_2                                ; numeric
    61  3283 60                 l34_5            rts                                      ; exit
    62                          
    63  3284 20a540             l34_6            jsr chargt                               ; terminating character is a space, eat it just this once
    64  3287 8305f0                              +lbra chrtst                             ; return with flags set appropriately (esp. for 'range')
    65                          
    66                          ;.end

; ******** Source: basic.asm

; ******** Source: command/list.asm
     1                          
     2                          
     3                          
     4  328a 7755               list             rmb7 helper                              ; clear 'help' flag for p1line
     5                          
     6                          ; Determine which form of LIST we have...
     7                          
     8  328c f3aa00                              +lbeq list_memory                        ; branch if terminator (no parameter)
     9  328f 93a700                              +lbcc list_memory                        ; branch if a number (assume range parameter)
    10  3292 c9ab                                cmp #minus_token
    11  3294 f3a200                              +lbeq list_memory                        ; branch if a dash (assume range parameter)
    12                          
    13                          
    14                          ; LIST command is of the form  LIST filename [,U#] [,D#]
    15                          
    16                          list_file
    17  3297 a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
    18  3299 202074                              jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 )
    19  329c 20dc77                              jsr chk1                                 ; check parameters
    20  329f a900                                lda #0
    21  32a1 8d8311                              sta dossa                                ; setup as dload would (0 = load channel)
    22  32a4 201d71                              jsr find_la                              ; find an available la to use (cannot use reserved one)
    23  32a7 a009                                ldy #fopn
    24  32a9 a204                                ldx #4
    25  32ab 20fd70                              jsr open_file                            ; open the file
    26  32ae b077                                bcs list_err                             ; exit if error
    27                          
    28  32b0 ae8111                              ldx dosla
    29  32b3 20c6ff                              jsr _chkin                               ; get input channel
    30  32b6 b06f                                bcs list_err                             ; exit if bad??
    31  32b8 20cfff                              jsr _basin                               ; waste 'load address'
    32  32bb 20cfff                              jsr _basin
    33                          
    34  32be 20cfff             l35_1            jsr _basin                               ; get link bytes
    35  32c1 8d0013                              sta dosstr
    36  32c4 20cfff                              jsr _basin
    37  32c7 8d0113                              sta dosstr+1
    38  32ca 0d0013                              ora dosstr
    39  32cd f051                                beq list_exit                            ; done if null pointer
    40  32cf 20b7ff                              jsr _readst
    41  32d2 d04c                                bne list_exit                            ; done if eof or bad status
    42                          ; ???? assumes serial bus
    43  32d4 a913                                lda #>dosstr                             ; point p1line's pointer at our line buffer
    44  32d6 a200                                ldx #<dosstr
    45  32d8 8562                                sta lowtr+1
    46  32da 8661                                stx lowtr
    47                          
    48  32dc a202                                ldx #2
    49  32de 20cfff                              jsr _basin                               ; read line into buffer
    50  32e1 9d0013                              sta dosstr,x
    51  32e4 e8                                  inx
    52  32e5 20cfff                              jsr _basin                               ; 2-byte line #
    53  32e8 9d0013                              sta dosstr,x
    54  32eb e8                                  inx
    55  32ec e0ff               l35_2            cpx #255                                 ; check buffer (buflen????)
    56  32ee b38043                              +lbcs errlen                             ; 'too long' error
    57  32f1 20cfff                              jsr _basin
    58  32f4 9d0013                              sta dosstr,x
    59  32f7 e8                                  inx
    60  32f8 a8                                  tay                                      ; save char
    61  32f9 20b7ff                              jsr _readst                              ; check channel status (serial bus????)
    62  32fc d022                                bne list_exit                            ; exit if eof or error
    63  32fe 20e1ff                              jsr _stop
    64  3301 f01d                                beq list_exit                            ; exit if stop key down
    65  3303 98                                  tya
    66  3304 d0e6                                bne l35_2                                ; loop until eol
    67                          
    68  3306 20c770                              jsr dcato                                ; get output channel
    69  3309 20f737                              jsr crdo                                 ; start new line
    70  330c ae0213                              ldx dosstr+2                             ; get line #
    71  330f ad0313                              lda dosstr+3
    72  3312 207733                              jsr p1line                               ; print line #, space, and the line of code
    73  3315 20ccff                              jsr _clrch
    74  3318 ae8111                              ldx dosla
    75  331b 20c6ff                              jsr _chkin                               ; get input channel
    76  331e 909e                                bcc l35_1                                ; [900730]
    77                          
    78                          list_exit
    79  3320 20c770                              jsr dcato                                ; flush last line with a <cr>
    80  3323 20f737                              jsr crdo                                 ; flush current line
    81  3326 18                                  clc                                      ; no errors    [910404]
    82                          list_err
    83  3327 08                                  php                                      ; save error status   [910404]
    84  3328 48                                  pha
    85  3329 20b438                              jsr release_channels                     ; release cmd channel, restore terminal
    86  332c ad8111                              lda dosla
    87                          ; bra close_out  ;    removed [900725]
    88  332f 18                                  clc                                      ; a real close   new [910404]
    89  3330 20c3ff                              jsr _close
    90  3333 68                                  pla                                      ; pop error status, if any
    91  3334 28                                  plp
    92  3335 833735                              +lbra exit_disk_op
    93                          
    94                          
    95                          ; LIST command is of the form  LIST [range]
    96                          
    97                          list_memory
    98  3338 205042                              jsr range                                ; set up line range
    99                          
   100  333b a001               l36_1            ldy #1
   101  333d 20ad22                              jsr indlow                               ; get ms byte of line to list's pointer
   102  3340 d007                                bne l36_2                                ; ok if not zero, but..
   103  3342 88                                  dey
   104  3343 20ad22                              jsr indlow
   105  3346 f3af04                              +lbeq crdo                               ; ..if ls byte is also zero, we're done
   106                          
   107  3349 20cc2c             l36_2            jsr is_stop_key_down
   108  334c 20f737                              jsr crdo                                 ; new line
   109  334f a002                                ldy #2
   110  3351 20ad22                              jsr indlow                               ; get ms byte of line number
   111  3354 aa                                  tax
   112  3355 c8                                  iny
   113  3356 20ad22                              jsr indlow                               ; get ls byte
   114                          
   115  3359 c517                                cmp linnum+1                             ; test if we are past the last line requested
   116  335b d004                                bne l36_3
   117  335d e416                                cpx linnum
   118  335f f003                                beq l36_4
   119  3361 b39404             l36_3            +lbcs crdo                               ; next line is > last line requested, exit
   120  3364 207733             l36_4            jsr p1line                               ; print line #, space, and the line of code
   121  3367 a000                                ldy #0                                   ; move 'pointer to next line' into (lowtr)
   122  3369 20ad22                              jsr indlow
   123  336c aa                                  tax
   124  336d c8                                  iny
   125  336e 20ad22                              jsr indlow
   126  3371 8661                                stx lowtr
   127  3373 8562                                sta lowtr+1
   128  3375 80c4                                bra l36_1

; ******** Source: basic.asm

; ******** Source: command/list/basic.asm
     1                          
     2                          
     3                          ;******************************************************
     4                          ; P1LINE Print 1 line of BASIC text
     5                          ;
     6                          ; Entry: (a,x) contains line number low,high
     7                          ;  (lowtr) points to beginning of line
     8                          ;
     9                          ; next-line   line-num  BASIC text......  null
    10                          ; lo    hi    lo    hi  byte byte...byte   00
    11                          ;        ^           ^     ^
    12                          ;    (lowtr)        .A    .X
    13                          ;******************************************************
    14                          
    15  3377 4f7e03             p1line           bbr4 runmod,l37_1                        ; [910620]
    16  337a 837a89                              +lbra edit_p1line                        ; handle things differently for plain text
    17                          
    18  337d a003               l37_1            ldy #3
    19  337f 844b                                sty lstpnt
    20  3381 8411                                sty dores                                ; reset quote-switch
    21  3383 207f64                              jsr linprt                               ; print line number
    22  3386 a920                                lda #' '                                 ; print a space
    23                          
    24  3388 a44b               p1l010           ldy lstpnt
    25  338a 297f                                and #$7f
    26                          
    27  338c c93a               p1l015           cmp #':'                                 ; end-of-stmt?     [900516]
    28  338e d00b                                bne l38_1                                ; no
    29  3390 7f5508                              bbr7 helper,l38_1                        ; yes, but skip e-o-s check if not HELP...
    30  3393 ff1105                              bbs7 dores,l38_1                         ; or ':' is inside quotes
    31  3396 20cb3c                              jsr highlight_done                       ; yes, restore normal text color
    32  3399 a93a                                lda #':'
    33                          
    34  339b 203d68             l38_1            jsr outch                                ; outdo
    35  339e c922                                cmp #'"'                                 ; if quote character, toggle quote-switch
    36  33a0 d006                                bne l38_2
    37  33a2 a511                                lda dores
    38  33a4 49ff                                eor #$ff
    39  33a6 8511                                sta dores
    40                          
    41  33a8 c8                 l38_2            iny                                      ; point to next character (should never wrap)
    42  33a9 8f5506                              bbs0 helper,l38_3                        ; branch if highlighting tokens
    43  33ac df5503                              bbs5 helper,l38_3                        ; branch if called by FIND/CHANGE
    44  33af 7f5503                              bbr7 helper,l38_4                        ; branch if called by LIST or HELP satisfied
    45  33b2 20963c             l38_3            jsr helpsb
    46                          
    47  33b5 20ad22             l38_4            jsr indlow
    48  33b8 f31109                              +lbeq highlight_done                     ; finished when trailing null is found
    49  33bb 6c0603                              jmp (iqplop)                             ; usually points to nqplop
    50                          
    51                          
    52                          nqplop                                                    ; <<<<<<< vector entry
    53  33be 10cc                                bpl p1l015                               ; not a token, just print character
    54  33c0 ff11c9                              bbs7 dores,p1l015                        ; branch if inside quotes, print chr as is
    55                          
    56                          ;  At this point, we know we're talking token.  Scan the token text
    57                          ;  list until the correct text is found, and print that text.
    58                          
    59  33c3 8554                                sta token_saver                          ; save token for REM check   [910626]
    60  33c5 c9fe                                cmp #esc_command_token                   ; is this an escape token?
    61  33c7 f042                                beq print_esc_cmd                        ; yes- escape command
    62  33c9 c9ce                                cmp #esc_function_token
    63  33cb f059                                beq print_esc_fn                         ; yes- escape function
    64  33cd c9ff                                cmp #pi
    65  33cf f0bb                                beq p1l015                               ; no- pi is >$80, but should be printed 'as is'
    66  33d1 aa                                  tax
    67  33d2 844b                                sty lstpnt                               ; no- use the token as index into ROM keyword list
    68  33d4 a924                                lda #>keyword_list
    69  33d6 a03a                                ldy #<keyword_list
    70                          
    71                          ; Scan list pointed to by (y,a) for token in (x), and print token's text
    72                          
    73  33d8 8525               p1l026           sta index1+1                             ; index1 points to token text list in ROM
    74  33da 8424                                sty index1
    75  33dc a000                                ldy #0                                   ; begin scanning lists for this token's text
    76  33de ca                                  dex
    77  33df 1014                                bpl p1l070                               ; what luck! it's the first one
    78                          
    79  33e1 e324               l39_1            inw index1                               ; scan text until next command found
    80  33e3 b124                                lda (index1),y                           ; ind.ok (ROM)
    81  33e5 10fa                                bpl l39_1                                ; loop until terminal char (msb=1)
    82  33e7 ca                                  dex                                      ; is next text the one we want?
    83  33e8 30f7                                bmi l39_1                                ; no, keep scanning
    84  33ea e324                                inw index1                               ; yes, point to first character
    85                          
    86  33ec 3f5506                              bbr3 helper,p1l070                       ; found text for this token, is it REM?  [910626]
    87  33ef a554                                lda token_saver                          ; [910628]
    88  33f1 c98f                                cmp #rem_token
    89  33f3 f009                                beq p1l071                               ; yes, and REM highlighting is enabled
    90                          
    91                          p1l070                                                    ; found text for this token
    92  33f5 4f5509                              bbr4 helper,p1l072                       ; branch if not highlighting tokens
    93  33f8 b124                                lda (index1),y                           ; peek at first character
    94  33fa 308c                                bmi p1l010                               ; branch if operator (1-byte, msb=1)
    95  33fc 8755                                smb0 helper                              ; else begin highlight
    96  33fe 20dc3c             p1l071           jsr highlight_text
    97                          
    98  3401 b124               p1l072           lda (index1),y                           ; get char from ROM table
    99  3403 3083                                bmi p1l010                               ; msb=1=last char this token, contine line
   100  3405 203d68                              jsr outch                                ; else print it
   101  3408 c8                                  iny
   102  3409 80f6                                bra p1l072
   103                          
   104                          
   105                          ; Print Escape Command
   106                          
   107                          print_esc_cmd
   108  340b aa                                  tax                                      ; save type (cmd) in case it is a foreign esc token
   109  340c c8                                  iny
   110  340d 20ad22                              jsr indlow                               ; look at second token
   111  3410 f37aff                              +lbeq p1l015                             ; none?  print funny character
   112  3413 844b                                sty lstpnt
   113  3415 c902                                cmp #first_esc_command_token             ; is this one of ours?
   114  3417 9028                                bcc print_foreign_esc                    ; nope
   115  3419 c946                                cmp #last_esc_command_token+1
   116  341b b024                                bcs print_foreign_esc                    ; nope
   117  341d 697e                                adc #$80-first_esc_command_token         ; yes- make a pointer p1l will be proud of
   118  341f aa                                  tax
   119  3420 a029                                ldy #<esc_command_list
   120  3422 a926                                lda #>esc_command_list
   121  3424 80b2                                bra p1l026                               ; go scan list and print it
   122                          
   123                          
   124                          
   125                          ; Print Escape Function
   126                          
   127                          print_esc_fn
   128  3426 aa                                  tax                                      ; save type (function) in case it's a foreign esc token
   129  3427 c8                                  iny
   130  3428 20ad22                              jsr indlow                               ; look at second token
   131  342b f35fff                              +lbeq p1l015                             ; none?  print funny character
   132  342e 844b                                sty lstpnt
   133  3430 c902                                cmp #first_esc_function_token            ; is this one of ours?
   134  3432 900d                                bcc print_foreign_esc                    ; nope
   135  3434 c90e                                cmp #last_esc_function_token+1
   136  3436 b009                                bcs print_foreign_esc                    ; nope
   137  3438 697e                                adc #$80-first_esc_function_token        ; yes- make a pointer p1l will be proud of
   138  343a aa                                  tax
   139  343b a09a                                ldy #<esc_function_list
   140  343d a927                                lda #>esc_function_list
   141  343f 8097                                bra p1l026                               ; go scan list and print it
   142                          
   143                          
   144                          ; The token to be printed is an escape token which is NOT recognized by BASIC.
   145                          ; We will jump through the indirect chain and see if anyone claims this token.
   146                          ;
   147                          ; At this point:
   148                          ; .C = 1 to signal 'unclaimed'
   149                          ; .X = type (0==>command, ff==>function)
   150                          ; .A = second token character
   151                          ;
   152                          ; If anyone claims this token, they should:
   153                          ;
   154                          ; > Clear .C to flag 'taken'
   155                          ; > Point (INDEX1) at the string to be printed (with msb of last char set)
   156                          ; > Note: string to print MUST be in RAM-0!
   157                          
   158                          print_foreign_esc
   159  3441 e0fe                                cpx #esc_command_token
   160  3443 d003                                bne l40_1
   161  3445 a200                                ldx #0
   162  3447 2c                                  !text $2c
   163                          
   164  3448 a2ff               l40_1            ldx #$ff
   165  344a 38                                  sec
   166  344b 6c0e03                              jmp (iescpr)
   167                          
   168  344e b33cff             nescpr           +lbcs p1l015                             ; no takers, print a funny graphic character
   169  3451 a000                                ldy #0
   170  3453 80a0                                bra p1l070
   171                          
   172                          

; ******** Source: basic.asm

; ******** Source: command/newclr.asm
     1                          
     2                          
     3                          
     4                          ;
     5                          ; The NEW command clears the program text as well as variable space.
     6                          ;
     7                          
     8  3455 f021               new              beq init_text                            ; Erase program in memory
     9  3457 c98c                                cmp #restore_token                       ; Restore an erased program?    [910103]
    10  3459 d3eff9                              +lbne snerr                              ; no- syntax error    [910410]
    11  345c 2022b5                              jsr chkeos                               ; yes- eat token, error if not eos  [910429]
    12  345f a52d                                lda txttab                               ; "seed" first link to fool 'chead'
    13  3461 a62e                                ldx txttab+1
    14  3463 8524                                sta index
    15  3465 8625                                stx index+1
    16  3467 a900                                lda #0
    17  3469 a001                                ldy #1
    18  346b a224                                ldx #index
    19  346d 200c23                              jsr sta_far_ram0                         ; clear msb  (bleed-thru)
    20  3470 88                                  dey
    21  3471 1a                                  inc
    22  3472 200c23                              jsr sta_far_ram0                         ; set lsb   (bleed-thru)
    23  3475 839c09                              +lbra renumber                           ; make renumber check it for us (not 100%) & relink
    24                          
    25                          
    26                          init_text
    27  3478 a52d                                lda txttab                               ; find the bottom of basic text
    28  347a a62e                                ldx txttab+1
    29  347c 8524                                sta index
    30  347e 8625                                stx index+1
    31  3480 c324                                dew index                                ; (the absolute bottom)
    32                          
    33  3482 a900                                lda #0
    34  3484 a8                                  tay
    35  3485 a224                                ldx #index
    36  3487 200c23                              jsr sta_far_ram0                         ; clear bottom     (bleed-thru)
    37  348a c8                                  iny
    38  348b 200c23                              jsr sta_far_ram0                         ; clear first link bytes    (bleed-thru)
    39  348e c8                                  iny
    40  348f 200c23                              jsr sta_far_ram0                         ; (bleed-thru)
    41  3492 18                                  clc
    42  3493 a52d                                lda txttab
    43  3495 6902                                adc #2
    44  3497 8582                                sta text_top                             ; set up (text_top), the end of text
    45  3499 a52e                                lda txttab+1
    46  349b 6900                                adc #0
    47  349d 8583                                sta text_top+1
    48                          
    49  349f 577e                                rmb5 runmod                              ; trcflg. reset trace flag
    50                          
    51                          
    52  34a1 201f35             runc             jsr reset_txtptr                         ; load (txtptr) with (txttab)-1
    53  34a4 8025                                bra clearc                               ; "CLR" to clear vars    [910410]
    54                          
    55                          
    56                          ; CLeaR Routines
    57                          ;
    58                          
    59                          ; Special forms of CLR command:
    60                          ;
    61                          ; CLR ERR$ Clears program error status, useful in TRAP handlers which
    62                          ;   have resolved an error & wish to RESUME with a clean status.
    63                          ;
    64                          ; CLR DS$  Clears the currently buffered DS,DS$ messages.  The next
    65                          ;   use of DS or DS$ will make BASIC re a new message from DOS.
    66                          
    67  34a6 f023               clear            beq clearc                               ; branch if no args    [910410]
    68                          
    69  34a8 c9d3                                cmp #err_token                           ; CLR ERR$
    70  34aa d006                                bne l41_1                                ; no
    71  34ac 2022b5                              jsr chkeos                               ; yes- eat token & error if not eos
    72  34af 832b10                              +lbra error_clear                        ; and go clear ERR$
    73                          
    74  34b2 c944               l41_1            cmp #'D'                                 ; CLR DS$     [910717]
    75  34b4 d00c                                bne l41_2                                ; no- error
    76  34b6 208322                              jsr chrget
    77  34b9 c953                                cmp #'S'
    78  34bb d005                                bne l41_2
    79  34bd 208322                              jsr chrget
    80  34c0 c924                                cmp #'$'
    81  34c2 d386f9             l41_2            +lbne snerr                              ; no- error
    82  34c5 2022b5                              jsr chkeos
    83  34c8 83b843                              +lbra Clear_DS                           ; yes- clear current DS$
    84                          
    85                          
    86                          ; Clearc is a subroutine which initializes the variable and array space by
    87                          ; resetting STREND (the end of array storage).  It falls into INIT_STACK,
    88                          ; which resets the stack.
    89                          
    90  34cb 20e7ff             clearc           jsr _clall                               ; close all files
    91  34ce a000                                ldy #0
    92  34d0 8479                                sty dsdesc                               ; flag 'no DS$ string'
    93  34d2 88                                  dey                                      ; (y=$ff)
    94  34d3 8ccb02                              sty trapno+1                             ; flag no current trap line
    95  34d6 8cc802                              sty errlin                               ; reset last error pointers
    96  34d9 8cc902                              sty errlin+1
    97  34dc 8cc702                              sty errnum
    98                          
    99  34df a539                                lda max_mem_1                            ; clear string space
   100  34e1 a43a                                ldy max_mem_1+1
   101  34e3 8535                                sta fretop
   102  34e5 8436                                sty fretop+1
   103                          
   104  34e7 a9ff                                lda #<stkbot                             ; empty run-time stack
   105  34e9 a005                                ldy #>stkbot
   106  34eb 857c                                sta tos
   107  34ed 847d                                sty tos+1
   108                          
   109  34ef a52f                                lda vartab
   110  34f1 a430                                ldy vartab+1
   111  34f3 8531                                sta arytab                               ; this will delete all variables,
   112  34f5 8432                                sty arytab+1
   113  34f7 8533                                sta strend                               ; ..and arrays
   114  34f9 8434                                sty strend+1
   115                          
   116  34fb a203                                ldx #pumony-puchrs                       ; reset print using chars
   117  34fd bddb69             l42_1            lda pudefs,x
   118  3500 9dd411                              sta puchrs,x
   119  3503 ca                                  dex
   120  3504 10f7                                bpl l42_1
   121                          
   122  3506 20fc3d             fload            jsr restore__1                           ; reset pointer for DATA statements
   123                          

; ******** Source: basic.asm

; ******** Source: stack/init.asm
     1                          
     2                          ; INIT_STACK Routine (formerly STKINI)
     3                          ;
     4                          ;   Init_Stack resets the stack pointer.  String temporaries are freed up,
     5                          ;   SUBFLG is reset, continuing is prohibited.
     6                          
     7                          init_stack
     8  3509 7a                                  ply                                      ; pop return address
     9  350a 68                                  pla
    10  350b a2fa                                ldx #stkend-257                          ; reset system stack pointer
    11  350d 9a                                  txs
    12  350e 48                                  pha                                      ; push return address
    13  350f 5a                                  phy
    14  3510 a21b                                ldx #tempst                              ; reset string temporaries
    15  3512 8618                                stx temppt
    16  3514 a900                                lda #0
    17  3516 8512                                sta subflg                               ; allow subscripted & integer vars
    18  3518 8d7311                              sta oldtxt+1                             ; disallow continuing
    19  351b 8dd702                              sta bits                                 ; reset math bit/byte flag
    20                          
    21  351e 60                 stkrts           rts
    22                          
    23                          
    24                          
    25                          reset_txtptr
    26  351f 18                                  clc                                      ; load (txtptr) with (txttab)-1
    27  3520 a52d                                lda txttab
    28  3522 69ff                                adc #$ff
    29  3524 853d                                sta txtptr
    30  3526 a52e                                lda txttab+1
    31  3528 69ff                                adc #$ff
    32  352a 853e                                sta txtptr+1                             ; set up text pointers
    33  352c 60                                  rts
    34                          

; ******** Source: basic.asm

; ******** Source: command/return.asm
     1                          
     2                          
     3                          
     4                          ;*********************************************************************
     5                          ; RETURN Routine
     6                          ;
     7                          ; Restores the line number and text pointer from the stack, and
     8                          ; eliminates all the FOR entries in front of the GOSUB entry.
     9                          ;
    10                          ;*********************************************************************
    11                          
    12                          return
    13                          
    14                          ; Ok, pay attention: we got here by a pseudo-jsr which left a return to NEWSTT
    15                          ; on the stack for us to return to.  There is also a return to NEWSTT left on
    16                          ; the stack from the GOSUB we are returning from.  This is true UNLESS we got
    17                          ; here on a sprite collision, in which case we still have the NEWSUB return
    18                          ; recently left by our current call, but the second return goes back to the
    19                          ; trapping mechanism.  The bottom line is: we have an extra return address on
    20                          ; the stack, which we have to get rid of before leaving.
    21                          
    22  352d 68                                  pla                                      ; mea culpa, mea culpa, mea culpa
    23  352e 68                                  pla
    24  352f a98d                                lda #gosub_token
    25  3531 204331                              jsr search                               ; look for GOSUB on runtime stack
    26  3534 f005                                beq ret010                               ; found
    27  3536 a20c                                ldx #errrg                               ; else error
    28  3538 8315f9                              +lbra error
    29                          
    30  353b 20e631             ret010           jsr movfnd                               ; (fndpnt) => (tos)
    31  353e a005                                ldy #lengos
    32  3540 20ef31                              jsr rlsstk                               ; effectivly pop GOSUB off run-time stack
    33                          ; dey
    34                          ; lda (fndpnt),y
    35                          ; sta txtptr+1
    36                          ; dey
    37                          ; lda (fndpnt),y
    38                          ; sta txtptr
    39                          ; dey
    40                          ; lda (fndpnt),y
    41  3543 204279                              jsr retpat                               ; 01/18/84 patch: correct RETURN to GOSUB from direct mode
    42                          ; lda (fndpnt),y
    43                          ; sta curlin ;jump to DATA to waste rest of stmt (in case of ON..GOSUB)
    44  3546 8000                                bra data
    45                          

; ******** Source: basic.asm

; ******** Source: command/data.asm
     1                          
     2                          
     3                          
     4                          
     5                          data
     6  3548 205b35                              jsr datan                                ; skip to end of statement- offset in .y
     7  354b 98                 addon            tya
     8  354c 18                                  clc
     9  354d 653d                                adc txtptr                               ; add offset to end to txtptr
    10  354f 853d                                sta txtptr
    11  3551 9002                                bcc remrts
    12  3553 e63e                                inc txtptr+1
    13  3555 60                 remrts           rts                                      ; NEWSTT rts addr is still there
    14                          
    15                          
    16                          
    17  3556 205e35             rem              jsr remn                                 ; skip rest of statement
    18  3559 80f0                                bra addon                                ; will always branch
    19                          
    20                          
    21  355b a23a               datan            ldx #':'                                 ; DATA terminates on ":" and null
    22  355d 2c                                  !text $2c
    23                          
    24  355e a200               remn             ldx #0                                   ; REM terminates on null only
    25  3560 860a                                stx charac                               ; preserve terminator
    26  3562 a000                                ldy #0                                   ; this makes charac=0 after swap
    27  3564 840b                                sty endchr
    28                          
    29  3566 a50b               l43_1            lda endchr
    30  3568 a60a                                ldx charac
    31  356a 850a                                sta charac
    32  356c 860b                                stx endchr
    33  356e 20c522             l43_2            jsr indtxt
    34  3571 f0e2                                beq remrts                               ; null always terminates
    35  3573 c50b                                cmp endchr                               ; is it some another terminator?
    36  3575 f0de                                beq remrts                               ; yes, it's finished
    37  3577 c8                                  iny                                      ; progress to next character
    38  3578 c922                                cmp #'"'                                 ; is it a quote?
    39  357a d0f2                                bne l43_2                                ; no, just continue
    40  357c f0e8                                beq l43_1                                ; yes, time to change
    41                          

; ******** Source: basic.asm

; ******** Source: command/ifthenelse.asm
     1                          
     2                          
     3                          
     4                          ;****************************************************************
     5                          ;*
     6                          ;* IF Statment
     7                          ;*
     8                          ;* IF exp {GOTO line#  | THEN {line# | statements | b-block} }
     9                          ;*  [:ELSE {line# | statements | b-block} ]
    10                          ;*
    11                          ;* B-block
    12                          ;*
    13                          ;* BEGIN : [statement(s) on one or more lines] : BEND
    14                          ;*
    15                          ;****************************************************************
    16                          
    17  357e 20ef4c             if               jsr frmevl                               ; evaluate the conditional expression
    18  3581 208522                              jsr chrgot                               ; re-get current character
    19  3584 c989                                cmp #goto_token                          ; is terminating character a GOTO?
    20  3586 f005                                beq l44_1                                ; yes
    21  3588 a9a7                                lda #then_token                          ; no, it must be THEN
    22  358a 205d4e                              jsr synchr
    23                          
    24  358d a563               l44_1            lda facexp                               ; test truth value of argument
    25  358f d026                                bne if_true                              ; branch if true
    26                          
    27                          if_false
    28  3591 208522                              jsr chrgot                               ; is there a b-block?
    29  3594 c9fe                                cmp #esc_command_token
    30  3596 d00b                                bne l45_1                                ; no, must be an escape command
    31  3598 c8                                  iny                                      ; might be, look at escape token
    32  3599 20c522                              jsr indtxt
    33  359c c918                                cmp #begin_token
    34  359e d003                                bne l45_1                                ; branch if not
    35  35a0 20d935                              jsr find_bend                            ; skip to end of b-block
    36                          
    37  35a3 204835             l45_1            jsr data                                 ; may be 'else' clause. first skip over 'then' clause..
    38  35a6 a000                                ldy #0
    39  35a8 20c522                              jsr indtxt                               ; ..and see if end of stmt or end of line
    40  35ab f0a9                                beq rem                                  ; end of line, no 'else'. go to next line
    41  35ad 208322                              jsr chrget                               ; another statement on this line.. is it 'else'?
    42  35b0 c9d5                                cmp #else_token
    43  35b2 d0ef                                bne l45_1                                ; no, keep looking on this line
    44  35b4 208322                              jsr chrget                               ; yes! skip over token and execute clause (below)
    45                          
    46  35b7 208522             if_true          jsr chrgot
    47  35ba f017                                beq l46_2                                ; branch if end of statement
    48  35bc b003                                bcs l46_1                                ; branch if not a number
    49  35be 833b07                              +lbra goto                               ; here if of the form 'THEN line#'
    50                          
    51  35c1 c9fe               l46_1            cmp #esc_command_token                   ; is this the beginning of a b-block?
    52  35c3 d00e                                bne l46_2                                ; no, must be an escape command
    53  35c5 c8                                  iny                                      ; might be, look at escape token
    54  35c6 20c522                              jsr indtxt
    55  35c9 c918                                cmp #begin_token
    56  35cb d006                                bne l46_2
    57  35cd 208322                              jsr chrget                               ; skip over 'BEGIN' if so...
    58  35d0 208322                              jsr chrget                               ; ..and the second token, as well.
    59                          
    60  35d3 208522             l46_2            jsr chrgot                               ; get back original character, & set up flags
    61  35d6 837af6                              +lbra xeqcm3                             ; ..and go execute whatever it is
    62                          
    63                          
    64                          find_bend                                                 ; ... subroutine to find end of current b-block
    65  35d9 208322                              jsr chrget
    66  35dc d026                                bne l47_3
    67                          
    68                          ; End of statement.. set up next
    69                          
    70  35de c93a               l47_1            cmp #':'                                 ; is this EOL?
    71  35e0 f0f7                                beq find_bend                            ; no, keep looking
    72                          
    73  35e2 7f7e48             l47_2            bbr7 runmod,l47_7                        ; EOL: branch if direct mode, 'block terminator not found' error
    74                          
    75  35e5 a002                                ldy #2
    76  35e7 20c522                              jsr indtxt                               ; end of text?
    77  35ea f041                                beq l47_7                                ; yes, msb of next stmt pointer = 0. error
    78                          
    79  35ec c8                                  iny
    80  35ed 20c522                              jsr indtxt
    81  35f0 853b                                sta curlin                               ; set up next line of text
    82  35f2 c8                                  iny
    83  35f3 20c522                              jsr indtxt
    84  35f6 853c                                sta curlin+1
    85  35f8 98                                  tya
    86  35f9 18                                  clc
    87  35fa 653d                                adc txtptr
    88  35fc 853d                                sta txtptr
    89  35fe 90d9                                bcc find_bend
    90  3600 e63e                                inc txtptr+1
    91  3602 80d5                                bra find_bend                            ; always
    92                          
    93  3604 c922               l47_3            cmp #'"'
    94  3606 d007                                bne l47_4
    95  3608 203236                              jsr un_quote                             ; look for terminating quote, or EOL
    96  360b f0d1                                beq l47_1                                ; EOL or ':' after closing quote
    97  360d d0ca                                bne find_bend                            ; ..else normal char, keep looking
    98                          
    99  360f c98f               l47_4            cmp #rem_token                           ; REM?
   100  3611 d005                                bne l47_5                                ; no
   101  3613 205635                              jsr rem                                  ; yes, trash this line
   102  3616 80ca                                bra l47_2                                ; and go test for end of text
   103                          
   104  3618 c9fe               l47_5            cmp #esc_command_token                   ; is this a BEND?
   105  361a d0bd                                bne find_bend                            ; can't be, has to be an escape
   106                          
   107  361c 208322                              jsr chrget                               ; skip over esc token
   108  361f c919                                cmp #bend_token
   109  3621 f009                                beq l47_6                                ; this is what we came for, bye!
   110                          
   111  3623 c918                                cmp #begin_token                         ; not a BEND. is it a BEGIN?
   112  3625 d0b2                                bne find_bend                            ; it's just a normal, stick-in-the-mud char. keep looking.
   113                          
   114  3627 20d935                              jsr find_bend                            ; oh-oh, recursion. Dr. Ja-Ja warned me about this.
   115  362a 80ad                                bra find_bend
   116                          
   117  362c 60                 l47_6            rts
   118                          
   119  362d a225               l47_7            ldx #err_no_bend
   120  362f 831ef8                              +lbra error
   121                          
   122                          un_quote                                                  ; txtptr points to a '"'. look for closing '"', or EOL
   123  3632 a000                                ldy #0
   124  3634 e33d               l48_1            inw txtptr
   125  3636 20c522                              jsr indtxt
   126  3639 f007                                beq l48_2                                ; EOL, get out here with .z set and a '00' in .a
   127  363b c922                                cmp #'"'
   128  363d d0f5                                bne l48_1                                ; keep looking until quote
   129  363f 4c8322                              jmp chrget                               ; got closing quote, get byte after quote, set flags
   130                          
   131  3642 60                 l48_2            rts
   132                          
   133                          
   134                          
   135  3643 c9fe               else             cmp #esc_command_token                   ; is this of the form "ELSE b-block"?
   136  3645 d00b                                bne l49_1                                ; no, must be an escape command
   137  3647 c8                                  iny                                      ; might be, look at escape token
   138  3648 20c522                              jsr indtxt
   139  364b c918                                cmp #begin_token
   140  364d d003                                bne l49_1                                ; no, justa plain-old "ELSE statement"
   141  364f 20d935                              jsr find_bend                            ; yes, it is a b-block. skip over the b-block.
   142  3652 8302ff             l49_1            +lbra rem
   143                          
   144                          

; ******** Source: basic.asm

; ******** Source: command/on.asm
     1                          
     2                          
     3                          
     4                          ;*********************************************************
     5                          ;* ON expression {GOTO | GOSUB} line_number
     6                          ;*********************************************************
     7                          ongoto
     8  3655 206c5d                              jsr getbyt                               ; get & save GOTO/GOSUB
     9  3658 48                                  pha
    10  3659 c989                                cmp #goto_token                          ; GOTO?
    11  365b f005                                beq l50_1                                ; yes
    12  365d c98d                                cmp #gosub_token                         ; GOSUB?
    13  365f d3e9f7                              +lbne snerr                              ; no, syntax error
    14                          
    15  3662 c667               l50_1            dec faclo
    16  3664 d004                                bne l50_2                                ; skip another line number
    17  3666 68                                  pla                                      ; get dispatch character
    18  3667 8300f6                              +lbra xeqcm2
    19                          
    20  366a 208322             l50_2            jsr chrget                               ; advance and set codes
    21  366d 202e32                              jsr linget                               ; read next line
    22  3670 c92c                                cmp #','                                 ; is it a "comma"?
    23  3672 f0ee                                beq l50_1
    24  3674 68                                  pla                                      ; remove stack entry (token)
    25  3675 60                                  rts                                      ; either end of line or syntax error
    26                          

; ******** Source: basic.asm

; ******** Source: command/let.asm
     1                          
     2                          
     3                          
     4                          ;****************************************************************
     5                          ;*
     6                          ;*  [LET] variable = expression
     7                          ;*
     8                          ;****************************************************************
     9                          
    10  3676 207c4f             let              jsr ptrget                               ; get pntr to variable into "varpnt"
    11  3679 854b                                sta forpnt                               ; preserve pointer
    12  367b 844c                                sty forpnt+1
    13  367d a9b2                                lda #equal_token
    14  367f 205d4e                              jsr synchr                               ; "=" is necessary
    15                          
    16  3682 a510                                lda intflg                               ; save type for later
    17  3684 48                                  pha
    18  3685 a50f                                lda valtyp                               ; retain the variable's value type too
    19  3687 48                                  pha
    20                          
    21  3688 20ef4c                              jsr frmevl                               ; get value of formula into FAC
    22  368b 68                                  pla
    23  368c 2a                                  rol                                      ; carry set for string, off for numeric
    24  368d 20de4c                              jsr chkval                               ; make sure VALTYP matches carry
    25                          ;and set zero flag for numeric
    26  3690 d022                                bne copstr                               ; if numeric, copy it
    27  3692 68                                  pla                                      ; get number type
    28                          
    29  3693 1018               qintgr           bpl copflt                               ; store a floating point number
    30  3695 20b262                              jsr round                                ; round integer
    31  3698 20b458                              jsr ayint                                ; make two-byte number
    32  369b a000                                ldy #0
    33  369d a566                                lda facmo                                ; get high
    34  369f da                                  phx
    35  36a0 a24b                                ldx #forpnt
    36  36a2 20f022                              jsr sta_far_ram1 ;sta (forpnt),y         ; store it
    37  36a5 c8                                  iny
    38  36a6 a567                                lda faclo                                ; get low
    39  36a8 20f022                              jsr sta_far_ram1                         ; sta (forpnt),y
    40  36ab fa                                  plx
    41  36ac 60                                  rts
    42                          
    43                          
    44                          
    45  36ad a64b               copflt           ldx forpnt
    46  36af a44c                                ldy forpnt+1
    47  36b1 83af2b                              +lbra movmf_ram1                         ; put number @forpnt in var bank
    48                          
    49                          
    50                          
    51  36b4 68                 copstr           pla                                      ; if string, no INTFLG
    52                          
    53  36b5 a44c               inpcom           ldy forpnt+1                             ; TI$?
    54  36b7 c002                                cpy #>zero                               ; (only TI$ can be this on assign)
    55  36b9 f3c21c                              +lbeq Set_TI_String                      ; yes
    56  36bc 8024                                bra getspt                               ; no
    57                          
    58                          
    59  36be 68                 dskx1            pla
    60  36bf c8                                  iny
    61                          
    62  36c0 c536               dskx2            cmp fretop+1
    63  36c2 9018                                bcc l51_2
    64  36c4 d008                                bne l51_1
    65  36c6 88                                  dey
    66  36c7 20a922                              jsr indfmo
    67  36ca c535                                cmp fretop
    68  36cc 900e                                bcc l51_2
    69                          
    70  36ce a467               l51_1            ldy faclo                                ; qvaria
    71  36d0 c430                                cpy vartab+1                             ; if (vartab) > (facmo), don't copy
    72  36d2 9008                                bcc l51_2
    73  36d4 d023                                bne copy                                 ; it is less
    74  36d6 a566                                lda facmo
    75  36d8 c52f                                cmp vartab                               ; compare low orders
    76  36da b01d                                bcs copy
    77                          
    78  36dc a566               l51_2            lda facmo                                ; dntcpy
    79  36de a467                                ldy facmo+1
    80  36e0 8035                                bra copyc
    81                          
    82                          
    83  36e2 a002               getspt           ldy #2                                   ; get pntr to descriptor
    84  36e4 20a922                              jsr indfmo
    85  36e7 c57b                                cmp dsdesc+2                             ; check for DS$ hi
    86  36e9 d0d5                                bne dskx2                                ; nope
    87  36eb 48                                  pha
    88  36ec 88                                  dey
    89  36ed 20a922                              jsr indfmo
    90  36f0 c57a                                cmp dsdesc+1                             ; check for DS$ lo
    91  36f2 d0ca                                bne dskx1                                ; nope
    92  36f4 a579                                lda dsdesc                               ; check if len=0
    93  36f6 f0c6                                beq dskx1                                ; yup
    94  36f8 68                                  pla                                      ; fall through to copy
    95                          
    96                          
    97  36f9 a000               copy             ldy #0
    98  36fb 20a922                              jsr indfmo
    99  36fe 20735a                              jsr strini                               ; get room to copy string into
   100  3701 a552                                lda dscpnt                               ; get pointer to old descriptor, so
   101  3703 a453                                ldy dscpnt+1
   102  3705 8570                                sta strng1                               ; movins can find string
   103  3707 8471                                sty strng1+1
   104  3709 20355b                              jsr movins                               ; copy it
   105                          
   106  370c a570                                lda strng1                               ; fix to free get strings
   107  370e a471                                ldy strng1+1
   108  3710 20cc5b                              jsr fretms                               ; free the string, if it is a temp
   109                          
   110  3713 a963                                lda #<dsctmp
   111  3715 a000                                ldy #>dsctmp
   112                          
   113  3717 8552               copyc            sta dscpnt
   114  3719 8453                                sty dscpnt+1
   115  371b 8524                                sta index                                ; index points to new descriptor
   116  371d 8425                                sty index+1
   117  371f 20cc5b                              jsr fretms
   118                          
   119                          
   120                          ;   Fix the strings by flagging the old string as garbage and the new
   121                          ;   string by pointing it to its new descriptor.
   122                          
   123  3722 206737                              jsr stradj                               ; set up new string
   124  3725 9011                                bcc l52_1                                ; leave it alone
   125  3727 a000                                ldy #0
   126  3729 a54b                                lda forpnt                               ; put in backwards link
   127  372b da                                  phx
   128  372c a224                                ldx #index
   129  372e 20f022                              jsr sta_far_ram1
   130  3731 c8                                  iny
   131  3732 a54c                                lda forpnt+1
   132  3734 20f022                              jsr sta_far_ram1
   133  3737 fa                                  plx
   134                          
   135  3738 a54b               l52_1            lda forpnt                               ; fix old string
   136  373a 8524                                sta index
   137  373c a54c                                lda forpnt+1
   138  373e 8525                                sta index+1
   139  3740 206737                              jsr stradj                               ; point to old string
   140  3743 9010                                bcc l52_2                                ; in text do not fix
   141  3745 88                                  dey                                      ; restore y
   142  3746 da                                  phx
   143  3747 a224                                ldx #index
   144  3749 a9ff                                lda #$ff                                 ; garbage flag
   145  374b 20f022                              jsr sta_far_ram1
   146  374e 88                                  dey
   147  374f 68                                  pla                                      ; (was txa)
   148  3750 48                                  pha
   149  3751 20f022                              jsr sta_far_ram1                         ; store length
   150  3754 fa                                  plx
   151                          
   152  3755 a002               l52_2            ldy #2                                   ; set the descriptor
   153  3757 da                                  phx
   154  3758 a24b                                ldx #forpnt
   155  375a a952               l52_3            lda #dscpnt
   156  375c 20d722                              jsr lda_far_ram1                         ; lda (dscpnt),y from RAM1
   157  375f 20f022                              jsr sta_far_ram1                         ; sta (forpnt),y to   RAM1
   158  3762 88                                  dey
   159  3763 10f5                                bpl l52_3
   160  3765 fa                                  plx
   161  3766 60                                  rts
   162                          
   163                          
   164                          ;   STRADJ takes the pointer index which points to a descriptor and
   165                          ;   indexes to the desciptor's string data.  If the string is not in
   166                          ;   string space (no action to take) we return with carry clear, else
   167                          ;   we return with the pointer set to the link bytes in the string, the
   168                          ;   length in .a and the carry set.
   169                          
   170  3767 a000               stradj           ldy #0
   171  3769 20d522                              jsr indin1_ram1                          ; push length on stack
   172  376c 48                                  pha
   173  376d f036                                beq l53_5                                ; if length=0 do nothing
   174  376f c8                                  iny
   175  3770 20d522                              jsr indin1_ram1                          ; get low byte (into .x)
   176  3773 aa                                  tax
   177  3774 c8                                  iny
   178  3775 20d522                              jsr indin1_ram1                          ; get high byte
   179  3778 c53a                                cmp max_mem_1+1
   180  377a 9006                                bcc l53_1                                ; ok
   181  377c d027                                bne l53_5                                ; if above top of memory
   182  377e e439                                cpx max_mem_1                            ; msb the same, test lsb
   183  3780 b023                                bcs l53_5                                ; if above top of memory
   184                          
   185  3782 c536               l53_1            cmp fretop+1
   186  3784 901f                                bcc l53_5                                ; if below fretop
   187  3786 d004                                bne l53_2
   188  3788 e435                                cpx fretop
   189  378a 9019                                bcc l53_5                                ; if below fretop
   190                          
   191  378c c57b               l53_2            cmp dsdesc+2
   192  378e d004                                bne l53_3                                ; fix
   193  3790 e47a                                cpx dsdesc+1
   194  3792 f011                                beq l53_5
   195                          
   196  3794 8624               l53_3            stx index                                ; ok set pointer
   197  3796 8525                                sta index+1
   198  3798 68                                  pla                                      ; get back length
   199  3799 aa                                  tax                                      ; into x also
   200  379a 18                                  clc
   201  379b 6524                                adc index
   202  379d 8524                                sta index
   203  379f 9002                                bcc l53_4
   204  37a1 e625                                inc index+1
   205  37a3 38                 l53_4            sec                                      ; carry set
   206  37a4 60                                  rts
   207                          
   208  37a5 68                 l53_5            pla                                      ; clean up stack
   209  37a6 18                                  clc
   210  37a7 60                                  rts
   211                          

; ******** Source: basic.asm

; ******** Source: command/printcmd.asm
     1                          
     2                          
     3                          
     4                          ;***********************************************************
     5                          ;*
     6                          ;* PRINT   PRINT#   CMD
     7                          ;*
     8                          ;**********************************************************
     9                          
    10  37a8 20ae37             printn           jsr cmd                                  ; docmd
    11  37ab 830701                              +lbra release_channels                   ; restore terminal
    12                          
    13                          
    14  37ae 206c5d             cmd              jsr getbyt
    15  37b1 f005                                beq l54_1
    16  37b3 a92c                                lda #','                                 ; comma?
    17  37b5 205d4e                              jsr synchr
    18                          
    19  37b8 08                 l54_1            php                                      ; save stat (beq=eof)
    20  37b9 48                                  pha                                      ; save char
    21  37ba 8615                                stx channl                               ; channel to output on
    22  37bc 204968                              jsr coout
    23  37bf 68                                  pla                                      ; get char back
    24  37c0 28                                  plp                                      ; get stat back
    25  37c1 8006                                bra print
    26                          
    27                          
    28  37c3 203e38             strdon           jsr strprt
    29                          
    30  37c6 208522             newchr           jsr chrgot                               ; reget last character
    31                          
    32  37c9 f02c               print            beq crdo                                 ; terminator only, so print crlf
    33  37cb c9fb                                cmp #using_token
    34  37cd f31032                              +lbeq using
    35                          
    36                          
    37                          
    38  37d0 f032               printc           beq prtrts  ;here after seeing TAB(x) or "," or " ; " in which case
    39                          ;a terminator does not mean a crlf but just RTS
    40  37d2 c9a3                                cmp #tab_token                           ; TAB function?
    41  37d4 f03f                                beq taber                                ; yes (c=1)
    42  37d6 c9a6                                cmp #spc_token                           ; space function?
    43  37d8 18                                  clc                                      ; clear carry
    44  37d9 f03a                                beq taber                                ; yes (c=0)
    45  37db c92c                                cmp #','                                 ; comma?
    46  37dd f026                                beq comprt                               ; yes
    47  37df c93b                                cmp #';'                                 ; a semicolon?
    48  37e1 f04e                                beq notabr                               ; yes
    49                          
    50  37e3 20ef4c                              jsr frmevl                               ; evaluate the formula
    51  37e6 ff0fda                              bbs7 valtyp,strdon                       ; branch if a string
    52  37e9 208f64                              jsr fout
    53  37ec 20855a                              jsr strlit                               ; build descriptor
    54  37ef 203e38                              jsr strprt                               ; print the number
    55  37f2 205838                              jsr outspc                               ; print a space
    56  37f5 80cf                                bra newchr                               ; always goes
    57                          
    58                          
    59                          
    60  37f7 a90d               crdo             lda #cr
    61  37f9 203d68                              jsr outch                                ; outdo
    62                          
    63  37fc 7f1505             crfin            bbr7 channl,prtrts
    64  37ff a90a                                lda #lf
    65  3801 203d68                              jsr outch                                ; outdo
    66                          ; eor #$ff  ;????
    67                          
    68  3804 60                 prtrts           rts
    69                          
    70                          
    71                          
    72  3805 38                 comprt           sec
    73  3806 20f0ff                              jsr _plot                                ; get tab position in x
    74  3809 98                                  tya
    75  380a 38                                  sec
    76  380b e90a               morco1           sbc #column_width
    77  380d b0fc                                bcs morco1
    78  380f 49ff                                eor #$ff
    79  3811 6901                                adc #1
    80  3813 d017                                bne aspac
    81                          
    82  3815 08                 taber            php                                      ; remember if SPC(c=0) or TAB(c=1) function
    83  3816 38                                  sec
    84  3817 20f0ff                              jsr _plot                                ; read tab position
    85  381a 8454                                sty trmpos
    86  381c 20695d                              jsr gtbytc                               ; get value into accx
    87  381f c929                                cmp #')'
    88  3821 d327f6                              +lbne snerr
    89  3824 28                                  plp
    90  3825 9006                                bcc xspac
    91  3827 8a                                  txa
    92  3828 e554                                sbc trmpos
    93  382a 9005                                bcc notabr                               ; negative, don't print any
    94  382c aa                 aspac            tax
    95  382d e8                 xspac            inx
    96  382e ca                 xspac2           dex
    97  382f d005                                bne xspac1
    98                          
    99                          
   100  3831 208322             notabr           jsr chrget                               ; reget last character
   101  3834 809a                                bra printc                               ; don't call crdo
   102                          
   103                          
   104  3836 205838             xspac1           jsr outspc
   105  3839 d0f3                                bne xspac2
   106                          
   107                          
   108                          ; STROUT Routine
   109                          ;
   110                          ; Print the string pointed to by .x.  It must end with a null byte.
   111                          
   112  383b 20855a             strout           jsr strlit                               ; get a string literal
   113                          
   114  383e 206d5b             strprt           jsr frefac                               ; return temp pointer
   115  3841 aa                                  tax                                      ; put count into counter
   116  3842 a000                                ldy #0
   117  3844 e8                                  inx                                      ; move one ahead
   118  3845 ca                 strpr2           dex
   119  3846 f0bc                                beq prtrts                               ; all done
   120  3848 20d522                              jsr indin1_ram1                          ; lda (index),y
   121  384b 203d68                              jsr outch                                ; outdo
   122  384e c8                                  iny
   123  384f c90d                                cmp #cr
   124  3851 d0f2                                bne strpr2
   125  3853 20fc37                              jsr crfin                                ; type rest of carriage return
   126  3856 80ed                                bra strpr2                               ; and on and on
   127                          
   128  3858 a515               outspc           lda channl                               ; if terminal print skip chr., else print space
   129  385a d003                                bne realsp
   130  385c a91d                                lda #29                                  ; CBM cursor right (non-destructive skip char)
   131  385e 2c                                  !text $2c
   132                          
   133  385f a920               realsp           lda #' '                                 ; space
   134  3861 2c                                  !text $2c
   135                          
   136  3862 a93f               outqst           lda #'?'
   137                          
   138                          ;outdo
   139  3864 4c3d68                              jmp outch                                ; output char in .a
   140                          ; and #$ff ;????
   141                          ; rts
   142                          
   143                          ;.end

; ******** Source: basic.asm

; ******** Source: command/inputs.asm
     1                          
     2                          
     3  3867 20e258             get              jsr errdir                               ; direct mode illegal
     4  386a 8576                                sta z_p_temp_1                           ; flag to distinguish between GET and GETKEY
     5                          
     6  386c c923                                cmp #'#'                                 ; is it GET# ?
     7  386e f009                                beq getn                                 ; yes
     8  3870 c9f9                                cmp #key_token                           ; is it GETKEY ?
     9  3872 d015                                bne gettty                               ; no, must be plain GET
    10  3874 208322                              jsr chrget                               ; yes, skip over KEY token
    11  3877 8010                                bra gettty
    12                          
    13                          
    14  3879 208322             getn             jsr chrget                               ; GET# move up to next byte
    15  387c 206c5d                              jsr getbyt                               ; get channel into x
    16  387f a92c                                lda #','                                 ; comma?
    17  3881 205d4e                              jsr synchr
    18  3884 8615                                stx channl
    19  3886 205268                              jsr coin                                 ; chkin
    20                          
    21                          
    22                          gettty                                                    ; GET
    23  3889 a201                                ldx #<buf+1                              ; point to 0
    24  388b a002                                ldy #>buf
    25  388d a900                                lda #0                                   ; to stuff and to point
    26  388f 8d0102                              sta buf+1                                ; zero it
    27  3892 a940                                lda #$40                                 ; turn on v-bit
    28  3894 201b39                              jsr inpco1                               ; do the get
    29  3897 a615                                ldx channl
    30  3899 d019                                bne release_channels                     ; restore terminal channels
    31  389b 60                                  rts
    32                          
    33                          
    34                          linputn                                                   ; input line from channel into a string var
    35  389c 208322                              jsr chrget                               ; (eat input# token)
    36  389f f787                                smb7 op
    37  38a1 2c                                  !text $2c
    38                          
    39  38a2 7787               inputn           rmb7 op                                  ; flag INPUT# vs. LINPUT#
    40  38a4 206c5d                              jsr getbyt                               ; get channel number
    41  38a7 a92c                                lda #','                                 ; a comma?
    42  38a9 205d4e                              jsr synchr
    43  38ac 8615                                stx channl
    44  38ae 205268                              jsr coin                                 ; chkin
    45  38b1 20e938                              jsr notqti                               ; do input to variables
    46                          
    47                          
    48                          release_channels                                          ; iodone, iorele.
    49  38b4 20ccff                              jsr _clrch                               ; clear I/O channels
    50                          ; ldx #0   ;restore normal terminal channels
    51  38b7 8515                                sta channl                               ; (was stx)     [910909]
    52  38b9 60                                  rts
    53                          
    54                          
    55                          linput                                                    ; input line from console into a string var
    56  38ba 208322                              jsr chrget                               ; (eat input token)
    57  38bd f787                                smb7 op
    58  38bf 2c                                  !text $2c
    59                          
    60  38c0 7787               input            rmb7 op                                  ; flag INPUT vs. LINPUT
    61  38c2 c922                                cmp #'"'                                 ; a quote?
    62  38c4 d023                                bne notqti                               ; no message
    63  38c6 20164e                              jsr strtxt                               ; literalize the string in text
    64                          
    65  38c9 208522                              jsr chrgot                               ; looking for prompt string terminator  [910219]
    66  38cc c92c                                cmp #','
    67  38ce d011                                bne l55_1
    68  38d0 8dff01                              sta buf_txtptr                           ; is comma- supress '?' after prompt  [910219]
    69  38d3 208322                              jsr chrget                               ; eat comma
    70  38d6 203e38                              jsr strprt                               ; print prompt
    71  38d9 20e258                              jsr errdir                               ; error if direct mode
    72  38dc 201c31                              jsr InputLine                            ; get first item
    73  38df 8013                                bra getagn1                              ; see if there's more to do
    74                          
    75  38e1 a93b               l55_1            lda #';'                                 ; must end in semicolon
    76  38e3 205d4e                              jsr synchr
    77  38e6 203e38                              jsr strprt                               ; print prompt
    78                          
    79  38e9 20e258             notqti           jsr errdir                               ; use common routine since def direct
    80  38ec a92c                                lda #','                                 ; get comma
    81  38ee 8dff01                              sta buf_txtptr                           ; (data reader expects buffer to start with terminator)
    82                          
    83  38f1 201231             getagn           jsr PromptedInput                        ; type "?" and input a line of text
    84  38f4 a515               getagn1          lda channl
    85  38f6 f00d                                beq l56_1
    86  38f8 20b7ff                              jsr _readst                              ; get status byte
    87                          ; and #2   ; (assumes serial bus????)  [910618] eoi ok
    88  38fb 2987                                and #%10000111                           ; serial: err if dnp, r/w timeout errors
    89  38fd f006                                beq l56_1                                ; a-ok rs232: err if brk, ovr, frm, par errors
    90  38ff 20b438                              jsr release_channels                     ; bad, close channel
    91  3902 8344fc                              +lbra data                               ; skip rest of input
    92                          
    93  3905 ad0002             l56_1            lda buf                                  ; bufful. get anything?
    94  3908 d00f                                bne inpcon                               ; yes- process input
    95                          ; lda channl  ;didn't get anything.  is this keyboard? [901212]
    96                          ; bne getagn  ; no- keep looking for data ????
    97  390a 205b35                              jsr datan                                ; skip to end of statement
    98  390d 833cfc                              +lbra addon
    99                          
   100                          
   101  3910 7787               read             rmb7 op                                  ; flag READ vs. LREAD    [910102]
   102  3912 a643                                ldx datptr                               ; get last data location
   103  3914 a444                                ldy datptr+1
   104  3916 a998                                lda #$98                                 ; initiator= read
   105  3918 2c                                  !text $2c
   106                          
   107  3919 a900               inpcon           lda #0                                   ; initiator= input
   108  391b 8513               inpco1           sta input_flag                           ; $98=read, $40=get, $00=input
   109                          
   110                          ; In the processing of DATA and READ statements, one pointer points to the data
   111                          ; (i.e., the numbers being fetched) and another points to the list of variables.
   112                          ;
   113                          ; The pointer into the data always starts pointing to a terminator- a ",", ":", or EOL.
   114                          ; At this point TXTPTR points to list of variables and (x,y) points to data or input line.
   115                          
   116  391d 8645                                stx inpptr                               ; pointer to data
   117  391f 8446                                sty inpptr+1
   118                          
   119  3921 207c4f             inloop           jsr ptrget                               ; get a pointer to the variable
   120  3924 854b                                sta forpnt                               ; store its address
   121  3926 844c                                sty forpnt+1
   122                          
   123  3928 a201                                ldx #1
   124  392a b53d               l57_1            lda txtptr,x                             ; move variable list pointer to 'vartxt'
   125  392c 954d                                sta vartxt,x
   126  392e b545                                lda inpptr,x                             ; move data line pointer to 'txtptr'
   127  3930 953d                                sta txtptr,x
   128  3932 ca                                  dex
   129  3933 10f5                                bpl l57_1
   130                          
   131  3935 208522                              jsr chrgot                               ; get first data byte
   132  3938 d02f                                bne datbk1                               ; not null, so we got something
   133  393a 2413                                bit input_flag                           ; READ($98), GET($40), or INPUT($00)?
   134  393c 501a                                bvc qdata                                ; branch if READ or INPUT
   135  393e a576                                lda z_p_temp_1                           ; GET or GETKEY?
   136  3940 c9f9                                cmp #key_token
   137  3942 d008                                bne l57_3                                ; branch if GET
   138                          
   139  3944 205b68             l57_2            jsr cgetl                                ; GETKEY
   140  3947 aa                                  tax                                      ; test if null
   141  3948 f0fa                                beq l57_2                                ; it is null, keep scanning
   142  394a d003                                bne l57_4                                ; got a key, go put it in var
   143                          
   144  394c 205b68             l57_3            jsr cgetl                                ; get a key if pressed, otherwise gets a zero
   145  394f 8d0002             l57_4            sta buf
   146  3952 a2ff                                ldx #<buf_txtptr
   147  3954 a001                                ldy #>buf_txtptr
   148  3956 800d                                bra datbk
   149                          
   150                          
   151  3958 33f000             qdata            +lbmi datlop                             ; branch if READ
   152  395b a515                                lda channl                               ; else it's INPUT
   153  395d d003                                bne l58_1
   154  395f 206238                              jsr outqst                               ; console input, so display '? ' prompt
   155                          
   156  3962 201231             l58_1            jsr PromptedInput                        ; get another line
   157                          
   158  3965 863d               datbk            stx txtptr                               ; set for CHRGET
   159  3967 843e                                sty txtptr+1
   160                          
   161  3969 7f8708             datbk1           bbr7 op,l59_1                            ; no chrgot if LINPUT (want leading spaces) [910513]
   162  396c 20a540                              jsr chargt
   163  396f 208e22                              jsr chrtst
   164  3972 8003                                bra l59_2
   165                          
   166  3974 208322             l59_1            jsr chrget                               ; get next data byte
   167  3977 7f0f32             l59_2            bbr7 valtyp,l59_8                        ; get value type, input a number if numeric
   168  397a 6f1309                              bbr6 input_flag,l59_4                    ; branch if not get, set quote
   169  397d e8                                  inx
   170  397e 863d                                stx txtptr
   171  3980 a900               l59_3            lda #0                                   ; [901212]
   172  3982 850a                                sta charac
   173  3984 800f                                bra l59_5
   174                          
   175  3986 ff87f7             l59_4            bbs7 op,l59_3                            ; no terminators if LINPUT or LREAD  [901212]
   176  3989 850a                                sta charac                               ; setqut.  assume quoted string
   177  398b c922                                cmp #'"'                                 ; terminators ok?
   178  398d f007                                beq l59_6                                ; yes (sets .c)
   179  398f a93a                                lda #':'                                 ; set terminators to ":" and...
   180  3991 850a                                sta charac
   181  3993 a92c                                lda #','                                 ; ...comma
   182                          
   183  3995 18                 l59_5            clc                                      ; resetc
   184  3996 850b               l59_6            sta endchr                               ; nowget
   185  3998 a53d                                lda txtptr
   186  399a a43e                                ldy txtptr+1
   187  399c 6900                                adc #0                                   ; .c is set properly above
   188  399e 9001                                bcc l59_7
   189  39a0 c8                                  iny
   190  39a1 208b5a             l59_7            jsr strlt2                               ; make a string descriptor for the value & copy if needed
   191  39a4 20224e                              jsr st2txt                               ; copy strng2 to txtptr (st-2-txt... get it?)
   192  39a7 20b536                              jsr inpcom                               ; do assignment
   193  39aa 800d                                bra l59_9
   194                          
   195  39ac ff871d             l59_8            bbs7 op,l59_10                           ; error if LINPUT (string input only)  [901212]
   196  39af a200                                ldx #0                                   ; numins. flag 'text bank' (0)
   197  39b1 208d63                              jsr fin
   198  39b4 a510                                lda intflg                               ; set codes on flags
   199  39b6 209336                              jsr qintgr                               ; go decide on float
   200                          
   201  39b9 208522             l59_9            jsr chrgot                               ; strdn2. read last character
   202  39bc f041                                beq trmok                                ; ":" or EOL is ok
   203  39be c92c                                cmp #','                                 ; a comma?
   204  39c0 f03d                                beq trmok
   205                          
   206  39c2 a513                                lda input_flag                           ; is this get, read, or input?
   207  39c4 f00a                                beq l59_11                               ; input
   208  39c6 3004                                bmi l59_10                               ; read
   209  39c8 a615                                ldx channl                               ; get. if not kbd, go use 'bad file data error'
   210  39ca d008                                bne l59_12
   211                          
   212  39cc a216               l59_10           ldx #errtm                               ; tmerr. 'get from kbd' or 'read' saw a bad type
   213  39ce 8006                                bra l59_13                               ; always
   214                          
   215  39d0 a515               l59_11           lda channl
   216  39d2 f005                                beq l59_14                               ; do again if keybd input
   217  39d4 a218               l59_12           ldx #errbd                               ; input saw bad file data
   218  39d6 8377f4             l59_13           +lbra error
   219                          
   220                          
   221  39d9 20dc3c             l59_14           jsr highlight_text                       ; [911119]
   222  39dc 207dff                              jsr _primm
   223  39df 3f5245444f204652...                 !text "?REDO FROM START",cr,0
   224  39f1 20cb3c                              jsr highlight_done                       ; [911119]
   225                          
   226  39f4 ad7211             ott              lda oldtxt
   227  39f7 ac7311                              ldy oldtxt+1
   228  39fa 853d                                sta txtptr                               ; put user back to beginning of input
   229  39fc 843e                                sty txtptr+1
   230  39fe 60                                  rts
   231                          
   232                          
   233                          
   234  39ff a201               trmok            ldx #1
   235  3a01 b53d               l60_1            lda txtptr,x
   236  3a03 9545                                sta inpptr,x                             ; save for more reads
   237  3a05 b54d                                lda vartxt,x
   238  3a07 953d                                sta txtptr,x                             ; point to variable list
   239  3a09 ca                                  dex
   240  3a0a 10f5                                bpl l60_1
   241                          
   242  3a0c 208522                              jsr chrgot                               ; look at last vartab character
   243  3a0f f006                                beq l60_2                                ; that's the end of the list
   244  3a11 205b4e                              jsr chkcom                               ; not end. check for comma
   245  3a14 830bff                              +lbra inloop
   246                          
   247  3a17 a545               l60_2            lda inpptr                               ; put away a new data pntr name
   248  3a19 a446                                ldy inpptr+1
   249  3a1b 7f1305                              bbr7 input_flag,l60_3
   250  3a1e 8543                                sta datptr
   251  3a20 8444                                sty datptr+1
   252  3a22 60                                  rts
   253                          
   254  3a23 a000               l60_3            ldy #0                                   ; last data chr could have been ',' or ':' but should be null
   255  3a25 a945                                lda #inpptr
   256  3a27 20c722                              jsr lda_far_ram0
   257  3a2a f01d                                beq l60_4                                ; it is null
   258  3a2c a515                                lda channl                               ; if not terminal, no type
   259  3a2e d019                                bne l60_4
   260                          
   261  3a30 20dc3c                              jsr highlight_text                       ; [911119]
   262  3a33 207dff                              jsr _primm
   263  3a36 3f45585452412049...                 !text "?EXTRA IGNORED", cr,0
   264  3a46 20cb3c                              jsr highlight_done                       ; [911119]
   265                          
   266  3a49 60                 l60_4            rts                                      ; do next statement
   267                          
   268                          
   269                          ; DATLOP Routine Subroutine to find data.
   270                          ;
   271                          ; The search is made by using the execution code for data to skip over
   272                          ; statements, the start word of each statement is compared with "data_token".
   273                          ; Each new line number is stored in "datlin" so that if any error occurs while
   274                          ; reading data the error message can give the line number of the bad data.
   275                          
   276  3a4a 205b35             datlop           jsr datan                                ; skip some text
   277  3a4d c8                                  iny
   278  3a4e aa                                  tax                                      ; end of line?
   279  3a4f d016                                bne l61_1                                ; no
   280  3a51 a20d                                ldx #errod                               ; yes, "no data" error
   281  3a53 c8                                  iny
   282  3a54 20c522                              jsr indtxt
   283  3a57 f3f6f3                              +lbeq error
   284                          
   285  3a5a c8                                  iny
   286  3a5b 20c522                              jsr indtxt                               ; get high byte of line number
   287  3a5e 8541                                sta datlin
   288  3a60 c8                                  iny
   289  3a61 20c522                              jsr indtxt                               ; get low byte
   290  3a64 c8                                  iny
   291  3a65 8542                                sta datlin+1
   292                          
   293  3a67 204b35             l61_1            jsr addon                                ; nowlin.  txtptr+.y
   294  3a6a 208522                              jsr chrgot                               ; span blanks
   295  3a6d aa                                  tax                                      ; used later
   296  3a6e e083                                cpx #data_token                          ; is it a DATA statement?
   297  3a70 d0d8                                bne datlop                               ; not quite right, keep looking
   298  3a72 83f5fe                              +lbra datbk1                             ; this is the one
   299                          
   300                          

; ******** Source: basic.asm

; ******** Source: command/next.asm
     1                          
     2                          
     3                          
     4                          ; Next routine
     5                          ;
     6                          ; 'FOR' entry on the stack has the following format:
     7                          ;
     8                          ; Low address
     9                          ;  token (for_token) 1 byte
    10                          ;  a pointer to the loop variable 2 bytes
    11                          ;  the step 5 bytes
    12                          ;  a byte reflecting the sign of the incr. 2 bytes
    13                          ;  the upper value (packed) 5 bytes
    14                          ;  the line number of the FOR statement 2 bytes
    15                          ;  a text pointer into the FOR statement 2 bytes
    16                          ; High address
    17                          ;
    18                          ; (total 16 bytes)
    19                          
    20  3a75 d013               next             bne l62_2                                ; hop if 'next' variable given
    21  3a77 a0ff                                ldy #$ff                                 ; flag no specific 'for' variable
    22  3a79 8014                                bra l62_3                                ; always
    23                          
    24  3a7b a012               l62_1            ldy #lenfor                              ; done, clean up stack
    25  3a7d 20ef31                              jsr rlsstk                               ; release (y) items from stack
    26  3a80 208522                              jsr chrgot
    27  3a83 c92c                                cmp #','                                 ; ie., NEXT j,k
    28  3a85 d069                                bne l62_7
    29  3a87 208322                              jsr chrget
    30                          
    31  3a8a 207c4f             l62_2            jsr ptrget                               ; get pointer to variable in (a,y)
    32  3a8d 854b                                sta forpnt
    33                          
    34  3a8f 844c               l62_3            sty forpnt+1
    35  3a91 a981                                lda #for_token
    36  3a93 204331                              jsr search                               ; look for FOR entry in run-time stack
    37  3a96 f005                                beq l62_4                                ; branch if found
    38  3a98 a20a                                ldx #errnf                               ; otherwise 'error, not found'
    39  3a9a 83b3f3                              +lbra error
    40                          
    41                          
    42                          ; Set up to move STEP value to FAC
    43                          
    44  3a9d 20e631             l62_4            jsr movfnd                               ; (fndpnt) => (tos)
    45  3aa0 a53f                                lda fndpnt
    46  3aa2 18                                  clc
    47  3aa3 6903                                adc #3                                   ; offset to step value
    48  3aa5 a440                                ldy fndpnt+1
    49  3aa7 9001                                bcc l62_5
    50  3aa9 c8                                  iny
    51                          
    52  3aaa 200e62             l62_5            jsr movfm                                ; actually "move from ROM", but sys stack is in "common"
    53  3aad a008                                ldy #8                                   ; MOVFM doesn't move sign.  Get it
    54  3aaf b13f                                lda (fndpnt),y
    55  3ab1 8568                                sta facsgn
    56                          
    57                          ; Get pointer to FOR variable
    58                          
    59  3ab3 a001                                ldy #1
    60  3ab5 b13f                                lda (fndpnt),y                           ; get lsb
    61  3ab7 48                                  pha
    62  3ab8 aa                                  tax
    63  3ab9 c8                                  iny
    64  3aba b13f                                lda (fndpnt),y                           ; get msb
    65  3abc 48                                  pha
    66  3abd a8                                  tay                                      ; msb in y
    67  3abe 8a                                  txa                                      ; lsb in a
    68  3abf 20bb5d                              jsr fadd                                 ; add STEP value to FOR variable (fadd gets from bank 1)
    69  3ac2 7a                                  ply                                      ; msb in y
    70  3ac3 fa                                  plx                                      ; lsb in x
    71  3ac4 206262                              jsr movmf_ram1                           ; put result back into FOR variable in var bank
    72                          
    73                          ; Make (a,y) point at TO value in stack
    74                          
    75  3ac7 a53f                                lda fndpnt
    76  3ac9 18                                  clc
    77  3aca 6909                                adc #9
    78  3acc a440                                ldy fndpnt+1
    79  3ace 9001                                bcc l62_6
    80  3ad0 c8                                  iny
    81                          
    82                          ; Test if loop done
    83                          
    84                          l62_6
    85                          ; sta sw_rom_ram0 ;????
    86  3ad1 20f162                              jsr fcomp                                ; compare FAC to value pointed to by (a,y)
    87  3ad4 a008                                ldy #8
    88  3ad6 38                                  sec
    89  3ad7 f13f                                sbc (fndpnt),y                           ; (common area????)
    90  3ad9 f0a0                                beq l62_1                                ; branch taken if done
    91                          
    92  3adb a011                                ldy #17                                  ; not done, set pointers to re-execute loop
    93  3add b13f                                lda (fndpnt),y                           ; (common area????)
    94  3adf 853d                                sta txtptr
    95  3ae1 88                                  dey
    96  3ae2 b13f                                lda (fndpnt),y
    97  3ae4 853e                                sta txtptr+1
    98  3ae6 88                                  dey
    99  3ae7 b13f                                lda (fndpnt),y
   100  3ae9 853c                                sta curlin+1
   101  3aeb 88                                  dey
   102  3aec b13f                                lda (fndpnt),y
   103  3aee 853b                                sta curlin
   104  3af0 60                 l62_7            rts
   105                          

; ******** Source: basic.asm

; ******** Source: command/dim.asm
     1                          
     2                          
     3                          
     4                          ; The DIMension code sets DIMFLG and then falls into the variable search
     5                          ; routine, which looks at DIMFLG at 3 different points:
     6                          ;
     7                          ; 1) If an entry is found, DIMFLG being on indicates a
     8                          ;    doubly-defined variable.
     9                          ; 2) When a new entry is being built, DIMFLG being on indicates
    10                          ;    the indices should be used for the size of each index.
    11                          ;    Otherwise the default of ten is used.
    12                          ; 3) When the build entry code finishes, indexing will be done
    13                          ;    only if DIMFLG is off.
    14                          
    15                          
    16  3af1 205b4e             dim3             jsr chkcom                               ; must be a comma
    17                          
    18  3af4 aa                 dim              tax                                      ; make .x non-zero (.a must be non-zero to work correctly)
    19  3af5 20814f                              jsr ptrgt1
    20  3af8 208522                              jsr chrgot                               ; get last character
    21  3afb d0f4                                bne dim3
    22  3afd 60                                  rts
    23                          

; ******** Source: basic.asm

; ******** Source: command/sys.asm
     1                          
     2                          
     3                          
     4  3afe 208a5d             sys              jsr getwrd                               ; convert arg to integer value
     5  3b01 a516                                lda linnum                               ; set up arg's for call to 'long jsr'
     6  3b03 8504                                sta _pclo
     7  3b05 a517                                lda linnum+1
     8  3b07 8503                                sta _pchi
     9  3b09 add102                              lda current_bank
    10  3b0c 8502                                sta _bank
    11                          
    12  3b0e 202679                              jsr optbyt                               ; (optional) .A reg arg
    13  3b11 9002                                bcc l63_1
    14  3b13 8606                                stx _a_reg
    15                          
    16  3b15 202679             l63_1            jsr optbyt                               ; (optional) .X reg arg
    17  3b18 9002                                bcc l63_2
    18  3b1a 8607                                stx _x_reg
    19                          
    20  3b1c 202679             l63_2            jsr optbyt                               ; (optional) .Y reg arg
    21  3b1f 9009                                bcc l63_4
    22  3b21 8608                                stx _y_reg
    23                          
    24  3b23 202679             l63_3            jsr optbyt                               ; (optional) .Z reg arg
    25  3b26 9002                                bcc l63_4
    26  3b28 8609                                stx _z_reg
    27                          
    28  3b2a 202679             l63_4            jsr optbyt                               ; (optional) .S reg arg
    29  3b2d 9002                                bcc l63_5
    30  3b2f 8605                                stx _s_reg
    31                          
    32  3b31 4c6eff             l63_5            jmp _jsr_far                             ; far, far away
    33                          ;If returns, Kernel will update _reg's for us
    34                          

; ******** Source: basic.asm

; ******** Source: command/dma.asm
     1                          
     2                          
     3                          
     4                          ; DMA - Set up for DMA operation (FETCH/STASH/SWAP)
     5                          ;
     6                          ;  Syntax:  DMA  command,length,source(l/h/b),destination(l/h/b)[,subcmd,mod(l/h)] [,...]
     7                          
     8                          
     9                          dma                                                       ; params are not longer optional-  [910520] F018A
    10  3b34 206c5d                              jsr getbyt                               ; get command
    11  3b37 9009               l64_1            bcc l64_2
    12  3b39 8a                                  txa                                      ; [910102]
    13  3b3a 2904                                and #%00000100                           ;
    14  3b3c d3c016                              +lbne fcerr                              ; (disallow chained DMA lists)
    15  3b3f 8e5001                              stx dma2_cmd
    16                          
    17  3b42 20875d             l64_2            jsr comwrd                               ; get length
    18                          ; bcc l64_3
    19  3b45 8c5101                              sty dma2_cnt_lo
    20  3b48 8d5201                              sta dma2_cnt_hi
    21                          
    22  3b4b 20875d             l64_3            jsr comwrd                               ; get source address & bank
    23                          ; bcc l64_4
    24  3b4e 8c5301                              sty dma2_src_lo
    25  3b51 8d5401                              sta dma2_src_hi
    26  3b54 20825d             l64_4            jsr combyt
    27                          ; bcc l64_5
    28  3b57 8e5501                              stx dma2_src_bank
    29                          
    30  3b5a 20875d             l64_5            jsr comwrd                               ; get destination address & bank
    31                          ; bcc l64_6
    32  3b5d 8c5601                              sty dma2_dest_lo
    33  3b60 8d5701                              sta dma2_dest_hi
    34  3b63 20825d             l64_6            jsr combyt
    35                          ; bcc l64_7
    36  3b66 8e5801                              stx dma2_dest_bank
    37                          
    38  3b69 202479             l64_7            jsr optzer                               ; get subcmd, default=0    [910520] F018A
    39                          ; bcc l64_8
    40  3b6c 8e5901                              stx dma2_subcmd
    41                          
    42  3b6f 202479             l64_8            jsr optzer                               ; get mod lo/hi, default=0   [910102]
    43                          ; bcc l64_9
    44  3b72 8e5a01                              stx dma2_mod_lo
    45  3b75 202479             l64_9            jsr optzer
    46                          ; bcc l64_10
    47  3b78 8e5b01                              stx dma2_mod_hi
    48                          
    49  3b7b a000               l64_10           ldy #0                                   ; dma_list (bank 0)
    50  3b7d a201                                ldx #>dma2_cmd
    51  3b7f a950                                lda #<dma2_cmd
    52  3b81 8c02d7                              sty dma_ctlr+2                           ; dma_list bank
    53  3b84 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
    54  3b87 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
    55  3b8a 2c03d7             l64_11           bit dma_ctlr+3                           ; check status (in case IRQ enabled)  [910103]
    56  3b8d 30fb                                bmi l64_11                               ; busy
    57                          
    58  3b8f 208522                              jsr chrgot                               ; eol?
    59  3b92 f005                                beq l64_12                               ; yes
    60  3b94 202679                              jsr optbyt                               ; no- continue after getting comma & next cmd byte
    61  3b97 809e                                bra l64_1
    62                          
    63  3b99 60                 l64_12           rts
    64                          

; ******** Source: basic.asm

; ******** Source: command/trace.asm
     1                          
     2                          
     3                          
     4                          
     5                          tron                                                      ; trace mode on
     6  3b9a d77e                                smb5 runmod                              ; trcflg
     7  3b9c 60                                  rts
     8                          
     9                          
    10                          troff                                                     ; trace mode off
    11  3b9d 577e                                rmb5 runmod                              ; trcflg
    12  3b9f 60                                  rts
    13                          
    14                          

; ******** Source: basic.asm

; ******** Source: command/sys/returnreg.asm
     1                          
     2                          
     3                          
     4                          ; RREG - Return values of 6502 registers following a SYS call.
     5                          ;
     6                          ; Syntax : RREG [.A variable [,[.X[...Z] variable] [,[.S variable] ]]]
     7                          
     8  3ba0 a900               rreg             lda #0
     9  3ba2 850d                                sta count
    10                          
    11  3ba4 208522             l65_1            jsr chrgot
    12  3ba7 f038                                beq l65_4                                ; reached end of statement- done
    13  3ba9 c92c                                cmp #','                                 ; skip this arg?
    14  3bab f022                                beq l65_3                                ; branch if so
    15  3bad 207c4f                              jsr ptrget                               ; get pointer to target variable
    16  3bb0 854b                                sta forpnt                               ; a little bit of set up so we can share LET code
    17  3bb2 844c                                sty forpnt+1
    18  3bb4 a50f                                lda valtyp                               ; what kind of variable name did ptrget find?
    19  3bb6 d32f11                              +lbne chkerr                             ; type mismatch error if string
    20                          
    21  3bb9 a40d                                ldy count                                ; which register's value are we looking for?
    22  3bbb b90600                              lda _a_reg,y                             ; .A, .X, .Y, & .Z are contiguious
    23  3bbe c004                                cpy #4
    24  3bc0 d002                                bne l65_2
    25  3bc2 a505                                lda _s_reg                               ; but .S isn't
    26                          
    27  3bc4 a8                 l65_2            tay                                      ; low byte in .Y
    28  3bc5 a900                                lda #0                                   ; high byte of zero
    29  3bc7 203f4e                              jsr givayf                               ; go float it
    30  3bca a510                                lda intflg                               ; set conditions for type of var (int/float)
    31  3bcc 209336                              jsr qintgr                               ; ..and use part of LET to do the work
    32                          
    33  3bcf e60d               l65_3            inc count                                ; 5 registers to do
    34  3bd1 a50d                                lda count
    35  3bd3 c905                                cmp #5
    36  3bd5 b00a                                bcs l65_4
    37  3bd7 208522                              jsr chrgot                               ; was this e-o-statement?
    38  3bda f005                                beq l65_4
    39  3bdc 208322                              jsr chrget                               ; not e-o-s, skip over comma,
    40  3bdf d0c3                                bne l65_1                                ; ..and go do next
    41                          
    42  3be1 60                 l65_4            rts
    43                          

; ******** Source: basic.asm

; ******** Source: command/midstring.asm
     1                          
     2                          
     3                          
     4                          ; Alternate use of the MID$ function, as the target of an assignment.
     5                          ;
     6                          ; MID$(string_var,starting_position [,length]) = string_expression
     7                          
     8                          midd2
     9                          midwrk           =midd2-1
    10                          
    11  3be2 20584e                              jsr chkopn                               ; check for '('
    12  3be5 207c4f                              jsr ptrget                               ; get pointer to descriptor of string-var
    13  3be8 854b                                sta forpnt                               ; store for later use
    14  3bea 844c                                sty forpnt+1
    15  3bec 20dd4c                              jsr chkstr                               ; check if string
    16                          
    17  3bef 20825d                              jsr combyt                               ; look for comma, followed by 1 byte starting address
    18  3bf2 ca                                  dex                                      ; adjust starting addr
    19  3bf3 8677                                stx hulp                                 ; store    " "
    20                          
    21  3bf5 c929                                cmp #')'                                 ; finished?
    22  3bf7 f004                                beq l66_1                                ; branch if so (use default length)
    23  3bf9 20825d                              jsr combyt                               ; ..else get length
    24  3bfc 2c                                  !text $2c
    25                          
    26  3bfd a2ff               l66_1            ldx #$ff                                 ; default length
    27  3bff 8676                                stx z_p_temp_1
    28  3c01 20554e                              jsr chkcls                               ; look for ')'
    29  3c04 a9b2                                lda #equal_token                         ; look for '='
    30  3c06 205d4e                              jsr synchr
    31  3c09 20ef4c                              jsr frmevl                               ; bring on the source!
    32  3c0c 20dd4c                              jsr chkstr                               ; nothing funny
    33                          
    34  3c0f a002                                ldy #2                                   ; get string descriptors
    35  3c11 a94b               l66_2            lda #forpnt                              ; target
    36  3c13 20d722                              jsr lda_far_ram1                         ; lda (forpnt),y
    37  3c16 995d00                              sta str1,y
    38  3c19 20a922                              jsr indfmo                               ; source
    39  3c1c 996000                              sta str2,y
    40  3c1f 88                                  dey
    41  3c20 10ef                                bpl l66_2
    42                          
    43                          ; Test for target string in text was removed-  all strings are copied to
    44                          ; string RAM when they are created.
    45                          
    46  3c22 38                                  sec                                      ; adjust pointer to source string so that the same
    47  3c23 a561                                lda str2+1                               ; ..index can load & save
    48  3c25 e577                                sbc hulp
    49  3c27 8561                                sta str2+1
    50  3c29 b002                                bcs l66_3
    51  3c2b c662                                dec str2+2
    52                          
    53  3c2d a576               l66_3            lda z_p_temp_1                           ; get specified length (or default)
    54  3c2f c560                                cmp str2                                 ; compare with length of source
    55  3c31 9002                                bcc l66_4                                ; ok if less,
    56  3c33 a560                                lda str2                                 ; ..else use length of source
    57  3c35 aa                 l66_4            tax
    58  3c36 f01f                                beq l66_7                                ; done if length=0
    59  3c38 18                                  clc
    60  3c39 6577                                adc hulp                                 ; add length to starting posn.
    61  3c3b b3c115                              +lbcs fcerr                              ; illegal quantity error if > 256
    62  3c3e c55d                                cmp str1
    63  3c40 9003                                bcc l66_5
    64  3c42 d3ba15                              +lbne fcerr                              ; ...or if > target length
    65                          
    66  3c45 a477               l66_5            ldy hulp                                 ; get adjusted starting address
    67  3c47 da                 l66_6            phx
    68  3c48 a25e                                ldx #str1+1
    69  3c4a a961                                lda #str2+1
    70  3c4c 20d722                              jsr lda_far_ram1                         ; fetch from string bank
    71  3c4f 20f022                              jsr sta_far_ram1                         ; this is what it's all about
    72  3c52 c8                                  iny
    73  3c53 fa                                  plx
    74  3c54 ca                                  dex
    75  3c55 d0f0                                bne l66_6                                ; keep going for specified length
    76                          
    77  3c57 83141f             l66_7            +lbra frefac                             ; free up temp. string, rts
    78                          

; ******** Source: basic.asm

; ******** Source: command/auto.asm
     1                          
     2                          
     3                          
     4                          ; AUTO Increment
     5                          ;   Syntax :    auto {line-number} (line-number = 0 means turn off)
     6                          
     7                          auto
     8  3c5a 20ed58                              jsr errind
     9  3c5d 202e32                              jsr linget
    10  3c60 a516                                lda linnum
    11  3c62 8574                                sta autinc
    12  3c64 a517                                lda linnum+1
    13  3c66 8575                                sta autinc+1
    14  3c68 60                                  rts
    15                          
    16                          ;.end
    17                          
    18                          
    19                          
    20  3c69 aec702             help             ldx errnum                               ; check for error status
    21  3c6c e8                                  inx
    22  3c6d f022                                beq l67_1                                ; exit if there is no current error
    23  3c6f adc802                              lda errlin
    24  3c72 acc902                              ldy errlin+1
    25  3c75 8516                                sta linnum
    26  3c77 8417                                sty linnum+1
    27  3c79 20fa31                              jsr FindLine                             ; find the beginning of line with error
    28  3c7c 9013                                bcc l67_1                                ; exit if line not found?
    29                          
    30  3c7e 20f737                              jsr crdo                                 ; begin a new line
    31  3c81 a616                                ldx linnum
    32  3c83 a517                                lda linnum+1
    33  3c85 ab5500                              ldz helper
    34  3c88 4755                                rmb4 helper                              ; temporarily disable token highlighting
    35  3c8a f755                                smb7 helper                              ; set 'help' flag for P1LINE
    36  3c8c 207733                              jsr p1line                               ; display line & highlight error
    37  3c8f 6455                                stz helper
    38  3c91 7755               l67_1            rmb7 helper                              ; reset 'help' flag
    39  3c93 8362fb                              +lbra crdo                               ; and return to caller
    40                          
    41                          
    42                          
    43                          helpsb                                                    ; logic to highlight error or find string
    44  3c96 cf5532                              bbs4 helper,highlight_done               ; branch if highlighting tokens
    45  3c99 df5514                              bbs5 helper,l68_3                        ; branch if FIND
    46                          
    47  3c9c a662                                ldx lowtr+1                              ; has P1LINE reached code in error?
    48  3c9e 98                                  tya
    49  3c9f 18                                  clc
    50  3ca0 6561                                adc lowtr                                ; add character pointer to line pointer...
    51  3ca2 9001                                bcc l68_1
    52  3ca4 e8                                  inx
    53  3ca5 ecce02             l68_1            cpx errtxt+1                             ; and compare to error pointer
    54  3ca8 d005                                bne l68_2                                ; not there
    55  3caa cdcd02                              cmp errtxt
    56  3cad b02d                                bcs highlight_text                       ; we're there- begin highlighting
    57  3caf 60                 l68_2            rts
    58                          
    59                          
    60  3cb0 c43f               l68_3            cpy fndpnt                               ; at first character of find string?
    61  3cb2 9013                                bcc l68_5                                ; before it
    62  3cb4 adda02                              lda find_count
    63  3cb7 f00e                                beq l68_5                                ; past it
    64  3cb9 300d                                bmi l68_6                                ; at last character
    65  3cbb c58a                                cmp fstr1+2
    66  3cbd 9003                                bcc l68_4                                ; in middle of string
    67  3cbf 20dc3c                              jsr highlight_text                       ; at first char- start highlight
    68  3cc2 ceda02             l68_4            dec find_count                           ; one less character to highlight
    69  3cc5 f0fb                                beq l68_4                                ; special case-
    70                          ;make it negative for next time around
    71  3cc7 60                 l68_5            rts
    72                          
    73  3cc8 eeda02             l68_6            inc find_count                           ; make it zero
    74                          
    75                          
    76                          highlight_done                                            ; nasty kludge to colorize error or found text
    77  3ccb add902                              lda highlight_save
    78  3cce 300b                                bmi l69_1                                ; (unless it's already normal)
    79  3cd0 85f1                                sta _color                               ; restore normal color
    80  3cd2 0980                                ora #$80
    81  3cd4 8dd902                              sta highlight_save                       ; mark highlight_save invalid
    82  3cd7 7755                                rmb7 helper                              ; remove HELP flag
    83  3cd9 1755                                rmb1 helper                              ; remove token flag
    84  3cdb 60                 l69_1            rts
    85                          
    86                          
    87                          highlight_text                                            ; nasty kludge to colorize error or found text
    88  3cdc 2cd902                              bit highlight_save
    89  3cdf 100a                                bpl l70_1                                ; (unless it's already highlighted)
    90  3ce1 a5f1                                lda _color                               ; save current (normal) color
    91  3ce3 8dd902                              sta highlight_save                       ; msb=0 to mark highlight_save valid
    92  3ce6 add802                              lda highlight_color
    93  3ce9 85f1                                sta _color                               ; change color to highlight
    94  3ceb 60                 l70_1            rts
    95                          

; ******** Source: basic.asm

; ******** Source: command/gotosub.asm
     1                          
     2                          
     3                          
     4                          ; GOSUB-  Push text pointer, line #, & gosub token on stack:
     5                          ;
     6                          ;  (bottom) highest memory
     7                          ;===========================================================
     8                          ;  txtptr+1 address of next statement
     9                          ;  txtptr
    10                          ;  ========
    11                          ;  curlin+1 current line number
    12                          ;  curlin
    13                          ;  ========
    14                          ;  'gosub' token <== (tos) top of stack pointer
    15                          ;===========================================================
    16                          ;  (top of stack) lowest memory
    17                          
    18                          
    19  3cec cf7e6a             gosub            bbs4 runmod,edit_err                     ; [910620]
    20  3cef 20393d                              jsr gosub_sub
    21  3cf2 208522                              jsr chrgot                               ; get character and set carry for linget
    22  3cf5 20fb3c                              jsr goto
    23  3cf8 8313ef                              +lbra newstt
    24                          
    25                          
    26  3cfb cf7e5b             goto             bbs4 runmod,edit_err                     ; [910620]
    27  3cfe 202e32                              jsr linget                               ; pick up the line number in LINNUM
    28  3d01 a50b                                lda endchr                               ; test if linget found any number
    29  3d03 f345f1                              +lbeq snerr                              ; no number error
    30                          
    31  3d06 205e35             goto_1           jsr remn                                 ; jump to end of line (entry for interrupt code)
    32  3d09 38                                  sec
    33  3d0a a53b                                lda curlin
    34  3d0c e516                                sbc linnum
    35  3d0e a53c                                lda curlin+1
    36  3d10 e517                                sbc linnum+1
    37  3d12 b00b                                bcs luk4it
    38  3d14 98                                  tya
    39  3d15 38                                  sec
    40  3d16 653d                                adc txtptr
    41  3d18 a63e                                ldx txtptr+1
    42  3d1a 9007                                bcc lukall
    43  3d1c e8                                  inx
    44  3d1d 8004                                bra lukall                               ; always goes
    45                          
    46                          
    47  3d1f a52d               luk4it           lda txttab
    48  3d21 a62e                                ldx txttab+1
    49                          
    50  3d23 20fe31             lukall           jsr FindLink                             ; (a,x) are all set up
    51  3d26 9316f1                              +lbcc userr                              ; undefined statement error
    52  3d29 a561                                lda lowtr
    53  3d2b e901                                sbc #1
    54  3d2d 853d                                sta txtptr
    55  3d2f a562                                lda lowtr+1
    56  3d31 e900                                sbc #0
    57  3d33 853e                                sta txtptr+1
    58  3d35 7f7e63                              bbr7 runmod,setexc                       ; branch if in direct mode
    59  3d38 60                                  rts
    60                          
    61                          
    62                          
    63                          gosub_sub
    64  3d39 a905                                lda #lengos                              ; free up necessary space on stack
    65  3d3b 209431                              jsr getstk                               ; make sure there is room
    66  3d3e a004                                ldy #lengos-1
    67  3d40 a53e                                lda txtptr+1                             ; push on the text pointer
    68  3d42 917c                                sta (tos),y                              ; (common area)
    69  3d44 88                                  dey
    70  3d45 a53d                                lda txtptr
    71  3d47 917c                                sta (tos),y                              ; (common area)
    72  3d49 88                                  dey
    73  3d4a a53c                                lda curlin+1                             ; push on the current line number
    74  3d4c 917c                                sta (tos),y                              ; (common area)
    75  3d4e 88                                  dey
    76  3d4f a53b                                lda curlin
    77  3d51 917c                                sta (tos),y                              ; (common area)
    78  3d53 88                                  dey
    79  3d54 a98d                                lda #gosub_token                         ; (a) was smashed by GETSTK
    80  3d56 917c                                sta (tos),y                              ; (common area)
    81  3d58 60                                  rts
    82                          
    83                          
    84                          edit_err
    85  3d59 a22a                                ldx #edit_mode_error                     ; [910620]
    86  3d5b 83f2f0                              +lbra error
    87                          
    88                          ;.end
    89                          
    90                          
    91                          
    92                          go_without_to
    93  3d5e 208322                              jsr chrget                               ; what is next character?
    94  3d61 c9a4                                cmp #to_token                            ; ..is it GO TO?
    95  3d63 d005                                bne l71_1
    96  3d65 208322                              jsr chrget                               ; ..yes, set up for goto
    97  3d68 8091                                bra goto                                 ; ..bye!
    98                          
    99  3d6a 206c5d             l71_1            jsr getbyt                               ; is it GO 64?
   100  3d6d e040                                cpx #64
   101  3d6f d3d9f0                              +lbne snerr                              ; ...no, error
   102                          
   103                          ; The user wants to go to C64 mode.
   104                          
   105  3d72 20c378             l71_2            jsr are_you_sure
   106  3d75 d03c                                bne cont_rts                             ; must have had second thoughts. never mind
   107                          ; jsr put_io_in_map
   108  3d77 4c53ff                              jmp _go_64
   109                          
   110                          

; ******** Source: basic.asm

; ******** Source: command/continue.asm
     1                          
     2                          
     3                          ;**********************************************************
     4                          ;*
     5                          ;* CONTINUE Execution after STOP/END
     6                          ;*
     7                          ;**********************************************************
     8                          
     9  3d7a d037               cont             bne cont_rts                             ; make sure there is a terminator
    10  3d7c cf7eda                              bbs4 runmod,edit_err                     ; [910620]
    11  3d7f ff7e31                              bbs7 runmod,cont_rts                     ; if in run-mode just rts
    12                          
    13  3d82 a21a                                ldx #errcn                               ; continue error.
    14  3d84 ac7311                              ldy oldtxt+1                             ; a stored txtptr of zero set up by INIT_STACK
    15  3d87 f3c6f0                              +lbeq error                              ; indicates there is nothing to continue
    16                          
    17  3d8a ad7211                              lda oldtxt                               ; STOP, END, typing crlf to INPUT, and STOP key
    18  3d8d 853d                                sta txtptr
    19  3d8f 843e                                sty txtptr+1
    20  3d91 ad7011                              lda oldlin
    21  3d94 ac7111                              ldy oldlin+1
    22  3d97 853b                                sta curlin
    23  3d99 843c                                sty curlin+1
    24                          
    25  3d9b f77e               setexc           smb7 runmod                              ; set up run mode
    26  3d9d a900                                lda #0
    27  3d9f 8574                                sta autinc                               ; turn auto increment off
    28  3da1 8575                                sta autinc+1
    29  3da3 8ddc02                              sta intval                               ; enable & reset collision-trapping mechanism
    30  3da6 85f6                                sta _autoinsert                          ; disable auto-insert mode ?????
    31                          
    32  3da8 a202                                ldx #2                                   ; turn off all interrupt trip flags
    33  3daa 9ddd02             l72_1            sta int_trip_flag,x
    34  3dad ca                                  dex
    35  3dae 10fa                                bpl l72_1
    36                          
    37  3db0 2090ff                              jsr _setmsg                              ; turn kernel messages off & rts
    38                          
    39                          cont_rts
    40  3db3 60                                  rts
    41                          

; ******** Source: basic.asm

; ******** Source: command/run.asm
     1                          
     2                          
     3                          ;***********************************************************
     4                          ;*
     5                          ;* RUN Command
     6                          ;*
     7                          ;* RUN [line_number]
     8                          ;* RUN filename [[ON] Ddrive_number[,Uunit_number]]
     9                          ;*
    10                          ;* Entry:  RUN_A_PROGRAM sets up, links, and executes
    11                          ;*  a program previously loaded into RAM.
    12                          ;*
    13                          ;***********************************************************
    14                          
    15  3db4 cf7ea2             run              bbs4 runmod,edit_err                     ; [910620]
    16  3db7 f019                                beq run__10                              ; branch if no arguments
    17  3db9 901d                                bcc run__20                              ; branch if number (i.e., RUN line_number)
    18                          
    19                          
    20                          ; Here if of the form "RUN file_name"
    21                          
    22  3dbb e77e                                smb6 runmod                              ; set flag for load not to go to ready
    23  3dbd 206971                              jsr dload                                ; use DLOAD's parser, and load the program
    24  3dc0 b3742a                              +lbcs erexit                             ; if problem loading   [900801]
    25                          
    26                          run_a_program
    27  3dc3 20f737                              jsr crdo                                 ; [911010]
    28  3dc6 203e42                              jsr fix_links                            ; re-link the program
    29  3dc9 209b3d                              jsr setexc                               ; set various run modes
    30  3dcc 20a134                              jsr runc
    31  3dcf 833cee                              +lbra newstt                             ; start executing
    32                          
    33                          
    34                          ; Here if of the form "RUN"
    35                          
    36  3dd2 209b3d             run__10          jsr setexc                               ; set various run codes
    37  3dd5 83caf6                              +lbra runc                               ; ..and start executing
    38                          
    39                          
    40                          ; Here if of the form "RUN line_number"
    41                          
    42  3dd8 20cb34             run__20          jsr clearc                               ; first trash all variables
    43  3ddb 208522                              jsr chrgot
    44  3dde 20fb3c                              jsr goto                                 ; set up to execute from new line number
    45  3de1 209b3d                              jsr setexc                               ; ..and do a little housekeeping,
    46  3de4 8327ee                              +lbra newstt                             ; ..otherwise it's business as usual
    47                          

; ******** Source: basic.asm

; ******** Source: command/restore.asm
     1                          
     2                          
     3                          ;*********************************************************************
     4                          ;*
     5                          ;* RESTORE Command
     6                          ;*
     7                          ;* Reset pointers to next DATA statement.  Allows optional argument
     8                          ;* specifying a specific line number, otherwise the default is the
     9                          ;* beginning of text area.
    10                          ;*
    11                          ;*********************************************************************
    12                          
    13                          restor
    14  3de7 f013                                beq restore__1                           ; branch if no argument...use default
    15  3de9 208a5d                              jsr getwrd                               ; get 2 byte argument (???? no check for real number means a var legal)
    16  3dec 8416                                sty linnum
    17  3dee 8517                                sta linnum+1
    18  3df0 20fa31                              jsr FindLine                             ; get pointer to specified line
    19  3df3 9349f0                              +lbcc userr                              ; error if not found
    20                          
    21  3df6 a561                                lda lowtr                                ; decrement 2 byte pointer, and save it
    22  3df8 a462                                ldy lowtr+1
    23  3dfa 8005                                bra restore__2                           ; always
    24                          
    25                          
    26                          restore__1                                                ; entry from FLOAD
    27  3dfc 38                                  sec
    28  3dfd a52d                                lda txttab
    29  3dff a42e                                ldy txttab+1
    30                          
    31                          restore__2
    32  3e01 e901                                sbc #1
    33  3e03 b001                                bcs l73_1
    34  3e05 88                                  dey
    35  3e06 8543               l73_1            sta datptr
    36  3e08 8444                                sty datptr+1
    37  3e0a 60                                  rts
    38                          

; ******** Source: basic.asm

; ******** Source: command/renumber.asm
     1                          
     2                          
     3                          ;***********************************************************************
     4                          ;
     5                          ; RENUMBER Command
     6                          ;
     7                          ; Syntax:  RENUMBER [n1 [,[n2] ,n3]]
     8                          ;
     9                          ;  n1 = new start line number, default 10
    10                          ;  n2 = line increment, default 10
    11                          ;  n3 = start line, default first
    12                          ;
    13                          ; - Syntax error may occur for missing commas or bad line numbers.
    14                          ; - Illegal quantity error for line increment of 0 or for bad range.
    15                          ; - Overflow error if increment wraps line number during renumber,
    16                          ;  line number too large error if renumbering would force line
    17                          ;  numbers greater than 63999.
    18                          ; - Out of memory error if the renumbered program would be too large.
    19                          ; - Unresolved reference error if an imbedded line number references
    20                          ;  a line which does not exist.
    21                          ;
    22                          ; Otherwise returns to "ready" mode upon completion.
    23                          ;
    24                          ;***********************************************************************
    25                          
    26                          
    27                          ; Before any data is changed in any way, two preliminary passes are
    28                          ; made to insure no errors would occur during the actual renumbering
    29                          ; process (as detailed below).
    30                          ;
    31                          ; Pass 1 makes sure that the renumbered program would have no line
    32                          ; numbers greater than 63999 (nothing is actually renumbered; the
    33                          ; statement table is not modified).
    34                          ;
    35                          ; Pass 2 checks if the renumbered program would be too long and also
    36                          ; checks for non-existant line number destinations.
    37                          ;
    38                          ; Pass 3 examines the entire statement table first for imbedded line
    39                          ; numbers (branches) to fix. This is done by looking for keywords (GOTO,
    40                          ; GOSUB, THEN, RUN) which are usually followed by line numbers. The old
    41                          ; line number is mapped to a new value and the string representing the
    42                          ; new branch label replaces the original text.
    43                          ;
    44                          ; Pass 4 then replaces the statement number bytes by their final values.
    45                          ; and the table is relinked.
    46                          
    47                          
    48                          testwd
    49  3e0b 898a8da7                            !text goto_token,run_token,gosub_token,then_token
    50  3e0f 8cd6d7d5                            !text restore_token,resume_token,trap_token,else_token
    51                          
    52                          renumber
    53  3e13 20ed58                              jsr errind                               ; allowed only in direct mode
    54                          
    55                          ; Set up default values for n1, n2, and n3
    56                          
    57  3e16 a900                                lda #0                                   ; line #10...
    58  3e18 a20a                                ldx #10
    59  3e1a 8e7911                              stx renum_tmp_1                          ; default renum origin (n1)
    60  3e1d 8d7a11                              sta renum_tmp_1+1
    61  3e20 8e7b11                              stx renum_tmp_2                          ; default increment (n2)
    62  3e23 8d7c11                              sta renum_tmp_2+1
    63  3e26 855c                                sta hightr                               ; default start line # (n3)
    64  3e28 855d                                sta hightr+1
    65                          
    66  3e2a 208522                              jsr chrgot                               ; any parameters?
    67  3e2d f053                                beq ren_pass_1                           ; no...
    68                          
    69                          
    70                          ; Check for new starting line number (n1)
    71                          
    72  3e2f 202e32                              jsr linget                               ; check for a number
    73  3e32 a50b                                lda endchr                               ; was there one?
    74  3e34 f00a                                beq renum_10                             ; no...use default
    75  3e36 a516                                lda linnum
    76  3e38 a617                                ldx linnum+1
    77  3e3a 8d7911                              sta renum_tmp_1
    78  3e3d 8e7a11                              stx renum_tmp_1+1
    79                          
    80                          ; Check for new increment
    81                          
    82                          renum_10
    83  3e40 20f278                              jsr optwrd                               ; an increment given?
    84  3e43 900c                                bcc renum_30                             ; no...use default
    85                          
    86  3e45 8c7b11                              sty renum_tmp_2
    87  3e48 8d7c11                              sta renum_tmp_2+1
    88  3e4b 0d7b11                              ora renum_tmp_2                          ; increment must be >0
    89  3e4e f3ae13                              +lbeq fcerr                              ; illegal quantity error
    90                          
    91                          ; Check for starting line number
    92                          
    93                          renum_30
    94  3e51 20f278                              jsr optwrd                               ; starting line number given?
    95  3e54 902c                                bcc ren_pass_1                           ; no...
    96                          
    97  3e56 845c                                sty hightr
    98  3e58 8416                                sty linnum
    99  3e5a 855d                                sta hightr+1
   100  3e5c 8517                                sta linnum+1
   101  3e5e 20fa31                              jsr FindLine                             ; test for illegal renumber range
   102  3e61 a561                                lda lowtr                                ; (n1 must be >= n3)
   103  3e63 a662                                ldx lowtr+1
   104  3e65 855a                                sta highds                               ; pointer to first statement to renumber
   105  3e67 865b                                stx highds+1
   106  3e69 ad7911                              lda renum_tmp_1
   107  3e6c ae7a11                              ldx renum_tmp_1+1
   108  3e6f 8516                                sta linnum
   109  3e71 8617                                stx linnum+1
   110  3e73 20fa31                              jsr FindLine                             ; lowtr = ptr to 1st stmt to be overlapped
   111  3e76 38                                  sec
   112  3e77 a561                                lda lowtr                                ; can't be smaller
   113  3e79 e55a                                sbc highds
   114  3e7b a562                                lda lowtr+1
   115  3e7d e55b                                sbc highds+1
   116  3e7f 937d13                              +lbcc fcerr                              ; bad...
   117                          
   118                          
   119                          ;***********************************************************************
   120                          ;**************  R E N U M B E R    P A S S    O N E  ******************
   121                          ;***********************************************************************
   122                          
   123                          ; Pass 1 makes sure that the renumbered program will not have any line numbers
   124                          ; greater than 63999 (however, nothing is actually renumbered in this pass).
   125                          
   126                          ren_pass_1
   127  3e82 20472c                              jsr tto                                  ; save txtptr for restoration when done
   128  3e85 207240                              jsr n1_reset                             ; put n1 in FAC, reset txtptr
   129  3e88 20a540                              jsr chargt                               ; skip low link
   130  3e8b c8                                  iny                                      ; (.y=1)
   131  3e8c 20c522                              jsr indtxt                               ; skip high link
   132  3e8f f03a                                beq ren_pass_2                           ; end of program => begin pass 2 (assumes txttab > 0)
   133                          
   134                          r_pass1_10
   135  3e91 c8                                  iny                                      ; (.y=2)
   136  3e92 20c522                              jsr indtxt                               ; line number low
   137  3e95 38                                  sec
   138  3e96 e55c                                sbc hightr                               ; in line range which is to be renumbered?
   139  3e98 c8                                  iny                                      ; (.y=3)
   140  3e99 20c522                              jsr indtxt                               ; line number high
   141  3e9c e55d                                sbc hightr+1
   142  3e9e b007                                bcs r_pass1_20                           ; yes => fake renumbering
   143  3ea0 20ba3e                              jsr set_next                             ; goto next line
   144  3ea3 d0ec                                bne r_pass1_10                           ; if z=0 then not end-of-text => keep going
   145  3ea5 f024                                beq ren_pass_2                           ; else end
   146                          
   147                          r_pass1_20
   148  3ea7 20ba3e                              jsr set_next                             ; goto next line
   149  3eaa f01f                                beq ren_pass_2                           ; if z=1 then end-of-text => exit
   150  3eac 209340                              jsr new_num                              ; create next line number
   151  3eaf b004                                bcs r_pass1_30                           ; if c=1 then it wrapped => error
   152  3eb1 c9f9                                cmp #>63999                              ; can't have lines > 63999
   153  3eb3 90f2                                bcc r_pass1_20                           ; if c=0 then ok
   154                          
   155                          r_pass1_30                                                ; renumbering will generate an illegal line #
   156  3eb5 a226                                ldx #err_too_large                       ; 'line number too large' error
   157  3eb7 8396ef                              +lbra error
   158                          
   159                          set_next
   160  3eba a000                                ldy #0                                   ; set for next BASIC line
   161  3ebc 20c522                              jsr indtxt                               ; low link
   162  3ebf aa                                  tax
   163  3ec0 c8                                  iny                                      ; (.y=1)
   164  3ec1 20c522                              jsr indtxt                               ; high link
   165  3ec4 f004                                beq set_end                              ; if z=1 then end of program => exit
   166  3ec6 863d                                stx txtptr
   167  3ec8 853e                                sta txtptr+1
   168  3eca 60                 set_end          rts
   169                          
   170                          
   171                          ;***********************************************************************
   172                          ;**************  R E N U M B E R    P A S S    T W O  ******************
   173                          ;***********************************************************************
   174                          
   175                          ; Pass 2 checks if the renumbered program will be too long and also
   176                          ; checks for non-existant line number destinations.
   177                          
   178                          ren_pass_2
   179  3ecb 4f7e05                              bbr4 runmod,l74_1                        ; skip pass two and three if plain text (edit mode) [910620]
   180  3ece 207240                              jsr n1_reset                             ; yes- just setup up starting line # and reset txtptr
   181  3ed1 8014                                bra ren_pass_4                           ; then renumber just the text's line numbers
   182                          
   183  3ed3 a901               l74_1            lda #$01                                 ; set flag for 'pass 2'
   184  3ed5 8576                                sta z_p_temp_1
   185  3ed7 a582                                lda text_top                             ; copy top-of-text pointer for later use
   186  3ed9 a683                                ldx text_top+1                           ; (we don't want to change original here)
   187  3edb 853f                                sta fndpnt
   188  3edd 8640                                stx fndpnt+1
   189  3edf 20293f                              jsr imbed_lines                          ; search for imbedded lines (but don't change)
   190                          
   191                          
   192                          
   193                          ;***********************************************************************
   194                          ;************  R E N U M B E R    P A S S    T H R E E  ****************
   195                          ;***********************************************************************
   196                          
   197                          ; Pass 3 actually renumbers the imbedded destination line numbers
   198                          ; which follow goto, gosub, trap, etc.
   199                          
   200                          ren_pass_3
   201  3ee2 c676                                dec z_p_temp_1                           ; z_p_temp_1 = 0 (for pass 3)
   202  3ee4 20293f                              jsr imbed_lines                          ; search for and update imbedded line #'s
   203                          
   204                          
   205                          ;***********************************************************************
   206                          ;*************  R E N U M B E R    P A S S    F O U R  *****************
   207                          ;***********************************************************************
   208                          
   209                          ; Pass 4 actually renumbers the program line numbers & exits
   210                          
   211                          ren_pass_4
   212  3ee7 20a340                              jsr chargt_x2                            ; skip link
   213  3eea f031                                beq renumber_exit                        ; null link=> end-of-text, exit (assumes txttab > 0)
   214  3eec 20a540                              jsr chargt                               ; not null...
   215  3eef 8516                                sta linnum                               ; if line# >= start#, replace with facho
   216  3ef1 c8                                  iny
   217  3ef2 20c522                              jsr indtxt
   218  3ef5 38                                  sec
   219  3ef6 e55d                                sbc hightr+1
   220  3ef8 901b                                bcc r_pass4_20                           ; no, let alone
   221  3efa d006                                bne r_pass4_10                           ; yes, replace
   222  3efc a516                                lda linnum
   223  3efe e55c                                sbc hightr
   224  3f00 9013                                bcc r_pass4_20                           ; no, let alone
   225                          
   226                          r_pass4_10
   227  3f02 a564                                lda facho
   228                          ; phx
   229  3f04 200a23                              jsr sta_far_txt                          ; sta (txtptr),y  hi  (bleed-thru)
   230  3f07 88                                  dey
   231  3f08 a565                                lda facho+1
   232  3f0a 200a23                              jsr sta_far_txt                          ; sta (txtptr),y  lo (bleed-thru)
   233                          ; plx
   234  3f0d 20a540                              jsr chargt                               ; skip past 2nd byte of line#
   235  3f10 208a40                              jsr line_inc                             ; incr line# and scan to eol
   236  3f13 80d2                                bra ren_pass_4                           ; always...
   237                          
   238                          r_pass4_20
   239  3f15 20a540                              jsr chargt                               ; skip past line#
   240  3f18 208d40                              jsr scan_thru                            ; scan to eol
   241  3f1b 80ca                                bra ren_pass_4                           ; always...
   242                          
   243                          
   244                          renumber_exit
   245  3f1d 203e42                              jsr fix_links                            ; patch things up: relink & set eot
   246                          
   247                          direct_mode_exit
   248  3f20 20f439                              jsr ott                                  ; restore txtptr for next command in buffer
   249  3f23 a900                                lda #0                                   ; but disallow continuing
   250  3f25 8d7311                              sta oldtxt+1
   251  3f28 60                                  rts
   252                          
   253                          
   254                          ;***********************************************************************
   255                          ;*************  R E N U M B E R   S U B R O U T I N E S  ***************
   256                          ;***********************************************************************
   257                          
   258                          ; Look for imbedded line #'s (after GOTO, GOSUB, etc.)
   259                          ; but only change them in pass 3 (ie. z_p_temp_1 = 0)
   260                          
   261                          imbed_lines
   262  3f29 201f35                              jsr reset_txtptr                         ; start at first line: load (txtptr) with (txttab)-1
   263                          
   264                          next_line
   265  3f2c 20a340                              jsr chargt_x2                            ; skip link (assumes txttab > 0)
   266  3f2f f34101                              +lbeq n1_reset                           ; null link: put current line # in fac, reset txtptr, exit
   267  3f32 20a540                              jsr chargt                               ; line number
   268  3f35 854b                                sta forpnt                               ; save in case there is an error
   269  3f37 20a540                              jsr chargt
   270  3f3a 854c                                sta forpnt+1
   271                          
   272                          next_char
   273  3f3c 20a540                              jsr chargt                               ; first character in the line
   274                          
   275                          chk_quote
   276  3f3f c922                                cmp #'"'                                 ; opening double quote?
   277  3f41 d00b                                bne not_quote                            ; no...
   278  3f43 20a540             l75_1            jsr chargt                               ; scan line
   279  3f46 f0e4                                beq next_line                            ; end...
   280  3f48 c922                                cmp #'"'                                 ; close double quote
   281  3f4a d0f7                                bne l75_1                                ; no... continue
   282  3f4c 80ee                                bra next_char                            ; yes... resume renumber
   283                          
   284                          not_quote
   285  3f4e aa                                  tax                                      ; end of line?
   286  3f4f f0db                                beq next_line                            ; yes...
   287  3f51 10e9                                bpl next_char                            ; not a token...
   288                          
   289  3f53 a208                                ldx #8                                   ; check special token list
   290  3f55 dd0a3e             l76_1            cmp testwd-1,x
   291  3f58 f028                                beq iline_10                             ; a match...
   292  3f5a ca                                  dex
   293  3f5b d0f8                                bne l76_1                                ; continue until zero
   294                          
   295  3f5d c9cb                                cmp #go_token                            ; wasn't in the token list. check for 'go to'
   296  3f5f d00b                                bne chk_escape                           ; not 'go', go check for 'collision' *c128 fix*
   297  3f61 208322             hop_1            jsr chrget                               ; got a 'go', look for 'to'
   298  3f64 f0c6                                beq next_line                            ; end of line, abort
   299  3f66 c9a4                                cmp #to_token
   300  3f68 f018                                beq iline_10                             ; got it! go to fix number routine
   301  3f6a 80d0                                bra next_char                            ; no 'to', keep looking
   302                          
   303                          ; Look for 'COLLISION'.  This is an escape command. *c128 fix* ?????????
   304                          
   305                          chk_escape
   306  3f6c c9fe                                cmp #esc_command_token
   307  3f6e d0cc                                bne next_char
   308  3f70 208322                              jsr chrget
   309  3f73 f0ec                                beq hop_1                                ; end of line ,abort
   310  3f75 c917                                cmp #collision_token
   311  3f77 d0c3                                bne next_char
   312  3f79 208322             l77_1            jsr chrget                               ; got it! skip over first argument
   313  3f7c f0e3                                beq hop_1                                ; end of line, abort
   314  3f7e c92c                                cmp #','
   315  3f80 d0f7                                bne l77_1                                ; not there yet
   316                          
   317                          
   318                          iline_10
   319  3f82 a53d                                lda txtptr                               ; save current txtptr
   320  3f84 8d7011                              sta oldlin
   321  3f87 a53e                                lda txtptr+1
   322  3f89 8d7111                              sta oldlin+1
   323  3f8c 208322                              jsr chrget
   324  3f8f b0ae                                bcs chk_quote                            ; not a #...
   325  3f91 202e32                              jsr linget                               ; get line # from text
   326  3f94 202340                              jsr form_line                            ; replace if this line # > n3
   327  3f97 ad7011                              lda oldlin                               ; restore old txtptr
   328  3f9a 853d                                sta txtptr
   329  3f9c ad7111                              lda oldlin+1
   330  3f9f 853e                                sta txtptr+1
   331                          
   332  3fa1 208322                              jsr chrget                               ; skip over leading spaces
   333  3fa4 c33d                                dew txtptr                               ; then backup (txtptr) by 1
   334  3fa6 a2ff                                ldx #$ff
   335  3fa8 a576                                lda z_p_temp_1                           ; if this is pass2 then don't actually change
   336  3faa f037                                beq p3code                               ; if z=1 then pass3 => ok to change
   337  3fac 20b83f                              jsr p2code                               ; renumber 'pass two': trial run to see if enough room
   338  3faf 208522                              jsr chrgot                               ; re-get last character from BASIC text & rts
   339                          
   340                          iline_20
   341  3fb2 c92c                                cmp #','                                 ; comma from 'on'?
   342  3fb4 f0cc                                beq iline_10                             ; it is...
   343  3fb6 8087                                bra chk_quote                            ; no...
   344                          
   345                          
   346                          ;*********** This part of imbed_lines executed in pass 2 only **********
   347                          
   348                          p2code                                                    ; updates text_top without actually changing lines
   349  3fb8 e8                                  inx
   350  3fb9 bd0101                              lda fbuffr+1,x                           ; get character from number
   351  3fbc f01c                                beq l78_3                                ; end of number
   352  3fbe 208322                              jsr chrget                               ; get digit from old number
   353  3fc1 90f5                                bcc p2code                               ; digit...move on
   354                          
   355  3fc3 e33f               l78_1            inw fndpnt
   356  3fc5 38                                  sec                                      ; have we run out of memory (theoretically)?
   357  3fc6 a53f                                lda fndpnt                               ; (compare with limit-of-memory pointer)
   358  3fc8 edcf02                              sbc max_mem_0
   359  3fcb a540                                lda fndpnt+1
   360  3fcd edd002                              sbc max_mem_0+1
   361  3fd0 b36fee                              +lbcs omerr                              ; yes- out of memory error
   362  3fd3 e8                                  inx                                      ; no - next...
   363  3fd4 bd0101                              lda fbuffr+1,x
   364  3fd7 d0ea                                bne l78_1
   365  3fd9 60                 l78_2            rts                                      ; no more
   366                          
   367  3fda 208322             l78_3            jsr chrget
   368  3fdd b0fa                                bcs l78_2                                ; old stuff after # is other char
   369  3fdf c33f                                dew fndpnt                               ; digit...move down
   370  3fe1 80f7                                bra l78_3                                ; still digits...
   371                          
   372                          
   373                          ;*********** This part of imbed_lines executed in pass 3 only **********
   374                          
   375                          p3code
   376  3fe3 e8                                  inx
   377  3fe4 bd0101                              lda fbuffr+1,x                           ; get character from number
   378  3fe7 f026                                beq l79_3                                ; end of number
   379                          
   380  3fe9 48                                  pha                                      ; save digit from new number
   381  3fea 20a540                              jsr chargt                               ; get digit from old number
   382  3fed c93a                                cmp #':'                                 ; command terminator or letter?
   383  3fef b00c                                bcs l79_1
   384  3ff1 c920                                cmp #' '                                 ; space? (fix for goto10 :rem)
   385  3ff3 f008                                beq l79_1
   386  3ff5 38                                  sec
   387  3ff6 e930                                sbc #'0'                                 ; number?
   388  3ff8 38                                  sec
   389  3ff9 e9d0                                sbc #$d0
   390  3ffb 9008                                bcc l79_2                                ; digit...move on
   391                          
   392  3ffd 20ac40             l79_1            jsr move_init                            ; other char...move up
   393  4000 201741                              jsr moveup
   394  4003 e382                                inw text_top
   395                          
   396  4005 68                 l79_2            pla
   397  4006 da                                  phx
   398  4007 a000                                ldy #0
   399  4009 200a23                              jsr sta_far_txt                          ; put new digit in new number (bleed-thru)
   400  400c fa                                  plx
   401  400d 80d4                                bra p3code
   402                          
   403                          
   404  400f 208322             l79_3            jsr chrget
   405  4012 b09e                                bcs iline_20                             ; old stuff after # is other char
   406                          
   407  4014 20ac40             l79_4            jsr move_init                            ; digit...move down
   408  4017 20c440                              jsr movedown
   409  401a c382                                dew text_top
   410  401c 208522                              jsr chrgot
   411  401f 90f3                                bcc l79_4                                ; still digits...
   412                          
   413  4021 808f                                bra iline_20                             ; branch always
   414                          
   415                          
   416                          ;*************************** FORM_LINE *********************************
   417                          
   418                          ; Remaps the destination line if it is greater than n3
   419                          
   420                          form_line
   421  4023 207240                              jsr n1_reset
   422                          find_it
   423  4026 20a340                              jsr chargt_x2                            ; new line, skip over link
   424  4029 d00d                                bne l80_1                                ; if we get to end-of-text without finding the
   425  402b a227                                ldx #err_ref                             ; line # then 'unresolved reference' error
   426  402d a54b                                lda forpnt
   427  402f 853b                                sta curlin                               ; fake error routine into saying 'in line xxxxx'
   428  4031 a54c                                lda forpnt+1
   429  4033 853c                                sta curlin+1
   430  4035 8318ee                              +lbra error
   431                          
   432  4038 20a540             l80_1            jsr chargt                               ; get line number low
   433  403b 855a                                sta highds                               ; highds = current line# in loop
   434  403d c516                                cmp linnum
   435  403f d027                                bne l80_4
   436  4041 20a540                              jsr chargt                               ; get line number high
   437  4044 855b                                sta highds+1
   438  4046 c517                                cmp linnum+1
   439  4048 d023                                bne l80_5
   440  404a 38                                  sec                                      ; if linnum < start#, no remapping
   441  404b e55d                                sbc hightr+1
   442  404d 9008                                bcc l80_2
   443  404f d00e                                bne l80_3
   444  4051 a516                                lda linnum
   445  4053 e55c                                sbc hightr
   446  4055 b008                                bcs l80_3
   447                          
   448  4057 a516               l80_2            lda linnum                               ; use same line#
   449  4059 8565                                sta facho+1
   450  405b a517                                lda linnum+1
   451  405d 8564                                sta facho
   452                          
   453  405f a290               l80_3            ldx #$90                                 ; make replacement string
   454  4061 38                                  sec
   455  4062 20df62                              jsr floatc
   456  4065 832824                              +lbra fout
   457                          
   458                          
   459  4068 20a540             l80_4            jsr chargt
   460  406b 855b                                sta highds+1                             ; (** 01/27/84 fix)
   461                          
   462  406d 207f40             l80_5            jsr line_add                             ; scan to end of line
   463  4070 80b4                                bra find_it                              ; always
   464                          
   465                          
   466                          ;*************************** N1_RESET **********************************
   467                          
   468                          ; Copies n1 (new renumber origin) into facho & sets (txtptr) = (txttab)-1
   469                          
   470                          n1_reset
   471  4072 ad7911                              lda renum_tmp_1
   472  4075 8565                                sta facho+1
   473  4077 ad7a11                              lda renum_tmp_1+1
   474  407a 8564                                sta facho
   475  407c 83a1f4                              +lbra reset_txtptr
   476                          
   477                          
   478                          ;*************************** LINE_ADD **********************************
   479                          
   480                          ; Adds n2 (new line increment) to line number stored in facho if the
   481                          ; current line number (highds) >= n3 (line to start renumbering with).
   482                          ; The line is then scanned.
   483                          
   484                          line_add
   485  407f a55a                                lda highds                               ; if line# >= start# then incr new#
   486  4081 38                                  sec
   487  4082 e55c                                sbc hightr
   488  4084 a55b                                lda highds+1
   489  4086 e55d                                sbc hightr+1
   490  4088 9003                                bcc scan_thru
   491                          
   492                          line_inc
   493  408a 209340                              jsr new_num
   494                          
   495                          scan_thru
   496  408d 20a540                              jsr chargt                               ; scan to end of line
   497  4090 d0fb                                bne scan_thru
   498  4092 60                                  rts
   499                          
   500                          
   501                          ;**************************** NEW_NUM **********************************
   502                          
   503                          ; Adds n2 (the new line increment) to the line number stored in facho.
   504                          
   505                          new_num
   506  4093 a565                                lda facho+1                              ; increment new line#
   507  4095 18                                  clc
   508  4096 6d7b11                              adc renum_tmp_2
   509  4099 8565                                sta facho+1
   510  409b a564                                lda facho
   511  409d 6d7c11                              adc renum_tmp_2+1
   512  40a0 8564                                sta facho
   513  40a2 60                                  rts
   514                          
   515                          
   516                          ;********************** CHARGT & CHARGT_X2 *****************************
   517                          
   518                          ; Chargt simulates chrget but doesn't ignore spaces & carry has no
   519                          ; significance.  Chargt_x2 executes chargt twice.
   520                          ; Used by Renumber, Find/Change, etc.
   521                          
   522                          chargt_x2
   523  40a3 e33d                                inw txtptr                               ; jsr chargt
   524                          chargt
   525  40a5 a000                                ldy #0                                   ; increment txtptr
   526  40a7 e33d                                inw txtptr
   527  40a9 831ae2                              +lbra indtxt
   528                          
   529                          
   530                          ;***********************************************************************
   531                          ;************************* MEMORY MOVE ROUTINES ************************
   532                          ;***********************************************************************
   533                          
   534                          ;****************************** MOVEINIT *******************************
   535                          
   536                          ; Setup for Renumber memory move.
   537                          
   538                          move_init
   539  40ac a53d                                lda txtptr                               ; index1 = txtptr
   540  40ae 8524                                sta index1
   541  40b0 a53e                                lda txtptr+1
   542  40b2 8525                                sta index1+1
   543                          
   544  40b4 a582                                lda text_top                             ; index2 = text_top
   545  40b6 8526                                sta index2
   546  40b8 a583                                lda text_top+1
   547  40ba 8527                                sta index2+1
   548                          
   549  40bc a901                                lda #1                                   ; move 1 character
   550  40be 850d                                sta count                                ; lo
   551  40c0 3a                                  dec
   552  40c1 856d                                sta argmo                                ; hi
   553                          
   554  40c3 60                                  rts
   555                          
   556                          
   557                          ;****************************** MOVEDOWN *******************************
   558                          
   559                          ; Move block of BASIC text from INDEX1+COUNT to INDEX2 down to INDEX1.
   560                          ; Used by commands Renumber, Find/Change.
   561                          
   562                          movedown
   563  40c4 38                                  sec                                      ; set up DMA list:   [900524]
   564  40c5 a526                                lda index2
   565  40c7 e524                                sbc index1
   566  40c9 8d4501                              sta dma1_cnt_lo                          ; cnt = index2-index1-count
   567  40cc a527                                lda index2+1
   568  40ce e525                                sbc index1+1
   569  40d0 8d4601                              sta dma1_cnt_hi
   570  40d3 38                                  sec
   571  40d4 ad4501                              lda dma1_cnt_lo
   572  40d7 e50d                                sbc count                                ; lo
   573  40d9 8d4501                              sta dma1_cnt_lo
   574  40dc ad4601                              lda dma1_cnt_hi
   575  40df e56d                                sbc argmo                                ; hi
   576  40e1 8d4601                              sta dma1_cnt_hi
   577                          
   578  40e4 18                                  clc
   579  40e5 a524                                lda index1
   580  40e7 8d4a01                              sta dma1_dest_lo                         ; dest = index1
   581  40ea 650d                                adc count
   582  40ec 8d4701                              sta dma1_src_lo                          ; src = index1+count
   583  40ef a525                                lda index1+1
   584  40f1 8d4b01                              sta dma1_dest_hi
   585  40f4 656d                                adc argmo
   586  40f6 8d4801                              sta dma1_src_hi
   587                          
   588  40f9 a584                                lda text_bank                            ; bank = BASIC text bank
   589                          ; and #%00001111  ;      [910520] F018A
   590  40fb 8d4901                              sta dma1_src_bank
   591  40fe 8d4c01                              sta dma1_dest_bank
   592                          
   593                          execute_DMA1                                              ; [910620] Edit
   594  4101 a900                                lda #0
   595  4103 8d4401                              sta dma1_cmd                             ; command = copy from startpoint
   596  4106 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
   597                          
   598  4109 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
   599  410c a901                                lda #>dma1_cmd
   600  410e 8d01d7                              sta dma_ctlr+1                           ; dma_list hi
   601  4111 a944                                lda #<dma1_cmd
   602  4113 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
   603  4116 60                                  rts
   604                          
   605                          
   606                          ;******************************* MOVEUP ********************************
   607                          
   608                          ; Move block of BASIC text from INDEX1 to INDEX2 up to INDEX2+COUNT.
   609                          ; Used by commands Renumber, Find/Change.
   610                          
   611                          moveup
   612  4117 38                                  sec                                      ; set up DMA list:   [900524]
   613  4118 a526                                lda index2
   614  411a e524                                sbc index1
   615  411c 8d4501                              sta dma1_cnt_lo                          ; cnt = index2-index1
   616  411f a527                                lda index2+1
   617  4121 e525                                sbc index1+1
   618  4123 8d4601                              sta dma1_cnt_hi
   619                          
   620  4126 c326                                dew index2                               ; (index2 = text_top = end+1)
   621  4128 18                                  clc
   622  4129 a526                                lda index2
   623  412b 8d4701                              sta dma1_src_lo                          ; src = index2
   624  412e 650d                                adc count
   625  4130 8d4a01                              sta dma1_dest_lo                         ; dest = index2+count
   626  4133 a527                                lda index2+1
   627  4135 8d4801                              sta dma1_src_hi
   628  4138 656d                                adc argmo
   629  413a 8d4b01                              sta dma1_dest_hi
   630                          
   631                          ; lda dma_ctlr+3  ;dma controller version    [910520] F018A
   632                          ; and #1
   633                          ; beq l81_1   ; F018    removed [910808] F018B
   634  413d a930                                lda #%00110000                           ; F018A,B
   635  413f 8d4401             l81_1            sta dma1_cmd                             ; command=copy, source=start   [910102]
   636                          ; php
   637  4142 a584                                lda text_bank                            ; bank = BASIC text bank   [910520] F018A
   638                          ; plp   ;version?    removed [910808] F018B
   639                          ; bne l81_2   ; F018A
   640                          ; and #%00001111  ; F018     [910102]
   641                          ; ora #%01000000  ;(copy source=endpoint)    [910102]
   642  4144 8d4901             l81_2            sta dma1_src_bank                        ; banks
   643  4147 8d4c01                              sta dma1_dest_bank
   644                          
   645  414a a900                                lda #0                                   ; [910219]
   646                          ; sta dma1_cmd  ; command = copy, source=endpoint
   647  414c 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
   648                          ; dec a   ;      [910219]
   649  414f 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
   650  4152 a001                                ldy #>dma1_cmd                           ; dma_list
   651  4154 a944                                lda #<dma1_cmd
   652  4156 8c01d7                              sty dma_ctlr+1                           ; dma_list hi
   653  4159 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
   654  415c 60                                  rts
   655                          
   656                          ;.end

; ******** Source: basic.asm

; ******** Source: command/for.asm
     1                          
     2                          ; FOR
     3                          ;
     4                          ; Push the following information on the run-time stack:
     5                          ;
     6                          ; (bottom)   highest memory
     7                          ; =========================
     8                          ;  txtptr    address of next statement
     9                          ;  txtptr+1
    10                          ;  ========
    11                          ;  curlin+1  current line number
    12                          ;  curlin
    13                          ;  ========
    14                          ;  to lo
    15                          ;  to mo
    16                          ;  to moh    'to' value
    17                          ;  to ho
    18                          ;  to exp
    19                          ;  ========
    20                          ;  step sign
    21                          ;  step lo
    22                          ;  step mo
    23                          ;  step moh  'step' value
    24                          ;  step ho
    25                          ;  step exp
    26                          ;  ========
    27                          ;  forpnt+1  'for' variable pointer
    28                          ;  forpnt
    29                          ;  ========
    30                          ;  'for' token       <== (tos) top of stack pointer
    31                          ; ============================
    32                          ; (top of stack)  lowest memory
    33                          
    34                          
    35  415d a980               for              lda #$80
    36  415f 8512                                sta subflg                               ; no arrays(), no integers%
    37  4161 207636                              jsr let                                  ; get & set FOR variables
    38  4164 a981                                lda #for_token                           ; set up for call to see if
    39  4166 204331                              jsr search                               ; ..this 'for' variable is unique
    40  4169 f008                                beq l82_1                                ; branch if not
    41                          
    42                          ; If the variable is not unique, (fndpnt) will point to last occurance
    43                          ; in stack, and we will reset the stack to that point.  Otherwise we
    44                          ; will adjust the pointer by 'lenfor' and start from that point.
    45                          
    46  416b a912                                lda #lenfor
    47  416d 209431                              jsr getstk                               ; updates stack pointer, error if overflow
    48  4170 20dd31                              jsr movtos                               ; (tos) => (fndpnt)
    49                          
    50  4173 20e631             l82_1            jsr movfnd                               ; (fndpnt) => (tos)   (redundant for new entries)
    51  4176 205b35                              jsr datan                                ; find address of next statement
    52  4179 98                                  tya                                      ; offset from (txtptr) in y
    53  417a a011                                ldy #lenfor-1
    54                          
    55  417c 18                                  clc                                      ; Push address of next statement on stack
    56  417d 653d                                adc txtptr
    57  417f 917c                                sta (tos),y                              ; (common area)
    58  4181 a53e                                lda txtptr+1
    59  4183 6900                                adc #0
    60  4185 88                                  dey
    61  4186 917c                                sta (tos),y                              ; (common area)
    62                          
    63  4188 a53c                                lda curlin+1                             ; Push current line number on stack
    64  418a 88                                  dey
    65  418b 917c                                sta (tos),y                              ; (common area)
    66  418d a53b                                lda curlin
    67  418f 88                                  dey
    68  4190 917c                                sta (tos),y                              ; (common area)
    69                          
    70  4192 a9a4                                lda #to_token                            ; Look for TO, must appear
    71  4194 205d4e                              jsr synchr
    72  4197 20db4c                              jsr chknum                               ; get TO value
    73  419a 20d84c                              jsr frmnum
    74  419d a568                                lda facsgn
    75  419f 097f                                ora #$7f
    76  41a1 2564                                and facho
    77  41a3 8564                                sta facho
    78                          
    79  41a5 a204                                ldx #4
    80  41a7 a00d                                ldy #lenfor-5
    81  41a9 b563               l82_2            lda facexp,x                             ; Push faclo,mo,moh,ho,exp
    82  41ab 917c                                sta (tos),y                              ; (common area)
    83  41ad ca                                  dex
    84  41ae 88                                  dey
    85  41af 10f8                                bpl l82_2
    86                          
    87  41b1 a999                                lda #<fone                               ; Push STEP value
    88  41b3 a05f                                ldy #>fone                               ; (point to default 'one' in ROM)
    89  41b5 200e62                              jsr movfm
    90  41b8 208522                              jsr chrgot
    91  41bb c9a9                                cmp #step_token
    92  41bd d006                                bne l82_3                                ; branch if no step given
    93  41bf 208322                              jsr chrget
    94  41c2 20d84c                              jsr frmnum
    95                          
    96  41c5 20c162             l82_3            jsr sign
    97  41c8 48                                  pha                                      ; save sign for a moment
    98  41c9 20b262                              jsr round
    99  41cc 68                                  pla
   100                          
   101  41cd a008                                ldy #lenfor-10
   102  41cf a205                                ldx #5
   103  41d1 917c               l82_4            sta (tos),y                              ; (common area)
   104  41d3 b562                                lda facexp-1,x
   105  41d5 88                                  dey
   106  41d6 ca                                  dex
   107  41d7 10f8                                bpl l82_4
   108                          
   109  41d9 a54c                                lda forpnt+1                             ; Finally push pointer to 'for' variable, & 'for' token
   110  41db 917c                                sta (tos),y                              ; (common area)
   111  41dd a54b                                lda forpnt
   112  41df 88                                  dey
   113  41e0 917c                                sta (tos),y                              ; (common area)
   114  41e2 a981                                lda #for_token
   115  41e4 88                                  dey
   116  41e5 917c                                sta (tos),y                              ; (common area)
   117  41e7 60                                  rts
   118                          

; ******** Source: basic.asm

; ******** Source: command/delete.asm
     1                          
     2                          
     3                          
     4                          ; Delete a range of source   -or-   Delete a disk file
     5                          ;
     6                          ; Syntax: DELETE from# - to# (same range parameters as LIST)
     7                          ;  DELETE "filename" (same parameters as SCRATCH)
     8                          
     9                          ; Determine which form of DELETE we have...
    10                          
    11  41e8 9007               delete           bcc delete_line                          ; branch if a number (assume range parameter)
    12  41ea c9ab                                cmp #minus_token
    13  41ec f003                                beq delete_line                          ; branch if a dash (assume range parameter)
    14  41ee 83e430                              +lbra scratch                            ; branch if string (assume filename or U#)
    15                          
    16                          delete_line
    17  41f1 20ed58                              jsr errind                               ; direct mode only command
    18  41f4 208522                              jsr chrgot                               ; requires line# or range, no default
    19  41f7 f351ec                              +lbeq snerr                              ; error, none given
    20                          
    21  41fa 205042                              jsr range                                ; parse range, find starting line, ptr to ending line
    22  41fd a561                                lda lowtr
    23  41ff a662                                ldx lowtr+1
    24  4201 8524                                sta index1                               ; (destination)
    25  4203 8625                                stx index1+1
    26                          
    27  4205 20fa31                              jsr FindLine                             ; find ending line
    28  4208 9015                                bcc l83_2                                ; branch if not found
    29  420a a001                                ldy #1
    30  420c 20ad22                              jsr indlow                               ; if eot, use this ptr.  else, need ptr to next
    31  420f 88                                  dey
    32  4210 aa                                  tax                                      ; save it in case of swap
    33  4211 d005                                bne l83_1                                ; branch if not eot (end-of-text)
    34  4213 20ad22                              jsr indlow
    35  4216 f007                                beq l83_2                                ; branch if eot (null link bytes)
    36                          
    37  4218 20ad22             l83_1            jsr indlow
    38  421b 8561                                sta lowtr                                ; (source)
    39  421d 8662                                stx lowtr+1
    40                          
    41  421f a561               l83_2            lda lowtr                                ; check that start <= end
    42  4221 38                                  sec
    43  4222 e524                                sbc index1                               ; calculate delta
    44  4224 850d                                sta count                                ; (count)
    45  4226 a562                                lda lowtr+1                              ; (does not catch case where
    46  4228 e525                                sbc index1+1                             ; start>end when end=start+1,
    47  422a 856d                                sta argmo                                ; but it does no harm)
    48  422c 050d                                ora count
    49  422e f00e                                beq fix_links                            ; all done- nothing to move!?
    50  4230 9318ec                              +lbcc snerr                              ; error- bad range (start > end)
    51                          
    52  4233 a582                                lda text_top                             ; setup for common DMA move routine: [900530]
    53  4235 a683                                ldx text_top+1
    54  4237 8526                                sta index2                               ; index2 = top
    55  4239 8627                                stx index2+1                             ; index1 = destination
    56                          ; count  = delta
    57                          
    58  423b 20c440                              jsr movedown                             ; delete the text, then relink & exit
    59                          
    60                          
    61                          
    62                          fix_links                                                 ; <<<<<<<<<<<<<<<<<<<<<<<<<<< entry from renumber
    63                          
    64  423e 20b930                              jsr link_program                         ; relink program
    65  4241 a524                                lda index1
    66  4243 a625                                ldx index1+1
    67  4245 18                                  clc
    68  4246 6902                                adc #2
    69  4248 9001                                bcc l84_1
    70  424a e8                                  inx
    71  424b 8582               l84_1            sta text_top                             ; set eot pointer
    72  424d 8683                                stx text_top+1
    73  424f 60                                  rts                                      ; C128-04 fix: was 'jmp ready' (FAB)
    74                          
    75                          
    76                          ;********************************
    77                          ;*
    78                          ;*    Input Range Parameters
    79                          ;*
    80                          ;********************************
    81                          
    82  4250 f012               range            beq l85_1                                ; a terminator from chrgot?
    83  4252 9010                                bcc l85_1                                ; a number?
    84  4254 c9ab                                cmp #minus_token                         ; a dash?
    85  4256 d02e                                bne l85_4   ;if it's not a dash, error (C128-03 fix ; FAB)
    86  4258 a001                                ldy #1
    87  425a 20c522                              jsr indtxt                               ; let's peek, and see what follows the dash!
    88  425d f027                                beq l85_4                                ; uh-oh! it's of the form 'delete -' - error
    89  425f c93a                                cmp #':'                                 ; the other terminator
    90  4261 f023                                beq l85_4                                ; ..still bad
    91  4263 38                                  sec                                      ; set up for linget
    92                          
    93  4264 202e32             l85_1            jsr linget                               ; get first #
    94  4267 20fa31                              jsr FindLine                             ; find it & set ptrs
    95  426a 208522                              jsr chrgot                               ; get last char
    96  426d f00c                                beq l85_2                                ; skip done
    97  426f c9ab                                cmp #minus_token                         ; a dash?
    98  4271 d013                                bne l85_4                                ; no- syntax error
    99  4273 208322                              jsr chrget                               ; yes- skip dash
   100  4276 202e32                              jsr linget                               ; get second #
   101  4279 d00b                                bne l85_4                                ; error- wasn't a number
   102                          
   103  427b a50b               l85_2            lda endchr                               ; was a # input?
   104  427d d006                                bne l85_3                                ; yes
   105  427f a9ff                                lda #$ff                                 ; no - make max
   106  4281 8516                                sta linnum
   107  4283 8517                                sta linnum+1
   108  4285 60                 l85_3            rts
   109                          
   110                          
   111  4286 83c2eb             l85_4            +lbra snerr                              ; syntax error
   112                          

; ******** Source: basic.asm

; ******** Source: command/findchange.asm
     1                          
     2                          
     3                          
     4                          ; FIND   "string"                    [,line_range]
     5                          ; CHANGE "oldstring" TO "newstring"  [,line_range]
     6                          ;
     7                          ; where <"> delimiter can be any character, but only
     8                          ; double-quotes will prevent tokenization of strings.
     9                          ;
    10                          ; N.B.: I am assuming that lines cannot be greater than 255 chars, as is
    11                          ; the case where the line was entered "normally", that is, using LINGET.
    12                          
    13                          find
    14  4289 7787                                rmb7 op                                  ; FIND flag
    15  428b 2c                                  !text $2c
    16                          
    17                          change
    18  428c f787                                smb7 op                                  ; CHANGE flag
    19  428e 6787                                rmb6 op                                  ; reset change-all mode
    20  4290 20ed58                              jsr errind                               ; report error if not in direct mode
    21                          
    22  4293 208522                              jsr chrgot                               ; get delimeter
    23  4296 a200                                ldx #0                                   ; evaluate string args
    24  4298 202644                              jsr delimit_string                       ; string1
    25  429b a58a                                lda fstr1+2
    26  429d f35f0f                              +lbeq fcerr                              ; error if string1 null
    27  42a0 7f8713                              bbr7 op,l86_1                            ; branch if no string2
    28  42a3 208322                              jsr chrget                               ; pick up required 'to' token
    29  42a6 c9a4                                cmp #to_token
    30  42a8 d3a0eb                              +lbne snerr                              ; error if missing
    31  42ab 208322                              jsr chrget
    32  42ae f39aeb                              +lbeq snerr                              ; error if eol
    33  42b1 a203                                ldx #3
    34  42b3 202644                              jsr delimit_string                       ; string2
    35                          
    36  42b6 208322             l86_1            jsr chrget                               ; line number range given?
    37  42b9 f003                                beq l86_2                                ; no, eol
    38  42bb 205b4e                              jsr chkcom                               ; yes, pick up required comma
    39  42be 205042             l86_2            jsr range                                ; set up line number range (lowtr,linnum)
    40  42c1 20472c                              jsr tto                                  ; save txtptr for restoration when done
    41  42c4 7755                                rmb7 helper                              ; clear 'help' flag for 'p1line'
    42  42c6 a555                                lda helper
    43  42c8 48                                  pha
    44  42c9 4755                                rmb4 helper                              ; temporarily disable token highlighting
    45  42cb d755                                smb5 helper                              ; set   'find' flag for 'p1line'
    46  42cd 800e                                bra find_loop_1                          ; begin
    47                          
    48                          
    49                          find_loop
    50  42cf a000                                ldy #0                                   ; move to next line (copy link bytes to lowtr)
    51  42d1 20ad22                              jsr indlow
    52  42d4 aa                                  tax
    53  42d5 c8                                  iny
    54  42d6 20ad22                              jsr indlow
    55  42d9 8661                                stx lowtr
    56  42db 8562                                sta lowtr+1
    57                          
    58                          find_loop_1
    59  42dd a001                                ldy #1
    60  42df 20ad22                              jsr indlow                               ; check link
    61  42e2 d007                                bne l87_1                                ; not null- continue
    62  42e4 88                                  dey
    63  42e5 20ad22                              jsr indlow
    64  42e8 f31e01                              +lbeq find_exit                          ; null- exit
    65                          
    66  42eb a002               l87_1            ldy #2
    67  42ed 20ad22                              jsr indlow                               ; check line number
    68  42f0 aa                                  tax
    69  42f1 c8                                  iny
    70  42f2 20ad22                              jsr indlow
    71  42f5 c517                                cmp linnum+1
    72  42f7 d004                                bne l87_2
    73  42f9 e416                                cpx linnum
    74  42fb f003                                beq l87_3                                ; line is <= last line requested, continue
    75  42fd b30901             l87_2            +lbcs find_exit                          ; line is >  last line requested, exit
    76                          
    77  4300 a203               l87_3            ldx #3                                   ; set initial position - 1 (past link & line#)
    78  4302 863f                                stx fndpnt
    79                          
    80                          
    81                          find_loop_2
    82  4304 20e1ff                              jsr _stop                                ; check stop key
    83  4307 f31101                              +lbeq find_break                         ; exit if down
    84                          
    85  430a a63f                                ldx fndpnt                               ; duh, where are we?
    86  430c 18                                  clc
    87  430d 8a                                  txa                                      ; program:
    88  430e 6561                                adc lowtr                                ; txtptr = line start + position in line
    89  4310 853d                                sta txtptr
    90  4312 a900                                lda #0
    91  4314 6562                                adc lowtr+1
    92  4316 853e                                sta txtptr+1                             ; search string:
    93  4318 a300                                ldz #0                                   ; at the beginning
    94                          
    95  431a 20a540             l88_1            jsr chargt                               ; get next character from text
    96  431d f0b0                                beq find_loop                            ; eol (no match this line)
    97  431f e8                                  inx                                      ; bump pointer to next character
    98  4320 d288                                cmp (fstr1),z                            ; character match?  ind okay- buffer
    99  4322 d0f6                                bne l88_1                                ; no
   100  4324 863f                                stx fndpnt                               ; yes- save next position
   101                          
   102  4326 1b                 l88_2            inz                                      ; bump position in search string
   103  4327 d48a                                cpz fstr1+2                              ; string match?
   104  4329 b00b                                bcs print_line                           ; yes
   105  432b 20a540                              jsr chargt
   106  432e f09f                                beq find_loop                            ; no- eol
   107  4330 d288                                cmp (fstr1),z                            ; ind okay- buffer
   108  4332 d0d0                                bne find_loop_2                          ; no- rewind to beginning of search string
   109  4334 f0f0                                beq l88_2                                ; maybe- still more chars to compare
   110                          
   111                          
   112                          ; Print the line of text at LOWTR, highlighting the section of code
   113                          ; beginning at LOWTR+FNDPNT and running for FIND_COUNT characters.
   114                          
   115                          print_line
   116  4336 20f737                              jsr crdo                                 ; get a new display line
   117  4339 a58a                                lda fstr1+2                              ; length of string to highlight
   118  433b 8dda02                              sta find_count
   119  433e a002                                ldy #2
   120  4340 20ad22                              jsr indlow                               ; get ms byte of line number
   121  4343 aa                                  tax
   122  4344 c8                                  iny
   123  4345 20ad22                              jsr indlow                               ; get ls byte
   124  4348 207733                              jsr p1line                               ; print #, space, and the line of code
   125  434b 7f87b6                              bbr7 op,find_loop_2                      ; Find op? branch if so and continue search
   126                          
   127                          
   128                          ; Change operation
   129                          ; Query the user and replace string1 with string2 if he wants to.
   130                          ; Options are  'Y' (yes),  '*' (do all),  'CR' (quit),  anything else means no.
   131                          
   132                          change_line
   133  434e ef8720                              bbs6 op,l89_1                            ; branch if change-all mode set
   134  4351 207dff                              jsr _primm                               ; prompt & get response
   135  4354 0d204348414e4745...                 !text cr," CHANGE? ",0
   136  435f 20d878                              jsr response_get
   137  4362 c959                                cmp #'Y'
   138  4364 f00b                                beq l89_1                                ; yes, change it
   139  4366 c90d                                cmp #cr
   140  4368 f39e00                              +lbeq find_exit                          ; cr only, abort entire operation
   141  436b c92a                                cmp #'*'
   142  436d d095                                bne find_loop_2                          ; *, change all.  else don't change
   143  436f e787                                smb6 op
   144                          
   145                          ; Replace string1 with string2.  Requires moving text up/down beginning at
   146                          ; LOWTR+FNDPNT+(LEN(string1)-LEN(string2)) through TEXT_TOP and copying
   147                          ; string1 into text beginning at LOWTR+FNDPNT for LEN(string2) characters.
   148                          
   149  4371 a582               l89_1            lda text_top                             ; setup upper address of text to move (index2)
   150  4373 8526                                sta index2
   151  4375 a583                                lda text_top+1                           ; TEXT_TOP
   152  4377 8527                                sta index2+1
   153                          
   154  4379 18                                  clc                                      ; setup lower address of text to move (index1)
   155  437a a53f                                lda fndpnt
   156  437c 6561                                adc lowtr
   157  437e 8524                                sta index1                               ; LOWTR+FNDPNT
   158  4380 a900                                lda #0
   159  4382 856d                                sta argmo                                ; count hi
   160  4384 6562                                adc lowtr+1
   161  4386 8525                                sta index1+1
   162                          
   163  4388 38                                  sec                                      ; calc number of chars to insert/delete
   164  4389 a58a                                lda fstr1+2                              ; LEN(string1)-LEN(string2)
   165  438b e58d                                sbc fstr2+2
   166  438d f052                                beq l89_6                                ; branch if string1 = string2 (no move)
   167  438f 103d                                bpl l89_4                                ; branch if string1 > string2 (delete)
   168                          ; else      string1 < string2 (insert)
   169                          
   170  4391 42                                  neg                                      ; Move memory up to make room for larger string2
   171  4392 850d                                sta count
   172  4394 a000                                ldy #0                                   ; first check for line too long
   173  4396 20ad22                              jsr indlow
   174  4399 650d                                adc count
   175  439b 4b                                  taz
   176  439c c8                                  iny
   177  439d 20ad22                              jsr indlow                               ; (link+#chr)-line_sa must be <256
   178  43a0 6900                                adc #0
   179  43a2 a8                                  tay
   180  43a3 38                                  sec
   181  43a4 6b                                  tza
   182  43a5 e561                                sbc lowtr
   183  43a7 98                                  tya
   184  43a8 e562                                sbc lowtr+1
   185  43aa d3c432                              +lbne errlen                             ; error, line > 255 characters
   186                          
   187  43ad 18                                  clc                                      ; now check for sufficient memory
   188  43ae a483                                ldy text_top+1
   189  43b0 a50d                                lda count
   190  43b2 6582                                adc text_top
   191  43b4 9001                                bcc l89_2
   192  43b6 c8                                  iny
   193  43b7 ccd002             l89_2            cpy max_mem_0+1
   194  43ba 9009                                bcc l89_3                                ; result is less than top-of-memory: ok
   195  43bc d383ea                              +lbne omerr                              ; msb >  top, overflow
   196  43bf cdcf02                              cmp max_mem_0                            ; msb's the same, test lsb's
   197  43c2 b37dea                              +lbcs omerr                              ; lsb >= top, overflow
   198  43c5 8582               l89_3            sta text_top
   199  43c7 8483                                sty text_top+1                           ; set new top of text pointer
   200  43c9 201741                              jsr moveup                               ; make room
   201  43cc 8013                                bra l89_6                                ; go copy string2 into area
   202                          
   203  43ce 850d               l89_4            sta count                                ; Move memory down for smaller string2
   204  43d0 a483                                ldy text_top+1
   205  43d2 a582                                lda text_top
   206  43d4 38                                  sec
   207  43d5 e50d                                sbc count
   208  43d7 b001                                bcs l89_5
   209  43d9 88                                  dey
   210  43da 8582               l89_5            sta text_top
   211  43dc 8483                                sty text_top+1                           ; set new top of text pointer
   212  43de 20c440                              jsr movedown                             ; squish out excess space
   213                          
   214  43e1 a58d               l89_6            lda fstr2+2                              ; Copy string2 into text
   215  43e3 f015                                beq l89_8                                ; branch if null, nothing to copy
   216  43e5 8dda02                              sta find_count                           ; how many characters to copy
   217  43e8 a261                                ldx #lowtr
   218  43ea a43f                                ldy fndpnt                               ; index into text
   219  43ec a300                                ldz #0                                   ; index into string2
   220  43ee b28b               l89_7            lda (fstr2),z                            ; ind okay- buffer
   221  43f0 200c23                              jsr sta_far_ram0                         ; do the copy
   222  43f3 c8                                  iny
   223  43f4 1b                                  inz
   224  43f5 ceda02                              dec find_count
   225  43f8 d0f4                                bne l89_7
   226                          
   227  43fa 20b930             l89_8            jsr link_program                         ; relink program
   228  43fd 18                                  clc
   229  43fe a53f                                lda fndpnt                               ; place find position after new text
   230  4400 658d                                adc fstr2+2
   231  4402 3a                                  dec
   232  4403 853f                                sta fndpnt
   233  4405 83fdfe                              +lbra find_loop_2                        ; and resume searching
   234                          
   235                          
   236                          find_exit
   237  4408 20f737                              jsr crdo                                 ; normal exit
   238  440b 68                                  pla
   239  440c 8555                                sta helper                               ; restore token highlight status
   240  440e 5755                                rmb5 helper                              ; remove 'find' flag
   241  4410 830efb                              +lbra direct_mode_exit                   ; done
   242                          
   243                          
   244                          
   245                          find_omerr                                                ; out of memory
   246  4413 a210                                ldx #errom
   247  4415 2c                                  !text $2c
   248                          find_errlen                                               ; string too long
   249  4416 a217                                ldx #errls
   250  4418 38                                  sec
   251  4419 89                                  !text $89
   252                          find_break                                                ; stop key break
   253  441a 18                                  clc
   254  441b 68                                  pla
   255  441c 8555                                sta helper                               ; restore token highlight status
   256  441e 5755                                rmb5 helper                              ; remove 'find' flag
   257  4420 93afe8                              +lbcc break_exit                         ; [910925]
   258  4423 832aea                              +lbra error
   259                          
   260                          
   261                          delimit_string                                            ; command is in buffer, .x = ptr to strptr
   262  4426 8564                                sta match                                ; delimiter character
   263  4428 a53d                                lda txtptr                               ; point to first character in string
   264  442a 1a                                  inc                                      ; (never wraps- string in input buffer)
   265  442b 9588                                sta fstr1,x                              ; set pointer to string data
   266  442d a53e                                lda txtptr+1
   267  442f 9589                                sta fstr1+1,x
   268  4431 a9ff                                lda #$ff                                 ; set string length
   269  4433 958a                                sta fstr1+2,x
   270                          
   271  4435 f68a               l90_1            inc fstr1+2,x
   272  4437 20a540                              jsr chargt                               ; build string
   273  443a f30eea                              +lbeq snerr                              ; error if eol encountered inside string
   274  443d c564                                cmp match
   275  443f d0f4                                bne l90_1                                ; continue until matching delimiter found
   276  4441 60                                  rts
   277                          
   278                          ;.end
   279                          
   280                          
   281                          
   282  4442 20675b             puctrl           jsr frmstr                               ; do frmevl,frestr. return with a=len, index=~string
   283  4445 a8                                  tay
   284  4446 88                                  dey
   285  4447 c004                                cpy #4
   286  4449 b3b30d                              +lbcs fcerr                              ; len > 4 is illegal value error
   287                          
   288  444c 20d522             l91_1            jsr indin1_ram1                          ; lda (index),y
   289  444f 99d411                              sta puchrs,y
   290  4452 88                                  dey
   291  4453 10f7                                bpl l91_1
   292  4455 60                                  rts
   293                          
   294                          ;.end

; ******** Source: basic.asm

; ******** Source: command/trap.asm
     1                          
     2                          
     3                          trap
     4                          ; jsr errdir ;why not????      [910925]
     5  4456 208522                              jsr chrgot                               ; if no #, means 'turn off trap'
     6  4459 f007                                beq l92_1
     7  445b 208a5d                              jsr getwrd
     8  445e 8cca02                              sty trapno
     9  4461 2c                                  !text $2c
    10                          
    11  4462 a9ff               l92_1            lda #$ff                                 ; flag no trap
    12  4464 8dcb02                              sta trapno+1
    13  4467 60                                  rts
    14                          

; ******** Source: basic.asm

; ******** Source: command/resume.asm
     1                          
     2                          
     3                          
     4                          
     5                          ; RESUME command
     6                          ;
     7                          ; Used to resume execution following a TRAPped error.
     8                          ;
     9                          ; Syntax: RESUME [line_number | NEXT]
    10                          ;
    11                          ; Can take the following forms:
    12                          ;
    13                          ; RESUME   :resume executing at the statement which caused
    14                          ;     the error.
    15                          ; RESUME NEXT  :resume execution at the statement FOLLOWING
    16                          ;     the statement which caused the error.
    17                          ; RESUME line_number :resume at the specified line number.
    18                          
    19                          
    20  4468 20e258             resume           jsr errdir                               ; no direct mode
    21  446b aec902                              ldx errlin+1                             ; is there an error to resume from?
    22  446e e8                                  inx
    23  446f f077                                beq rescnt                               ; can't resume!
    24  4471 208522                              jsr chrgot                               ; look for arguments
    25  4474 f046                                beq resswp                               ; no arg's...restart err'd line
    26  4476 9039                                bcc l93_3                                ; numeric argument
    27  4478 c982                                cmp #next_token                          ; only other choice is 'next'
    28  447a d3cee9                              +lbne snerr                              ; if not, syntax error
    29                          
    30  447d 20bc44                              jsr resswp                               ; resume execution with next stm't
    31  4480 a000                                ldy #0
    32  4482 20c522                              jsr indtxt
    33  4485 d024                                bne l93_2                                ; must be a ':'
    34  4487 c8                                  iny                                      ; must be a null,get next line
    35  4488 20c522                              jsr indtxt                               ; make sure its not end-of-text
    36  448b d007                                bne l93_1
    37  448d c8                                  iny
    38  448e 20c522                              jsr indtxt
    39  4491 f3bae9                              +lbeq ready                              ; 2 nulls, eot. bye!
    40                          
    41  4494 a003               l93_1            ldy #3                                   ; new line, update pointers
    42  4496 20c522                              jsr indtxt
    43  4499 853b                                sta curlin
    44  449b c8                                  iny
    45  449c 20c522                              jsr indtxt
    46  449f 853c                                sta curlin+1
    47  44a1 98                                  tya
    48  44a2 18                                  clc
    49  44a3 653d                                adc txtptr
    50  44a5 853d                                sta txtptr
    51  44a7 9002                                bcc l93_2
    52  44a9 e63e                                inc txtptr+1
    53  44ab 208322             l93_2            jsr chrget                               ; skip over this character, into body of statement
    54  44ae 8398f0                              +lbra data                               ; advance until null or ':', then rts
    55                          
    56                          
    57  44b1 208a5d             l93_3            jsr getwrd                               ; resnum. numeric argument
    58  44b4 8517                                sta linnum+1
    59  44b6 20d644                              jsr resend
    60  44b9 8364f8                              +lbra luk4it
    61                          
    62                          
    63  44bc adcd02             resswp           lda errtxt                               ; backup one so chrget will work
    64  44bf d003                                bne l94_1
    65  44c1 cece02                              dec errtxt+1
    66  44c4 cecd02             l94_1            dec errtxt
    67                          
    68  44c7 a201                                ldx #1
    69  44c9 bdc802             l94_2            lda errlin,x                             ; restore line#
    70  44cc 953b                                sta curlin,x
    71  44ce bdcd02                              lda errtxt,x                             ; restore text pointer to statement
    72  44d1 953d                                sta txtptr,x
    73  44d3 ca                                  dex
    74  44d4 10f3                                bpl l94_2
    75                          
    76                          
    77  44d6 aecc02             resend           ldx tmptrp                               ; restore trap line to allow traps again
    78  44d9 8ecb02                              stx trapno+1
    79                          error_clear
    80  44dc a2ff                                ldx #$ff
    81  44de 8ec702                              stx errnum                               ; reset error status- he's saying he's fixed it
    82  44e1 8ec802                              stx errlin
    83  44e4 8ec902                              stx errlin+1                             ; flag 'no further resumes until next error'
    84  44e7 60                                  rts
    85                          
    86                          
    87  44e8 a21f               rescnt           ldx #errcr
    88  44ea 8363e9                              +lbra error
    89                          
    90                          ;.end

; ******** Source: basic.asm

; ******** Source: command/loops.asm
     1                          
     2                          
     3  44ed a001               do               ldy #1
     4  44ef b93d00             l95_1            lda txtptr,y                             ; save current pointers for stack entry
     5  44f2 997911                              sta tmptxt,y
     6  44f5 b93b00                              lda curlin,y
     7  44f8 997b11                              sta tmplin,y
     8  44fb 88                                  dey
     9  44fc 10f1                                bpl l95_1
    10                          
    11  44fe 208522                              jsr chrgot                               ; look for 'while' or 'until'
    12  4501 f01b                                beq doyes                                ; unconditional
    13  4503 c9fc                                cmp #until_token
    14  4505 f010                                beq do10
    15  4507 c9fd                                cmp #while_token
    16  4509 d03f                                bne snrjmp
    17                          
    18                          
    19                          ;  Here for WHILE
    20                          
    21  450b 20cf45                              jsr frmjmp
    22  450e a563                                lda facexp
    23  4510 d00c                                bne doyes                                ; conditional evaluated true
    24                          
    25  4512 208522             dono             jsr chrgot
    26  4515 8039                                bra fnd010                               ; advance to end of block, do rts
    27                          
    28                          
    29                          ;  Here for UNTIL
    30                          
    31  4517 20cf45             do10             jsr frmjmp
    32  451a a563                                lda facexp
    33  451c d0f4                                bne dono
    34                          
    35  451e a905               doyes            lda #5                                   ; 'do' needs 5 bytes on the run-time stack
    36  4520 209431                              jsr getstk
    37  4523 a004                                ldy #4                                   ; ..now stuff those 5 bytes!
    38  4525 ad7a11                              lda tmptxt+1
    39  4528 917c                                sta (tos),y                              ; (common area)
    40  452a 88                                  dey
    41  452b ad7911                              lda tmptxt
    42  452e 917c                                sta (tos),y                              ; (common area)
    43  4530 88                                  dey
    44  4531 ad7c11                              lda tmplin+1
    45  4534 917c                                sta (tos),y                              ; (common area)
    46  4536 88                                  dey
    47  4537 ad7b11                              lda tmplin
    48  453a 917c                                sta (tos),y                              ; (common area)
    49  453c 88                                  dey
    50  453d a9eb                                lda #do_token
    51  453f 917c                                sta (tos),y                              ; (common area)
    52  4541 60                                  rts
    53                          
    54                          
    55                          ;  Here for EXIT
    56                          
    57  4542 20a045             exit             jsr popdgo                               ; pop do entry off stack
    58  4545 208522                              jsr chrgot
    59  4548 f006                                beq fnd010
    60  454a 83fee8             snrjmp           +lbra snerr
    61                          
    62                          
    63                          
    64                          ;  Find end of current block
    65                          
    66  454d 208322             fndend           jsr chrget
    67                          
    68  4550 f017               fnd010           beq l96_2                                ; end of statement
    69  4552 c9ec                                cmp #loop_token
    70  4554 f3f2ef                              +lbeq data                               ; a hit!  read to end of statement, rts
    71  4557 c922                                cmp #'"'                                 ; quote
    72  4559 f009                                beq l96_1
    73  455b c9eb                                cmp #do_token
    74  455d d0ee                                bne fndend                               ; keep looking
    75  455f 204d45                              jsr fndend                               ; recursivly
    76  4562 80ae                                bra dono                                 ; do a chrgot, go to fnd010
    77                          
    78                          
    79  4564 203236             l96_1            jsr un_quote                             ; look for terminating quote, or end of statement
    80  4567 d0e4                                bne fndend                               ; character after quote wasn't terminator, keep going
    81                          
    82  4569 c93a               l96_2            cmp #':'                                 ; end of line or end of stmt?
    83  456b f0e0                                beq fndend                               ; just stmt, keep going
    84  456d 7f7e3f                              bbr7 runmod,fnderr                       ; if direct mode, not found error
    85  4570 a002                                ldy #2
    86  4572 20c522                              jsr indtxt                               ; end of text?
    87  4575 f038                                beq fnderr                               ; 'fraid so
    88  4577 c8                                  iny                                      ; y=3
    89  4578 20c522                              jsr indtxt                               ; update pointers
    90  457b 853b                                sta curlin
    91  457d c8                                  iny
    92  457e 20c522                              jsr indtxt
    93  4581 853c                                sta curlin+1
    94  4583 98                                  tya
    95  4584 18                                  clc
    96  4585 653d                                adc txtptr
    97  4587 853d                                sta txtptr
    98  4589 90c2                                bcc fndend
    99  458b e63e                                inc txtptr+1
   100  458d 80be                                bra fndend
   101                          
   102                          
   103  458f f035               loop             beq popngo                               ; no conditionals, just do it
   104  4591 c9fd                                cmp #while_token
   105  4593 f02c                                beq loop10
   106  4595 c9fc                                cmp #until_token
   107  4597 d0b1                                bne snrjmp
   108                          
   109                          ;  Here for UNTIL
   110                          
   111  4599 20cf45                              jsr frmjmp
   112  459c a563                                lda facexp
   113  459e f026                                beq popngo                               ; false, do it again!
   114                          
   115  45a0 a9eb               popdgo           lda #do_token                            ; pop, but don't go
   116  45a2 204331                              jsr search
   117  45a5 d015                                bne poperr                               ; branch if not found
   118  45a7 20e631                              jsr movfnd
   119  45aa a005                                ldy #5
   120  45ac 8341ec                              +lbra rlsstk
   121                          
   122                          
   123                          fnderr
   124  45af ad7b11                              lda tmplin                               ; loop not found error: must make curlin match oldtxt
   125  45b2 ae7c11                              ldx tmplin+1
   126  45b5 853b                                sta curlin
   127  45b7 863c                                stx curlin+1
   128                          
   129  45b9 a220                                ldx #errlnf
   130  45bb 2c                                  !text $2c
   131                          poperr
   132  45bc a221                                ldx #errlwd                              ; loop without do
   133  45be 838fe8                              +lbra error
   134                          
   135                          
   136                          
   137                          ;  Here for WHILE
   138                          
   139                          loop10
   140  45c1 20cf45                              jsr frmjmp
   141  45c4 f0da                                beq popdgo                               ; false, exit
   142                          popngo
   143  45c6 63d8ff                              bsr popdgo
   144                          ; dey
   145                          ; lda (fndpnt),y ;restore pointers
   146                          ; sta txtptr+1
   147                          ; dey
   148                          ; lda (fndpnt),y
   149                          ; sta txtptr
   150                          ; dey
   151                          ; lda (fndpnt),y
   152  45c9 204279                              jsr retpat                               ; (** 01/18/84 fixes 'loop' to a direct mode 'do')
   153                          ; lda (fndpnt),y
   154                          ; sta curlin
   155  45cc 831fff                              +lbra do
   156                          
   157                          frmjmp
   158  45cf 208322                              jsr chrget
   159  45d2 831b07                              +lbra frmevl
   160                          

; ******** Source: basic.asm

; ******** Source: command/key.asm
     1                          
     2                          
     3                          
     4                          ;**************************************************************
     5                          ;
     6                          ;   KEY  Programmable Key Functions    [900725]
     7                          ;
     8                          ;**************************************************************
     9                          
    10  45d5 f033               key              beq Key_List                             ; KEY ? yes- no args
    11                          
    12  45d7 a6d1               l97_1            ldx _kyndx                               ; is function key buffered?
    13  45d9 d0fc                                bne l97_1                                ; yes- hang until IRQ finishes processing it ????
    14                          
    15  45db c991                                cmp #on_token                            ; KEY ON ?
    16  45dd d004                                bne l97_2
    17  45df 57f7                                rmb5 _locks                              ; yes- reset Editor's lock bit
    18  45e1 8024                                bra l97_4                                ; exit
    19                          
    20  45e3 c993               l97_2            cmp #load_token                          ; KEY LOAD <filename>[,D#,U#]
    21  45e5 f3d500                              +lbeq Key_load
    22                          
    23  45e8 c994                                cmp #save_token                          ; KEY SAVE <filename>[,D#,U#]
    24  45ea f33001                              +lbeq Key_Save
    25                          
    26  45ed c98c                                cmp #restore_token                       ; KEY RESTORE ?      [910925]
    27  45ef d007                                bne l97_3                                ; no
    28  45f1 57f7                                rmb5 _locks                              ; yes- reset Editor's lock bit (enable keys)
    29  45f3 20b546                              jsr key_restore                          ; init key definitions
    30  45f6 800f                                bra l97_4                                ; exit
    31                          
    32  45f8 c9fe               l97_3            cmp #esc_command_token                   ; KEY OFF ?
    33  45fa d39f00                              +lbne Key_Change                         ; no- must be new key definition
    34  45fd 208322                              jsr chrget
    35  4600 c924                                cmp #off_token
    36  4602 d346e8                              +lbne snerr                              ; no- bad syntax
    37  4605 d7f7                                smb5 _locks                              ; yes- set Editor's lock bit
    38  4607 837adc             l97_4            +lbra chrget                             ; exit
    39                          
    40                          
    41                          ;**************************************************************
    42                          ;
    43                          ;   Key_List  List all function key definitions
    44                          ;
    45                          ;**************************************************************
    46                          
    47                          Key_List
    48  460a a200                                ldx #0                                   ; display all key definitions
    49  460c a000                                ldy #0
    50                          
    51  460e e8                 lstky1           inx                                      ; get key number = 1-16
    52  460f bdff0f                              lda _pky_lengths-1,x                     ; get key size
    53  4612 f05a                                beq lstest                               ; skip if key not defined
    54  4614 8577                                sta keysiz                               ; save size
    55  4616 8676                                stx z_p_temp_1                           ; save key number
    56                          
    57  4618 5a                                  phy
    58  4619 a203                                ldx #3
    59  461b bd8c46             l98_1            lda preamb,x                             ; print key preamble:
    60  461e 20d2ff                              jsr _bsout
    61  4621 ca                                  dex                                      ; 'KEY '
    62  4622 10f7                                bpl l98_1
    63  4624 a676                                ldx z_p_temp_1                           ; key number
    64  4626 a900                                lda #0
    65  4628 207f64                              jsr linprt
    66  462b a92c                                lda #','
    67  462d 20d2ff                              jsr _bsout                               ; comma
    68                          
    69  4630 7a                                  ply
    70  4631 a207                                ldx #7                                   ; (length of 'keydat' string)
    71  4633 b91010             lsloop           lda _pky_buffer,y                        ; print key definition
    72  4636 c8                                  iny
    73  4637 48                                  pha                                      ; save character
    74  4638 da                                  phx                                      ; save position in output string
    75                          
    76  4639 a204                                ldx #4                                   ; check for special (non-printable) characters
    77  463b dd9646             l99_1            cmp keychr-1,x
    78  463e f033                                beq list_special                         ; yes, display it as 'CHR$(...)'
    79  4640 ca                                  dex
    80  4641 d0f8                                bne l99_1
    81                          
    82  4643 fa                                  plx                                      ; restore position
    83  4644 e008                                cpx #8
    84  4646 9007                                bcc l99_2                                ; 1st time thru- display leading quote
    85  4648 d00a                                bne l99_3                                ; previous was a character- no additions needed
    86  464a a92b                                lda #'+'                                 ; add since previous was quote or return
    87  464c 20d2ff                              jsr _bsout
    88  464f a922               l99_2            lda #'"'
    89  4651 20d2ff                              jsr _bsout                               ; add leading quote
    90  4654 68                 l99_3            pla                                      ; restore character
    91  4655 20d2ff                              jsr _bsout                               ; display it
    92  4658 a209                                ldx #9                                   ; mark normal character
    93                          
    94  465a c677               lstnd            dec keysiz
    95  465c d0d5                                bne lsloop                               ; loop to end of definition
    96  465e e009                                cpx #9
    97  4660 9005                                bcc l100_1                               ; skip if previous not normal character
    98  4662 a922                                lda #'"'
    99  4664 20d2ff                              jsr _bsout                               ; add ending quote
   100                          
   101  4667 a98d               l100_1           lda #$8d
   102  4669 20d2ff                              jsr _bsout                               ; add ending return (shifted)
   103                          
   104  466c a676                                ldx z_p_temp_1                           ; key number
   105  466e e010               lstest           cpx #number_fkeys
   106  4670 d09c                                bne lstky1                               ; ...loop until done all keys
   107  4672 60                                  rts
   108                          
   109                          
   110                          list_special
   111  4673 fa                                  plx                                      ; restore .x
   112  4674 bd8d46             l101_1           lda keydat-3,x                           ; display something like  ' "+CHR$( '
   113  4677 20d2ff                              jsr _bsout
   114  467a ca                                  dex
   115  467b e003                                cpx #3
   116  467d b0f5                                bcs l101_1
   117  467f 68                                  pla                                      ; restore character
   118  4680 203779                              jsr prtdec                               ; display decimal value of chr in .a
   119  4683 a929                                lda #')'                                 ; finish off with closing paren.
   120  4685 20d2ff                              jsr _bsout
   121  4688 a208                                ldx #8                                   ; mark end of special
   122  468a 80ce                                bra lstnd                                ; ..always
   123                          
   124                          
   125  468c 2059454b           preamb           !text " YEK"                             ; key preamble
   126                          
   127  4690 28245248432b22     keydat           !text "($RHC+",$22                       ; chr$( string
   128                          
   129  4697 0d8d221b           keychr           !text cr,$8d,$22,esc                     ; special KEY chars- return, sft-return, quote, esc
   130                          
   131                          
   132                          ;************************************************************************
   133                          ;
   134                          ;   Key_Change  Add, Delete or Change function key definition
   135                          ;
   136                          ;************************************************************************
   137                          
   138                          Key_Change
   139  469b 206c5d                              jsr getbyt                               ; get key number (1-16)
   140  469e 8676                                stx z_p_temp_1                           ; save key number     [910925]
   141  46a0 ca                                  dex
   142  46a1 e010                                cpx #number_fkeys
   143  46a3 b3590b                              +lbcs fcerr                              ; exit - key number invalid
   144                          
   145                          ; stx z_p_temp_1 ;save key number
   146  46a6 205b4e                              jsr chkcom                               ; look for comma
   147  46a9 20675b                              jsr frmstr                               ; do frmevl, frestr. returns len in .a, addr in 'index'
   148  46ac a8                                  tay                                      ; set up for call to do-a-key
   149  46ad a901                                lda #1                                   ; tell do-a-key that string is in bank 1
   150  46af 8526                                sta index+2
   151  46b1 a924                                lda #index                               ; now .A points to (adr lo, adr hi, bank #)
   152  46b3 a676                                ldx z_p_temp_1
   153                          ; inx         [910925]
   154                          key_restore
   155                          ; jsr put_io_in_map
   156  46b5 2068ff                              jsr _doakey                              ; re-define the key
   157  46b8 b387e7                              +lbcs omerr                              ; bad return (.c=1)
   158  46bb 60                                  rts                                      ; ok return  (.c=0)
   159                          
   160                          
   161                          ;************************************************************************
   162                          ;   Key_Load  Load function key definitions (from disk)   [900725]
   163                          ;************************************************************************
   164                          
   165                          Key_load
   166  46bc 20c946                              jsr GetLoadChannel                       ; get a channel      [911001]
   167  46bf a010                                ldy #>_pky_lengths
   168  46c1 a900                                lda #<_pky_lengths
   169  46c3 20fa46                              jsr LoadBlock                            ; load it
   170  46c6 835fec                              +lbra list_err                           ; release channel, close file, return to main
   171                          
   172                          
   173                          GetLoadChannel                                            ; Used by KeyLoad and SpriteLoad    [911001]
   174  46c9 208322                              jsr chrget                               ; eat LOAD token
   175  46cc a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
   176  46ce 202074                              jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 )
   177  46d1 20dc77                              jsr chk1                                 ; check parameters
   178  46d4 a900                                lda #0
   179  46d6 8d8311                              sta dossa                                ; setup as dload would (0 = load channel)
   180  46d9 201d71                              jsr find_la                              ; find an unused LA to use (cannot use reserved one)
   181  46dc a009                                ldy #fopn
   182  46de a204                                ldx #4
   183  46e0 20fd70                              jsr open_file                            ; open the file
   184  46e3 b033                                bcs LoadEOF                              ; exit if problem
   185  46e5 ae8111                              ldx dosla
   186  46e8 20c6ff                              jsr _chkin                               ; get input channel
   187  46eb b02b                                bcs LoadEOF                              ; exit if bad??
   188  46ed 20cfff                              jsr _basin                               ; waste dummy load address
   189  46f0 20cfff                              jsr _basin
   190  46f3 20b7ff                              jsr _readst                              ; prevent corruption if there's a problem
   191  46f6 d01c                                bne LoadERR                              ; exit if problem
   192  46f8 18                                  clc
   193  46f9 60                                  rts
   194                          
   195                          
   196                          LoadBlock
   197  46fa 855a                                sta highds                               ; where to put data
   198  46fc 845b                                sty highds+1
   199                          LoadBlockNext
   200  46fe a000                                ldy #0
   201  4700 20cfff             l102_1           jsr _basin                               ; read definitions
   202  4703 915a                                sta (highds),y
   203  4705 20b7ff                              jsr _readst                              ; check channel status
   204  4708 d00e                                bne LoadEOF                              ; exit if eof or error
   205  470a 20e1ff                              jsr _stop
   206  470d f009                                beq LoadEOF                              ; exit if stop key down
   207  470f c8                                  iny
   208  4710 d0ee                                bne l102_1                               ; continue up to 1 page maximum
   209  4712 18                                  clc                                      ; indicate "more"
   210  4713 60                                  rts
   211                          
   212                          
   213                          LoadERR
   214  4714 a21d                                ldx #erload                              ; Load Error
   215  4716 38                                  sec
   216  4717 89                                  !text $89
   217                          
   218                          LoadEOF
   219  4718 18                                  clc
   220  4719 830cec                              +lbra list_err                           ; release channel, close file, return to main
   221                          
   222                          
   223                          ;************************************************************************
   224                          ;   Key_Save  Save function key definitions (from disk)   [900725]
   225                          ;************************************************************************
   226                          
   227                          Key_Save
   228  471c 202e47                              jsr GetSaveChannel                       ; [910930]
   229  471f a95a                                lda #highds                              ; set starting & ending addresses
   230  4721 a010                                ldy #>_pky_lengths                       ; start address & pointer to it
   231  4723 a200                                ldx #<_pky_lengths
   232  4725 845b                                sty highds+1
   233  4727 865a                                stx highds
   234  4729 c8                                  iny                                      ; end address = start address + 256 + 1
   235  472a e8                                  inx
   236  472b 833e21                              +lbra savenb                             ; [910925]
   237                          ; jsr _savesp  ;save it
   238                          ;; clc   ; return no error  ????why not  [910404]
   239                          ; bra exit_disk_op ; but if direct mode print DOS error  [910404]
   240                          
   241                          
   242                          
   243                          GetSaveChannel                                            ; Used by KeySave and SpriteSave    [910930]
   244  472e 208322                              jsr chrget                               ; eat SAVE token
   245  4731 a966                                lda #$66                                 ; parse:  filename [,U#] [,D#]
   246  4733 202074                              jsr dosprs                               ; parse options
   247  4736 20e177                              jsr chk2                                 ; check required parameters
   248                          
   249  4739 a009                                ldy #fopn                                ; DOS table offset
   250  473b a904                                lda #4                                   ; length
   251  473d 20f276                              jsr sendp
   252  4740 a900                                lda #sys_bank                            ; set banks ???? buffer in system bank ????
   253  4742 a200                                ldx #sys_bank
   254  4744 4c6bff                              jmp _setbank
   255                          
   256                          ;.end

; ******** Source: basic.asm

; ******** Source: command/bank.asm
     1                          
     2                          
     3                          ;************************************************************************
     4                          ;*  Set Memory Bank for PEEK,POKE,WAIT,BLOAD,BSAVE and SYS,BOOT Commands
     5                          ;*
     6                          ;*  Syntax: BANK DATA  n  for PEEK,POKE,WAIT,BLOAD,BSAVE
     7                          ;*  BANK SYS  [a,x,y,z] for SYS,BOOT Commands
     8                          ;*
     9                          ;* where   n=  %11111111  to access I/O area (System MAP)
    10                          ;*      %0xxxxxxx to use physical bank n
    11                          ;*
    12                          ;* or      a,x,y,z  describe precise configuration for MAPper
    13                          ;*    if omitted, the System MAP is to be used.
    14                          ;*
    15                          ;* The DATA option is to access data,  i.e., LDA/STA_far
    16                          ;* The SYS  option is to execute code, i.e., JMP/JSR_far
    17                          ;*
    18                          ;*  Idea: BANK SCREEN n  when REC is finalized????
    19                          ;************************************************************************
    20                          
    21  4747 206c5d             bank             jsr getbyt                               ; get bank number in .x
    22  474a 8ed102                              stx current_bank
    23  474d 60                                  rts
    24                          
    25                          

; ******** Source: basic.asm

; ******** Source: command/play.asm
     1                          
     2                          
     3                          
     4                          ; C65 Music Interpreter
     5                          ;
     6                          ; Syntax : PLAY "music_string"
     7                          ;
     8                          ; Where : music_string is a string of characters composed of:
     9                          ;
    10                          ; A..G   : notes
    11                          ; W,H,Q,I,S : set note lengths to whole,half,quarter,eighth,sixteenth
    12                          ; U   : set volume level   (0-9)
    13                          ; O   : set octave    (0-6)
    14                          ; T   : set current envelope  (0-9)
    15                          ; V   : select voice to play  (1-6: 1-3 right, 4-6 left)
    16                          ; X   : filter    (0-1: 0=off, 1=on)
    17                          ; M   : measure
    18                          ; R   : rest
    19                          ; .   : dot
    20                          ; #   : sharp
    21                          ; $   : flat
    22                          
    23                          
    24  474e 20675b             play             jsr frmstr                               ; frmevl,frestr,return w/ .A=len, (index)=>string
    25                          ; sta sw_rom_ram0  ;????
    26  4751 8576                                sta z_p_temp_1                           ; save number of characters
    27  4753 207b49                              jsr clear_play_flags                     ; set 'dot' and 'sharp' to 0. return with Acc=0
    28  4756 8577                                sta hulp                                 ; zero counter
    29                          
    30  4758 a477               l103_1           ldy hulp
    31  475a c476                                cpy z_p_temp_1
    32  475c f00a                                beq play_rts                             ; done!
    33  475e 20d522                              jsr indin1_ram1
    34  4761 206947                              jsr play_one_character
    35  4764 e677                                inc hulp
    36  4766 d0f0                                bne l103_1                               ; always
    37                          play_rts
    38  4768 60                                  rts
    39                          
    40                          
    41                          play_one_character
    42  4769 c920                                cmp #' '                                 ; spaces are a 'no-op'
    43  476b f0fb                                beq play_rts
    44                          
    45  476d c941               l104_1           cmp #'A'                                 ; note name a-g?
    46  476f 9005                                bcc l104_2
    47  4771 c948                                cmp #'H'
    48  4773 934601                              +lbcc play_note                          ; yes...play it
    49                          
    50  4776 a204               l104_2           ldx #4                                   ; test for notes,'w,h,q,i,s'
    51  4778 dd9649             l104_3           cmp notes,x
    52  477b f31d01                              +lbeq set_note_length
    53  477e ca                                  dex
    54  477f 10f7                                bpl l104_3
    55                          
    56  4781 c952                                cmp #'R'                                 ; rest?
    57  4783 f3a101                              +lbeq play_rest
    58  4786 c92e                                cmp #'.'                                 ; dotted note?
    59  4788 f30c01                              +lbeq play_dot
    60                          
    61  478b a205                                ldx #5                                   ; test for v,o,t,x,u,m commands
    62  478d dd9b49             l104_4           cmp mutabl,x
    63  4790 f36c01                              +lbeq play_command
    64  4793 ca                                  dex
    65  4794 10f7                                bpl l104_4                               ; test all 5 characters in table
    66                          
    67  4796 c923                                cmp #'#'                                 ; sharp?
    68  4798 f37d01                              +lbeq play_sharp
    69  479b c924                                cmp #'$'                                 ; flat?
    70  479d f37b01                              +lbeq play_flat
    71                          
    72                          
    73                          ; Must be a digit here for Octave, Voice, envelope (T), filter (X), or volume (U)
    74                          
    75  47a0 38                                  sec
    76  47a1 e930                                sbc #'0'                                 ; mask nybble
    77  47a3 c90a                                cmp #10                                  ; must be in range 0..9
    78  47a5 b3e900                              +lbcs play_bad_value
    79                          
    80  47a8 0edb11                              asl flag                                 ; octave, voice, envelope, filter, or volume?
    81  47ab b041                                bcs set_voice
    82  47ad 0edb11                              asl flag                                 ; octave, envelope, filter, or volume?
    83  47b0 b047                                bcs set_octave
    84  47b2 0edb11                              asl flag                                 ; envelope, filter, or volume?
    85  47b5 b04c                                bcs set_envelope
    86  47b7 0edb11                              asl flag                                 ; filter or volume?
    87  47ba 9072                                bcc set_volume
    88                          
    89                          set_filter
    90  47bc 207648                              jsr wait_for_all_quiet                   ; [910722]
    91  47bf c902                                cmp #2
    92  47c1 b3cd00                              +lbcs play_bad_value                     ; value too large
    93  47c4 4a                                  lsr                                      ; .c=on/off
    94  47c5 ac6f12                              ldy voice                                ; 0-5
    95  47c8 be064a                              ldx filter_offset,y                      ; 0 0 0 4 4 4
    96  47cb bd7a12                              lda filters1+2,x                         ; get current filter data for this SID  [910612]
    97  47ce 195f79                              ora vbits,y                              ; update filter voice bit
    98  47d1 b003                                bcs l105_1                               ; branch to turn filter on
    99  47d3 595f79                              eor vbits,y                              ; else, turn filter off   [910612]
   100                          
   101  47d6 9d7a12             l105_1           sta filters1+2,x
   102                          ; lda filters1+3,x ;why????     [910612]
   103                          ; sta filters1+4,x ;save new filter-type/volume
   104                          
   105                          ; jsr put_io_in_map
   106  47d9 b9004a                              lda SID_offset,y                         ; get hardware offset for current voice
   107  47dc 29f0                                and #$f0                                 ; $00 or $20
   108  47de a8                                  tay
   109                          ; jsr go_slow  ;      [910716] 4567R7A
   110  47df a303                                ldz #3
   111  47e1 bd7812             l105_2           lda filters1,x                           ; update the hardware
   112  47e4 9915d4                              sta sid1+21,y
   113  47e7 e8                                  inx
   114  47e8 c8                                  iny
   115  47e9 3b                                  dez
   116  47ea 10f5                                bpl l105_2
   117                          ; jsr go_fast  ;      [910716] 4567R7A
   118  47ec 8063                                bra clear_flag                           ; always
   119                          
   120                          
   121                          set_voice
   122  47ee 3a                                  dec
   123  47ef c906                                cmp #6                                   ; stereo SIDs: 0-2=right, 3-5=left  [910612]
   124  47f1 b39d00                              +lbcs play_bad_value
   125  47f4 8d6f12                              sta voice                                ; 0-5
   126  47f7 8058                                bra clear_flag                           ; always
   127                          
   128                          
   129                          set_octave
   130  47f9 c907                                cmp #7
   131  47fb b39300                              +lbcs play_bad_value                     ; too big octave
   132  47fe 8d7012                              sta octave                               ; set octave
   133  4801 804e                                bra clear_flag                           ; always
   134                          
   135                          
   136                          set_envelope
   137  4803 206a48                              jsr wait_for_quiet                       ; [910626]
   138  4806 aa                                  tax
   139                          set_envelope_1                                            ; entry for initialization code
   140                          ; jsr put_io_in_map
   141  4807 ac6f12                              ldy voice
   142  480a bd9d12                              lda wavtab,x
   143  480d 996912                              sta waveform,y                           ; set waveform
   144  4810 b9004a                              lda SID_offset,y                         ; get hardware offset for this voice
   145  4813 a8                                  tay
   146                          ; jsr go_slow  ;      [910716] 4567R7A
   147  4814 bd8912                              lda atktab,x
   148  4817 9905d4                              sta sid1+5,y                             ; set attack/decay
   149  481a bd9312                              lda sustab,x
   150  481d 9906d4                              sta sid1+6,y                             ; set sustain/release
   151  4820 bda712                              lda pulslw,x
   152  4823 9902d4                              sta sid1+2,y                             ; set pulse width - low byte
   153  4826 bdb112                              lda pulshi,x
   154  4829 9903d4                              sta sid1+3,y                             ; set pulse width - high byte
   155                          ; jsr go_fast  ;      [910716] 4567R7A
   156  482c 8023                                bra clear_flag
   157                          
   158                          
   159                          set_volume
   160  482e 207648                              jsr wait_for_all_quiet                   ; [910626]
   161  4831 aa                                  tax
   162  4832 ac6f12                              ldy voice                                ; [910612]
   163  4835 b9064a                              lda filter_offset,y                      ; get filter offset for this voice
   164  4838 a8                                  tay
   165  4839 b97b12                              lda filters1+3,y                         ; get mode/volume for this SID
   166  483c 29f0                                and #$f0                                 ; mask out old volume
   167  483e 1d0c4a                              ora voltab,x                             ; add new volume
   168  4841 997b12                              sta filters1+3,y                         ; save for filter change
   169                          ; lda filters1+4,y ;get current filter-type/volume ????why  [910612]
   170                          ; and #$f0
   171                          ; ora voltab,x
   172  4844 aa                                  tax
   173  4845 ac6f12                              ldy voice
   174  4848 b9004a                              lda SID_offset,y                         ; get hardware offset for current voice
   175  484b 29f0                                and #$f0                                 ; $00 or $20
   176  484d a8                                  tay
   177                          ; jsr go_slow  ;      [910716] 4567R7A
   178  484e 9b18d4                              stx sid1+24,y                            ; set new volume
   179                          ; jsr go_fast  ;      [910716] 4567R7A
   180                          ;fall into clear_flag
   181                          
   182                          clear_flag
   183  4851 a900                                lda #0
   184  4853 8ddb11                              sta flag
   185  4856 60                                  rts
   186                          
   187                          
   188                          go_fast
   189  4857 a586                                lda sid_speed_flag
   190  4859 0c31d0                              tsb vic+49
   191  485c 60                                  rts
   192                          
   193                          
   194                          go_slow
   195  485d 48                                  pha
   196  485e a940                                lda #$40
   197  4860 2d31d0                              and vic+49
   198  4863 1c31d0                              trb vic+49
   199  4866 8586                                sta sid_speed_flag
   200  4868 68                                  pla
   201  4869 60                                  rts
   202                          
   203                          
   204                          wait_for_quiet                                            ; Wait for current voice to be quiet  [910626]
   205  486a ac6f12                              ldy voice
   206  486d be9049                              ldx times2,y                             ; voice*2
   207  4870 3c5e12             l106_1           bit voices+1,x                           ; test if voice is active   [910617]
   208  4873 10fb                                bpl l106_1                               ; loop until inactive (IRQ)
   209  4875 60                                  rts
   210                          
   211                          
   212                          wait_for_all_quiet                                          ; Wait for all voices on this SID to be quiet [910626]
   213  4876 a003                                ldy #3
   214  4878 ae6f12                              ldx voice
   215  487b e003                                cpx #3                                   ; determine left/right SID
   216  487d b002                                bcs l107_1
   217  487f a000                                ldy #0
   218  4881 a303               l107_1           ldz #3                                   ; for each of 3 voices
   219  4883 be9049             l107_2           ldx times2,y
   220  4886 3c5e12             l107_3           bit voices+1,x                           ; wait for voice to be inactive (IRQ)
   221  4889 10fb                                bpl l107_3
   222  488b c8                                  iny                                      ; next voice
   223  488c 3b                                  dez
   224  488d d0f4                                bne l107_2                               ; until done 3 voices
   225  488f 60                                  rts
   226                          
   227                          
   228                          play_bad_value
   229  4890 205148                              jsr clear_flag
   230  4893 836909                              +lbra fcerr                              ; illegal quantity
   231                          
   232                          play_dot
   233  4896 8d7212                              sta dnote
   234  4899 60                                  rts
   235                          
   236                          
   237                          
   238                          set_note_length
   239                          ; ldy #<beats  ;found note (.x), divide beats accordingly
   240                          ; sty ntime
   241                          ; ldy #>beats
   242                          ; sty ntime+1
   243                          
   244  489a 2c0311                              bit _pal_ntsc                            ; determine if PAL or NTSC system  [910724]
   245  489d 3006                                bmi l108_1                               ; ...branch if PAL
   246  489f a3a0                                ldz #<beats_ntsc                         ; (whole note 4/4 time = 2 sec)
   247  48a1 a005                                ldy #>beats_ntsc
   248  48a3 8004                                bra l108_2
   249  48a5 a3b0               l108_1           ldz #<beats_pal
   250  48a7 a004                                ldy #>beats_pal
   251  48a9 9c7612             l108_2           stz ntime
   252  48ac 8c7712                              sty ntime+1
   253                          
   254  48af ca                 l108_3           dex
   255  48b0 3008                                bmi l108_4                               ; finished dividing, exit
   256  48b2 4e7712                              lsr ntime+1
   257  48b5 6e7612                              ror ntime
   258  48b8 80f5                                bra l108_3
   259                          
   260  48ba 60                 l108_4           rts
   261                          
   262                          
   263                          play_note
   264  48bb 38                                  sec
   265  48bc e941                                sbc #'A'
   266  48be aa                                  tax
   267  48bf bda149                              lda scalen,x                             ; note #0-11
   268  48c2 aa                                  tax
   269  48c3 a906                                lda #6
   270  48c5 38                                  sec
   271  48c6 ed7012                              sbc octave
   272  48c9 a8                                  tay
   273  48ca 8a                                  txa
   274  48cb 18                                  clc
   275  48cc 6d7112                              adc sharp
   276  48cf 1003                                bpl l109_1                               ; added sharp or nat
   277  48d1 a90b                                lda #11                                  ; underflow
   278  48d3 c8                                  iny                                      ; bump octave down
   279  48d4 c90c               l109_1           cmp #12                                  ; overflow?
   280  48d6 9003                                bcc l109_2                               ; no...
   281  48d8 a900                                lda #0
   282  48da 88                                  dey                                      ; bump octave up
   283  48db aa                 l109_2           tax
   284  48dc bda849                              lda scalel,x
   285  48df 8d7412                              sta pitch
   286                          
   287  48e2 2c0311                              bit _pal_ntsc                            ; determine if PAL or NTSC system
   288  48e5 3005                                bmi l109_3                               ; ...branch if PAL
   289  48e7 bdb449                              lda scaleh,x                             ; continue as before patch
   290  48ea 8009                                bra l109_4
   291                          
   292  48ec bdc049             l109_3           lda scalelp,x                            ; load from PAL tables
   293  48ef 8d7412                              sta pitch
   294  48f2 bdcc49                              lda scalehp,x
   295                          
   296  48f5 88                 l109_4           dey
   297  48f6 3028                                bmi play_note_1                          ; go play note
   298  48f8 4a                                  lsr
   299  48f9 6e7412                              ror pitch
   300  48fc 80f7                                bra l109_4
   301                          
   302                          
   303                          play_command
   304  48fe c94d                                cmp #'M'                                 ; measure?
   305  4900 f007                                beq l110_1
   306                          
   307  4902 bd6d79                              lda rbits,x                              ; all others, set flag for next number
   308  4905 8ddb11                              sta flag
   309  4908 60                                  rts
   310                          
   311                          ; Wait for msb of all 3 voice counters to underflow
   312                          
   313                          ;l110_1 ldy #5
   314                          ;l110_2 lda voices,y
   315                          ; bpl l110_2
   316                          ; dey
   317                          ; dey
   318                          ; bpl l110_2
   319                          ; rts
   320                          
   321  4909 a005               l110_1           ldy #5                                   ; [910626]
   322  490b be9049             l110_2           ldx times2,y
   323  490e 3c5e12             l110_3           bit voices+1,x                           ; wait for voice to be inactive (IRQ)
   324  4911 10fb                                bpl l110_3
   325  4913 88                                  dey                                      ; next voice
   326  4914 10f5                                bpl l110_2                               ; until done 6 voices
   327  4916 60                                  rts
   328                          
   329                          
   330                          
   331                          play_sharp
   332  4917 a901                                lda #1
   333  4919 2c                                  !text $2c
   334                          play_flat
   335  491a a9ff                                lda #$ff
   336  491c 8d7112                              sta sharp
   337  491f 60                                  rts
   338                          
   339                          
   340                          play_note_1                                               ; play a note
   341  4920 8d7512                              sta pitch+1
   342  4923 a900                                lda #0                                   ; flag 'not rest'
   343  4925 2c                                  !text $2c                                ; hop
   344                          play_rest
   345  4926 a9ff                                lda #$ff                                 ; flag 'rest'
   346  4928 48                                  pha                                      ; save flag
   347  4929 ae6f12                              ldx voice
   348  492c bc9049                              ldy times2,x                             ; y=x*2
   349  492f b95e12             l111_1           lda voices+1,y                           ; test if there is a note playing
   350  4932 10fb                                bpl l111_1                               ; and loop if so
   351                          
   352  4934 78                                  sei
   353  4935 ad7612                              lda ntime                                ; load counter for current length
   354  4938 995d12                              sta voices,y
   355  493b ad7712                              lda ntime+1
   356  493e 995e12                              sta voices+1,y
   357  4941 ad7212                              lda dnote                                ; test if this is a dotted note
   358  4944 f017                                beq l111_2                               ; no
   359  4946 ad7712                              lda ntime+1
   360  4949 4a                                  lsr                                      ; duration is 1.5 x current length
   361  494a 48                                  pha
   362  494b ad7612                              lda ntime
   363  494e 6a                                  ror
   364  494f 18                                  clc
   365  4950 795d12                              adc voices,y
   366  4953 995d12                              sta voices,y
   367  4956 68                                  pla
   368  4957 795e12                              adc voices+1,y
   369  495a 995e12                              sta voices+1,y
   370                          
   371  495d 68                 l111_2           pla                                      ; test if this is a rest
   372  495e 301a                                bmi l111_3                               ; and branch if so- clear play flags and exit [910722]
   373                          
   374                          ; jsr put_io_in_map
   375                          ; jsr go_slow  ;      [910716] 4567R7A
   376  4960 bc004a                              ldy SID_offset,x                         ; get offset to voice hardware
   377  4963 ad7412                              lda pitch
   378  4966 9900d4                              sta sid1,y
   379  4969 ad7512                              lda pitch+1
   380  496c 9901d4                              sta sid1+1,y
   381  496f a908                                lda #$08                                 ; reset this voice
   382  4971 9904d4                              sta sid1+4,y
   383  4974 bd6912                              lda waveform,x                           ; and finally, turn on gate
   384  4977 9904d4                              sta sid1+4,y
   385                          ; jsr go_fast  ;      [910716] 4567R7A
   386  497a 58                 l111_3           cli
   387                          
   388                          
   389                          clear_play_flags
   390  497b a900                                lda #0
   391  497d 8d7112                              sta sharp                                ; clear flags
   392  4980 8d7212                              sta dnote
   393  4983 58                                  cli
   394  4984 60                                  rts
   395                          
   396                          
   397  4985 206c5d             tempo            jsr getbyt                               ; duration of whole note 4/4 time = 24/rate
   398  4988 8a                                  txa
   399  4989 f37308                              +lbeq fcerr                              ; can't be zero- illegal quantity error
   400  498c 8e7312                              stx tempo_rate
   401  498f 60                                  rts
   402                          
   403                          
   404  4990 00020406080a       times2           !text 0,2,4,6,8,10                       ; [910612] stereo
   405                          
   406  4996 5748514953         notes            !text "WHQIS"                            ; sixteenth,eigth,quarter,half,and whole notes
   407                          
   408  499b 564f5458554d       mutabl           !text "VOTXUM"                           ; voice,octave,envelope,filter,volume,& measure
   409                          
   410  49a1 090b0002040507     scalen           !text 9,11,0,2,4,5,7                     ; a,b,c,d,e,f,g
   411                          
   412  49a8 0f0c46bf7d83       scalel           !text $0f,$0c,$46,$bf,$7d,$83            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (NTSC, octave 6)
   413  49ae d67a73c87c97                        !text $d6,$7a,$73,$c8,$7c,$97            ; [910729]
   414                          
   415  49b4 43474b4f5459       scaleh           !text $43,$47,$4b,$4f,$54,$59            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (NTSC, octave 6)
   416  49ba 5e646a70777e                        !text $5e,$64,$6a,$70,$77,$7e            ; [910729]
   417                          
   418  49c0 878bcc4e1424       scalelp          !text $87,$8b,$cc,$4e,$14,$24            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (PAL,  octave 6)
   419  49c6 802d3291527a                        !text $80,$2d,$32,$91,$52,$7a            ; [910729]
   420                          
   421  49cc 43474b50555a       scalehp          !text $43,$47,$4b,$50,$55,$5a            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (PAL,  octave 6)
   422  49d2 5f656b71787f                        !text $5f,$65,$6b,$71,$78,$7f            ; [910729]
   423                          
   424                          ;  Music envelope tables, default values downloaded to RAM:
   425                          ;
   426                          ; 0: piano   1: accordion    2: calliope  3: drum     4: flute
   427                          ; 5: guitar  6: harpsichord  7: organ     8: trumpet  9: xylophone
   428                          
   429                          ;  Attack/decay rates
   430                          
   431  49d8 09c0000594090909...atkmus           !text $09,$c0,$00,$05,$94,$09,$09,$09,$89,$09
   432                          
   433                          ;  Sustain/release rates
   434                          
   435  49e2 00c0f05040210090...susmus           !text $00,$c0,$f0,$50,$40,$21,$00,$90,$41,$00
   436                          
   437                          ;  Waveform table
   438                          
   439  49ec 4121118111214141...wavmus           !text $41,$21,$11,$81,$11,$21,$41,$41,$41,$11
   440                          
   441                          ;  Pulse width hi table
   442                          
   443  49f6 0600000000000208...pwhmus           !text $06,$00,$00,$00,$00,$00,$02,$08,$02,$00
   444                          
   445                          ;  Offset tables
   446                          
   447                          SID_offset
   448  4a00 00070e20272e                        !text $00,$07,$0e,$20,$27,$2e            ; [910612] stereo
   449                          filter_offset
   450  4a06 000000040404                        !text 0,0,0,4,4,4
   451                          
   452                          ;  Volume levels
   453                          
   454  4a0c 0001030507080a0c...voltab           !text 0,1,3,5,7,8,10,12,14,15
   455                          

; ******** Source: basic.asm

; ******** Source: command/filter.asm
     1                          
     2                          
     3                          
     4                          ;******************************************************************
     5                          ;
     6                          ;  FILTER  sid, freq, lp, bp, hp, res   --  set values for filter
     7                          ;
     8                          ;     sid =  right (1), left (2)
     9                          ;          freq =  filter frequency (0-1023)
    10                          ;            lp =  low pass filter on (1) or off (0)
    11                          ;            bp =  band pass filter on (1) or off (0)
    12                          ;            hp =  high pass filter on (1) or off (0)
    13                          ;           res =  resonance (0-15)
    14                          ;
    15                          ;******************************************************************
    16                          
    17  4a16 206c5d             filter           jsr getbyt                               ; get left/right SID    [910612]
    18  4a19 ca                                  dex
    19  4a1a e002                                cpx #2
    20  4a1c b3e007                              +lbcs fcerr
    21  4a1f bd084a                              lda filter_offset+2,x                    ; get filter offset for specified SID
    22  4a22 8576                                sta z_p_temp_1
    23  4a24 aa                                  tax
    24                          
    25  4a25 a000                                ldy #0
    26  4a27 bd7812             l112_1           lda filters1,x                           ; save current voice's filter params
    27  4a2a 998012                              sta fltsav,y
    28  4a2d e8                                  inx
    29  4a2e c8                                  iny
    30  4a2f c004                                cpy #4
    31  4a31 90f4                                bcc l112_1
    32                          
    33  4a33 20f278                              jsr optwrd                               ; get filter frequency
    34  4a36 9017                                bcc l112_2                               ; skip if no value given
    35  4a38 c908                                cmp #8                                   ; test m.s. byte
    36  4a3a b3c207                              +lbcs fcerr                              ; error if > 2047
    37  4a3d 8c8012                              sty fltsav                               ; save lower byte
    38                          
    39                          ; Idea: shift lower 3 bits of upper byte into lower byte, forming bits 10-3
    40                          
    41  4a40 8c8112                              sty fltsav+1
    42  4a43 4a                                  lsr
    43  4a44 6e8112                              ror fltsav+1
    44  4a47 4a                                  lsr
    45  4a48 6e8112                              ror fltsav+1                             ; save upper 7 bits (10-3)
    46  4a4b 4a                                  lsr
    47  4a4c 6e8112                              ror fltsav+1
    48                          
    49  4a4f a910               l112_2           lda #$10                                 ; start at type=LP
    50  4a51 8d8412                              sta fltflg
    51  4a54 ad8012                              lda fltsav
    52                          
    53  4a57 202679             l112_3           jsr optbyt                               ; get filter types (LP,BP,HP)
    54  4a5a 9017                                bcc l112_6                               ; skip if no value input
    55  4a5c e001                                cpx #1                                   ; (set .c: 0=0, 1=1)
    56  4a5e 9005                                bcc l112_4
    57  4a60 f003                                beq l112_4
    58  4a62 839a07                              +lbra fcerr                              ; error if >1
    59                          
    60  4a65 ad8312             l112_4           lda fltsav+3                             ; get filter flags byte
    61  4a68 0d8412                              ora fltflg                               ; set filter on
    62  4a6b b003                                bcs l112_5                               ; skip if it should be on
    63  4a6d 4d8412                              eor fltflg                               ; turn filter off
    64  4a70 8d8312             l112_5           sta fltsav+3                             ; save value
    65                          
    66  4a73 0e8412             l112_6           asl fltflg                               ; shift for next filter
    67  4a76 10df                                bpl l112_3                               ; loop 3 times
    68                          
    69  4a78 202679                              jsr optbyt                               ; get resonance value
    70  4a7b 9016                                bcc l112_7                               ; skip if no value given
    71                          ; cpx #16
    72                          ; bcs fcerr  ;error if >15
    73  4a7d 2010b5                              jsr chknyb                               ; [910930]
    74  4a80 8a                                  txa
    75  4a81 0a                                  asl                                      ; shift to upper nibble
    76  4a82 0a                                  asl
    77  4a83 0a                                  asl
    78  4a84 0a                                  asl
    79  4a85 8dbc12                              sta nibble
    80  4a88 ad8212                              lda fltsav+2                             ; get current value
    81  4a8b 290f                                and #$0f                                 ; mask it out
    82  4a8d 0dbc12                              ora nibble                               ; add new value
    83  4a90 8d8212                              sta fltsav+2                             ; save it
    84                          
    85  4a93 a676               l112_7           ldx z_p_temp_1                           ; hardware offset for this voice's filter [910612]
    86  4a95 a000                                ldy #0
    87  4a97 b98012             l112_8           lda fltsav,y                             ; copy new filter params to hardware
    88  4a9a 9d7812                              sta filters1,x
    89  4a9d e8                                  inx
    90  4a9e c8                                  iny
    91  4a9f c004                                cpy #4
    92  4aa1 90f4                                bcc l112_8
    93  4aa3 60                                  rts
    94                          
    95                          ;.end

; ******** Source: basic.asm

; ******** Source: command/envelope.asm
     1                          
     2                          
     3                          ;****************************************************************
     4                          ;
     5                          ;  ENVELOPE n, attack, decay, sustain, release, waveform, pulse width
     6                          ;        set music envelope
     7                          ;                n = envelope number (0-9)
     8                          ;            wave  =   0 : triangle waveform
     9                          ;                      1 : sawtooth waveform
    10                          ;                      2 : pulse waveform
    11                          ;                      3 : noise waveform
    12                          ;                      4 : ring modulation
    13                          ;            pulse = pulse width if pulse waveform is selected (0-4095)
    14                          ;
    15                          ;******************************************************************
    16                          
    17                          envelope
    18  4aa4 206c5d                              jsr getbyt                               ; get envelope number
    19  4aa7 e00a                                cpx #10
    20  4aa9 b35307                              +lbcs fcerr                              ; exit - invalid tone number
    21  4aac 8e8512                              stx tonnum                               ; save number
    22  4aaf bd8912                              lda atktab,x                             ; get attack/decay rates
    23  4ab2 8d8612                              sta tonval
    24  4ab5 bd9312                              lda sustab,x                             ; get sustain/release rates
    25  4ab8 8d8712                              sta tonval+1
    26  4abb bd9d12                              lda wavtab,x                             ; get waveform and filter
    27  4abe 8d8812                              sta tonval+2
    28                          
    29  4ac1 a200                                ldx #0
    30  4ac3 8ebb12             l113_1           stx parcnt
    31  4ac6 202679                              jsr optbyt                               ; get parameter - attack or sustain
    32  4ac9 9016                                bcc l113_2                               ; skip if no input
    33  4acb 8a                                  txa
    34  4acc 0a                                  asl
    35  4acd 0a                                  asl                                      ; shift to upper nibble
    36  4ace 0a                                  asl
    37  4acf 0a                                  asl
    38  4ad0 8dbc12                              sta nibble                               ; save it
    39  4ad3 aebb12                              ldx parcnt
    40  4ad6 bd8612                              lda tonval,x                             ; get current value
    41  4ad9 290f                                and #$0f                                 ; mask it out
    42  4adb 0dbc12                              ora nibble                               ; add new value
    43  4ade 9d8612                              sta tonval,x                             ; save it
    44                          
    45  4ae1 202679             l113_2           jsr optbyt                               ; get decay or release rate
    46  4ae4 9014                                bcc l113_3                               ; skip if no input
    47  4ae6 8a                                  txa
    48  4ae7 290f                                and #$0f                                 ; use only lower nibble
    49  4ae9 8dbc12                              sta nibble                               ; save it
    50  4aec aebb12                              ldx parcnt
    51  4aef bd8612                              lda tonval,x                             ; get current value
    52  4af2 29f0                                and #$f0                                 ; mask it out
    53  4af4 0dbc12                              ora nibble                               ; add new value
    54  4af7 9d8612                              sta tonval,x                             ; save it
    55                          
    56  4afa aebb12             l113_3           ldx parcnt
    57  4afd e8                                  inx
    58  4afe e001                                cpx #1
    59  4b00 f0c1                                beq l113_1                               ; loop to do sustain/release rates
    60  4b02 202679                              jsr optbyt                               ; get waveform
    61  4b05 9011                                bcc l113_5                               ; skip if no value
    62  4b07 a915                                lda #$15                                 ; assume ring modulation
    63  4b09 e004                                cpx #4
    64  4b0b f008                                beq l113_4                               ; skip if correct
    65  4b0d b3ef06                              +lbcs fcerr                              ; error if >4
    66  4b10 bd6979                              lda sbits+4,x                            ; get waveform bit
    67  4b13 0901                                ora #1                                   ; set gate bit
    68                          
    69  4b15 8d8812             l113_4           sta tonval+2                             ; save waveform
    70                          
    71  4b18 20f278             l113_5           jsr optwrd                               ; is there a pulse width arg?
    72  4b1b 9013                                bcc l113_6                               ; nope, done
    73                          
    74  4b1d aa                                  tax                                      ; save msb
    75  4b1e ad8812                              lda tonval+2                             ; get waveform
    76  4b21 2940                                and #$40
    77  4b23 f00b                                beq l113_6                               ; skip if not pulse waveform
    78  4b25 8a                                  txa
    79  4b26 ae8512                              ldx tonnum                               ; get envelope number
    80  4b29 9db112                              sta pulshi,x                             ; save high byte of pulse width
    81  4b2c 98                                  tya
    82  4b2d 9da712                              sta pulslw,x                             ; save low byte
    83                          
    84  4b30 ae8512             l113_6           ldx tonnum
    85  4b33 ad8612                              lda tonval                               ; set inputted values
    86  4b36 9d8912                              sta atktab,x
    87  4b39 ad8712                              lda tonval+1
    88  4b3c 9d9312                              sta sustab,x
    89  4b3f ad8812                              lda tonval+2
    90  4b42 9d9d12                              sta wavtab,x
    91                          volrts
    92  4b45 60                                  rts
    93                          
    94                          ;.end

; ******** Source: basic.asm

; ******** Source: command/volume.asm
     1                          
     2                          
     3                          ;***************************************************************
     4                          ;*
     5                          ;*  VOLUME - set volume of SID chips
     6                          ;*
     7                          ;* Syntax : VOLUME [right] [,left]
     8                          ;*
     9                          ;* Where  : vol in 0..15
    10                          ;*
    11                          ;***************************************************************
    12                          
    13  4b46 f302e3             volume           +lbeq snerr                              ; stereo parameters    [910612]
    14  4b49 c92c                                cmp #','
    15  4b4b f017                                beq l114_1                               ; left volume only
    16                          ; jsr getbyt  ;right volume in .x
    17                          ; cpx #16
    18                          ; bcs fcerr  ;too large
    19  4b4d 200db5                              jsr getnyb                               ; [910930]
    20  4b50 8676                                stx z_p_temp_1                           ; a temp (sorry fred)
    21                          
    22                          ; The way this is done must work with 'PLAY' without too much conflict.
    23                          ; So, along with setting the SID 'volume' reg, we'll also set up PLAY's
    24                          ; record of current volume as well.
    25                          
    26  4b52 ad7b12                              lda filters1+3
    27  4b55 29f0                                and #$f0
    28  4b57 0576                                ora z_p_temp_1
    29  4b59 8d7b12                              sta filters1+3
    30                          
    31                          ; lda filters1+4  ;???? why     [910612]
    32                          ; and #$f0
    33                          ; ora z_p_temp_1
    34                          ; sta filters1+4
    35                          
    36                          ; jsr put_io_in_map
    37                          ; jsr go_slow  ;      [910716] 4567R7A
    38  4b5c 8d18d4                              sta sid1+24
    39                          ; jsr go_fast  ;      [910716] 4567R7A
    40  4b5f 208522                              jsr chrgot
    41  4b62 f0e1                                beq volrts
    42                          
    43  4b64 202679             l114_1           jsr optbyt                               ; get optional left parameter   [910612]
    44  4b67 93e1e2                              +lbcc snerr                              ; comma but no value not given??
    45  4b6a 2010b5                              jsr chknyb                               ; [910930]
    46                          ; cpx #16
    47                          ; bcs fcerr  ;too large
    48  4b6d 8676                                stx z_p_temp_1                           ; a temp (sorry fred)
    49                          
    50  4b6f ad7f12                              lda filters2+3
    51  4b72 29f0                                and #$f0
    52  4b74 0576                                ora z_p_temp_1
    53  4b76 8d7f12                              sta filters2+3
    54                          
    55                          ; lda filters2+4  ;???? why     [910612]
    56                          ; and #$f0
    57                          ; ora z_p_temp_1
    58                          ; sta filters2+4
    59                          
    60                          ; jsr put_io_in_map
    61                          ; jsr go_slow  ;      [910716] 4567R7A
    62  4b79 8d38d4                              sta sid2+24
    63                          ; jsr go_fast  ;      [910716] 4567R7A
    64  4b7c 60                                  rts
    65                          

; ******** Source: basic.asm

; ******** Source: command/sound.asm
     1                          
     2                          
     3                          
     4                          ;*****************************************************************************
     5                          ;*
     6                          ;*  SOUND - Produce sound effects
     7                          ;*
     8                          ;* Syntax : SOUND v, f, d [,[dir] [,[m] [,[s] [,[w] [,p] ]]]]
     9                          ;*
    10                          ;* Where : v   = voice    (1..6)
    11                          ;*  f   = frequency    (0..65535)
    12                          ;*  d   = duration    (0..32767 jiffys)
    13                          ;*  dir = step direction  (0(up) ,1(down) or 2(oscillate)) default=0
    14                          ;*  m   = minimum frequency  (if sweep is used) (0..65535) default=0
    15                          ;*  s   = step value for effects  (0..32767) default=0
    16                          ;*  w   = waveform  (0=triangle,1=saw,2=square,3=noise) default=2
    17                          ;*  p   = pulse width  (0..4095) default=2048 (50% duty cycle)
    18                          ;*
    19                          ;*****************************************************************************
    20                          
    21  4b7d c99c               sound            cmp #clr_token                           ; SOUND CLR: init sound/music environment [910717]
    22  4b7f f3d472                              +lbeq Sound_CLR                          ; yes
    23                          
    24  4b82 206c5d                              jsr getbyt                               ; get voice number in .X
    25  4b85 ca                                  dex                                      ; adjust 1..3 to 0..2
    26  4b86 e006                                cpx #6                                   ; [910612]
    27  4b88 b37406             l115_1           +lbcs fcerr                              ; illegal value
    28                          
    29  4b8b 8ebd12             l115_2           stx sound_voice
    30                          
    31                          ; Get frequency
    32                          
    33  4b8e 20875d                              jsr comwrd                               ; eat comma, get frequency in y,a
    34  4b91 8c6211                              sty temp_max_lo                          ; save our copy of max, also set up as current
    35  4b94 8d6311                              sta temp_max_hi
    36  4b97 8c6911                              sty temp_freq_lo
    37  4b9a 8d6a11                              sta temp_freq_hi
    38                          
    39                          ; Get duration
    40                          
    41  4b9d 20875d                              jsr comwrd                               ; eat comma, get number of jiffys to play
    42  4ba0 c980                                cmp #$80
    43  4ba2 b0e4                                bcs l115_1
    44  4ba4 8c6011                              sty temp_time_lo
    45  4ba7 8d6111                              sta temp_time_hi
    46                          
    47                          ; Get sweep direction
    48                          
    49  4baa 202479                              jsr optzer                               ; get optional sweep (default = 0, up)
    50  4bad e003                                cpx #3
    51  4baf b0d7                                bcs l115_1
    52  4bb1 8a                                  txa
    53  4bb2 8d6611                              sta temp_direction
    54  4bb5 2901                                and #1                                   ; set .Z if sweep up or oscillate
    55  4bb7 08                                  php                                      ; save .Z for step (below)
    56                          
    57                          ; Get minimum frequency value (sweep lo)
    58                          
    59  4bb8 20f278                              jsr optwrd
    60  4bbb 8c6411                              sty temp_min_lo
    61  4bbe 8d6511                              sta temp_min_hi
    62                          
    63                          ; Get step value for sweep
    64                          
    65  4bc1 20f278                              jsr optwrd                               ; get optional step, default is zero
    66  4bc4 28                                  plp                                      ; get flags from direction
    67  4bc5 f00d                                beq l115_3                               ; branch if 'up' or oscillate
    68  4bc7 48                                  pha                                      ; if 'down', make step 2's complement
    69  4bc8 98                                  tya
    70  4bc9 49ff                                eor #$ff
    71  4bcb 18                                  clc
    72  4bcc 6901                                adc #1
    73  4bce a8                                  tay
    74  4bcf 68                                  pla
    75  4bd0 49ff                                eor #$ff
    76  4bd2 6900                                adc #0
    77  4bd4 8d6811             l115_3           sta temp_step_hi
    78  4bd7 98                                  tya
    79  4bd8 8d6711                              sta temp_step_lo
    80                          
    81                          ; Get waveform
    82                          
    83  4bdb a202                                ldx #2                                   ; get waveform. default is square (2)
    84  4bdd 202679                              jsr optbyt
    85  4be0 e004                                cpx #4
    86  4be2 b0a4                                bcs l115_1                               ; illegal value
    87  4be4 bd6979                              lda sbits+4,x                            ; get bit pattern for selected waveform
    88  4be7 0901                                ora #1                                   ; add in the gate bit
    89  4be9 8d6d11                              sta temp_waveform
    90                          
    91                          ; Get pulse width
    92                          
    93  4bec 20f278                              jsr optwrd                               ; get optional pulse width in y,a
    94  4bef b004                                bcs l115_4
    95  4bf1 a908                                lda #8                                   ; no arg's given, use default pulse width
    96  4bf3 a000                                ldy #0
    97  4bf5 c910               l115_4           cmp #16
    98  4bf7 b08f                                bcs l115_1
    99  4bf9 8c6b11                              sty temp_pulse_lo
   100  4bfc 8d6c11                              sta temp_pulse_hi
   101                          
   102                          ; All arg's in, time to get to work
   103                          
   104  4bff ad6011                              lda temp_time_lo
   105  4c02 0d6111                              ora temp_time_hi
   106  4c05 f046                                beq l115_9                               ; special case: time=0 means 'kill it NOW'
   107                          
   108                          ; Wait for all current uses of this voice to time out
   109                          
   110  4c07 aebd12                              ldx sound_voice                          ; first test 'PLAY'
   111  4c0a 8a                                  txa                                      ; make an index into PLAY's tables
   112  4c0b 0a                                  asl
   113  4c0c a8                                  tay
   114  4c0d b95e12             l115_5           lda voices+1,y
   115  4c10 10fb                                bpl l115_5
   116                          
   117  4c12 bdc412             l115_6           lda sound_time_hi,x                      ; now test 'SOUND'
   118  4c15 10fb                                bpl l115_6
   119                          
   120                          ; All clear, now set up for current effect
   121                          
   122  4c17 a000                                ldy #0                                   ; download max freq l&h, min freq l&h,
   123  4c19 b96211             l115_7           lda temp_max_lo,y                        ; ..sweep direction, step value l&h, & freq l&h
   124  4c1c 9dca12                              sta sound_max_lo,x
   125  4c1f e8                                  inx
   126  4c20 e8                                  inx
   127  4c21 e8                                  inx
   128  4c22 e8                                  inx                                      ; [910612] stereo
   129  4c23 e8                                  inx
   130  4c24 e8                                  inx
   131  4c25 c8                                  iny
   132  4c26 c009                                cpy #9
   133  4c28 90ef                                bcc l115_7
   134                          
   135                          ; Now set up SID
   136                          
   137  4c2a aebd12                              ldx sound_voice
   138  4c2d bc004a                              ldy SID_offset,x                         ; get index to SID voices
   139                          ; jsr put_io_in_map
   140                          ; jsr go_slow  ;      [910716] 4567R7A
   141                          
   142  4c30 a908                                lda #$08                                 ; turn off SID gate
   143  4c32 9904d4                              sta sid1+4,y
   144                          
   145  4c35 a900                                lda #0                                   ; set up attack & decay,
   146  4c37 9905d4                              sta sid1+5,y
   147  4c3a a9f0                                lda #$f0                                 ; ..and sustain & release
   148  4c3c 9906d4                              sta sid1+6,y
   149                          
   150  4c3f a200                                ldx #0                                   ; set up freq (l&h), pulse width (l&h), & waveform
   151  4c41 bd6911             l115_8           lda temp_freq_lo,x
   152  4c44 9900d4                              sta sid1,y
   153  4c47 c8                                  iny
   154  4c48 e8                                  inx
   155  4c49 e005                                cpx #5
   156  4c4b d0f4                                bne l115_8
   157                          ; jsr go_fast  ;      [910716] 4567R7A
   158                          
   159                          ; Now set up time to play
   160                          
   161  4c4d aebd12             l115_9           ldx sound_voice
   162  4c50 ac6011                              ldy temp_time_lo
   163  4c53 ad6111                              lda temp_time_hi
   164                          
   165  4c56 78                                  sei
   166  4c57 9dc412                              sta sound_time_hi,x
   167  4c5a 98                                  tya
   168  4c5b 9dbe12                              sta sound_time_lo,x
   169  4c5e 58                                  cli
   170                          
   171  4c5f 60                                  rts
   172                          

; ******** Source: basic.asm

; ******** Source: command/window.asm
     1                          
     2                          
     3                          
     4                          ;****************************************************************
     5                          ;*
     6                          ;*  WINDOW Command
     7                          ;*
     8                          ;*  Syntax : WINDOW upper-left col, upper-left row,
     9                          ;*      lower-left col, lower-right row [,clear]
    10                          ;*
    11                          ;*  Where  :  0 <= row <= 24
    12                          ;*       0 <= column <= (80/40)
    13                          ;*       clear : 0 (no) or 1 (yes)
    14                          ;*
    15                          ;****************************************************************
    16                          
    17  4c60 206c5d             window           jsr getbyt                               ; get u.l. col
    18  4c63 e050                                cpx #80
    19  4c65 7fd702                              bbr7 _mode,l116_1
    20  4c68 e028                                cpx #40
    21  4c6a b057               l116_1           bcs l116_4
    22  4c6c 8e7911                              stx window_temp
    23                          
    24  4c6f 20825d                              jsr combyt                               ; get u.l. row
    25  4c72 e019                                cpx #25
    26  4c74 b04d                                bcs l116_4
    27  4c76 8e7a11                              stx window_temp+1
    28                          
    29  4c79 20825d                              jsr combyt                               ; get l.r. column
    30  4c7c e050                                cpx #80
    31  4c7e 7fd702                              bbr7 _mode,l116_2
    32  4c81 e028                                cpx #40
    33  4c83 b03e               l116_2           bcs l116_4
    34  4c85 8e7b11                              stx window_temp+2
    35  4c88 ec7911                              cpx window_temp                          ; can't be less than u.l. column
    36  4c8b 9036                                bcc l116_4
    37                          
    38  4c8d 20825d                              jsr combyt                               ; get l.r. row
    39  4c90 e019                                cpx #25
    40  4c92 b02f                                bcs l116_4
    41  4c94 8e7c11                              stx window_temp+3
    42  4c97 ec7a11                              cpx window_temp+1                        ; can't be less than u.l. row
    43  4c9a 9027                                bcc l116_4
    44                          
    45  4c9c 202479                              jsr optzer                               ; get optional clear flag
    46  4c9f e002                                cpx #2
    47  4ca1 b020                                bcs l116_4
    48  4ca3 da                                  phx
    49                          
    50  4ca4 ae7911                              ldx window_temp
    51  4ca7 ad7a11                              lda window_temp+1
    52  4caa 18                                  clc
    53  4cab 202de0                              jsr _set_window
    54                          
    55  4cae ae7b11                              ldx window_temp+2
    56  4cb1 ad7c11                              lda window_temp+3
    57  4cb4 38                                  sec
    58  4cb5 202de0                              jsr _set_window
    59                          
    60  4cb8 a213                                ldx #19                                  ; assume 'home', not 'cls'
    61  4cba 68                                  pla
    62  4cbb f002                                beq l116_3
    63  4cbd a293                                ldx #147
    64  4cbf 8a                 l116_3           txa
    65  4cc0 4cd2ff                              jmp _bsout
    66                          
    67  4cc3 833905             l116_4           +lbra fcerr                              ; illegal value error
    68                          

; ******** Source: basic.asm

; ******** Source: command/fastslow.asm
     1                          
     2                          
     3                          
     4                          ;***********************************************************************
     5                          ;
     6                          ;    FAST - put the system in FAST (4 MHz?) mode.
     7                          ;
     8                          ;***********************************************************************
     9                          
    10                          fast
    11  4cc6 d382e1                              +lbne snerr                              ; no args      [910410]
    12                          ; jsr put_io_in_map
    13  4cc9 a940                                lda #%01000000
    14  4ccb 0c31d0                              tsb vic+49                               ; set FAST (4MHz?) mode
    15  4cce 60                                  rts
    16                          
    17                          
    18                          
    19                          ;***********************************************************************
    20                          ;
    21                          ;    SLOW - put the system in SLOW (1 MHz) mode.
    22                          ;
    23                          ;***********************************************************************
    24                          
    25                          slow
    26  4ccf d379e1                              +lbne snerr                              ; no args      [910410]
    27                          ; jsr put_io_in_map
    28  4cd2 a940                                lda #%01000000
    29  4cd4 1c31d0                              trb vic+49
    30  4cd7 60                                  rts
    31                          
    32                          ;.end
    33                          
    34                          
    35                          
    36                          ; These routines check for certain VALTYP.   (c) is not preserved.
    37                          
    38                          
    39                          
    40  4cd8 20ef4c             frmnum           jsr frmevl
    41                          
    42  4cdb 18                 chknum           clc
    43  4cdc 89                                  !text $89
    44                          
    45  4cdd 38                 chkstr           sec
    46                          
    47                          chkval
    48                          ; bbs7 valtyp,docstr ;cannot do this- return status +/-/= needed!
    49  4cde 240f                                bit valtyp
    50  4ce0 3003                                bmi docstr
    51  4ce2 b003                                bcs chkerr
    52  4ce4 60                 chkok            rts
    53                          
    54  4ce5 b0fd               docstr           bcs chkok
    55                          
    56  4ce7 a216               chkerr           ldx #errtm
    57  4ce9 2c                                  !text $2c
    58                          
    59  4cea a219               sterr            ldx #errst
    60  4cec 8361e1                              +lbra error
    61                          
    62                          ;.end

; ******** Source: basic.asm

; ******** Source: system/evaluate.asm
     1                          
     2                          
     3                          ; Formula Evaluator Routine
     4                          ;
     5                          ; The formula evaluator starts with (txtptr) pointing to the first character
     6                          ; in the formula.  At the end (txtptr) points to the terminator.
     7                          ; The result is left in the FAC.  On return (a) does not reflect the terminator.
     8                          ;
     9                          ; The formula evaluator uses the operator (optab) to determine precedence and
    10                          ; dispatch addresses for each operator.
    11                          ; A temporary result on the stack has the following format:
    12                          ;
    13                          ;     * The address of the operator routine.
    14                          ;     * The floating point temporary result.
    15                          ;     * The precedence of the operator.
    16                          
    17                          
    18  4cef c33d               frmevl           dew txtptr                               ; txtptr points to 1st char. in formula
    19  4cf1 a200                                ldx #0                                   ; dummy precedence = 0
    20  4cf3 89                                  !text $89
    21                          
    22  4cf4 48                 lpoper           pha                                      ; save precedence
    23  4cf5 da                                  phx
    24  4cf6 ba                                  tsx                                      ; confirm enough system stack available (recursive calls)
    25  4cf7 e089                                cpx #<sysstk+44                          ; bottom of stack + room for error handling
    26  4cf9 90ef                                bcc sterr                                ; formula too complex
    27  4cfb 20e24d                              jsr eval
    28  4cfe a900                                lda #0
    29  4d00 854f                                sta opmask
    30                          
    31  4d02 208522             tstop            jsr chrgot                               ; last char
    32  4d05 38                 loprel           sec                                      ; prepare to subtract
    33  4d06 e9b1                                sbc #greater_token                       ; is current character a relation?
    34  4d08 9017                                bcc endrel                               ; no, relations all through
    35  4d0a c903                                cmp #less_token-greater_token+1
    36  4d0c b013                                bcs endrel                               ; really relational?  no, just big
    37  4d0e c901                                cmp #1                                   ; reset carry for zero only
    38  4d10 2a                                  rol                                      ; 0 to 1, 1 to 2, 2 to 4
    39  4d11 4901                                eor #1
    40  4d13 454f                                eor opmask                               ; bring in the old bits
    41  4d15 c54f                                cmp opmask                               ; make sure that the new mask is bigger
    42  4d17 9331e1                              +lbcc snerr                              ; syntax error, because two of the same
    43  4d1a 854f                                sta opmask                               ; save mask
    44  4d1c 208322                              jsr chrget
    45  4d1f 80e4                                bra loprel                               ; get the next candidate
    46                          
    47                          
    48  4d21 a64f               endrel           ldx opmask                               ; were there any?
    49  4d23 d02c                                bne finrel                               ; yes, handle as special op
    50  4d25 b39000                              +lbcs qop                                ; not an operator
    51  4d28 6907                                adc #greater_token-plus_token
    52  4d2a 938b00                              +lbcc qop                                ; not an operator
    53  4d2d 650f                                adc valtyp                               ; (c)=1
    54  4d2f f3c50d                              +lbeq cat                                ; only if (a)=0 and VALTYP=$FF (a string)
    55                          
    56  4d32 69ff                                adc #$ff                                 ; get back original (a)
    57  4d34 8524                                sta index1
    58  4d36 0a                                  asl                                      ; multiply by two
    59  4d37 6524                                adc index1                               ; by three
    60  4d39 a8                                  tay                                      ; set up for later
    61                          
    62  4d3a 68                 qprec            pla                                      ; get previous precedence
    63  4d3b d94c29                              cmp optab,y                              ; is old precedence greater or equal?
    64  4d3e b07c                                bcs qchnum                               ; yes, go operate
    65  4d40 20db4c                              jsr chknum                               ; can't be string here
    66                          
    67  4d43 48                 doprec           pha                                      ; save old precedence
    68                          
    69  4d44 20644d             negprc           jsr dopre1                               ; save a return for op
    70  4d47 68                                  pla                                      ; pull off previous precedence
    71  4d48 a44d                                ldy opptr                                ; get pointer to op
    72  4d4a 1011                                bpl qprec1                               ; that's a real operator
    73  4d4c aa                                  tax                                      ; done?
    74  4d4d f06b                                beq qopgo                                ; done!
    75  4d4f 8074                                bra pulstk
    76                          
    77                          
    78  4d51 460f               finrel           lsr valtyp                               ; get value type into (c)
    79  4d53 8a                                  txa
    80  4d54 2a                                  rol                                      ; put VALTYP into low order bit of mask
    81  4d55 c33d                                dew txtptr                               ; decrement text pointer
    82  4d57 a01b                                ldy #ptdorl-optab                        ; make (y) point at operator entry
    83  4d59 854f                                sta opmask                               ; save the operation mask
    84  4d5b 80dd                                bra qprec                                ; branch always
    85                          
    86                          
    87                          qprec1                                                    ; note b7(VALTYP)=0 so CHKNUM call is ok
    88  4d5d d94c29                              cmp optab,y                              ; last precedence is greater?
    89  4d60 b063                                bcs pulstk                               ; yes, go operate
    90  4d62 90df                                bcc doprec                               ; no, save argument and get other operand
    91                          
    92                          
    93  4d64 b94e29             dopre1           lda optab+2,y
    94  4d67 48                                  pha                                      ; disp addr goes on stack
    95  4d68 b94d29                              lda optab+1,y
    96  4d6b 48                                  pha
    97  4d6c 20734d                              jsr pushf1                               ; save FAC on stack unpacked, precedence in (x)
    98  4d6f a54f                                lda opmask                               ; (a) may be mask for rel
    99  4d71 8081                                bra lpoper
   100                          
   101                          
   102                          pushf1                                                    ; save FAC on stack unpacked
   103  4d73 68                                  pla                                      ; first grab return address off stack
   104  4d74 8524                                sta index1
   105  4d76 68                                  pla
   106  4d77 8525                                sta index1+1
   107  4d79 e324                                inw index1
   108                          
   109  4d7b be4c29                              ldx optab,y                              ; precedence
   110  4d7e a468                                ldy facsgn
   111  4d80 5a                                  phy
   112  4d81 20b262                              jsr round                                ; put rounded FAC on stack
   113  4d84 a567                                lda faclo
   114  4d86 48                                  pha
   115  4d87 a566                                lda facmo
   116  4d89 48                                  pha
   117  4d8a a565                                lda facmoh
   118  4d8c 48                                  pha
   119  4d8d a564                                lda facho
   120  4d8f 48                                  pha
   121  4d90 a563                                lda facexp
   122  4d92 48                                  pha
   123  4d93 6c2400                              jmp (index1)                             ; return
   124                          
   125                          
   126                          pullf1                                                    ; retrieve FAC from stack unpacked  [910402]
   127  4d96 68                                  pla                                      ; first grab return address off stack
   128  4d97 8524                                sta index1
   129  4d99 68                                  pla
   130  4d9a 8525                                sta index1+1
   131  4d9c e324                                inw index1
   132                          
   133  4d9e a900                                lda #0                                   ; it's been rounded
   134  4da0 8571                                sta facov
   135  4da2 68                                  pla
   136  4da3 8563                                sta facexp
   137  4da5 68                                  pla
   138  4da6 8564                                sta facho
   139  4da8 68                                  pla
   140  4da9 8565                                sta facmoh
   141  4dab 68                                  pla
   142  4dac 8566                                sta facmo
   143  4dae 68                                  pla
   144  4daf 8567                                sta faclo
   145  4db1 68                                  pla
   146  4db2 8568                                sta facsgn
   147  4db4 6c2400                              jmp (index1)                             ; return
   148                          
   149                          
   150  4db7 a0ff               qop              ldy #255
   151  4db9 68                                  pla                                      ; get high precedence of last op
   152  4dba f023               qopgo            beq qoprts                               ; done!
   153                          
   154  4dbc c964               qchnum           cmp #100                                 ; relational operator?
   155  4dbe f003                                beq unpstk                               ; yes, don't check operand
   156  4dc0 20db4c                              jsr chknum                               ; must be number
   157                          
   158  4dc3 844d               unpstk           sty opptr                                ; save operator's pointer for next time
   159  4dc5 68                 pulstk           pla                                      ; get mask for rel op if it is one
   160  4dc6 4a                                  lsr                                      ; setup .c for dorel's chkval
   161  4dc7 8514                                sta domask                               ; save for "docmp"
   162  4dc9 68                                  pla                                      ; unpack stack into arg
   163  4dca 856a                                sta argexp
   164  4dcc 68                                  pla
   165  4dcd 856b                                sta argho
   166  4dcf 68                                  pla
   167  4dd0 856c                                sta argmoh
   168  4dd2 68                                  pla
   169  4dd3 856d                                sta argmo
   170  4dd5 68                                  pla
   171  4dd6 856e                                sta arglo
   172  4dd8 68                                  pla
   173  4dd9 856f                                sta argsgn
   174  4ddb 4568                                eor facsgn                               ; get probable result sign
   175  4ddd 8570                                sta arisgn                               ; sign used by add, sub, mul, div
   176                          
   177  4ddf a563               qoprts           lda facexp                               ; get it and set codes
   178  4de1 60                                  rts                                      ; return
   179                          
   180  4de2 6c0a03             eval             jmp (ieval)
   181                          
   182  4de5 a900               neval            lda #0                                   ; assume numeric
   183  4de7 850f                                sta valtyp
   184                          
   185  4de9 208322             eval0            jsr chrget                               ; get a character
   186  4dec b005                                bcs eval2
   187  4dee a200               eval1            ldx #0                                   ; flag 'bank 0' (text bank)
   188  4df0 839b15                              +lbra fin                                ; it is a number
   189                          
   190  4df3 200250             eval2            jsr isletc                               ; variable name?
   191  4df6 b07b                                bcs is_variable                          ; yes.
   192  4df8 c9ff                                cmp #pi                                  ; pi?
   193  4dfa d00a                                bne qdot
   194  4dfc a91e                                lda #<pival
   195  4dfe a05f                                ldy #>pival
   196  4e00 200e62                              jsr movfm                                ; put value in for p1.
   197  4e03 4c8322                              jmp chrget
   198                          
   199                          
   200  4e06 c92e               qdot             cmp #'.'                                 ; constant?
   201  4e08 f0e4                                beq eval1
   202  4e0a c9ab                                cmp #minus_token                         ; negation?
   203  4e0c f05e                                beq domin                                ; yes.
   204  4e0e c9aa                                cmp #plus_token
   205  4e10 f0d7                                beq eval0
   206  4e12 c922                                cmp #'"'                                 ; string?
   207  4e14 d015                                bne eval3
   208                          
   209  4e16 a53d               strtxt           lda txtptr
   210  4e18 a43e                                ldy txtptr+1
   211  4e1a 6900                                adc #0                                   ; c=1
   212  4e1c 9001                                bcc strtx2
   213  4e1e c8                                  iny
   214  4e1f 20855a             strtx2           jsr strlit                               ; process string
   215                          
   216  4e22 a672               st2txt           ldx strng2
   217  4e24 a473                                ldy strng2+1
   218  4e26 863d                                stx txtptr
   219  4e28 843e                                sty txtptr+1
   220  4e2a 60                                  rts
   221                          
   222                          
   223  4e2b c9a8               eval3            cmp #not_token                           ; not?
   224  4e2d d016                                bne eval4
   225  4e2f a018                                ldy #24
   226  4e31 d03b                                bne gonprc                               ; branch always
   227                          
   228                          
   229  4e33 20b458             notop            jsr ayint                                ; integerize
   230  4e36 a567                                lda faclo                                ; get argument
   231  4e38 49ff                                eor #$ff
   232  4e3a a8                                  tay
   233  4e3b a566                                lda facmo
   234  4e3d 49ff                                eor #$ff
   235                          
   236  4e3f 20d758             givayf           jsr stoint                               ; integer to float routine
   237  4e42 839614                              +lbra floats
   238                          
   239                          
   240  4e45 c9a5               eval4            cmp #fn_token                            ; user defined function?
   241  4e47 f3ec0a                              +lbeq fndoer                             ; yes
   242  4e4a c9b4                                cmp #first_function_token                ; function name?
   243  4e4c b3bfde                              +lbcs isfun                              ; yes
   244                          ; (functions are the highest numbered
   245                          ; tokens so no need to check further)
   246                          
   247  4e4f 20584e             parchk           jsr chkopn                               ; only thing left is formula in parens
   248  4e52 20ef4c                              jsr frmevl                               ; a formula in parens
   249                          
   250  4e55 a929               chkcls           lda #')'                                 ; close paren?
   251  4e57 2c                                  !text $2c
   252                          
   253  4e58 a928               chkopn           lda #'('                                 ; open paren?
   254  4e5a 2c                                  !text $2c
   255                          
   256  4e5b a92c               chkcom           lda #','                                 ; comma?
   257                          
   258                          
   259                          ; SYNCHR looks at the current character to make sure it is the specific
   260                          ; thing loaded into (a) just before the call to SYNCHR.  If not, it calls
   261                          ; the "syntax error" routine.  Otherwise it gobbles the next char and returns.
   262                          ;
   263                          ; (a)=new char and TXTPTR is advanced by CHRGET.
   264                          
   265                          
   266  4e5d a000               synchr           ldy #0
   267  4e5f 8578                                sta syntmp
   268  4e61 20c522                              jsr indtxt
   269  4e64 c578                                cmp syntmp
   270  4e66 d3e2df                              +lbne snerr
   271  4e69 4c8322                              jmp chrget                               ; ok
   272                          
   273                          
   274                          
   275                          domin
   276                          l117_1           =negtab-optab                            ; negoff
   277  4e6c a015                                ldy #l117_1                              ; precedence below '-'
   278                          
   279  4e6e 68                 gonprc           pla                                      ; get rid of rts addr.
   280  4e6f 68                                  pla
   281  4e70 83d2fe                              +lbra negprc                             ; do negation
   282                          
   283                          ;.end
   284                          
   285                          
   286                          
   287                          is_variable
   288  4e73 207c4f                              jsr ptrget                               ; parse variable name, put name in varnam
   289                          
   290  4e76 8566               isvret           sta facmo                                ; save pointer to variable
   291  4e78 8467                                sty facmo+1
   292  4e7a a647                                ldx varnam
   293  4e7c a448                                ldy varnam+1
   294  4e7e a50f                                lda valtyp
   295  4e80 f050                                beq is_numeric                           ; branch if numeric
   296                          
   297  4e82 a900                                lda #0
   298  4e84 8571                                sta facov
   299  4e86 e054                                cpx #'T'                                 ; TI$ is a special case. look for it
   300  4e88 d013                                bne isvds                                ; no- go test for DS$
   301  4e8a c0c9                                cpy #'I'+$80                             ; shifted I?
   302  4e8c d043                                bne ds_rts                               ; no- and it's not DS$ either
   303                          
   304                          ; Variable name is TI$.  To see if this is 'the' TI$ and not an
   305                          ; array TI$(), test to see if it has a pointer to the zero in "ROM".
   306                          ; If it is an array item, its pointer will be to a real value, or
   307                          ; a real zero.  If it isn't an array item, its pointer will point
   308                          ; to a dummy zero in "ROM".
   309                          
   310  4e8e a567                                lda facmo+1
   311  4e90 c902                                cmp #>zero
   312  4e92 d03d                                bne ds_rts                               ; not TI$, not DS$
   313  4e94 a566                                lda facmo
   314  4e96 c9c4                                cmp #<zero
   315  4e98 d037                                bne ds_rts
   316  4e9a 835905                              +lbra Get_TI_String                      ; the one and only TI$
   317                          
   318                          
   319  4e9d e044               isvds            cpx #'D'                                 ; is this DS$?
   320  4e9f d030                                bne ds_rts                               ; no
   321  4ea1 c0d3                                cpy #'S'+$80                             ; shifted S?
   322  4ea3 d02c                                bne ds_rts                               ; no
   323                          
   324  4ea5 200e78                              jsr Check_DS                             ; yes- check DS$ allocation,
   325                          ;  and get it if not in memory
   326  4ea8 a0ff                                ldy #$ff
   327  4eaa c8                 l118_1           iny                                      ; copy DS$ to a temp.
   328  4eab a97a                                lda #dsdesc+1                            ; must first determine how big it is
   329  4ead 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
   330  4eb0 d0f8                                bne l118_1                               ; loop until terminating null found
   331                          
   332  4eb2 98                                  tya                                      ; length of string required
   333  4eb3 20735a                              jsr strini                               ; get temp. string space & descriptor
   334  4eb6 a8                                  tay
   335  4eb7 f015                                beq l118_3                               ; (don't bother copying if length is 0)
   336                          
   337  4eb9 da                                  phx
   338                          
   339  4eba a264                                ldx #dsctmp+1                            ; ???? was ldx #frespc
   340  4ebc a97a               l118_2           lda #dsdesc+1                            ; copy DS$ into temp
   341  4ebe 88                                  dey
   342  4ebf 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
   343  4ec2 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
   344  4ec5 98                                  tya
   345  4ec6 d0f4                                bne l118_2
   346  4ec8 fa                                  plx
   347  4ec9 a579                                lda dsdesc                               ; a=length     [901014] FAB
   348  4ecb 205d5b                              jsr mvdone                               ; ???? (does nothing on C128 - bug or oversight?)
   349                          
   350  4ece 83000c             l118_3           +lbra putnew
   351                          
   352  4ed1 60                 ds_rts           rts
   353                          
   354                          
   355                          is_numeric
   356  4ed2 7f100f                              bbr7 intflg,is_floating                  ; branch if not an integer
   357  4ed5 a000                                ldy #0
   358  4ed7 20a922                              jsr indfmo                               ; fetch high
   359  4eda aa                                  tax
   360  4edb c8                                  iny
   361  4edc 20a922                              jsr indfmo                               ; fetch low
   362  4edf a8                                  tay                                      ; put low in y
   363  4ee0 8a                                  txa                                      ; get high in a
   364  4ee1 835cff                              +lbra givayf                             ; float and return
   365                          
   366                          
   367                          ; Screen out TI, ST, ER, and EL, and assign values to them.  First test
   368                          ; if the pointer points to "ROM" zero.  If not, it can't be any of the above.
   369                          
   370                          is_floating
   371  4ee4 a567                                lda facmo+1
   372  4ee6 c902                                cmp #>zero
   373  4ee8 d064                                bne gomovf                               ; not TI, etc.
   374  4eea a566                                lda facmo
   375  4eec c9c4                                cmp #<zero
   376  4eee d05e                                bne gomovf                               ; not TI, etc.
   377                          
   378                          
   379                          ; The pointer does point to the ROM zero.  Now it is necessary to
   380                          ; examine the actual variable name case by case.
   381                          
   382  4ef0 e054                                cpx #'T'                                 ; TI?
   383  4ef2 d007                                bne qstatv                               ; no
   384  4ef4 c049                                cpy #'I'
   385  4ef6 d056                                bne gomovf                               ; no, and it can't be ST either
   386  4ef8 f34805                              +lbeq Get_TI
   387                          
   388                          
   389  4efb e053               qstatv           cpx #'S'                                 ; ST?
   390  4efd d00a                                bne qdsav                                ; no, go test DS
   391  4eff c054                                cpy #'T'
   392  4f01 d04b                                bne gomovf
   393  4f03 20b7ff                              jsr _readst                              ; (???? system bank for rs232 st)
   394  4f06 83ca13                              +lbra float
   395                          
   396                          
   397  4f09 e044               qdsav            cpx #'D'                                 ; DS?
   398  4f0b d026                                bne qerlin                               ; no, go test ER & EL
   399  4f0d c053                                cpy #'S'
   400  4f0f d03d                                bne gomovf
   401                          
   402                          ; Get disk status - make the first two characters of DS$ string into a number.
   403                          
   404  4f11 200e78                              jsr Check_DS                             ; get a DS$ string if one doesn't exist already
   405  4f14 a000                                ldy #0
   406  4f16 a97a                                lda #dsdesc+1
   407  4f18 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
   408  4f1b 290f                                and #$0f
   409  4f1d 0a                                  asl
   410  4f1e 8511                                sta garbfl
   411  4f20 0a                                  asl
   412  4f21 0a                                  asl
   413  4f22 6511                                adc garbfl
   414  4f24 8511                                sta garbfl
   415  4f26 c8                                  iny
   416  4f27 a97a                                lda #dsdesc+1
   417  4f29 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
   418  4f2c 290f                                and #$0f
   419  4f2e 6511                                adc garbfl
   420  4f30 83a013                              +lbra float
   421                          
   422                          
   423  4f33 e045               qerlin           cpx #'E'                                 ; ER or EL?
   424  4f35 d017                                bne gomovf
   425  4f37 c052                                cpy #'R'
   426  4f39 f00d                                beq qnumer
   427  4f3b c04c                                cpy #'L'
   428  4f3d d00f                                bne gomovf
   429                          
   430  4f3f adc902                              lda errlin+1                             ; want EL (last error line #)
   431  4f42 acc802                              ldy errlin
   432  4f45 838009                              +lbra nosflt
   433                          
   434  4f48 adc702             qnumer           lda errnum                               ; want ER (number of last error)
   435  4f4b 838513                              +lbra float
   436                          
   437                          
   438  4f4e a566               gomovf           lda facmo
   439  4f50 a467                                ldy facmo+1
   440                          
   441  4f52 8524               movfrm           sta index1                               ; move value from RAM
   442  4f54 8425                                sty index1+1
   443                          
   444  4f56 a000                                ldy #0
   445  4f58 20d522                              jsr indin1_ram1
   446  4f5b 8563                                sta facexp
   447  4f5d 8471                                sty facov
   448                          
   449  4f5f c8                                  iny                                      ; (1)
   450  4f60 20d522                              jsr indin1_ram1
   451  4f63 8568                                sta facsgn
   452  4f65 0980                                ora #$80
   453  4f67 8564                                sta facho
   454                          
   455  4f69 c8                                  iny                                      ; (2)
   456  4f6a 20d522                              jsr indin1_ram1
   457  4f6d 8565                                sta facmoh
   458                          
   459  4f6f c8                                  iny                                      ; (3)
   460  4f70 20d522                              jsr indin1_ram1
   461  4f73 8566                                sta facmo
   462                          
   463  4f75 c8                                  iny                                      ; (4)
   464  4f76 20d522                              jsr indin1_ram1
   465  4f79 8567                                sta faclo
   466  4f7b 60                                  rts
   467                          
   468                          ;.end
   469                          
   470                          
   471                          
   472                          ;  Read the variable name at the current text position and put a pointer
   473                          ;  to its value in VARPNT.   TXTPTR points to the terminating character.
   474                          ;  Note that evaluating subscripts in a variable name can cause recursive
   475                          ;  calls to PTRGET, so all values must be stored on the stack.
   476                          
   477  4f7c a200               ptrget           ldx #0
   478  4f7e 208522                              jsr chrgot
   479  4f81 860e               ptrgt1           stx dimflg                               ; store flag away
   480  4f83 8547               ptrgt2           sta varnam
   481  4f85 208522                              jsr chrgot                               ; get current character
   482  4f88 200250                              jsr isletc                               ; check for a letter
   483  4f8b 93bdde                              +lbcc snerr                              ; not a letter
   484                          
   485  4f8e a200                                ldx #0                                   ; assume no second character
   486  4f90 860f                                stx valtyp                               ; default is numeric
   487  4f92 8610                                stx intflg                               ; assume floating
   488  4f94 208322                              jsr chrget                               ; get following character
   489  4f97 9005                                bcc l119_1                               ; branch if numeric
   490  4f99 200250                              jsr isletc                               ; is it alpha?
   491  4f9c 900b                                bcc l119_3                               ; no, no second character. branch
   492  4f9e aa                 l119_1           tax                                      ; issec. save second character of name
   493                          
   494  4f9f 208322             l119_2           jsr chrget                               ; skip over remainder of name. we only care about 2 chars.
   495  4fa2 90fb                                bcc l119_2                               ; ..eat numbers,
   496  4fa4 200250                              jsr isletc
   497  4fa7 b0f6                                bcs l119_2                               ; ..and alphas, too!
   498                          
   499  4fa9 c924               l119_3           cmp #'$'                                 ; nosec. is this a string?
   500  4fab d006                                bne l119_4                               ; if not, VALTYP = 0
   501  4fad a9ff                                lda #$ff
   502  4faf 850f                                sta valtyp                               ; ..else, flag 'string'
   503  4fb1 800f                                bra l119_5
   504                          
   505  4fb3 c925               l119_4           cmp #'%'                                 ; notstr. isn't string. is it integer?
   506  4fb5 d012                                bne l119_6                               ; branch if not
   507  4fb7 a512                                lda subflg
   508                          ; bne snerr ; syntax error if integers disabled
   509  4fb9 d32cfd                              +lbne chkerr                             ; integers disallowed- type mismatch error  [910114]
   510  4fbc a980                                lda #$80                                 ; flag integer by turning on both high bits
   511  4fbe 8510                                sta intflg
   512  4fc0 0447                                tsb varnam
   513                          
   514  4fc2 8a                 l119_5           txa                                      ; turnon. turn on msb of second character
   515  4fc3 0980                                ora #$80
   516  4fc5 aa                                  tax
   517  4fc6 208322                              jsr chrget                               ; get character after $ or %
   518                          
   519  4fc9 8648               l119_6           stx varnam+1                             ; strnam. store away second character
   520  4fcb 38                                  sec
   521  4fcc 0512                                ora subflg                               ; add flag whether to allow arrays
   522  4fce e928                                sbc #'('
   523  4fd0 f3b101                              +lbeq is_array                           ; note: won't match if SUBFLG set
   524                          
   525  4fd3 a000                                ldy #0
   526  4fd5 8412                                sty subflg                               ; allow subscripts again
   527  4fd7 a52f                                lda vartab                               ; place to start search
   528  4fd9 a630                                ldx vartab+1
   529                          
   530  4fdb 8662               l119_7           stx lowtr+1                              ; stxfnd.
   531  4fdd 8561               l119_8           sta lowtr
   532  4fdf e432                                cpx arytab+1                             ; at end of table yet?
   533  4fe1 d004                                bne l119_9
   534  4fe3 c531                                cmp arytab
   535  4fe5 f025                                beq notfns                               ; yes, we couldn't find it
   536                          
   537  4fe7 20bd22             l119_9           jsr indlow_ram1                          ; lda (lowtr),y
   538  4fea c547                                cmp varnam                               ; compare high orders
   539  4fec d00a                                bne l119_10
   540  4fee c8                                  iny
   541  4fef 20bd22                              jsr indlow_ram1
   542  4ff2 c548                                cmp varnam+1                             ; and the low part?
   543  4ff4 f32f01                              +lbeq finptr                             ; !!that's it!!
   544                          
   545  4ff7 88                                  dey
   546  4ff8 18                 l119_10          clc
   547  4ff9 a561                                lda lowtr
   548  4ffb 6907                                adc #7                                   ; makes no difference among types
   549  4ffd 90de                                bcc l119_8
   550  4fff e8                                  inx
   551  5000 80d9                                bra l119_7                               ; branch always
   552                          
   553                          
   554                          
   555                          
   556                          ; Test for a letter: (c)=0 not a letter
   557                          ;   (c)=1 a letter
   558                          
   559  5002 c941               isletc           cmp #'A'
   560  5004 9005                                bcc l120_1                               ; if less than "a", return
   561  5006 e95b                                sbc #'Z'+1                               ; $5a + 1
   562  5008 38                                  sec
   563  5009 e9a5                                sbc #$a5                                 ; reset carry if (a) .gt. "z".
   564  500b 60                 l120_1           rts
   565                          
   566                          
   567  500c ba                 notfns           tsx                                      ; check who's calling????
   568  500d bd0201                              lda $102,x                               ; sniff processor stack
   569  5010 c957                                cmp #>pointer_ret
   570  5012 f004                                beq ldzr                                 ; special case if called by pointer function
   571                          
   572                          l121_1           = isvret-1
   573  5014 c94e                                cmp #>l121_1                             ; is eval calling????
   574  5016 d02a                                bne notevl                               ; no, carry on
   575                          
   576  5018 a9c4               ldzr             lda #<zero                               ; set up pointer to simulated zero
   577  501a a002                                ldy #>zero
   578  501c 60                                  rts                                      ; for strings or numeric
   579                          
   580                          
   581  501d c0c9               qst001           cpy #'I'+$80                             ; we know first is T, is second <shift>I (TI$)?
   582  501f f0f7                                beq ldzr
   583  5021 c049                                cpy #'I'                                 ; or I (TI)?
   584  5023 d031                                bne varok
   585  5025 f018                                beq gobadv
   586                          
   587                          
   588  5027 c0d3               qst004           cpy #'S'+$80                             ; check for DS$
   589  5029 f014                                beq gobadv
   590  502b c053                                cpy #'S'                                 ; check for DS
   591  502d d027                                bne varok
   592  502f f00e                                beq gobadv
   593                          
   594                          
   595  5031 c054               qst002           cpy #'T'                                 ; check for ST
   596  5033 d021                                bne varok
   597  5035 f008                                beq gobadv
   598                          
   599                          
   600  5037 c052               qst003           cpy #'R'                                 ; check for ER
   601  5039 f004                                beq gobadv
   602  503b c04c                                cpy #'L'                                 ; check for EL
   603  503d d017                                bne varok
   604                          
   605                          
   606  503f 8309de             gobadv           +lbra snerr
   607                          
   608                          
   609                          
   610  5042 a547               notevl           lda varnam
   611  5044 a448                                ldy varnam+1
   612  5046 c954                                cmp #'T'                                 ; screen out TI
   613  5048 f0d3                                beq qst001
   614  504a c953                                cmp #'S'                                 ; ...and ST
   615  504c f0e3                                beq qst002
   616  504e c945                                cmp #'E'                                 ; ...and ER and EL
   617  5050 f0e5                                beq qst003
   618  5052 c944                                cmp #'D'                                 ; ...and DS
   619  5054 f0d1                                beq qst004
   620                          
   621                          
   622  5056 a531               varok            lda arytab
   623  5058 a432                                ldy arytab+1
   624  505a 8561                                sta lowtr
   625  505c 8462                                sty lowtr+1
   626  505e a533                                lda strend
   627  5060 a434                                ldy strend+1
   628  5062 855c                                sta hightr
   629  5064 845d                                sty hightr+1
   630  5066 18                                  clc
   631  5067 6907                                adc #7
   632  5069 9001                                bcc l122_1                               ; not even
   633  506b c8                                  iny
   634                          
   635  506c 855a               l122_1           sta highds
   636  506e 845b                                sty highds+1
   637  5070 203451                              jsr bltu
   638  5073 a55a                                lda highds
   639  5075 a45b                                ldy highds+1
   640  5077 c8                                  iny
   641  5078 8531                                sta arytab
   642  507a 8432                                sty arytab+1
   643                          
   644                          
   645                          ; Scan thru array entries for string arrays.  If any are found it will be
   646                          ; necessary to adjust the back-links of the strings in that array, since
   647                          ; the array descriptor block itself was moved.
   648                          
   649  507c 855a                                sta arypnt                               ; set pointer to arrays
   650  507e 845b                                sty arypnt+1
   651                          
   652  5080 a55a               aryva2           lda arypnt
   653  5082 a65b                                ldx arypnt+1
   654                          
   655  5084 e434               aryva3           cpx strend+1                             ; end of arrays?
   656  5086 d004                                bne aryvgo
   657  5088 c533                                cmp strend
   658  508a f07e                                beq arydon                               ; ...finished
   659                          
   660                          
   661  508c 8524               aryvgo           sta index1
   662  508e 8625                                stx index1+1
   663  5090 a000                                ldy #0
   664  5092 20d522                              jsr indin1_ram1                          ; look at array name
   665  5095 aa                                  tax
   666  5096 c8                                  iny
   667  5097 20d522                              jsr indin1_ram1                          ; name 2nd char
   668  509a 08                                  php                                      ; save status reg
   669  509b c8                                  iny
   670  509c 20d522                              jsr indin1_ram1                          ; point to offset to next array
   671  509f 655a                                adc arypnt
   672  50a1 855a                                sta arypnt                               ; save start of next array in arypnt
   673  50a3 c8                                  iny
   674  50a4 20d522                              jsr indin1_ram1
   675  50a7 655b                                adc arypnt+1
   676  50a9 855b                                sta arypnt+1
   677  50ab 28                                  plp                                      ; restore status
   678  50ac 10d2                                bpl aryva2                               ; not a string type
   679  50ae 8a                                  txa
   680  50af 30cf                                bmi aryva2                               ; not a string array
   681  50b1 c8                                  iny                                      ; ok we have a string array
   682  50b2 20d522                              jsr indin1_ram1                          ; get number of dimensions
   683  50b5 a000                                ldy #0
   684  50b7 0a                                  asl                                      ; move index to ptr to 1st string (add 2*number of dims + 5)
   685  50b8 6905                                adc #5
   686  50ba 6524                                adc index1
   687  50bc 8524                                sta index1
   688  50be 9002                                bcc aryget
   689  50c0 e625                                inc index1+1
   690                          
   691  50c2 a625               aryget           ldx index1+1
   692  50c4 e45b                                cpx arypnt+1                             ; done with this array?
   693  50c6 d004                                bne l123_1
   694  50c8 c55a                                cmp arypnt
   695  50ca f0b8                                beq aryva3                               ; yes
   696                          
   697  50cc a000               l123_1           ldy #0                                   ; process string pointer
   698  50ce 20d522                              jsr indin1_ram1                          ; get length of string
   699  50d1 f02a                                beq dvarts                               ; skip if null string
   700  50d3 8578                                sta syntmp
   701  50d5 c8                                  iny
   702  50d6 20d522                              jsr indin1_ram1                          ; get lo byte of string ptr
   703  50d9 18                                  clc
   704  50da 6578                                adc syntmp                               ; and add string length
   705  50dc 855c                                sta hightr
   706  50de c8                                  iny
   707  50df 20d522                              jsr indin1_ram1                          ; get hi byte of string ptr
   708  50e2 6900                                adc #0                                   ; adjust high byte
   709  50e4 855d                                sta hightr+1
   710                          
   711                          ; Fix backwards pointer by adding move length to it.
   712                          
   713  50e6 da                                  phx
   714  50e7 a25c                                ldx #hightr
   715  50e9 a000                                ldy #0
   716  50eb 20a522                              jsr indhtr_ram1                          ; lda (hightr),y
   717  50ee 6907                                adc #7                                   ; carry clear (careful!)
   718  50f0 20f022                              jsr sta_far_ram1                         ; sta (hightr),y
   719  50f3 c8                                  iny
   720  50f4 20a522                              jsr indhtr_ram1                          ; lda (hightr),y
   721  50f7 6900                                adc #0
   722  50f9 20f022                              jsr sta_far_ram1                         ; sta (hightr),y
   723  50fc fa                                  plx                                      ; done with this string
   724                          
   725                          ; Fix the next string in the array
   726                          
   727  50fd a903               dvarts           lda #strsiz
   728  50ff 18                                  clc
   729  5100 6524                                adc index1
   730  5102 8524                                sta index1
   731  5104 90bc                                bcc aryget
   732  5106 e625                                inc index1+1
   733  5108 80b8                                bra aryget                               ; branch always
   734                          
   735                          
   736  510a da                 arydon           phx
   737  510b a261                                ldx #lowtr
   738  510d a000                                ldy #0
   739  510f a547                                lda varnam
   740  5111 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
   741  5114 c8                                  iny                                      ; .y=1
   742  5115 a548                                lda varnam+1
   743  5117 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
   744  511a a900                                lda #0
   745  511c c8                 l124_1           iny
   746  511d 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
   747  5120 c006                                cpy #6
   748  5122 d0f8                                bne l124_1
   749  5124 fa                                  plx
   750                          
   751  5125 a561               finptr           lda lowtr
   752  5127 18                                  clc
   753  5128 6902                                adc #2
   754  512a a462                                ldy lowtr+1
   755  512c 9001                                bcc l125_1
   756  512e c8                                  iny
   757  512f 8549               l125_1           sta varpnt
   758  5131 844a                                sty varpnt+1
   759  5133 60                                  rts
   760                          
   761                          
   762                          
   763                          
   764  5134 20af31             bltu             jsr reason
   765  5137 8533                                sta strend
   766  5139 8434                                sty strend+1
   767  513b 38                                  sec
   768  513c a55c                                lda hightr
   769  513e e561                                sbc lowtr
   770  5140 8524                                sta index
   771  5142 a8                                  tay
   772  5143 a55d                                lda hightr+1
   773  5145 e562                                sbc lowtr+1
   774  5147 aa                                  tax
   775  5148 e8                                  inx
   776  5149 98                                  tya
   777  514a f02f                                beq decblt
   778  514c a55c                                lda hightr
   779  514e 38                                  sec
   780  514f e524                                sbc index
   781  5151 855c                                sta hightr
   782  5153 b003                                bcs l126_1
   783  5155 c65d                                dec hightr+1
   784  5157 38                                  sec
   785  5158 a55a               l126_1           lda highds
   786  515a e524                                sbc index
   787  515c 855a                                sta highds
   788  515e b00e                                bcs moren1
   789  5160 c65b                                dec highds+1
   790  5162 900a                                bcc moren1
   791                          
   792  5164 20a522             bltlp            jsr indhtr_ram1                          ; lda (hightr),y
   793  5167 da                                  phx
   794  5168 a25a                                ldx #highds
   795  516a 20f022                              jsr sta_far_ram1                         ; sta (highds),y
   796  516d fa                                  plx
   797                          
   798  516e 88                 moren1           dey
   799  516f d0f3                                bne bltlp
   800  5171 20a522                              jsr indhtr_ram1                          ; lda (hightr),y
   801  5174 da                                  phx
   802  5175 a25a                                ldx #highds
   803  5177 20f022                              jsr sta_far_ram1                         ; sta (highds),y
   804  517a fa                                  plx
   805                          
   806  517b c65d               decblt           dec hightr+1
   807  517d c65b                                dec highds+1
   808  517f ca                                  dex
   809  5180 d0ec                                bne moren1
   810  5182 60                                  rts
   811                          

; ******** Source: basic.asm

; ******** Source: system/arrays.asm
     1                          
     2                          
     3                          
     4                          ; The format of arrays in core:
     5                          ;
     6                          ; Descriptor: low  byte = first character
     7                          ;   high byte = second character (msb is string flag)
     8                          ; Length of array in memory in bytes (includes everything).
     9                          ; Number of dimensions.
    10                          ; For each dimension starting with the first a list (2 bytes each)
    11                          ; of the max indice+1.
    12                          ; The values.
    13                          
    14                          
    15                          is_array
    16  5183 a50e                                lda dimflg
    17  5185 0510                                ora intflg
    18  5187 48                                  pha                                      ; save DIMFLG for recursion
    19  5188 a50f                                lda valtyp
    20  518a 48                                  pha                                      ; save VALTYP for recursion
    21  518b a000                                ldy #0                                   ; set number of dimensions to zero
    22                          
    23  518d 5a                 l127_1           phy                                      ; save number of dims
    24  518e a548                                lda varnam+1
    25  5190 48                                  pha
    26  5191 a547                                lda varnam
    27  5193 48                                  pha                                      ; save looks
    28  5194 20a758                              jsr intidx                               ; evaluate indice into facmo&lo
    29  5197 68                                  pla
    30  5198 8547                                sta varnam
    31  519a 68                                  pla
    32  519b 8548                                sta varnam+1                             ; get back all...we're home
    33  519d 7a                                  ply                                      ; (# of units)
    34  519e ba                                  tsx
    35  519f bd0201                              lda 258,x
    36  51a2 48                                  pha                                      ; push DIMFLG and VALTYP further
    37  51a3 bd0101                              lda 257,x
    38  51a6 48                                  pha
    39  51a7 a566                                lda indice                               ; put indice onto stack
    40  51a9 9d0201                              sta 258,x                                ; under DIMFLG and VALTYP
    41  51ac a567                                lda indice+1
    42  51ae 9d0101                              sta 257,x
    43  51b1 c8                                  iny                                      ; y counts # of subscripts
    44  51b2 840d                                sty count                                ; protect y from chrget
    45  51b4 208522                              jsr chrgot                               ; get terminating character
    46  51b7 a40d                                ldy count
    47  51b9 c92c                                cmp #','                                 ; more subscripts?
    48  51bb f0d0                                beq l127_1                               ; yes
    49                          
    50                          
    51  51bd 20554e                              jsr chkcls                               ; must be closed paren
    52  51c0 68                                  pla
    53  51c1 850f                                sta valtyp                               ; get VALTYP and
    54  51c3 68                                  pla
    55  51c4 8510                                sta intflg
    56  51c6 297f                                and #$7f
    57  51c8 850e                                sta dimflg                               ; DIMFLG off stack
    58  51ca a631                                ldx arytab                               ; place to start search
    59  51cc a532                                lda arytab+1
    60                          
    61                          
    62  51ce 8661               l127_2           stx lowtr
    63  51d0 8562                                sta lowtr+1
    64  51d2 c534                                cmp strend+1                             ; end of arrays?
    65  51d4 d004                                bne l127_3
    66  51d6 e433                                cpx strend
    67  51d8 f043                                beq notfdd                               ; a fine thing! no array!
    68                          
    69  51da a000               l127_3           ldy #0
    70  51dc 20bd22                              jsr indlow_ram1                          ; get high of name from array bank (ram1)
    71  51df c8                                  iny
    72  51e0 c547                                cmp varnam                               ; compare high orders.
    73  51e2 d007                                bne l127_4                               ; no way is it this. get the bite outta here
    74  51e4 20bd22                              jsr indlow_ram1
    75  51e7 c548                                cmp varnam+1                             ; low orders?
    76  51e9 f018                                beq gotary                               ; well here it is
    77                          
    78  51eb c8                 l127_4           iny
    79  51ec 20bd22                              jsr indlow_ram1                          ; get length
    80  51ef 18                                  clc
    81  51f0 6561                                adc lowtr
    82  51f2 aa                                  tax
    83  51f3 c8                                  iny
    84  51f4 20bd22                              jsr indlow_ram1
    85  51f7 6562                                adc lowtr+1
    86  51f9 90d3                                bcc l127_2                               ; always branches
    87                          
    88                          
    89  51fb a212               bserr            ldx #errbs                               ; get bad sub error number
    90  51fd 2c                                  !text $2c
    91                          
    92  51fe a20e               fcerr            ldx #errfc                               ; too big. Illegal Quantity error
    93  5200 834ddc                              +lbra error
    94                          
    95                          
    96                          
    97  5203 a213               gotary           ldx #errdd                               ; perhaps a "re-dimension" error
    98  5205 a50e                                lda dimflg                               ; test the DIMFLG
    99  5207 d346dc                              +lbne error
   100  520a 206c53                              jsr fmaptr
   101  520d a004                                ldy #4
   102  520f 20bd22                              jsr indlow_ram1
   103  5212 8578                                sta syntmp
   104  5214 a50d                                lda count                                ; get number of dims input.
   105  5216 c578                                cmp syntmp                               ; # of dims the same?
   106  5218 d0e1                                bne bserr                                ; same so get definition.
   107  521a 83b300                              +lbra getdef
   108                          
   109                          
   110                          ; Come here when variable is not found in the array table to build an entry.
   111                          ;
   112                          ; Put down the descriptor.
   113                          ; Setup number of dimensions.
   114                          ; Make sure there is room for the new entry.
   115                          ; Remember VARPNT.
   116                          ; Tally=4.
   117                          ; Skip two locs for later fill in of size.
   118                          ; LOOP: Get an indice.
   119                          ;  Put down number+1 and increment VARPTR.
   120                          ;  Tally=tally*number+1
   121                          ;  Decrement number of dims.
   122                          ;  Bne LOOP
   123                          ; Call REASON with (a,b) reflecting last loc of variable.
   124                          ; Update STREND
   125                          ; Zero all.
   126                          ; Make tally include maxdims and descriptor.
   127                          ; Put down tally
   128                          ; If called by dimension, return.
   129                          ;  Else index into the variable as if it were found on the initial search.
   130                          
   131                          notfdd
   132  521d 206c53                              jsr fmaptr                               ; form ARYPNT
   133  5220 20af31                              jsr reason
   134  5223 a000                                ldy #0
   135  5225 8473                                sty curtol+1
   136  5227 a205                                ldx #5
   137  5229 a547                                lda varnam
   138  522b 08                                  php
   139  522c da                                  phx
   140  522d a261                                ldx #lowtr                               ; point to string/array bank
   141  522f 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
   142  5232 fa                                  plx
   143  5233 28                                  plp
   144  5234 1001                                bpl l128_1
   145  5236 ca                                  dex
   146                          
   147  5237 c8                 l128_1           iny                                      ; notflt.
   148  5238 a548                                lda varnam+1
   149  523a 08                                  php
   150  523b da                                  phx
   151  523c a261                                ldx #lowtr                               ; point to string/array bank
   152  523e 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
   153  5241 fa                                  plx
   154  5242 28                                  plp
   155  5243 1002                                bpl l128_2
   156  5245 ca                                  dex
   157  5246 ca                                  dex
   158                          
   159  5247 8672               l128_2           stx curtol
   160  5249 a50d                                lda count                                ; save number of dimensions
   161  524b c8                                  iny
   162  524c c8                                  iny
   163  524d c8                                  iny
   164  524e a261                                ldx #lowtr                               ; point to string/array bank
   165  5250 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
   166                          
   167  5253 a20b               l128_3           ldx #11                                  ; loppta. default size
   168  5255 a900                                lda #0
   169  5257 6f0e08                              bbr6 dimflg,l128_4                       ; not in a dim statement
   170  525a 68                                  pla                                      ; get low order of indice
   171  525b 18                                  clc
   172  525c 6901                                adc #1
   173  525e aa                                  tax
   174  525f 68                                  pla                                      ; get high order of indice
   175  5260 6900                                adc #0
   176                          
   177  5262 c8                 l128_4           iny                                      ; notdim.
   178  5263 da                                  phx
   179  5264 a261                                ldx #lowtr
   180  5266 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; store high part of indice
   181  5269 fa                                  plx
   182  526a c8                                  iny
   183  526b 8a                                  txa
   184  526c da                                  phx
   185  526d a261                                ldx #lowtr
   186  526f 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; store low part of indice
   187  5272 fa                                  plx
   188  5273 203753                              jsr umult                                ; (a,x)+(curtol)*(lowtr,y)
   189  5276 8672                                stx curtol                               ; save new tally
   190  5278 8573                                sta curtol+1
   191  527a a424                                ldy index
   192  527c c60d                                dec count                                ; any more indices left?
   193  527e d0d3                                bne l128_3                               ; yes
   194  5280 655b                                adc arypnt+1
   195  5282 b3bddb                              +lbcs omerr                              ; overflow
   196  5285 855b                                sta arypnt+1                             ; compute where to zero
   197  5287 a8                                  tay
   198  5288 8a                                  txa
   199  5289 655a                                adc arypnt
   200  528b 9004                                bcc l128_5
   201  528d c8                                  iny
   202  528e f3b1db                              +lbeq omerr
   203                          
   204  5291 20af31             l128_5           jsr reason                               ; grease.  get room
   205  5294 8533                                sta strend
   206  5296 8434                                sty strend+1                             ; new end of storage
   207  5298 a900                                lda #0                                   ; storing (a) is faster than clear
   208  529a e673                                inc curtol+1
   209  529c a472                                ldy curtol
   210  529e f00c                                beq l128_7
   211                          
   212  52a0 88                 l128_6           dey                                      ; zero out new entry
   213  52a1 08                                  php
   214  52a2 da                                  phx
   215  52a3 a25a                                ldx #arypnt
   216  52a5 20f022                              jsr sta_far_ram1                         ; sta (arypnt),y
   217  52a8 fa                                  plx
   218  52a9 28                                  plp
   219  52aa d0f4                                bne l128_6                               ; no. continue
   220                          
   221  52ac c65b               l128_7           dec arypnt+1                             ; deccur.
   222  52ae c673                                dec curtol+1
   223  52b0 d0ee                                bne l128_6                               ; do another block
   224  52b2 e65b                                inc arypnt+1                             ; bump back up. will use later
   225  52b4 38                                  sec
   226  52b5 a533                                lda strend                               ; restore (a)
   227  52b7 e561                                sbc lowtr                                ; determine length
   228  52b9 a002                                ldy #2
   229  52bb da                                  phx
   230  52bc a261                                ldx #lowtr
   231  52be 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; low
   232  52c1 a534                                lda strend+1
   233  52c3 c8                                  iny
   234  52c4 e562                                sbc lowtr+1
   235  52c6 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; high
   236  52c9 fa                                  plx
   237  52ca a50e                                lda dimflg                               ; quit here if this is a DIM statement
   238  52cc d068                                bne dimrts                               ; bye!
   239  52ce c8                                  iny
   240                          
   241                          
   242                          ; At this point (LOWTR,y) points beyond the size to the number of dimensions.
   243                          ; Strategy:
   244                          ;  NUMDIM = number of dimensions
   245                          ;  curtol = 0
   246                          ;  INLPNM: Get a new indice
   247                          ;   Make sure indice is not too big
   248                          ;   Multiply CURTOL by CURMAX
   249                          ;   Add indice to CURTOL
   250                          ;   NUMDIM=NUMDIM-1
   251                          ;   bne INLPNM
   252                          ;  Use (CURTOL)*4 as offset
   253                          
   254                          
   255  52cf 20bd22             getdef           jsr indlow_ram1                          ; get # of dim's from string bank
   256  52d2 850d                                sta count                                ; save a counter
   257  52d4 a900                                lda #0                                   ; zero (curtol)
   258  52d6 8572                                sta curtol
   259                          
   260  52d8 8573               inlpnm           sta curtol+1
   261  52da fa                                  plx                                      ; get low indice
   262  52db 8666                                stx indice
   263  52dd c8                                  iny
   264  52de 20bd22                              jsr indlow_ram1
   265  52e1 8578                                sta syntmp
   266  52e3 68                                  pla                                      ; and the high part
   267  52e4 8567                                sta indice+1
   268  52e6 c578                                cmp syntmp                               ; compare with max indice
   269  52e8 900f                                bcc inlpn2
   270  52ea d00a                                bne bserr7                               ; if greater, "bad subscript" error
   271  52ec c8                                  iny
   272  52ed 20bd22                              jsr indlow_ram1
   273  52f0 8578                                sta syntmp
   274  52f2 e478                                cpx syntmp
   275  52f4 9004                                bcc inlpn1
   276                          
   277  52f6 8303ff             bserr7           +lbra bserr
   278                          
   279                          
   280  52f9 c8                 inlpn2           iny
   281  52fa a573               inlpn1           lda curtol+1                             ; don't multiply if curtol=0
   282  52fc 0572                                ora curtol
   283  52fe 18                                  clc                                      ; prepare to get indice back
   284  52ff f00a                                beq l129_1                               ; get high part of indice back
   285  5301 203753                              jsr umult                                ; multiply (curtol) by (5&6,lowtr)
   286  5304 8a                                  txa
   287  5305 6566                                adc indice                               ; add in (indice)
   288  5307 aa                                  tax
   289  5308 98                                  tya
   290  5309 a424                                ldy index1
   291                          
   292  530b 6567               l129_1           adc indice+1
   293  530d 8672                                stx curtol
   294  530f c60d                                dec count                                ; any more?
   295  5311 d0c5                                bne inlpnm                               ; yes
   296  5313 8573                                sta curtol+1
   297  5315 a205                                ldx #5
   298  5317 a547                                lda varnam
   299  5319 1001                                bpl l129_2
   300  531b ca                                  dex
   301  531c a548               l129_2           lda varnam+1
   302  531e 1002                                bpl l129_3
   303  5320 ca                                  dex
   304  5321 ca                                  dex
   305  5322 862a               l129_3           stx addend
   306  5324 a900                                lda #0
   307  5326 204253                              jsr umultd                               ; on rts, a & y = hi. x = lo.
   308  5329 8a                                  txa
   309  532a 655a                                adc arypnt
   310  532c 8549                                sta varpnt
   311  532e 98                                  tya
   312  532f 655b                                adc arypnt+1
   313  5331 854a                                sta varpnt+1
   314  5333 a8                                  tay
   315  5334 a549                                lda varpnt
   316  5336 60                 dimrts           rts
   317                          
   318                          
   319                          ; Integer arithmetic routines.
   320                          ;
   321                          ; Two byte unsigned integer multiply.
   322                          ; This is for multiply dimensioned arrays.
   323                          ; (a,b)=(curtol)*(5&6,x).
   324                          
   325                          umult
   326  5337 8424                                sty index
   327  5339 20bd22                              jsr indlow_ram1
   328  533c 852a                                sta addend                               ; low, then high
   329  533e 88                                  dey
   330  533f 20bd22                              jsr indlow_ram1                          ; put (5&6,lowtr) in faster memory
   331                          
   332  5342 852b               umultd           sta addend+1
   333  5344 a910                                lda #16
   334  5346 855f                                sta deccnt
   335  5348 a200                                ldx #0                                   ; clear the accs
   336  534a a000                                ldy #0                                   ; result initially zero
   337                          
   338  534c 8a                 umultc           txa
   339  534d 0a                                  asl                                      ; multiply by two
   340  534e aa                                  tax
   341  534f 98                                  tya
   342  5350 2a                                  rol
   343  5351 a8                                  tay
   344  5352 b3edda                              +lbcs omerr                              ; to much!
   345  5355 0672                                asl curtol
   346  5357 2673                                rol curtol+1
   347  5359 900c                                bcc umlcnt                               ; nothing in this position to multiply
   348  535b 18                                  clc
   349  535c 8a                                  txa
   350  535d 652a                                adc addend
   351  535f aa                                  tax
   352  5360 98                                  tya
   353  5361 652b                                adc addend+1
   354  5363 a8                                  tay
   355  5364 b3dbda                              +lbcs omerr                              ; man, just too much!
   356                          
   357  5367 c65f               umlcnt           dec deccnt                               ; done?
   358  5369 d0e1                                bne umultc                               ; keep it up
   359  536b 60                                  rts                                      ; yes, all done
   360                          
   361                          
   362  536c a50d               fmaptr           lda count
   363  536e 0a                                  asl
   364  536f 6905                                adc #5                                   ; point to entries. ((c) cleared by asl)
   365  5371 6561                                adc lowtr
   366  5373 a462                                ldy lowtr+1
   367  5375 9001                                bcc l130_1
   368  5377 c8                                  iny
   369  5378 855a               l130_1           sta arypnt
   370  537a 845b                                sty arypnt+1
   371  537c 60                                  rts
   372                          

; ******** Source: basic.asm

; ******** Source: command/time.asm
     1                          
     2                          
     3                          
     4                          ; TI$="hh:mm:ss.t" Allows optional colons to delimit parameters and
     5                          ;   allows input to be abbrieviated (eg., TI$="h:mm" or
     6                          ;   even TI$=""), defaulting to "00" for unspecified
     7                          ;   parameters.  24-hour clock (00:00:00.0 to 23:59:59.9).
     8                          ;   901010 F.Bowen
     9                          
    10                          Set_TI_String
    11  537d 206d5b                              jsr frefac                               ; we won't need it
    12  5380 850d                                sta count                                ; save length
    13                          
    14  5382 a000                                ldy #0                                   ; our pointer into TI$ assignment
    15  5384 8487                                sty time                                 ; default time to zero, in case it's not fully specified
    16  5386 8488                                sty time+1
    17  5388 8489                                sty time+2
    18  538a 848a                                sty time+3
    19                          
    20  538c a203                                ldx #3                                   ; parameter pointer (3=hr,2=min,1=sec,0=tenths)
    21  538e 20d453             l131_1           jsr GetTimeDigit                         ; get first digit, convert to BCD
    22  5391 b013                                bcs l131_2                               ; colon or eos
    23  5393 9587                                sta time,x
    24  5395 20d453                              jsr GetTimeDigit                         ; get second digit, convert to BCD
    25  5398 b00c                                bcs l131_2                               ; colon or eos
    26                          
    27  539a 1687                                asl time,x                               ; move first digit to msd
    28  539c 1687                                asl time,x
    29  539e 1687                                asl time,x
    30  53a0 1687                                asl time,x
    31  53a2 1587                                ora time,x                               ; combine with second digit
    32  53a4 9587                                sta time,x                               ; now we have a time element of packed BCD
    33                          
    34  53a6 b587               l131_2           lda time,x
    35  53a8 ddf153                              cmp MaxTimeValues,x                      ; check for parameter too big
    36  53ab b351fe                              +lbcs fcerr                              ; hr>23, min>59, sec>59, tenths>9
    37                          
    38  53ae ca                                  dex                                      ; check if done
    39  53af 3012                                bmi l131_4                               ; yes- all parameters accounted for
    40  53b1 c40d                                cpy count
    41  53b3 b013                                bcs l131_5                               ; yes- end of string
    42                          
    43  53b5 20d522                              jsr indin1_ram1                          ; check for optional colon (or period)   [910103]
    44  53b8 c93a                                cmp #':'
    45  53ba f004                                beq l131_3
    46  53bc c92e                                cmp #'.'
    47  53be d0ce                                bne l131_1                               ; not there
    48  53c0 c8                 l131_3           iny                                      ; it's there- skip over it
    49                          
    50  53c1 80cb                                bra l131_1                               ; loop until done
    51                          
    52                          
    53  53c3 c40d               l131_4           cpy count                                ; done
    54  53c5 93a922                              +lbcc errlen                             ; error if string too long
    55                          
    56  53c8 ab8700             l131_5           ldz time                                 ; tenths  0-9
    57  53cb a588                                lda time+1                               ; seconds 0-59
    58  53cd a689                                ldx time+2                               ; minutes 0-59
    59  53cf a48a                                ldy time+3                               ; hours  0-23
    60  53d1 4cdbff                              jmp _SetTime                             ; Go set time & exit
    61                          
    62                          
    63                          ; Get an ASCII digit, make sure it's in range 0-9 or a colon.
    64                          ; if no digit to get, default to '0'
    65                          ;
    66                          ; exit with .c=0 if okay  (.A contains BCD)
    67                          ;    .c=1 if colon or eos (.A invalid)
    68                          
    69                          GetTimeDigit
    70  53d4 a900                                lda #0                                   ; default to '0'
    71  53d6 c40d                                cpy count
    72  53d8 b014                                bcs l132_1                               ; exit if at end of string (carry set)
    73                          
    74  53da 20d522                              jsr indin1_ram1                          ; else get a character from string
    75  53dd c8                                  iny                                      ; point to next character
    76  53de c92e                                cmp #'.'                                 ; [910103]
    77  53e0 f00c                                beq l132_1                               ; terminator (period) (carry set)
    78  53e2 c930                                cmp #'0'                                 ; check character, only 0-9 allowed
    79  53e4 9318fe                              +lbcc fcerr                              ; too small
    80  53e7 c93a                                cmp #':'
    81  53e9 9003                                bcc l132_1                               ; just right  (carry clear)
    82  53eb d311fe                              +lbne fcerr                              ; too big
    83                          ; falls through if colon (carry set)
    84                          
    85  53ee 290f               l132_1           and #$0f                                 ; make BCD
    86  53f0 60                                  rts
    87                          
    88                          
    89                          
    90                          MaxTimeValues
    91  53f1 10606024                            !text $10,$60,$60,$24                    ; t,s,m,h in packed BCD
    92                          
    93                          
    94                          ; x$=TI$  Return a string of the form "hh:mm:ss.t", including colons.
    95                          
    96                          Get_TI_String
    97  53f5 207054                              jsr ReadSystemClock                      ; get time as packed BCD
    98                          
    99  53f8 a90a                                lda #10                                  ; get string space for 10 characters
   100  53fa 207b5a                              jsr strspa
   101  53fd a8                                  tay                                      ; length
   102  53fe 88                                  dey                                      ; index
   103                          
   104  53ff a587                                lda time                                 ; build TI$ string in 'fbuffr'
   105  5401 0930                                ora #'0'                                 ; (build string backwards, from last chr to first)
   106  5403 a264                                ldx #dsctmp+1
   107  5405 20f022                              jsr sta_far_ram1                         ; put tenths (special case- only 1 digit)
   108  5408 88                                  dey
   109  5409 a92e                                lda #'.'
   110  540b 20f022                              jsr sta_far_ram1                         ; put period (special case)   [910103]
   111  540e 88                                  dey
   112  540f a201                                ldx #1
   113  5411 800a                                bra l133_2
   114                          
   115  5413 da                 l133_1           phx                                      ; element pointer (1=secs, 2=mins, 3=hrs)
   116  5414 a264                                ldx #dsctmp+1
   117  5416 a93a                                lda #':'
   118  5418 20f022                              jsr sta_far_ram1                         ; put colon
   119  541b 88                                  dey
   120  541c fa                                  plx
   121                          
   122  541d b587               l133_2           lda time,x
   123  541f 4b                                  taz
   124  5420 290f                                and #$0f                                 ; do lsd first, since we're working backwards
   125  5422 0930                                ora #'0'
   126  5424 da                                  phx
   127  5425 a264                                ldx #dsctmp+1
   128  5427 20f022                              jsr sta_far_ram1                         ; put lsd
   129  542a 88                                  dey
   130  542b 6b                                  tza                                      ; then do msd
   131  542c 4a                                  lsr
   132  542d 4a                                  lsr
   133  542e 4a                                  lsr
   134  542f 4a                                  lsr
   135  5430 0930                                ora #'0'
   136  5432 20f022                              jsr sta_far_ram1                         ; put msd
   137  5435 fa                                  plx
   138  5436 e8                                  inx                                      ; next packed element
   139  5437 88                                  dey
   140  5438 10d9                                bpl l133_1                               ; loop until done
   141                          
   142  543a a90a                                lda #10                                  ; length
   143  543c 205d5b                              jsr mvdone                               ; update frespc ????
   144  543f 838f06                              +lbra putnew                             ; make descriptor in dsctmp real
   145                          

; ******** Source: basic.asm

; ******** Source: system/time.asm
     1                          ; TI. Convert 24-hour TOD into tenths of seconds.  901010 F.Bowen
     2                          
     3                          Get_TI
     4  5442 207054                              jsr ReadSystemClock                      ; glance at the clock, get time as h:m:s:t
     5  5445 6467                                stz faclo                                ; init accumulator with tenths (0-9, so nothing to convert)
     6  5447 a300                                ldz #0
     7  5449 6466                                stz facmo
     8  544b 6465                                stz facmoh
     9                          
    10  544d a203                                ldx #3                                   ; convert time (BCD) to tenths of seconds (binary) since midnight
    11  544f 207c54             l134_1           jsr TimeMultiply
    12  5452 18                                  clc
    13  5453 6567                                adc faclo
    14  5455 8567                                sta faclo
    15  5457 a52b                                lda product+1
    16  5459 6566                                adc facmo
    17  545b 8566                                sta facmo
    18  545d a52c                                lda product+2
    19  545f 6565                                adc facmoh
    20  5461 8565                                sta facmoh                               ; (can't overflow since 23:59:59:9 -> 863999 ($0D2EFF)
    21  5463 ca                                  dex
    22  5464 d0e9                                bne l134_1                               ; next factor
    23                          
    24  5466 a900                                lda #0                                   ; float value in FAC
    25  5468 8564                                sta facho                                ; zero msb, facov, facsgn
    26  546a a2a0                                ldx #160                                 ; set facov for time
    27  546c 38                                  sec                                      ; normal fac
    28  546d 83760e                              +lbra floatb                             ; do it
    29                          
    30                          
    31                          
    32                          ReadSystemClock
    33  5470 20deff                              jsr _ReadTime                            ; get packed BCD, y=hrs, x=min, a=sec, z=tenths
    34                          ; (assumes system clock was set properly!)
    35  5473 6487                                stz time                                 ; tenths  0-9
    36  5475 8588                                sta time+1                               ; seconds  0-59
    37  5477 8689                                stx time+2                               ; minutes  0-59
    38  5479 848a                                sty time+3                               ; hours  0-59
    39  547b 60                                  rts
    40                          
    41                          
    42                          ; Unsigned Integer Multiply: Time * Factor  -> Tenths_of_Seconds
    43                          ;     A   *  (B,C)  ->      (D,E,F)
    44                          
    45                          TimeMultiply
    46  547c b587                                lda time,x                               ; convert packed BCD to binary
    47  547e 290f                                and #$0f
    48  5480 8564                                sta facho
    49  5482 b587                                lda time,x                               ; 10x = 8x + 2x
    50  5484 29f0                                and #$f0
    51  5486 4a                                  lsr                                      ; msd x 8
    52  5487 9587                                sta time,x
    53  5489 4a                                  lsr
    54  548a 4a                                  lsr                                      ; msd x 2
    55  548b 18                                  clc
    56  548c 6564                                adc facho                                ; lsd
    57  548e 7587                                adc time,x
    58  5490 9587                                sta time,x                               ; can't overflow ($99->153)
    59                          
    60  5492 8a                                  txa                                      ; make a word pointer from byte pointer
    61  5493 0a                                  asl
    62  5494 a8                                  tay
    63  5495 b9b954                              lda TimeFactor-2,y                       ; multiplicand = TimeFactor,y  (2 bytes)
    64  5498 8528                                sta multiplicand                         ; multiplier = Time,x x (1 byte)
    65  549a b9ba54                              lda TimeFactor-1,y                       ; -----------
    66  549d 8529                                sta multiplicand+1
    67  549f a900                                lda #0                                   ; product lo   (3 bytes)
    68  54a1 852b                                sta product+1                            ; mid
    69  54a3 852c                                sta product+2                            ; hi
    70                          
    71  54a5 a010                                ldy #16                                  ; 16-bit multiplicand
    72  54a7 0a                 l135_1           asl
    73  54a8 eb2b00                              row product+1
    74  54ab eb2800                              row multiplicand                         ; multiplier * multiplicand -> product
    75  54ae 9007                                bcc l135_2
    76  54b0 18                                  clc
    77  54b1 7587                                adc time,x
    78  54b3 9002                                bcc l135_2
    79  54b5 e32b                                inw product+1                            ; (does no error check, since using time factors
    80  54b7 88                 l135_2           dey                                      ; in ROM and maximum time multiplier of 59 there
    81  54b8 d0ed                                bne l135_1                               ; is no danger of overflow)
    82                          
    83                          ; sta product
    84  54ba 60                                  rts                                      ; (.X is preserved)
    85                          
    86                          
    87                          TimeFactor
    88  54bb 0a00                                !word 10                                 ; tenths per second  (max    59*10 =    590 ($0024E)
    89  54bd 5802                                !word 600                                ; per minute  (max   59*600 =  35400 ($08A48)
    90  54bf a08c                                !word 36000                              ; per hour    (max 23*36000 = 828000 ($CA260)

; ******** Source: basic.asm

; ******** Source: command/sleep.asm
     1                          
     2                          
     3                          
     4                          ;*******************************************************************************
     5                          ;*
     6                          ;* SLEEP Command - Postpone all activity for a specified number of seconds
     7                          ;*
     8                          ;* Syntax:  SLEEP n
     9                          ;*
    10                          ;* Where n is the number of seconds to remain inactive,
    11                          ;* expressed as a positive value < 65536.
    12                          ;*
    13                          ;*******************************************************************************
    14                          
    15  54c1 208a5d             sleep            jsr getwrd                               ; get argument in (y,a)
    16                          
    17                          ; Multiply # of seconds to sleep by 60.  This will be the number of 'jiffies'
    18                          ; to hibernate.  Store this value in 3 consecutive locations the kernel will
    19                          ; decrement as a 24-bit binary value, and wait for an underflow.
    20                          ;
    21                          ; ldx #0   ;THIS CODE REPLACED    [910730]
    22                          ; php
    23                          ; sei   ;silence, please!
    24                          ; sty _sleep_counter
    25                          ; sta _sleep_counter+1
    26                          ; stx _sleep_counter+2 ;sleep_counter = n
    27                          ;
    28                          ; jsr sleep_times_2 ;sleep_counter = 2n
    29                          ; jsr add_xay_to_sleep ;sleep_counter = 3n
    30                          ; jsr sleep_times_4 ;sleep_counter = 12n
    31                          ;
    32                          ; ldy _sleep_counter
    33                          ; lda _sleep_counter+1
    34                          ; ldx _sleep_counter+2 ;(xay) = 12n
    35                          ;
    36                          ; jsr sleep_times_4 ;sleep_counter = 48n
    37                          ; jsr add_xay_to_sleep ;sleep_counter = 60n !!!!!
    38                          ;
    39                          ; plp
    40                          ;
    41                          ;1$ jsr is_stop_key_down
    42                          ; ldx _sleep_counter+2
    43                          ; inx   ;underflow?
    44                          ; bne 1$   ;no, loop
    45                          ; rts
    46                          ;
    47                          ;
    48                          ;sleep_times_4
    49                          ; jsr sleep_times_2
    50                          ;sleep_times_2
    51                          ; asl _sleep_counter
    52                          ; rol _sleep_counter+1
    53                          ; rol _sleep_counter+2
    54                          ; rts
    55                          ;
    56                          ;add_xay_to_sleep
    57                          ; pha
    58                          ; tya
    59                          ; adc _sleep_counter
    60                          ; sta _sleep_counter
    61                          ; pla
    62                          ; adc _sleep_counter+1
    63                          ; sta _sleep_counter+1
    64                          ; txa
    65                          ; adc _sleep_counter+2
    66                          ; sta _sleep_counter+2
    67                          ; rts
    68                          
    69                          
    70                          ; SLEEP is now based upon the system hardware TOD clock (same one used by TI$).  This
    71                          ; makes it accurate, something it was not when it was based upon the frame rate.
    72                          
    73  54c4 8487                                sty time                                 ; Number of seconds to "sleep"   [910730] new
    74  54c6 8588                                sta time+1
    75                          
    76  54c8 20deff             l136_1           jsr _ReadTime                            ; Get current time
    77  54cb 6489                                stz time+2                               ; tenths
    78  54cd 858a                                sta time+3                               ; seconds
    79                          
    80  54cf 20cc2c             l136_2           jsr is_stop_key_down                     ; Allow user to abort
    81  54d2 20deff                              jsr _ReadTime                            ; Wait for seconds to increment
    82  54d5 c58a                                cmp time+3
    83  54d7 f0f6                                beq l136_2
    84  54d9 858a                                sta time+3
    85                          
    86  54db 20deff             l136_3           jsr _ReadTime                            ; Wait for tenths to increment
    87  54de d489                                cpz time+2
    88  54e0 d0f9                                bne l136_3
    89                          
    90  54e2 c387                                dew time                                 ; Decrement sleep period 1 second
    91  54e4 d0e9                                bne l136_2                               ; Loop until sleep period over
    92                          
    93  54e6 60                                  rts
    94                          

; ******** Source: basic.asm

; ******** Source: command/wait.asm
     1                          
     2                          
     3                          
     4                          ; WAIT<location>,<mask1>[,<mask2>] statement waits until the contents of
     5                          ; <location> is nonzero when XORed with mask2 and then ANDed with mask1.
     6                          ; If mask2 is not present, it is assumed to be zero.
     7                          
     8  54e7 207c5d             wait             jsr getnum                               ; get required mask1
     9  54ea 864b                                stx andmsk
    10  54ec a200                                ldx #0
    11  54ee 208522                              jsr chrgot
    12  54f1 f003                                beq l137_1
    13  54f3 20825d                              jsr combyt                               ; get optional mask2
    14  54f6 864c               l137_1           stx eormsk
    15                          
    16  54f8 db                                  phz
    17  54f9 abd102                              ldz current_bank                         ; set up bank number for fetch
    18  54fc a216                                ldx #poker                               ; ..and address
    19  54fe a000                                ldy #0                                   ; ..and index
    20                          
    21  5500 2cd102             l137_2           bit current_bank
    22  5503 3004                                bmi l137_3                               ; NOMAP?
    23  5505 2074ff                              jsr _lda_far                             ; lda (poker),y
    24  5508 2c                                  !text $2c
    25                          
    26  5509 b116               l137_3           lda (poker),y
    27  550b 454c                                eor eormsk
    28  550d 254b                                and andmsk
    29  550f f0ef                                beq l137_2
    30  5511 fb                                  plz
    31  5512 60                                  rts                                      ; got a nonzero
    32                          

; ******** Source: basic.asm

; ******** Source: function/fre.asm
     1                          
     2                          
     3                          
     4                          ;*****************************************************************************
     5                          ; FRE(n) Function
     6                          ;
     7                          ; Where: n=0 returns amount of free RAM in bank 0. This is the area
     8                          ;  between top of text (TEXT_TOP) and top of RAM (MAX_MEM_0).
     9                          ;
    10                          ;  n=1 returns amount of free ram in bank 1. This is the area
    11                          ;  between top of arrays (STREND) and bottom of strings (FRETOP).
    12                          ;
    13                          ;  n=2 returns the amount (???? presence) of expansion RAM.
    14                          ;
    15                          ;*****************************************************************************
    16                          
    17  5513 206f5d             fre              jsr conint                               ; get integer argument in .x
    18  5516 e001                                cpx #1                                   ; which bank?
    19  5518 f015                                beq l138_1                               ; go do bank one
    20  551a e002                                cpx #2                                   ; go do expansion banks   [910107]
    21  551c f020                                beq l138_2                               ; else it must be bank zero
    22  551e b3defc                              +lbcs fcerr                              ; any other is unpleasant to talk about
    23                          
    24  5521 38                                  sec                                      ; FRE(text_bank)
    25  5522 adcf02                              lda max_mem_0
    26  5525 e582                                sbc text_top
    27  5527 a8                                  tay                                      ; set up result for nosflt
    28  5528 add002                              lda max_mem_0+1
    29  552b e583                                sbc text_top+1
    30  552d 8014                                bra l138_3                               ; assumes text_top < max_mem
    31                          
    32                          
    33  552f 20335c             l138_1           jsr garba2                               ; FRE(var_bank) do garbage collect first
    34  5532 38                                  sec
    35  5533 a535                                lda fretop
    36  5535 e533                                sbc strend
    37  5537 a8                                  tay
    38  5538 a536                                lda fretop+1
    39  553a e534                                sbc strend+1
    40  553c 8005                                bra l138_3
    41                          
    42  553e ac0711             l138_2           ldy _expansion                           ; FRE(expansion banks)    [910107]
    43  5541 a900                                lda #0
    44                          
    45  5543 838203             l138_3           +lbra nosflt                             ; go float the number (y,a)=(lo,hi)
    46                          

; ******** Source: basic.asm

; ******** Source: function/val.asm
     1                          
     2                          
     3                          
     4                          ; The VAL function takes a string and turns it into a number by interpreting
     5                          ; the PETSCII digits etc.  Except for the problem that a terminator must be
     6                          ; supplied by replacing the character beyond the string, VAL is merely a call
     7                          ; to floating point input (FIN).
     8                          
     9  5546 205c5a             val              jsr len1                                 ; get length
    10  5549 f3fe08                              +lbeq zerofc                             ; return 0 if len=0
    11                          
    12                          ; Use text to fp number code by faking a new text poiner
    13                          
    14  554c 18                 val_1            clc                                      ; ///jump table entry.  convert PETSCII to floating point
    15  554d 6524                                adc index1
    16  554f 8572                                sta strng2                               ; add length to index1 and put in strng2
    17  5551 a525                                lda index1+1
    18  5553 6900                                adc #0
    19  5555 8573                                sta strng2+1
    20                          
    21  5557 a000                                ldy #0
    22  5559 a972                                lda #strng2
    23  555b 20d722                              jsr lda_far_ram1                         ; replace character after string with $00 (fake EOL)
    24  555e 48                                  pha                                      ; save old character
    25  555f 98                                  tya                                      ; (.A=0)
    26  5560 a272                                ldx #strng2
    27  5562 20f022                              jsr sta_far_ram1 ;sta (strng2),y         ; ..and put in null
    28  5565 205f64                              jsr fin_chrget_2                         ; get character pointed to and set flags.(sorta like chrgot)
    29  5568 a201                                ldx #1                                   ; flag 'bank 1'
    30  556a 208d63                              jsr fin                                  ; go do evaluation
    31  556d 68                                  pla                                      ; get saved character
    32  556e da                                  phx
    33  556f a272                                ldx #strng2
    34  5571 a000                                ldy #0
    35  5573 20f022                              jsr sta_far_ram1 ;sta (strng2),y         ; restore zeroed-out character
    36  5576 fa                                  plx
    37  5577 60                                  rts
    38                          

; ******** Source: basic.asm

; ******** Source: function/dec.asm
     1                          
     2                          
     3                          
     4                          ; DEC convert a hex string representing a 2-byte integer into decimal.
     5                          
     6  5578 205c5a             dcml             jsr len1                                 ; find length of string
     7  557b 8526                                sta index2                               ; len ret. in a
     8  557d a000                                ldy #0
     9  557f 8427                                sty index2+1                             ; zero char counter
    10  5581 8473                                sty strng2+1                             ; zero out value
    11  5583 8472                                sty strng2
    12                          
    13  5585 c426               l139_1           cpy index2                               ; evaluated all characters?
    14  5587 f034                                beq l139_4                               ; branch if so
    15  5589 20d522                              jsr indin1_ram1                          ; get next character from string
    16  558c c8                                  iny
    17  558d c920                                cmp #' '                                 ; ignore spaces
    18  558f f0f4                                beq l139_1
    19  5591 e627                                inc index2+1
    20  5593 a627                                ldx index2+1
    21  5595 e005                                cpx #5
    22  5597 b02b                                bcs decbad                               ; can't have more than 4 characters
    23                          
    24  5599 c930                                cmp #'0'
    25  559b 9027                                bcc decbad                               ; bad if < 0
    26  559d c93a                                cmp #':'                                 ; '9'+1
    27  559f 900a                                bcc l139_2                               ; ok if  = 0-9
    28  55a1 c941                                cmp #'A'
    29  55a3 901f                                bcc decbad                               ; bad if > 9  and < A
    30  55a5 c947                                cmp #'G'
    31  55a7 b01b                                bcs decbad                               ; bad if > F
    32                          
    33  55a9 e907                                sbc #7                                   ; adjust if A-F  (.c is clr)
    34  55ab e92f               l139_2           sbc #$2f                                 ; adjust to $00..$0f (.c is set)
    35  55ad 0a                                  asl                                      ; shift low nibble to high
    36  55ae 0a                                  asl
    37  55af 0a                                  asl
    38  55b0 0a                                  asl
    39                          
    40  55b1 a204                                ldx #4                                   ; mult. old val. by 16, add new
    41  55b3 0a                 l139_3           asl
    42  55b4 2672                                rol strng2
    43  55b6 2673                                rol strng2+1
    44  55b8 ca                                  dex
    45  55b9 d0f8                                bne l139_3
    46  55bb 80c8                                bra l139_1
    47                          
    48  55bd a472               l139_4           ldy strng2                               ; get lsb of value,
    49  55bf a573                                lda strng2+1                             ; & msb,
    50  55c1 830403                              +lbra nosflt                             ; go float 2 byte unsigned integer
    51                          
    52                          
    53                          decbad
    54  55c4 8338fc                              +lbra fcerr                              ; illegal qty error
    55                          
    56                          ;.end

; ******** Source: basic.asm

; ******** Source: command/peekpoke.asm
     1                          
     2                          
     3                          
     4  55c7 fc1600             peek             phw poker                                ; ..also happens to be LINNUM!   [910911]
     5  55ca 20db4c                              jsr chknum
     6  55cd 208d5d                              jsr getadr
     7  55d0 a000                                ldy #0                                   ; index
     8  55d2 2cd102                              bit current_bank
     9  55d5 300b                                bmi l140_1                               ; NOMAP?
    10                          
    11  55d7 db                                  phz
    12  55d8 abd102                              ldz current_bank                         ; set up bank number for Kernel's fetch
    13  55db a216                                ldx #poker                               ; ..and address
    14  55dd 2074ff                              jsr _lda_far                             ; lda (poker),y
    15  55e0 fb                                  plz
    16  55e1 2c                                  !text $2c
    17                          
    18  55e2 b116               l140_1           lda (poker),y
    19  55e4 a8                                  tay                                      ; get byte into .y
    20  55e5 68                                  pla
    21  55e6 8517                                sta poker+1                              ; restore linnum
    22  55e8 68                                  pla
    23  55e9 8516                                sta poker
    24  55eb 83e502                              +lbra sngflt                             ; float it
    25                          
    26                          
    27  55ee 207c5d             poke             jsr getnum
    28  55f1 8a                 l141_1           txa                                      ; set up value to store for Kernel 'stash' routine
    29  55f2 a000                                ldy #0                                   ; ..and index
    30  55f4 78                                  sei                                      ; to allow poking IRQ vector, etc.  [910612]
    31  55f5 2cd102                              bit current_bank
    32  55f8 300b                                bmi l141_2                               ; (anything >1Meg means NOMAP)
    33                          
    34  55fa db                                  phz
    35  55fb a216                                ldx #poker                               ; ..and address
    36  55fd abd102                              ldz current_bank                         ; ..finally, get the bank number
    37  5600 2077ff                              jsr _sta_far                             ; sta (poker),y
    38  5603 fb                                  plz
    39  5604 2c                                  !text $2c
    40                          
    41  5605 9116               l141_2           sta (poker),y                            ; NoMap
    42                          
    43  5607 208522             l141_3           jsr chrgot                               ; eol?
    44  560a f00a                                beq l141_4                               ; yes
    45  560c e316                                inw poker                                ; no- increment address
    46                          ; lda poker  ; check for segment wrap (FFFF->0000) [910911]
    47                          ; ora poker+1
    48  560e f331d8                              +lbeq omerr                              ; [910916]
    49  5611 202679                              jsr optbyt                               ; & get next [,byte]
    50  5614 b0db                                bcs l141_1
    51                          
    52  5616 58                 l141_4           cli                                      ; [910612]
    53  5617 60                                  rts
    54                          
    55                          
    56                          ;.end

; ******** Source: basic.asm

; ******** Source: function/errstr.asm
     1                          
     2                          
     3  5618 20c162             errd             jsr sign                                 ; get sign
     4  561b 300c                                bmi l142_1                               ; (allow err$(er) when er=-1)
     5  561d 206f5d                              jsr conint                               ; get integer arg in x
     6  5620 ca                                  dex
     7  5621 8a                                  txa                                      ; error # (0 to max-1)
     8  5622 c92a                                cmp #last_error_message                  ; check range
     9  5624 900f                                bcc l142_2                               ; ok
    10  5626 a200                                ldx #0                                   ; too high, return null
    11  5628 2c                                  !text $2c
    12                          
    13  5629 a202               l142_1           ldx #2                                   ; no error, return "ok"    [910911]
    14  562b a96a                                lda #<ok_error_message
    15  562d a029                                ldy #>ok_error_message
    16  562f 8526                                sta index2
    17  5631 8427                                sty index2+1
    18  5633 8013                                bra l142_5                               ; pass it
    19                          
    20  5635 20a92b             l142_2           jsr erstup                               ; look up the error, set up a pointer to it
    21  5638 a0ff                                ldy #$ff                                 ; determine how long it is
    22  563a a200                                ldx #0
    23  563c e8                 l142_3           inx                                      ; count printing characters
    24  563d c8                 l142_4           iny
    25  563e b126                                lda (index2),y                           ; (rom: ind.ok)
    26  5640 3006                                bmi l142_5                               ; msb set means last
    27  5642 c920                                cmp #' '
    28  5644 90f7                                bcc l142_4                               ; don't count non-printers
    29  5646 80f4                                bra l142_3                               ; count all others
    30                          
    31  5648 8a                 l142_5           txa                                      ; message length
    32  5649 207b5a                              jsr strspa                               ; get space
    33  564c aa                                  tax
    34  564d f01d                                beq l142_7                               ; null
    35                          
    36                          ; sta sw_rom_ram1  ;set up string bank????
    37  564f a200                                ldx #0
    38  5651 a0ff                                ldy #$ff
    39  5653 c8                 l142_6           iny                                      ; copy message into memory
    40  5654 b126                                lda (index2),y                           ; (rom: ind.ok)
    41  5656 c920                                cmp #' '
    42  5658 90f9                                bcc l142_6                               ; skip non-printers
    43                          
    44  565a 48                                  pha
    45  565b 297f                                and #$7f
    46  565d 5a                                  phy                                      ; swap x&y
    47  565e da                                  phx
    48  565f 7a                                  ply
    49  5660 a264                                ldx #dsctmp+1
    50  5662 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y to RAM1
    51  5665 5a                                  phy                                      ; swap x&y
    52  5666 fa                                  plx
    53  5667 7a                                  ply
    54  5668 e8                                  inx
    55  5669 68                                  pla                                      ; test if msb was set
    56  566a 10e7                                bpl l142_6
    57                          
    58  566c 835903             l142_7           +lbra chrd1                              ; pla,pla,jmp putnew
    59                          
    60                          

; ******** Source: basic.asm

; ******** Source: function/hexstr.asm
     1                          
     2                          
     3                          
     4  566f 20db4c             hexd             jsr chknum
     5  5672 fc1600                              phw poker                                ; save linnum    [910911]
     6  5675 208d5d                              jsr getadr                               ; 2 byte val in (poker)
     7  5678 a904                                lda #4
     8  567a 207b5a                              jsr strspa
     9  567d a000                                ldy #0
    10  567f a517                                lda poker+1
    11  5681 209256                              jsr hexit
    12  5684 a516                                lda poker
    13  5686 209256                              jsr hexit
    14  5689 68                                  pla                                      ; restore linnum
    15  568a 8517                                sta poker+1
    16  568c 68                                  pla
    17  568d 8516                                sta poker
    18  568f 833603                              +lbra chrd1                              ; pla,pla,jmp putnew
    19                          
    20  5692 48                 hexit            pha
    21  5693 4a                                  lsr
    22  5694 4a                                  lsr
    23  5695 4a                                  lsr
    24  5696 4a                                  lsr
    25  5697 209b56                              jsr dohex
    26  569a 68                                  pla
    27                          
    28  569b 290f               dohex            and #$0f
    29  569d c90a                                cmp #$0a
    30  569f 9002                                bcc l143_1
    31  56a1 6906                                adc #6
    32  56a3 6930               l143_1           adc #'0'
    33  56a5 da                                  phx
    34  56a6 a264                                ldx #dsctmp+1
    35  56a8 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
    36  56ab fa                                  plx
    37  56ac c8                                  iny
    38  56ad 60                                  rts
    39                          

; ******** Source: basic.asm

; ******** Source: function/joy.asm
     1                          
     2                          
     3                          
     4                          ;*************************************************************
     5                          ; JOY (n)  -- Return joystick status
     6                          ;
     7                          ; where: n =  1  return position of joystick-1
     8                          ;       2  return position of joystick-2
     9                          ;
    10                          ; result:      0  no direction, no button
    11                          ;       1-8    direction (see below), no button
    12                          ;       128 no direction, button
    13                          ;       129-136 direction & button  128 + [1...8]
    14                          ;
    15                          ; button--->  128        1
    16                          ;       8     2
    17                          ; stick--->  7           3
    18                          ;       6     4
    19                          ;          5
    20                          ;
    21                          ;*************************************************************
    22                          
    23  56ae 206f5d             joy              jsr conint                               ; get 1 byte arg in x
    24  56b1 ca                                  dex
    25  56b2 e002                                cpx #2                                   ; make sure arg. is valid
    26  56b4 b348fb                              +lbcs fcerr                              ; >1, error
    27                          
    28  56b7 8a                                  txa
    29  56b8 4901                                eor #1                                   ; invert to match legends on case
    30  56ba aa                                  tax
    31  56bb 08                                  php                                      ; save status
    32                          
    33                          ; jsr put_io_in_map
    34  56bc 78                                  sei                                      ; disable IRQ to inhibit kybd
    35  56bd ad00dc                              lda d1pra
    36  56c0 48                                  pha                                      ; save kybd output lines
    37  56c1 a0ff                                ldy #$ff
    38  56c3 8c00dc                              sty d1pra                                ; set to not read any kybd inputs
    39                          
    40  56c6 bd00dc             l144_1           lda d1pra,x                              ; read joystick values
    41  56c9 dd00dc                              cmp d1pra,x                              ; debounce
    42  56cc d0f8                                bne l144_1
    43                          
    44  56ce aa                                  tax                                      ; save joystick values
    45  56cf 68                                  pla
    46  56d0 8d00dc                              sta d1pra                                ; reset kybd output lines
    47  56d3 8a                                  txa                                      ; restore joystick values
    48  56d4 28                                  plp                                      ; restore status
    49  56d5 290f                                and #$0f                                 ; test which direction
    50  56d7 a8                                  tay
    51  56d8 b9e356                              lda joytab-5,y                           ; get direction indicator
    52  56db a8                                  tay                                      ; save direction : 0-8
    53  56dc 8a                                  txa                                      ; restore joystick value
    54  56dd 2910                                and #$10                                 ; test if button triggered
    55  56df d004                                bne l144_2                               ; skip if not
    56  56e1 98                                  tya
    57  56e2 0980                                ora #$80                                 ; show trigger depressed
    58  56e4 a8                                  tay
    59  56e5 83eb01             l144_2           +lbra sngflt                             ; float 1 byte arg in y.
    60                          
    61  56e8 0402030006080700...joytab           !text 4,2,3,0,6,8,7,0,5,1,0
    62                          
    63                          ;.end

; ******** Source: basic.asm

; ******** Source: function/potpen.asm
     1                          
     2                          
     3                          ;***********************************************************
     4                          ; POT(n)  --  Read paddles
     5                          ;
     6                          ;    n = 1 : paddle-1 - X-position
     7                          ;  2 : paddle-1 - Y-position
     8                          ;  3 : paddle-2 - X-position
     9                          ;  4 : paddle-2 - Y-position
    10                          ;
    11                          ;     result >= 256 --  trigger set
    12                          ;***********************************************************
    13                          
    14  56f3 20554e             pot              jsr chkcls                               ; look for closing paren
    15  56f6 206f5d                              jsr conint                               ; get 1-byte arg in .x
    16  56f9 ca                                  dex
    17  56fa e004                                cpx #4
    18  56fc b300fb                              +lbcs fcerr                              ; value error
    19                          
    20                          ; jsr put_io_in_map
    21  56ff 8a                                  txa                                      ; convert arg (0-3) into paddle enables
    22  5700 4a                                  lsr                                      ; .c= X/Y   .a= port 1/2
    23  5701 aa                                  tax
    24  5702 bd6b79                              lda sbits+6,x
    25  5705 aa                                  tax                                      ; (CIA paddle port, $40/$80)
    26  5706 a900                                lda #0
    27  5708 2a                                  rol
    28  5709 a8                                  tay                                      ; (SID x/y offset,  $00/$01)
    29                          
    30  570a 8e6e11                              stx pot_temp_1                           ; save which port
    31  570d 08                                  php                                      ; save IRQ enable while we
    32  570e 78                                  sei                                      ; disable IRQ to inhibit keyboard scan
    33  570f ad00dc                              lda d1pra
    34  5712 48                                  pha                                      ; save kybd output lines
    35  5713 8e00dc                              stx d1pra                                ; turn on correct paddle
    36                          
    37  5716 205d48                              jsr go_slow
    38  5719 a200                                ldx #0
    39  571b e8                 l145_1           inx                                      ; delay to let pot be read by SID
    40  571c d0fd                                bne l145_1
    41                          
    42  571e b919d4             l145_2           lda sid1+25,y                            ; read pot
    43  5721 d919d4                              cmp sid1+25,y                            ; debounce
    44  5724 d0f8                                bne l145_2
    45  5726 8d6f11                              sta pot_temp_2                           ; save pot value
    46  5729 205748                              jsr go_fast
    47                          
    48  572c a200                                ldx #0                                   ; set index to d1pra
    49  572e 2c6e11                              bit pot_temp_1                           ; test if pot-0,1 or pot-2,3
    50  5731 3001                                bmi l145_3                               ; skip if pot 2,3
    51  5733 e8                                  inx                                      ; index to d1prb
    52  5734 a904               l145_3           lda #04                                  ; use joy line-2
    53  5736 88                                  dey                                      ; test if pot-x or pot-y
    54  5737 3001                                bmi l145_4                               ; skip if pot-x
    55  5739 0a                                  asl                                      ; use joy line-3
    56  573a a0ff               l145_4           ldy #$ff
    57  573c 8c00dc                              sty d1pra                                ; disable keybd inputs
    58  573f c8                                  iny                                      ; set to zero for no trigger
    59  5740 3d00dc                              and d1pra,x                              ; test if trigger set
    60  5743 d001                                bne l145_5                               ; skip if not trigger
    61  5745 c8                                  iny                                      ; return value >255 for trigger
    62  5746 68                 l145_5           pla
    63  5747 8d00dc                              sta d1pra                                ; restore keybd lines
    64  574a 98                                  tya
    65  574b ac6f11                              ldy pot_temp_2                           ; restore pot value
    66  574e 28                                  plp                                      ; restore status
    67  574f 837601                              +lbra nosflt                             ; output 2-byte result
    68                          
    69                          
    70                          ;*************************************************************
    71                          ;  LPEN(n)  --  Read light pen
    72                          ;
    73                          ; n = 0 x position
    74                          ;     1 y position
    75                          ;*************************************************************
    76                          
    77  5752 20554e             lpen             jsr chkcls                               ; look for closing parens
    78  5755 206f5d                              jsr conint                               ; get 1 byte arg in .X
    79                          ; dex   ;convert [1-2] to [0-1]
    80  5758 e002                                cpx #2
    81  575a b3a2fa                              +lbcs fcerr                              ; bad value
    82                          
    83  575d a900                                lda #0
    84  575f 78                                  sei
    85  5760 bce802                              ldy lightpen_xpos,x                      ; get latched light pen value (a=msb, y=lsb)
    86  5763 9de802                              sta lightpen_xpos,x                      ; reset to zero (????preserve last latched position)
    87  5766 58                                  cli
    88  5767 e000                                cpx #0
    89  5769 d006                                bne l146_1                               ; done if y position
    90  576b 98                                  tya
    91  576c 0a                                  asl                                      ; else multiply *2 to get correct x position
    92  576d a8                                  tay                                      ; lsb
    93  576e a900                                lda #0
    94  5770 2a                                  rol                                      ; msb
    95  5771 835401             l146_1           +lbra nosflt                             ; float it (y,a)
    96                          
    97                          

; ******** Source: basic.asm

; ******** Source: function/pointer.asm
     1                          
     2                          
     3                          
     4                          ;******************************************************************
     5                          ;
     6                          ; POINTER(var_name) - Return address of descriptor for var_name
     7                          ;
     8                          ;******************************************************************
     9                          
    10  5774 208322             pointer          jsr chrget                               ; skip over escape token
    11  5777 20584e                              jsr chkopn                               ; test for open paren
    12  577a 200250                              jsr isletc                               ; test if character follows parens
    13  577d 93cbd6                              +lbcc snerr                              ; ...syntax error if not.
    14  5780 207c4f                              jsr ptrget                               ; look for this varname in table
    15                          
    16                          pointer_ret      =*-1
    17  5783 aa                                  tax
    18  5784 5a                                  phy
    19  5785 20554e                              jsr chkcls                               ; look for closing paren
    20  5788 8a                                  txa
    21  5789 a8                                  tay
    22  578a 68                                  pla
    23  578b c902                                cmp #>zero                               ; is this a dummy pointer?
    24  578d d003                                bne l147_1
    25  578f a900                                lda #0                                   ; if so, return 0
    26  5791 a8                                  tay
    27  5792 833301             l147_1           +lbra nosflt
    28                          

; ******** Source: basic.asm

; ******** Source: operator/xor.asm
     1                          
     2                          
     3                          
     4                          ;**************************************************************
     5                          ;*
     6                          ;*   XOR - Exclusive-or two 16 bit arguments
     7                          ;*
     8                          ;* Syntax : XOR (arg1, arg2)
     9                          ;*
    10                          ;**************************************************************
    11                          
    12  5795 fc1600             xor              phw poker                                ; protect the poker value (could be in use)  [910911]
    13  5798 20db4c                              jsr chknum
    14  579b 208d5d                              jsr getadr                               ; get first arg
    15  579e 48                                  pha                                      ; save MSB
    16  579f 5a                                  phy                                      ; save LSB
    17                          
    18  57a0 20875d                              jsr comwrd                               ; check for comma, get word
    19  57a3 20554e                              jsr chkcls                               ; check for closing parens
    20                          
    21  57a6 68                                  pla
    22  57a7 4516                                eor poker                                ; xor LSB (comwrd left a copy of its arg in POKER)
    23  57a9 a8                                  tay
    24  57aa 68                                  pla
    25  57ab 4517                                eor poker+1                              ; ..and MSB
    26  57ad 20c758                              jsr nosflt                               ; ..and go float 'em
    27                          
    28  57b0 68                                  pla
    29  57b1 8517                                sta poker+1
    30  57b3 68                                  pla
    31  57b4 8516                                sta poker
    32  57b6 60                                  rts
    33                          

; ******** Source: basic.asm

; ******** Source: operator/mod.asm
     1                          
     2                          
     3                          
     4                          ;**************************************************************
     5                          ;*
     6                          ;* MOD  -  Modulus of a number
     7                          ;*
     8                          ;* Syntax : MOD (number, range)
     9                          ;*      910402 FAB
    10                          ;**************************************************************
    11                          
    12                          ; Calculate   MOD = NUMBER-RANGE*INT(NUMBER/RANGE)
    13                          
    14  57b7 20db4c             mod              jsr chknum                               ; 1st arg in FAC1 (number)
    15  57ba 20734d                              jsr pushf1                               ; save two copies of it for later
    16  57bd 20734d                              jsr pushf1
    17  57c0 205b4e                              jsr chkcom                               ; check for comma
    18  57c3 20d84c                              jsr frmnum                               ; 2nd arg in FAC1 (range)
    19  57c6 20554e                              jsr chkcls                               ; check for closing paren
    20                          
    21  57c9 20a362                              jsr movaf                                ; save range in FAC2
    22  57cc 20964d                              jsr pullf1                               ; get back number in FAC1
    23  57cf a205                                ldx #5                                   ; swap FAC1 and FAC2
    24  57d1 b563               l148_1           lda facexp,x
    25  57d3 b46a                                ldy argexp,x
    26  57d5 956a                                sta argexp,x
    27  57d7 9463                                sty facexp,x
    28  57d9 ca                                  dex
    29  57da 10f5                                bpl l148_1
    30  57dc 20734d                              jsr pushf1                               ; save one copy of range for later
    31                          
    32  57df 207861                              jsr fdivt_c65                            ; number/range
    33  57e2 206363                              jsr int                                  ; INT(number/range)
    34  57e5 20a362                              jsr movaf                                ; round & move to FAC2
    35  57e8 20964d                              jsr pullf1                               ; retrieve arg2 (range)
    36  57eb 206360                              jsr fmultt_c65                           ; range*INT(number/range)
    37  57ee 20fc65                              jsr negop                                ; -range*INT(number/range)
    38  57f1 20a362                              jsr movaf                                ; move to FAC2
    39  57f4 20964d                              jsr pullf1                               ; retrieve arg1 (number)
    40  57f7 83230c                              +lbra faddt_c65                          ; number-range*INT(number/range)
    41                          
    42                          
    43                          ;.end

; ******** Source: basic.asm

; ******** Source: function/rwindow.asm
     1                          
     2                          
     3                          ;******************************************************************************
     4                          ;
     5                          ; RWINDOW  - Returns information about the current console display environment.
     6                          ;
     7                          ;   Syntax : RWINDOW (n)
     8                          ;
     9                          ;   Where: n=0 : number of lines in the current window
    10                          ;   =1 : number of rows in the current window
    11                          ;   =2 : returns either 40 or 80, depending on the
    12                          ;   current console device
    13                          ;
    14                          ;******************************************************************************
    15                          
    16  57fa 20554e             rwindow          jsr chkcls
    17  57fd 206f5d                              jsr conint
    18  5800 e002                                cpx #2
    19  5802 f015                                beq l149_2                               ; return current console
    20  5804 b3f8f9                              +lbcs fcerr
    21                          
    22  5807 e000                                cpx #0
    23  5809 d007                                bne l149_1
    24                          
    25  580b a5e4                                lda _screen_bottom
    26  580d 38                                  sec
    27  580e e5e5                                sbc _screen_top
    28  5810 800d                                bra l149_3                               ; always
    29                          
    30  5812 a5e7               l149_1           lda _screen_right
    31  5814 38                                  sec
    32  5815 e5e6                                sbc _screen_left
    33  5817 8006                                bra l149_3                               ; always
    34                          
    35                          
    36  5819 a950               l149_2           lda #80                                  ; assume 80 col
    37  581b 7fd701                              bbr7 _mode,l149_3
    38  581e 4a                                  lsr
    39  581f a8                 l149_3           tay
    40  5820 83b000                              +lbra sngflt                             ; float 1 byte arg in .Y
    41                          

; ******** Source: basic.asm

; ******** Source: function/rnd.asm
     1                          
     2                          
     3                          
     4                          ;    Random Number Function  RND(x)
     5                          ;
     6                          ;  x=0 ==> generate a random number based on hardware clock & noisy POT lines
     7                          ;  x<0 ==> seed a reproducable, pseudo-random number generator
     8                          ;  x>0 ==> generate a reproducable pseudo-random # based upon seed value above
     9                          
    10                          
    11  5823 20c162             rnd              jsr sign                                 ; get sign into .a
    12                          
    13  5826 3042               rnd_0            bmi l150_2                               ; /// entry from jump table
    14  5828 d02b                                bne l150_1
    15                          
    16                          
    17                          ; Get value from hardware
    18                          
    19  582a 205d48                              jsr go_slow                              ; Use CIA#1 timer B & SID#2 pot X & Y for seeds  [910314]
    20  582d ad39d4                              lda sid2+25                              ; go slow to read POT-X
    21  5830 0a                                  asl
    22  5831 0a                                  asl
    23  5832 0a                                  asl
    24  5833 0a                                  asl
    25  5834 0d3ad4                              ora sid2+26                              ; and POT-Y
    26  5837 4d12d0                              eor vic+18                               ; ???? should be okay- we're in Slow mode
    27  583a 8565                                sta facmoh
    28  583c 205748                              jsr go_fast                              ; restore speed
    29  583f ad06dc                              lda d1pra+6                              ; timer B is free-running
    30  5842 8566                                sta facmo
    31  5844 ad07dc                              lda d1pra+7
    32  5847 8567                                sta faclo
    33  5849 4564                                eor facho
    34  584b 6565                                adc facmoh
    35  584d 4566                                eor facmo
    36  584f 6567                                adc faclo
    37  5851 8564                                sta facho
    38  5853 8025                                bra l150_3
    39                          
    40                          
    41  5855 a974               l150_1           lda #<rndx                               ; get last one into FAC
    42  5857 a011                                ldy #>rndx
    43  5859 200e62                              jsr movfm
    44  585c a990                                lda #<rmulc
    45  585e a058                                ldy #>rmulc                              ; FAC was zero.  restore last one
    46  5860 204860                              jsr rommlt                               ; multiply by random constant
    47  5863 a995                                lda #<raddc
    48  5865 a058                                ldy #>raddc
    49  5867 205160                              jsr romadd                               ; add random constant
    50                          
    51  586a a667               l150_2           ldx faclo
    52  586c a564                                lda facho
    53  586e 8567                                sta faclo
    54  5870 8664                                stx facho                                ; reverse hi and lo
    55  5872 a665                                ldx facmoh
    56  5874 a566                                lda facmo
    57  5876 8565                                sta facmoh
    58  5878 8666                                stx facmo
    59                          
    60  587a a900               l150_3           lda #0                                   ; strnex.  make number positive
    61  587c 8568                                sta facsgn
    62  587e a563                                lda facexp                               ; put exp where it will
    63  5880 8571                                sta facov                                ; be shifted in by normal
    64  5882 a980                                lda #$80
    65  5884 8563                                sta facexp                               ; make result between 0 and 1
    66  5886 20295e                              jsr normal                               ; normalize
    67  5889 a274                                ldx #<rndx
    68  588b a011                                ldy #>rndx
    69  588d 83ab09                              +lbra movmf                              ; put new one into memory
    70                          
    71  5890 9835447a00         rmulc            !text 152,53,68,122,0
    72  5895 6828b14600         raddc            !text 104,40,177,70,0
    73                          
    74                          ;.end

; ******** Source: basic.asm

; ******** Source: math/ext1.asm
     1                          
     2                          
     3  589a 9080000000         n32768           !text $90,$80,0,0,0
     4                          
     5                          
     6  589f 20b458             flpint           jsr ayint
     7  58a2 a566                                lda facmo
     8  58a4 a467                                ldy  faclo
     9  58a6 60                                  rts
    10                          
    11                          
    12  58a7 208322             intidx           jsr chrget
    13  58aa 20ef4c                              jsr frmevl                               ; get a number
    14                          
    15                          
    16  58ad 20db4c             posint           jsr chknum
    17  58b0 a568                                lda facsgn
    18  58b2 300d                                bmi nonono                               ; if negative, blow him out
    19                          
    20                          
    21  58b4 a563               ayint            lda facexp
    22  58b6 c990                                cmp #$90                                 ; FAC > 32767?
    23  58b8 900a                                bcc qintgo
    24  58ba a99a                                lda #<n32768                             ; get address of -32768
    25  58bc a058                                ldy #>n32768
    26  58be 20f162                              jsr fcomp                                ; see if FAC=((x))
    27                          
    28  58c1 d33bf9             nonono           +lbne fcerr                              ; no, FAC is too big
    29  58c4 836a0a             qintgo           +lbra qint                               ; go shove it
    30                          
    31                          
    32                          ; Float an unsigned double byte integer
    33                          ; Entry:  MSB in (a), LSB in (y)
    34                          
    35  58c7 20d758             nosflt           jsr stoint
    36  58ca 38                                  sec                                      ; sign is positive
    37  58cb 83120a                              +lbra floatc
    38                          
    39                          
    40                          
    41  58ce 38                 pos              sec
    42  58cf 20f0ff                              jsr _plot                                ; get tab pos in .y
    43                          
    44  58d2 a900               sngflt           lda #0
    45  58d4 8369f5                              +lbra givayf                             ; float it
    46                          
    47                          
    48                          
    49  58d7 a200               stoint           ldx #0                                   ; move int to fac & compute proper exponents
    50  58d9 860f                                stx valtyp
    51  58db 8564                                sta facho
    52  58dd 8465                                sty facho+1
    53  58df a290                                ldx #$90
    54  58e1 60                 storts           rts
    55                          
    56                          
    57                          
    58                          ; See if we are in direct mode, and complain if so.
    59                          
    60  58e2 ff7efc             errdir           bbs7 runmod,storts                       ; goto error if not in run mode
    61                          
    62  58e5 a215                                ldx #errid                               ; input direct error code
    63  58e7 2c                                  !text $2c
    64                          
    65  58e8 a21b               errguf           ldx #erruf
    66  58ea 8363d5                              +lbra error
    67                          
    68                          
    69  58ed 7f7ef1             errind           bbr7 runmod,storts                       ; goto error if not in direct mode
    70  58f0 a222                                ldx #erroid
    71  58f2 835bd5                              +lbra error
    72                          
    73                          ;.end

; ******** Source: basic.asm

; ******** Source: function/userdef.asm
     1                          
     2                          
     3                          ; User Defined Function Code
     4                          ;
     5                          ; Note only single arguments are allowed to functions, and functions must
     6                          ; be of the single line form:
     7                          ;
     8                          ;  DEF FNA(x)=x~2 + x-2
     9                          ;
    10                          ; No strings may be involved with these functions.
    11                          ;
    12                          ; Idea: create a simple variable entry whose first character has the MSB set.
    13                          ; The value will be:
    14                          ;
    15                          ;  A text pointer to the formula
    16                          ;  A pointer to the argument variable
    17                          
    18  58f5 202259             def              jsr getfnm                               ; get a pointer to the function
    19  58f8 20e258                              jsr errdir
    20  58fb 20584e                              jsr chkopn                               ; must have a (
    21  58fe a980                                lda #$80
    22  5900 8512                                sta subflg                               ; prohibit subscripted & integer variables
    23  5902 207c4f                              jsr ptrget                               ; get pointer to argument
    24  5905 20db4c                              jsr chknum                               ; is it a number?
    25  5908 20554e                              jsr chkcls                               ; must have )
    26  590b a9b2                                lda #equal_token                         ; followed by =
    27  590d 205d4e                              jsr synchr
    28  5910 48                                  pha
    29  5911 a54a                                lda varpnt+1
    30  5913 48                                  pha
    31  5914 a549                                lda varpnt
    32  5916 48                                  pha
    33  5917 a53e                                lda txtptr+1
    34  5919 48                                  pha
    35  591a a53d                                lda txtptr
    36  591c 48                                  pha
    37  591d 204835                              jsr data
    38  5920 8073                                bra deffin
    39                          
    40                          
    41                          ; Subroutine to get a pointer to a function name
    42                          
    43  5922 a9a5               getfnm           lda #fn_token                            ; must start with fn
    44  5924 205d4e                              jsr synchr
    45  5927 0980                                ora #$80                                 ; put function bit on
    46  5929 8512                                sta subflg                               ; (disallows array & integer variables)
    47  592b 20834f                              jsr ptrgt2                               ; get pointer to function or create anew
    48  592e 8550                                sta defpnt
    49  5930 8451                                sty defpnt+1
    50  5932 83a7f3                              +lbra chknum                             ; make sure it's not a string, and return
    51                          
    52                          
    53  5935 202259             fndoer           jsr getfnm                               ; get the function's name
    54  5938 a551                                lda defpnt+1
    55  593a 48                                  pha
    56  593b a550                                lda defpnt
    57  593d 48                                  pha
    58  593e 204f4e                              jsr parchk                               ; evaluate parameter
    59  5941 20db4c                              jsr chknum
    60  5944 68                                  pla
    61  5945 8550                                sta defpnt
    62  5947 68                                  pla
    63  5948 8551                                sta defpnt+1
    64  594a a002                                ldy #2
    65  594c 209922                              jsr inddef                               ; get pointer to the variable
    66  594f 8549                                sta varpnt                               ; save variable pointer
    67  5951 aa                                  tax
    68  5952 c8                                  iny
    69  5953 209922                              jsr inddef
    70  5956 f090                                beq errguf
    71  5958 854a                                sta varpnt+1
    72  595a c8                                  iny                                      ; since def uses only 4
    73                          
    74                          
    75  595b a949               defstf           lda #varpnt
    76  595d 20d722                              jsr lda_far_ram1
    77  5960 48                                  pha                                      ; push it all on the stack, since we might be recursing
    78  5961 88                                  dey
    79  5962 10f7                                bpl defstf
    80  5964 a44a                                ldy varpnt+1
    81                          
    82  5966 206262                              jsr movmf_ram1                           ; put current FAC into our argument variable
    83  5969 a53e                                lda txtptr+1                             ; save variable pointer
    84  596b 48                                  pha
    85  596c a53d                                lda txtptr
    86  596e 48                                  pha
    87  596f 209922                              jsr inddef                               ; get pointer to function
    88  5972 853d                                sta txtptr
    89  5974 c8                                  iny
    90  5975 209922                              jsr inddef
    91  5978 853e                                sta txtptr+1
    92  597a a54a                                lda varpnt+1                             ; save variable pointer
    93  597c 48                                  pha
    94  597d a549                                lda varpnt
    95  597f 48                                  pha
    96  5980 20d84c                              jsr frmnum                               ; evaluate variable, and check numeric
    97  5983 68                                  pla
    98  5984 8550                                sta defpnt
    99  5986 68                                  pla
   100  5987 8551                                sta defpnt+1
   101  5989 208522                              jsr chrgot
   102  598c d3bcd4                              +lbne snerr                              ; it didn't terminate, syntax error
   103                          
   104  598f 68                                  pla                                      ; restore text pointer
   105  5990 853d                                sta txtptr
   106  5992 68                                  pla
   107  5993 853e                                sta txtptr+1
   108                          
   109  5995 a000               deffin           ldy #0
   110  5997 68                 l151_1           pla                                      ; get old arg value off stack,
   111  5998 da                                  phx
   112  5999 a250                                ldx #defpnt
   113  599b 20f022                              jsr sta_far_ram1 ;sta (defpnt),y         ; and put it back in variable
   114  599e fa                                  plx
   115  599f c8                                  iny
   116  59a0 c005                                cpy #5
   117  59a2 d0f3                                bne l151_1
   118  59a4 60                                  rts
   119                          

; ******** Source: basic.asm

; ******** Source: function/stringmisc.asm
     1                          
     2                          
     3                          
     4                          
     5                          ; The STR$() function takes a number and gives a string with
     6                          ; the characters the output of the number would have given.
     7                          
     8  59a5 20db4c             strd             jsr chknum                               ; arg has to be numeric
     9  59a8 a000                                ldy #0
    10  59aa 209164                              jsr foutc                                ; do its output
    11  59ad 68                                  pla
    12  59ae 68                                  pla
    13                          
    14  59af a9ff               timstr           lda #<lofbuf
    15  59b1 a000                                ldy #>lofbuf
    16  59b3 83d000                              +lbra strlit
    17                          
    18                          
    19                          ; CHR$() creates a string which contains as its only character the PETSCII
    20                          ; equivalent of the integer argument (#) which must be < 256.
    21                          
    22  59b6 206f5d             chrd             jsr conint                               ; get integer in range
    23  59b9 da                                  phx
    24  59ba a901                                lda #1                                   ; one-character string
    25  59bc 207b5a                              jsr strspa                               ; get space for string
    26  59bf a000                                ldy #0
    27  59c1 68                                  pla
    28                          ; phx   ;set up string bank
    29  59c2 a264                                ldx #dsctmp+1
    30  59c4 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
    31                          ; plx
    32                          
    33  59c7 68                 chrd1            pla                                      ; get rid of "chknum" return address
    34  59c8 68                                  pla
    35  59c9 830501                              +lbra putnew                             ; setup FAC to point to desc
    36                          
    37                          
    38                          ; The following is the LEFT$($,#) function.  It takes the leftmost # characters
    39                          ; of the string.  If # > len of the string, it returns the whole string.
    40                          
    41  59cc 203e5a             leftd            jsr pream                                ; test parameters
    42  59cf 48                                  pha                                      ; # arg
    43  59d0 20a122                              jsr inddpt                               ; string len
    44  59d3 8578                                sta syntmp
    45  59d5 68                                  pla
    46  59d6 c578                                cmp syntmp
    47  59d8 98                                  tya                                      ; that's all there is to LEFT$
    48                          
    49  59d9 9005               rleft            bcc l152_1
    50  59db 20a122                              jsr inddpt
    51  59de aa                                  tax                                      ; put length into x
    52  59df 98                                  tya                                      ; zero (a), the offset
    53  59e0 48                 l152_1           pha                                      ; save offset
    54  59e1 8a                 rleft2           txa
    55  59e2 48                 rleft3           pha                                      ; save length
    56  59e3 207b5a                              jsr strspa                               ; get space
    57  59e6 a552                                lda dscpnt
    58  59e8 a453                                ldy dscpnt+1
    59  59ea 20715b                              jsr fretmp
    60  59ed 7a                                  ply
    61  59ee 68                                  pla
    62  59ef 18                                  clc
    63  59f0 6524                                adc index                                ; compute where to copy
    64  59f2 8524                                sta index
    65  59f4 9002                                bcc l153_1
    66  59f6 e625                                inc index+1
    67  59f8 98                 l153_1           tya
    68  59f9 204a5b                              jsr movdo                                ; go move it
    69  59fc 83d200                              +lbra putnew
    70                          
    71                          
    72                          
    73  59ff 203e5a             rightd           jsr pream
    74  5a02 48                                  pha
    75  5a03 20a122                              jsr inddpt
    76  5a06 8578                                sta syntmp
    77  5a08 68                                  pla
    78  5a09 18                                  clc                                      ; (length des'd)-(length)-1
    79  5a0a e578                                sbc syntmp
    80  5a0c 49ff                                eor #$ff                                 ; negate
    81  5a0e 80c9                                bra rleft
    82                          
    83                          
    84                          ; MID$($,#) returns string with chars from # position onward. If # > LEN($)
    85                          ; then return null string.  MID($,#,#) returns string with characters from
    86                          ; # position for #2 characters.  If #2 goes past end of string return as much
    87                          ; as possible.
    88                          
    89  5a10 a9ff               midd             lda #255                                 ; default
    90  5a12 8567                                sta faclo                                ; save for later compare
    91  5a14 208522                              jsr chrgot                               ; get current character
    92  5a17 c929                                cmp #')'                                 ; is it a right paren )?
    93  5a19 f003                                beq l154_1                               ; no third paren.
    94                          ; jsr chkcom  ;must have comma
    95                          ; jsr getbyt  ;get the length into "faclo"
    96  5a1b 20825d                              jsr combyt                               ; [910820]
    97                          
    98  5a1e 203e5a             l154_1           jsr pream                                ; check it out
    99  5a21 f3dbf7                              +lbeq fcerr                              ; illegal qty error
   100  5a24 ca                                  dex                                      ; compute offset
   101  5a25 da                                  phx
   102  5a26 da                                  phx                                      ; preserve a while (2 copies)
   103  5a27 a200                                ldx #0
   104  5a29 20a122                              jsr inddpt                               ; get length of what's left
   105  5a2c 8578                                sta syntmp
   106  5a2e 68                                  pla
   107  5a2f 18                                  clc
   108  5a30 e578                                sbc syntmp
   109  5a32 b0ad                                bcs rleft2                               ; give null string
   110  5a34 49ff                                eor #$ff                                 ; in sub c was 0 so just complement
   111  5a36 c567                                cmp faclo                                ; greater than what's desired
   112  5a38 90a8                                bcc rleft3                               ; no, just copy that much
   113  5a3a a567                                lda faclo                                ; get length of what's desired
   114  5a3c b0a4                                bcs rleft3                               ; copy it
   115                          
   116                          
   117                          
   118                          
   119                          ; Common routine used by RIGHT$, LEFT$, MID$, for parameter chk and setup.
   120                          
   121  5a3e 20554e             pream            jsr chkcls                               ; param list should end
   122  5a41 7a                                  ply
   123  5a42 68                                  pla
   124  5a43 8557                                sta jmper+1                              ; get return address
   125  5a45 68                                  pla                                      ; get rid of fingo's jsr ret addr
   126  5a46 68                                  pla
   127  5a47 fa                                  plx                                      ; get length
   128  5a48 68                                  pla
   129  5a49 8552                                sta dscpnt
   130  5a4b 68                                  pla
   131  5a4c 8553                                sta dscpnt+1
   132  5a4e a557                                lda jmper+1
   133  5a50 48                                  pha
   134  5a51 5a                                  phy
   135  5a52 a000                                ldy #0
   136  5a54 8a                                  txa
   137  5a55 60                                  rts
   138                          
   139                          
   140                          
   141                          ; The function LEN$() returns the length of the string passed as an argument.
   142                          
   143  5a56 630400             len              bsr len1
   144  5a59 8377fe                              +lbra sngflt
   145                          
   146  5a5c 206a5b             len1             jsr frestr                               ; free up string
   147  5a5f a200                                ldx #0
   148  5a61 860f                                stx valtyp                               ; force numeric
   149  5a63 a8                                  tay                                      ; set condition codes
   150  5a64 60                                  rts                                      ; done
   151                          
   152                          
   153                          
   154                          
   155                          
   156                          ; The following is the ASC$() function.  It returns an integer which is the
   157                          ; decimal equivalent of the PETSCII string argument.
   158                          
   159  5a65 205c5a             asc              jsr len1
   160  5a68 f006                                beq l155_1                               ; it was null (zero length)
   161  5a6a a000                                ldy #0
   162  5a6c 20d522                              jsr indin1_ram1                          ; get 1st character
   163  5a6f a8                                  tay
   164  5a70 8360fe             l155_1           +lbra sngflt
   165                          
   166                          ;.end
   167                          
   168                          
   169                          
   170                          
   171                          
   172                          ; STRINI gets string space for the creation of a string and creates
   173                          ; a descriptor for it in DSCTMP.
   174                          
   175                          strini
   176  5a73 a666                                ldx facmo                                ; get facmo to store in dscpnt
   177  5a75 a467                                ldy facmo+1
   178  5a77 8652                                stx dscpnt                               ; retain the descriptor pointer
   179  5a79 8453                                sty dscpnt+1
   180                          
   181  5a7b 20dd5b             strspa           jsr getspa                               ; get string space
   182  5a7e 8664                                stx dsctmp+1                             ; save location
   183  5a80 8465                                sty dsctmp+2
   184  5a82 8563                                sta dsctmp                               ; save length
   185  5a84 60                                  rts                                      ; done
   186                          
   187                          
   188                          ; STRLT2 takes the string literal whose first character is pointed to by
   189                          ; (xreg)+1 and builds a descriptor for it.  The descriptor is initially
   190                          ; built in DSCTMP, but PUTNEW transfers it into a temporary and leaves a
   191                          ; pointer to the temporary in FACMO & FACLO.  The characters other than the
   192                          ; zero that terminates the string should be set up in CHARAC and ENDCHR.
   193                          ; If the terminator is a quote, the quote is skipped over.  Leading quotes
   194                          ; should be skipped before call.  On return, the character after the string
   195                          ; literal is pointed to by (strng2).
   196                          
   197                          
   198  5a85 a222               strlit           ldx #'"'                                 ; assume string ends on quote
   199  5a87 860a                                stx charac
   200  5a89 860b                                stx endchr
   201                          
   202  5a8b 8570               strlt2           sta strng1                               ; save pointer to string
   203  5a8d 8471                                sty strng1+1
   204  5a8f 8564                                sta dsctmp+1                             ; in case no strcpy
   205  5a91 8465                                sty dsctmp+2
   206                          
   207  5a93 a0ff                                ldy #255                                 ; initialize character count
   208  5a95 c8                 strget           iny
   209  5a96 20b122                              jsr indst1                               ; get character
   210  5a99 f00c                                beq l156_2                               ; if zero
   211  5a9b c50a                                cmp charac                               ; this terminator?
   212  5a9d f004                                beq l156_1                               ; yes
   213  5a9f c50b                                cmp endchr
   214  5aa1 d0f2                                bne strget                               ; look further
   215                          
   216  5aa3 c922               l156_1           cmp #'"'                                 ; strfin.  quote?
   217  5aa5 f001                                beq l156_3
   218                          
   219  5aa7 18                 l156_2           clc
   220  5aa8 8463               l156_3           sty dsctmp                               ; no, back up. retain count
   221  5aaa 98                                  tya
   222  5aab 6570                                adc strng1                               ; wishing to set (txtptr)
   223  5aad 8572                                sta strng2
   224  5aaf a671                                ldx strng1+1
   225  5ab1 9001                                bcc l156_4
   226  5ab3 e8                                  inx
   227  5ab4 8673               l156_4           stx strng2+1
   228  5ab6 98                                  tya
   229                          
   230                          
   231                          strlit_1                                                  ; //// entry from SPRSAV
   232  5ab7 20735a                              jsr strini
   233  5aba a8                                  tay
   234  5abb f013                                beq putnew                               ; length=0, don't bother copying
   235  5abd 48                                  pha                                      ; save length
   236  5abe da                                  phx
   237  5abf a237                                ldx #frespc
   238  5ac1 88                 l157_1           dey
   239  5ac2 20b122                              jsr indst1                               ; lda (strng1),y in bank 0
   240  5ac5 20f022                              jsr sta_far_ram1                         ; sta (frespc),y in bank 1
   241  5ac8 98                                  tya
   242  5ac9 d0f6                                bne l157_1
   243  5acb fa                                  plx
   244  5acc 68                                  pla                                      ; restore length
   245  5acd 205d5b                              jsr mvdone                               ; finish up by updating frespc
   246                          
   247                          
   248                          ; Some string function is returning a result in DSCTMP.  Set up a temp
   249                          ; descriptor with DSCTMP in it.  Put a pointer to the descriptor in FACMO&LO
   250                          ; and flag the result as a string type.
   251                          
   252  5ad0 a618               putnew           ldx temppt                               ; pointer to first free temp
   253  5ad2 e024                                cpx #tempst+strsiz+strsiz+strsiz
   254  5ad4 f314f2                              +lbeq sterr                              ; string temporary error
   255                          
   256  5ad7 a563                                lda dsctmp                               ; length
   257  5ad9 9500                                sta 0,x
   258  5adb a564                                lda dsctmp+1                             ; pointer to string lo
   259  5add 9501                                sta 1,x
   260  5adf a565                                lda dsctmp+2                             ; hi
   261  5ae1 9502                                sta 2,x
   262                          
   263  5ae3 a000                                ldy #0                                   ; pointer to temp. descriptor
   264  5ae5 8666                                stx facmo                                ; lo
   265  5ae7 8467                                sty facmo+1                              ; hi
   266  5ae9 8471                                sty facov
   267  5aeb 88                                  dey                                      ; ($ff)
   268  5aec 840f                                sty valtyp                               ; type is string
   269  5aee 8619                                stx lastpt                               ; set pointer to last-used temp
   270                          
   271  5af0 e8                                  inx
   272  5af1 e8                                  inx
   273  5af2 e8                                  inx                                      ; point further
   274  5af3 8618                                stx temppt                               ; save pointer to next temp, if any
   275  5af5 60                                  rts                                      ; all done
   276                          
   277                          
   278                          ; The following routine concatenates two strings.  At this point, the FAC
   279                          ; contains the first one and (txtptr) points to the + sign.
   280                          
   281  5af6 a567               cat              lda faclo                                ; push high order onto stack
   282  5af8 48                                  pha
   283  5af9 a566                                lda facmo                                ; and the low
   284  5afb 48                                  pha
   285  5afc 20e24d                              jsr eval                                 ; can come back here since operator is known
   286  5aff 20dd4c                              jsr chkstr                               ; must be string
   287  5b02 68                                  pla
   288  5b03 8570                                sta strng1                               ; get high order of old descriptor
   289  5b05 68                                  pla
   290  5b06 8571                                sta strng1+1
   291  5b08 a000                                ldy #0
   292  5b0a 20b522                              jsr indst1_ram1                          ; get length of old string
   293  5b0d 8578                                sta syntmp
   294  5b0f 20a922                              jsr indfmo
   295  5b12 18                                  clc
   296  5b13 6578                                adc syntmp
   297  5b15 b3591b                              +lbcs errlen                             ; result >255, error "long string"
   298                          
   299  5b18 20735a                              jsr strini                               ; sizeok.  initialize string
   300  5b1b 20355b                              jsr movins                               ; move it
   301  5b1e a552                                lda dscpnt                               ; get pointer to second
   302  5b20 a453                                ldy dscpnt+1
   303  5b22 20715b                              jsr fretmp                               ; free it
   304  5b25 204a5b                              jsr movdo                                ; move second string
   305  5b28 a570                                lda strng1
   306  5b2a a471                                ldy strng1+1
   307  5b2c 20715b                              jsr fretmp
   308  5b2f 20d05a                              jsr putnew
   309  5b32 83cef1                              +lbra tstop                              ; "cat" reenters frmevl from tstop
   310                          
   311                          
   312  5b35 a000               movins           ldy #0                                   ; get address of string
   313  5b37 20b522                              jsr indst1_ram1
   314  5b3a 48                                  pha
   315  5b3b c8                                  iny
   316  5b3c 20b522                              jsr indst1_ram1
   317  5b3f aa                                  tax
   318  5b40 c8                                  iny
   319  5b41 20b522                              jsr indst1_ram1
   320  5b44 a8                                  tay
   321  5b45 68                                  pla
   322                          
   323  5b46 8624               movstr           stx index                                ; adr in (x,y), len in a
   324  5b48 8425                                sty index+1
   325                          
   326  5b4a a8                 movdo            tay
   327  5b4b f010                                beq mvdone
   328                          
   329  5b4d 48                                  pha
   330  5b4e da                                  phx
   331  5b4f a237                                ldx #frespc
   332  5b51 88                 l158_1           dey
   333  5b52 20d522                              jsr indin1_ram1
   334  5b55 20f022                              jsr sta_far_ram1                         ; sta (frespc),y
   335  5b58 98                                  tya
   336  5b59 d0f6                                bne l158_1
   337  5b5b fa                                  plx
   338  5b5c 68                                  pla
   339                          
   340  5b5d 18                 mvdone           clc                                      ; update frespc pointer
   341  5b5e 6537                                adc frespc
   342  5b60 8537                                sta frespc
   343  5b62 9002                                bcc l159_1
   344  5b64 e638                                inc frespc+1
   345  5b66 60                 l159_1           rts
   346                          

; ******** Source: basic.asm

; ******** Source: string/manager.asm
     1                          ; FRETMP is passed a string descriptor pntr in (a,y).  A check is made to see
     2                          ; if the string descriptor points to the last temporary descriptor allocated by
     3                          ; putnew.  If so, the temporary is freed up by the updating of (temppt).  If a
     4                          ; string is freed up, a further check sees if it was the last one created and if
     5                          ; so, (fretop) is updated to reflect the fact that the space is no longer in use.
     6                          ; The address of the actual string is returned in (x,y) and its length in (a).
     7                          
     8  5b67 20ef4c             frmstr           jsr frmevl
     9                          
    10  5b6a 20dd4c             frestr           jsr chkstr                               ; make sure it's a string
    11  5b6d a566               frefac           lda facmo                                ; free up string pointed to by FAC
    12  5b6f a467                                ldy facmo+1
    13  5b71 8524               fretmp           sta index                                ; get length for later
    14  5b73 8425                                sty index+1
    15  5b75 20cc5b                              jsr fretms                               ; check desc. if last
    16  5b78 d03c                                bne l160_3                               ; one then scratch it
    17  5b7a 206737                              jsr stradj                               ; index points to link
    18  5b7d 9037                                bcc l160_3                               ; literal no fix
    19                          
    20  5b7f da                                  phx                                      ; .x=length
    21  5b80 88                                  dey                                      ; .y=1
    22  5b81 a224                                ldx #index
    23  5b83 a9ff                                lda #$ff                                 ; flag string as garbage
    24  5b85 20f022                              jsr sta_far_ram1                         ; sta (index),y
    25  5b88 68                                  pla
    26  5b89 48                                  pha                                      ; get length, but leave copy on stack
    27  5b8a 88                                  dey
    28  5b8b a224                                ldx #index
    29  5b8d 20f022                              jsr sta_far_ram1 ;sta (index),y          ; put in length
    30                          
    31  5b90 49ff                                eor #$ff                                 ; put index back
    32  5b92 38                                  sec                                      ; to first byte
    33  5b93 6524                                adc index
    34  5b95 a425                                ldy index+1
    35  5b97 b001                                bcs l160_1
    36  5b99 88                                  dey
    37  5b9a 8524               l160_1           sta index
    38  5b9c 8425                                sty index+1
    39                          
    40  5b9e aa                                  tax                                      ; lo into x
    41  5b9f 68                                  pla                                      ; pull length from stack
    42  5ba0 c436                                cpy fretop+1                             ; = to fretop?
    43  5ba2 d038                                bne frerts
    44  5ba4 e435                                cpx fretop
    45  5ba6 d034                                bne frerts
    46                          
    47                          
    48                          ; The string was the last one put into string space.  Save garbage
    49                          ; collection some time by freeing up. (length + 2)
    50                          
    51  5ba8 48                                  pha                                      ; save length on stack
    52  5ba9 38                                  sec                                      ; plus one
    53  5baa 6535                                adc fretop
    54  5bac 8535                                sta fretop
    55  5bae 9002                                bcc l160_2
    56  5bb0 e636                                inc fretop+1
    57  5bb2 e335               l160_2           inw fretop                               ; + one more
    58  5bb4 68                                  pla                                      ; pull length off stack
    59  5bb5 60                                  rts
    60                          
    61                          
    62  5bb6 a000               l160_3           ldy #0                                   ; set up x,y,a and index
    63  5bb8 20d522                              jsr indin1_ram1                          ; length
    64  5bbb 48                                  pha                                      ; on stack
    65  5bbc c8                                  iny
    66  5bbd 20d522                              jsr indin1_ram1                          ; pointer lo
    67  5bc0 aa                                  tax
    68  5bc1 c8                                  iny
    69  5bc2 20d522                              jsr indin1_ram1                          ; pointer hi
    70  5bc5 a8                                  tay
    71  5bc6 8624                                stx index
    72  5bc8 8425                                sty index+1
    73  5bca 68                                  pla                                      ; get back length
    74  5bcb 60                                  rts
    75                          
    76                          
    77                          
    78  5bcc c41a               fretms           cpy lastpt+1                             ; last entry to temp?
    79  5bce d00c                                bne frerts
    80  5bd0 c519                                cmp lastpt
    81  5bd2 d008                                bne frerts
    82  5bd4 8518                                sta temppt
    83  5bd6 e903                                sbc #strsiz                              ; point to lst one
    84  5bd8 8519                                sta lastpt                               ; update temp pointer
    85  5bda a000                                ldy #0                                   ; also clears zflg so we do rest of fretmp
    86  5bdc 60                 frerts           rts                                      ; all done
    87                          

; ******** Source: basic.asm

; ******** Source: string/garbage.asm
     1                          
     2                          
     3                          
     4                          ;  Get space for a string, perhaps forcing garbage collection.
     5                          ;
     6                          ;  Entry:  a = # of chars
     7                          ;  Exit:   (x,y) pointer to space, otherwise
     8                          ;          blows off to 'out of string space' error
     9                          ;          (also preserves .a and sets frespc= y,x = -> at space.)
    10                          
    11                          
    12  5bdd 4611               getspa           lsr garbfl                               ; signal no garbage collection yet
    13                          
    14  5bdf aa                 tryag2           tax                                      ; save in x also
    15  5be0 f042                                beq getrts                               ; length of 0 no go...
    16  5be2 48                                  pha                                      ; save a (length) on stack
    17  5be3 a535                                lda fretop                               ; lo byte
    18  5be5 38                                  sec                                      ; for subtract
    19  5be6 e902                                sbc #2                                   ; minus 2 (link bytes)
    20  5be8 a436                                ldy fretop+1
    21  5bea b001                                bcs l161_1
    22  5bec 88                                  dey
    23  5bed 8524               l161_1           sta index1                               ; save for later
    24  5bef 8425                                sty index1+1
    25  5bf1 8a                                  txa
    26  5bf2 49ff                                eor #$ff
    27  5bf4 38                                  sec
    28  5bf5 6524                                adc index1
    29  5bf7 b001                                bcs l161_2
    30  5bf9 88                                  dey
    31  5bfa c434               l161_2           cpy strend+1
    32  5bfc 9027                                bcc garbag
    33  5bfe d004                                bne strfre
    34  5c00 c533                                cmp strend
    35  5c02 9021                                bcc garbag                               ; clean up
    36                          
    37                          
    38  5c04 8537               strfre           sta frespc
    39  5c06 8438                                sty frespc+1
    40  5c08 a001                                ldy #1                                   ; flag string as garbage
    41  5c0a a9ff                                lda #$ff
    42  5c0c da                                  phx                                      ; set up string bank
    43  5c0d a224                                ldx #index1
    44  5c0f 20f022                              jsr sta_far_ram1 ;sta (index1),y         ; flag
    45  5c12 fa                                  plx
    46  5c13 88                                  dey
    47  5c14 68                                  pla                                      ; length
    48  5c15 da                                  phx                                      ; set up string bank
    49  5c16 a224                                ldx #index1
    50  5c18 20f022                              jsr sta_far_ram1 ;sta (index1),y         ; length
    51  5c1b fa                                  plx
    52  5c1c a637                                ldx frespc
    53  5c1e a438                                ldy frespc+1
    54  5c20 8635                                stx fretop
    55  5c22 8436                                sty fretop+1                             ; save new (fretop)
    56  5c24 60                 getrts           rts
    57                          
    58                          
    59  5c25 a511               garbag           lda garbfl
    60  5c27 3318d2                              +lbmi omerr                              ; if out of memory
    61  5c2a 20335c                              jsr garba2
    62  5c2d 38                                  sec
    63  5c2e 6611                                ror garbfl
    64  5c30 68                                  pla                                      ; get back string length
    65  5c31 80ac                                bra tryag2                               ; always branches
    66                          
    67                          
    68                          
    69                          ; Routine looks for and squashes out any unused string space it finds, thus
    70                          ; returning the space for future use by the string routines.  GARBA2 is called
    71                          ; only when BASIC needs space or the FRE() function is used.
    72                          
    73                          
    74  5c33 a618               garba2           ldx temppt                               ; ptr to temp. strings
    75  5c35 e01b               l162_1           cpx #tempst                              ; any out there?
    76  5c37 f016                                beq l162_2                               ; none
    77  5c39 20505d                              jsr slr1                                 ; setup ptr (tempf2) to temp. string's bkptr
    78  5c3c f0f7                                beq l162_1                               ; (skip if null string!)
    79  5c3e 8a                                  txa                                      ; .x = lsb of ptr to descriptor
    80  5c3f da                                  phx                                      ; set up string bank
    81  5c40 a25e                                ldx #tempf2
    82  5c42 a000                                ldy #0
    83  5c44 20f022                              jsr sta_far_ram1 ;(tempf2),y             ; place backpointer on string to temp. descr
    84  5c47 98                                  tya                                      ; .a = msb of ptr (0)
    85  5c48 c8                                  iny
    86  5c49 20f022                              jsr sta_far_ram1                         ; (tempf2),y
    87  5c4c fa                                  plx
    88  5c4d 80e6                                bra l162_1                               ; always
    89                          
    90                          
    91  5c4f a000               l162_2           ldy #0                                   ; set up flag
    92  5c51 845a                                sty highds
    93  5c53 a639                                ldx max_mem_1
    94  5c55 a43a                                ldy max_mem_1+1
    95  5c57 8661                                stx grbtop                               ; set both pointers
    96  5c59 8650                                stx grbpnt
    97  5c5b 8637                                stx frespc
    98  5c5d 8462                                sty grbtop+1
    99  5c5f 8451                                sty grbpnt+1
   100  5c61 8438                                sty frespc+1
   101  5c63 8a                                  txa
   102                          
   103                          
   104                          ; do while (grbpnt <= fretop)
   105                          
   106  5c64 20de5c             gloop            jsr chkgrb                               ; check garbage string
   107  5c67 d00c                                bne l163_2                               ; if not garbage
   108                          
   109  5c69 88                 l163_1           dey                                      ; back up to length
   110  5c6a 20b922                              jsr indgrb
   111  5c6d 20325d                              jsr movpnt                               ; move grbpnt to next
   112  5c70 38                                  sec
   113  5c71 665a                                ror highds                               ; indicate garbage string found
   114  5c73 80ef                                bra gloop                                ; always
   115                          
   116  5c75 245a               l163_2           bit highds
   117  5c77 1052                                bpl l163_6                               ; if garbage string not found
   118  5c79 a200                                ldx #0
   119  5c7b 865a                                stx highds                               ; clear indicator
   120                          
   121  5c7d a902                                lda #2                                   ; skip pointers past
   122                          
   123                          ; Move a string over garbage
   124                          
   125  5c7f da                 l163_3           phx
   126  5c80 a261                                ldx #grbtop
   127  5c82 a001                                ldy #1                                   ; move the link bytes
   128  5c84 20b922                              jsr indgrb
   129  5c87 20f022                              jsr sta_far_ram1                         ; sta (grbtop),y
   130  5c8a 88                                  dey
   131  5c8b 20b922                              jsr indgrb
   132  5c8e 20f022                              jsr sta_far_ram1                         ; sta (grbtop),y
   133  5c91 fa                                  plx
   134                          
   135  5c92 20d522                              jsr indin1_ram1
   136  5c95 aa                                  tax
   137  5c96 20415d                              jsr movtop                               ; move top pointer
   138  5c99 8537                                sta frespc                               ; save in frespc
   139  5c9b 8438                                sty frespc+1
   140  5c9d 8a                                  txa
   141  5c9e 20325d                              jsr movpnt                               ; move grbpnt
   142  5ca1 8a                                  txa                                      ; put length-1 in .y
   143  5ca2 a8                                  tay
   144                          
   145  5ca3 88                 l163_4           dey
   146  5ca4 20b922                              jsr indgrb
   147  5ca7 da                                  phx
   148  5ca8 a261                                ldx #grbtop
   149  5caa 20f022                              jsr sta_far_ram1                         ; sta (grbtop),y
   150  5cad fa                                  plx
   151  5cae ca                                  dex
   152  5caf d0f2                                bne l163_4
   153                          
   154  5cb1 a002                                ldy #2                                   ; fix the descriptor
   155  5cb3 da                                  phx
   156  5cb4 a224                                ldx #index1
   157  5cb6 b96000             l163_5           lda grbtop-1,y
   158  5cb9 20f022                              jsr sta_far_ram1                         ; sta (index1),y
   159  5cbc 88                                  dey
   160  5cbd d0f7                                bne l163_5
   161  5cbf fa                                  plx
   162                          
   163  5cc0 a550                                lda grbpnt                               ; check pointer
   164  5cc2 a451                                ldy grbpnt+1
   165  5cc4 20de5c                              jsr chkgrb                               ; check garbage string
   166  5cc7 f0a0                                beq l163_1                               ; if garbage found
   167  5cc9 d0b4                                bne l163_3                               ; always
   168                          
   169  5ccb a000               l163_6           ldy #0                                   ; skip over good strings
   170  5ccd 20d522                              jsr indin1_ram1
   171  5cd0 aa                                  tax
   172  5cd1 20415d                              jsr movtop
   173  5cd4 8537                                sta frespc
   174  5cd6 8438                                sty frespc+1
   175  5cd8 8a                                  txa
   176  5cd9 20325d                              jsr movpnt
   177  5cdc 8086                                bra gloop

; ******** Source: basic.asm

; ******** Source: string/garbage/utils.asm
     1                          
     2                          ; Subroutines used for garbage collection.
     3                          ;
     4                          ;  Compare for (y,a) = fretop.
     5                          ; Entry  (y,a) = address of current string descriptor.
     6                          ; Exits to caller if (y,a) = fretop, else z flag set if garbage string.
     7                          ;      z flag clear if not garbage string.
     8                          ; In either case pointers are setup for next loop and string movement.
     9                          ; If carry clear (y,a) <= fretop
    10                          
    11                          
    12  5cde c436               chkgrb           cpy fretop+1                             ; end of strings?
    13  5ce0 9029                                bcc l164_5
    14  5ce2 d006                                bne l164_1                               ; if not equal
    15  5ce4 c535                                cmp fretop
    16  5ce6 f023                                beq l164_5
    17  5ce8 9021                                bcc l164_5
    18                          
    19  5cea 245a               l164_1           bit highds                               ; check flag
    20  5cec 3005                                bmi l164_2                               ; if empty string found
    21  5cee a902                                lda #2                                   ; skip pointers past
    22  5cf0 20415d                              jsr movtop                               ; move top pointer
    23                          
    24  5cf3 a902               l164_2           lda #2                                   ; skip pointers past
    25  5cf5 20325d                              jsr movpnt                               ; move pointers
    26  5cf8 a001                                ldy #1
    27  5cfa 20b922                              jsr indgrb                               ; garbage?
    28  5cfd c9ff                                cmp #$ff
    29  5cff f009                                beq l164_4                               ; yes
    30                          
    31  5d01 20b922             l164_3           jsr indgrb                               ; to link bytes
    32  5d04 992400                              sta index1,y
    33  5d07 88                                  dey
    34  5d08 10f7                                bpl l164_3                               ; if two bytes not moved
    35  5d0a 60                 l164_4           rts
    36                          
    37                          
    38  5d0b a618               l164_5           ldx temppt                               ; ptr to temp. strings
    39                          
    40  5d0d e01b               l164_6           cpx #tempst                              ; any out there?
    41  5d0f f016                                beq l164_7                               ; no
    42  5d11 20505d                              jsr slr1                                 ; setup ptr (tempf2) to temp. string's bkptr.
    43  5d14 f0f7                                beq l164_6                               ; (skip if null string!)
    44  5d16 da                                  phx
    45  5d17 a25e                                ldx #tempf2
    46  5d19 a000                                ldy #0                                   ; .a = string length
    47  5d1b 20f022                              jsr sta_far_ram1 ;sta (tempf2),y         ; remove backpointer built at garba2
    48  5d1e c8                                  iny
    49  5d1f a9ff                                lda #$ff
    50  5d21 20f022                              jsr sta_far_ram1 ;sta (tempf2),y         ; and mark as garbage
    51  5d24 fa                                  plx
    52  5d25 80e6                                bra l164_6                               ; always
    53                          
    54  5d27 68                 l164_7           pla                                      ; throw away return address
    55  5d28 68                                  pla
    56  5d29 a537                                lda frespc                               ; fix fretop and frespc
    57  5d2b a438                                ldy frespc+1
    58  5d2d 8535                                sta fretop
    59  5d2f 8436                                sty fretop+1
    60  5d31 60                                  rts
    61                          
    62                          
    63  5d32 49ff               movpnt           eor #$ff                                 ; comp and add
    64  5d34 38                                  sec
    65  5d35 6550                                adc grbpnt
    66  5d37 a451                                ldy grbpnt+1
    67  5d39 b001                                bcs l165_1
    68  5d3b 88                                  dey
    69  5d3c 8550               l165_1           sta grbpnt
    70  5d3e 8451                                sty grbpnt+1
    71  5d40 60                                  rts
    72                          
    73                          
    74                          
    75  5d41 49ff               movtop           eor #$ff                                 ; comp and add
    76  5d43 38                                  sec
    77  5d44 6561                                adc grbtop
    78  5d46 a462                                ldy grbtop+1
    79  5d48 b001                                bcs l166_1
    80  5d4a 88                                  dey
    81  5d4b 8561               l166_1           sta grbtop
    82  5d4d 8462                                sty grbtop+1
    83  5d4f 60                                  rts
    84                          
    85                          
    86                          
    87  5d50 ca                 slr1             dex                                      ; .x = ptr to temp. string descriptor
    88  5d51 b500                                lda 0,x                                  ; msb of ptr to string
    89  5d53 855f                                sta tempf2+1
    90  5d55 ca                                  dex
    91  5d56 b500                                lda 0,x                                  ; lsb of ptr to string
    92  5d58 855e                                sta tempf2
    93  5d5a ca                                  dex
    94  5d5b b500                                lda 0,x                                  ; string length
    95  5d5d 48                                  pha                                      ; save for later test
    96  5d5e 18                                  clc
    97  5d5f 655e                                adc tempf2                               ; want ptr to string's backpointer
    98  5d61 855e                                sta tempf2
    99  5d63 9002                                bcc l167_1
   100  5d65 e65f                                inc tempf2+1
   101  5d67 68                 l167_1           pla   ;.a=len & set z flag               ; .x=next desc. ptr
   102  5d68 60                                  rts
   103                          

; ******** Source: basic.asm

; ******** Source: math/ext2.asm
     1                          
     2                          
     3                          
     4  5d69 208322             gtbytc           jsr chrget
     5                          
     6  5d6c 20d84c             getbyt           jsr frmnum                               ; read formula into FAC
     7                          
     8  5d6f 20ad58             conint           jsr posint                               ; convert the FAC to a single byte int
     9  5d72 a666                                ldx facmo
    10  5d74 d388f4                              +lbne fcerr                              ; result must be <= 255
    11  5d77 a667                                ldx faclo
    12  5d79 4c8522                              jmp chrgot                               ; set condition codes on terminator
    13                          
    14                          
    15                          getnum                                                    ; get 2-byte value in y,a: check for a comma, get 1 byte val in x
    16  5d7c 20d84c                              jsr frmnum                               ; get address
    17  5d7f 208d5d                              jsr getadr                               ; get that location
    18                          
    19                          combyt                                                    ; check for a comma, get a 1 byte value in x
    20  5d82 205b4e                              jsr chkcom                               ; check for comma
    21  5d85 80e5                                bra getbyt                               ; get something to store and return
    22                          
    23                          
    24  5d87 205b4e             comwrd           jsr chkcom
    25                          
    26  5d8a 20d84c             getwrd           jsr frmnum                               ; get an unsigned 2-byte value in y,a
    27                          
    28  5d8d a568               getadr           lda facsgn                               ; for this entry, value can't be < 0
    29  5d8f 336df4                              +lbmi fcerr                              ; function call error
    30                          
    31                          getsad                                                    ; get a signed 2-byte value in (y,a), ///entry from sprcor
    32  5d92 a563                                lda facexp                               ; examine exponent
    33  5d94 c991                                cmp #145
    34  5d96 b366f4                              +lbcs fcerr                              ; function call error
    35  5d99 203063                              jsr qint                                 ; integerize it
    36  5d9c a566                                lda facmo
    37  5d9e a467                                ldy facmo+1
    38  5da0 8416                                sty poker
    39  5da2 8517                                sta poker+1
    40  5da4 60                                  rts                                      ; it's all done
    41                          

; ******** Source: basic.asm

; ******** Source: math/ext3.asm
     1                          
     2                          
     3                          
     4                          ; Floating Point Math Package configuration:
     5                          ;
     6                          ; Throughout the math package the floating point format is as follows:
     7                          ;
     8                          ; the sign of the first bit of the mantissa.
     9                          ; the mantissa is 24 bits long.
    10                          ; the binary point is to the left of the msb.
    11                          ; number = mantissa * 2 ~ exponent.
    12                          ; the mantissa is positive with a 1 assumed to be where the sign bit is.
    13                          ; the sign of the exponent is the first bit of the exponent.
    14                          ; the exponent is stored in excess $80, i.e., with a bias of +$80.
    15                          ; so, the exponent is a signed 8 bit number with $80 added to it.
    16                          ; an exponent of zero means the number is zero.
    17                          ; the other bytes may not be assumed to be zero.
    18                          ; to keep the same number in the fac while shifting,
    19                          ; to shift right, exp:=exp+1.
    20                          ; to shift left,  exp:=exp-1.
    21                          ;
    22                          ; In memory the number looks like this:
    23                          ; the exponent as a signed number +$80.
    24                          ; the sign bit in 7, bits 2-8 of mantissa are bits 6-0.
    25                          ;  remember bit 1 of mantissa is always a one.
    26                          ; bits 9-16 of the mantissa.
    27                          ; bits 17-24 of the mantisa.
    28                          ;
    29                          ; Arithmetic routine calling conventions:
    30                          ;
    31                          ;   For one-argument functions:
    32                          ; the argument is in the fac.
    33                          ; the result is left in the fac.
    34                          ;   For two-argument operations:
    35                          ; the first argument is in arg (argexp,ho,mo,lo and argsgn).
    36                          ;       the second argument is in the fac.
    37                          ; the result is left in the fac.
    38                          ;
    39                          ; The "t" entry points to the two argument operations have both arguments setup
    40                          ; in the respective registers. Before calling arg may have been popped off the
    41                          ; stack and into arg, for example. The other entry point assumes (xreg) points
    42                          ; to the argument somewhere in memory. it is unpacked into arg by "conupk".
    43                          ;
    44                          ; On the stack, the sgn is pushed on first, the lo,mo,ho, and finally exp.
    45                          ; Note all things are kept unpacked in arg, fac and on the stack.
    46                          ;
    47                          ; It is only when something is stored away that it is packed to four bytes,
    48                          ; the unpacked format has a sn byte reflecting the sign of the ho turned on.
    49                          ; The exp is the same as stored format. This is done for speed of operation.
    50                          
    51                          
    52  5da5 20f760             fsub             jsr conupk
    53                          
    54  5da8 a568               fsubt            lda facsgn
    55  5daa 49ff                                eor #$ff                                 ; complement it
    56  5dac 8568                                sta facsgn
    57  5dae 456f                                eor argsgn                               ; complement arisgn
    58  5db0 8570                                sta arisgn
    59  5db2 a563                                lda facexp                               ; set codes on facexp
    60  5db4 8008                                bra faddt                                ; (y)=argexp
    61                          
    62  5db6 20e75e             fadd5            jsr shiftr                               ; do a long shift
    63  5db9 903b                                bcc fadd4                                ; continue with addition
    64                          
    65  5dbb 20f760             fadd             jsr conupk
    66  5dbe f3d304             faddt            +lbeq movfa                              ; if fac=0, result is in arg
    67  5dc1 a671                                ldx facov
    68  5dc3 8658                                stx oldov
    69  5dc5 a26a                                ldx #argexp                              ; default is shift argument
    70  5dc7 a56a                                lda argexp                               ; if arg=0, fac is result
    71                          
    72  5dc9 a8                 faddc            tay                                      ; also copy (a) into (y)
    73  5dca f38300                              +lbeq zerrts                             ; return
    74  5dcd 38                                  sec
    75  5dce e563                                sbc facexp
    76  5dd0 f024                                beq fadd4                                ; no shifting
    77  5dd2 9012                                bcc fadda                                ; branch if argexp < facexp
    78  5dd4 8463                                sty facexp                               ; resulting exponent
    79  5dd6 a46f                                ldy argsgn                               ; since arg is bigger, its
    80  5dd8 8468                                sty facsgn                               ; sign is sign of result
    81  5dda 49ff                                eor #$ff                                 ; shift a negative number of palces
    82  5ddc 6900                                adc #0                                   ; complete negation, w/ c=1
    83  5dde a000                                ldy #0                                   ; zero oldov
    84  5de0 8458                                sty oldov
    85  5de2 a263                                ldx #fac                                 ; shift the FAC instead
    86  5de4 8004                                bra fadd1
    87                          
    88  5de6 a000               fadda            ldy #0
    89  5de8 8471                                sty facov
    90                          
    91  5dea c9f9               fadd1            cmp #$f9                                 ; for speed and necessity.  gets most likely case to
    92                          ;SHIFTR fastest and allows shifting of neg nums by QUINT
    93  5dec 30c8                                bmi fadd5                                ; shift big
    94  5dee a8                                  tay
    95  5def a571                                lda facov                                ; set facov
    96  5df1 5601                                lsr 1,x                                  ; gets 0 in the MSB
    97  5df3 20fe5e                              jsr rolshf                               ; do the rolling
    98                          
    99  5df6 7f7057             fadd4            bbr7 arisgn,fadd2                        ; get resulting sign and if positive, add. carry is clear
   100  5df9 a063                                ldy #facexp
   101  5dfb e06a                                cpx #argexp                              ; fac is bigger
   102  5dfd f002                                beq l168_1
   103  5dff a06a                                ldy #argexp                              ; arg is bigger
   104                          
   105  5e01 38                 l168_1           sec                                      ; subit.
   106  5e02 49ff                                eor #$ff
   107  5e04 6558                                adc oldov
   108  5e06 8571                                sta facov
   109  5e08 b90400                              lda 4,y
   110  5e0b f504                                sbc 4,x
   111  5e0d 8567                                sta faclo
   112  5e0f b90300                              lda 3,y
   113  5e12 f503                                sbc 3,x
   114  5e14 8566                                sta facmo
   115  5e16 b90200                              lda 2,y
   116  5e19 f502                                sbc 2,x
   117  5e1b 8565                                sta facmoh
   118  5e1d b90100                              lda 1,y
   119  5e20 f501                                sbc 1,x
   120  5e22 8564                                sta facho
   121                          
   122  5e24 b003               fadflt           bcs normal                               ; here if signs differ. if carry, FAC is set ok
   123  5e26 20995e                              jsr negfac                               ; negate (FAC)
   124                          
   125  5e29 a000               normal           ldy #0
   126  5e2b 98                                  tya
   127  5e2c 18                                  clc
   128                          
   129  5e2d a664               l169_1           ldx facho
   130  5e2f d049                                bne norm1
   131  5e31 a665                                ldx facho+1                              ; shift 8 bits at a time for speed
   132  5e33 8664                                stx facho
   133  5e35 a666                                ldx facmoh+1
   134  5e37 8665                                stx facmoh
   135  5e39 a667                                ldx facmo+1
   136  5e3b 8666                                stx facmo
   137  5e3d a671                                ldx facov
   138  5e3f 8667                                stx faclo
   139  5e41 8471                                sty facov
   140  5e43 6908                                adc #8
   141  5e45 c920                                cmp #32
   142  5e47 d0e4                                bne l169_1
   143                          
   144  5e49 a900               zerofc           lda #0                                   ; not needed by NORMAL, but by others
   145  5e4b 8563               zerof1           sta facexp                               ; number must be zero
   146  5e4d 8568               zeroml           sta facsgn                               ; make sign positive
   147  5e4f 60                 zerrts           rts                                      ; all done
   148                          
   149                          
   150  5e50 6558               fadd2            adc oldov
   151  5e52 8571                                sta facov
   152  5e54 a567                                lda faclo
   153  5e56 656e                                adc arglo
   154  5e58 8567                                sta faclo
   155  5e5a a566                                lda facmo
   156  5e5c 656d                                adc argmo
   157  5e5e 8566                                sta facmo
   158  5e60 a565                                lda facmoh
   159  5e62 656c                                adc argmoh
   160  5e64 8565                                sta facmoh
   161  5e66 a564                                lda facho
   162  5e68 656b                                adc argho
   163  5e6a 8564                                sta facho
   164  5e6c 8019                                bra squeez                               ; go round if signs same
   165                          
   166                          
   167  5e6e 6901               norm2            adc #1                                   ; decrement shift counter
   168  5e70 0671                                asl facov                                ; shift all left one bit
   169  5e72 2667                                rol faclo
   170  5e74 2666                                rol facmo
   171  5e76 2665                                rol facmoh
   172  5e78 2664                                rol facho
   173                          
   174  5e7a 10f2               norm1            bpl norm2                                ; if msb=0 shift again
   175  5e7c 38                                  sec
   176  5e7d e563                                sbc facexp
   177  5e7f b0c8                                bcs zerofc
   178  5e81 49ff                                eor #$ff
   179  5e83 6901                                adc #1                                   ; complement
   180  5e85 8563                                sta facexp
   181                          
   182  5e87 900f               squeez           bcc rndrts                               ; bits to shift?
   183  5e89 e663               rndshf           inc facexp
   184  5e8b f3bacf                              +lbeq overr
   185  5e8e 6664                                ror facho
   186  5e90 6665                                ror facmoh
   187  5e92 6666                                ror facmo
   188  5e94 6667                                ror faclo
   189  5e96 6671                                ror facov
   190  5e98 60                 rndrts           rts                                      ; all done adding
   191                          
   192                          
   193  5e99 a568               negfac           lda facsgn
   194  5e9b 49ff                                eor #$ff                                 ; complement FAC entirely
   195  5e9d 8568                                sta facsgn
   196                          
   197  5e9f a564               negfch           lda facho
   198  5ea1 49ff                                eor #$ff                                 ; complement just the number
   199  5ea3 8564                                sta facho
   200  5ea5 a565                                lda facmoh
   201  5ea7 49ff                                eor #$ff
   202  5ea9 8565                                sta facmoh
   203  5eab a566                                lda facmo
   204  5ead 49ff                                eor #$ff
   205  5eaf 8566                                sta facmo
   206  5eb1 a567                                lda faclo
   207  5eb3 49ff                                eor #$ff
   208  5eb5 8567                                sta faclo
   209  5eb7 a571                                lda facov
   210  5eb9 49ff                                eor #$ff
   211  5ebb 8571                                sta facov
   212  5ebd e671                                inc facov
   213  5ebf d00e                                bne incfrt
   214                          
   215  5ec1 e667               incfac           inc faclo
   216  5ec3 d00a                                bne incfrt
   217  5ec5 e666                                inc facmo
   218  5ec7 d006                                bne incfrt                               ; if no carry, return
   219  5ec9 e665                                inc facmoh
   220  5ecb d002                                bne incfrt
   221  5ecd e664                                inc facho                                ; carry complement
   222  5ecf 60                 incfrt           rts
   223                          
   224                          
   225                          ; SHIFTR shifts (x+1:x+3) (-a) bits right.  Shifts bits to start with
   226                          ; if possible.
   227                          
   228  5ed0 a227               mulshf           ldx #resho-1                             ; entry point for multiplier
   229  5ed2 b404               shftr2           ldy 4,x                                  ; shift bits first
   230  5ed4 8471                                sty facov
   231  5ed6 b403                                ldy 3,x
   232  5ed8 9404                                sty 4,x
   233  5eda b402                                ldy 2,x                                  ; get mo
   234  5edc 9403                                sty 3,x                                  ; store lo
   235  5ede b401                                ldy 1,x                                  ; get ho
   236  5ee0 9402                                sty 2,x                                  ; store mo
   237  5ee2 acd702                              ldy bits
   238  5ee5 9401                                sty 1,x                                  ; store ho
   239                          
   240  5ee7 6908               shiftr           adc #8
   241  5ee9 30e7                                bmi shftr2
   242  5eeb f0e5                                beq shftr2
   243  5eed e908                                sbc #8                                   ; c can be either 1,0 and it works!
   244  5eef a8                                  tay
   245  5ef0 a571                                lda facov
   246  5ef2 b014                                bcs shftrt                               ; equiv to beq here
   247                          
   248  5ef4 1601               shftr3           asl 1,x
   249  5ef6 9002                                bcc l170_1
   250  5ef8 f601                                inc 1,x
   251  5efa 7601               l170_1           ror 1,x
   252  5efc 7601                                ror 1,x                                  ; yes, two of them
   253                          
   254  5efe 7602               rolshf           ror 2,x
   255  5f00 7603                                ror 3,x
   256  5f02 7604                                ror 4,x                                  ; one more time
   257  5f04 6a                                  ror
   258  5f05 c8                                  iny
   259  5f06 d0ec                                bne shftr3                               ; $$$ (most expensive!!!)
   260                          
   261  5f08 18                 shftrt           clc                                      ; clear output of FACOV
   262  5f09 60                                  rts
   263                          

; ******** Source: basic.asm

; ******** Source: math/const.asm
     1                          
     2                          
     3                          
     4                          ; Constants used by LOG, EXP, TRIG, and others.
     5                          
     6  5f0a 7f00000000         fr4              !text 127,0,0,0,0                        ; 1/4
     7  5f0f 8080000000         neghlf           !text 128,128,0,0,0                      ; -0.5
     8  5f14 8000000000         fhalf            !text 128,0,0,0,0                        ; 0.5
     9  5f19 8420000000         tenc             !text 132,32,0,0,0                       ; 10.0
    10  5f1e 82490fdaa1         pival            !text 130,73,15,218,161                  ; pi
    11  5f23 81490fdaa2         pi2              !text 129,73,15,218,162                  ; pi/2
    12  5f28 83490fdaa2         twopi            !text 131,73,15,218,162                  ; pi*2
    13                          
    14  5f2d 9b3ebc1ffd         n0999            !text $9b,$3e,$bc,$1f,$fd
    15  5f32 9e6e6b27fd         n9999            !text $9e,$6e,$6b,$27,$fd
    16  5f37 9e6e6b2800         nmil             !text $9e,$6e,$6b,$28,$00
    17                          
    18                          foutbl                                                    ; powers of 10
    19  5f3c fa0a1f00                            !text 250,10,31,0                        ; -100,000,000
    20  5f40 00989680                            !text 0,152,150,128                      ; 10,000,000
    21  5f44 fff0bdc0                            !text 255,240,189,192                    ; -1,000,000
    22  5f48 000186a0                            !text 0,1,134,160                        ; 100,000
    23  5f4c ffffd8f0                            !text 255,255,216,240                    ; -10,000
    24  5f50 000003e8                            !text 0,0,3,232                          ; 1,000
    25  5f54 ffffff9c                            !text 255,255,255,156                    ; -100
    26  5f58 0000000a                            !text 0,0,0,10                           ; 10
    27  5f5c ffffffff                            !text 255,255,255,255                    ; -1
    28                          fdcend
    29                          
    30                          ; .byte @377,@337,@012,@200 ;-2,160,000 for time converter removed [901014]
    31                          ; .byte @000,@003,@113,@300 ;   216,000
    32                          ; .byte @377,@377,@163,@140 ;   -36,000
    33                          ; .byte @000,@000,@016,@020 ;     3,600
    34                          ; .byte @377,@377,@375,@250 ;      -600
    35                          ; .byte @000,@000,@000,@074 ;        60
    36                          ;timend
    37                          
    38  5f60 03                 logcn2           !text 3                                  ; degree-1
    39  5f61 7f5e56cb79                          !text 127,94,86,203,121                  ; 0.43425594188
    40  5f66 80139b0b64                          !text 128,19,155,11,100                  ; 0.57658454134
    41  5f6b 8076389316                          !text 128,118,56,147,22                  ; 0.96180075921
    42  5f70 8238aa3b20                          !text 130,56,170,59,32                   ; 2.8853900728
    43                          
    44  5f75 07                 expcon           !text 7                                  ; degree-1
    45  5f76 7134583e56                          !text 113,52,88,62,86                    ; 0.000021498763697
    46  5f7b 74167eb31b                          !text 116,22,126,179,27                  ; 0.00014352314036
    47  5f80 772feee385                          !text 119,47,238,227,133                 ; 0.0013422634824
    48  5f85 7a1d841c2a                          !text 122,29,132,28,42                   ; 0.0096140170199
    49  5f8a 7c6359580a                          !text 124,99,89,88,10                    ; 0.055505126860
    50  5f8f 7e75fde7c6                          !text 126,117,253,231,198                ; 0.24022638462
    51  5f94 8031721810                          !text 128,49,114,24,16                   ; 0.69314718600
    52  5f99 8100000000         fone             !text 129,0,0,0,0                        ; 1.0
    53                          
    54  5f9e 8138aa3b29         logeb2           !text 129,56,170,59,41                   ; log(e) base 2
    55  5fa3 803504f334         sqr05            !text 128,53,4,243,52                    ; 0.707106781 sqr(0.5)
    56  5fa8 813504f334         sqr20            !text 129,53,4,243,52                    ; 1.41421356 sqr(2.0)
    57  5fad 80317217f8         log2             !text 128,49,114,23,248                  ; 0.693147181 ln(2)
    58                          
    59                          
    60  5fb2 05                 sincon           !text 5                                  ; degree-1 trig
    61  5fb3 84e61a2d1b                          !text 132,230,26,45,27
    62  5fb8 862807fbf8                          !text 134,40,7,251,248
    63  5fbd 8799688901                          !text 135,153,104,137,1
    64  5fc2 872335dfe1                          !text 135,35,53,223,225
    65  5fc7 86a55de728                          !text 134,165,93,231,40
    66  5fcc 83490fdaa2                          !text 131,73,15,218,162
    67                          
    68  5fd1 0b                 atncon           !text 11                                 ; degree-1
    69  5fd2 76b383bdd3                          !text 118,179,131,189,211
    70  5fd7 791ef4a6f5                          !text 121,30,244,166,245
    71  5fdc 7b83fcb010                          !text 123,131,252,176,16
    72  5fe1 7c0c1f67ca                          !text 124,12,31,103,202
    73  5fe6 7cde53cbc1                          !text 124,222,83,203,193
    74  5feb 7d1464704c                          !text 125,20,100,112,76
    75  5ff0 7db7ea517a                          !text 125,183,234,81,122
    76  5ff5 7d6330887e                          !text 125,99,48,136,126
    77  5ffa 7e9244993a                          !text 126,146,68,153,58
    78  5fff 7e4ccc91c7                          !text 126,76,204,145,199
    79  6004 7faaaaaa13                          !text 127,170,170,170,19
    80  6009 8100000000                          !text 129,0,0,0,0

; ******** Source: basic.asm

; ******** Source: math/log.asm
     1                          
     2                          ; Natural Log Function
     3                          ;
     4                          ; Calculation is by   LN(f*2^n) = (n+LOG2(f))*LN(2)
     5                          ; An approximation polynomial is used to calculate LOG2(f).
     6                          
     7                          
     8  600e 20c162             log              jsr sign                                 ; is it positive?
     9  6011 f3ebf1                              +lbeq fcerr                              ; can't tolerate neg or zero
    10                          
    11  6014 a563                                lda facexp                               ; get exponent into (a)
    12  6016 e97f                                sbc #$7f                                 ; remove bias (carry is off)
    13  6018 48                                  pha                                      ; save exponent a while
    14  6019 a980                                lda #$80
    15  601b 8563                                sta facexp                               ; result is FAC in range (0.5,1)
    16  601d a9a3                                lda #<sqr05                              ; get pointer to sqr(0.5)
    17  601f a05f                                ldy #>sqr05
    18  6021 205160                              jsr romadd
    19  6024 a9a8                                lda #<sqr20
    20  6026 a05f                                ldy #>sqr20
    21  6028 205d60                              jsr romdiv
    22  602b a999                                lda #<fone
    23  602d a05f                                ldy #>fone
    24  602f 205760                              jsr romsub
    25  6032 a960                                lda #<logcn2
    26  6034 a05f                                ldy #>logcn2
    27  6036 205a66                              jsr polyx                                ; evaluate approximation polynomial
    28  6039 a90f                                lda #<neghlf                             ; add in last constant
    29  603b a05f                                ldy #>neghlf
    30  603d 205160                              jsr romadd
    31  6040 68                                  pla                                      ; get exponent back
    32  6041 201464                              jsr finlog
    33  6044 a9ad                                lda #<log2                               ; multiply result by ln(2)
    34  6046 a05f                                ldy #>log2
    35                          
    36                          
    37  6048 20cc60             rommlt           jsr romupk
    38  604b 8023                                bra fmultt                               ; multiply together
    39                          
    40                          
    41  604d a914               faddh            lda #<fhalf
    42  604f a05f                                ldy #>fhalf
    43                          
    44  6051 20cc60             romadd           jsr romupk
    45  6054 8368fd                              +lbra faddt
    46                          
    47                          
    48  6057 20cc60             romsub           jsr romupk
    49  605a 834cfd                              +lbra fsubt
    50                          
    51                          
    52  605d 20cc60             romdiv           jsr romupk
    53  6060 832301                              +lbra fdivt

; ******** Source: basic.asm

; ******** Source: math/multiply.asm
     1                          
     2                          ; Multiplication        FAC = ARG*FAC
     3                          
     4                          fmultt_c65                                                ; [910402]
     5  6063 a56f                                lda argsgn
     6  6065 4568                                eor facsgn
     7  6067 8570                                sta arisgn                               ; resultant sign
     8  6069 a663                                ldx facexp                               ; set signs on thing to multiply
     9  606b 8003                                bra fmultt                               ; go multiply
    10                          
    11  606d 20f760             fmult            jsr conupk                               ; unpack the constant into arg for use
    12                          
    13  6070 f059               fmultt           beq multrt                               ; if FAC=0, return.  FAC is set
    14  6072 202761                              jsr muldiv                               ; fix up the exponents
    15  6075 a900                                lda #0                                   ; to clear result
    16  6077 8528                                sta resho
    17  6079 8529                                sta resmoh
    18  607b 852a                                sta resmo
    19  607d 852b                                sta reslo
    20  607f a571                                lda facov
    21  6081 209e60                              jsr mltpl1                               ; *** THIS fixes the DBL-0 bug without causing other grief!  C128-04 FAB
    22  6084 a567                                lda faclo                                ; multiply arg by faclo
    23  6086 209b60                              jsr mltply
    24  6089 a566                                lda facmo                                ; multiply arg by facmo
    25  608b 209b60                              jsr mltply
    26  608e a565                                lda facmoh
    27  6090 209e60                              jsr mltpl1                               ; *** THIS fixes the DBL-0 bug without causing other grief!  C128-04 FAB
    28  6093 a564                                lda facho                                ; multiply arg by facho
    29  6095 209e60                              jsr mltpl1
    30  6098 836101                              +lbra movfr                              ; move result into FAC
    31                          
    32                          
    33  609b f333fe             mltply           +lbeq mulshf                             ; normalize result and return. shift result right 1 byte.  exits with .c=0
    34  609e 4a                 mltpl1           lsr
    35  609f 0980                                ora #$80                                 ; will flag end of shifting
    36                          
    37  60a1 a8                 l171_1           tay
    38  60a2 9019                                bcc l171_2                               ; if mult bit=0, just shift
    39  60a4 18                                  clc
    40  60a5 a52b                                lda reslo
    41  60a7 656e                                adc arglo
    42  60a9 852b                                sta reslo
    43  60ab a52a                                lda resmo
    44  60ad 656d                                adc argmo
    45  60af 852a                                sta resmo
    46  60b1 a529                                lda resmoh
    47  60b3 656c                                adc argmoh
    48  60b5 8529                                sta resmoh
    49  60b7 a528                                lda resho
    50  60b9 656b                                adc argho
    51  60bb 8528                                sta resho
    52                          
    53  60bd 6628               l171_2           ror resho
    54  60bf 6629                                ror resmoh
    55  60c1 662a                                ror resmo
    56  60c3 662b                                ror reslo
    57  60c5 6671                                ror facov                                ; save for rounding
    58  60c7 98                                  tya
    59  60c8 4a                                  lsr                                      ; clear msb so we get a closer to 0
    60  60c9 d0d6                                bne l171_1                               ; slow as a turtle
    61                          
    62  60cb 60                 multrt           rts
    63                          

; ******** Source: basic.asm

; ******** Source: math/unpack.asm
     1                          ; Unpack a ROM constant into the FAC
     2                          
     3  60cc 8524               romupk           sta index1
     4  60ce 8425                                sty index1+1
     5  60d0 a004                                ldy #4
     6  60d2 b124                                lda (index1),y                           ; it's in ROM, so ok to use ind
     7  60d4 856e                                sta arglo
     8  60d6 88                                  dey
     9  60d7 b124                                lda (index1),y
    10  60d9 856d                                sta argmo
    11  60db 88                                  dey
    12  60dc b124                                lda (index1),y
    13  60de 856c                                sta argmoh
    14  60e0 88                                  dey
    15  60e1 b124                                lda (index1),y
    16  60e3 856f                                sta argsgn
    17  60e5 4568                                eor facsgn
    18  60e7 8570                                sta arisgn
    19  60e9 a56f                                lda argsgn
    20  60eb 0980                                ora #$80
    21  60ed 856b                                sta argho
    22  60ef 88                                  dey
    23  60f0 b124                                lda (index1),y
    24  60f2 856a                                sta argexp
    25  60f4 a563                                lda facexp                               ; sets code of facexp
    26  60f6 60                                  rts
    27                          
    28                          
    29                          ; Unpack a RAM constant into the FAC
    30                          
    31  60f7 8524               conupk           sta index1
    32  60f9 8425                                sty index1+1
    33                          
    34                          ; lda mmu_config_reg
    35                          ; pha   ;preserve caller's memory config????
    36                          
    37  60fb a004                                ldy #4
    38  60fd 20d522                              jsr indin1_ram1
    39  6100 856e                                sta arglo
    40  6102 88                                  dey
    41  6103 20d522                              jsr indin1_ram1
    42  6106 856d                                sta argmo
    43  6108 88                                  dey
    44  6109 20d522                              jsr indin1_ram1
    45  610c 856c                                sta argmoh
    46  610e 88                                  dey
    47  610f 20d522                              jsr indin1_ram1
    48  6112 856f                                sta argsgn
    49  6114 4568                                eor facsgn
    50  6116 8570                                sta arisgn
    51  6118 a56f                                lda argsgn
    52  611a 0980                                ora #$80
    53  611c 856b                                sta argho
    54  611e 88                                  dey
    55  611f 20d522                              jsr indin1_ram1
    56  6122 856a                                sta argexp
    57                          
    58                          ; pla
    59                          ; sta mmu_config_reg ;restore caller's memory config????
    60                          
    61  6124 a563                                lda facexp                               ; set codes of facexp
    62  6126 60                                  rts
    63                          
    64                          
    65                          ; Check special cases and add exponents for FMULT, FDIV
    66                          
    67                          muldiv
    68  6127 a56a                                lda argexp                               ; exp of arg=0?
    69  6129 f01f               mldexp           beq zeremv                               ; so we get zero exponent
    70  612b 18                                  clc
    71  612c 6563                                adc facexp                               ; result is in (a)
    72  612e 9005                                bcc l172_1                               ; find (c) xor (n)
    73  6130 3315cd                              +lbmi overr                              ; overflow if bits match
    74  6133 18                                  clc
    75  6134 2c                                  !text $2c
    76                          
    77  6135 1013               l172_1           bpl zeremv                               ; underflow
    78  6137 6980                                adc #$80                                 ; add bias
    79  6139 8563                                sta facexp
    80  613b f310fd                              +lbeq zeroml                             ; zero the rest of it
    81  613e a570                                lda arisgn
    82  6140 8568                                sta facsgn                               ; arisgn is result's sign
    83  6142 60                                  rts                                      ; done
    84                          
    85                          
    86  6143 a568               mldvex           lda facsgn                               ; get sign
    87  6145 49ff                                eor #$ff                                 ; complement it
    88  6147 33fecc                              +lbmi overr
    89                          
    90  614a 68                 zeremv           pla                                      ; get addr off stack
    91  614b 68                                  pla
    92  614c 83fbfc                              +lbra zerofc                             ; underflow
    93                          
    94                          
    95                          ; Multiply FAC by 10
    96                          
    97  614f 20a362             mul10            jsr movaf                                ; copy FAC into ARG
    98  6152 aa                                  tax
    99  6153 f012                                beq mul10r                               ; if (FAC)=0, got answer
   100  6155 18                                  clc
   101  6156 6902                                adc #2                                   ; augment exp by 2
   102  6158 b3edcc                              +lbcs overr                              ; overflow
   103                          
   104  615b a200               finml6           ldx #0
   105  615d 8670                                stx arisgn                               ; signs are same
   106  615f 20c95d                              jsr faddc                                ; add together
   107  6162 e663                                inc facexp                               ; multiply by two
   108  6164 f3e1cc                              +lbeq overr                              ; overflow
   109                          
   110  6167 60                 mul10r           rts
   111                          
   112                          
   113  6168 20a362             div10            jsr movaf                                ; move FAC to ARG
   114  616b a919                                lda #<tenc
   115  616d a05f                                ldy #>tenc                               ; point to constant of 10.0
   116  616f a200                                ldx #0                                   ; signs are both positive
   117                          
   118  6171 8670               fdivf            stx arisgn
   119  6173 200e62                              jsr movfm                                ; put it into FAC
   120  6176 800d                                bra fdivt
   121                          
   122                          fdivt_c65                                                 ; [910402]
   123  6178 a56f                                lda argsgn
   124  617a 4568                                eor facsgn
   125  617c 8570                                sta arisgn                               ; resultant sign
   126  617e a663                                ldx facexp                               ; set signs on thing to divide
   127  6180 8003                                bra fdivt                                ; go divide
   128                          
   129  6182 20f760             fdiv             jsr conupk                               ; unpack constant
   130  6185 f3bdcc             fdivt            +lbeq doverr                             ; can't divide by zero
   131  6188 20b262                              jsr round                                ; take FACOV into account in FAC
   132  618b a900                                lda #0                                   ; negate facexp
   133  618d 38                                  sec
   134  618e e563                                sbc facexp
   135  6190 8563                                sta facexp
   136  6192 202761                              jsr muldiv                               ; fix up exponents
   137  6195 e663                                inc facexp                               ; scale it right
   138  6197 f3aecc                              +lbeq overr                              ; overflow
   139  619a a2fc                                ldx #$fc                                 ; set up procedure
   140  619c a901                                lda #1
   141                          
   142                          
   143                          divide                                                    ; this is the best code in the whole pile
   144  619e a46b                                ldy argho                                ; see what relation holds
   145  61a0 c464                                cpy facho
   146  61a2 d010                                bne savquo                               ; (c)=0,1. n(c=0)=0.
   147  61a4 a46c                                ldy argmoh
   148  61a6 c465                                cpy facmoh
   149  61a8 d00a                                bne savquo
   150  61aa a46d                                ldy argmo
   151  61ac c466                                cpy facmo
   152  61ae d004                                bne savquo
   153  61b0 a46e                                ldy arglo
   154  61b2 c467                                cpy faclo
   155                          
   156  61b4 08                 savquo           php
   157  61b5 2a                                  rol                                      ; save result
   158  61b6 9009                                bcc qshft                                ; if not done, continue
   159  61b8 e8                                  inx
   160  61b9 952b                                sta reslo,x
   161  61bb f031                                beq ld100
   162  61bd 1033                                bpl divnrm                               ; note this req 1 no ram then access
   163  61bf a901                                lda #1
   164                          
   165  61c1 28                 qshft            plp                                      ; return condition codes
   166  61c2 b00e                                bcs divsub                               ; FAC <= ARG
   167                          
   168  61c4 066e               shfarg           asl arglo                                ; shift ARG one place left
   169  61c6 266d                                rol argmo
   170  61c8 266c                                rol argmoh
   171  61ca 266b                                rol argho
   172  61cc b0e6                                bcs savquo                               ; save a result of one for this position and divide
   173  61ce 30ce                                bmi divide                               ; if msb on, go decide whether to sub
   174  61d0 10e2                                bpl savquo
   175                          
   176                          
   177  61d2 a8                 divsub           tay                                      ; notice c must be on here
   178  61d3 a56e                                lda arglo
   179  61d5 e567                                sbc faclo
   180  61d7 856e                                sta arglo
   181  61d9 a56d                                lda argmo
   182  61db e566                                sbc facmo
   183  61dd 856d                                sta argmo
   184  61df a56c                                lda argmoh
   185  61e1 e565                                sbc facmoh
   186  61e3 856c                                sta argmoh
   187  61e5 a56b                                lda argho
   188  61e7 e564                                sbc facho
   189  61e9 856b                                sta argho
   190  61eb 98                                  tya
   191  61ec 80d6                                bra shfarg
   192                          
   193                          
   194                          
   195  61ee a940               ld100            lda #$40                                 ; only want two more bits
   196  61f0 80cf                                bra qshft                                ; always branches
   197                          
   198                          
   199                          
   200  61f2 0a                 divnrm           asl                                      ; get last two bits into MSB and B6
   201  61f3 0a                                  asl
   202  61f4 0a                                  asl
   203  61f5 0a                                  asl
   204  61f6 0a                                  asl
   205  61f7 0a                                  asl
   206  61f8 8571                                sta facov
   207  61fa 28                                  plp
   208                          
   209                          
   210                          
   211  61fb a528               movfr            lda resho                                ; move result to FAC
   212  61fd 8564                                sta facho
   213  61ff a529                                lda resmoh
   214  6201 8565                                sta facmoh
   215  6203 a52a                                lda resmo
   216  6205 8566                                sta facmo
   217  6207 a52b                                lda reslo                                ; move lo and sign
   218  6209 8567                                sta faclo
   219  620b 831cfc                              +lbra normal                             ; all done
   220                          
   221                          
   222                          
   223  620e 8524               movfm            sta index1                               ; move memory into FAC from ROM (unpacked)
   224  6210 8425                                sty index1+1
   225  6212 a004                                ldy #4
   226  6214 b124                                lda (index1),y
   227  6216 8567                                sta faclo
   228  6218 88                                  dey
   229  6219 b124                                lda (index1),y
   230  621b 8566                                sta facmo
   231  621d 88                                  dey
   232  621e b124                                lda (index1),y
   233  6220 8565                                sta facmoh
   234  6222 88                                  dey
   235  6223 b124                                lda (index1),y
   236  6225 8568                                sta facsgn
   237  6227 0980                                ora #$80
   238  6229 8564                                sta facho
   239  622b 88                                  dey
   240  622c b124                                lda (index1),y
   241  622e 8563                                sta facexp
   242  6230 8471                                sty facov
   243  6232 60                                  rts
   244                          
   245                          
   246                          ; Move number from FAC to memory
   247                          
   248  6233 a25e               mov2f            ldx #tempf2                              ; move from FAC to temp FAC2
   249  6235 2c                                  !text $2c
   250                          
   251  6236 a259               mov1f            ldx #tempf1                              ; move from FAC to temp FAC1
   252                          
   253  6238 a000                                ldy #0
   254  623a 20b262             movmf            jsr round
   255  623d 8624                                stx index1
   256  623f 8425                                sty index1+1
   257  6241 a004                                ldy #4
   258  6243 a567                                lda faclo
   259  6245 9124                                sta (index),y                            ; BasePage
   260  6247 88                                  dey
   261  6248 a566                                lda facmo
   262  624a 9124                                sta (index),y                            ; BasePage
   263  624c 88                                  dey
   264  624d a565                                lda facmoh
   265  624f 9124                                sta (index),y                            ; BasePage
   266  6251 88                                  dey
   267  6252 a568                                lda facsgn                               ; include sign in ho
   268  6254 097f                                ora #$7f
   269  6256 2564                                and facho
   270  6258 9124                                sta (index),y                            ; BasePage
   271  625a 88                                  dey
   272  625b a563                                lda facexp
   273  625d 9124                                sta (index),y                            ; BasePage
   274  625f 8471                                sty facov                                ; zero it since rounded
   275  6261 60                                  rts                                      ; (y)=0
   276                          
   277                          
   278                          movmf_ram1
   279  6262 20b262                              jsr round
   280  6265 8624                                stx index1
   281  6267 8425                                sty index1+1
   282  6269 da                                  phx
   283  626a a224                                ldx #index
   284  626c a004                                ldy #4
   285  626e a567                                lda faclo
   286  6270 20f022                              jsr sta_far_ram1                         ; sta (index),y
   287  6273 88                                  dey
   288  6274 a566                                lda facmo
   289  6276 20f022                              jsr sta_far_ram1                         ; sta (index),y
   290  6279 88                                  dey
   291  627a a565                                lda facmoh
   292  627c 20f022                              jsr sta_far_ram1                         ; sta (index),y
   293  627f 88                                  dey
   294  6280 a568                                lda facsgn                               ; include sign in ho
   295  6282 097f                                ora #$7f
   296  6284 2564                                and facho
   297  6286 20f022                              jsr sta_far_ram1                         ; sta (index),y
   298  6289 88                                  dey
   299  628a a563                                lda facexp
   300  628c 20f022                              jsr sta_far_ram1                         ; sta (index),y
   301  628f 8471                                sty facov                                ; zero it since rounded
   302  6291 fa                                  plx
   303  6292 60                                  rts                                      ; (y)=0
   304                          
   305                          
   306  6293 a56f               movfa            lda argsgn
   307                          
   308  6295 8568               movfa1           sta facsgn
   309                          
   310  6297 a205                                ldx #5
   311  6299 b569               l173_1           lda argexp-1,x
   312  629b 9562                                sta facexp-1,x
   313  629d ca                                  dex
   314  629e d0f9                                bne l173_1
   315  62a0 8671                                stx facov
   316  62a2 60                                  rts
   317                          
   318                          
   319  62a3 20b262             movaf            jsr round
   320                          
   321  62a6 a206               movef            ldx #6
   322  62a8 b562               l174_1           lda facexp-1,x
   323  62aa 9569                                sta argexp-1,x
   324  62ac ca                                  dex
   325  62ad d0f9                                bne l174_1
   326  62af 8671                                stx facov                                ; zero it since rounded
   327  62b1 60                 movrts           rts
   328                          
   329                          
   330                          
   331  62b2 a563               round            lda facexp                               ; zero?
   332  62b4 f0fb                                beq movrts                               ; yes, done rounding
   333  62b6 0671                                asl facov                                ; round?
   334  62b8 90f7                                bcc movrts                               ; no, msb off
   335                          
   336  62ba 20c15e             incrnd           jsr incfac                               ; yes, add one to lsb(FAC) /// entry from EXP
   337                          ;note .c=1 since incfac doesn't touch .c
   338  62bd f3cafb                              +lbeq rndshf                             ; carry:   squeeze msb in and rts
   339  62c0 60                                  rts                                      ; no carry: rts now
   340                          
   341                          
   342                          
   343                          ; Put sign in FAC into (a).
   344                          
   345  62c1 a563               sign             lda facexp
   346  62c3 f009                                beq signrt                               ; if number is zero, so is result
   347                          
   348  62c5 a568               fcsign           lda facsgn
   349  62c7 2a                 fcomps           rol
   350  62c8 a9ff                                lda #$ff                                 ; assume negative
   351  62ca b002                                bcs signrt
   352  62cc a901                                lda #1                                   ; get +1
   353  62ce 60                 signrt           rts
   354                          
   355                          
   356                          
   357                          ; SGN function
   358                          
   359  62cf 20c162             sgn              jsr sign
   360                          
   361                          ;float the signed integer in accb
   362  62d2 8564               float            sta facho                                ; put (accb) in high order
   363  62d4 a900                                lda #0
   364  62d6 8565                                sta facho+1
   365  62d8 a288                                ldx #$88                                 ; get the exponent
   366                          ;float the signed number in FAC
   367                          
   368                          
   369  62da a564               floats           lda facho
   370  62dc 49ff                                eor #$ff
   371  62de 2a                                  rol                                      ; get comp of sign in carry
   372  62df a900               floatc           lda #0                                   ; zero (a) but not carry
   373  62e1 8567                                sta faclo
   374  62e3 8566                                sta facmo
   375                          
   376  62e5 8663               floatb           stx facexp
   377  62e7 8571                                sta facov
   378  62e9 8568                                sta facsgn
   379  62eb 8337fb                              +lbra fadflt
   380                          
   381                          
   382                          
   383                          
   384                          ; Absolute value of FAC
   385                          
   386  62ee 4668               abs              lsr facsgn
   387  62f0 60                                  rts
   388                          
   389                          
   390                          
   391                          ; Compare two numbers:
   392                          ;
   393                          ; a=1  if  ARG < FAC
   394                          ; a=0  if  ARG = FAC
   395                          ; a=-1 if  ARG > FAC
   396                          
   397  62f1 8526               fcomp            sta index2
   398  62f3 8427                                sty index2+1
   399  62f5 a000                                ldy #0
   400  62f7 b126                                lda (index2),y                           ; has argexp
   401  62f9 c8                                  iny                                      ; bump pointer up
   402  62fa aa                                  tax                                      ; save a in x and reset codes
   403  62fb f0c4                                beq sign
   404  62fd b126                                lda (index2),y
   405  62ff 4568                                eor facsgn                               ; signs the same
   406  6301 30c2                                bmi fcsign                               ; signs differ so result is
   407  6303 e463                                cpx facexp                               ; sign of FAC again
   408  6305 d021                                bne l175_1
   409                          
   410  6307 b126                                lda (index2),y
   411  6309 0980                                ora #$80
   412  630b c564                                cmp facho
   413  630d d019                                bne l175_1
   414  630f c8                                  iny
   415  6310 b126                                lda (index2),y
   416  6312 c565                                cmp facmoh
   417  6314 d012                                bne l175_1
   418  6316 c8                                  iny
   419  6317 b126                                lda (index2),y
   420  6319 c566                                cmp facmo
   421  631b d00b                                bne l175_1
   422  631d c8                                  iny
   423  631e a97f                                lda #$7f
   424  6320 c571                                cmp facov
   425  6322 b126                                lda (index2),y
   426  6324 e567                                sbc faclo                                ; get zero if equal
   427  6326 f028                                beq qintrt                               ; rts
   428                          
   429  6328 a568               l175_1           lda facsgn
   430  632a 9002                                bcc l175_2
   431  632c 49ff                                eor #$ff
   432  632e 8097               l175_2           bra fcomps                               ; a part of sign sets up (a)
   433                          

; ******** Source: basic.asm

; ******** Source: math/ext4.asm
     1                          
     2                          
     3                          
     4                          ; Quick Greatest Integer Function
     5                          ;
     6                          ; Leaves INT(FAC) in FACHO&MO&LO signed
     7                          ; Assumes FAC < 2~23 =8388608
     8                          
     9  6330 a563               qint             lda facexp
    10  6332 f04f                                beq clrfac                               ; if zero, got it
    11  6334 38                                  sec
    12  6335 e9a0                                sbc #$a0                                 ; get number of places to shift
    13                          
    14  6337 7f680a                              bbr7 facsgn,l176_1
    15                          
    16  633a aa                                  tax
    17  633b a9ff                                lda #$ff
    18  633d 8dd702                              sta bits                                 ; put $ff in when shftr shifts bytes
    19  6340 209f5e                              jsr negfch                               ; truly negate quantity in FAC
    20  6343 8a                                  txa
    21                          
    22  6344 a263               l176_1           ldx #fac
    23  6346 c9f9                                cmp #$f9
    24  6348 1007                                bpl qint1                                ; if number of places > 7 shift 1 place at a time
    25  634a 20e75e                              jsr shiftr                               ; start shifting bytes, then bits
    26  634d 8cd702                              sty bits                                 ; zero bits since adder wants zero
    27  6350 60                 qintrt           rts
    28                          
    29                          
    30  6351 a8                 qint1            tay                                      ; put count in counter
    31  6352 a568                                lda facsgn
    32  6354 2980                                and #$80                                 ; get sign bit
    33  6356 4664                                lsr facho                                ; save first shifted byte
    34  6358 0564                                ora facho
    35  635a 8564                                sta facho
    36  635c 20fe5e                              jsr rolshf                               ; shift the rest
    37  635f 8cd702                              sty bits                                 ; zero (bits)
    38  6362 60                                  rts
    39                          
    40                          
    41                          
    42                          ; Greatest Integer Function
    43                          
    44  6363 a563               int              lda facexp
    45  6365 c9a0                                cmp #$a0
    46  6367 b023                                bcs intrts                               ; forget it
    47  6369 20b262                              jsr round                                ; round FAC per FACOV (fixes the  INT(.9+.1) -> 0  Microsoft bug.  FAB)
    48  636c 203063                              jsr qint                                 ; INT(FAC)
    49  636f 8471                                sty facov                                ; clr overflow byte
    50  6371 a568                                lda facsgn
    51  6373 8468                                sty facsgn                               ; make FAC look positive
    52  6375 4980                                eor #$80                                 ; get complement of sign in carry
    53  6377 2a                                  rol
    54  6378 a9a0                                lda #$a0                                 ; @230+8
    55  637a 8563                                sta facexp
    56  637c a567                                lda faclo
    57  637e 850a                                sta integr
    58  6380 83a2fa                              +lbra fadflt
    59                          
    60                          
    61  6383 8564               clrfac           sta facho                                ; make it really zero
    62  6385 8565                                sta facmoh
    63  6387 8566                                sta facmo
    64  6389 8567                                sta faclo
    65  638b a8                                  tay
    66  638c 60                 intrts           rts

; ******** Source: basic.asm

; ******** Source: math/fpin.asm
     1                          
     2                          
     3                          ; Floating Point Input Routine.
     4                          ;
     5                          ; Number input is left in FAC.  At entry (TXTPTR) points to the first character
     6                          ; in a text buffer.  The first character is also in (a).  FIN packs the digits
     7                          ; into the FAC as an integer and keeps track of where the decimal point is.
     8                          ; (DPTFLG) tells whether a dp has been seen.  (DECCNT) is the number of digits
     9                          ; after the dp.  At the end (DECCNT) and the exponent are used to determine how
    10                          ; many times to multiply or divide by ten to get the correct number.
    11                          
    12                          
    13  638d 8ed202             fin              stx fin_bank                             ; save bank number where string is stored
    14                          
    15  6390 a000                                ldy #0                                   ; zero facsgn, sgnflg
    16  6392 a20a                                ldx #$0a                                 ; zero exp and ho (and moh)
    17  6394 945f               l177_1           sty deccnt,x                             ; zero mo and lo
    18  6396 ca                                  dex                                      ; zero tenexp and expsgn
    19  6397 10fb                                bpl l177_1                               ; zero deccnt, dptflg
    20                          
    21  6399 900f                                bcc findgq                               ; flags still set from chrget
    22  639b c92d                                cmp #'-'                                 ; a negative sign?
    23  639d d004                                bne qplus                                ; no, try plus sign
    24  639f 8669                                stx sgnflg                               ; it's negative. (x=@377)
    25  63a1 8004                                bra finc                                 ; always branches
    26                          
    27                          
    28  63a3 c92b               qplus            cmp #'+'                                 ; plus sign?
    29  63a5 d005                                bne fin1                                 ; yes, skip it
    30                          
    31  63a7 205764             finc             jsr fin_chrget
    32                          
    33  63aa 9056               findgq           bcc findig
    34                          
    35  63ac c92e               fin1             cmp #'.'                                 ; the dp?
    36  63ae f02c                                beq findp                                ; no kidding
    37  63b0 c945                                cmp #'E'                                 ; exponent follows
    38  63b2 d02d                                bne fine                                 ; no
    39                          
    40  63b4 205764                              jsr fin_chrget                           ; yes, get another, to check sign of exponent
    41  63b7 9017                                bcc fnedg1                               ; is it a digit. (easier than backing up pointer)
    42  63b9 c9ab                                cmp #minus_token                         ; minus?
    43  63bb f00e                                beq finec1                               ; negate
    44  63bd c92d                                cmp #'-'                                 ; minus sign?
    45  63bf f00a                                beq finec1
    46  63c1 c9aa                                cmp #plus_token                          ; plus?
    47  63c3 f008                                beq finec
    48  63c5 c92b                                cmp #'+'                                 ; plus sign?
    49  63c7 f004                                beq finec
    50  63c9 8007                                bra finec2
    51                          
    52  63cb 6662               finec1           ror expsgn                               ; turn it on
    53                          
    54  63cd 205764             finec            jsr fin_chrget                           ; get another
    55                          
    56  63d0 9055               fnedg1           bcc finedg                               ; it is a digit
    57  63d2 7f620c             finec2           bbr7 expsgn,fine
    58  63d5 a900                                lda #0
    59  63d7 38                                  sec
    60  63d8 e560                                sbc tenexp
    61  63da 8007                                bra fine1
    62                          
    63  63dc 6661               findp            ror dptflg
    64  63de 6f61c6                              bbr6 dptflg,finc
    65                          
    66  63e1 a560               fine             lda tenexp
    67  63e3 38                 fine1            sec
    68  63e4 e55f                                sbc deccnt                               ; get number of places to shift
    69  63e6 8560                                sta tenexp
    70  63e8 f012                                beq finqng                               ; negate?
    71  63ea 1009                                bpl finmul                               ; positive, so multiply
    72                          
    73  63ec 206861             findiv           jsr div10
    74  63ef e660                                inc tenexp                               ; done?
    75  63f1 d0f9                                bne findiv                               ; no
    76  63f3 8007                                bra finqng                               ; yes
    77                          
    78                          
    79  63f5 204f61             finmul           jsr mul10
    80  63f8 c660                                dec tenexp                               ; done?
    81  63fa d0f9                                bne finmul                               ; no
    82  63fc a569               finqng           lda sgnflg
    83  63fe 33fc01                              +lbmi negop                              ; if negative, negate and return
    84  6401 60                                  rts                                      ; if positive, return
    85                          
    86                          
    87                          
    88  6402 48                 findig           pha
    89  6403 7f6102                              bbr7 dptflg,l178_1
    90  6406 e65f                                inc deccnt
    91  6408 204f61             l178_1           jsr mul10
    92  640b 68                                  pla                                      ; get it back
    93  640c 38                                  sec
    94  640d e930                                sbc #'0'
    95  640f 201464                              jsr finlog                               ; add it in
    96  6412 8093                                bra finc
    97                          
    98                          
    99                          
   100  6414 48                 finlog           pha
   101  6415 20a362                              jsr movaf                                ; save it for later
   102  6418 68                                  pla
   103  6419 20d262                              jsr float                                ; float the value in (a)
   104                          
   105                          faddt_c65                                                 ; [910402]
   106  641c a56f                                lda argsgn
   107  641e 4568                                eor facsgn
   108  6420 8570                                sta arisgn                               ; resultant sign
   109  6422 a663                                ldx facexp                               ; set signs on thing to add
   110  6424 8398f9                              +lbra faddt                              ; add together and return
   111                          
   112                          
   113                          ; Pack in the next digit of the exponent.
   114                          ; Multiply the old exp by 10 and add in the next digit.
   115                          ; (note: does not check for exp overflow)
   116                          
   117  6427 a560               finedg           lda tenexp                               ; get exp so far
   118  6429 c90a                                cmp #10                                  ; will result be >= 100?
   119  642b 9008                                bcc l179_1
   120  642d a964                                lda #100
   121  642f ff6220                              bbs7 expsgn,l179_4                       ; if neg exp, no chk for overr
   122  6432 8313ca                              +lbra overr
   123                          
   124  6435 0a                 l179_1           asl                                      ; max is 120
   125  6436 0a                                  asl                                      ; mult by 2 twice
   126  6437 18                                  clc                                      ; possible shift out of high
   127  6438 6560                                adc tenexp                               ; like multiplying by five
   128  643a 0a                                  asl                                      ; and now by ten
   129  643b 18                                  clc
   130  643c a000                                ldy #0
   131  643e 8578                                sta syntmp
   132                          
   133  6440 add202                              lda fin_bank                             ; text or string bank?
   134  6443 d005                                bne l179_2
   135  6445 20c522                              jsr indtxt                               ; text
   136  6448 8003                                bra l179_3
   137  644a 20d522             l179_2           jsr indin1_ram1                          ; string
   138                          
   139  644d 6578               l179_3           adc syntmp
   140  644f 38                                  sec
   141  6450 e930                                sbc #'0'
   142  6452 8560               l179_4           sta tenexp                               ; save result
   143  6454 8377ff                              +lbra finec
   144                          
   145                          
   146                          ; Get a character from either text or string area, and set the flags
   147                          ; in the manner performed by CHRGET.
   148                          
   149                          fin_chrget
   150  6457 add202                              lda fin_bank                             ; text or string bank?
   151  645a f327be                              +lbeq chrget                             ; get byte from text bank via normal CHRGET mechanism
   152                          
   153                          fin_chrget_1                                              ; get byte from string bank via modified CHRGET mechanism
   154  645d e324                                inw index1
   155                          fin_chrget_2
   156  645f a000                                ldy #0
   157  6461 20d522                              jsr indin1_ram1
   158  6464 c93a                                cmp #':'
   159  6466 b00a                                bcs l180_1
   160  6468 c920                                cmp #' '
   161  646a f0f1                                beq fin_chrget_1                         ; skip over spaces
   162  646c 38                                  sec
   163  646d e930                                sbc #'0'                                 ; set up .c as CHRGET would
   164  646f 38                                  sec
   165  6470 e9d0                                sbc #$d0
   166  6472 60                 l180_1           rts
   167                          

; ******** Source: basic.asm

; ******** Source: math/ext5.asm
     1                          
     2                          
     3                          
     4  6473 207dff             inprt            jsr _primm
     5  6476 20494e2000                          !text " IN ",0
     6                          
     7  647b a53c               curprt           lda curlin+1
     8  647d a63b                                ldx curlin
     9                          
    10  647f 8564               linprt           sta facho
    11  6481 8665                                stx facho+1
    12  6483 a290                                ldx #$90                                 ; exponent of 16
    13  6485 38                                  sec                                      ; number is positive
    14  6486 20df62                              jsr floatc
    15  6489 209164                              jsr foutc
    16  648c 83add3                              +lbra strout                             ; print and return
    17                          
    18                          
    19  648f a001               fout             ldy #1
    20  6491 a920               foutc            lda #' '                                 ; if positive, print space
    21  6493 7f6802                              bbr7 facsgn,l181_1
    22  6496 a92d                                lda #'-'                                 ; if neg
    23  6498 99ff00             l181_1           sta fbuffr-1,y                           ; store the character
    24  649b 8568                                sta facsgn                               ; make FAC pos for QINT
    25  649d 8472                                sty fbufpt                               ; save for later
    26  649f c8                                  iny
    27  64a0 a930                                lda #'0'                                 ; get zero to type if FAC=0
    28  64a2 a663                                ldx facexp
    29  64a4 f30901                              +lbeq fout19
    30                          
    31  64a7 a900                                lda #0
    32  64a9 e080                                cpx #$80                                 ; is number < 1?
    33  64ab f002                                beq l181_2                               ; no
    34  64ad b009                                bcs l181_3
    35                          
    36  64af a937               l181_2           lda #<nmil                               ; mult by 10~6
    37  64b1 a05f                                ldy #>nmil
    38  64b3 204860                              jsr rommlt
    39  64b6 a9f7                                lda #$f7
    40  64b8 855f               l181_3           sta deccnt                               ; save count or zero it
    41                          
    42  64ba a932               l181_4           lda #<n9999
    43  64bc a05f                                ldy #>n9999
    44  64be 20f162                              jsr fcomp                                ; is number > 999999.499 or 999999999.5?
    45  64c1 f01e                                beq l181_9                               ; go to biggies
    46  64c3 1012                                bpl l181_7                               ; yes, make it smaller
    47                          
    48  64c5 a92d               l181_5           lda #<n0999
    49  64c7 a05f                                ldy #>n0999
    50  64c9 20f162                              jsr fcomp                                ; is number > 99999.9499 or 99999999.90625?
    51  64cc f002                                beq l181_6
    52  64ce 100e                                bpl l181_8                               ; yes. done multiplying
    53                          
    54  64d0 204f61             l181_6           jsr mul10                                ; make it bigger
    55  64d3 c65f                                dec deccnt
    56  64d5 d0ee                                bne l181_5                               ; see if that does it (this always goes)
    57                          
    58  64d7 206861             l181_7           jsr div10                                ; make it smaller
    59  64da e65f                                inc deccnt
    60  64dc d0dc                                bne l181_4                               ; see if that does it (this always goes)
    61                          
    62  64de 204d60             l181_8           jsr faddh                                ; add a half to round up
    63                          
    64                          
    65  64e1 203063             l181_9           jsr qint                                 ; biggies.
    66  64e4 a201                                ldx #1                                   ; decimal point count
    67  64e6 a55f                                lda deccnt
    68  64e8 18                                  clc
    69  64e9 690a                                adc #$0a                                 ; should number be printed in E notation?  (ie, is number .lt. .01?)
    70  64eb 3009                                bmi l181_10                              ; yes
    71  64ed c90b                                cmp #$0b                                 ; is it > 999999 or 9999999999?
    72  64ef b006                                bcs l181_11                              ; yes, use E notation
    73  64f1 69ff                                adc #$ff                                 ; number of places before decimal point
    74  64f3 aa                                  tax                                      ; put into accx
    75  64f4 a902                                lda #2                                   ; no E notation
    76  64f6 38                 l181_10          sec
    77                          
    78  64f7 e902               l181_11          sbc #2                                   ; effectively add 5 to orig exp
    79  64f9 8560                                sta tenexp                               ; that is the exponent to print
    80  64fb 865f                                stx deccnt                               ; number of decimal places
    81  64fd 8a                                  txa
    82  64fe f002                                beq l181_12
    83  6500 1013                                bpl l181_14                              ; some places before dec pnt
    84                          
    85  6502 a472               l181_12          ldy fbufpt                               ; get pointer to output
    86  6504 a92e                                lda #'.'                                 ; put in "."
    87  6506 c8                                  iny
    88  6507 99ff00                              sta fbuffr-1,y
    89  650a 8a                                  txa
    90  650b f006                                beq l181_13
    91  650d a930                                lda #'0'                                 ; get the ensuing zero
    92  650f c8                                  iny
    93  6510 99ff00                              sta fbuffr-1,y
    94                          
    95  6513 8472               l181_13          sty fbufpt                               ; save it for later
    96                          
    97  6515 a000               l181_14          ldy #0
    98                          
    99  6517 a280               foutim           ldx #$80                                 ; first pass through, accb has msb set
   100  6519 a567               fout2            lda faclo
   101  651b 18                                  clc
   102  651c 793f5f                              adc foutbl+3,y
   103  651f 8567                                sta faclo
   104  6521 a566                                lda facmo
   105  6523 793e5f                              adc foutbl+2,y
   106  6526 8566                                sta facmo
   107  6528 a565                                lda facmoh
   108  652a 793d5f                              adc foutbl+1,y
   109  652d 8565                                sta facmoh
   110  652f a564                                lda facho
   111  6531 793c5f                              adc foutbl,y
   112  6534 8564                                sta facho
   113  6536 e8                                  inx                                      ; it was done yet another time
   114  6537 b004                                bcs l182_1
   115  6539 10de                                bpl fout2
   116  653b 3002                                bmi l182_2
   117                          
   118  653d 30da               l182_1           bmi fout2
   119  653f 8a                 l182_2           txa
   120  6540 9004                                bcc l182_3                               ; can use (a) as is
   121  6542 49ff                                eor #$ff                                 ; find 11.(a)
   122  6544 690a                                adc #10                                  ; c is still on to complete negation, and will always be on after
   123                          
   124  6546 692f               l182_3           adc #'0'-1                               ; get a character to print
   125  6548 c8                                  iny
   126  6549 c8                                  iny
   127  654a c8                                  iny
   128  654b c8                                  iny
   129  654c 8449                                sty fdecpt
   130  654e a472                                ldy fbufpt
   131  6550 c8                                  iny                                      ; point to place to store output
   132  6551 aa                                  tax
   133  6552 297f                                and #$7f                                 ; get rid of msb
   134  6554 99ff00                              sta fbuffr-1,y
   135  6557 c65f                                dec deccnt
   136  6559 d006                                bne l182_4                               ; not time for dp yet
   137  655b a92e                                lda #'.'
   138  655d c8                                  iny
   139  655e 99ff00                              sta fbuffr-1,y                           ; store dp
   140                          
   141  6561 8472               l182_4           sty fbufpt                               ; store pointer for later
   142  6563 a449                                ldy fdecpt
   143  6565 8a                                  txa                                      ; complement accb
   144  6566 49ff                                eor #$ff                                 ; complement acca
   145  6568 2980                                and #$80                                 ; save only msb
   146  656a aa                                  tax
   147  656b c024                                cpy #fdcend-foutbl
   148                          ; beq l182_5  ;for time converter ????   removed [901014]
   149                          ; cpy #timend-foutbl
   150  656d d0aa                                bne fout2                                ; continue with output
   151                          
   152  656f a472               l182_5           ldy fbufpt                               ; get back output pointer
   153  6571 b9ff00             l182_6           lda fbuffr-1,y                           ; remove trailing blanks
   154  6574 88                                  dey
   155  6575 c930                                cmp #'0'
   156  6577 f0f8                                beq l182_6
   157  6579 c92e                                cmp #'.'
   158  657b f001                                beq l182_7                               ; ran into dp,  stop
   159  657d c8                                  iny                                      ; something else, save it
   160                          
   161  657e a92b               l182_7           lda #'+'
   162  6580 a660                                ldx tenexp
   163  6582 f02e                                beq fout17                               ; no exponent to output
   164  6584 1008                                bpl l182_8
   165  6586 a900                                lda #0
   166  6588 38                                  sec
   167  6589 e560                                sbc tenexp
   168  658b aa                                  tax
   169  658c a92d                                lda #'-'                                 ; exponent is negative
   170                          
   171  658e 990101             l182_8           sta fbuffr+1,y                           ; store sign of exponent
   172  6591 a945                                lda #'E'
   173  6593 990001                              sta fbuffr,y                             ; store the 'E' character
   174  6596 8a                                  txa
   175                          
   176  6597 a22f                                ldx #'0'-1
   177  6599 38                                  sec
   178  659a e8                 l182_9           inx                                      ; move closer to output value
   179  659b e90a                                sbc #10                                  ; subtract 10
   180  659d b0fb                                bcs l182_9                               ; not negative yet
   181                          
   182  659f 693a                                adc #'9'+1                               ; get second output character
   183  65a1 990301                              sta fbuffr+3,y                           ; store high digit
   184  65a4 8a                                  txa
   185  65a5 990201                              sta fbuffr+2,y                           ; store low digit
   186  65a8 a900                                lda #0                                   ; put in terminator
   187  65aa 990401                              sta fbuffr+4,y
   188  65ad 8008                                bra fout20                               ; return
   189                          
   190                          
   191  65af 99ff00             fout19           sta fbuffr-1,y                           ; store the character
   192  65b2 a900               fout17           lda #0                                   ; store the terminator
   193  65b4 990001                              sta fbuffr,y
   194                          
   195  65b7 a900               fout20           lda #<fbuffr
   196  65b9 a001                                ldy #>fbuffr
   197  65bb 60                                  rts                                      ; all done
   198                          
   199                          
   200                          ; Exponentiation and Square Root Functions.
   201                          ;
   202                          ; square root function - sqr(a)
   203                          ; use sqr(x) = x^.5
   204                          
   205  65bc 20a362             sqr              jsr movaf                                ; move FAC into ARG
   206  65bf a914                                lda #<fhalf
   207  65c1 a05f                                ldy #>fhalf
   208                          
   209  65c3 200e62             fpwr             jsr movfm                                ; put memory into FAC    ARG^MEM
   210                          
   211                          
   212                          ; Last thing fetched is facexp into accx.
   213                          ;
   214                          ; Exponentiation --- x^y.
   215                          ; n.b. 0^0=1
   216                          ; First check if y=0, and if so the result is one.
   217                          ; Next  check if x=0, and if so the result is zero.
   218                          ; Then  check if x>0:
   219                          ; if not check that y is an integer.
   220                          ; if so negate x, so that lg doesn't give fcerr.
   221                          ; If x is negative and y is odd, negate the result returned by exp.
   222                          ; To compute the result use x^y = EXP((y*LOG(x))
   223                          
   224                          
   225  65c6 f03f               fpwrt            beq exp                                  ; if FAC=0, just exponentiate that  ARG^FAC
   226  65c8 a56a                                lda argexp                               ; is x=0?
   227  65ca f37ff8                              +lbeq zerof1                             ; zero FAC
   228                          
   229  65cd a250                                ldx #<tempf3                             ; save it for later in a temp
   230  65cf a000                                ldy #>tempf3
   231  65d1 203a62                              jsr movmf                                ; FAC->MEM
   232                          
   233  65d4 a56f                                lda argsgn                               ; note y=0 already. that's good, in case no one calls int.
   234  65d6 100f                                bpl l183_1                               ; no problems if x>0
   235  65d8 206363                              jsr int                                  ; integerize the FAC
   236  65db a950                                lda #<tempf3                             ; get addr of comperand
   237  65dd a000                                ldy #>tempf3
   238  65df 20f162                              jsr fcomp                                ; equal?
   239  65e2 d003                                bne l183_1                               ; leave x neg. log will blow him out
   240                          ;a=-1 and y is irrelavant
   241  65e4 98                                  tya                                      ; negative x. make positive
   242  65e5 a40a                                ldy integr                               ; get evenness
   243                          
   244  65e7 209562             l183_1           jsr movfa1                               ; alternate entry point.    ARG->FAC
   245  65ea 5a                                  phy                                      ; save evenness for later
   246  65eb 200e60                              jsr log                                  ; find log
   247  65ee a950                                lda #<tempf3                             ; multiply FAC times LOG(x)
   248  65f0 a000                                ldy #>tempf3
   249  65f2 206d60                              jsr fmult
   250  65f5 200766                              jsr exp                                  ; exponentiate the FAC
   251  65f8 68                                  pla
   252  65f9 4a                                  lsr                                      ; is it even?
   253  65fa 900a                                bcc negrts                               ; yes. or x>0
   254                          ;negate the number in FAC
   255                          
   256                          
   257                          negop                                                     ; /// entry point
   258  65fc a563                                lda facexp
   259  65fe f006                                beq negrts
   260  6600 a568                                lda facsgn
   261  6602 49ff                                eor #$ff
   262  6604 8568                                sta facsgn
   263  6606 60                 negrts           rts
   264                          

; ******** Source: basic.asm

; ******** Source: math/ext6.asm
     1                          
     2                          
     3                          
     4                          ; Exponentation Function
     5                          ;
     6                          ; First save the original argument and multiply the FAC by LOG2(e).  The
     7                          ; result is used to determine if overflow will occur since
     8                          ;
     9                          ;  EXP(x) = 2^(x*LOG2(e))
    10                          ;
    11                          ; where
    12                          ;  LOG2(e) = LOG(e), base 2
    13                          ;
    14                          ; Then save the integer part of this to scale the answer at the end, since
    15                          ; 2^y=2^INT(y)*2^(y-INT(y)) and 2^INT(y) are easy to compute.  Now compute
    16                          ;
    17                          ;  2^(x*LOG2(e)-INT(x*LOG2(e))
    18                          ; by
    19                          ;  p(LOG(2)*(INT(x*LOG2(e))+1)-x
    20                          ;
    21                          ; where p is an approximation polynomial. The result is then scaled by the
    22                          ; power of two previously saved.  Re: Taylor expansion.
    23                          
    24                          
    25  6607 a99e               exp              lda #<logeb2                             ; multiply by LOG(e) base 2
    26  6609 a05f                                ldy #>logeb2
    27  660b 204860                              jsr rommlt                               ; LOGEB2->ARG, FAC=FAC*ARG
    28  660e a571                                lda facov
    29  6610 6950                                adc #$50                                 ; ????
    30  6612 9003                                bcc l184_1
    31  6614 20ba62                              jsr incrnd
    32                          
    33  6617 8558               l184_1           sta oldov
    34  6619 20a662                              jsr movef                                ; to save in ARG without round.  ARG=FAC, facov=0)
    35  661c a563                                lda facexp
    36  661e c988                                cmp #$88                                 ; if ABS(FAC) >= 128, too big
    37  6620 9003                                bcc l184_3
    38                          
    39  6622 204361             l184_2           jsr mldvex                               ; overflow or overflow
    40  6625 206363             l184_3           jsr int                                  ; FAC=INT(FAC), uses facov
    41  6628 a50a                                lda integr                               ; get low part
    42  662a 18                                  clc
    43  662b 6981                                adc #$81
    44  662d f0f3                                beq l184_2                               ; overflow or overflow!!
    45                          
    46  662f 38                                  sec
    47  6630 e901                                sbc #1                                   ; subtract it
    48  6632 48                                  pha                                      ; save a while
    49                          
    50  6633 a205                                ldx #5                                   ; swap FAC and ARG
    51  6635 b56a               l184_4           lda argexp,x
    52  6637 b463                                ldy facexp,x
    53  6639 9563                                sta facexp,x
    54  663b 946a                                sty argexp,x
    55  663d ca                                  dex
    56  663e 10f5                                bpl l184_4
    57                          
    58  6640 a558                                lda oldov
    59  6642 8571                                sta facov
    60  6644 20a85d                              jsr fsubt                                ; FAC=ARG-FAC
    61  6647 20fc65                              jsr negop                                ; negate FAC
    62  664a a975                                lda #<expcon
    63  664c a05f                                ldy #>expcon
    64  664e 207066                              jsr poly
    65  6651 a900                                lda #0
    66  6653 8570                                sta arisgn                               ; multiply by positive 1.0
    67                          
    68  6655 68                                  pla                                      ; recall scale factor
    69  6656 202961                              jsr mldexp                               ; modify facexp and check for overflow
    70  6659 60                                  rts                                      ; (has to do jsr due to pla's in muldiv)

; ******** Source: basic.asm

; ******** Source: math/polyeval.asm
     1                          
     2                          
     3                          ; Polynomial Evaluator and the Random Number Generator.
     4                          ;
     5                          ; Evaluate  p(x^2)*x
     6                          ; The pointer to degree is in (a,y) and the constants follow the degree.
     7                          ; For x=FAC, compute  c0*x + c1*x^3 + c2*x^5 + c3*x^7 +...+ c(n)*x^(2*n+1)
     8                          
     9                          
    10  665a 8572               polyx            sta polypt                               ; retain polynomial pointer for later
    11  665c 8473                                sty polypt+1
    12  665e 203662                              jsr mov1f                                ; save FAC in factmp (y=0 upon return)
    13  6661 a959                                lda #tempf1
    14  6663 206d60                              jsr fmult                                ; compute x^2.
    15  6666 207466                              jsr poly1                                ; compute p(x^2).
    16  6669 a959                                lda #<tempf1
    17  666b a000                                ldy #>tempf1
    18  666d 83fef9                              +lbra fmult                              ; multiply by FAC again
    19                          
    20                          
    21                          ; Polynomial Evaluator
    22                          ;
    23                          ; Pointer to degree is in (a,y).
    24                          ; Compute:  c0+c1*x+c2*x^2+c3*x^3+c4*x^4...+c(n-1)*x^(n-1)+c(n)*x^n
    25                          ;  which is roughly (LOG(2)^n)/LOG(EXP(1))/n!
    26                          
    27                          
    28  6670 8572               poly             sta polypt
    29  6672 8473                                sty polypt+1
    30                          
    31  6674 203362             poly1            jsr mov2f                                ; save FAC (rounds, .y=0)
    32  6677 b172                                lda (polypt),y
    33  6679 8569                                sta degree
    34  667b e372                                inw polypt
    35  667d a572                                lda polypt
    36  667f a473                                ldy polypt+1
    37                          
    38  6681 204860             l185_1           jsr rommlt
    39  6684 a572                                lda polypt                               ; get current pointer
    40  6686 a473                                ldy polypt+1
    41  6688 18                                  clc
    42  6689 6905                                adc #5
    43  668b 9001                                bcc l185_2
    44  668d c8                                  iny
    45  668e 8572               l185_2           sta polypt
    46  6690 8473                                sty polypt+1
    47  6692 205160                              jsr romadd                               ; add in constant
    48  6695 a95e                                lda #<tempf2                             ; multiply the original FAC
    49  6697 a000                                ldy #>tempf2
    50  6699 c669                                dec degree                               ; done?
    51  669b d0e4                                bne l185_1
    52  669d 60                                  rts                                      ; yes
    53                          

; ******** Source: basic.asm

; ******** Source: math/ext7.asm
     1                          
     2                          
     3                          
     4                          ; Sine, Cosine, and Tangent Functions.
     5                          
     6                          
     7                          
     8                          ; Cosine function cos(x)=sin(x+pi/2)
     9                          
    10                          
    11  669e a923               cos              lda #<pi2                                ; pointer to pi/2
    12  66a0 a05f                                ldy #>pi2
    13  66a2 205160                              jsr romadd                               ; add it in.  fall into sine
    14                          
    15                          
    16                          
    17                          ; Sine function
    18                          ;
    19                          ; Use identities to get FAC in quadrants I or IV.  The FAC is divided by 2*pi
    20                          ; and the integer part is ignored because sin(x+2*pi)=sin(x).  Then the
    21                          ; argument can be compared with pi/2 by comparing the result of the division
    22                          ; with pi/2(2*pi)=1/4.  Identities are then used to get the result in quadrants
    23                          ; I or IV.  An approximation polynomial is then used to compute sin(x).
    24                          
    25                          
    26  66a5 20a362             sin              jsr movaf
    27  66a8 a928                                lda #<twopi                              ; get pointer to divisor
    28  66aa a05f                                ldy #>twopi
    29  66ac a66f                                ldx argsgn                               ; get sign of result
    30  66ae 207161                              jsr fdivf
    31  66b1 20a362                              jsr movaf                                ; get result into ARG
    32  66b4 206363                              jsr int                                  ; integerize FAC
    33  66b7 a900                                lda #0
    34  66b9 8570                                sta arisgn                               ; always have the same sign
    35  66bb 20a85d                              jsr fsubt                                ; keep only the fractional part
    36  66be a90a                                lda #<fr4                                ; get pointer to 1/4
    37  66c0 a05f                                ldy #>fr4
    38  66c2 205760                              jsr romsub
    39  66c5 a568                                lda facsgn                               ; save sign for later
    40  66c7 48                                  pha
    41  66c8 100d                                bpl sin1                                 ; first quadrant
    42  66ca 204d60                              jsr faddh                                ; add 1/2 to FAC
    43  66cd a568                                lda facsgn                               ; sign is negative?
    44  66cf 3009                                bmi sin2
    45  66d1 a514                                lda tansgn                               ; quads II and III come here
    46  66d3 49ff                                eor #$ff
    47  66d5 8514                                sta tansgn
    48                          
    49  66d7 20fc65             sin1             jsr negop                                ; if positive, negate it
    50                          
    51  66da a90a               sin2             lda #<fr4                                ; pointer to 1/4
    52  66dc a05f                                ldy #>fr4
    53  66de 205160                              jsr romadd                               ; add it in
    54  66e1 68                                  pla                                      ; get original quadrant
    55  66e2 1003                                bpl l186_1
    56  66e4 20fc65                              jsr negop                                ; if negative, negate result
    57                          
    58  66e7 a9b2               l186_1           lda #<sincon
    59  66e9 a05f                                ldy #>sincon
    60  66eb 836dff                              +lbra polyx                              ; do approximation polyomial
    61                          
    62                          
    63                          
    64                          ; Tangent function
    65                          
    66                          
    67  66ee 203662             tan              jsr mov1f                                ; move FAC into temporary
    68  66f1 a900                                lda #0
    69  66f3 8514                                sta tansgn                               ; remember whether to negate
    70  66f5 20a566                              jsr sin                                  ; compute the sin
    71  66f8 a250                                ldx #<tempf3
    72  66fa a000                                ldy #>tempf3
    73  66fc 203a62                              jsr movmf                                ; put sign into other temp
    74  66ff a959                                lda #<tempf1
    75  6701 a000                                ldy #>tempf1
    76  6703 200e62                              jsr movfm                                ; put this memory location into FAC
    77  6706 a900                                lda #0
    78  6708 8568                                sta facsgn                               ; start off positive
    79  670a a514                                lda tansgn
    80  670c 201c67                              jsr l187_1                               ; compute cosine
    81  670f a950                                lda #<tempf3
    82  6711 a000                                ldy #>tempf3                             ; address of sine value
    83                          ; bra fdiv ;divide sine by cosine and return
    84  6713 20f760                              jsr conupk                               ; unpack constant    [910226] FAB
    85  6716 f32fc7                              +lbeq overr                              ; overflow error     "
    86  6719 836afa                              +lbra fdivt                              ; "
    87                          
    88  671c 48                 l187_1           pha                                      ; cosc.
    89  671d 80b8                                bra sin1
    90                          
    91                          
    92                          ; Arctangent function
    93                          ;
    94                          ; Use identities to get arg between 0 and 1 and then use an approximation
    95                          ; polynomial to compute arctan(x).
    96                          
    97                          
    98  671f a568               atn              lda facsgn                               ; what is sign?
    99  6721 48                                  pha                                      ; save for later
   100  6722 1003                                bpl l188_1
   101  6724 20fc65                              jsr negop                                ; if negative, negate FAC
   102                          ;use arctan(x)=-arctan(-x)
   103  6727 a563               l188_1           lda facexp
   104  6729 48                                  pha                                      ; save this too for later
   105  672a c981                                cmp #$81                                 ; see if FAC >= 1.0
   106  672c 9007                                bcc l188_2                               ; it is less than 1
   107  672e a999                                lda #<fone                               ; get pntr to 1.0
   108  6730 a05f                                ldy #>fone
   109  6732 205d60                              jsr romdiv                               ; compute reciprocal
   110                          ;use aectan(x)=pi/2-arctan(1/x)
   111  6735 a9d1               l188_2           lda #<atncon                             ; pointer to arctan constants
   112  6737 a05f                                ldy #>atncon
   113  6739 205a66                              jsr polyx
   114  673c 68                                  pla
   115  673d c981                                cmp #$81                                 ; was original argument < 1?
   116  673f 9007                                bcc l188_3                               ; yes
   117  6741 a923                                lda #<pi2
   118  6743 a05f                                ldy #>pi2
   119  6745 205760                              jsr romsub                               ; subtract arctan from pi/2
   120                          
   121  6748 68                 l188_3           pla                                      ; was original aurgument positive?
   122  6749 1003                                bpl l188_4                               ; yes
   123  674b 83affe                              +lbra negop                              ; if negative, negate result
   124                          
   125  674e 60                 l188_4           rts                                      ; all done
   126                          

; ******** Source: basic.asm

; ******** Source: system/boot.asm
     1                          
     2                          
     3                          
     4                          ;****************************************************************************
     5                          ; BOOT  Boot has three modes of operation...
     6                          ;
     7                          ;   1. *B*LOAD a given binary file and SYS to its load address.
     8                          ;   2. *D*LOAD a BASIC file named AUTOBOOT.C65* and RUN it.
     9                          ;   3. BOOT SYS loads the home sector to $0400 and JMPs to it.
    10                          ;
    11                          ; For modes 1 & 2, syntax is the same as BLOAD.  Differentiate
    12                          ; between the two modes via the presence of a filename.  All other
    13                          ; parameters, such as drive and device numbers, are utilized in the
    14                          ; normal manner.  For mode 3 there are no options.  It's intended
    15                          ; to boot a new OS.  BASIC is turned off if it's successful.  If it
    16                          ; fails, the run time stack & sprites might be corrupted.
    17                          ;****************************************************************************
    18                          
    19  674f c99e               boot             cmp #sys_token                           ; BOOTSYS?      [910111]
    20  6751 d00d                                bne l189_1                               ; no
    21  6753 208322                              jsr chrget                               ; yes- eat token
    22  6756 2059ff                              jsr _bootsys                             ; attempt to boot a new OS
    23  6759 902f                                bcc l189_4                               ; returned to us after successful install
    24  675b a224                                ldx #errbdk                              ; bootsys failed, report 'bad disk'????
    25  675d 83f0c6                              +lbra error
    26                          
    27  6760 4f7e03             l189_1           bbr4 runmod,l189_2                       ; Error if in Edit mode     [910620]
    28  6763 83f4d5                              +lbra edit_err
    29                          
    30  6766 a900               l189_2           lda #0                                   ; BOOT "filename"     [910417]
    31  6768 850c                                sta verck                                ; want 'load', not 'verify'
    32  676a a9e6                                lda #$e6                                 ; set up parameters for DOS parser like BLOAD
    33  676c a2fc                                ldx #$fc
    34  676e 202274                              jsr dosprx                               ; parse the command
    35  6771 0f7f17                              bbr0 parsts,l189_5                       ; was there a filename?  branch if not
    36  6774 20ed71                              jsr bload_boot                           ; yes- bload it
    37  6777 b3bd00                              +lbcs erexit                             ; load error
    38                          
    39                          ; ldx current_bank ;assume no B(ank) arg was given    [910114]
    40                          ; bbr0 parstx,l189_3  ; correct, use current setup
    41  677a ae8c11                              ldx dosbnk                               ; else use given bank number
    42  677d 8602               l189_3           stx _bank
    43  677f a5ac                                lda _starting_addr                       ; set up address BLOAD loaded to
    44  6781 8504                                sta _pclo
    45  6783 a5ad                                lda _starting_addr+1
    46  6785 8503                                sta _pchi
    47  6787 206eff                              jsr _jsr_far                             ; call it
    48  678a 60                 l189_4           rts
    49                          
    50  678b a0ff               l189_5           ldy #$ff
    51  678d c8                 l189_6           iny                                      ; Copy default filename from ROM into buffer
    52  678e b92868                              lda autoboot_filename,y
    53  6791 999111                              sta savram,y
    54  6794 d0f7                                bne l189_6                               ; null terminated
    55                          
    56  6796 8c8511                              sty dosf1l                               ; length not counting terminator
    57  6799 e77e                                smb6 runmod                              ; set flag for load not to go to ready
    58  679b 207b71                              jsr dload_boot                           ; Load it
    59  679e b39600                              +lbcs erexit                             ; error if problems
    60  67a1 8320d6                              +lbra run_a_program                      ; else go run it
    61                          
    62                          
    63                          ; AUTOBOOT_CSG Runs a system diagnostic if PB0 is low after initialization.
    64                          ;  Diagnostic is copied to RAM-0 from ROM-2 and jumped to.
    65                          
    66                          autobootCSG                                               ; Run ROMed diagnostic if PB0 low   [911105]
    67  67a4 ad01dd                              lda $dd01
    68  67a7 4a                                  lsr
    69  67a8 b032                                bcs autoboot                             ; no, try to boot from disk
    70                          
    71  67aa 78                                  sei                                      ; prevent IRQ from wacking code DL'd to $1xxx  [911106]
    72  67ab a20b                                ldx #12-1
    73  67ad bdd067             l190_1           lda l190_2,x                             ; prep DMA list
    74  67b0 9d4401                              sta dma1_cmd,x
    75  67b3 ca                                  dex
    76  67b4 10f7                                bpl l190_1
    77                          
    78  67b6 a900                                lda #0
    79  67b8 a201                                ldx #>dma1_cmd                           ; copy program from ROM to RAM
    80  67ba a044                                ldy #<dma1_cmd
    81  67bc 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
    82  67bf 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
    83  67c2 8c00d7                              sty dma_ctlr                             ; dma_list lo & trigger
    84                          
    85                          ; jmp run_a_program ;if 'program' was BASIC
    86                          ; lda #0   ;else set up arg's for call to 'long jmp'  [911105]
    87  67c5 8502                                sta _bank
    88  67c7 8504                                sta _pclo
    89  67c9 a910                                lda #$10
    90  67cb 8503                                sta _pchi
    91  67cd 4c71ff                              jmp _jmp_far                             ; jump to code, no return.  NOTE: this *MAPs* RAM-0 into context!
    92                          
    93                          ; move from $024001 to $002001, $3FFF bytes  BASIC program
    94                          ;l190_2 .byte $00,$ff,$3f,$01,$40,$02,$01,$20,$00,$00,$00,$00
    95                          
    96                          ; move from $024000 to $1000, $4000 bytes   Diagnostic  [911105]
    97  67d0 0000400040020010...l190_2           !text $00,$00,$40,$00,$40,$02,$00,$10,$00,0,0,0
    98                          
    99                          
   100                          ; AUTOBOOT Attempts to RUN a disk program after cold startup.  The
   101                          ;  program must be a BASIC program called "AUTOBOOT.C65*"
   102                          
   103                          autoboot
   104  67dc a900                                lda #0                                   ; Select internal drive
   105  67de 8d80d0                              sta fdc
   106  67e1 2c82d0             l191_1           bit fdc+2                                ; busywait
   107  67e4 30fb                                bmi l191_1
   108  67e6 ad83d0                              lda fdc+3                                ; See if a diskette is present
   109  67e9 2908                                and #$08
   110  67eb f03a                                beq l191_3                               ; exit with no action taken if not
   111                          
   112  67ed a9e6                                lda #$e6                                 ; set up parameters for DOS parser like BLOAD
   113  67ef a2fc                                ldx #$fc
   114  67f1 202274                              jsr dosprx                               ; let the parser init DOS stuff
   115                          
   116  67f4 a0ff                                ldy #$ff
   117  67f6 c8                 l191_2           iny                                      ; Copy filename from ROM into buffer
   118  67f7 b92868                              lda autoboot_filename,y
   119  67fa 999111                              sta savram,y
   120  67fd d0f7                                bne l191_2                               ; null terminated
   121  67ff 8c8511                              sty dosf1l                               ; length not counting terminator
   122                          
   123  6802 a941                                lda #%01000001                           ; set flag for load indicating autoboot
   124  6804 857e                                sta runmod                               ; set flag for load not to go to ready
   125  6806 207b71                              jsr dload_boot                           ; skip parser & load it
   126                          
   127  6809 a900                                lda #0                                   ; clear autoboot flags
   128  680b 857e                                sta runmod
   129  680d da                                  phx                                      ; save end address
   130  680e 5a                                  phy
   131  680f 20b7ff                              jsr _readst                              ; get status report, but check it later
   132  6812 48                                  pha
   133  6813 209a78                              jsr Suck_DS                              ; clear any DOS errors (to kill error LED)
   134  6816 68                                  pla                                      ; now check I/O status
   135  6817 7a                                  ply
   136  6818 fa                                  plx
   137  6819 29bf                                and #$bf                                 ; EOI is okay
   138  681b d00a                                bne l191_3                               ; outside problems
   139  681d b008                                bcs l191_3                               ; inside problems
   140                          
   141  681f 8682                                stx text_top                             ; success- set end address & run it
   142  6821 8483                                sty text_top+1
   143  6823 58                                  cli
   144  6824 839dd5                              +lbra run_a_program
   145                          
   146  6827 60                 l191_3           rts                                      ; failure- go_ready
   147                          
   148                          
   149                          autoboot_filename
   150  6828 4155544f424f4f54...                 !text "AUTOBOOT.C65*",0
   151                          
   152                          
   153                          
   154                          
   155  6836 aa                 erexit           tax                                      ; set termination flags
   156  6837 d316c6                              +lbne error                              ; normal error
   157  683a 8395c4                              +lbra break_exit                         ; user break
   158                          
   159                          
   160                          
   161  683d 20d2ff             outch            jsr _bsout
   162  6840 b0f4                                bcs erexit
   163  6842 60                                  rts
   164                          
   165                          
   166                          
   167  6843 20cfff             inchr            jsr _basin
   168  6846 b0ee                                bcs erexit
   169  6848 60                                  rts
   170                          
   171                          
   172                          coout
   173                          ; jsr put_io_in_map
   174  6849 20c9ff                              jsr _chkout
   175  684c 20c169                              jsr dschk                                ; see if device # >=4, and clear DS if so
   176  684f b0e5                                bcs erexit                               ; take error exit of there was one
   177  6851 60                                  rts
   178                          
   179                          
   180                          coin
   181                          ; jsr put_io_in_map
   182  6852 20c6ff                              jsr _chkin
   183  6855 20c169                              jsr dschk                                ; see if device # >=4, and clear DS if so
   184  6858 b0dc                                bcs erexit
   185  685a 60                                  rts
   186                          
   187                          cgetl
   188                          ; jsr put_io_in_map
   189  685b 20e4ff                              jsr _getin
   190  685e b371c4                              +lbcs break_exit                         ; 'stop' key was pressed
   191  6861 60                                  rts
   192                          
   193                          
   194  6862 202569             save             jsr plsv                                 ; parse parameters, dschk
   195                          
   196                          
   197                          savenp                                                    ; Save Program (from DSave)
   198  6865 a682                                ldx text_top                             ; ending address
   199  6867 a483                                ldy text_top+1
   200  6869 a92d                                lda #<txttab                             ; pointer to start address
   201                          
   202                          
   203                          savenb                                                    ; Save Binary (from BSave & KEY SAVE)
   204                          ; jsr put_io_in_map
   205  686b 20d8ff                              jsr _savesp                              ; save it
   206                          
   207                          ; Any changes to the following code must be duplicated at:
   208                          ;  bload
   209                          ;  load (load_file)
   210                          
   211                          exit_disk_op
   212                          exit_disk_operation
   213  686e 08                                  php                                      ; preserve kernel error status (.c)
   214  686f 48                                  pha                                      ; preserve kernel error # (.a)
   215  6870 206e72                              jsr print_dos_error                      ; print DOS error msg if any only in direct mode
   216  6873 68                                  pla
   217  6874 28                                  plp
   218  6875 900f                                bcc l192_3                               ; branch if no error (rts)
   219  6877 ff7e0a                              bbs7 runmod,l192_2                       ; branch if run mode (erexit)
   220  687a c904                                cmp #errfnf                              ; is it 'file not found' catch-all?
   221  687c d005                                bne l192_1                               ; no  (erexit)
   222  687e 8dc702                              sta errnum                               ; yes- save error # for 'er'
   223  6881 0980                                ora #$80                                 ; but no errdis
   224  6883 38                 l192_1           sec
   225  6884 b0b0               l192_2           bcs erexit                               ; exit if kernel problem (rts)
   226  6886 60                 l192_3           rts
   227                          
   228                          
   229  6887 a901               verify           lda #1                                   ; verify flag
   230  6889 2c                                  !text $2c                                ; skip two bytes
   231                          
   232  688a a900               load             lda #0                                   ; load flag
   233  688c 850c                                sta verck
   234  688e 4f7e03             l193_1           bbr4 runmod,l193_2                       ; Error if in Edit mode     [910620]
   235  6891 83c6d4                              +lbra edit_err
   236  6894 202569             l193_2           jsr plsv                                 ; parse parameters, dschk
   237                          
   238                          cld10                                                     ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< entry from dload
   239                          ; jsr put_io_in_map
   240  6897 a50c                                lda verck
   241  6899 a62d                                ldx txttab                               ; .x and .y have alt...
   242  689b a42e                                ldy txttab+1                             ; ...load address
   243                          
   244                          ; Any changes to the following code must be duplicated at:
   245                          ;  bload
   246                          ;  save (exit_disk_op)
   247                          
   248                          load_file
   249  689d 20d5ff                              jsr _loadsp                              ; load it
   250  68a0 8f7e36                              bbs0 runmod,cld20                        ; skip error checks if autoboot (rts)
   251  68a3 da                                  phx                                      ; save end address
   252  68a4 5a                                  phy
   253  68a5 08                                  php                                      ; save kernel load status (.c)
   254  68a6 48                                  pha                                      ; save kernel error # (.a)
   255  68a7 20b7ff                              jsr _readst                              ; save I/O status byte
   256  68aa 857f                                sta parsts
   257  68ac 206e72                              jsr print_dos_error                      ; report error msg if any only in direct mode
   258  68af 68                                  pla                                      ; restore error stuff
   259  68b0 28                                  plp
   260  68b1 9010                                bcc l194_3                               ; branch if no error (rts)
   261  68b3 ff7e0a                              bbs7 runmod,l194_2                       ; branch if run mode (erexit)
   262  68b6 c904                                cmp #errfnf                              ; is it 'file not found' catch-all?
   263  68b8 d005                                bne l194_1                               ; no  (erexit)
   264  68ba 8dc702                              sta errnum                               ; yes- save error # for 'er'
   265  68bd 0980                                ora #$80                                 ; but no errdis
   266  68bf 38                 l194_1           sec
   267  68c0 b374ff             l194_2           +lbcs erexit                             ; exit if kernel problem
   268  68c3 7a                 l194_3           ply                                      ; restore end address
   269  68c4 fa                                  plx
   270  68c5 a50c                                lda verck
   271  68c7 f011                                beq cld50                                ; was load
   272                          
   273                          ; Finish verify
   274                          
   275                          verify_check
   276  68c9 a21c                                ldx #ervfy                               ; assume error
   277                          ; jsr _readst  ;read status
   278  68cb cf7f14                              bbs4 parsts,cld55                        ; branch if 'verify' error
   279  68ce ff7e08                              bbs7 runmod,cld20                        ; branch if not direct mode
   280                          verify_ok
   281  68d1 207dff                              jsr _primm
   282  68d4 0d4f4b0d00                          !text cr,"OK", cr,0
   283  68d9 60                 cld20            rts
   284                          
   285                          
   286                          
   287                          ; Finish load
   288                          
   289                          cld50
   290                          ; jsr _readst  ;check I/O status
   291  68da a57f                                lda parsts
   292  68dc 29bf                                and #%10111111                           ; EOI is okay, so mask it
   293  68de f005                                beq cld60                                ; good- finish load operation
   294                          
   295                          load_error
   296  68e0 a21d                                ldx #erload
   297  68e2 836bc5             cld55            +lbra error
   298                          
   299                          
   300  68e5 8682               cld60            stx text_top
   301  68e7 8483                                sty text_top+1                           ; end load address
   302                          
   303  68e9 ff7e0c                              bbs7 runmod,cld70                        ; branch if not direct mode
   304  68ec ef7eea                              bbs6 runmod,cld20                        ; special "RUN file_name" flag...get out here (rts)
   305                          
   306  68ef 20b930                              jsr link_program                         ; relink
   307  68f2 20a134                              jsr runc                                 ; clear vars
   308  68f5 83f6c5                              +lbra ready_2                            ; print 'ready' & return to main
   309                          
   310                          
   311                          ; Program load
   312                          
   313  68f8 201f35             cld70            jsr reset_txtptr
   314  68fb 20b930                              jsr link_program
   315  68fe 8306cc                              +lbra fload
   316                          
   317                          
   318  6901 207469             open             jsr paoc                                 ; parse statement
   319  6904 20c0ff                              jsr _open                                ; open it
   320  6907 8009                                bra close_out_1
   321                          
   322                          
   323                          
   324  6909 207469             close            jsr paoc                                 ; parse statement
   325                          ; jsr put_io_in_map
   326  690c a54b                                lda andmsk                               ; get la
   327                          
   328                          
   329                          close_out                                                 ; enter with .a=LA   [900725]
   330  690e 18                                  clc                                      ; flag a real close
   331  690f 20c3ff                              jsr _close                               ; close it
   332                          
   333                          close_out_1
   334  6912 08                                  php
   335  6913 48                                  pha
   336  6914 a5ba                                lda _fa                                  ; special error checking if disk op
   337  6916 c908                                cmp #8
   338  6918 9005                                bcc l195_1
   339  691a 68                                  pla
   340  691b 28                                  plp
   341  691c 8350ff                              +lbra exit_disk_operation                ; disk
   342                          
   343  691f 68                 l195_1           pla                                      ; something else
   344  6920 28                                  plp
   345  6921 b313ff                              +lbcs erexit
   346  6924 60                                  rts
   347                          
   348                          
   349                          ; Parse LOAD, SAVE, & VERIFY commands
   350                          
   351                          plsv
   352  6925 a900                                lda #0                                   ; set default filename (none)
   353  6927 20bdff                              jsr _setnam
   354  692a ae0611                              ldx _default_drive                       ; set default device # (dosffn)
   355  692d a000                                ldy #0                                   ; command 0
   356  692f 20baff                              jsr _setlfs
   357  6932 a584                                lda text_bank                            ; all loads to   bank 0 ???? set default memory banks
   358  6934 a685                                ldx var_bank                             ; all names from bank 1 ????   [910620]
   359  6936 206bff                              jsr _setbank
   360                          
   361  6939 206169                              jsr paoc20                               ; by-pass junk
   362  693c 20b869                              jsr paoc15                               ; get/set file name
   363  693f 206169                              jsr paoc20                               ; by-pass junk
   364  6942 205b69                              jsr plsv7                                ; get ',fa'
   365  6945 a000                                ldy #0                                   ; command 0
   366  6947 864b                                stx andmsk
   367  6949 20baff                              jsr _setlfs
   368  694c 206169                              jsr paoc20                               ; by-pass junk
   369  694f 205b69                              jsr plsv7                                ; get ',sa'
   370  6952 8a                                  txa                                      ; new command
   371  6953 a8                                  tay
   372  6954 a64b                                ldx andmsk                               ; device #
   373  6956 20baff                              jsr _setlfs
   374  6959 8066                                bra dschk                                ; make dosfa current   [900801]
   375                          
   376                          
   377                          
   378                          ; Look for comma followed by byte
   379                          
   380  695b 206969             plsv7            jsr paoc30
   381  695e 830cf4                              +lbra getbyt
   382                          
   383                          
   384                          
   385                          ; Skip return if next char is end
   386                          
   387  6961 208522             paoc20           jsr chrgot
   388  6964 d002                                bne paocx
   389  6966 68                                  pla
   390  6967 68                                  pla
   391  6968 60                 paocx            rts
   392                          
   393                          
   394                          
   395                          ; Check for comma and good stuff
   396                          
   397  6969 205b4e             paoc30           jsr chkcom                               ; check comma
   398                          
   399  696c 208522             paoc32           jsr chrgot                               ; get current character
   400  696f d0f7                                bne paocx                                ; is okay
   401  6971 83d7c4                              +lbra snerr                              ; bad...end of line
   402                          
   403                          
   404                          ; Parse OPEN/CLOSE
   405                          
   406  6974 a900               paoc             lda #sys_bank                            ; ????      [910620]
   407  6976 a685                                ldx var_bank                             ;
   408  6978 206bff                              jsr _setbank                             ; filename bank     (string bank)????
   409  697b 20bdff                              jsr _setnam                              ; default file name (null)
   410  697e 206c69                              jsr paoc32                               ; must get something
   411  6981 206c5d                              jsr getbyt                               ; get la
   412  6984 864b                                stx andmsk
   413  6986 8a                                  txa
   414  6987 ae0611                              ldx _default_drive                       ; default device
   415  698a a000                                ldy #0                                   ; default command
   416  698c 20baff                              jsr _setlfs                              ; store it
   417  698f 206169                              jsr paoc20                               ; skip junk
   418  6992 205b69                              jsr plsv7
   419  6995 864c                                stx eormsk
   420  6997 a000                                ldy #0                                   ; default sa (command)
   421  6999 a54b                                lda andmsk                               ; get la
   422  699b e003                                cpx #3
   423  699d 9001                                bcc l196_1
   424  699f 88                                  dey                                      ; if sa not given and fa=serial bus, default to $ff
   425  69a0 20baff             l196_1           jsr _setlfs                              ; store them
   426  69a3 206169                              jsr paoc20                               ; skip junk
   427  69a6 205b69                              jsr plsv7                                ; get sa
   428  69a9 8a                                  txa
   429  69aa a8                                  tay
   430  69ab a64c                                ldx eormsk
   431  69ad a54b                                lda andmsk
   432  69af 20baff                              jsr _setlfs                              ; set up real everything
   433  69b2 206169                              jsr paoc20
   434  69b5 206969                              jsr paoc30
   435                          
   436  69b8 20675b             paoc15           jsr frmstr                               ; do frmevl, frestr. return with len in a, index =~string
   437  69bb 20dd5b                              jsr getspa                               ; ????fixes old PET bug- load"string",val(chr$(56)) [910917]
   438                          ; ldx index1
   439                          ; ldy index1+1
   440  69be 20bdff                              jsr _setnam                              ; bank always set at plsv
   441                          ;fall into dschk     [900801]
   442                          
   443                          
   444                          
   445  69c1 08                 dschk            php                                      ; check if current device >=8, and clear DS if so
   446  69c2 48                                  pha
   447  69c3 a5ba                                lda _fa
   448  69c5 c901                                cmp #1
   449  69c7 d005                                bne l197_1
   450  69c9 ad0611                              lda _default_drive
   451  69cc 85ba                                sta _fa
   452  69ce c908               l197_1           cmp #8                                   ; ????     [900807]
   453  69d0 9006                                bcc l197_2
   454  69d2 8d8211                              sta dosfa                                ; also make last DOS device = current device
   455  69d5 208278                              jsr Clear_DS
   456  69d8 68                 l197_2           pla
   457  69d9 28                                  plp
   458  69da 60                                  rts
   459                          
   460                          
   461                          ;k_readst
   462                          ; jsr put_io_in_map
   463                          ; jmp _readst
   464                          
   465                          
   466                          
   467                          ;k_setlfs
   468                          ; jsr put_io_in_map
   469                          ; jmp _setlfs
   470                          
   471                          
   472                          
   473                          ;k_setnam
   474                          ; jsr put_io_in_map
   475                          ; jmp _setnam
   476                          
   477                          
   478                          
   479                          ;k_basin
   480                          ; jsr put_io_in_map
   481                          ; jmp _basin
   482                          
   483                          
   484                          ;k_bsout
   485                          ; jsr put_io_in_map
   486                          ; jmp _bsout
   487                          
   488                          
   489                          ;k_clrch
   490                          ; jsr put_io_in_map
   491                          ; jmp _clrch
   492                          
   493                          
   494                          
   495                          ;k_close
   496                          ; jsr put_io_in_map
   497                          ; jmp _close
   498                          
   499                          
   500                          
   501                          ;k_clall
   502                          ; jsr put_io_in_map
   503                          ; jmp _clall
   504                          
   505                          
   506                          
   507                          ;k_primm
   508                          ; jsr put_io_in_map
   509                          ; jmp _primm
   510                          
   511                          
   512                          ;k_setbank
   513                          ; jsr put_io_in_map
   514                          ; jmp _setbank
   515                          ; rts
   516                          
   517                          
   518                          ;k_plot
   519                          ; sta sw_rom_ram0  ;????
   520                          ; jmp _plot
   521                          
   522                          
   523                          ;k_stop
   524                          ; jsr put_io_in_map
   525                          ; jmp _stop
   526                          

; ******** Source: basic.asm

; ******** Source: command/print/using.asm
     1                          
     2                          
     3                          ; Print Using - Formatted print routine
     4                          ;
     5                          ; Entered by cmd, print, or print#
     6                          ; Syntax:  PRINT USING"****";a;b;c
     7                          
     8  69db 202c2e24           pudefs           !text " ,.$"                             ; default:  fill, comma, dec pnt, money symbol
     9                          
    10  69df a2ff               using            ldx #$ff
    11  69e1 8eeb11                              stx endfd
    12  69e4 208322                              jsr chrget
    13  69e7 20ef4c                              jsr frmevl                               ; evaluate format string
    14  69ea 20dd4c                              jsr chkstr                               ; must be string type...
    15                          
    16  69ed a566                                lda facmo                                ; save temp descriptor
    17  69ef 48                                  pha
    18  69f0 a567                                lda facmo+1
    19  69f2 48                                  pha
    20                          
    21  69f3 a002                                ldy #2                                   ; move (facmo),1&2 to form,form+1
    22  69f5 20a922             l198_1           jsr indfmo
    23  69f8 88                                  dey
    24  69f9 993f00                              sta form,y
    25  69fc d0f7                                bne l198_1
    26                          
    27  69fe 20a922                              jsr indfmo                               ; get length
    28  6a01 8dea11                              sta lfor
    29  6a04 a8                                  tay
    30  6a05 f00b                                beq l198_3                               ; syntax error if length is zero
    31                          
    32  6a07 88                 l198_2           dey
    33  6a08 209d22                              jsr indfrm
    34  6a0b c923                                cmp #'#'                                 ; at least one # in format?
    35  6a0d f006                                beq l198_4                               ; yes...
    36  6a0f 98                                  tya                                      ; no...end of format
    37  6a10 d0f5                                bne l198_2                               ; no...
    38  6a12 8336c4             l198_3           +lbra snerr                              ; yes...syntax error
    39                          
    40                          
    41  6a15 a93b               l198_4           lda #';'                                 ; '
    42  6a17 205d4e             eex2             jsr synchr                               ; check character
    43  6a1a 8476                                sty z_p_temp_1                           ; clear flag for anaf
    44  6a1c 8cd811                              sty bnr                                  ; set pointer to begin of no
    45  6a1f 20ef4c                              jsr frmevl                               ; evaluate expression
    46  6a22 7f0f39                              bbr7 valtyp,conv                         ; branch if numeric
    47                          
    48  6a25 20536c                              jsr ini                                  ; init counters and flags
    49  6a28 20a16d                              jsr anaf                                 ; analyze format
    50  6a2b aee011                              ldx chsn                                 ; > or = in format field
    51  6a2e f015                                beq prcha                                ; branch if not
    52  6a30 a200                                ldx #0
    53  6a32 38                                  sec
    54  6a33 ade611                              lda cform
    55  6a36 e577                                sbc hulp                                 ; .a=room left in field
    56  6a38 900b                                bcc prcha                                ; branch if no room left
    57  6a3a a23d                                ldx #'='
    58  6a3c ece011                              cpx chsn                                 ; = in field
    59  6a3f d003                                bne l199_1                               ; branch if not
    60  6a41 4a                                  lsr                                      ; .a=.a/2
    61  6a42 6900                                adc #0                                   ; add 1 if odd
    62                          
    63  6a44 aa                 l199_1           tax                                      ; store no of blanks in x
    64  6a45 a000               prcha            ldy #0
    65  6a47 8a                 chx              txa
    66  6a48 f005                                beq cpef                                 ; branch if no blanks
    67  6a4a ca                                  dex
    68                          
    69  6a4b a920               oblk             lda #' '                                 ; output a blank
    70  6a4d 8008                                bra outc                                 ; always
    71                          
    72                          
    73  6a4f c477               cpef             cpy hulp                                 ; end of string reached?
    74  6a51 b0f8                                bcs oblk                                 ; output blank if yes
    75  6a53 20d522                              jsr indin1_ram1                          ; lda (index),y
    76  6a56 c8                                  iny
    77                          
    78  6a57 209a6d             outc             jsr cdout                                ; output character
    79  6a5a d0eb                                bne chx                                  ; branch if not ready
    80  6a5c 8029                                bra reay
    81                          
    82                          
    83                          
    84  6a5e 208f64             conv             jsr fout                                 ; convert mfp to decimal
    85                          
    86  6a61 a0ff                                ldy #$ff                                 ; build descriptor for fout string
    87  6a63 c8                 l200_1           iny                                      ; how big IS it?
    88  6a64 b90001                              lda fbuffr,y
    89  6a67 d0fa                                bne l200_1
    90  6a69 98                                  tya
    91  6a6a 207b5a                              jsr strspa                               ; jsr getspa,stx dsctmp+1,sty dsctmp+2,sta dsctmp,rts
    92                          
    93  6a6d da                                  phx
    94  6a6e a000                                ldy #0
    95  6a70 a264                                ldx #dsctmp+1
    96  6a72 b90001             l200_2           lda fbuffr,y
    97  6a75 f006                                beq l200_3
    98  6a77 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
    99  6a7a c8                                  iny
   100  6a7b d0f5                                bne l200_2
   101                          
   102  6a7d fa                 l200_3           plx
   103  6a7e 20d05a                              jsr putnew
   104  6a81 20536c                              jsr ini                                  ; init counters and flags
   105  6a84 20a46a                              jsr fform                                ; output one formatted number
   106                          
   107  6a87 208522             reay             jsr chrgot                               ; get old character
   108  6a8a c92c                                cmp #','                                 ; comma?
   109  6a8c f089                                beq eex2                                 ; continue print use if yes
   110  6a8e 38                                  sec
   111  6a8f 6676                                ror z_p_temp_1                           ; set flag for anaf
   112  6a91 20a16d                              jsr anaf                                 ; print rest of format
   113  6a94 7a                                  ply                                      ; restore descriptor
   114  6a95 68                                  pla
   115  6a96 20715b                              jsr fretmp
   116  6a99 208522                              jsr chrgot
   117  6a9c c93b                                cmp #';'                                 ; semi-colon?
   118  6a9e d357cd                              +lbne crdo                               ; end of print using
   119  6aa1 4c8322                              jmp chrget                               ; branch if yes

; ******** Source: basic.asm

; ******** Source: command/fform.asm
     1                          
     2                          
     3                          ;  FFORM - output a number to format
     4                          ;
     5                          ;  Number is in fbuffr,  format checked by anaf
     6                          
     7                          fform
     8                          ; sta sw_rom_ram0 ;????
     9  6aa4 add411                              lda pufill
    10  6aa7 8de811                              sta blfd                                 ; set working fill char
    11  6aaa a9ff                                lda #$ff
    12  6aac 8de711             ana              sta sno                                  ; save blank or '-' in sno
    13  6aaf 8002                                bra insy
    14                          
    15                          
    16  6ab1 867f               stp              stx point                                ; set point pointer
    17  6ab3 c477               insy             cpy hulp                                 ; end of no reached?
    18  6ab5 f032                                beq eoa                                  ; branch if yes
    19  6ab7 b90001                              lda fbuffr,y                             ; get character of no
    20  6aba c8                                  iny
    21  6abb c920                                cmp #' '                                 ; blank?
    22  6abd f0f4                                beq insy                                 ; yes...span
    23  6abf c92d                                cmp #'-'                                 ; sign no negative
    24  6ac1 f0e9                                beq ana                                  ; yes...
    25  6ac3 c92e                                cmp #'.'                                 ; decimal point?
    26  6ac5 f0ea                                beq stp                                  ; yes...
    27  6ac7 c945                                cmp #'E'                                 ; is char 'e'?
    28  6ac9 f010                                beq lsg                                  ; yes...
    29  6acb 9d0001                              sta fbuffr,x                             ; move number
    30  6ace 8ed911                              stx enr                                  ; update end-no pointer
    31  6ad1 e8                                  inx
    32  6ad2 247f                                bit point                                ; point pointer set?
    33  6ad4 10dd                                bpl insy                                 ; yes...
    34  6ad6 eedf11                              inc vn                                   ; count digits before point
    35  6ad9 80d8                                bra insy
    36                          
    37                          
    38  6adb b90001             lsg              lda fbuffr,y
    39  6ade c92d                                cmp #'-'                                 ; sign of exponent negative
    40  6ae0 d003                                bne l201_1                               ; no...
    41  6ae2 6edd11                              ror usgn                                 ; make sign negative
    42  6ae5 c8                 l201_1           iny
    43  6ae6 8cde11                              sty uexp                                 ; set exponent pointer
    44                          
    45  6ae9 a57f               eoa              lda point                                ; decimal found?
    46  6aeb 1002                                bpl l202_1                               ; yes...
    47  6aed 867f                                stx point                                ; no...add point
    48                          
    49  6aef 20a16d             l202_1           jsr anaf                                 ; analyze format
    50  6af2 ade111                              lda vf
    51  6af5 c9ff                                cmp #$ff
    52  6af7 f029                                beq l202_3                               ; field overflow
    53  6af9 ade411                              lda fesp                                 ; exponent in field
    54  6afc f03f                                beq cff                                  ; convert to f format if not
    55  6afe adde11                              lda uexp                                 ; exponent in number?
    56  6b01 d012                                bne l202_2                               ; yes...
    57  6b03 aed911                              ldx enr
    58  6b06 20286c                              jsr et2                                  ; add exponent to number
    59  6b09 de0201                              dec fbuffr+2,x
    60  6b0c e8                                  inx
    61  6b0d 8ede11                              stx uexp
    62  6b10 20af6c                              jsr alg                                  ; delete leading zeros
    63  6b13 f025                                beq hup                                  ; all zero
    64                          
    65  6b15 ace311             l202_2           ldy posp                                 ; + or - in format?
    66  6b18 d017                                bne sswe                                 ; yes...
    67  6b1a ace711                              ldy sno                                  ; +?
    68  6b1d 3012                                bmi sswe                                 ; yes...
    69  6b1f ade111                              lda vf
    70                          
    71  6b22 f068               l202_3           beq errf                                 ; no room for sign
    72  6b24 cee111                              dec vf                                   ; reserve room
    73  6b27 d005                                bne l202_4
    74  6b29 ade211                              lda nf                                   ; one #?
    75  6b2c f05e                                beq errf                                 ; yes...error
    76                          
    77  6b2e eedc11             l202_4           inc swe
    78                          
    79  6b31 20a36b             sswe             jsr shpn                                 ; shift decimal point
    80  6b34 206d6c                              jsr uround                               ; round number
    81  6b37 20a36b                              jsr shpn                                 ; shift again if necessary
    82                          
    83  6b3a 839401             hup              +lbra chout                              ; output number
    84                          
    85                          
    86                          
    87  6b3d acde11             cff              ldy uexp                                 ; exponent in no?
    88  6b40 f015                                beq l203_2                               ; no...
    89  6b42 8577                                sta hulp                                 ; delete exponent
    90  6b44 38                                  sec                                      ; adjust decimal point
    91  6b45 6ee511                              ror etof                                 ; set e-to-f flag
    92  6b48 a47f                                ldy point
    93  6b4a addd11                              lda usgn                                 ; exec nos3 or nos4
    94  6b4d 1005                                bpl l203_1                               ; depends on sign of exp
    95  6b4f 20db6b                              jsr nos3
    96  6b52 800c                                bra l203_3
    97                          
    98  6b54 20bd6b             l203_1           jsr nos4
    99                          
   100  6b57 a47f               l203_2           ldy point                                ; at start of no?
   101  6b59 f005                                beq l203_3                               ; yes...
   102  6b5b 20b36c                              jsr cho                                  ; no = 0 ?
   103  6b5e f005                                beq l203_4                               ; yes...no round
   104                          
   105  6b60 206d6c             l203_3           jsr uround
   106  6b63 8003                                bra l203_5
   107                          
   108  6b65 cedf11             l203_4           dec vn                                   ; adjust...no was 0
   109  6b68 38                 l203_5           sec
   110  6b69 ade111                              lda vf
   111  6b6c eddf11                              sbc vn
   112  6b6f 901b                                bcc errf                                 ; no fit...error
   113  6b71 8ddc11                              sta swe                                  ; save difference
   114  6b74 ace311                              ldy posp                                 ; + or -?
   115  6b77 d01b                                bne ahp                                  ; yes...
   116  6b79 ace711                              ldy sno                                  ; get sign
   117  6b7c 3016                                bmi ahp                                  ; positive...
   118  6b7e a8                                  tay
   119  6b7f f00b                                beq errf                                 ; no room for sign
   120  6b81 88                                  dey
   121  6b82 d013                                bne ldvn                                 ; swe<>1
   122  6b84 ade211                              lda nf
   123  6b87 0ddf11                              ora vn                                   ; both zero?
   124  6b8a d0ae                                bne hup                                  ; no...
   125                          
   126                          
   127  6b8c a92a               errf             lda #'*'                                 ; format error
   128  6b8e 209a6d             stout            jsr cdout                                ; fill field with stars
   129  6b91 d0fb                                bne stout
   130  6b93 60                                  rts
   131                          
   132                          
   133  6b94 a8                 ahp              tay                                      ; output no if swe=0
   134  6b95 f0a3                                beq hup
   135  6b97 addf11             ldvn             lda vn
   136  6b9a d09e                                bne hup                                  ; vn<>0
   137  6b9c cedc11                              dec swe                                  ; add extra 0
   138  6b9f e676                                inc z_p_temp_1                           ; before decimal point
   139  6ba1 8097                                bra hup
   140                          
   141                          
   142                          ; Using- shift decimal point
   143                          
   144  6ba3 38                 shpn             sec
   145  6ba4 ade111                              lda vf
   146  6ba7 eddf11                              sbc vn
   147  6baa f038                                beq rdy                                  ; format o.k
   148  6bac a47f                                ldy point
   149  6bae 9016                                bcc pntl                                 ; vf<vn
   150  6bb0 8577                                sta hulp
   151                          
   152  6bb2 ccd911             incy             cpy enr                                  ; end of no reached?
   153  6bb5 f002                                beq ity
   154  6bb7 b001                                bcs nos1                                 ; yes...
   155                          
   156  6bb9 c8                 ity              iny
   157  6bba eedf11             nos1             inc vn
   158  6bbd 20f16b             nos4             jsr eado                                 ; adjust exponent
   159  6bc0 c677                                dec hulp                                 ; ready?
   160  6bc2 d0ee                                bne incy                                 ; no...
   161  6bc4 f01c                                beq poit
   162                          
   163  6bc6 49ff               pntl             eor #$ff
   164  6bc8 6901                                adc #1
   165  6bca 8577                                sta hulp                                 ; =vn-vf
   166                          
   167  6bcc ccd811             decy             cpy bnr                                  ; begin of no?
   168  6bcf f006                                beq inz1                                 ; yes...
   169  6bd1 88                                  dey
   170  6bd2 cedf11                              dec vn
   171  6bd5 8002                                bra inz2
   172                          
   173                          
   174  6bd7 e676               inz1             inc z_p_temp_1                           ; add leading zeros
   175  6bd9 a980               inz2             lda #$80
   176  6bdb 20f36b             nos3             jsr eadj                                 ; adjust exponent
   177  6bde c677                                dec hulp                                 ; ready?
   178  6be0 d0ea                                bne decy                                 ; no...
   179                          
   180  6be2 847f               poit             sty point                                ; decimal point pointer
   181  6be4 60                 rdy              rts
   182                          
   183                          
   184                          ; Using- adjust exponent
   185                          
   186  6be5 d039               sexp             bne retrn                                ; no over/underflow
   187  6be7 4909                                eor #$09                                 ; .a is 0 or 9
   188  6be9 9d0001                              sta fbuffr,x                             ; digit back in exp
   189  6bec ca                                  dex                                      ; = 0 or 9
   190  6bed ecde11                              cpx uexp
   191  6bf0 60                                  rts
   192                          
   193                          
   194  6bf1 a900               eado             lda #0
   195  6bf3 aede11             eadj             ldx uexp
   196  6bf6 e8                                  inx
   197  6bf7 2ce511                              bit etof                                 ; e-to-f flag on?
   198  6bfa 3010                                bmi l204_2                               ; yes...
   199  6bfc 4ddd11                              eor usgn
   200  6bff f00b                                beq l204_2                               ; ++ or --
   201                          
   202  6c01 20366c             l204_1           jsr tag3                                 ; inc exp, overflow?
   203  6c04 20e56b                              jsr sexp                                 ; digit 0 if yes
   204  6c07 b0f8                                bcs l204_1                               ; try second digit
   205  6c09 833cc2                              +lbra overr                              ; exp>99
   206                          
   207  6c0c bd0001             l204_2           lda fbuffr,x
   208  6c0f de0001                              dec fbuffr,x                             ; decrement exp
   209  6c12 c930                                cmp #'0'                                 ; underflow on digit?
   210  6c14 20e56b                              jsr sexp                                 ; set digit=9 if yes...
   211  6c17 b0f3                                bcs l204_2                               ; try 2nd digit
   212  6c19 2ce511                              bit etof                                 ; flag off?
   213  6c1c 1005                                bpl et3                                  ; yes...
   214  6c1e 847f                                sty point                                ; decimal point pointer
   215                          
   216  6c20 68                 retrn            pla
   217  6c21 68                                  pla
   218  6c22 60                                  rts                                      ; return to fform/main
   219                          
   220                          
   221  6c23 addd11             et3              lda usgn
   222  6c26 4980                                eor #$80                                 ; reverse sign exp
   223  6c28 8ddd11             et2              sta usgn
   224  6c2b a930                                lda #'0'
   225  6c2d 9d0101                              sta fbuffr+1,x                           ; exp<0 here
   226  6c30 a931                                lda #'1'
   227  6c32 9d0201                              sta fbuffr+2,x
   228  6c35 60                                  rts
   229                          
   230                          
   231  6c36 bd0001             tag3             lda fbuffr,x                             ; get digit of exp
   232  6c39 fe0001                              inc fbuffr,x                             ; increment digit
   233  6c3c c939                                cmp #'9'                                 ; overflow
   234  6c3e 60                                  rts                                      ; return .z set
   235                          
   236                          
   237                          ; Using- ansub: load format field char in .a
   238                          
   239  6c3f 18                 ansub            clc
   240  6c40 c8                                  iny                                      ; begin format?
   241  6c41 f005                                beq l205_1                               ; yes...
   242  6c43 ccea11                              cpy lfor                                 ; end?
   243  6c46 9004                                bcc l205_2                               ; no...
   244                          
   245  6c48 a476               l205_1           ldy z_p_temp_1                           ; <>0?
   246  6c4a d0d4                                bne retrn                                ; yes...
   247                          
   248  6c4c 209d22             l205_2           jsr indfrm
   249  6c4f eee611                              inc cform                                ; pointer to field
   250  6c52 60                                  rts
   251                          
   252                          
   253                          ;  Using- ini: init counters and flags
   254                          
   255  6c53 206d5b             ini              jsr frefac                               ; free temp descriptor
   256  6c56 8577                                sta hulp                                 ; length string
   257  6c58 a20a                                ldx #$0a                                 ; printed in hulp
   258  6c5a a900                                lda #0
   259                          
   260  6c5c 9ddc11             l206_1           sta swe,x                                ; init working registers
   261  6c5f ca                                  dex
   262  6c60 10fa                                bpl l206_1
   263  6c62 8edb11                              stx flag                                 ; comma flag =ff
   264  6c65 867f                                stx point                                ; point pointer=ff
   265  6c67 8eda11                              stx dolr                                 ; dollar flag=ff
   266  6c6a aa                                  tax                                      ; x=y=0
   267  6c6b a8                                  tay
   268  6c6c 60                                  rts
   269                          
   270                          
   271                          ; Using- round number
   272                          
   273  6c6d 18                 uround           clc
   274  6c6e a57f                                lda point
   275  6c70 6de211                              adc nf                                   ; overflow?
   276  6c73 b039                                bcs rrts                                 ; yes...
   277  6c75 38                                  sec
   278  6c76 e576                                sbc z_p_temp_1                           ; underflow?
   279  6c78 9034                                bcc rrts                                 ; yes...
   280  6c7a cdd911                              cmp enr                                  ; anything to round?
   281  6c7d f002                                beq l207_1                               ; yes...
   282  6c7f b02d                                bcs rrts                                 ; no...
   283                          
   284  6c81 cdd811             l207_1           cmp bnr                                  ; again...
   285  6c84 9028                                bcc rrts                                 ; no...
   286  6c86 aa                                  tax
   287  6c87 bd0001                              lda fbuffr,x                             ; get digit
   288  6c8a c935                                cmp #'5'                                 ; <5 ?
   289  6c8c 9020                                bcc rrts                                 ; yes...no round
   290                          
   291  6c8e ecd811             l207_2           cpx bnr                                  ; begin of no reached?
   292  6c91 f00a                                beq l207_3                               ; yes..add 1
   293  6c93 ca                                  dex
   294  6c94 20366c                              jsr tag3                                 ; increment digit
   295  6c97 8ed911                              stx enr                                  ; new end of no pointer
   296  6c9a f0f2                                beq l207_2                               ; branch on overflow
   297  6c9c 60                                  rts
   298                          
   299  6c9d a931               l207_3           lda #'1'
   300  6c9f 9d0001                              sta fbuffr,x
   301  6ca2 e8                                  inx
   302  6ca3 867f                                stx point
   303  6ca5 c676                                dec z_p_temp_1                           ; # of 0's before '.'
   304  6ca7 1005                                bpl rrts                                 ; no underflow
   305  6ca9 e676                                inc z_p_temp_1                           ; underflow...back to 0
   306  6cab eedf11                              inc vn
   307  6cae 60                 rrts             rts
   308                          
   309                          
   310                          ; Using- alg: delete leading zeros of no
   311                          
   312  6caf a47f               alg              ldy point                                ; start with a .?
   313  6cb1 f017                                beq szer                                 ; yes...
   314                          
   315  6cb3 acd811             cho              ldy bnr
   316  6cb6 b90001             cmo              lda fbuffr,y                             ; start with a 0?
   317  6cb9 c930                                cmp #'0'
   318  6cbb 60                                  rts
   319                          
   320                          
   321  6cbc e67f               nbr              inc point                                ; adjust point
   322  6cbe 20f16b                              jsr eado                                 ; and exponent
   323  6cc1 eed811                              inc bnr                                  ; and pointer to begin of no
   324  6cc4 ccd911                              cpy enr                                  ; end of number?
   325  6cc7 f0e5                                beq rrts                                 ; yes...
   326  6cc9 c8                                  iny
   327                          
   328  6cca 20b66c             szer             jsr cmo                                  ; zero in no?
   329  6ccd f0ed                                beq nbr                                  ; yes...
   330  6ccf 60                                  rts                                      ; no...
   331                          
   332                          
   333                          ; Using- chout: print number
   334                          
   335  6cd0 adda11             chout            lda dolr                                 ; dollar flag set?
   336  6cd3 3002                                bmi l208_1                               ; no...
   337  6cd5 e676                                inc z_p_temp_1                           ; make room for $
   338                          
   339  6cd7 aed811             l208_1           ldx bnr                                  ; start of #
   340  6cda ca                                  dex
   341  6cdb ace911                              ldy begfd                                ; begin of field
   342                          
   343  6cde 209d22             afrm             jsr indfrm
   344  6ce1 c8                                  iny
   345  6ce2 c92c                                cmp #','                                 ; comma?
   346  6ce4 d00f                                bne punt                                 ; no...
   347  6ce6 2cdb11                              bit flag                                 ; comma flag on?
   348  6ce9 3005                                bmi bout                                 ; yes, do a fill char
   349                          ; sta sw_rom_ram0 ;????
   350  6ceb add511                              lda pucoma
   351  6cee 8064                                bra out                                  ; no,...output a comma char
   352                          
   353                          
   354  6cf0 ade811             bout             lda blfd
   355  6cf3 805f                                bra out
   356                          
   357                          
   358  6cf5 c92e               punt             cmp #'.'                                 ; decimal point?
   359  6cf7 d005                                bne afplus
   360                          ; sta sw_rom_ram0 ;????
   361  6cf9 add611                              lda pudot                                ; yes...
   362  6cfc 8056                                bra out
   363                          
   364                          
   365  6cfe c92b               afplus           cmp #'+'                                 ; plus?
   366  6d00 f03a                                beq ispl                                 ; yes...
   367  6d02 c92d                                cmp #'-'                                 ; minus?
   368  6d04 f031                                beq ispl1                                ; yes...
   369  6d06 c95e                                cmp #'^'                                 ; up arrow?
   370  6d08 d070                                bne pndd                                 ; no...
   371  6d0a a945                                lda #'E'
   372  6d0c 209a6d                              jsr cdout
   373  6d0f acde11                              ldy uexp
   374  6d12 20b66c                              jsr cmo                                  ; first dig of exp zero?
   375  6d15 d006                                bne l209_1                               ; no...
   376  6d17 c8                                  iny
   377  6d18 20b66c                              jsr cmo                                  ; second digit?
   378  6d1b f007                                beq l209_2                               ; yes
   379                          
   380  6d1d a92d               l209_1           lda #'-'
   381  6d1f 2cdd11                              bit usgn
   382  6d22 3002                                bmi l209_3
   383                          
   384  6d24 a92b               l209_2           lda #'+'
   385  6d26 209a6d             l209_3           jsr cdout                                ; output sign exp
   386  6d29 aede11                              ldx uexp
   387  6d2c bd0001                              lda fbuffr,x
   388  6d2f 209a6d                              jsr cdout                                ; output first dig exp
   389  6d32 aceb11                              ldy endfd
   390  6d35 8013                                bra telx
   391                          
   392  6d37 ade711             ispl1            lda sno                                  ; positive?
   393  6d3a 30b4                                bmi bout                                 ; yes...out blank or *
   394  6d3c ade711             ispl             lda sno                                  ; output sgn
   395  6d3f 8013                                bra out
   396                          
   397                          
   398  6d41 a576               zerot            lda z_p_temp_1                           ; # of zeros
   399  6d43 d017                                bne zerot1
   400  6d45 ecd911                              cpx enr                                  ; end of # reached?
   401  6d48 f005                                beq zout                                 ; yes...output zero
   402                          
   403  6d4a e8                 telx             inx
   404  6d4b bd0001                              lda fbuffr,x                             ; get digit
   405  6d4e 2c                                  !text $2c                                ; skip
   406                          
   407  6d4f a930               zout             lda #'0'                                 ; output zero
   408                          
   409  6d51 4edb11             outs             lsr flag                                 ; clear comma flag
   410                          
   411  6d54 209a6d             out              jsr cdout                                ; output character
   412  6d57 f355ff                              +lbeq rrts
   413  6d5a 8082                                bra afrm                                 ; not ready...
   414                          
   415                          
   416  6d5c c676               zerot1           dec z_p_temp_1                           ; count leading zeros
   417  6d5e adda11                              lda dolr                                 ; $ flag set?
   418  6d61 30ec                                bmi zout                                 ; no...output zero
   419                          
   420  6d63 209d22                              jsr indfrm                               ; take a peek at the next character in the format string
   421  6d66 c92c                                cmp #','                                 ; if it's a comma, we got problems
   422  6d68 d007                                bne l210_1                               ; ...branch if no comma & resume normal processing
   423                          
   424  6d6a ade811                              lda blfd                                 ; here's the "$,999.99" bug fix:
   425  6d6d 209a6d                              jsr cdout                                ; print a 'fill' character instead of the '$'
   426  6d70 c8                                  iny                                      ; and increment format string pointer past comma
   427                          
   428  6d71 38                 l210_1           sec                                      ; resume normal processing
   429  6d72 6eda11                              ror dolr                                 ; clear the dollar flag & go on to print '$'
   430                          ; sta sw_rom_ram0 ;????
   431  6d75 add711                              lda pumony
   432  6d78 80d7                                bra outs                                 ; output money symbol
   433                          
   434                          
   435  6d7a addc11             pndd             lda swe                                  ; # of blanks
   436  6d7d f0c2                                beq zerot
   437  6d7f cedc11                              dec swe                                  ; count !
   438                          
   439  6d82 d36cff             l211_1           +lbne bout                               ; out blank or *
   440  6d85 ade311                              lda posp                                 ; + or - in field?
   441  6d88 30f8                                bmi l211_1                               ; yes...out blank or *
   442                          
   443  6d8a 209d22             l211_2           jsr indfrm
   444  6d8d c92c                                cmp #','                                 ; comma?
   445  6d8f d0a6                                bne ispl1                                ; no...out sign
   446  6d91 ade811                              lda blfd                                 ; yes...
   447  6d94 209a6d                              jsr cdout                                ; out blank or *
   448  6d97 c8                                  iny
   449  6d98 80f0                                bra l211_2
   450                          
   451                          
   452                          
   453  6d9a 203d68             cdout            jsr outch ;outdo                         ; char out
   454  6d9d cee611                              dec cform                                ; count it
   455  6da0 60                                  rts
   456                          
   457                          
   458                          ; Using- anaf: analyze format
   459                          
   460  6da1 aceb11             anaf             ldy endfd                                ; format pointer
   461  6da4 203f6c             gfor             jsr ansub
   462  6da7 20536e                              jsr comp                                 ; check special chars
   463  6daa d014                                bne pchar                                ; no match...
   464  6dac 8ce911                              sty begfd                                ; save beginning of field
   465  6daf 9019                                bcc ffoun                                ; # was found
   466  6db1 aa                                  tax                                      ; save char
   467                          
   468  6db2 203f6c             sfur             jsr ansub                                ; get next format char
   469  6db5 b005                                bcs l212_1                               ; stop on wrap-around
   470  6db7 205b6e                              jsr com1                                 ; compare specials
   471  6dba f009                                beq foun1                                ; found some...
   472                          
   473  6dbc ace911             l212_1           ldy begfd
   474  6dbf 8a                                  txa
   475  6dc0 203d68             pchar            jsr outch ;outdo                         ; out character
   476  6dc3 80df                                bra gfor
   477                          
   478                          
   479  6dc5 b0eb               foun1            bcs sfur                                 ; no #...keep looking
   480  6dc7 ace911                              ldy begfd
   481  6dca a676               ffoun            ldx z_p_temp_1
   482  6dcc d078                                bne trts
   483  6dce 8ee611                              stx cform
   484  6dd1 88                                  dey
   485                          
   486  6dd2 cee611             hyo2             dec cform                                ; correct counter
   487  6dd5 203f6c             hyo              jsr ansub                                ; get next format char
   488  6dd8 b072                                bcs efo                                  ; end of format
   489  6dda c92c                                cmp #','                                 ; comma?
   490  6ddc f0f7                                beq hyo                                  ; yes...ignore it
   491  6dde 202a6e                              jsr isp                                  ; + or - in format?
   492  6de1 90ef                                bcc hyo2                                 ; yes...
   493  6de3 c92e                                cmp #'.'                                 ; decimal point?
   494  6de5 d008                                bne avf1                                 ; no...
   495  6de7 e8                                  inx
   496  6de8 e002                                cpx #2                                   ; more than 1 decimal?
   497  6dea 90e9                                bcc hyo                                  ; no...
   498  6dec 835cc0             ero              +lbra snerr                              ; yes...syntax error
   499                          
   500                          
   501  6def 205f6e             avf1             jsr com2                                 ; =, >, or # in field
   502  6df2 d00a                                bne llar                                 ; no...
   503  6df4 9003                                bcc hyo1                                 ; was #
   504  6df6 8de011                              sta chsn                                 ; was > or =
   505                          
   506  6df9 fee111             hyo1             inc vf,x
   507  6dfc 80d7                                bra hyo
   508                          
   509  6dfe c924               llar             cmp #'$'                                 ; dollar?
   510  6e00 d00e                                bne expo                                 ; no...
   511  6e02 2cda11                              bit dolr                                 ; test flag
   512  6e05 10f2                                bpl hyo1                                 ; no...
   513  6e07 18                                  clc
   514  6e08 6eda11                              ror dolr                                 ; set flag
   515  6e0b cee111                              dec vf
   516  6e0e 80e9                                bra hyo1
   517                          
   518  6e10 c95e               expo             cmp #'^'                                 ; up arrow?
   519  6e12 d016                                bne isp                                  ; no...
   520  6e14 a202                                ldx #$02
   521  6e16 203f6c             l213_1           jsr ansub                                ; must be 4 up arrows
   522  6e19 b0d1                                bcs ero
   523  6e1b c95e                                cmp #'^'                                 ; up arrow?
   524  6e1d d0cd                                bne ero
   525  6e1f ca                                  dex
   526  6e20 10f4                                bpl l213_1
   527  6e22 eee411                              inc fesp                                 ; set exp flag
   528  6e25 203f6c                              jsr ansub                                ; next format char
   529  6e28 b022                                bcs efo                                  ; end of format
   530                          
   531  6e2a c92b               isp              cmp #'+'                                 ; plus?
   532  6e2c d019                                bne chom                                 ; no...
   533  6e2e ade711                              lda sno                                  ; sign neg?
   534  6e31 1005                                bpl spos                                 ; yes...
   535  6e33 a92b                                lda #'+'
   536  6e35 8de711                              sta sno
   537                          
   538  6e38 ade311             spos             lda posp                                 ; + or - already?
   539  6e3b d0af                                bne ero
   540  6e3d 6ee311                              ror posp                                 ; make posp neg/clc
   541  6e40 8ceb11                              sty endfd                                ; end field pointer
   542  6e43 eee611                              inc cform                                ; correct counter
   543  6e46 60                 trts             rts
   544                          
   545                          
   546  6e47 c92d               chom             cmp #'-'                                 ; minus?
   547  6e49 f0ed                                beq spos                                 ; yes...
   548  6e4b 38                                  sec
   549  6e4c 8ceb11             efo              sty endfd                                ; end field pointer
   550  6e4f ceeb11                              dec endfd
   551  6e52 60                                  rts
   552                          
   553                          
   554                          ; Using- comp: compare .a with symbols
   555                          
   556  6e53 c92b               comp             cmp #'+'
   557  6e55 f015                                beq rt
   558  6e57 c92d                                cmp #'-'
   559  6e59 f011                                beq rt
   560                          
   561  6e5b c92e               com1             cmp #'.'
   562  6e5d f00d                                beq rt
   563                          
   564  6e5f c93d               com2             cmp #'='
   565  6e61 f009                                beq rt
   566  6e63 c93e                                cmp #'>'
   567  6e65 f005                                beq rt
   568  6e67 c923                                cmp #'#'
   569  6e69 d001                                bne rt
   570  6e6b 18                                  clc
   571  6e6c 60                 rt               rts
   572                          
   573                          ;.end
   574                          

; ******** Source: basic.asm

; ******** Source: function/instr.asm
     1                          
     2                          ;  INSTRing - Find position of str1 in str2 at or after position n
     3                          ;
     4                          ; Usage: INSTR(a$,b${,n})
     5                          
     6  6e6d a566               instr            lda facmo                                ; save pointer to temporary descriptors
     7  6e6f 8dd302                              sta tmpdes
     8  6e72 a567                                lda facmo+1
     9  6e74 8dd402                              sta tmpdes+1
    10                          
    11  6e77 20ef4c                              jsr frmevl                               ; get next arg
    12  6e7a 20dd4c                              jsr chkstr                               ; must be string
    13  6e7d a566                                lda facmo
    14  6e7f 8dd502                              sta tmpdes+2
    15  6e82 a567                                lda facmo+1
    16  6e84 8dd602                              sta tmpdes+3
    17                          
    18  6e87 a201                                ldx #1                                   ; default starting position
    19  6e89 8667                                stx faclo
    20  6e8b 208522                              jsr chrgot
    21  6e8e c929                                cmp #')'                                 ; any length argument?
    22  6e90 f003                                beq l214_1                               ; branch if not
    23  6e92 20825d                              jsr combyt                               ; else go get a one byte argument
    24                          
    25  6e95 20554e             l214_1           jsr chkcls                               ; look for )
    26  6e98 a667                                ldx faclo
    27  6e9a f362e3                              +lbeq fcerr                              ; starting position can't be 0
    28  6e9d ca                                  dex
    29  6e9e 8663                                stx positn
    30                          
    31  6ea0 a203                                ldx #3                                   ; copy 'pointers to temp descriptors' to zero page
    32  6ea2 bdd302             l214_2           lda tmpdes,x
    33  6ea5 9559                                sta ptarg1,x
    34  6ea7 ca                                  dex
    35  6ea8 10f8                                bpl l214_2
    36                          
    37  6eaa a002                                ldy #2                                   ; now get the descriptors
    38  6eac a959               l214_3           lda #ptarg1
    39  6eae 20d722                              jsr lda_far_ram1                         ; lda (ptarg1),y
    40  6eb1 995d00                              sta str1,y
    41  6eb4 a95b                                lda #ptarg2
    42  6eb6 20d722                              jsr lda_far_ram1                         ; lda (ptarg2),y
    43  6eb9 996000                              sta str2,y
    44  6ebc 88                                  dey
    45  6ebd 10ed                                bpl l214_3
    46                          
    47  6ebf a560                                lda str2                                 ; check if string 2 is null
    48  6ec1 f03b                                beq l214_8                               ; if so, return 0
    49                          
    50  6ec3 a900               l214_4           lda #0
    51  6ec5 8564                                sta match
    52  6ec7 18                                  clc
    53  6ec8 a560                                lda str2                                 ; length of string 2
    54  6eca 6563                                adc positn
    55  6ecc b030                                bcs l214_8                               ; too long, not found
    56  6ece c55d                                cmp str1                                 ; see if > length of string 1
    57  6ed0 9002                                bcc l214_5                               ; < len string 1
    58  6ed2 d02a                                bne l214_8                               ; must be >, not found
    59                          
    60  6ed4 a464               l214_5           ldy match
    61  6ed6 c460                                cpy str2                                 ; if match len = str len, then found
    62  6ed8 f01f                                beq l214_7
    63  6eda 98                                  tya
    64  6edb 18                                  clc
    65  6edc 6563                                adc positn                               ; compare str1(s+p+m) with str2(m)
    66  6ede a8                                  tay
    67  6edf a95e                                lda #str1+1
    68  6ee1 20d722                              jsr lda_far_ram1                         ; lda (str1+1),y
    69  6ee4 8578                                sta syntmp
    70  6ee6 a464                                ldy match
    71  6ee8 a961                                lda #str2+1
    72  6eea 20d722                              jsr lda_far_ram1                         ; lda (str2+1),y
    73  6eed c578                                cmp syntmp
    74  6eef f004                                beq l214_6
    75  6ef1 e663                                inc positn                               ; not the same, start over from next positn
    76  6ef3 80ce                                bra l214_4                               ; always
    77                          
    78  6ef5 e664               l214_6           inc match                                ; count characters that match
    79  6ef7 80db                                bra l214_5                               ; always
    80                          
    81                          
    82  6ef9 e663               l214_7           inc positn                               ; found
    83  6efb a563                                lda positn
    84  6efd 2c                                  !text $2c
    85                          
    86  6efe a900               l214_8           lda #0                                   ; not found
    87                          ; sta sw_rom_ram0 ;????
    88  6f00 48                                  pha
    89  6f01 add502                              lda tmpdes+2                             ; free temp descriptors
    90  6f04 acd602                              ldy tmpdes+3
    91  6f07 20715b                              jsr fretmp
    92                          ; sta sw_rom_ram0 ;????
    93  6f0a add302                              lda tmpdes
    94  6f0d acd402                              ldy tmpdes+1
    95  6f10 20715b                              jsr fretmp
    96  6f13 7a                                  ply
    97  6f14 83bce9                              +lbra sngflt                             ; float 1 byte in .y
    98                          
    99                          ;.end
   100                          
   101                          

; ******** Source: basic.asm

; ******** Source: function/type.asm
     1                          
     2                          ; TYPE  types a given disk (SEQ) file to output channel
     3                          ;
     4                          
     5  6f17 a300               type             ldz #0
     6                          
     7                          open_SEQ_file
     8  6f19 db                                  phz                                      ; save EDIT load flag    [910620]
     9  6f1a a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
    10  6f1c 202074                              jsr dosprs                               ; (like dopen:      0 0 0 *  * 0 0 1 )
    11  6f1f 20dc77                              jsr chk1                                 ; check parameters
    12  6f22 201d71                              jsr find_la                              ; find an available LA
    13  6f25 200d71                              jsr find_sa                              ; find an available SA
    14  6f28 a011                                ldy #fopnseq
    15  6f2a a206                                ldx #6
    16  6f2c 20fd70                              jsr open_file                            ; open the file
    17  6f2f b3f6c3                              +lbcs list_err                           ; exit if error
    18  6f32 fb                                  plz                                      ; [910620]
    19  6f33 f001                                beq l215_1
    20  6f35 60                                  rts                                      ; or exit if called by EDIT load routine
    21                          
    22  6f36 20e1ff             l215_1           jsr _stop                                ; check stop key
    23  6f39 f03c                                beq l215_6                               ; exit if down
    24  6f3b ae8111                              ldx dosla
    25  6f3e 20c6ff                              jsr _chkin                               ; get input channel
    26  6f41 b034                                bcs l215_6                               ; exit if bad??
    27  6f43 a200                                ldx #0
    28  6f45 e0ff               l215_2           cpx #255                                 ; check buffer (buflen????)
    29                          ; bcs 99$   ; 'too long' error
    30  6f47 f011                                beq l215_3                               ; allow long lines   [910620]
    31  6f49 20cfff                              jsr _basin                               ; read file data
    32  6f4c 9d0013                              sta dosstr,x                             ; buffer it
    33  6f4f e8                                  inx                                      ; bump buffer pointer
    34  6f50 a8                                  tay                                      ; save char
    35  6f51 20b7ff                              jsr _readst                              ; check channel status
    36  6f54 d004                                bne l215_3                               ; exit if eof or error
    37  6f56 c00d                                cpy #cr
    38  6f58 d0eb                                bne l215_2                               ; loop until eol
    39                          
    40  6f5a 08                 l215_3           php                                      ; save input channel status (beq=eol, bne=eof/err)
    41  6f5b 8e7b11                              stx t4                                   ; save character count
    42  6f5e 20c770                              jsr dcato                                ; get output channel
    43  6f61 a200                                ldx #0
    44  6f63 ec7b11             l215_4           cpx t4                                   ; check buffer
    45  6f66 b009                                bcs l215_5                               ; end of buffered data
    46  6f68 bd0013                              lda dosstr,x                             ; output data
    47  6f6b 20d2ff                              jsr _bsout
    48  6f6e e8                                  inx                                      ; bump buffer pointer
    49  6f6f d0f2                                bne l215_4                               ; loop until end of buffer
    50                          
    51  6f71 20ccff             l215_5           jsr _clrch
    52  6f74 28                                  plp                                      ; check input status
    53  6f75 f0bf                                beq l215_1                               ; loop until eof or bad status
    54                          
    55  6f77 83a7c3             l215_6           +lbra list_exit                          ; release channel, close file, return to main
    56                          
    57                          ;99$ jsr _clrch  ;non-I/O trouble   removed [910620]
    58                          ; lda dosla  ; shut down disk & report BASIC error
    59                          ; clc
    60                          ; jsr _close
    61                          ; bra errlen  ;buffer overflow: report 'string too long'

; ******** Source: basic.asm

; ******** Source: command/disk.asm
     1                          
     2                          
     3                          
     4                          ; DISK "command_string" [,U#] [,D#]     new [910123]
     5                          
     6                          disk
     7  6f7a a9f6                                lda #$f6                                 ; parse:  command_string [,U#]
     8  6f7c 202074                              jsr dosprs
     9  6f7f 20dc77                              jsr chk1                                 ; check parameters
    10  6f82 a900                                lda #doslfn                              ; la (reserved la)
    11  6f84 8d8111                              sta dosla
    12  6f87 a96f                                lda #$6f
    13  6f89 8d8311                              sta dossa                                ; sa (command channel)
    14  6f8c a053                                ldy #fdisk
    15  6f8e a202                                ldx #2                                   ; add "/" [911108]
    16  6f90 20fd70                              jsr open_file                            ; open command channel & send command string
    17  6f93 08                                  php                                      ; save error status    [910404]
    18  6f94 48                                  pha
    19  6f95 a900                                lda #doslfn                              ; close it
    20  6f97 38                                  sec                                      ; not a real close
    21  6f98 20c3ff                              jsr _close                               ; close it
    22  6f9b 68                                  pla                                      ; [910404]
    23  6f9c 28                                  plp
    24  6f9d 83cff8                              +lbra exit_disk_op                       ; common error check & exit path ????
    25                          
    26                          

; ******** Source: basic.asm

; ******** Source: dos/setup.asm
     1                          
     2                          
     3                          
     4                          ; These routines take tokens and values after the following BASIC keywords:
     5                          ;
     6                          ;  DOPEN,   DCLOSE,  APPEND,  CONCAT, RECORD
     7                          ;  DLOAD,   DSAVE,   DVERIFY, BLOAD,  BSAVE
     8                          ;  FORMAT,  COLLECT, BACKUP,  COPY
     9                          ;  CATALOG, RENAME,  SCRATCH, DCLEAR
    10                          ;
    11                          ; It then parses the following line and finds syntax errors, checks for values
    12                          ; out of range, and sets variables in the zero-page to be passed to the disk
    13                          ; message generator.
    14                          
    15                          
    16                          directory                                                 ; display disk directory (catalog)
    17  6fa0 208522                              jsr chrgot                               ; get current chr
    18  6fa3 c9fe                                cmp #esc_command_token                   ; eat dirECTORY kludge if it's there
    19  6fa5 d00b                                bne l216_1
    20  6fa7 208322                              jsr chrget                               ; (esc token + another)
    21  6faa c929                                cmp #ectory_token
    22  6fac d39cbe                              +lbne snerr
    23  6faf 208322                              jsr chrget                               ; yes- get next good char
    24                          
    25  6fb2 201e74             l216_1           jsr dospar                               ; parse the line
    26  6fb5 a57f                                lda parsts                               ; check options
    27  6fb7 29e6                                and #$e6
    28  6fb9 d38fbe                              +lbne snerr
    29                          
    30  6fbc a001                                ldy #fdir                                ; table offset for directory
    31  6fbe 2c8f11                              bit dosflags                             ; want recoverable files? [901024]
    32  6fc1 5002                                bvc l216_2                               ; no
    33  6fc3 a005                                ldy #fdirr                               ; yes
    34  6fc5 a201               l216_2           ldx #1                                   ; just $
    35  6fc7 a57f                                lda parsts                               ; check for default
    36  6fc9 2911                                and #$11                                 ; no drive?
    37  6fcb f006                                beq l216_4
    38  6fcd 4a                                  lsr
    39  6fce 9002                                bcc l216_3                               ; just drive
    40  6fd0 e8                                  inx                                      ; drive and filename
    41  6fd1 e8                                  inx
    42  6fd2 e8                 l216_3           inx
    43  6fd3 8a                 l216_4           txa                                      ; a now has length
    44  6fd4 20f276                              jsr sendp                                ; build
    45                          
    46  6fd7 a200                                ldx #sys_bank                            ; set banks????  fname in system space, bank0 [910620]
    47  6fd9 8a                                  txa                                      ; (load bank is don't care- we're not actually loading)
    48  6fda 206bff                              jsr _setbank
    49                          
    50  6fdd a060                                ldy #$60                                 ; sa, load floppy
    51  6fdf ae8211                              ldx dosfa
    52  6fe2 a900                                lda #doslfn                              ; lfn
    53  6fe4 20baff                              jsr _setlfs                              ; set file parameters
    54  6fe7 20c0ff                              jsr _open                                ; open it...
    55  6fea 9009                                bcc l216_5                               ; ...ok
    56  6fec 48                                  pha
    57  6fed 204f70                              jsr dcat11                               ; ...error, shut down and report
    58  6ff0 fa                                  plx
    59  6ff1 38                                  sec
    60  6ff2 835bbe                              +lbra error
    61                          
    62  6ff5 a515               l216_5           lda channl                               ; determine DIR vs LDIR
    63  6ff7 d05e                                bne ldir                                 ; if output channel not default (screen)
    64                          ; use LDIR
    65                          
    66                          ; Get length in blocks
    67                          
    68  6ff9 a200               dir              ldx #doslfn
    69  6ffb 20c6ff                              jsr _chkin
    70  6ffe b04f                                bcs dcat11                               ; if problem??
    71  7000 20b7ff                              jsr _readst                              ; check status
    72  7003 d04a                                bne dcat11                               ; exit if bad status
    73  7005 20f737                              jsr crdo                                 ; output new line
    74  7008 a003                                ldy #3                                   ; loop counter
    75                          
    76  700a 8c7911             dcat3            sty t3                                   ; save counter
    77                          
    78  700d 20cfff             l217_1           jsr _basin                               ; get char
    79  7010 8d7b11                              sta t4
    80  7013 20cfff                              jsr _basin                               ; get char
    81  7016 8d7c11                              sta t4+1
    82  7019 20b7ff                              jsr _readst                              ; check status
    83  701c d031                                bne dcat11                               ; exit if eof or bad status
    84  701e ce7911                              dec t3
    85  7021 d0ea                                bne l217_1                               ; if not done
    86                          
    87                          ; Output blocks number
    88                          
    89  7023 ae7b11                              ldx t4
    90  7026 ad7c11                              lda t4+1
    91  7029 207f64                              jsr linprt                               ; output number
    92  702c a920                                lda #' '
    93  702e 20d2ff                              jsr _bsout                               ; output a space
    94                          
    95                          ; Get name & output it
    96                          
    97  7031 20b7ff             dcat4            jsr _readst                              ; get status
    98  7034 d016                                bne dcat10                               ; if bad status
    99  7036 20cfff                              jsr _basin                               ; get char
   100  7039 f005                                beq dcat5                                ; if eol
   101  703b 20d2ff                              jsr _bsout                               ; echo char
   102  703e 80f1                                bra dcat4                                ; continue to process name until eol or err
   103                          
   104                          ; Here on end of name
   105                          
   106  7040 20f737             dcat5            jsr crdo                                 ; output new line
   107  7043 20e1ff                              jsr _stop                                ; check stop key
   108  7046 f007                                beq dcat11                               ; exit if stop request
   109                          
   110                          ; Process next
   111                          
   112  7048 a002                                ldy #2                                   ; perform 2 times
   113  704a 80be                                bra dcat3
   114                          
   115                          
   116                          ; Exit directory
   117                          
   118  704c 20f737             dcat10           jsr crdo                                 ; flush current line
   119  704f 20b438             dcat11           jsr release_channels                     ; release cmd channel, restore terminal
   120  7052 a900                                lda #doslfn
   121  7054 83b8f8                              +lbra close_out                          ; [900725]

; ******** Source: basic.asm

; ******** Source: command/ldir.asm
     1                          
     2                          ; LDIR  same as DIR, except it buffers each line to reduce
     3                          ;       talker/listener turnaround time.  Even so, it is still
     4                          ; unacceptably slow for normal screen output, which is
     5                          ; why it was split out from the original DIRECTORY routine.
     6                          ;
     7                          
     8                          ; Read block count
     9                          
    10                          ldir
    11  7057 a9c0                                lda #$c0                                 ; serial bus kludge for open4,4:cmd4:dir ????
    12  7059 2d09d6                              and $d609
    13  705c 1c09d6                              trb $d609                                ; disable fast serial bus
    14  705f 8586                                sta sid_speed_flag                       ; but save enables so we can restore them
    15                          
    16  7061 a003                                ldy #3                                   ; loop counter (3=skip fake load adr & link bytes)
    17  7063 8c7911             l218_1           sty t3                                   ; save counter
    18  7066 a200                                ldx #doslfn
    19  7068 20c6ff                              jsr _chkin
    20  706b b053                                bcs ldir_end                             ; problem??
    21                          
    22  706d 20b7ff             l218_2           jsr _readst                              ; check status
    23  7070 d04e                                bne ldir_end                             ; exit if bad status
    24  7072 20cfff                              jsr _basin                               ; get block count
    25  7075 8d0013                              sta dosstr                               ; buffer it
    26  7078 20cfff                              jsr _basin
    27  707b 8d0113                              sta dosstr+1
    28  707e ce7911                              dec t3
    29  7081 d0ea                                bne l218_2                               ; continue eating bytes until we have block count
    30                          
    31                          ; Read filename
    32                          
    33  7083 a201                                ldx #1                                   ; buffer index-1
    34  7085 e8                 l218_3           inx
    35  7086 20b7ff                              jsr _readst                              ; check status
    36  7089 d035                                bne ldir_end                             ; exit if eof or bad status
    37  708b 20cfff                              jsr _basin                               ; buffer next character
    38  708e 9d0013                              sta dosstr,x
    39  7091 d0f2                                bne l218_3                               ; loop until eol (null terminator)
    40                          
    41                          ; Print one line of directory
    42                          
    43  7093 20c770                              jsr dcato                                ; get output channel
    44  7096 ae0013                              ldx dosstr
    45  7099 ad0113                              lda dosstr+1
    46  709c 207f64                              jsr linprt                               ; print blocks
    47                          
    48  709f a920                                lda #' '
    49  70a1 20d2ff                              jsr _bsout                               ; print space
    50                          
    51  70a4 a202                                ldx #2
    52  70a6 bd0013             l218_4           lda dosstr,x
    53  70a9 f006                                beq l218_5
    54  70ab 20d2ff                              jsr _bsout                               ; print filename (null terminated)
    55  70ae e8                                  inx
    56  70af d0f5                                bne l218_4
    57                          
    58  70b1 20f737             l218_5           jsr crdo                                 ; print return
    59  70b4 20ccff                              jsr _clrch
    60  70b7 20e1ff                              jsr _stop                                ; check stop key
    61  70ba f004                                beq ldir_end                             ; exit if stop request
    62                          
    63                          ; Continue with next line
    64                          
    65  70bc a002                                ldy #2                                   ; set to skip fake link bytes
    66  70be 80a3                                bra l218_1                               ; loop
    67                          
    68                          
    69                          ldir_end
    70  70c0 a586                                lda sid_speed_flag                       ; serial bus kludge for open4,4:cmd4:dir ????
    71  70c2 0c09d6                              tsb $d609                                ; restore fast serial bus enables
    72  70c5 8088                                bra dcat11
    73                          
    74                          
    75                          
    76  70c7 20ccff             dcato            jsr _clrch
    77  70ca a615                                ldx channl                               ; restore output channel
    78  70cc f003                                beq l219_1                               ; branch if screen (default output)
    79  70ce 4cc9ff                              jmp _chkout                              ; else get output channel
    80                          
    81  70d1 60                 l219_1           rts
    82                          

; ******** Source: basic.asm

; ******** Source: function/dopen.asm
     1                          ; DOPEN dfn(,t(,r))
     2                          
     3  70d2 a922               dopen            lda #$22                                 ; set error flag
     4  70d4 202074                              jsr dosprs                               ; parse the line
     5  70d7 200478                              jsr chk6                                 ; check required parameters
     6  70da 200d71                              jsr find_sa                              ; find unused secondary address
     7  70dd a009                                ldy #fopn                                ; fcb format pointer
     8  70df a204                                ldx #4                                   ; normal length
     9  70e1 6f7f13                              bbr6 parsts,open_it                      ; relative record? branch if not relative
    10  70e4 a208                                ldx #8                                   ; random access length
    11  70e6 800f                                bra open_it                              ; [910925]
    12                          
    13                          ;l220_1 jsr open_file  ;open it
    14                          ; bra exit_disk_op ;report any DOS errors, & return to main [910404]
    15                          
    16                          
    17                          
    18                          ; APPEND
    19                          
    20  70e8 a9e2               append           lda #$e2                                 ; set error flags
    21  70ea 202074                              jsr dosprs                               ; parse the line
    22  70ed 200478                              jsr chk6                                 ; check required parameters
    23  70f0 200d71                              jsr find_sa                              ; find secondary address
    24  70f3 a028                                ldy #fapn                                ; tabld index
    25  70f5 a205                                ldx #5                                   ; length
    26                          open_it
    27  70f7 20fd70                              jsr open_file                            ; open it
    28  70fa 8372f7                              +lbra exit_disk_op                       ; report any DOS errors, & return to main [910404]
    29                          
    30                          
    31                          
    32                          open_file                                                 ; dop2.
    33  70fd 8a                                  txa                                      ; set length into a
    34  70fe 20f276                              jsr sendp
    35  7101 20ccff                              jsr _clrch
    36  7104 a200                                ldx #sys_bank                            ; fname is in system space, bank0  [910620]
    37  7106 8a                                  txa                                      ; (load bank not req'd)????
    38  7107 206bff                              jsr _setbank
    39  710a 4cc0ff                              jmp _open
    40                          
    41                          
    42                          ; Find an available secondary address
    43                          
    44                          find_sa
    45  710d a061                                ldy #$61                                 ; 2-14 possible
    46                          
    47  710f c8                 l220_1           iny
    48  7110 c06f                                cpy #$6f
    49  7112 f017                                beq too_many_files                       ; if none available error
    50  7114 2062ff                              jsr _lkupsa                              ; kernel will lookup this sa in its tables
    51  7117 90f6                                bcc l220_1                               ; if used keep looking
    52  7119 8c8311                              sty dossa                                ; save secondary address
    53  711c 60                                  rts                                      ; return .y = sa
    54                          
    55                          
    56                          
    57                          ; Find an available logical address
    58                          
    59                          find_la
    60  711d a900                                lda #0                                   ; 1-127 possible
    61                          
    62  711f 1a                 l221_1           inc
    63  7120 3009                                bmi too_many_files                       ; if none available error
    64  7122 205fff                              jsr _lkupla                              ; kernel will lookup this la in its tables
    65  7125 90f8                                bcc l221_1                               ; if used keep looking
    66  7127 8d8111                              sta dosla                                ; save logical address
    67  712a 60                                  rts                                      ; return .a = la
    68                          
    69                          
    70                          
    71                          
    72                          too_many_files
    73  712b a201                                ldx #errtmf                              ; too many files open
    74  712d 8320bd                              +lbra error
    75                          
    76                          
    77                          ; Close disk file
    78                          
    79  7130 a9f3               dclose           lda #$f3                                 ; set error flags
    80  7132 202074                              jsr dosprs                               ; parse the line
    81  7135 208278                              jsr Clear_DS
    82  7138 2f7f06                              bbr2 parsts,dclall                       ; any la given?  branch if not
    83  713b ad8111                              lda dosla
    84  713e 83cef7                              +lbra close_out
    85                          
    86  7141 ad8211             dclall           lda dosfa                                ; get disk #
    87                          ; jsr put_io_in_map
    88  7144 4c50ff                              jmp _close_all                           ; close all channels
    89                          
    90                          
    91                          
    92                          ; DSAVE dfn
    93                          
    94  7147 4f7e03             dsave            bbr4 runmod,l222_1                       ; PROGRAM or EDIT mode?    [910620]
    95  714a 83ab4c                              +lbra edit_save                          ; edit
    96                          
    97  714d a966               l222_1           lda #$66                                 ; set error flags
    98  714f 202074                              jsr dosprs                               ; parse the line
    99  7152 20e177                              jsr chk2                                 ; check required parameters
   100  7155 a009                                ldy #fopn                                ; table offset
   101  7157 a904                                lda #4                                   ; ..length,
   102  7159 20f276                              jsr sendp
   103                          
   104  715c a584                                lda text_bank                            ; default to text bank set up banks???? [910620]
   105  715e a200                                ldx #sys_bank                            ; fname is in system space, bank0
   106  7160 206bff                              jsr _setbank
   107  7163 8300f7                              +lbra savenp
   108                          
   109                          
   110                          ; DVERIFY
   111                          
   112  7166 a901               dverify          lda #1                                   ; flag 'verify'
   113  7168 2c                                  !text $2c
   114                          
   115                          
   116                          
   117                          ; DLOAD dfn
   118                          
   119  7169 a900               dload            lda #0
   120  716b 850c                                sta verck                                ; set load flag (for verify check later)
   121                          
   122  716d 4f7e03                              bbr4 runmod,l223_1                       ; PROGRAM or EDIT mode?    [910620]
   123  7170 839b4b                              +lbra edit_load                          ; edit
   124                          
   125  7173 a9e6               l223_1           lda #$e6                                 ; set error flags
   126  7175 202074                              jsr dosprs                               ; parse the line
   127  7178 20e177                              jsr chk2                                 ; check required parameters
   128                          
   129                          
   130                          dload_boot                                                ; <<<<<<<<<<<<<<<<<< entry for BOOT'AUTOBOOT.C65'
   131  717b a900                                lda #0
   132  717d 8d8311                              sta dossa                                ; set relocate flag
   133  7180 a009                                ldy #fopn                                ; table offset
   134  7182 a904                                lda #4                                   ; ..length
   135  7184 20f276                              jsr sendp
   136                          
   137  7187 a584                                lda text_bank                            ; set up banks ???? want text_bank ????  [910620]
   138  7189 a200                                ldx #sys_bank                            ; fname is in system space, bank0
   139  718b 206bff                              jsr _setbank
   140                          
   141  718e 8307f7                              +lbra cld10                              ; finish load, using 'LOAD' code.
   142                          
   143                          
   144                          ; BSAVE
   145                          
   146  7191 a966               bsave            lda #$66                                 ; std error flag
   147  7193 a2f8                                ldx #$f8                                 ; auxiliary error flag (allow bank, start & end address)
   148  7195 202274                              jsr dosprx                               ; parse options
   149  7198 20e177                              jsr chk2                                 ; check required parameters
   150                          
   151  719b a580                                lda parstx                               ; check for starting & ending addresses
   152  719d 2906                                and #6
   153  719f c906                                cmp #6
   154  71a1 d3a7bc                              +lbne snerr                              ; ..if not present, syntax error
   155                          
   156  71a4 ad8011                              lda dosofh+1                             ; check that ea>sa
   157  71a7 cd7e11                              cmp dosofl+1
   158  71aa 9352e0                              +lbcc fcerr                              ; ...error
   159  71ad d00c                                bne l224_1
   160  71af ad7f11                              lda dosofh
   161  71b2 cd7d11                              cmp dosofl
   162  71b5 9347e0                              +lbcc fcerr                              ; ...error
   163  71b8 f344e0                              +lbeq fcerr
   164                          
   165  71bb a009               l224_1           ldy #fopn                                ; table offset
   166  71bd a904                                lda #4                                   ; ..length
   167  71bf 20f276                              jsr sendp
   168                          
   169  71c2 ad8c11                              lda dosbnk                               ; get requested bank
   170  71c5 a200                                ldx #sys_bank                            ; ..and name will be in system bank
   171  71c7 206bff                              jsr _setbank                             ; ..and go set up bank
   172                          
   173  71ca ae7d11                              ldx dosofl                               ; start addr
   174  71cd ac7e11                              ldy dosofl+1
   175  71d0 a95a                                lda #highds                              ; ..and a pointer to start address
   176  71d2 865a                                stx highds
   177  71d4 845b                                sty highds+1
   178  71d6 ae7f11                              ldx dosofh                               ; end addr
   179  71d9 ac8011                              ldy dosofh+1
   180  71dc 838df6                              +lbra savenb
   181                          
   182                          
   183                          
   184                          ; DVERIFY
   185                          
   186  71df a901               bverify          lda #1                                   ; flag 'verify'
   187  71e1 2c                                  !text $2c
   188                          

; ******** Source: basic.asm

; ******** Source: command/bload.asm
     1                          
     2                          ; BLOAD dfn
     3                          
     4  71e2 a900               bload            lda #0                                   ; flag 'load'
     5  71e4 850c                                sta verck                                ; eventually the 'load' routine will look here
     6                          
     7  71e6 a9e6                                lda #$e6                                 ; std error flag
     8  71e8 a2fc                                ldx #$fc                                 ; aux error flag (allow bank & load address)
     9  71ea 202274                              jsr dosprx                               ; parse options
    10                          
    11                          bload_boot                                                ; <<<<<<<<<<<<<<<<<<<<<< entry for BOOT'filename'
    12  71ed 20e177                              jsr chk2                                 ; check required parameters
    13  71f0 ae7d11                              ldx dosofl                               ; get starting address high
    14  71f3 ac7e11                              ldy dosofl+1                             ; ..and lo
    15  71f6 a900                                lda #0                                   ; assume x & y not both=ff (means real add., not def)
    16  71f8 e0ff                                cpx #$ff
    17  71fa d006                                bne l225_1
    18  71fc c0ff                                cpy #$ff
    19  71fe d002                                bne l225_1
    20  7200 a9ff                                lda #$ff                                 ; use defaults
    21  7202 8d8311             l225_1           sta dossa
    22                          
    23  7205 a009                                ldy #fopn                                ; table offset
    24  7207 a904                                lda #4                                   ; ..length,
    25  7209 20f276                              jsr sendp                                ; ...and go send parameters
    26                          
    27  720c ad8c11                              lda dosbnk
    28  720f a200                                ldx #sys_bank
    29  7211 206bff                              jsr _setbank
    30                          
    31  7214 a50c                                lda verck                                ; flag LOAD or VERIFY
    32  7216 ae7d11                              ldx dosofl                               ; get starting address high
    33  7219 ac7e11                              ldy dosofl+1                             ; ..and lo (in case this isn't a 'default' load)
    34  721c 20d5ff                              jsr _loadsp                              ; load it
    35                          
    36                          ; Any changes to the following code must be duplicated at:
    37                          ;  load (load_file)
    38                          ;  save (exit_disk_op)
    39                          
    40  721f 08                                  php                                      ; save kernel load status (.c)
    41  7220 48                                  pha                                      ; save kernel error # (.a)
    42  7221 20b7ff                              jsr _readst                              ; save I/O status byte
    43  7224 857f                                sta parsts
    44  7226 206e72                              jsr print_dos_error                      ; report DOS problems
    45  7229 68                                  pla                                      ; restore error stuff
    46  722a 28                                  plp
    47  722b 9010                                bcc l225_4                               ; branch if no error (rts)
    48  722d ff7e0a                              bbs7 runmod,l225_3                       ; branch if run mode (erexit)
    49  7230 c904                                cmp #errfnf                              ; is it 'file not found' catch-all?
    50  7232 d005                                bne l225_2                               ; no  (erexit)
    51  7234 8dc702                              sta errnum                               ; yes- save error # for 'er'
    52  7237 0980                                ora #$80                                 ; but no errdis
    53  7239 38                 l225_2           sec
    54  723a b3faf5             l225_3           +lbcs erexit                             ; exit if kernel problem (rts)
    55                          
    56  723d a50c               l225_4           lda verck                                ; load or verify operation?
    57  723f d388f6                              +lbne verify_check                       ; verify
    58                          
    59                          ; jsr _readst  ;  read status
    60  7242 a57f                                lda parsts                               ; load
    61  7244 29bf                                and #%10111111                           ; EOI is okay, so mask it
    62  7246 d398f6                              +lbne load_error                         ; load error
    63  7249 18                                  clc
    64  724a 60                                  rts

; ******** Source: basic.asm

; ******** Source: command/header.asm
     1                          
     2                          
     3                          ; HEADER nddn [,id]  (alias: FORMAT)
     4                          
     5  724b 201e74             header           jsr dospar                               ; parse the line
     6  724e 20dc77                              jsr chk1                                 ; check parameter errors
     7  7251 2901                                and #$01
     8  7253 c901                                cmp #$01
     9  7255 d3f3bb                              +lbne snerr                              ; if required parameters not present
    10                          
    11  7258 20e7ff                              jsr _clall                               ; close all files
    12  725b 20c378                              jsr are_you_sure                         ; confirm if in direct mode
    13  725e d072                                bne header_rts                           ; exit if 'no' response
    14  7260 a02d                                ldy #fhed                                ; tabld index
    15  7262 a904                                lda #4                                   ; length
    16  7264 ae8d11                              ldx dosdid                               ; check for diskid
    17  7267 f002                                beq l226_1
    18  7269 a906                                lda #6                                   ; length with id
    19                          
    20  726b 20f973             l226_1           jsr trans                                ; build and send command
    21                          ;fall into 'print_dos_error'

; ******** Source: basic.asm

; ******** Source: dos/errors.asm
     1                          
     2                          print_dos_error                                           ; [900725]
     3  726e ff7e61                              bbs7 runmod,header_rts                   ; branch if not direct mode
     4  7271 200e78                              jsr Check_DS                             ; get current disk error message
     5  7274 a000                                ldy #0
     6  7276 a97a                                lda #dsdesc+1
     7  7278 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y peek at first character
     8  727b c932                                cmp #'2'
     9  727d 9053                                bcc header_rts                           ; branch if no error occured ('00' or '01')
    10  727f c937                                cmp #'7'
    11  7281 d00a                                bne l227_1                               ; [900730]
    12  7283 c8                                  iny
    13  7284 a97a                                lda #dsdesc+1
    14  7286 20d722                              jsr lda_far_ram1                         ; might be '73' powerup message
    15  7289 c933                                cmp #'3'
    16  728b f045                                beq header_rts                           ; yup
    17                          
    18                          ; ldx #errbdk  ; bad disk error (carry is set)
    19                          ; bra error
    20                          
    21                          ; Print DOS error message as if it were a BASIC error message   [900910]
    22                          
    23  728d a9ff               l227_1           lda #$ff                                 ; reset error line
    24  728f 8dc802                              sta errlin                               ;
    25  7292 8dc902                              sta errlin+1
    26  7295 20ccff                              jsr _clrch
    27                          ; inc a   ;a=0 restore output to screen   [910909]
    28  7298 8515                                sta channl
    29  729a 2027af                              jsr RestoreTextScreen                    ; make sure we're in text mode????  [910404]
    30  729d 200935                              jsr init_stack                           ; clean up system, string temps, etc.  [910121]
    31                          
    32  72a0 20dc3c                              jsr highlight_text                       ; [910624]
    33  72a3 207dff                              jsr _primm                               ; start a new line with '?DOS: '
    34  72a6 0d3f444f533a2000                    !text cr,"?DOS: ",0                      ; (to distinguish ?DOS: SYNTAX ERROR from ?SYNTAX ERROR)
    35                          
    36  72ae a003                                ldy #3                                   ; print text part of message only
    37  72b0 a97a                                lda #dsdesc+1
    38  72b2 20d722                              jsr lda_far_ram1                         ; skip err#, comma, & leading space if any
    39  72b5 c920                                cmp #' '
    40  72b7 d00a                                bne l227_3
    41  72b9 c8                                  iny
    42  72ba a97a               l227_2           lda #dsdesc+1
    43  72bc 20d722                              jsr lda_far_ram1
    44  72bf c92c                                cmp #','                                 ; finished at comma preceding trk, sector
    45  72c1 f006                                beq l227_4
    46  72c3 203d68             l227_3           jsr outch
    47  72c6 c8                                  iny
    48  72c7 10f1                                bpl l227_2                               ; loop always (bpl=failsafe)
    49                          
    50  72c9 20cb3c             l227_4           jsr highlight_done                       ; [910624]
    51  72cc 20f737                              jsr crdo
    52  72cf 837cbb                              +lbra ready                              ; we're in direct mode, error msg has been printed, abort
    53                          
    54                          header_rts
    55  72d2 18                                  clc
    56  72d3 60                                  rts

; ******** Source: basic.asm

; ******** Source: command/scratch.asm
     1                          
     2                          ; SCRATCH sdfn  aliases: DELETE, ERASE
     3                          
     4  72d4 201e74             scratch          jsr dospar                               ; parse the line
     5  72d7 20dc77                              jsr chk1
     6  72da 20c378                              jsr are_you_sure                         ; confirm if in direct mode
     7  72dd d02b                                bne l228_4                               ; branch if 'no' response given
     8                          
     9  72df a049                                ldy #fscr                                ; offset
    10  72e1 a904                                lda #4                                   ; length
    11  72e3 2c8f11                              bit dosflags                             ; scratch or recover?
    12  72e6 5004                                bvc l228_1                               ; scratch
    13  72e8 a04d                                ldy #frscr                               ; recover
    14  72ea a906                                lda #6
    15  72ec 20f973             l228_1           jsr trans                                ; transmit scratch command
    16  72ef 201378                              jsr Read_DS                              ; read error channel & update DS$
    17                          
    18  72f2 ff7e15                              bbs7 runmod,l228_4                       ; branch if not direct mode
    19  72f5 20f737                              jsr crdo                                 ; output cr
    20                          
    21  72f8 a000                                ldy #0                                   ; display 'files scratched' DOS message
    22  72fa a97a               l228_2           lda #dsdesc+1
    23  72fc 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
    24  72ff f006                                beq l228_3                               ; if end of error message
    25  7301 203d68                              jsr outch                                ; print it
    26  7304 c8                                  iny
    27  7305 10f3                                bpl l228_2                               ; always (bpl=failsafe)
    28                          
    29  7307 20f737             l228_3           jsr crdo                                 ; done
    30                          
    31  730a 60                 l228_4           rts
    32                          

; ******** Source: basic.asm

; ******** Source: command/record.asm
     1                          ; RECORD- relative record access
     2                          
     3  730b a923               record           lda #'#'
     4  730d 205d4e                              jsr synchr                               ; syntax error if not 'record#'
     5                          
     6  7310 206c5d                              jsr getbyt                               ; get lfn in x
     7  7313 e000                                cpx #0
     8  7315 f3e7de                              +lbeq fcerr                              ; cannot be zero
     9  7318 8e8111                              stx dosla                                ; save logical address
    10                          
    11  731b 20875d                              jsr comwrd                               ; check for comma, get record number in 'poker'
    12                          
    13  731e a201                                ldx #1                                   ; set up to get starting byte # - default is 1
    14  7320 202679                              jsr optbyt
    15  7323 8e8b11                              stx dosrcl                               ; save byte position (pos)    [911024]
    16  7326 8a                                  txa                                      ; cpx #0
    17  7327 f3d5de                              +lbeq fcerr                              ; if out of range
    18  732a e8                                  inx                                      ; cpx #$ff
    19  732b f3d1de                              +lbeq fcerr                              ; if out of range
    20                          
    21  732e ad8111                              lda dosla                                ; get logical address
    22                          ; jsr put_io_in_map
    23  7331 205fff                              jsr _lkupla                              ; logical to physical map
    24  7334 b01a                                bcs l229_1                               ; if file not found (not open)    [910404]
    25  7336 8c9011                              sty dossa_temp                           ; save secondary address
    26                          
    27  7339 8e8211                              stx dosfa                                ; set up device number for trans routine
    28  733c a900                                lda #0
    29  733e 8d8111                              sta dosla                                ; set up logical address for trans routine
    30  7341 a96f                                lda #$6f
    31  7343 8d8311                              sta dossa                                ; and secondary address, too!
    32                          
    33  7346 a055                                ldy #frec                                ; set pointer
    34  7348 a904                                lda #4                                   ; process five bytes
    35  734a 20f973                              jsr trans                                ; send command
    36  734d 831fff                              +lbra print_dos_error                    ; if any
    37                          
    38  7350 a203               l229_1           ldx #errfno                              ; file not found err (file not open)   [910404]
    39  7352 83fbba                              +lbra error

; ******** Source: basic.asm

; ******** Source: command/dclear.asm
     1                          
     2                          ; DCLEAR - reinitilaize the drive
     3                          
     4  7355 201e74             dclear           jsr dospar                               ; parse the line
     5  7358 a0ff                                ldy #finit                               ; set code
     6  735a a902                                lda #2
     7  735c 20f973                              jsr trans                                ; send command
     8  735f 206e72                              jsr print_dos_error                      ; if any
     9  7362 83ddfd                              +lbra dclall

; ******** Source: basic.asm

; ******** Source: command/collect.asm
     1                          ; COLLECT v<drive#>
     2                          
     3  7365 201e74             collect          jsr dospar                               ; parse the line
     4  7368 20ed77                              jsr chk3                                 ; check optional parameters
     5  736b 20e7ff                              jsr _clall                               ; close all files
     6  736e a033                                ldy #fcoll                               ; tabld offset
     7  7370 a901                                lda #1                                   ; length
     8  7372 4f7f01                              bbr4 parsts,l230_1
     9  7375 1a                                  inc                                      ; include drive
    10  7376 20f973             l230_1           jsr trans                                ; send command
    11  7379 83f3fe                              +lbra print_dos_error                    ; if any
    12                          

; ******** Source: basic.asm

; ******** Source: command/copy.asm
     1                          
     2                          ; COPY cdddfn=sdsfn
     3                          
     4  737c 201e74             dcopy            jsr dospar                               ; parse the line
     5  737f 2930                                and #$30
     6  7381 c930                                cmp #$30                                 ; check required parameters
     7  7383 d024                                bne l231_1                               ; branch if single drive copy
     8  7385 a57f                                lda parsts                               ; else check for dual drive params
     9  7387 29c7                                and #$c7
    10  7389 f023                                beq l231_2
    11  738b 2903                                and #3                                   ; special check for 2nd filename   [910717]
    12  738d c903                                cmp #3
    13  738f f018                                beq l231_1                               ; branch if given
    14  7391 a92a                                lda #'*'
    15  7393 8d8d11                              sta dosdid                               ; else supply "*" for him, just like 'name2'
    16  7396 a901                                lda #1
    17  7398 a28d                                ldx #<dosdid
    18  739a a011                                ldy #>dosdid
    19  739c 8d8711                              sta dosf2l
    20  739f 8e8911                              stx dosf2a
    21  73a2 8c8a11                              sty dosf2a+1
    22  73a5 a902                                lda #2                                   ; and set filename2 flag
    23  73a7 047f                                tsb parsts                               ; set flag in status
    24  73a9 a57f               l231_1           lda parsts
    25  73ab 20f377                              jsr chk4
    26                          ; lda parsts
    27  73ae a039               l231_2           ldy #fcopy                               ; tabld offset
    28  73b0 a908                                lda #8                                   ; length
    29  73b2 20f973                              jsr trans                                ; send command
    30  73b5 83b7fe                              +lbra print_dos_error                    ; if any
    31                          
    32                          

; ******** Source: basic.asm

; ******** Source: command/concat.asm
     1                          ; CONCAT
     2                          
     3  73b8 201e74             concat           jsr dospar                               ; parse the line
     4  73bb 20f377                              jsr chk4
     5  73be a01f                                ldy #fconc                               ; offset
     6  73c0 a90c                                lda #12                                  ; length
     7  73c2 20f973                              jsr trans                                ; send command
     8  73c5 83a7fe                              +lbra print_dos_error                    ; if any
     9                          
    10                          

; ******** Source: basic.asm

; ******** Source: command/rename.asm
     1                          
     2                          ; RENAME rdddfn=sdsfn
     3                          
     4  73c8 a9e4               rename           lda #$e4                                 ; set error flags
     5  73ca 202074                              jsr dosprs                               ; parse the line
     6  73cd 20fa77                              jsr chk5
     7  73d0 a041                                ldy #fren                                ; offset
     8  73d2 a908                                lda #8                                   ; length
     9  73d4 20f973                              jsr trans                                ; send command
    10  73d7 8395fe                              +lbra print_dos_error                    ; if any
    11                          
    12                          
    13                          
    14                          ; BACKUP D<destination_drive>=D<source_drive>
    15                          ;
    16                          ; where destination|source_drive is [0...9]
    17                          
    18  73da a9c7               backup           lda #$c7                                 ; set error flags
    19  73dc 202074                              jsr dosprs                               ; parse the line
    20  73df 2930                                and #$30                                 ; required parameters
    21  73e1 c930                                cmp #$30
    22  73e3 d365ba                              +lbne snerr
    23  73e6 20c378                              jsr are_you_sure
    24  73e9 f001                                beq l232_1                               ; if run mode or not 'yes'
    25  73eb 60                                  rts
    26                          
    27  73ec 204171             l232_1           jsr dclall                               ; close disk
    28  73ef a035                                ldy #fbak
    29  73f1 a904                                lda #4                                   ; length
    30  73f3 20f973                              jsr trans                                ; send command
    31  73f6 8376fe                              +lbra print_dos_error                    ; if any

; ******** Source: basic.asm

; ******** Source: command/trans.asm
     1                          
     2                          
     3                          ; Trans subroutine
     4                          
     5  73f9 20f276             trans            jsr sendp                                ; build string to output
     6  73fc 20ccff                              jsr _clrch
     7  73ff a200                                ldx #sys_bank                            ; name is in system space, bank0 ????  [910620]
     8  7401 8a                                  txa
     9  7402 206bff                              jsr _setbank
    10  7405 20c0ff                              jsr _open                                ; send it...
    11  7408 08                                  php                                      ; save error status (.c)
    12  7409 48                                  pha                                      ; save error code (if any)
    13  740a ad8111                              lda dosla
    14  740d 38                                  sec
    15  740e 20c3ff                              jsr _close                               ; special close...
    16  7411 68                                  pla                                      ; pop error
    17  7412 28                                  plp                                      ; pop error status
    18  7413 b321f4                              +lbcs erexit                             ; ...branch if there was an error opening
    19  7416 60                                  rts
    20                          

; ******** Source: basic.asm

; ******** Source: dos/parser.asm
     1                          
     2                          
     3                          
     4                          ; This is the DOS parser routine which looks at lines passed to it and
     5                          ; verifies that the syntax is proper.  -mgm 7/23/79-
     6                          ;
     7                          ; Entry  (dosprs)
     8                          ; a = parsts bit which must be zero.
     9                          ;
    10                          ; Exit  a = parsts as follows
    11                          ;
    12                          ;    ---------------------------------
    13                          ;    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    14                          ;    ---------------------------------
    15                          ;      ^   ^   ^   ^   ^   ^   ^   ^
    16                          ;      |   |   |   |   |   |   |   |_____ fn1 set for the first filename
    17                          ;      |   |   |   |   |   |   |_______ fn2 set for second filename
    18                          ;      |   |   |   |   |   |_________ la set when #lfn parsed
    19                          ;      |   |   |   |   |___________ fa set for device number
    20                          ;      |   |   |   |_____________ d1 set for first disk unit
    21                          ;      |   |   |_______________ d2 set for second disk unit
    22                          ;      |   |_________________ dosrcl set for record size
    23                          ;      |___________________ @ set when @ encountered
    24                          ;
    25                          ; The following are the vaild bit patterns for parsts after parsing for the
    26                          ; various keywords:
    27                          ;
    28                          ;       7 6 5 4  3 2 1 0
    29                          ;
    30                          ;     header  0 0 0 *  * 0 0 1
    31                          ;     collect 0 0 0 *  * 0 0 0
    32                          ;     dclear  0 0 0 *  * 0 0 0
    33                          ;     backup  0 0 1 1  * 0 0 0
    34                          ;     copy    0 0 1 1  * 0 0 0
    35                          ;      or..   0 0 * *  * 0 1 1
    36                          ;     concat  0 0 * *  * 0 1 1
    37                          ;     bsave   * 0 0 *  * 0 0 1
    38                          ;     dsave   * 0 0 *  * 0 0 1
    39                          ;     bload   0 0 0 *  * 0 0 1
    40                          ;     dload   0 0 0 *  * 0 0 1
    41                          ;     dverify 0 0 0 *  * 0 0 1
    42                          ;     catalog 0 0 0 *  * 0 0 *
    43                          ;     rename  0 0 0 *  * 0 1 1
    44                          ;     append  0 0 0 *  * 1 0 1
    45                          ;     scratch 0 0 0 *  * 0 0 1
    46                          ;     dopen   * * 0 *  * 1 0 1
    47                          ;     dclose  0 0 0 0  * * 0 0
    48                          ;             ^ ^ ^ ^  ^ ^ ^ ^
    49                          ;             @ l d d  f l f f
    50                          ;             r r 2 1  a a n n
    51                          ;             p e          2 1
    52                          ;             l l
    53                          ;
    54                          ;      "0" bits are required to be clear
    55                          ;      "1" bits are required to be set
    56                          ;      "*" bits are optional parameters
    57                          
    58                          ; Entry (dosprs):
    59                          ;  parstx shall be set to prevent any auxiliary options to be specified.
    60                          ;
    61                          ; Entry (dosprx):
    62                          ;  .x = parstx bits which must be zero.
    63                          ;
    64                          ; Exit:  .x = parstx as follows:
    65                          ;
    66                          ;     ---------------------------------
    67                          ;     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    68                          ;     ---------------------------------
    69                          ;       ^   ^   ^   ^   ^   ^   ^   ^____ bnk is set for bank option
    70                          ;       |   |   |   |   |   |   | ______ offl set for 1st address
    71                          ;       |   |   |   |   |   |_________ offh set for 2nd address
    72                          ;       |   |   |   |   |___________ unused
    73                          ;       |   |   |   |_____________ unused
    74                          ;       |   |   |_______________ unused
    75                          ;       |   |_________________ unused
    76                          ;       |___________________ unused
    77                          ;
    78                          ; The following are the valid bit patterns for parstx after parsing for the
    79                          ; various keywords.  These options are allowed for load/save commands only.
    80                          ;
    81                          ;    7 6 5 4  3 2 1 0
    82                          ;
    83                          ;   bsave   0 0 0 0  0 1 1 *
    84                          ;   bload   0 0 0 0  0 0 * *
    85                          ;   bverify 0 0 0 0  0 0 * *
    86                          ;   [auto]boot 0 0 0 0  0 0 * *
    87                          ;    ^ ^ ^ ^  ^ ^ ^ ^
    88                          ;    ? ? ? ?  ? o o b
    89                          ;        f f n
    90                          ;        h l k
    91                          ;
    92                          ;      "0" bits are required to be clear
    93                          ;      "1" bits are required to be set
    94                          ;      "*" bits are optional parameters
    95                          
    96  7417 ffffffff           dostbl           !word $ffff,$ffff                        ; default start/end address
    97  741b 00086f                              !text doslfn,dosffn,$6f                  ; default la/fa/sa
    98                          
    99                          
   100  741e a900               dospar           lda #0                                   ; DOS Parser
   101                          
   102                          dosprs                                                    ; special error flag entry
   103  7420 a2ff                                ldx #$ff                                 ; no aux options!
   104                          
   105                          dosprx                                                    ; spec aux error flag entry
   106  7422 48                                  pha                                      ; save error flags
   107  7423 da                                  phx
   108  7424 a900                                lda #0
   109  7426 857f                                sta parsts                               ; reset parser status/option words
   110  7428 8580                                sta parstx
   111                          
   112  742a a20d                                ldx #dosspc                              ; clear DOS scratch area   [900522]
   113  742c 9d8311             l233_1           sta xcnt-1,x
   114  742f ca                                  dex                                      ; no filenames, null lengths
   115  7430 d0fa                                bne l233_1
   116                          
   117  7432 a206                                ldx #dossa-dosofl                        ; set some defaults from table
   118  7434 bd1774             l233_2           lda dostbl,x
   119  7437 9d7d11                              sta dosofl,x                             ; start/end adr = $FFFF, la/fa/sa
   120  743a ca                                  dex
   121  743b 10f7                                bpl l233_2
   122                          
   123  743d ae0611                              ldx _default_drive                       ; set default device   [900522]
   124  7440 8e8211                              stx dosfa
   125  7443 aed102                              ldx current_bank                         ; set current bank
   126  7446 8e8c11                              stx dosbnk
   127                          
   128  7449 208522                              jsr chrgot                               ; get next character from command string
   129  744c d00f                                bne parse1                               ; if eol stick with defaults, else begin parsing
   130                          
   131                          
   132                          ; Done parsing, check for errors, return if everything okay
   133                          
   134  744e 68                 done             pla                                      ; get aux error flag
   135  744f 2580                                and parstx                               ; repeated or illegal params?
   136  7451 d3f7b9                              +lbne snerr                              ; yes- report syntax error
   137  7454 68                                  pla                                      ; get error flags
   138  7455 208c76                              jsr prmrpt
   139  7458 a57f                                lda parsts
   140  745a a680                                ldx parstx
   141  745c 60                                  rts
   142                          
   143                          
   144                          ; Parse given parameters.  what it is  example
   145                          ;     -------------------- ---------
   146  745d c922               parse1           cmp #'"'
   147  745f f30201                              +lbeq name1                              ; explicit filename "file"
   148  7462 c928                                cmp #'('
   149  7464 f3fd00                              +lbeq name1                              ; evaluate filename (f$)
   150  7467 c923                                cmp #'#'
   151  7469 f039                                beq logadr                               ; logical file number #1
   152  746b c955                                cmp #'U'
   153  746d f029                                beq unit1                                ; unit number  U8
   154  746f c944                                cmp #'D'
   155  7471 f06d                                beq drv1                                 ; drive number  D0
   156  7473 c950                                cmp #'P'
   157  7475 f3b700                              +lbeq doffl                              ; load/save address P1234
   158  7478 c942                                cmp #'B'
   159  747a f022                                beq dbank1                               ; load/save bank   B0
   160  747c c957                                cmp #'W'
   161  747e f038                                beq reclen                               ; write mode  W
   162  7480 c94c                                cmp #'L'
   163  7482 f034                                beq reclen                               ; record length  L80
   164  7484 c952                                cmp #'R'
   165  7486 f3ce00                              +lbeq recover                            ; recover mode  R
   166  7489 c949                                cmp #'I'
   167  748b f06b                                beq ident                                ; ID   Ixx
   168  748d c991                                cmp #on_token
   169                          ; beq on1   ; ON token  ON
   170                          
   171  748f d3b9b9                              +lbne snerr                              ; none of these, syntax error
   172                          
   173                          
   174  7492 20fe75             on1              jsr on
   175  7495 83e400                              +lbra del1
   176                          
   177                          
   178  7498 200a76             unit1            jsr unit                                 ; do unit# parsing
   179  749b 83de00                              +lbra del1                               ; always
   180                          
   181                          
   182  749e 202476             dbank1           jsr dbank
   183  74a1 83d800                              +lbra del1                               ; always
   184                          
   185                          
   186  74a4 a904               logadr           lda #4
   187  74a6 208c76                              jsr prmrpt                               ; check for repeated parameter
   188  74a9 20695d                              jsr gtbytc                               ; getval
   189  74ac 8a                                  txa                                      ; cpx #0
   190  74ad f34fdd                              +lbeq fcerr                              ; if illegal value
   191  74b0 8e8111                              stx dosla
   192  74b3 a904                                lda #4                                   ; set logical address flag
   193  74b5 83c400                              +lbra del1                               ; get next parameter
   194                          
   195                          
   196  74b8 aa                 reclen           tax                                      ; save char
   197  74b9 a940                                lda #$40
   198  74bb 208c76                              jsr prmrpt                               ; check for repeated parameter
   199  74be e057                                cpx #'W'
   200  74c0 d005                                bne l234_1
   201  74c2 208322                              jsr chrget
   202  74c5 8014                                bra l234_4                               ; set parsts
   203                          
   204  74c7 a201               l234_1           ldx #1                                   ; a kludge to allow  DOPEN#lf,"relfile",L  [911024]
   205  74c9 208322                              jsr chrget
   206  74cc f003                                beq l234_2                               ; eol? open existing rel file
   207  74ce 206c5d                              jsr getbyt                               ; get reclen (was getval)
   208  74d1 8e8b11             l234_2           stx dosrcl                               ; store parcel
   209  74d4 8a                                  txa                                      ; cpx #0
   210  74d5 f001                                beq l234_3                               ; zero illegal dosrcl
   211  74d7 e8                                  inx                                      ; cpx #255
   212  74d8 f324dd             l234_3           +lbeq fcerr                              ; illegal dosrcl
   213                          
   214  74db a940               l234_4           lda #$40                                 ; set dosrcl flag &
   215  74dd 839c00                              +lbra del1
   216                          
   217                          
   218  74e0 a910               drv1             lda #$10
   219  74e2 208c76                              jsr prmrpt                               ; check for repeated parameter
   220  74e5 20695d                              jsr gtbytc                               ; getval
   221  74e8 e00a                                cpx #10
   222  74ea b312dd                              +lbcs fcerr                              ; illegal drv# if >9 [allow 0: to 9: ?????]
   223  74ed 8e8611                              stx dosds1
   224  74f0 8e8811                              stx dosds2
   225  74f3 a910                                lda #$10
   226  74f5 838400                              +lbra del1
   227                          
   228                          
   229  74f8 a980               ident            lda #$80                                 ; set ID flag
   230  74fa 0c8f11                              tsb dosflags
   231  74fd d34bb9                              +lbne snerr                              ; repeated parameter
   232  7500 208322                              jsr chrget                               ; get next character
   233  7503 c928                                cmp #'('                                 ; c65: allow I(ID$) syntax  [900710]
   234  7505 d019                                bne l235_1
   235  7507 20675b                              jsr frmstr                               ; get ID from var
   236  750a c902                                cmp #2
   237  750c 935c01                              +lbcc err_mfn                            ; if length < 2, error
   238  750f a000                                ldy #0
   239  7511 20d522                              jsr indin1_ram1                          ; else grab first two characters
   240  7514 8d8d11                              sta dosdid
   241  7517 c8                                  iny
   242  7518 20d522                              jsr indin1_ram1
   243  751b 8d8e11                              sta dosdid+1
   244  751e 805d                                bra delim1                               ; continue
   245                          
   246  7520 8d8d11             l235_1           sta dosdid                               ; m(txtptr => dosdid
   247  7523 208322                              jsr chrget
   248  7526 8d8e11                              sta dosdid+1
   249  7529 208322                              jsr chrget                               ; continue
   250  752c 8052                                bra delim2
   251                          
   252                          
   253  752e a902               doffl            lda #$02                                 ; check aux status
   254  7530 209276                              jsr prxrpt
   255  7533 207576                              jsr getoff                               ; get offset value
   256  7536 8c7d11                              sty dosofl
   257  7539 8d7e11                              sta dosofl+1
   258  753c a902                                lda #$02
   259  753e 0580               dlimx1           ora parstx                               ; set aux status bits
   260  7540 8580                                sta parstx
   261  7542 d039                                bne delim1                               ; try for next param
   262                          
   263                          
   264  7544 a904               doffh            lda #$04
   265  7546 209276                              jsr prxrpt
   266  7549 207576                              jsr getoff
   267  754c 8c7f11                              sty dosofh
   268  754f 8d8011                              sta dosofh+1
   269  7552 a904                                lda #$04
   270  7554 80e8                                bra dlimx1                               ; set aux status
   271                          
   272                          
   273  7556 a940               recover          lda #$40
   274  7558 0c8f11                              tsb dosflags                             ; set 'recover' bit
   275  755b d3edb8                              +lbne snerr                              ; if repeated parameter
   276  755e 208322                              jsr chrget                               ; continue
   277  7561 801d                                bra delim2
   278                          
   279                          
   280  7563 a901               name1            lda #1                                   ; name1 allowed only once
   281  7565 203676                              jsr newnam                               ; do name parsing
   282  7568 8d8511                              sta dosf1l
   283                          
   284  756b a000                                ldy #0
   285  756d 20d522             l236_1           jsr indin1_ram1
   286  7570 999111                              sta savram,y                             ; copy name into buffer
   287  7573 c8                                  iny
   288  7574 cc8511                              cpy dosf1l
   289  7577 90f4                                bcc l236_1                               ; ...copy all of it
   290  7579 a901                                lda #1                                   ; set name1 flag
   291                          
   292                          
   293  757b 047f               del1             tsb parsts
   294                          
   295  757d 208522             delim1           jsr chrgot
   296  7580 d016               delim2           bne nxxx
   297  7582 83cafe                              +lbra done                               ; <cr>/<> => done
   298                          
   299                          
   300  7585 c991               next6            cmp #on_token
   301  7587 f309ff                              +lbeq on1
   302  758a c9a4                                cmp #to_token                            ; "to" token
   303  758c d3bcb8                              +lbne snerr                              ; syntax error
   304                          
   305                          ;  If "to" is not followed by an offset param, then do file2 params.
   306                          ;  Otherwise, do high offset and continue with file0 options.
   307                          
   308  758f 208322                              jsr chrget
   309  7592 c950                                cmp #'P'
   310  7594 d00f                                bne pars22
   311  7596 f0ac                                beq doffh
   312                          
   313                          
   314  7598 c92c               nxxx             cmp #','
   315  759a d0e9                                bne next6
   316  759c 208322                              jsr chrget
   317  759f 83bcfe                              +lbra parse1
   318                          
   319                          
   320  75a2 208322             parse2           jsr chrget
   321  75a5 c944               pars22           cmp #'D'
   322  75a7 f010                                beq l237_1
   323  75a9 c991                                cmp #on_token                            ; "on" token
   324  75ab f020                                beq on2
   325  75ad c955                                cmp #'U'
   326  75af f021                                beq unit2
   327  75b1 c922                                cmp #'"'
   328  75b3 f022                                beq name2
   329  75b5 c928                                cmp #'('
   330  75b7 f01e                                beq name2
   331                          
   332  75b9 a920               l237_1           lda #$20
   333  75bb 208c76                              jsr prmrpt                               ; check for repeated parameter
   334  75be 20695d                              jsr gtbytc                               ; getval
   335  75c1 e00a                                cpx #10
   336  75c3 b339dc                              +lbcs fcerr                              ; illegal drive #  [allow 0: to 9: ????]
   337  75c6 8e8811                              stx dosds2
   338  75c9 a920                                lda #$20
   339  75cb 801a                                bra del2
   340                          
   341  75cd 20fe75             on2              jsr on
   342  75d0 8015                                bra del2
   343                          
   344                          
   345  75d2 200a76             unit2            jsr unit                                 ; do unit# parsing
   346  75d5 8010                                bra del2                                 ; always
   347                          
   348  75d7 a902               name2            lda #2                                   ; name2 allowed only once
   349  75d9 203676                              jsr newnam
   350  75dc 8d8711                              sta dosf2l
   351  75df 8e8911                              stx dosf2a
   352  75e2 8c8a11                              sty dosf2a+1
   353                          
   354  75e5 a902                                lda #2                                   ; set filename2 flag &
   355  75e7 047f               del2             tsb parsts                               ; set flag in status
   356  75e9 208522                              jsr chrgot
   357  75ec f360fe                              +lbeq done                               ; done on <cr>/<>
   358  75ef c92c                                cmp #','
   359  75f1 f0af                                beq parse2
   360  75f3 c991                                cmp #on_token                            ; "on" token
   361  75f5 f0d6                                beq on2
   362  75f7 c955                                cmp #'U'
   363  75f9 f0d7                                beq unit2
   364  75fb 834db8                              +lbra snerr
   365                          
   366                          
   367  75fe 208322             on               jsr chrget
   368  7601 c942                                cmp #'B'
   369  7603 f01f                                beq dbank
   370  7605 c955                                cmp #'U'
   371  7607 d341b8                              +lbne snerr
   372                          
   373                          
   374  760a 20695d             unit             jsr gtbytc                               ; getval
   375  760d e01f                                cpx #31
   376  760f b05c                                bcs err_ild                              ; error if >30
   377  7611 e001                                cpx #1                                   ; drive 1 = use system default drive  [910221]
   378  7613 d005                                bne l238_1
   379  7615 ae0611                              ldx _default_drive
   380  7618 8004                                bra l238_2
   381  761a e004               l238_1           cpx #4
   382  761c 904f                                bcc err_ild                              ; error if <4
   383  761e 8e8211             l238_2           stx dosfa
   384  7621 a908                                lda #$08                                 ; set parser's unit flag
   385  7623 60                                  rts
   386                          
   387                          
   388  7624 a901               dbank            lda #$01                                 ; repeated param?
   389  7626 209276                              jsr prxrpt
   390  7629 20695d                              jsr gtbytc                               ; getval
   391                          ; cpx #16  ;bank too large?
   392                          ; bcs fcerr ;illegal qty
   393  762c 8e8c11                              stx dosbnk
   394  762f a901                                lda #$01
   395  7631 0480                                tsb parstx                               ; set bnk bit in aux status
   396  7633 a900                                lda #0                                   ; .a=std status wrd, no bits to set
   397  7635 60                                  rts
   398                          
   399                          
   400                          newnam
   401  7636 48                                  pha                                      ; save nam1,2 for subdir check later  [901115]
   402  7637 208c76                              jsr prmrpt                               ; check for repeated parameter
   403  763a 20675b                              jsr frmstr
   404  763d aa                                  tax                                      ; save length of string
   405  763e f02a                                beq err_mfn                              ; if length = 0
   406  7640 a000                                ldy #0
   407  7642 20d522                              jsr indin1_ram1
   408  7645 c940                                cmp #'@'                                 ; Replace file convention?
   409  7647 d00c                                bne l239_1                               ; no
   410  7649 a980                                lda #$80                                 ; yes- check for repeated param
   411  764b 208c76                              jsr prmrpt
   412  764e f77f                                smb7 parsts                              ; set "@" flag
   413  7650 ca                                  dex                                      ; decrement length
   414  7651 e324                                inw index1                               ; increment past "@"
   415  7653 800c                                bra lenchk
   416                          
   417  7655 c92f               l239_1           cmp #'/'                                 ; Subdirectory (partition)?   [901115]
   418  7657 d008                                bne lenchk                               ; no
   419  7659 68                                  pla                                      ; yes- recall nam1 or nam2
   420  765a 0c8f11                              tsb dosflags                             ; set appropriate '/' flag (.a=1 or 2)
   421  765d ca                                  dex                                      ; decrement length
   422  765e e324                                inw index1                               ; increment past "@"
   423  7660 89                                  !text $89
   424                          
   425                          
   426  7661 68                 lenchk           pla                                      ; [901115]
   427  7662 8a                                  txa                                      ; Check filename length
   428  7663 f005                                beq err_mfn                              ; too small, missing filename  [901115]
   429                          ; cmp #17  ;  ???? (problem if name has ',P')
   430                          ; bcs errlen ; too long
   431  7665 a624                                ldx index1
   432  7667 a425                                ldy index1+1                             ; ok- return pointer to filename
   433  7669 60                                  rts
   434                          
   435                          
   436  766a a208               err_mfn          ldx #err_missing_fname
   437  766c 2c                                  !text $2c
   438                          
   439  766d a209               err_ild          ldx #err_illegal_device
   440  766f 2c                                  !text $2c
   441                          
   442  7670 a217               errlen           ldx #errls                               ; string or filename too long
   443  7672 83dbb7                              +lbra error
   444                          
   445                          
   446                          
   447                          ; Get next value routine (use gtbytc instead!)
   448                          
   449                          ;getval jsr chrget ;get nxt chr
   450                          ; beq snerr ;if end of statement
   451                          ; bra getbyt ;       [911024]
   452                          
   453                          ; bcc getbyt ;can be numeric, go evaluate it  why this crap ????
   454                          ; jsr chkopn ;or a "("
   455                          ; jsr getbyt ;anything else is an error
   456                          ; bra chkcls ;need closing ")"
   457                          
   458                          
   459                          
   460                          ; Get next 2-byte expression.  Exit: .a,.y (high,low) value
   461                          
   462  7675 208322             getoff           jsr chrget                               ; get nxt chr
   463  7678 f3d0b7                              +lbeq snerr                              ; if end of statement
   464  767b 930de7                              +lbcc getwrd                             ; can be num. const, go evaluate it
   465  767e 20584e                              jsr chkopn                               ; or a "("
   466  7681 208a5d                              jsr getwrd                               ; expr
   467  7684 20554e                              jsr chkcls                               ; need closing ")"
   468  7687 a416                                ldy poker
   469  7689 a517                                lda poker+1
   470  768b 60                                  rts
   471                          
   472                          
   473                          
   474                          ; Prmrpt checks for a repeated parameter.
   475                          ;
   476                          ; Entry: .a contains parsts flag to check
   477                          
   478                          
   479  768c 257f               prmrpt           and parsts                               ; compare mask with status
   480  768e d3bab7                              +lbne snerr                              ; error if bit previously set
   481  7691 60                                  rts
   482                          
   483                          
   484                          
   485                          ; Prxrpt checks for a repeated parameter.
   486                          ;
   487                          ; Entry: .a contains parstx flag to check
   488                          
   489                          
   490  7692 2580               prxrpt           and parstx                               ; and with parstx
   491  7694 d3b4b7                              +lbne snerr                              ; if bit previously set
   492  7697 60                                  rts
   493                          
   494                          ;.end
   495                          
   496                          
   497                          
   498                          ; CBM-2001 BASIC-4 disk verb processors.  -- rsr 7-24-79 --
   499                          ;
   500                          ; Token Table Definitions
   501                          
   502                          xsca             =$c2                                     ; send dossca
   503                          xid              =$d0                                     ; sends disk id
   504                          xd1              =$d1                                     ; sends dosds1
   505                          xd2              =$d2                                     ; sends dosds2
   506                          xrec             =$e0                                     ; sends S for SEQ, or dosrcl
   507                          xwrt             =$e1                                     ; sends W or L
   508                          xrcl             =$e2                                     ; send low ((poker))
   509                          xfat             =$f0                                     ; sends "@" or "/" if specified
   510                          xfn1             =$f1                                     ; sends filename1
   511                          xfn2             =$f2                                     ; sends filename2
   512                          
   513                          
   514                          ; Tabld - used to build disk command strings
   515                          
   516                          tabld
   517                          finit            = $ff                                    ; Dclear
   518  7698 49d1                                !text "I",xd1
   519                          
   520                          fdir             = *-tabld-1                              ; Dir
   521  769a 24d13af1                            !text "$",xd1,":",xfn1
   522                          
   523                          fdirr            = *-tabld-1                              ; Recover Dir  [901024]
   524  769e 5fd13af1                            !text "_",xd1,":",xfn1                   ; ('_'=CBM backarrow, $5F)
   525                          
   526                          fopn             = *-tabld-1                              ; Dopen
   527  76a2 f0d13af12ce12ce0                    !text xfat,xd1,":",xfn1,",",xwrt,",",xrec
   528                          
   529                          fopnseq          = *-tabld-1                              ; Type   [900801]
   530  76aa f0d13af12c53                        !text xfat,xd1,":",xfn1,",S"
   531                          
   532                          fsavseq          = *-tabld-1                              ; EDIT_SAVE  [910620]
   533  76b0 f0d13af12c532c57                    !text xfat,xd1,":",xfn1,",S,W"
   534                          
   535                          fconc            = *-tabld-1                              ; Concat
   536  76b8 43d23af23dd23af2...                 !text "C",xd2,":",xfn2,"=",xd2,":",xfn2,","
   537                          
   538                          fapn             = *-tabld-1                              ; Append
   539  76c1 d13af12c41                          !text xd1,":",xfn1,",A"
   540                          
   541                          fhed             = *-tabld-1                              ; Header
   542  76c6 4ed13af12cd0                        !text "N",xd1,":",xfn1,",",xid
   543                          
   544                          fcoll            = *-tabld-1                              ; Collect
   545  76cc 56d1                                !text "V",xd1
   546                          
   547                          fbak             = *-tabld-1                              ; Backup
   548  76ce 44d23dd1                            !text "D",xd2,"=",xd1
   549                          
   550                          fcopy            = *-tabld-1                              ; Copy
   551  76d2 43d23af23dd13af1                    !text "C",xd2,":",xfn2,"=",xd1,":",xfn1
   552                          
   553                          fren             = *-tabld-1                              ; Rename
   554  76da 52d13af23dd13af1                    !text "R",xd1,":",xfn2,"=",xd1,":",xfn1
   555                          
   556                          fscr             = *-tabld-1                              ; Scratch
   557  76e2 53d13af1                            !text "S",xd1,":",xfn1
   558                          
   559                          frscr            = *-tabld-1                              ; Recover Del  [901024]
   560  76e6 462d52d13af1                        !text "F-R",xd1,":",xfn1
   561                          
   562                          fdisk            = *-tabld-1                              ; Disk command  [910123]
   563  76ec f0f1                                !text xfat,xfn1                          ; pass '/' [911030]
   564                          
   565                          frec             = *-tabld-1                              ; Record
   566  76ee 50c2e2e0                            !text "P",xsca,xrcl,xrec
   567                          

; ******** Source: basic.asm

; ******** Source: dos/sendparam.asm
     1                          ; Send parameters to device
     2                          ;
     3                          ; Entry: .a = number of bytes in format
     4                          ;  .y = pointer to TABLD entry
     5                          
     6  76f2 8d8411             sendp            sta xcnt                                 ; save number of string bytes
     7  76f5 5a                                  phy
     8  76f6 208278                              jsr Clear_DS                             ; clear old status
     9                          
    10  76f9 a200                                ldx #0
    11  76fb 68                 sdp1             pla
    12  76fc ce8411                              dec xcnt
    13  76ff 304d                                bmi tranr
    14  7701 a8                                  tay
    15  7702 c8                                  iny                                      ; move down table
    16  7703 5a                                  phy
    17  7704 b99876                              lda tabld,y                              ; get next entry
    18  7707 103f                                bpl sdp5                                 ; if not escape code
    19  7709 c9c2                                cmp #xsca                                ; if not secondary address
    20  770b f058                                beq rsca
    21  770d c9d0                                cmp #xid
    22  770f f06a                                beq rid                                  ; if disk id
    23  7711 c9e2                                cmp #xrcl
    24  7713 f38400                              +lbeq rdcn                               ; if record number
    25  7716 c9e1                                cmp #xwrt
    26  7718 f06d                                beq rwrt                                 ; if W or L
    27  771a c9f0                                cmp #xfat
    28  771c f04c                                beq rfat                                 ; if "@" symbol request
    29  771e c9f1                                cmp #xfn1
    30  7720 f38100                              +lbeq rsfn                               ; if filename 1
    31  7723 c9f2                                cmp #xfn2
    32  7725 f39200                              +lbeq rdfn                               ; if filename 2
    33  7728 c9e0                                cmp #xrec
    34  772a d00a                                bne sdp2                                 ; if not record type
    35  772c ad8b11                              lda dosrcl                               ; get rec #
    36  772f c901                                cmp #1                                   ; kludge to allow DOPEN#lf,"relfile",L  [911024]
    37  7731 d015                                bne sdp5                                 ; (note RECORD byte 0 = byte 1 anyhow)
    38  7733 3a                                  dec
    39  7734 8012                                bra sdp5                                 ; always branch
    40                          
    41  7736 c9d1               sdp2             cmp #xd1
    42  7738 d005                                bne sdp3                                 ; if not drive 1
    43  773a ad8611                              lda dosds1
    44  773d 8007                                bra sdp4                                 ; always branch
    45                          
    46  773f c9d2               sdp3             cmp #xd2
    47  7741 d0b8                                bne sdp1                                 ; if not drive 2, continue
    48  7743 ad8811                              lda dosds2
    49  7746 0930               sdp4             ora #'0'                                 ; change # to PETSCII
    50                          
    51  7748 9d0013             sdp5             sta dosstr,x                             ; else into buffer
    52  774b e8                                  inx
    53  774c 80ad                                bra sdp1                                 ; always
    54                          
    55                          
    56  774e 8a                 tranr            txa                                      ; length to a
    57  774f 48                                  pha
    58  7750 a200                                ldx #<dosstr                             ; set filename
    59  7752 a013                                ldy #>dosstr
    60  7754 20bdff                              jsr _setnam
    61                          
    62  7757 ad8111                              lda dosla                                ; set channel
    63  775a ae8211                              ldx dosfa
    64  775d ac8311                              ldy dossa
    65  7760 20baff                              jsr _setlfs
    66                          
    67  7763 68                                  pla
    68  7764 60                                  rts
    69                          
    70                          
    71                          
    72                          
    73  7765 ad9011             rsca             lda dossa_temp                           ; secondary address (record)
    74  7768 80de                                bra sdp5                                 ; always
    75                          
    76                          
    77  776a 7f7f04             rfat             bbr7 parsts,l240_1                       ; if "@" not encountered
    78  776d a940                                lda #'@'
    79  776f 80d7                                bra sdp5                                 ; always
    80                          
    81  7771 ad8f11             l240_1           lda dosflags
    82  7774 4a                                  lsr
    83  7775 9084                                bcc sdp1                                 ; if "/" not encountered
    84  7777 a92f                                lda #'/'
    85  7779 80cd                                bra sdp5
    86                          
    87                          
    88                          ; ID subroutine
    89                          
    90  777b ad8d11             rid              lda dosdid                               ; include id
    91  777e 9d0013                              sta dosstr,x
    92  7781 e8                                  inx
    93  7782 ad8e11                              lda dosdid+1
    94  7785 80c1                                bra sdp5                                 ; always
    95                          
    96                          
    97  7787 ad8b11             rwrt             lda dosrcl                               ; check for L or W
    98  778a f004                                beq l241_1                               ; zero then write
    99  778c a94c                                lda #'L'
   100  778e 80b8                                bra sdp5                                 ; always
   101                          
   102  7790 a953               l241_1           lda #'S'                                 ; send W,S
   103  7792 8d8b11                              sta dosrcl
   104  7795 a957                                lda #'W'
   105  7797 80af                                bra sdp5                                 ; always
   106                          
   107                          
   108                          
   109                          ; Move record number
   110                          
   111  7799 a516               rdcn             lda poker
   112  779b 9d0013                              sta dosstr,x
   113  779e a517                                lda poker+1
   114  77a0 e8                                  inx
   115  77a1 80a5                                bra sdp5                                 ; always
   116                          
   117                          
   118                          ; Move file names
   119                          
   120  77a3 ac8511             rsfn             ldy dosf1l                               ; file name 1: get length
   121  77a6 f030                                beq rdrt0                                ; if null string
   122                          
   123  77a8 a000                                ldy #0                                   ; move name to dosstr
   124  77aa b99111             l242_1           lda savram,y
   125  77ad 9d0013                              sta dosstr,x
   126  77b0 e8                                  inx
   127  77b1 c8                                  iny
   128  77b2 cc8511                              cpy dosf1l
   129  77b5 d0f3                                bne l242_1                               ; if move not complete
   130  77b7 8020                                bra rdrt1                                ; always
   131                          
   132                          
   133  77b9 ad8911             rdfn             lda dosf2a
   134  77bc 8524                                sta index1
   135  77be ad8a11                              lda dosf2a+1
   136  77c1 8525                                sta index1+1
   137  77c3 ac8711                              ldy dosf2l
   138  77c6 f010                                beq rdrt0                                ; if null string
   139                          
   140  77c8 a000                                ldy #0                                   ; move name to dosstr
   141  77ca 20d522             l243_1           jsr indin1_ram1
   142  77cd 9d0013                              sta dosstr,x
   143  77d0 e8                                  inx
   144  77d1 c8                                  iny
   145  77d2 cc8711                              cpy dosf2l
   146  77d5 d0f3                                bne l243_1                               ; if move not complete
   147  77d7 89                                  !text $89                                ; hop
   148                          
   149  77d8 ca                 rdrt0            dex                                      ; case cdd=sd
   150  77d9 8320ff             rdrt1            +lbra sdp1                               ; get next symbol
   151                          
   152                          
   153                          ; Syntax checker DOS write
   154                          
   155  77dc 29e6               chk1             and #$e6                                 ; for HEADER, DLOAD, SCRATCH, TYPE, LIST
   156  77de d36ab6                              +lbne snerr
   157                          
   158  77e1 a57f               chk2             lda parsts                               ; for DSAVE
   159  77e3 2901                                and #1
   160  77e5 c901                                cmp #1                                   ; check required parameters
   161  77e7 d361b6                              +lbne snerr                              ; error if 1 missing
   162  77ea a57f                                lda parsts                               ; reload for return
   163  77ec 60                                  rts
   164                          
   165                          
   166  77ed 29e7               chk3             and #$e7                                 ; for COLLECT
   167  77ef d359b6                              +lbne snerr                              ; check optional parameters
   168  77f2 60                                  rts
   169                          
   170                          
   171  77f3 29c4               chk4             and #$c4                                 ; for COPY, CONCAT
   172  77f5 d353b6                              +lbne snerr                              ; check optional parameters
   173  77f8 a57f                                lda parsts
   174  77fa 2903               chk5             and #3                                   ; for RENAME
   175  77fc c903                                cmp #3                                   ; check required parameters
   176  77fe d34ab6                              +lbne snerr
   177  7801 a57f                                lda parsts                               ; reload for return
   178  7803 60                                  rts
   179                          
   180                          
   181  7804 2905               chk6             and #5                                   ; for APPEND, DOPEN
   182  7806 c905                                cmp #5                                   ; check required parameters
   183  7808 d340b6                              +lbne snerr
   184  780b a57f                                lda parsts                               ; reload for rts
   185  780d 60                                  rts
   186                          
   187                          ;.end
   188                          
   189                          
   190                          
   191                          ; Allocate DS$ if nesessary, but use old DS$ string otherwise
   192                          ; Called by DS$ and DS
   193                          
   194                          Check_DS                                                  ; chkds.
   195  780e a579                                lda dsdesc
   196  7810 f005                                beq Read_DS_1                            ; branch if DS$ is not in memory
   197  7812 60                                  rts                                      ; else return & use old one
   198                          
   199                          
   200                          ; Allocate DS$ if necessary & Read DOS error channel
   201                          
   202                          Read_DS                                                   ; errchl.
   203  7813 a579                                lda dsdesc                               ; has DS$ space been allocated?
   204  7815 d01a                                bne Read_DS_2                            ; yes
   205                          
   206                          Read_DS_1
   207  7817 a928                                lda #40                                  ; no- get 40 char string
   208  7819 8579                                sta dsdesc
   209  781b 20dd5b                              jsr getspa                               ; allocate space for DS$
   210  781e 867a                                stx dsdesc+1                             ; low address of string
   211  7820 847b                                sty dsdesc+2                             ; high   "    "    "
   212  7822 a27a                                ldx #dsdesc+1                            ; set up string back pointer to dsdesc
   213  7824 a028                                ldy #40
   214  7826 a979                                lda #<dsdesc
   215  7828 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y
   216  782b c8                                  iny
   217  782c a900                                lda #>dsdesc
   218  782e 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y
   219                          
   220                          Read_DS_2
   221  7831 ae8211                              ldx dosfa                                ; fa
   222  7834 e002                                cpx #2
   223  7836 b006                                bcs l244_1                               ; if =0 or 1 use default  [910429]
   224  7838 ae0611                              ldx _default_drive                       ; (was dosffn)   [900710]
   225  783b 8e8211                              stx dosfa
   226  783e a900               l244_1           lda #doslfn                              ; la (reserved la)
   227  7840 a06f                                ldy #$6f                                 ; sa (command channel)
   228  7842 20baff                              jsr _setlfs
   229  7845 a900                                lda #0                                   ; no name (so no setbank)
   230  7847 20bdff                              jsr _setnam
   231  784a 20c0ff                              jsr _open                                ; get command channel
   232  784d a200                                ldx #doslfn
   233  784f 20c6ff                              jsr _chkin
   234  7852 b023                                bcs l244_4                               ; a problem (file already open??)
   235                          
   236  7854 a0ff                                ldy #$ff
   237  7856 c8                 l244_2           iny                                      ; read disk error message
   238  7857 20cfff                              jsr _basin
   239  785a c90d                                cmp #cr
   240  785c f009                                beq l244_3                               ; if eol
   241  785e a27a                                ldx #dsdesc+1
   242  7860 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y copy to DS$
   243  7863 c028                                cpy #40
   244  7865 90ef                                bcc l244_2                               ; loop unless too long
   245                          
   246  7867 a900               l244_3           lda #0                                   ; errend.
   247  7869 a27a                                ldx #dsdesc+1                            ; terminate DS$ with a null
   248  786b 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y
   249                          
   250  786e 20ccff                              jsr _clrch                               ; shut down command channel
   251  7871 a900                                lda #doslfn
   252  7873 38                                  sec                                      ; not a real close
   253  7874 4cc3ff                              jmp _close                               ; close it and rts
   254                          
   255  7877 48                 l244_4           pha                                      ; errbad.
   256  7878 206778                              jsr l244_3
   257  787b 208278                              jsr Clear_DS                             ; flag 'no DS available'
   258  787e fa                                  plx                                      ; get error
   259  787f 83ceb5                              +lbra error
   260                          
   261                          
   262                          ; Clear_DS subroutine - forget current DS$ message, if any
   263                          ;
   264                          
   265                          Clear_DS                                                  ; oldclr.
   266  7882 a579                                lda dsdesc                               ; check for allocation
   267  7884 f013                                beq l245_1                               ; branch if not allocated
   268                          
   269  7886 5a                                  phy                                      ; mark current DS$ string as garbage
   270  7887 da                                  phx
   271                          ; lda #40   ;   standard DS$ allocation
   272  7888 a8                                  tay
   273  7889 a27a                                ldx #dsdesc+1
   274  788b 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y length of garbage
   275  788e c8                                  iny
   276  788f a9ff                                lda #$ff
   277  7891 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y garbage flagged
   278  7894 1a                                  inc
   279  7895 8579                                sta dsdesc                               ; (0)    kill DS$
   280  7897 fa                                  plx
   281  7898 7a                                  ply
   282                          
   283  7899 60                 l245_1           rts
   284                          
   285                          
   286                          ; Read DOS error message, but don't care what it is.  Want to stop disk LED blink.
   287                          ;
   288                          
   289                          Suck_DS
   290  789a ae8211                              ldx dosfa                                ; fa
   291  789d a900                                lda #doslfn                              ; la (reserved la)
   292  789f a06f                                ldy #$6f                                 ; sa (command channel)
   293  78a1 20baff                              jsr _setlfs
   294  78a4 a900                                lda #0                                   ; no name (so no setbank)
   295  78a6 20bdff                              jsr _setnam
   296  78a9 20c0ff                              jsr _open                                ; get command channel
   297  78ac a200                                ldx #doslfn
   298  78ae 20c6ff                              jsr _chkin
   299  78b1 b007                                bcs l246_2                               ; skip input if problem
   300                          
   301  78b3 20cfff             l246_1           jsr _basin                               ; read disk error message
   302  78b6 c90d                                cmp #cr
   303  78b8 d0f9                                bne l246_1                               ; loop until eol
   304                          
   305  78ba 20ccff             l246_2           jsr _clrch                               ; shut down command channel
   306  78bd a900                                lda #doslfn
   307  78bf 38                                  sec                                      ; not a real close
   308  78c0 4cc3ff                              jmp _close                               ; close it
   309                          
   310                          
   311                          ; R-U-sure subroutine
   312                          
   313                          are_you_sure
   314                          
   315  78c3 ff7e29                              bbs7 runmod,response_fake                ; branch if not direct mode
   316                          
   317  78c6 207dff                              jsr _primm                               ; else prompt user for y/n answer
   318  78c9 41524520594f5520...                 !text "ARE YOU SURE? ", 0
   319                          
   320                          
   321                          response_get
   322  78d8 20ccff                              jsr _clrch                               ; clear channel for basin
   323  78db 20cfff                              jsr _basin                               ; next char
   324  78de 48                                  pha                                      ; save first char of reply
   325                          
   326  78df c90d               l247_1           cmp #cr                                  ; eat chars until end of line
   327  78e1 f005                                beq l247_2                               ; if cr received, exit
   328  78e3 20cfff                              jsr _basin
   329  78e6 d0f7                                bne l247_1                               ; continue to ignore
   330                          
   331  78e8 20d2ff             l247_2           jsr _bsout                               ; new line     [910212] FAB
   332  78eb 68                                  pla
   333  78ec c959                                cmp #'Y'                                 ; z set means ans=y.....
   334  78ee 60                                  rts
   335                          
   336                          
   337                          response_fake
   338  78ef a900                                lda #0                                   ; ...or not in direct mode
   339  78f1 60                                  rts
   340                          
   341                          ;.end
   342                          
   343                          
   344                          
   345                          ;*****************************************************************
   346                          ;  OPTWRD - get an optional, unsigned 2-byte value in y,a.
   347                          ;
   348                          ;      case 1 : pointer at end of line:
   349                          ;   return a=y=0, clear c to flag 'default'
   350                          ;      case 2 : pointer is at comma, next non-blank is also a comma:
   351                          ;   return a=y=0, clear c to flag 'default'
   352                          ;      case 3 : pointer is at comma, next non-blank is not a comma:
   353                          ;   get word in y,a, set c to flag 'non-default'
   354                          ;*****************************************************************
   355                          
   356  78f2 208522             optwrd           jsr chrgot
   357  78f5 f00c                                beq l248_1
   358  78f7 205b4e                              jsr chkcom
   359  78fa c92c                                cmp #','
   360  78fc f005                                beq l248_1
   361  78fe 208a5d                              jsr getwrd
   362  7901 38                                  sec
   363  7902 60                                  rts
   364                          
   365  7903 a900               l248_1           lda #0
   366  7905 a8                                  tay
   367                          
   368  7906 18                 optw99           clc
   369  7907 60                                  rts
   370                          
   371                          
   372  7908 205b4e             comsad           jsr chkcom                               ; get a comma & signed 2-byte arg in y,a   [910307]
   373  790b 83d83e                              +lbra sadwrd
   374                          
   375                          
   376                          
   377  790e 208522             optsad           jsr chrgot                               ; get a comma & optional, signed 2-byte arg in y,a [910307]
   378  7911 f00c                                beq l249_1                               ; eol, therefore this arg is not specified
   379  7913 205b4e                              jsr chkcom                               ; eat comma
   380  7916 c92c                                cmp #','                                 ; is next a comma too?
   381  7918 f005                                beq l249_1                               ; yes, therefore this arg is not specified
   382  791a 20e5b7                              jsr sadwrd                               ; get signed word
   383  791d 38                                  sec
   384  791e 60                                  rts
   385                          
   386  791f a900               l249_1           lda #0                                   ; default optional arg to zero
   387  7921 a8                                  tay
   388  7922 18                                  clc
   389  7923 60                                  rts
   390                          
   391                          
   392                          ;*****************************************************************
   393                          ;  OPTBYT - get an optional 1 byte value in x.
   394                          ;
   395                          ;  Enter with default value in x.
   396                          ;
   397                          ;      case 1 : pointer at end of line:
   398                          ;   return default x.
   399                          ;      case 2 : pointer is at comma, next non-blank is also a comma:
   400                          ;   return default x.
   401                          ;      case 3 : pointer is at comma, next non-blank is not a comma:
   402                          ;   get byte in x.
   403                          ;*****************************************************************
   404                          
   405  7924 a200               optzer           ldx #0                                   ; optional byte, with default=0
   406                          
   407  7926 208522             optbyt           jsr chrgot
   408  7929 f0db                                beq optw99                               ; EOL: clc/rts
   409  792b 205b4e                              jsr chkcom
   410  792e c92c                                cmp #','
   411  7930 f0d4                                beq optw99                               ; Comma: clc/rts
   412  7932 206c5d                              jsr getbyt
   413  7935 38                                  sec
   414  7936 60                                  rts
   415                          
   416                          
   417                          prtdec
   418  7937 5a                                  phy
   419  7938 da                                  phx
   420  7939 aa                                  tax                                      ; prints decimal value of chr in .a
   421  793a a900                                lda #0
   422  793c 207f64                              jsr linprt
   423  793f fa                                  plx
   424  7940 7a                                  ply
   425  7941 60                                  rts
   426                          
   427                          
   428                          
   429                          retpat                                                    ; f.bowen
   430  7942 88                                  dey                                      ; [910828]
   431  7943 b13f                                lda (fndpnt),y                           ; restore pointers
   432  7945 853e                                sta txtptr+1
   433  7947 88                                  dey
   434  7948 b13f                                lda (fndpnt),y
   435  794a 853d                                sta txtptr
   436  794c 88                                  dey
   437  794d b13f                                lda (fndpnt),y
   438                          
   439  794f 853c                                sta curlin+1                             ; fixes a problem when RETURNing to a GOSUB in direct mode
   440  7951 88                                  dey                                      ; or LOOPing to a DO in direct mode. 'curlin+1' must not be
   441  7952 aa                                  tax                                      ; restored to $ff without also resetting 'runmod'
   442  7953 e8                                  inx
   443  7954 d004                                bne l250_1                               ; branch if GOSUB or DO was from a program
   444  7956 a9c0                                lda #%11000000
   445  7958 147e                                trb runmod                               ; else force return to direct mode
   446                          
   447  795a b13f               l250_1           lda (fndpnt),y
   448  795c 853b                                sta curlin
   449  795e 60                                  rts
   450                          
   451                          
   452  795f 010204010204       vbits            !text $01,$02,$04,$01,$02,$04            ; for stereo filter, volume bit setting
   453  7965 0102040810204080   sbits            !text $01,$02,$04,$08,$10,$20,$40,$80
   454  796d 8040201008040201   rbits            !text $80,$40,$20,$10,$08,$04,$02,$01
   455                          

; ******** Source: basic.asm

; ******** Source: handler/irq.asm
     1                          
     2                          
     3                          
     4                          basic_irq
     5                          ; lda _vicIRQ  ;a VIC raster interrupt?
     6                          ; and #%10000001  ; (used to update moving sprites & sound stuff)
     7                          ; cmp #%10000001
     8                          ; bne collision_irq ; no, go check other VIC interrupts
     9                          
    10  7975 addb02                              lda irq_wrap_flag                        ; filter out wrapped IRQ calls (allows interruptable code)
    11  7978 f001                                beq l251_1                               ; it's ok
    12  797a 60                                  rts                                      ; exit- we're already handling one interrupt
    13                          
    14  797b eedb02             l251_1           inc irq_wrap_flag                        ; shut the door
    15  797e 58                                  cli                                      ; but leave the window open
    16                          
    17                          
    18                          ; Test if there was a VIC collision/light pen interrupt
    19                          
    20                          collision_irq
    21                          ; sei
    22  797f a5a0                                lda _vicIRQ                              ; check VIC IRQ flags
    23  7981 290e                                and #%00001110                           ; mask all but lp, s/s, and s/bgnd flags
    24  7983 f04c                                beq l252_5                               ; exit if none set
    25  7985 14a0                                trb _vicIRQ                              ; else reset flags we're going to handle
    26  7987 4a                                  lsr                                      ; shift out raster interrupt bit (not used)
    27                          
    28                          ; Test for 3 types of collision interrupts : sprite/sprite, sprite/bgnd, & light pen
    29                          
    30  7988 a001                                ldy #1                                   ; loop for sprite/bgnd and sprite/sprite collision check
    31  798a 4a                 l252_1           lsr
    32  798b 901b                                bcc l252_4                               ; bit not set ==> not source of interrupt
    33                          
    34  798d 48                                  pha
    35  798e b91ed0                              lda vic+30,y                             ; accumulate collision data (resets register)
    36  7991 19e602                              ora collisions,y
    37  7994 99e602                              sta collisions,y
    38                          
    39  7997 addc02                              lda intval                               ; allowable interrupts
    40  799a c000                                cpy #0                                   ; examine selected bit
    41  799c f001                                beq l252_2
    42  799e 4a                                  lsr
    43  799f 4a                 l252_2           lsr
    44  79a0 9005                                bcc l252_3                               ; BASIC doesn't want this interrupt
    45  79a2 a9ff                                lda #$ff
    46  79a4 99dd02                              sta int_trip_flag,y                      ; turn on trip flag
    47                          
    48  79a7 68                 l252_3           pla
    49                          
    50  79a8 88                 l252_4           dey
    51  79a9 10df                                bpl l252_1
    52                          
    53                          
    54                          ; Check light pen latch
    55                          
    56  79ab 4a                                  lsr
    57  79ac 9023                                bcc l252_5                               ; LightPen latch not valid
    58                          
    59  79ae ae31d0                              ldx vic+49                               ; 4567R7 bug- must read LP_latches in Slow mode????
    60  79b1 a940                                lda #%01000000                           ; [910618]
    61  79b3 1c31d0                              trb vic+49
    62  79b6 ac13d0                              ldy vic+19                               ; save latched x position
    63  79b9 8ce802                              sty lightpen_xpos
    64  79bc ac14d0                              ldy vic+20                               ; save latched y position
    65  79bf 8ce902                              sty lightpen_ypos
    66  79c2 8e31d0                              stx vic+49                               ; restore speed     [910618]
    67                          
    68  79c5 addc02                              lda intval                               ; is BASIC interested in our little find?
    69  79c8 2904                                and #4
    70  79ca f005                                beq l252_5                               ; no, move on to next IRQ task
    71  79cc a9ff                                lda #$ff
    72  79ce 8ddf02                              sta int_trip_flag+2                      ; yes- let BASIC know we caught one
    73                          
    74                          l252_5
    75                          
    76                          ; Update moving sprites
    77                          
    78                          movspr_irq
    79  79d1 ad15d0                              lda vic+21                               ; any sprites active?    [910212]
    80  79d4 f3f100                              +lbeq music_irq                          ; no- skip ahead
    81                          
    82  79d7 a007                                ldy #7                                   ; check each of 8 sprites
    83  79d9 ad15d0             l253_1           lda vic+21                               ; is this sprite is enabled?
    84  79dc 396579                              and sbits,y
    85  79df f03d                                beq l253_5                               ; sprite not enabled
    86                          
    87  79e1 befeb7                              ldx sproff,y                             ; get offset to sprite info from a table
    88  79e4 bd0512                              lda sprite_data,x                        ; is this sprite moving (speed >0 )?
    89  79e7 f035                                beq l253_5                               ; sprite not moving
    90  79e9 1005                                bpl l253_2                               ; sprite moving, no destination
    91  79eb 633700                              bsr movspr_to_irq                        ; sprite moving to a destination [910809]
    92  79ee 802e                                bra l253_5
    93                          
    94  79f0 9d0612             l253_2           sta sprite_data+1,x                      ; set counter
    95  79f3 98                 l253_3           tya                                      ; convert sprite# to a VIC register pointer
    96  79f4 0a                                  asl
    97  79f5 a8                                  tay
    98  79f6 bd0712                              lda sprite_data+2,x                      ; get angle sign
    99  79f9 3a                                  dec                                      ; subtract 1 for cosine
   100  79fa e8                                  inx
   101  79fb e8                                  inx
   102  79fc c8                                  iny
   103  79fd 20c67b                              jsr sprsub                               ; update y position
   104  7a00 ca                                  dex
   105  7a01 ca                                  dex
   106  7a02 88                                  dey
   107  7a03 bd0712                              lda sprite_data+2,x
   108  7a06 20c67b                              jsr sprsub                               ; update x position
   109  7a09 08                                  php
   110  7a0a 98                                  tya
   111  7a0b 4a                                  lsr                                      ; restore index (.Y=sprite pointer)
   112  7a0c a8                                  tay
   113  7a0d 28                                  plp
   114  7a0e 9009                                bcc l253_4                               ; skip if no overflow
   115  7a10 ad10d0                              lda vic+16                               ; get x position msb bits ???vic_save
   116  7a13 596579                              eor sbits,y                              ; invert bit
   117  7a16 8d10d0                              sta vic+16                               ; ???vic_save
   118  7a19 de0612             l253_4           dec sprite_data+1,x
   119  7a1c d0d5                                bne l253_3                               ; loop until counter done
   120                          
   121  7a1e 88                 l253_5           dey                                      ; check next sprite
   122  7a1f 10b8                                bpl l253_1                               ; loop until done moving all sprites
   123  7a21 83a400                              +lbra music_irq                          ; then continue with next IRQ task
   124                          
   125                          movspr_to_irq                                             ; [910809]
   126  7a24 5a                                  phy                                      ; sprite #
   127  7a25 293f                                and #$3f                                 ; speed factor
   128  7a27 4b                                  taz
   129  7a28 98                                  tya                                      ; vic sprite index
   130  7a29 0a                                  asl
   131  7a2a a8                                  tay
   132                          
   133  7a2b 38                 l254_1           sec                                      ; for i = 1 to abs(greatr)
   134  7a2c bd0612                              lda sprite_data+1,x
   135  7a2f e901                                sbc #1
   136  7a31 9d0612                              sta sprite_data+1,x
   137  7a34 b011                                bcs l254_2
   138  7a36 bd0712                              lda sprite_data+2,x
   139  7a39 e900                                sbc #0
   140  7a3b 9d0712                              sta sprite_data+2,x
   141  7a3e b007                                bcs l254_2
   142  7a40 a900                                lda #0
   143  7a42 9d0512                              sta sprite_data,x                        ; done!  sprite is at its destination
   144  7a45 7a                                  ply                                      ; remember sprite #
   145  7a46 60                                  rts
   146                          
   147  7a47 bd0812             l254_2           lda sprite_data+3,x                      ; ptr(lesser)
   148  7a4a 3c0f12                              bit sprite_data+10,x
   149  7a4d 3009                                bmi l254_3                               ; if e > 0
   150  7a4f 3c0812                              bit sprite_data+3,x                      ; sgn(lesser) (b7=1=neg, b6=1=pos, else 0)
   151  7a52 20907a                              jsr drwinc                               ; pos(lesser) = pos(lesser) + sgn(lesser)
   152                          
   153  7a55 bd0912                              lda sprite_data+4,x                      ; ptr(greater)
   154  7a58 4a                 l254_3           lsr                                      ; which f?
   155  7a59 b014                                bcs l254_4
   156  7a5b bd0e12                              lda sprite_data+9,x                      ; e = e + f1
   157  7a5e 7d0a12                              adc sprite_data+5,x
   158  7a61 9d0e12                              sta sprite_data+9,x
   159  7a64 bd0f12                              lda sprite_data+10,x
   160  7a67 7d0b12                              adc sprite_data+6,x
   161  7a6a 9d0f12                              sta sprite_data+10,x
   162  7a6d 8013                                bra l254_5
   163                          
   164  7a6f 18                 l254_4           clc
   165  7a70 bd0e12                              lda sprite_data+9,x                      ; e = e + f2
   166  7a73 7d0c12                              adc sprite_data+7,x
   167  7a76 9d0e12                              sta sprite_data+9,x
   168  7a79 bd0f12                              lda sprite_data+10,x
   169  7a7c 7d0d12                              adc sprite_data+8,x
   170  7a7f 9d0f12                              sta sprite_data+10,x
   171                          
   172  7a82 bd0912             l254_5           lda sprite_data+4,x                      ; ptr(greater)
   173  7a85 3c0912                              bit sprite_data+4,x                      ; sgn(greater) (b7=1=neg, b6=1=pos, else 0)
   174  7a88 20907a                              jsr drwinc                               ; pos(greater) = pos(greater) + sgn(greater)
   175                          
   176  7a8b 3b                                  dez                                      ; count
   177  7a8c d09d                                bne l254_1
   178  7a8e 7a                                  ply                                      ; remember sprite #
   179  7a8f 60                                  rts                                      ; done this frame
   180                          
   181                          
   182  7a90 08                 drwinc           php
   183  7a91 2901                                and #1                                   ; adjust .y for x or y position
   184  7a93 f001                                beq l255_1                               ; 0=x
   185  7a95 c8                                  iny                                      ; 1=y
   186  7a96 28                 l255_1           plp
   187  7a97 300b                                bmi l255_2                               ; enter with b7=negative, b6=positive, else zero
   188  7a99 5027                                bvc l255_4
   189                          
   190  7a9b b900d0                              lda vic,y                                ; positive direction
   191  7a9e 1a                                  inc
   192  7a9f 9900d0                              sta vic,y
   193  7aa2 8009                                bra l255_3
   194                          
   195  7aa4 b900d0             l255_2           lda vic,y                                ; negative direction
   196  7aa7 3a                                  dec
   197  7aa8 9900d0                              sta vic,y
   198  7aab c9ff                                cmp #$ff
   199                          
   200  7aad d013               l255_3           bne l255_4                               ; no wrap
   201  7aaf 98                                  tya
   202  7ab0 8901                                bit #1
   203  7ab2 d00e                                bne l255_4                               ; wrap in y okay
   204  7ab4 4a                                  lsr
   205  7ab5 a8                                  tay
   206  7ab6 b96579                              lda sbits,y                              ; wrap in x- toggle msb
   207  7ab9 4d10d0                              eor vic+16
   208  7abc 8d10d0                              sta vic+16
   209  7abf 98                                  tya
   210  7ac0 0a                                  asl
   211  7ac1 a8                                  tay
   212                          
   213  7ac2 98                 l255_4           tya                                      ; restore y to sprite offset
   214  7ac3 29fe                                and #$fe
   215  7ac5 a8                                  tay
   216  7ac6 60                                  rts
   217                          
   218                          
   219                          ; Play music, if in progress
   220                          
   221                          music_irq
   222  7ac7 a200                                ldx #0
   223  7ac9 bc5e12             l256_1           ldy voices+1,x
   224  7acc 3025                                bmi l256_2                               ; skip if not active
   225                          
   226  7ace bd5d12                              lda voices,x
   227  7ad1 38                                  sec
   228  7ad2 ed7312                              sbc tempo_rate                           ; decrement current value by current tempo
   229  7ad5 9d5d12                              sta voices,x
   230  7ad8 b019                                bcs l256_2
   231  7ada 98                                  tya                                      ; lda voices+1,x
   232  7adb e900                                sbc #0
   233  7add 9d5e12                              sta voices+1,x
   234  7ae0 b011                                bcs l256_2                               ; ok, no underflow
   235                          
   236  7ae2 8a                                  txa
   237  7ae3 4a                                  lsr                                      ; get offset to waveform
   238  7ae4 a8                                  tay
   239  7ae5 b96912                              lda waveform,y                           ; get waveform
   240  7ae8 29fe                                and #$fe                                 ; mask out gate bit
   241  7aea 48                                  pha
   242  7aeb b9004a                              lda SID_offset,y                         ; get offset to correct oscillator
   243  7aee a8                                  tay
   244  7aef 68                                  pla
   245                          ; jsr go_slow  ;      [910716] 4567R7A
   246  7af0 9904d4                              sta sid1+4,y                             ; turn off sound
   247                          ; jsr go_fast  ;      [910716] 4567R7A
   248                          
   249  7af3 e8                 l256_2           inx
   250  7af4 e8                                  inx
   251  7af5 e00c                                cpx #6+6                                 ; [910612]
   252  7af7 90d0                                bcc l256_1                               ; loop for 6 voices
   253                          ;then continue with next IRQ task
   254                          
   255                          ; Test if SOUND command wants anything
   256                          
   257                          sound_irq
   258  7af9 a005                                ldy #6-1                                 ; test six voices    [910612]
   259  7afb b9c412             l257_1           lda sound_time_hi,y                      ; active if msb clear
   260  7afe 1006                                bpl l257_3
   261  7b00 88                 l257_2           dey
   262  7b01 10f8                                bpl l257_1
   263  7b03 83bc00                              +lbra basic_irq_end
   264                          
   265  7b06 18                 l257_3           clc                                      ; add step to frequency
   266  7b07 b9f412                              lda sound_freq_lo,y
   267  7b0a 79e812                              adc sound_step_lo,y
   268  7b0d 99f412                              sta sound_freq_lo,y
   269  7b10 b9fa12                              lda sound_freq_hi,y
   270  7b13 79ee12                              adc sound_step_hi,y
   271  7b16 99fa12                              sta sound_freq_hi,y
   272                          
   273  7b19 b9e212                              lda sound_direction,y                    ; test if this is up or down
   274  7b1c aa                                  tax
   275  7b1d 2901                                and #1
   276  7b1f f02d                                beq l257_6                               ; branch if up
   277                          
   278                          ; If step direction is down, .C==0 OR freq < min  ==> reset value
   279                          
   280  7b21 900f                                bcc l257_4                               ; underflow, reset
   281  7b23 38                                  sec
   282  7b24 b9f412                              lda sound_freq_lo,y
   283  7b27 f9d612                              sbc sound_min_lo,y
   284  7b2a b9fa12                              lda sound_freq_hi,y
   285  7b2d f9dc12                              sbc sound_min_hi,y
   286  7b30 b04c                                bcs l257_9                               ; no borrow, don't reset
   287                          
   288  7b32 e002               l257_4           cpx #2                                   ; is 'cycle' bit set?
   289  7b34 900a                                bcc l257_5                               ; no, keep direction 'down'
   290                          
   291  7b36 20ab7b                              jsr negate_step                          ; make step 2's comp
   292  7b39 a902                                lda #2                                   ; change direction to 'up'
   293  7b3b 99e212                              sta sound_direction,y
   294  7b3e d032                                bne l257_8                               ; go reset for 'up'
   295                          
   296  7b40 b9ca12             l257_5           lda sound_max_lo,y                       ; reset to max
   297  7b43 99f412                              sta sound_freq_lo,y
   298  7b46 b9d012                              lda sound_max_hi,y
   299  7b49 99fa12                              sta sound_freq_hi,y
   300  7b4c 8030                                bra l257_9                               ; go update SID frequency
   301                          
   302                          ; If step direction is up, overflow (.C==1) OR freq > max ==> reset frequency
   303                          
   304  7b4e b014               l257_6           bcs l257_7                               ; overflow, must reset
   305  7b50 b9fa12                              lda sound_freq_hi,y                      ; 16 bit compare (yech!)
   306  7b53 d9d012                              cmp sound_max_hi,y
   307  7b56 9026                                bcc l257_9                               ; freq < max, no reset
   308  7b58 d00a                                bne l257_7                               ; freq > max, reset
   309  7b5a b9f412                              lda sound_freq_lo,y                      ; msb's the same, test lsb's
   310  7b5d d9ca12                              cmp sound_max_lo,y
   311  7b60 901c                                bcc l257_9                               ; freq < max, no reset
   312  7b62 f01a                                beq l257_9                               ; freq = max, no reset
   313                          
   314  7b64 e002               l257_7           cpx #2                                   ; is this 'cycle'?
   315  7b66 900a                                bcc l257_8                               ; no, go reset for next 'up'
   316                          
   317  7b68 20ab7b                              jsr negate_step                          ; make step 2's comp
   318  7b6b a903                                lda #3                                   ; change direction to 'down'
   319  7b6d 99e212                              sta sound_direction,y
   320  7b70 d0ce                                bne l257_5                               ; go reset for next 'down'
   321                          
   322  7b72 b9d612             l257_8           lda sound_min_lo,y                       ; set freq to minimum value
   323  7b75 99f412                              sta sound_freq_lo,y
   324  7b78 b9dc12                              lda sound_min_hi,y
   325  7b7b 99fa12                              sta sound_freq_hi,y
   326                          
   327                          ; Update SID frequency registers
   328                          
   329                          l257_9
   330                          ; jsr go_slow  ;      [910716] 4567R7A
   331  7b7e be004a                              ldx SID_offset,y                         ; get index to SID voices
   332  7b81 b9f412                              lda sound_freq_lo,y
   333  7b84 9d00d4                              sta sid1,x
   334  7b87 b9fa12                              lda sound_freq_hi,y
   335  7b8a 9d01d4                              sta sid1+1,x
   336                          ; jsr go_fast  ;      [910716] 4567R7A
   337                          
   338                          ; Decrement total time - see if it's time to bring down the curtain
   339                          
   340  7b8d 98                                  tya
   341  7b8e aa                                  tax
   342  7b8f bdbe12                              lda sound_time_lo,x                      ; 16 bit decrement - not very pretty
   343  7b92 d003                                bne l257_10
   344  7b94 dec412                              dec sound_time_hi,x
   345  7b97 debe12             l257_10          dec sound_time_lo,x
   346                          
   347  7b9a bdc412                              lda sound_time_hi,x                      ; underflow?
   348  7b9d 1361ff                              +lbpl l257_2                             ; nope
   349                          
   350                          ; Time to turn off this voice
   351                          
   352                          ; jsr go_slow  ;      [910716] 4567R7A
   353  7ba0 a908                                lda #$08
   354  7ba2 be004a                              ldx SID_offset,y
   355  7ba5 9d04d4                              sta sid1+4,x
   356                          ; jsr go_fast  ;      [910716] 4567R7A
   357  7ba8 8356ff                              +lbra l257_2
   358                          
   359                          
   360                          negate_step
   361  7bab b9e812                              lda sound_step_lo,y
   362  7bae 49ff                                eor #$ff
   363  7bb0 18                                  clc
   364  7bb1 6901                                adc #1
   365  7bb3 99e812                              sta sound_step_lo,y
   366  7bb6 b9ee12                              lda sound_step_hi,y
   367  7bb9 49ff                                eor #$ff
   368  7bbb 6900                                adc #0
   369  7bbd 99ee12                              sta sound_step_hi,y
   370  7bc0 60                                  rts
   371                          
   372                          
   373                          
   374                          ; Here is where BASIC_IRQ exits
   375                          
   376                          basic_irq_end
   377  7bc1 cedb02                              dec irq_wrap_flag                        ; open the door to IRQ
   378  7bc4 58                                  cli
   379  7bc5 60                                  rts
   380                          
   381                          
   382                          ; Update sprite position subroutine
   383                          
   384  7bc6 48                 sprsub           pha                                      ; save angle phase
   385  7bc7 18                                  clc
   386  7bc8 bd0812                              lda sprite_data+3,x                      ; add low bytes
   387  7bcb 7d0c12                              adc sprite_data+7,x
   388  7bce 9d0c12                              sta sprite_data+7,x
   389  7bd1 bd0912                              lda sprite_data+4,x                      ; add high bytes
   390  7bd4 7d0d12                              adc sprite_data+8,x
   391  7bd7 9d0d12                              sta sprite_data+8,x
   392  7bda 68                                  pla                                      ; get angle sign
   393  7bdb 9012                                bcc l258_3                               ; skip if no carry - do not update position
   394  7bdd 4a                                  lsr
   395  7bde 4a                                  lsr                                      ; test if positive or negative
   396  7bdf b900d0                              lda vic,y                                ; ???vic_save
   397  7be2 b004                                bcs l258_1                               ; skip if negative
   398  7be4 6901                                adc #1                                   ; increment position
   399  7be6 8004                                bra l258_2
   400                          
   401  7be8 e901               l258_1           sbc #1                                   ; decrement position
   402  7bea c9ff                                cmp #$ff                                 ; set carry if underflow
   403  7bec 9900d0             l258_2           sta vic,y                                ; decrement position  ???vic_save
   404  7bef 60                 l258_3           rts
   405                          

; ******** Source: basic.asm

; ******** Source: command/mouse.asm
     1                          
     2                          
     3                          
     4                          ;***********************************************************************
     5                          ;*   MOUSE  ON  [,[port] [,[sprite] [,[hotspot] [,X/Yposition] ]]]
     6                          ;*   MOUSE  OFF
     7                          ;*    where: port     = (1...3) for joyport 1, 2, or either (both)
     8                          ;*  sprite   = (0...7) sprite pointer
     9                          ;*  hotspot  = x,y offset in sprite, default 0,0
    10                          ;*  position = normal, relative, or angluar coordinates
    11                          ;*
    12                          ;*      (defaults to sprite 0, port 2, last hotspot & position)
    13                          ;***********************************************************************
    14                          
    15  7bf0 c991               mouse            cmp #on_token                            ; new [910122]
    16  7bf2 f010                                beq l259_1
    17  7bf4 2016b5                              jsr chkesc
    18  7bf7 c924                                cmp #off_token
    19  7bf9 d34fb2                              +lbne snerr
    20                          
    21                          ;    The Kernel MOUSE_CMD is called to install or remove mouse driver.
    22                          ; .a= B7,6 set to install mouse in game port 2 ($80), 1 ($40), or both ($C0)
    23                          ; .a= 0 to disable mouse driver
    24                          ; .x= 0-7 physical sprite pointer
    25                          
    26  7bfc a900                                lda #0                                   ; TURN MOUSE OFF
    27  7bfe 201be0                              jsr _mouse                               ; do it
    28  7c01 831f39                              +lbra chkeos                             ; eat token & exit after checking for eos
    29                          
    30                          ;TURN MOUSE ON
    31  7c04 208322             l259_1           jsr chrget                               ; eat token
    32  7c07 a202                                ldx #2                                   ; get (optional) port# in .X
    33  7c09 202679                              jsr optbyt                               ; if not present default to port 2
    34  7c0c e004                                cpx #4                                   ;
    35  7c0e b3eed5                              +lbcs fcerr                              ; illegal value
    36  7c11 da                                  phx
    37                          
    38  7c12 a200                                ldx #0                                   ; get (optional) sprite# in .X
    39  7c14 202679                              jsr optbyt                               ; if not present default to sprite 0
    40  7c17 e008                                cpx #8
    41  7c19 b3e3d5                              +lbcs fcerr                              ; illegal value
    42  7c1c 8676                                stx z_p_temp_1
    43  7c1e bcfeb7                              ldy sproff,x                             ; kill moving sprite
    44  7c21 a900                                lda #0                                   ; get offset to speed data
    45  7c23 990512                              sta sprite_data,y                        ; reset sprite's speed value
    46                          
    47  7c26 68                                  pla                                      ; setup for Kernel call- get port# into b7,6
    48  7c27 6a                                  ror                                      ; .a= port(s), .x=sprite
    49  7c28 6a                                  ror
    50  7c29 6a                                  ror
    51  7c2a 201be0                              jsr _mouse                               ; do it (???? do after coord error check)
    52                          
    53                          
    54  7c2d 202679                              jsr optbyt                               ; get (optional) hotspot, x  new [910307]
    55  7c30 9014                                bcc l259_2                               ; not given
    56  7c32 e018                                cpx #24
    57  7c34 b3c8d5                              +lbcs fcerr                              ; out of range (0-23)
    58  7c37 8a                                  txa
    59  7c38 42                                  neg
    60  7c39 aa                                  tax
    61  7c3a 6918                                adc #24
    62  7c3c 8d3d11                              sta _mouse_left
    63  7c3f 8a                                  txa
    64  7c40 18                                  clc
    65  7c41 6957                                adc #87
    66  7c43 8d3e11                              sta _mouse_right
    67                          
    68  7c46 202679             l259_2           jsr optbyt                               ; get (optional) hotspot, y
    69  7c49 9014                                bcc l259_3                               ; not given
    70  7c4b e015                                cpx #21
    71  7c4d b3afd5                              +lbcs fcerr                              ; out of range (0-20)
    72  7c50 8a                                  txa
    73  7c51 42                                  neg
    74  7c52 aa                                  tax
    75  7c53 6932                                adc #50
    76  7c55 8d3b11                              sta _mouse_top
    77  7c58 8a                                  txa
    78  7c59 18                                  clc
    79  7c5a 69fa                                adc #250
    80  7c5c 8d3c11                              sta _mouse_bottom
    81                          
    82  7c5f 208522             l259_3           jsr chrgot                               ; get (optional) position coordinate  [910123]
    83  7c62 f028                                beq l259_4                               ; eol, use this sprite's last position
    84  7c64 20c3b7                              jsr sprcor                               ; else get first coordinate
    85  7c67 2cf411                              bit numcnt                               ; test coordinate type
    86  7c6a 73deb1                              +lbvs snerr                              ; syntax error
    87  7c6d 8cf011                              sty xdest                                ; save coordinate value
    88  7c70 8cf211                              sty xdest+2
    89  7c73 8df111                              sta xdest+1
    90  7c76 8df311                              sta xdest+3
    91                          
    92  7c79 a97f                                lda #$7f                                 ; flag 'mouse' for movspr call  [910808]
    93  7c7b 8587                                sta op
    94  7c7d 20c3b7                              jsr sprcor                               ; get second coordinate
    95  7c80 2cf411                              bit numcnt                               ; test type of coordinate
    96  7c83 53bf39                              +lbvc movspr_normal                      ; position sprite, normal coordinates
    97  7c86 339e39                              +lbmi movspr_angle                       ; angular coordinates
    98  7c89 83bfb1                              +lbra snerr                              ; else error
    99                          
   100  7c8c 60                 l259_4           rts
   101                          

; ******** Source: basic.asm

; ******** Source: function/rmouse.asm
     1                          
     2                          
     3                          ;************************************************************************
     4                          ;*   RMOUSE Returns in variable list current status of mouse *
     5                          ;*         *
     6                          ;*   Syntax: RMOUSE [Xposition [,Yposition [, Buttons] ]]  *
     7                          ;*         *
     8                          ;*   Where: X,Yposition = current position of mouse pointer sprite *
     9                          ;*  Button      = current status of mouse buttons  *
    10                          ;*         *
    11                          ;*   0   = no button     *
    12                          ;*   1   = right button    *
    13                          ;*   128 = left button    *
    14                          ;*   129 = both buttons    *
    15                          ;*         *
    16                          ;* If a mouse is not installed, "-1" is returned for all vars. *
    17                          ;* If both ports are enabled, buttons from each port are merged. *
    18                          ;************************************************************************
    19                          
    20  7c8d a900               rmouse           lda #0                                   ; Init
    21  7c8f 850d                                sta count                                ; variable count = 0
    22  7c91 3a                                  dec
    23  7c92 a205                                ldx #6-1
    24  7c94 9587               l260_1           sta grapnt,x                             ; positions/buttons = -1
    25  7c96 ca                                  dex
    26  7c97 10fb                                bpl l260_1
    27                          
    28  7c99 ad3511                              lda _mouse_enable                        ; Is there a mouse in the house?
    29  7c9c 29c0                                and #%11000000
    30  7c9e f050                                beq l260_5                               ; no, exit
    31  7ca0 48                                  pha                                      ; yes, save port assigns for later
    32  7ca1 78                                  sei
    33  7ca2 ac3611                              ldy _mouse_pointer                       ; Where is it?  Get pointer to sprite
    34  7ca5 b900d0                              lda vic,y                                ; Get X position    ???vic_save
    35  7ca8 8587                                sta grapnt                               ; lsb
    36  7caa b96579                              lda sbits,y
    37  7cad 2d10d0                              and vic+16                               ; msb    ???vic_save
    38  7cb0 f002                                beq l260_2
    39  7cb2 a901                                lda #1                                   ; convert to 0 or 1
    40  7cb4 8588               l260_2           sta grapnt+1
    41  7cb6 c8                                  iny                                      ; Get Y position
    42  7cb7 b900d0                              lda vic,y                                ; lsb    ???vic_save
    43  7cba 8589                                sta grapnt+2
    44  7cbc a900                                lda #0                                   ; msb (fake it)
    45  7cbe 858a                                sta grapnt+3
    46                          
    47  7cc0 858b                                sta grapnt+4                             ; Init button status
    48  7cc2 858c                                sta grapnt+5
    49  7cc4 ab00dc                              ldz d1pra                                ; Set up port & read buttons
    50  7cc7 a9ff                                lda #$ff                                 ; save kybd output lines (IRQ already disabled)
    51  7cc9 8d00dc                              sta d1pra                                ; set to not read any kybd inputs
    52                          
    53  7ccc a000                                ldy #0                                   ; which port?
    54  7cce fa                                  plx                                      ; recall port assignments
    55  7ccf 8a                 l260_3           txa
    56  7cd0 0a                                  asl                                      ; .c=1 if this one
    57  7cd1 aa                                  tax
    58  7cd2 900f                                bcc l260_4                               ; not this one
    59  7cd4 b900dc                              lda d1pra,y                              ; read it (logical port is opposite physical port)
    60  7cd7 2911                                and #%00010001                           ; want left, right buttons only
    61  7cd9 4911                                eor #%00010001                           ; (invert, since low means button down)
    62  7cdb 048b                                tsb grapnt+4
    63  7cdd 2910                                and #%00010000                           ; shift left button to msb
    64  7cdf f002                                beq l260_4
    65  7ce1 f78b                                smb7 grapnt+4
    66  7ce3 c8                 l260_4           iny                                      ; next port
    67  7ce4 c002                                cpy #2
    68  7ce6 90e7                                bcc l260_3
    69                          
    70  7ce8 a97e                                lda #%01111110                           ; clean up
    71  7cea 148b                                trb grapnt+4                             ; fix button register
    72  7cec 9c00dc                              stz d1pra                                ; restore port for Kernel
    73  7cef 58                                  cli
    74                          
    75                          ; At this point, we have snapshot the current mouse status.
    76                          ; Now pass requested info along in a manner very similar to RREG...
    77                          
    78  7cf0 208522             l260_5           jsr chrgot                               ; Get a variable name from variable list
    79  7cf3 f032                                beq l260_8                               ; eol- exit
    80  7cf5 c92c                                cmp #','                                 ;
    81  7cf7 f01a                                beq l260_7                               ; null- skip this arg
    82  7cf9 207c4f                              jsr ptrget                               ; Get pointer to target variable
    83  7cfc 854b                                sta forpnt                               ; set up so we can share LET code
    84  7cfe 844c                                sty forpnt+1
    85  7d00 a50f                                lda valtyp                               ; what kind of variable name did ptrget find?
    86  7d02 d3e3cf                              +lbne chkerr                             ; string- type mismatch error
    87                          
    88  7d05 a60d               l260_6           ldx count                                ; Make assignment
    89  7d07 b487                                ldy grapnt,x                             ; low byte
    90  7d09 b588                                lda grapnt+1,x                           ; high byte
    91  7d0b 203f4e                              jsr givayf                               ; float it
    92  7d0e a510                                lda intflg                               ; set flags for type of var (int/float)
    93  7d10 209336                              jsr qintgr                               ; use part of LET to do the work
    94                          
    95  7d13 e60d               l260_7           inc count                                ; Next assignment
    96  7d15 e60d                                inc count
    97  7d17 a60d                                ldx count
    98  7d19 e006                                cpx #6                                   ; there are 3 possible
    99  7d1b b00a                                bcs l260_8                               ; done all 3, exit
   100  7d1d 208522                              jsr chrgot                               ; check terminator
   101  7d20 f005                                beq l260_8                               ; eol- exit
   102  7d22 205b4e                              jsr chkcom                               ; check delimiter
   103  7d25 80c9                                bra l260_5                               ; loop until done
   104                          
   105  7d27 60                 l260_8           rts
   106                          

; ******** Source: basic.asm

; ******** Source: command/cursor.asm
     1                          
     2                          
     3                          
     4                          ;*****************************************************************
     5                          ;*   CURSOR [ON|OFF,] [column] [,row [,style] ]
     6                          ;*
     7                          ;*   where: column,row = x,y logical screen position
     8                          ;*  style      = flashing (0) or solid (1)
     9                          ;*  ON,OFF     = to turn the cursor on or off
    10                          ;*****************************************************************
    11                          
    12  7d28 c991               cursor           cmp #on_token                            ; Check for ON | OFF
    13  7d2a 18                                  clc
    14  7d2b f046                                beq l261_3                               ; turn cursor on (.c=0)
    15  7d2d c9fe                                cmp #esc_command_token
    16  7d2f d00a                                bne l261_1                               ; (might be a function)
    17  7d31 2016b5                              jsr chkesc
    18  7d34 c924                                cmp #off_token                           ; turn cursor off (.c=1)
    19  7d36 f03b                                beq l261_3
    20  7d38 8310b1                              +lbra snerr
    21                          
    22  7d3b 48                 l261_1           pha                                      ; Evaluate cursor position parameters
    23  7d3c 38                                  sec
    24  7d3d 20f0ff                              jsr _plot                                ; get current cursor position & save it
    25  7d40 8688                                stx srow
    26  7d42 8487                                sty column
    27                          
    28  7d44 a687                                ldx column                               ; get new column, default=current column
    29  7d46 68                                  pla
    30  7d47 c92c                                cmp #','
    31  7d49 f003                                beq l261_2                               ; not given, use default
    32  7d4b 206c5d                              jsr getbyt
    33  7d4e 8687               l261_2           stx column
    34  7d50 a688                                ldx srow                                 ; get new row, default=current row
    35  7d52 202679                              jsr optbyt
    36                          ; stx srow
    37  7d55 a487                                ldy column
    38  7d57 18                                  clc
    39  7d58 20f0ff                              jsr _plot                                ; set new cursor position
    40  7d5b b3a1d4                              +lbcs fcerr                              ; error if bad position
    41                          
    42  7d5e 202479                              jsr optzer                               ; Get new cursor type   ???? assumes screen output
    43  7d61 901d                                bcc l261_4                               ; not given, exit
    44  7d63 a91b                                lda #esc
    45  7d65 20d2ff                              jsr _bsout                               ; use escape sequence to set
    46  7d68 8a                                  txa
    47  7d69 2901                                and #1
    48  7d6b 4901                                eor #1                                   ; [910808]
    49  7d6d 18                                  clc
    50  7d6e 6945                                adc #'E'                                 ; 0=F=flash, 1=E=solid
    51  7d70 4cd2ff                              jmp _bsout                               ; set it and exit
    52                          
    53  7d73 2030e0             l261_3           jsr _cursor                              ; Turn cursor ON or OFF per .c
    54                          
    55  7d76 208322                              jsr chrget                               ; eat token, get next character
    56  7d79 f005                                beq l261_4                               ; eol- exit
    57  7d7b 205b4e                              jsr chkcom                               ; else, must be comma
    58  7d7e 80bb                                bra l261_1                               ; it is- go evaluate position
    59                          
    60  7d80 60                 l261_4           rts                                      ; eol

; ******** Source: basic.asm

; ******** Source: function/rcursor.asm
     1                          
     2                          
     3                          ;************************************************************************
     4                          ;*   RCURSOR Returns in variable list current cursor position *
     5                          ;*         *
     6                          ;*   Syntax: RCURSOR [column [,row] ]    *
     7                          ;************************************************************************
     8                          
     9  7d81 38                 rcursor          sec                                      ; new [910228]
    10  7d82 20f0ff                              jsr _plot                                ; get current cursor position & save it
    11  7d85 8688                                stx srow
    12  7d87 8487                                sty column
    13                          
    14  7d89 a200                                ldx #0                                   ; just like RREG and RMOUSE...
    15  7d8b 860d                                stx count
    16  7d8d 208522             l262_1           jsr chrgot                               ; Get a variable name from variable list
    17  7d90 f030                                beq l262_4                               ; eol- exit
    18  7d92 c92c                                cmp #','                                 ;
    19  7d94 f01a                                beq l262_3                               ; null- skip this arg
    20  7d96 207c4f                              jsr ptrget                               ; Get pointer to target variable
    21  7d99 854b                                sta forpnt                               ; set up so we can share LET code
    22  7d9b 844c                                sty forpnt+1
    23  7d9d a50f                                lda valtyp                               ; what kind of variable name did ptrget find?
    24  7d9f d346cf                              +lbne chkerr                             ; string- type mismatch error
    25                          
    26  7da2 a60d               l262_2           ldx count                                ; Make assignment
    27  7da4 b487                                ldy column,x                             ; low byte
    28  7da6 a900                                lda #0                                   ; high byte
    29  7da8 203f4e                              jsr givayf                               ; float it
    30  7dab a510                                lda intflg                               ; set flags for type of var (int/float)
    31  7dad 209336                              jsr qintgr                               ; use part of LET to do the work
    32                          
    33  7db0 e60d               l262_3           inc count                                ; Next assignment
    34  7db2 a60d                                ldx count
    35  7db4 e002                                cpx #2                                   ; there are 2 possible
    36  7db6 b00a                                bcs l262_4                               ; done 2, exit
    37  7db8 208522                              jsr chrgot                               ; check terminator
    38  7dbb f005                                beq l262_4                               ; eol- exit
    39  7dbd 205b4e                              jsr chkcom                               ; check delimiter
    40  7dc0 80cb                                bra l262_1                               ; loop until done
    41                          
    42  7dc2 60                 l262_4           rts
    43                          
    44                          ;.end
    45                          
    46                          
    47                          
    48                          AutoScroll
    49  7dc3 48                                  pha                                      ; save character for Editor
    50  7dc4 ff7e1e                              bbs7 runmod,AutoScrollno                 ; branch if not direct mode
    51  7dc7 a415                                ldy channl                               ; is output redirected?
    52  7dc9 d01a                                bne AutoScrollno                         ; yes- can't do scroll (need to read screen)
    53  7dcb a52d                                lda txttab
    54  7dcd a62e                                ldx txttab+1                             ; is there a program in memory to scroll?
    55  7dcf 853d                                sta txtptr
    56  7dd1 863e                                stx txtptr+1
    57  7dd3 c8                                  iny                                      ; (1)
    58  7dd4 20c522                              jsr indtxt
    59  7dd7 d011                                bne AutoScrollyes                        ; yes- continue
    60  7dd9 800a                                bra AutoScrollno                         ; no-  exit
    61                          
    62                          AutoScrollpop
    63  7ddb 68                                  pla
    64  7ddc 68                                  pla
    65                          AutoScrollng
    66  7ddd a67f                                ldx point                                ; restore cursor position
    67  7ddf a480                                ldy point+1
    68  7de1 18                                  clc
    69  7de2 20f0ff                              jsr _plot
    70                          AutoScrollno
    71  7de5 1755                                rmb1 helper                              ; remove LINGET flag
    72  7de7 68                                  pla                                      ; restore character
    73  7de8 38                                  sec                                      ; return to Editor with no action taken
    74  7de9 60                                  rts
    75                          
    76                          AutoScrollyes
    77  7dea 663f                                ror form                                 ; save .c=direction (character already on stack)
    78  7dec 38                                  sec
    79  7ded 20f0ff                              jsr _plot                                ; get current cursor position & save it
    80  7df0 867f                                stx point
    81  7df2 8480                                sty point+1
    82  7df4 9755                                smb1 helper                              ; set flag for LINGET not to go to error if it has problems
    83  7df6 ff3f3d                              bbs7 form,AutoScrolldn                   ; branch according to direction of scroll...
    84                          
    85                          
    86                          AutoScrollup                                              ; wanting to scroll up
    87  7df9 38                                  sec
    88  7dfa a5e4                                lda _screen_bottom                       ; put cursor at bottom of screen
    89  7dfc e5e5                                sbc _screen_top
    90  7dfe 8540                                sta form+1                               ; save where it is- we'll be printing line there
    91  7e00 aa                                  tax
    92  7e01 20a87e                              jsr AutoSearch                           ; search for a line number on screen, put it in linnum
    93  7e04 20fa31                              jsr FindLine                             ; find the line in program
    94  7e07 900e                                bcc l263_1   ;  line not found           ; we have a pointer to the next line
    95  7e09 a000                                ldy #0
    96  7e0b 20ad22                              jsr indlow                               ; find the next line, the one we want to print, via link bytes
    97  7e0e aa                                  tax
    98  7e0f c8                                  iny
    99  7e10 20ad22                              jsr indlow
   100  7e13 8661                                stx lowtr                                ; advance pointer to it
   101  7e15 8562                                sta lowtr+1
   102  7e17 a640               l263_1           ldx form+1                               ; put cursor back at bottom of screen
   103  7e19 a000                                ldy #0
   104  7e1b 18                                  clc
   105  7e1c 20f0ff                              jsr _plot
   106  7e1f 20f737             l263_2           jsr crdo                                 ; get a blank line to print on- scroll screen up
   107  7e22 a001                                ldy #1
   108  7e24 20ad22                              jsr indlow                               ; end of program marker?
   109  7e27 d05f                                bne AutoScrollprint                      ; no-  print this line & exit
   110  7e29 a52d                                lda txttab                               ; yes- loop to start of program,
   111  7e2b a62e                                ldx txttab+1
   112  7e2d 8561                                sta lowtr
   113  7e2f 8662                                stx lowtr+1
   114  7e31 20f737                              jsr crdo                                 ; and add an extra newline
   115  7e34 80e9                                bra l263_2
   116                          
   117                          
   118                          AutoScrolldn                                              ; wanting to scroll down
   119  7e36 a200                                ldx #0                                   ; put cursor at top of screen
   120  7e38 20a87e                              jsr AutoSearch                           ; search for a line number on screen, put it in linnum
   121  7e3b a200                                ldx #0                                   ; get a blank line to print on
   122  7e3d a000                                ldy #0                                   ; put cursor at top of screen
   123  7e3f 18                                  clc
   124  7e40 20f0ff                              jsr _plot
   125  7e43 207dff             l264_1           jsr _primm                               ; and scroll screen (kill any pending Editor modes, too)
   126  7e46 1b1b1b5700                          !text esc,esc,esc,"W",0
   127  7e4b 20fa31                              jsr FindLine                             ; find the line in program whose number we found on screen
   128  7e4e a561                                lda lowtr                                ; (does not matter if it or next higher line is found)
   129  7e50 c52d                                cmp txttab
   130  7e52 d012                                bne l264_2
   131  7e54 a562                                lda lowtr+1
   132  7e56 c52e                                cmp txttab+1
   133  7e58 d00c                                bne l264_2
   134  7e5a a9ff                                lda #$ff                                 ; special case- it's the very first line, want to wrap to last line
   135  7e5c 8517                                sta linnum+1                             ; fake pointer to the last line,
   136  7e5e 207dff                              jsr _primm                               ; scroll screen to insert extra space,
   137  7e61 1b5700                              !text esc,"W",0
   138  7e64 80dd                                bra l264_1                               ; and go around again
   139                          
   140  7e66 a52d               l264_2           lda txttab                               ; start at beginning of program (txttab) and find the line which points at (lowtr)
   141  7e68 a62e                                ldx txttab+1
   142  7e6a 8524               l264_3           sta index                                ; pointer to link bytes
   143  7e6c 8625                                stx index+1
   144  7e6e a001                                ldy #1
   145  7e70 20c122                              jsr indin1                               ; get link bytes
   146  7e73 aa                                  tax
   147  7e74 88                                  dey
   148  7e75 20c122                              jsr indin1
   149  7e78 e462                                cpx lowtr+1                              ; do link bytes point at target line?
   150  7e7a d0ee                                bne l264_3
   151  7e7c c561                                cmp lowtr
   152  7e7e d0ea                                bne l264_3                               ; no- use these link bytes to find next line
   153                          
   154  7e80 a524                                lda index                                ; yes- copy pointer
   155  7e82 a625                                ldx index+1
   156  7e84 8561                                sta lowtr
   157  7e86 8662                                stx lowtr+1
   158                          ; bra AutoScrollprint ; print the line & exit
   159                          
   160                          
   161                          AutoScrollprint
   162  7e88 a002                                ldy #2                                   ; get line number to print
   163  7e8a 20ad22                              jsr indlow
   164  7e8d aa                                  tax
   165  7e8e c8                                  iny
   166  7e8f 20ad22                              jsr indlow
   167  7e92 207733                              jsr p1line                               ; print the number & the line
   168                          ; bra AutoScrolldone ;Normal exit
   169                          
   170                          AutoScrolldone
   171  7e95 207dff                              jsr _primm                               ; kill special Editor modes
   172  7e98 1b1b00                              !text esc,esc,0
   173  7e9b a67f                                ldx point                                ; restore cursor position
   174  7e9d a480                                ldy point+1
   175  7e9f 18                                  clc
   176  7ea0 20f0ff                              jsr _plot
   177  7ea3 1755                                rmb1 helper                              ; remove LINGET flag
   178  7ea5 68                                  pla                                      ; restore character
   179  7ea6 18                                  clc                                      ; return to Editor, with flag we handled character
   180  7ea7 60                                  rts
   181                          
   182                          AutoSearch
   183  7ea8 a000                                ldy #0                                   ; search for any line number on screen in leftmost column
   184  7eaa 18                                  clc
   185  7eab 20f0ff                              jsr _plot                                ; move to beginning of next line
   186                          ; bcs AutoScrollpop ;  exit if no more lines
   187  7eae b02a                                bcs l265_4                               ; no more lines- fake one   [910716]
   188  7eb0 38                                  sec
   189  7eb1 20f0ff                              jsr _plot                                ; else check if wrapped line
   190  7eb4 b018                                bcs l265_1                               ; it's wrapped- move up one line
   191  7eb6 a5e0                                lda _pnt
   192  7eb8 65e6                                adc _screen_left                         ; (.c=0)
   193  7eba 853d                                sta txtptr                               ; copy screen address of logical line to txtptr
   194  7ebc a5e1                                lda _pnt+1
   195  7ebe 6900                                adc #0
   196  7ec0 853e                                sta txtptr+1
   197  7ec2 a000                                ldy #0                                   ; get first character on this line in window
   198  7ec4 b13d                                lda (txtptr),y
   199                          ; jsr indtxt  ;    (I did not want to limit search to the first column,
   200  7ec6 c93a                                cmp #'9'+1                               ; but it was way too slow searching the entire screen)
   201  7ec8 b004                                bcs l265_1                               ; it's not a number
   202  7eca c930                                cmp #'0'
   203  7ecc b008                                bcs l265_3                               ; it's a digit 0-9, continue
   204                          
   205  7ece ff3f02             l265_1           bbs7 form,l265_2                         ; not on this line- move to next line
   206  7ed1 ca                                  dex                                      ; move up one line
   207  7ed2 89                                  !text $89
   208  7ed3 e8                 l265_2           inx                                      ; move down one line
   209  7ed4 80d2                                bra AutoSearch                           ; loop until we find a numeric digit or run out of lines
   210                          
   211  7ed6 18                 l265_3           clc                                      ; found a digit, get entire number into linnum & rts
   212  7ed7 8355b3                              +lbra linget
   213                          
   214  7eda a9ff               l265_4           lda #$ff                                 ; no line found, fake end of program   [910716]
   215  7edc 8517                                sta linnum+1
   216  7ede 60                                  rts
   217                          
   218                          
   219                          
   220                          

; ******** Source: basic.asm

; ******** Source: command/screen.asm
     1                          
     2                          
     3                          
     4                                           * = $af00                                ; [911001]
     5                          
     6                          ;*****************************************************************
     7                          ; SCREEN DEF      define a screen
     8                          ; SCREEN SET  set draw, view screen
     9                          ; SCREEN CLR  clear a screen
    10                          ; SCREEN OPEN  open a screen
    11                          ; SCREEN CLOSE  close a screen
    12                          ;*****************************************************************
    13                          
    14                          Screen
    15  af00 c99f                                cmp #open_token                          ; else dispatch per secondary token...
    16  af02 f39200                              +lbeq ScreenOpen
    17  af05 c9a0                                cmp #close_token
    18  af07 f39e00                              +lbeq ScreenClose
    19  af0a c996                                cmp #def_token
    20  af0c f058                                beq ScreenDef
    21  af0e c99c                                cmp #clr_token
    22  af10 f020                                beq ScreenClr
    23                          
    24  af12 2016b5                              jsr chkesc                               ; [910930]
    25                          ; cmp #esc_command_token
    26                          ; bne l266_1
    27                          ; jsr chrget  ; get past escape token
    28  af15 c92d                                cmp #set_token
    29  af17 f02f                                beq ScreenSet
    30  af19 832f7f             l266_1           +lbra snerr                              ; report syntax error
    31                          
    32                          
    33                          CheckGraphicMode
    34  af1c 2c4b1f                              bit $1f4b                                ; Check draw screen allocation   [910711]
    35  af1f 3001                                bmi NoGraphicArea
    36  af21 60                                  rts                                      ; ok
    37                          
    38                          
    39                          NoGraphicArea
    40  af22 a223                                ldx #errng                               ; bad- no graphic area????
    41  af24 83297f                              +lbra error
    42                          
    43                          
    44                          RestoreTextScreen                                          ; [910404]
    45  af27 a9ff                                lda #$ff                                 ; [910930]
    46  af29 8d001f                              sta GKI__parm1                           ; leave drawscreen as is
    47  af2c 8d011f                              sta GKI__parm2                           ; set viewscreen to text
    48  af2f 6c0e80                              jmp ($800e)                              ; kg65.screen
    49                          
    50                          ; lda vic+49  ;Check graphic screen allocation
    51                          ; and #%00010000
    52                          ; beq 99$   ; we're in text mode
    53                          ;; bit $1f43
    54                          ;; bmi NoGraphicArea
    55                          ;
    56                          ; sei
    57                          ; lda #$80
    58                          ; bit _mode  ;40/80 mode, 0=80 128=40
    59                          ; bmi l267_1
    60                          ;
    61                          ; tsb vic+49  ; 80
    62                          ; lda #1
    63                          ; trb vic+22  ;  fix x-scroll register
    64                          ; bra 99$
    65                          ;
    66                          ;l267_1 trb vic+49  ; 40
    67                          ; lda #1
    68                          ; tsb vic+22  ;  fix x-scroll register
    69                          ;
    70                          ;99$ cli
    71                          ;; lda #0
    72                          ;; sta _graphm  ;text mode????
    73                          ; rts
    74                          
    75                          
    76                          ;*****************************************************************
    77                          ; SCNCLR  clear a text or graphic screen
    78                          ;
    79                          ;  Syntax : SCNCLR  [ColorReg]
    80                          ;
    81                          ; if [ColorReg] not specified, clears text screen
    82                          ; else clears the graphic screen with given value.
    83                          ;*****************************************************************
    84                          
    85                          ScreenClr
    86  af32 208322                              jsr chrget                               ; eat token & fall into SCNCLR
    87                          
    88                          scnclr
    89  af35 d005                                bne C65__screenclear                     ; have a parameter, go clear graphic screen
    90                          
    91  af37 a993                                lda #$93
    92  af39 4cd2ff                              jmp _bsout                               ; no parameter, clear text screen
    93                          ; rts
    94                          
    95                          
    96                          
    97                          ;*****************************************************************
    98                          ;* SCREEN CLR  clear a graphic screen
    99                          ;*
   100                          ;*  Syntax : SCREEN CLR  color_reg#
   101                          ;*
   102                          ;*           parm1 = color reg#  0-255
   103                          ;*****************************************************************
   104                          
   105                          C65__screenclear
   106  af3c 206c5d                              jsr getbyt                               ; get color register # (range 0-255)?????
   107                          ;limit to range allowed by current screen def?
   108  af3f 8e001f                              stx GKI__parm1
   109  af42 201caf                              jsr CheckGraphicMode
   110  af45 6c0c80                              jmp ($800c)                              ; bra screenclear
   111                          
   112                          
   113                          ;*****************************************************************
   114                          ;* SCREEN SET  specify draw & view screens
   115                          ;*
   116                          ;*  Syntax : SCREEN SET  [DrawScreen] [,ViewScreen]
   117                          ;*
   118                          ;*           parm1 = draw screen # 0-3, 255=don't change    [910711]
   119                          ;*           parm2 = view screen # 0-3, 255=text
   120                          ;*****************************************************************
   121                          
   122                          ScreenSet
   123  af48 208322                              jsr chrget                               ; advance past token
   124                          
   125                          C65__screen
   126                          ; beq snerr  ;missing args??      [911017]
   127  af4b a2ff                                ldx #255                                 ; [911028]
   128  af4d c92c                                cmp #','
   129  af4f f003                                beq l267_1                               ; options byte only
   130                          
   131  af51 206c5d                              jsr getbyt                               ; get draw screen# in .x
   132                          ; cpx #4   ;       [910711]
   133                          ; bcs 20$   ;  out of range error???? (255=leave alone)  [910930]
   134  af54 8e001f             l267_1           stx GKI__parm1
   135                          
   136  af57 ae691f                              ldx $1f69                                ; current viewscreen     [911017]
   137  af5a 202679                              jsr optbyt                               ; eat a comma, get view screen# in .x
   138                          ; cpx #4   ;
   139                          ;20$ bcs fcerr  ;  out of range error???? (255=text)   [910930]
   140  af5d 8e011f                              stx GKI__parm2
   141                          
   142  af60 220e80                              jsr ($800e)                              ; kg65.screen
   143  af63 b0bd                                bcs NoGraphicArea
   144  af65 60                                  rts
   145                          
   146                          
   147                          ;*****************************************************************
   148                          ;* SCREEN DEF  define a graphic screen
   149                          ;*
   150                          ;*  Syntax : SCREEN DEF  screen#, width, height, depth
   151                          ;*
   152                          ;*           parm1 = screen#           0-3    [910711]
   153                          ;*           parm2 = width             0=320, 1=640, 2=1280
   154                          ;*           parm3 = height            0=200, 1=400
   155                          ;*           parm4 = depth             1-8 bitplanes (2-256 colors)
   156                          ;*****************************************************************
   157                          
   158                          ScreenDef
   159  af66 208322                              jsr chrget                               ; advance past token
   160                          
   161                          C65__screendef
   162  af69 206c5d                              jsr getbyt                               ; get screen number
   163  af6c e004                                cpx #4                                   ; range 0-3   [910711]
   164  af6e b01d                                bcs l268_1
   165  af70 8e001f                              stx GKI__parm1                           ; screen#
   166                          
   167  af73 20825d                              jsr combyt                               ; get width
   168  af76 e003                                cpx #3                                   ; range 0-2 ???? 1280 mode ????
   169  af78 b013                                bcs l268_1
   170  af7a 8e011f                              stx GKI__parm2                           ; width
   171                          
   172  af7d 20825d                              jsr combyt                               ; get height
   173  af80 e002                                cpx #2                                   ; range 0-1
   174  af82 b009                                bcs l268_1
   175  af84 8e021f                              stx GKI__parm3                           ; height
   176                          
   177  af87 20825d                              jsr combyt                               ; get depth (# bitplanes)
   178  af8a ca                                  dex                                      ; convert 1-8 to 0-7
   179  af8b e008                                cpx #8                                   ; range 0-7
   180  af8d b36fa2             l268_1           +lbcs fcerr                              ; illegal quantity error
   181  af90 8e031f                              stx GKI__parm4                           ; depth
   182                          
   183  af93 6c0680                              jmp ($8006)                              ; bra screendef
   184                          
   185                          
   186                          ;*****************************************************************
   187                          ;* SCREEN OPEN  open a graphic screen for viewing or drawing
   188                          ;*
   189                          ;*  Syntax : SCREEN OPEN screen#
   190                          ;*
   191                          ;*           parm1 = screen#      0-3    [910711]
   192                          ;*****************************************************************
   193                          
   194                          
   195                          ScreenOpen
   196  af96 208322                              jsr chrget                               ; advance past Open token
   197                          
   198                          C65__screenopen
   199  af99 206c5d                              jsr getbyt                               ; get screen# in .x
   200  af9c e004                                cpx #4                                   ; range 0-3   [910711]
   201  af9e b35ea2                              +lbcs fcerr                              ; branch if out of range
   202                          
   203  afa1 8e001f                              stx GKI__parm1
   204  afa4 6c0880                              jmp ($8008)                              ; screenopen    [910826]
   205                          
   206                          ; bcs NoGraphicArea ; bad ???? let user catch via RGRAPHIC
   207                          ; rts
   208                          
   209                          
   210                          ;*****************************************************************
   211                          ;* SCREEN CLOSE  close a graphic screen
   212                          ;*
   213                          ;*  Syntax : SCREEN CLOSE screen#
   214                          ;*
   215                          ;*           parm1 = screen#  0-3    [910711]
   216                          ;*****************************************************************
   217                          
   218                          
   219                          ScreenClose
   220  afa7 208322                              jsr chrget                               ; advance past Close token
   221                          
   222                          C65__screenclose
   223  afaa 206c5d                              jsr getbyt                               ; get screen#
   224  afad e004                                cpx #4                                   ; range 0-3   [910711]
   225  afaf b34da2                              +lbcs fcerr                              ; branch if out of range
   226  afb2 8e001f                              stx GKI__parm1
   227                          
   228  afb5 6c0a80                              jmp ($800a)                              ; bra screenclose

; ******** Source: basic.asm

; ******** Source: command/pen.asm
     1                          
     2                          ;*****************************************************************
     3                          ;* PEN
     4                          ;*
     5                          ;*  Syntax : PEN  Pen#, ColorReg
     6                          ;*
     7                          ;*           parm1 = pen#  0-2
     8                          ;*           parm2 = color reg#  0-255
     9                          ;*****************************************************************
    10                          
    11                          C65__setpen
    12  afb8 206c5d                              jsr getbyt                               ; get pen#
    13  afbb e003                                cpx #3                                   ; range 0-2
    14  afbd b33fa2                              +lbcs fcerr                              ; branch if out of range
    15  afc0 8e001f                              stx GKI__parm1
    16                          
    17  afc3 20825d                              jsr combyt                               ; get color reg#
    18                          ;???? error check for max color allowed
    19                          ; for the current screen.
    20  afc6 8e011f                              stx GKI__parm2
    21                          
    22  afc9 6c1080                              jmp ($8010)                              ; bra setpen

; ******** Source: basic.asm

; ******** Source: command/dmode.asm
     1                          
     2                          
     3                          ;*****************************************************************
     4                          ;* DMODE   Set Draw Mode
     5                          ;*
     6                          ;*  Syntax : DMODE  jam, complement, stencil, style, thickness
     7                          ;*
     8                          ;*         parm1 = jam           0-1
     9                          ;*         parm2 = complement (XOR) 0-1
    10                          ;*         parm3 = stencil       0-1  <<< not implemented  [911003]
    11                          ;*         parm4 = style         0-3  <<< only 0-1 implemented [911003]
    12                          ;*         parm5 = thickness     1-8  <<< not implemented  [911003]
    13                          ;*******************************************************************
    14                          
    15                          C65__setdmode
    16  afcc 206c5d                              jsr getbyt                               ; jam mode
    17  afcf e002                                cpx #2
    18  afd1 b026                                bcs l269_1
    19  afd3 8e001f                              stx GKI__parm1
    20                          
    21  afd6 20825d                              jsr combyt                               ; complement (xor) mode
    22  afd9 e002                                cpx #2                                   ; (ignores jam mode if set)
    23  afdb b01c                                bcs l269_1
    24  afdd 8e011f                              stx GKI__parm2
    25                          
    26  afe0 20825d                              jsr combyt                               ; stencil mode (not implemented)
    27  afe3 e002                                cpx #2
    28  afe5 b012                                bcs l269_1
    29  afe7 8e021f                              stx GKI__parm3
    30                          
    31  afea 20825d                              jsr combyt                               ; style mode
    32  afed e004                                cpx #4                                   ; 0=solid, 1=pattern, 2=tile (not implemented), 3=reserved
    33  afef b008                                bcs l269_1
    34  aff1 8e031f                              stx GKI__parm4
    35                          
    36  aff4 20825d                              jsr combyt                               ; thickness mode (not implemented)
    37                          ; dex   ; adjust to 0-7     [911003]
    38  aff7 e009                                cpx #8+1
    39  aff9 b303a2             l269_1           +lbcs fcerr                              ; illegal quantity error
    40  affc 8e041f                              stx GKI__parm5
    41                          
    42  afff 6c1480                              jmp ($8014)                              ; bra setdmode

; ******** Source: basic.asm

; ******** Source: command/dpat.asm
     1                          
     2                          
     3                          ;*****************************************************************
     4                          ;* DPAT   set draw pattern
     5                          ;*
     6                          ;*  Syntax : DPAT  type [, # bytes, byte1, byte2, byte3, byte4]
     7                          ;*
     8                          ;*           parm1 = type        0-63  <<< only 0-4 implemented [911003]
     9                          ;*           parm2 = # bytes     1-4
    10                          ;*           parm3 = byte1       0-255
    11                          ;*           parm4 = byte2       0-255
    12                          ;*           parm5 = byte3       0-255
    13                          ;*           parm6 = byte4       0-255
    14                          ;*****************************************************************
    15                          
    16                          C65__setdpat
    17  b002 206c5d                              jsr getbyt                               ; get pattern type
    18  b005 e005                                cpx #4+1                                 ; 63+1       [911028]
    19  b007 b3f5a1             l270_1           +lbcs fcerr                              ; if out of range
    20  b00a 8e001f                              stx GKI__parm1
    21  b00d 8a                                  txa
    22  b00e d033                                bne l270_2                               ; if parm1 is 0 then get extra stuff
    23                          
    24  b010 20825d                              jsr combyt                               ; get number of bytes
    25  b013 e005                                cpx #5
    26  b015 b0f0                                bcs l270_1                               ; too many bytes
    27  b017 8e011f                              stx GKI__parm2
    28  b01a 8676                                stx z_p_temp_1                           ; save for count
    29                          
    30  b01c 20825d                              jsr combyt                               ; get byte 1
    31  b01f 8e021f                              stx GKI__parm3
    32  b022 c676                                dec z_p_temp_1
    33  b024 f01d                                beq l270_2
    34  b026 33d6a1                              +lbmi fcerr                              ; too few bytes
    35                          
    36  b029 20825d                              jsr combyt                               ; get byte 2
    37  b02c 8e031f                              stx GKI__parm4
    38  b02f c676                                dec z_p_temp_1
    39  b031 f010                                beq l270_2
    40                          
    41  b033 20825d                              jsr combyt                               ; get byte 3
    42  b036 8e041f                              stx GKI__parm5
    43  b039 c676                                dec z_p_temp_1
    44  b03b f006                                beq l270_2
    45                          
    46  b03d 20825d                              jsr combyt                               ; get byte 4
    47  b040 8e051f                              stx GKI__parm6
    48                          
    49  b043 6c1680             l270_2           jmp ($8016)                              ; bra setdpat

; ******** Source: basic.asm

; ******** Source: command/palette.asm
     1                          
     2                          
     3                          ;*****************************************************************
     4                          ;* PALETTE   set palette colors
     5                          ;*
     6                          ;*  Syntax : PALETTE {screen|COLOR}, color_index, red, green, blue
     7                          ;*           PALETTE RESTORE
     8                          ;*
     9                          ;*           parm1 = screen  0-3     [910711]
    10                          ;*           parm2 = color_index 0-255
    11                          ;*           parm3 = red           0-31 (b0-3 red, b4=fgbg)  [910520]
    12                          ;*           parm4 = green         0-15
    13                          ;*           parm5 = blue          0-15
    14                          ;*****************************************************************
    15                          
    16                          C65__setpalette
    17  b046 c98c                                cmp #restore_token                       ; restore palette?
    18  b048 d006                                bne l271_1                               ; no
    19  b04a 208322                              jsr chrget                               ; yes- advance past Restore token
    20  b04d 4c27e0                              jmp _palette_init
    21                          
    22  b050 c9e7               l271_1           cmp #color_token                         ; set physical color register?
    23  b052 d00b                                bne l271_2                               ; no- set logical color register
    24  b054 8d001f                              sta GKI__parm1
    25  b057 208322                              jsr chrget                               ; yes- advance past Color token
    26  b05a 206c5d                              jsr getbyt
    27  b05d 800e                                bra l271_3
    28                          
    29  b05f 206c5d             l271_2           jsr getbyt                               ; get screen#
    30  b062 e004                                cpx #4                                   ; [910711]
    31  b064 b398a1                              +lbcs fcerr
    32  b067 8e001f                              stx GKI__parm1
    33                          
    34  b06a 20825d                              jsr combyt                               ; get color reg #
    35  b06d 8e011f             l271_3           stx GKI__parm2                           ; (GKI will check for out of range????)
    36                          
    37                          set_palette
    38  b070 20825d                              jsr combyt                               ; get red & fgbg
    39  b073 e020                                cpx #32                                  ; [910520]
    40  b075 b387a1                              +lbcs fcerr
    41  b078 8e021f                              stx GKI__parm3
    42                          
    43  b07b 200ab5                              jsr getcomnyb                            ; get green
    44                          ; cpx #16
    45                          ; bcs 10$
    46  b07e 8e031f                              stx GKI__parm4
    47                          
    48  b081 200ab5                              jsr getcomnyb                            ; get blue
    49                          ; cpx #16
    50                          ; bcs fcerr  ; illegal quantity error
    51  b084 8e041f                              stx GKI__parm5
    52                          
    53  b087 ad001f                              lda GKI__parm1                           ; logical or physical color register?
    54  b08a 1017                                bpl l272_1                               ; logical
    55  b08c ae011f                              ldx GKI__parm2
    56  b08f ad021f                              lda GKI__parm3                           ; physical
    57  b092 9d00d1                              sta _red,x
    58  b095 ad031f                              lda GKI__parm4
    59  b098 9d00d2                              sta _green,x
    60  b09b ad041f                              lda GKI__parm5
    61  b09e 9d00d3                              sta _blue,x
    62  b0a1 8006                                bra l272_2
    63                          
    64  b0a3 221280             l272_1           jsr ($8012)                              ; go set screen palette
    65  b0a6 b37afe                              +lbcs NoGraphicArea                      ; illegal screen# or color#  [910917]
    66                          
    67  b0a9 202679             l272_2           jsr optbyt                               ; get another color reg # ?
    68  b0ac 8e011f                              stx GKI__parm2
    69  b0af b0bf                                bcs set_palette                          ; yes- loop
    70  b0b1 60                                  rts

; ******** Source: basic.asm

; ******** Source: command/line.asm
     1                          
     2                          ;*****************************************************************
     3                          ;* LINE  draw a dot, a line or a stick shape
     4                          ;*
     5                          ;*  Syntax : LINE  x0, y0 [,[x1] [,y1]]...
     6                          ;*
     7                          ;* parm1,2 = x0 (lo/hi)
     8                          ;* parm3,4 = y0
     9                          ;* parm5,6 = x1 (x1,y1)=(x0,y0) if not specified
    10                          ;* parm7,8 = y1
    11                          ;*****************************************************************
    12                          
    13                          C65__line
    14  b0b2 c984                                cmp #input_token                         ; special check for 'line input#'  [910103]
    15  b0b4 f3e687                              +lbeq linputn                            ; yes
    16  b0b7 c985                                cmp #input_token+1                       ; special check for 'line input'
    17  b0b9 f3ff87                              +lbeq linput                             ; yes
    18                          
    19  b0bc 201caf                              jsr CheckGraphicMode
    20  b0bf 20e5b7                              jsr sadwrd                               ; get x0
    21  b0c2 8c001f                              sty GKI__parm1
    22  b0c5 8d011f                              sta GKI__parm2
    23  b0c8 8c041f                              sty GKI__parm5                           ; [910228]
    24  b0cb 8d051f                              sta GKI__parm6
    25                          
    26  b0ce 200879                              jsr comsad                               ; get y0
    27  b0d1 8c021f                              sty GKI__parm3
    28  b0d4 8d031f                              sta GKI__parm4
    29  b0d7 8c061f                              sty GKI__parm7                           ; [910228]
    30  b0da 8d071f                              sta GKI__parm8
    31                          
    32  b0dd 200e79                              jsr optsad                               ; get x1     [910228]
    33  b0e0 9006                                bcc l273_2                               ; use x0
    34  b0e2 8c041f             l273_1           sty GKI__parm5
    35  b0e5 8d051f                              sta GKI__parm6
    36                          
    37  b0e8 200e79             l273_2           jsr optsad                               ; get y1     [910228]
    38  b0eb 9006                                bcc l273_3                               ; use y0
    39  b0ed 8c061f                              sty GKI__parm7
    40  b0f0 8d071f                              sta GKI__parm8
    41                          
    42  b0f3 221880             l273_3           jsr ($8018)                              ; draw a line from x0,y0 to x1,y1
    43                          
    44  b0f6 a203                                ldx #3
    45  b0f8 bd041f             l273_4           lda GKI__parm5,x                         ; copy x1,y1 to x0,y0
    46  b0fb 9d001f                              sta GKI__parm1,x
    47  b0fe ca                                  dex
    48  b0ff 10f7                                bpl l273_4
    49                          
    50  b101 200e79                              jsr optsad                               ; more?
    51  b104 b0dc                                bcs l273_1                               ; yes, continue
    52  b106 60                                  rts

; ******** Source: basic.asm

; ******** Source: command/box.asm
     1                          
     2                          ;*****************************************************************
     3                          ;* BOX   draw a 4-sided figure
     4                          ;*
     5                          ;*  Syntax :  BOX x0,y0, x1,y1, x2,y2, x3,y3 [,solid flag]
     6                          ;*
     7                          ;* parm1,2   = x0  (lo/hi)
     8                          ;* parm3,4   = y0
     9                          ;* parm5,6   = x1
    10                          ;* parm7,8   = y1
    11                          ;* parm9,10  = x2
    12                          ;* parm11,12 = y2
    13                          ;* parm13,14 = x3
    14                          ;* parm15,16 = y3
    15                          ;* parm17    = solid flag
    16                          ;*****************************************************************
    17                          
    18                          C65__box
    19  b107 201caf                              jsr CheckGraphicMode
    20  b10a 20e5b7                              jsr sadwrd                               ; get x0
    21  b10d 8c001f                              sty GKI__parm1
    22  b110 8d011f                              sta GKI__parm2
    23                          
    24  b113 200879                              jsr comsad                               ; get y0
    25  b116 8c021f                              sty GKI__parm3
    26  b119 8d031f                              sta GKI__parm4
    27                          
    28  b11c 200879                              jsr comsad                               ; get x1
    29  b11f 8c041f                              sty GKI__parm5
    30  b122 8d051f                              sta GKI__parm6
    31                          
    32  b125 200879                              jsr comsad                               ; get y1
    33  b128 8c061f                              sty GKI__parm7
    34  b12b 8d071f                              sta GKI__parm8
    35                          
    36  b12e 200879                              jsr comsad                               ; get x2
    37  b131 8c081f                              sty GKI__parm9
    38  b134 8d091f                              sta GKI__parm10
    39                          
    40  b137 200879                              jsr comsad                               ; get y2
    41  b13a 8c0a1f                              sty GKI__parm11
    42  b13d 8d0b1f                              sta GKI__parm12
    43                          
    44  b140 200879                              jsr comsad                               ; get x3
    45  b143 8c0c1f                              sty GKI__parm13
    46  b146 8d0d1f                              sta GKI__parm14
    47                          
    48  b149 200879                              jsr comsad                               ; get y3
    49  b14c 8c0e1f                              sty GKI__parm15
    50  b14f 8d0f1f                              sta GKI__parm16
    51                          
    52  b152 202479                              jsr optzer                               ; get solid flag
    53  b155 8e101f                              stx GKI__parm17
    54                          
    55  b158 6c1a80                              jmp ($801a)                              ; bra box

; ******** Source: basic.asm

; ******** Source: command/circle.asm
     1                          
     2                          ;*****************************************************************
     3                          ;* CIRCLE   draw a Circle
     4                          ;*
     5                          ;*  Syntax : CIRCLE  CenterX, CenterY, radius [,solid flag]
     6                          ;*
     7                          ;*         parm1 = center x lo
     8                          ;*         parm2 = center x hi
     9                          ;*         parm3 = center y lo
    10                          ;*         parm4 = center y hi
    11                          ;*         parm5 = radius lo
    12                          ;*         parm6 = radius hi
    13                          ;*         parm7 = solid flag 0=no, 1=yes
    14                          ;*****************************************************************
    15                          
    16                          C65__circle
    17  b15b 201caf                              jsr CheckGraphicMode
    18  b15e 20e5b7                              jsr sadwrd                               ; get center x
    19  b161 8c001f                              sty GKI__parm1
    20  b164 8d011f                              sta GKI__parm2
    21                          
    22  b167 200879                              jsr comsad                               ; get center y
    23  b16a 8c021f                              sty GKI__parm3
    24  b16d 8d031f                              sta GKI__parm4
    25                          
    26  b170 200879                              jsr comsad                               ; get radius
    27  b173 8c041f                              sty GKI__parm5
    28  b176 8d051f                              sta GKI__parm6
    29                          
    30  b179 202479                              jsr optzer                               ; get solid flag
    31  b17c e002                                cpx #2
    32  b17e b37ea0                              +lbcs fcerr
    33  b181 8e061f                              stx GKI__parm7
    34                          
    35  b184 6c1c80                              jmp ($801c)                              ; bra circle
    36                          

; ******** Source: basic.asm

; ******** Source: command/ellipse.asm
     1                          
     2                          
     3                          ;*****************************************************************
     4                          ;* ELLIPSE   draw an Ellipse
     5                          ;*
     6                          ;*  Syntax : ELLIPSE  CenterX, CenterY, RadiusX,  RadiusY  [,solid flag]
     7                          ;*
     8                          ;*         parm1 = center x lo
     9                          ;*         parm2 = center x hi
    10                          ;*         parm3 = center y lo
    11                          ;*         parm4 = center y hi
    12                          ;*         parm5 = x radius lo
    13                          ;*         parm6 = x radius hi
    14                          ;*         parm7 = y radius lo
    15                          ;*         parm8 = y radius hi
    16                          ;*         parm9 = solid flag 0-1
    17                          ;*****************************************************************
    18                          
    19                          C65__ellipse
    20  b187 201caf                              jsr CheckGraphicMode
    21  b18a 20e5b7                              jsr sadwrd                               ; get center x
    22  b18d 8c001f                              sty GKI__parm1
    23  b190 8d011f                              sta GKI__parm2
    24                          
    25  b193 200879                              jsr comsad                               ; get center y
    26  b196 8c021f                              sty GKI__parm3
    27  b199 8d031f                              sta GKI__parm4
    28                          
    29  b19c 200879                              jsr comsad                               ; get xradius
    30  b19f 8c041f                              sty GKI__parm5
    31  b1a2 8d051f                              sta GKI__parm6
    32                          
    33  b1a5 200879                              jsr comsad                               ; get yradius
    34  b1a8 8c061f                              sty GKI__parm7
    35  b1ab 8d071f                              sta GKI__parm8
    36                          
    37  b1ae 202479                              jsr optzer                               ; get solid flag
    38  b1b1 e002                                cpx #2
    39  b1b3 b349a0                              +lbcs fcerr
    40  b1b6 8e081f                              stx GKI__parm9
    41                          
    42  b1b9 6c2080                              jmp ($8020)                              ; bra ellipse

; ******** Source: basic.asm

; ******** Source: command/polygon.asm
     1                          
     2                          
     3                          
     4                          ;*****************************************************************
     5                          ;* POLYGON   draw a regular n-sided Polygon
     6                          ;*
     7                          ;*  POLYGON  X,Y, Xradius, Yradius, sides [,drawsides [,subtend [,angle [,solid] ]]]
     8                          ;*
     9                          ;*         parm1 = center x lo
    10                          ;*         parm2 = center x hi
    11                          ;*         parm3 = center y lo
    12                          ;*         parm4 = center y hi
    13                          ;*         parm5 = xradius lo
    14                          ;*         parm6 = xradius hi
    15                          ;*         parm7 = yradius lo
    16                          ;*         parm8 = yradius hi
    17                          ;*         parm9 = solid flag 0-1
    18                          ;*         parm10 = sa lo (starting angle 0-360)
    19                          ;*         parm11 = sa hi
    20                          ;*         parm12 = # of sides to draw (1 to 127)
    21                          ;*         parm13 = # of sides (3 to parm12)
    22                          ;*         parm14 = subtend flag 0-1
    23                          ;****************************************************************
    24                          
    25                          C65__polygon                                              ; changed BASIC syntax to something more reasonable [910923] FAB
    26  b1bc 201caf                              jsr CheckGraphicMode
    27  b1bf 20e5b7                              jsr sadwrd                               ; get center x
    28  b1c2 8c001f                              sty GKI__parm1
    29  b1c5 8d011f                              sta GKI__parm2
    30                          
    31  b1c8 200879                              jsr comsad                               ; get center y
    32  b1cb 8c021f                              sty GKI__parm3
    33  b1ce 8d031f                              sta GKI__parm4
    34                          
    35  b1d1 20875d                              jsr comwrd                               ; get x radius
    36  b1d4 8c041f                              sty GKI__parm5
    37  b1d7 8d051f                              sta GKI__parm6
    38                          
    39  b1da 20875d                              jsr comwrd                               ; get y radius
    40  b1dd 8c061f                              sty GKI__parm7
    41  b1e0 8d071f                              sta GKI__parm8
    42                          
    43  b1e3 20825d                              jsr combyt                               ; get number of sides
    44  b1e6 e003                                cpx #3
    45  b1e8 900d                                bcc l274_2                               ; too few
    46  b1ea e080                                cpx #128
    47  b1ec b310a0             l274_1           +lbcs fcerr                              ; too many
    48  b1ef 8e0c1f                              stx GKI__parm13
    49                          
    50                          ; ldx GKI__parm13  ;get number of sides to draw (default=#sides)
    51  b1f2 202679                              jsr optbyt
    52  b1f5 e001                                cpx #1                                   ; must be at least 1 side
    53  b1f7 9305a0             l274_2           +lbcc fcerr
    54  b1fa 8e0b1f                              stx GKI__parm12
    55  b1fd ca                                  dex
    56  b1fe ec0c1f                              cpx GKI__parm13                          ; draw sides must be <= #sides
    57  b201 b0e9                                bcs l274_1
    58                          
    59  b203 202479                              jsr optzer                               ; get subtend flag
    60                          ; cpx #2
    61                          ; bcs l274_1
    62  b206 8e0d1f                              stx GKI__parm14
    63                          
    64  b209 20f278                              jsr optwrd                               ; get starting angle (default=0 degrees)
    65  b20c 8c091f                              sty GKI__parm10                          ; lo
    66  b20f 8d0a1f                              sta GKI__parm11                          ; hi
    67                          
    68  b212 202479                              jsr optzer                               ; get solid flag
    69                          ; cpx #2
    70                          ; bcs l274_1
    71  b215 8e081f                              stx GKI__parm9
    72                          
    73  b218 6c1e80                              jmp ($801e)                              ; bra polygon

; ******** Source: basic.asm

; ******** Source: command/set.asm
     1                          
     2                          
     3                          
     4                          ;  SET  A multipurpose command initiator
     5                          
     6                          
     7                          C65__set
     8  b21b c995                                cmp #verify_token                        ; SET VERIFY <ON | OFF>  new [910429]
     9  b21d f39c00                              +lbeq verify_mode
    10  b220 c996                                cmp #def_token                           ; SET DEF unit
    11  b222 d00c                                bne l275_1
    12  b224 2085b2                              jsr getdisknum_1
    13  b227 8e0611                              stx _default_drive
    14  b22a 8e8211                              stx dosfa                                ; Make last DOS device = current device
    15  b22d 8353c6                              +lbra Clear_DS
    16                          
    17                          
    18                          
    19  b230 2016b5             l275_1           jsr chkesc                               ; Must be ESCape token
    20  b233 c940                                cmp #disk_token                          ; ok so far
    21  b235 d3047c                              +lbne bad_command                        ; unknown command
    22                          
    23                          
    24                          
    25                          
    26  b238 2085b2                              jsr getdisknum_1                         ; SET DISK # [<,|TO> #]
    27  b23b 8e8211                              stx dosfa                                ; got current disk unit #
    28                          
    29  b23e 208522                              jsr chrgot                               ; check delimiter (comma, 'TO', or eos)
    30  b241 f33fc6                              +lbeq Clear_DS                           ; eos- just change DOS' current drive [910417]
    31  b244 c92c                                cmp #','                                 ; not eos, must be comma or 'TO'
    32  b246 f005                                beq l275_2
    33  b248 c9a4                                cmp #to_token
    34  b24a d3fe7b                              +lbne snerr
    35                          
    36  b24d 2085b2             l275_2           jsr getdisknum_1                         ; skip delimiter
    37  b250 8e8811                              stx dosds2                               ; got new disk unit #
    38                          
    39                          
    40                          
    41                          ;  Open disk command channel & pass it 'renumber' command
    42                          
    43  b253 204171                              jsr dclall                               ; Close any open files????
    44                          
    45  b256 a205                                ldx #6-1
    46  b258 bd7fb2             l275_3           lda disk_renum_cmd,x                     ; move command to RAM, setup for open
    47  b25b 9d9111                              sta savram,x
    48  b25e ca                                  dex
    49  b25f 10f7                                bpl l275_3
    50  b261 ad8811                              lda dosds2
    51  b264 0920                                ora #32                                  ; make new # a talk/listen address
    52  b266 8d9711                              sta savram+6
    53  b269 ad8811                              lda dosds2
    54  b26c 0940                                ora #64
    55  b26e 8d9811                              sta savram+7
    56                          
    57  b271 a908                                lda #8                                   ; command string length
    58  b273 2096b2                              jsr SendDiskCmd                          ; Send command
    59  b276 ad8811                              lda dosds2
    60  b279 8d8211                              sta dosfa                                ; Make last DOS device = current device
    61  b27c 8394b6                              +lbra close_out_1                        ; common error check & exit path ????
    62                          
    63                          
    64  b27f 4d2d57770002       disk_renum_cmd   !text "M-W",119,0,2                      ; Renumber Drive command
    65                          
    66                          
    67                          
    68                          ;  GetDiskNum - Get a (required) disk number and check it
    69                          
    70                          getdisknum_1
    71  b285 208322                              jsr chrget                               ; skip current character
    72                          getdisknum
    73  b288 206c5d                              jsr getbyt                               ; get number in .x
    74  b28b e008                                cpx #8                                   ; check range (8-30)
    75  b28d 936f9f                              +lbcc fcerr
    76  b290 e01f                                cpx #31
    77  b292 b36a9f                              +lbcs fcerr
    78  b295 60                                  rts                                      ; returns only if okay
    79                          
    80                          
    81                          
    82                          ;  SendDiskCmd - Send command in SAVRAM to disk, length in .A
    83                          
    84                          SendDiskCmd
    85                          ; lda #   ; command string length
    86  b296 a291                                ldx #<savram                             ; address
    87  b298 a011                                ldy #>savram
    88  b29a 20bdff                              jsr _setnam
    89  b29d a200                                ldx #sys_bank                            ; ???? sysbank ????
    90  b29f 206bff                              jsr _setbank
    91  b2a2 20ccff                              jsr _clrch                               ; Restore normal channels, establish our's
    92  b2a5 ae8211                              ldx dosfa                                ; fa
    93  b2a8 a900                                lda #doslfn                              ; la (reserved la)
    94  b2aa a06f                                ldy #$6f                                 ; sa (command channel)
    95  b2ac 20baff                              jsr _setlfs
    96  b2af 20c0ff                              jsr _open                                ; open channel & send command
    97  b2b2 a900                                lda #doslfn                              ; close it already
    98  b2b4 38                                  sec                                      ; not a real close
    99  b2b5 20c3ff                              jsr _close
   100  b2b8 83c8c5                              +lbra Clear_DS                           ; Exit
   101                          
   102                          
   103                          ;  SET VERIFY <ON | OFF> Set DOS verify-after-write mode for 3.5" drives
   104                          
   105                          verify_mode
   106  b2bb 208322                              jsr chrget                               ; eat 'verify' token, get next  new [910429]
   107  b2be c991                                cmp #on_token
   108  b2c0 38                                  sec
   109  b2c1 f009                                beq l276_1                               ; turn verify on (.c=1)
   110  b2c3 2016b5                              jsr chkesc
   111  b2c6 c924                                cmp #off_token                           ; turn cursor off (.c=0)
   112  b2c8 d3807b                              +lbne snerr
   113  b2cb 18                                  clc
   114                          
   115                          ;  Open disk command channel & pass it 'verify' command
   116                          
   117  b2cc 08                 l276_1           php                                      ; Save mode
   118  b2cd 2022b5                              jsr chkeos                               ; eat 'on/off' token, error if not eos
   119                          
   120  b2d0 a203                                ldx #4-1
   121  b2d2 bdecb2             l276_2           lda verify_cmd,x                         ; move command to RAM, setup for open
   122  b2d5 9d9111                              sta savram,x
   123  b2d8 ca                                  dex
   124  b2d9 10f7                                bpl l276_2
   125                          
   126  b2db a900                                lda #0                                   ; form on/off flag
   127  b2dd 28                                  plp
   128  b2de 2a                                  rol
   129  b2df 0930                                ora #$30
   130  b2e1 8d9511                              sta savram+4
   131                          
   132  b2e4 a905                                lda #5                                   ; command string length
   133  b2e6 2096b2                              jsr SendDiskCmd                          ; Send command
   134  b2e9 8327b6                              +lbra close_out_1                        ; common error check & exit path ????
   135                          
   136                          
   137  b2ec 55303e56           verify_cmd       !text "U0>V"                             ; Verify on/off command
   138                          

; ******** Source: basic.asm

; ******** Source: command/char.asm
     1                          
     2                          
     3                          
     4                          ;*****************************************************************
     5                          ;* CHAR   draw a character string
     6                          ;*
     7                          ;*  Syntax : CHAR column, row, height, width, direction, "string" [,charsetadr [,bank]]
     8                          ;*
     9                          ;* parm1  = column#
    10                          ;* parm2  = row lo
    11                          ;* parm3  = row hi
    12                          ;* parm4  = height
    13                          ;* parm5  = width
    14                          ;* parm6  = direction
    15                          ;* parm7  = len of string
    16                          ;* parm8  = lo addr of string
    17                          ;* parm9  = hi addr of string
    18                          ;* parm10 = lo addr of character set $29800 default
    19                          ;* parm11 = hi addr of character set
    20                          ;* parm12 = bank of character set   [910912]
    21                          ;****************************************************************
    22                          
    23                          C65__char
    24  b2f0 201caf                              jsr CheckGraphicMode
    25  b2f3 206c5d                              jsr getbyt                               ; get column
    26  b2f6 8e001f                              stx GKI__parm1
    27                          
    28  b2f9 200879                              jsr comsad                               ; get row
    29  b2fc 8c011f                              sty GKI__parm2
    30  b2ff 8d021f                              sta GKI__parm3
    31                          
    32  b302 20825d                              jsr combyt                               ; get height
    33  b305 8e031f                              stx GKI__parm4
    34                          
    35  b308 20825d                              jsr combyt                               ; get width
    36  b30b 8e041f                              stx GKI__parm5
    37                          
    38  b30e 20825d                              jsr combyt                               ; get direction
    39  b311 8e051f                              stx GKI__parm6
    40                          
    41  b314 205b4e                              jsr chkcom
    42  b317 20ef4c                              jsr frmevl                               ; evaluate the string
    43  b31a 20dd4c                              jsr chkstr                               ; type mismatch error if not string
    44  b31d a000                                ldy #0
    45  b31f 20a922                              jsr indfmo                               ; pointer to string descriptor is left in the fac by frmevl
    46  b322 8d061f                              sta GKI__parm7                           ; length  ???? check for null string ????
    47  b325 48                                  pha
    48  b326 c8                                  iny
    49  b327 20a922                              jsr indfmo
    50  b32a 8d071f                              sta GKI__parm8                           ; adrlo
    51  b32d c8                                  iny
    52  b32e 20a922                              jsr indfmo
    53  b331 8d081f                              sta GKI__parm9                           ; adrhi
    54  b334 206d5b                              jsr frefac                               ; [910917]
    55  b337 68                                  pla
    56  b338 20dd5b                              jsr getspa
    57                          
    58  b33b 20f278                              jsr optwrd                               ; get charset address (????bank)
    59  b33e b004                                bcs l277_1                               ; given
    60  b340 a000                                ldy #<$9800                              ; not given- use ROM as default   [910207] FAB
    61  b342 a998                                lda #>$9800                              ; ???? uc/lc or graphic set ????
    62  b344 8c091f             l277_1           sty GKI__parm10                          ; lo
    63  b347 8d0a1f                              sta GKI__parm11                          ; hi
    64  b34a a202                                ldx #2                                   ; default to ROM bank 2    [910912] FAB
    65  b34c 202679                              jsr optbyt
    66  b34f 8e0b1f                              stx GKI__parm12
    67                          
    68  b352 ad061f                              lda GKI__parm7                           ; ???? check for null string ????
    69  b355 f003                                beq l277_2
    70  b357 6c2c80                              jmp ($802c)                              ; bra kg65.char
    71                          
    72  b35a 60                 l277_2           rts

; ******** Source: basic.asm

; ******** Source: command/paint.asm
     1                          
     2                          
     3                          
     4                          ;*****************************************************************
     5                          ;* PAINT   fill a graphic area with color
     6                          ;*
     7                          ;*  Syntax : PAINT x, y [,mode [,color]]
     8                          ;*
     9                          ;* parm1  = x lo
    10                          ;* parm2  = x lo
    11                          ;* parm3  = y lo
    12                          ;* parm4  = y hi
    13                          ;* parm5  = mode
    14                          ;* parm6  = color
    15                          ;*
    16                          ;* fill color is pen-A
    17                          ; mode 0: fill region defined by color at x,y (default) new modes [910916] FAB
    18                          ; mode 1: fill region using given color as boundary
    19                          ; mode 2: fill connected region
    20                          ;****************************************************************
    21                          
    22                          C65__paint                                                ; new [910228] FAB
    23  b35b 201caf                              jsr CheckGraphicMode
    24  b35e 20e5b7                              jsr sadwrd                               ; get x
    25  b361 8c001f                              sty GKI__parm1
    26  b364 8d011f                              sta GKI__parm2
    27                          
    28  b367 200879                              jsr comsad                               ; get y
    29  b36a 8c021f                              sty GKI__parm3
    30  b36d 8d031f                              sta GKI__parm4
    31                          
    32  b370 a200                                ldx #0                                   ; [910916]
    33  b372 202679                              jsr optbyt                               ; mode, default = 0 (fill region pointed to)
    34  b375 e003                                cpx #3
    35  b377 b3859e                              +lbcs fcerr                              ; (range 0-2)
    36  b37a 8e041f                              stx GKI__parm5
    37  b37d a200                                ldx #0
    38  b37f 202679                              jsr optbyt                               ; boundary color, default = 0
    39  b382 8e051f                              stx GKI__parm6
    40                          
    41  b385 20335c             l278_1           jsr garba2                               ; create space in var bank for paint stack [910716]
    42  b388 a533                                lda strend
    43  b38a 8d061f                              sta GKI__parm7                           ; pass pointer to bottom of bank-1 free space
    44  b38d a534                                lda strend+1                             ; (top of stack)
    45  b38f 8d071f                              sta GKI__parm8
    46  b392 38                                  sec
    47  b393 a535                                lda fretop                               ; pass pointer to top of free space
    48  b395 e903                                sbc #3                                   ; (bottom of stack)
    49  b397 8d081f                              sta GKI__parm9
    50  b39a a536                                lda fretop+1
    51  b39c e900                                sbc #0
    52  b39e 8d091f                              sta GKI__parm10
    53                          
    54  b3a1 222e80                              jsr ($802e)                              ; bra paint
    55  b3a4 b001                                bcs l278_2                               ; error- stack overflow or stop key
    56  b3a6 60                                  rts
    57                          
    58  b3a7 e010               l278_2           cpx #errom
    59  b3a9 f3a47a                              +lbeq error                              ; stack overflow, say 'out of memory'
    60  b3ac 832379                              +lbra break_exit                         ; user hit stop key

; ******** Source: basic.asm

; ******** Source: command/loadiff.asm
     1                          
     2                          
     3                          
     4                          ;*****************************************************************
     5                          ;*   LOADIFF "filename" [,U#] [,D#]
     6                          ;*
     7                          ;* ???? requires SCREEN already opened   910402 FAB
     8                          ;*****************************************************************
     9                          
    10                          loadiff
    11  b3af 201caf                              jsr CheckGraphicMode
    12  b3b2 a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
    13  b3b4 202074                              jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 )
    14  b3b7 20dc77                              jsr chk1                                 ; check parameters
    15  b3ba a900                                lda #0
    16  b3bc 8d8311                              sta dossa                                ; setup as dload would (0 = load channel)
    17  b3bf 201d71                              jsr find_la                              ; find an available la to use (cannot use reserved one)
    18  b3c2 a009                                ldy #fopn
    19  b3c4 a204                                ldx #4
    20  b3c6 20fd70                              jsr open_file                            ; open the file
    21  b3c9 b006                                bcs l279_1                               ; exit if error
    22                          
    23  b3cb ae8111                              ldx dosla
    24                          ; stx GKI__parm1
    25  b3ce 20c6ff                              jsr _chkin                               ; get input channel
    26  b3d1 b3547f             l279_1           +lbcs list_err                           ; exit if error
    27                          
    28  b3d4 222a80                              jsr ($802a)                              ; Load it
    29                          
    30                          exit_GKI_disk_op
    31  b3d7 08                                  php                                      ; preserve completion status
    32  b3d8 48                                  pha
    33  b3d9 20ccff                              jsr _clrch
    34  b3dc ad8111                              lda dosla
    35  b3df 200e69                              jsr close_out                            ; close channel
    36                          
    37  b3e2 20cc2c                              jsr is_stop_key_down                     ; weed out BREAK error
    38  b3e5 fa                                  plx
    39  b3e6 28                                  plp
    40  b3e7 b3667a                              +lbcs error                              ; must be I/O or file data error
    41  b3ea 60                                  rts                                      ; load was successful

; ******** Source: basic.asm

; ******** Source: command/saveiff.asm
     1                          
     2                          ;*****************************************************************
     3                          ;*
     4                          ;*   SAVEIFF "[@]filename" [,U#] [,D#]      [910930] FAB
     5                          ;*
     6                          ;*****************************************************************
     7                          
     8                          saveiff
     9  b3eb 201caf                              jsr CheckGraphicMode
    10  b3ee a966                                lda #$66                                 ; set error flags
    11  b3f0 202074                              jsr dosprs                               ; parse the line
    12  b3f3 20e177                              jsr chk2                                 ; check required parameters
    13  b3f6 a901                                lda #1
    14  b3f8 8d8311                              sta dossa                                ; setup as dsave would (1 = save channel)
    15  b3fb 201d71                              jsr find_la                              ; find an available la to use (cannot use reserved one)
    16  b3fe a009                                ldy #fopn
    17  b400 a204                                ldx #4
    18  b402 20fd70                              jsr open_file                            ; open the file
    19  b405 b006                                bcs l280_1                               ; exit if error
    20                          
    21  b407 ae8111                              ldx dosla
    22                          ; stx GKI__parm1
    23  b40a 20c9ff                              jsr _chkout                              ; get output channel
    24  b40d b3187f             l280_1           +lbcs list_err                           ; exit if error
    25                          
    26  b410 223a80                              jsr ($803a)                              ; Save it
    27  b413 80c2                                bra exit_GKI_disk_op
    28                          
    29                          ; php   ;preserve completion status
    30                          ; pha
    31                          ; jsr _clrch
    32                          ; lda dosla
    33                          ; jsr close_out  ;close channel
    34                          ;
    35                          ; jsr is_stop_key_down ; weed out BREAK error
    36                          ; plx
    37                          ; plp
    38                          ; bcs error  ; must be I/O or file data error
    39                          ; rts   ; load was successful
    40                          

; ******** Source: basic.asm

; ******** Source: command/viewport.asm
     1                          
     2                          
     3                          
     4                          ;*****************************************************************
     5                          ;*   VIEWPORT <CLR | DEF>  x, y, viewport_width, viewport_height
     6                          ;*
     7                          ;* assumes SCREEN already opened   910626 FAB
     8                          ;*****************************************************************
     9                          
    10                          C65__Viewport
    11  b415 48                                  pha                                      ; save secondary command
    12  b416 208322                              jsr chrget                               ; advance past it
    13  b419 201caf                              jsr CheckGraphicMode                     ; make sure a screen is open
    14                          
    15  b41c 20e5b7                              jsr sadwrd                               ; get x0
    16  b41f 8c001f                              sty GKI__parm1
    17  b422 8d011f                              sta GKI__parm2
    18                          
    19  b425 200879                              jsr comsad                               ; get y0
    20  b428 8c021f                              sty GKI__parm3
    21  b42b 8d031f                              sta GKI__parm4
    22                          
    23  b42e 200879                              jsr comsad                               ; get width (delta-x)
    24  b431 8c041f                              sty GKI__parm5
    25  b434 8d051f                              sta GKI__parm6
    26                          
    27  b437 200879                              jsr comsad                               ; get height (delta-y)
    28  b43a 8c061f                              sty GKI__parm7
    29  b43d 8d071f                              sta GKI__parm8
    30                          
    31  b440 68                                  pla                                      ; dispatch per secondary token...
    32  b441 c99c                                cmp #clr_token
    33  b443 f008                                beq l281_1
    34  b445 c996                                cmp #def_token
    35  b447 d3017a                              +lbne snerr                              ; error
    36                          
    37  b44a 6c3080                              jmp ($8030)                              ; define viewport & return
    38                          
    39  b44d 6c2280             l281_1           jmp ($8022)                              ; clear viewport (???? make this a box command)
    40                          
    41                          
    42                          C65__copy
    43                          C65__cut
    44                          C65__paste
    45  b450 4c3b2e                              jmp bad_command

; ******** Source: basic.asm

; ******** Source: command/genlock.asm
     1                          
     2                          
     3                          
     4                          ;*****************************************************************
     5                          ;* GENLOCK  set/reset genlock mode & color registers
     6                          ;*
     7                          ;*  Syntax: GENLOCK <ON[,color#[,...]] | OFF[,color#,R,G,B]>
     8                          ;*****************************************************************
     9                          
    10  b453 8d001f             genlock          sta GKI__parm1                           ; save token as flag for set palette   [910107]
    11  b456 c991                                cmp #on_token
    12  b458 f028                                beq l282_4
    13  b45a 2016b5                              jsr chkesc
    14  b45d c924                                cmp #off_token
    15  b45f d3e979                              +lbne snerr
    16                          ;TURN GENLOCK OFF
    17  b462 ad31d0                              lda vic+49                               ; any interlaced bitplanes on?
    18  b465 2919                                and #%00011001
    19  b467 c919                                cmp #%00011001
    20  b469 f005                                beq l282_1                               ; yes, leave interlace mode on
    21                          
    22  b46b a901                                lda #%00000001
    23  b46d 1c31d0                              trb vic+49                               ; no, turn interlace off
    24  b470 a902               l282_1           lda #%00000010
    25  b472 1c30d0                              trb vic+48                               ; reset external sync mode
    26                          ; beq l282_2   ;       [910114]
    27                          ; lda vic+63  ;       [910111]
    28                          ; inc a   ;  adjust vert. position (chip bug ????)
    29                          ; inc a   ;  (to be handled by a custom C65 genlock board)
    30                          ; inc a
    31                          ; sta vic+63
    32                          
    33  b475 208322             l282_2           jsr chrget                               ; eat token
    34  b478 202679                              jsr optbyt                               ; get (optional) color reg# in .X
    35  b47b 8e011f                              stx GKI__parm2                           ; save it
    36  b47e b3f0fb                              +lbcs set_palette                        ; if present, go do it & exit
    37  b481 60                 l282_3           rts                                      ; if not present (eol), exit
    38                          
    39                          
    40  b482 a901               l282_4           lda #%00000001                           ; TURN GENLOCK ON
    41  b484 0c31d0                              tsb vic+49                               ; set interlace mode
    42  b487 0a                                  asl
    43  b488 0c30d0                              tsb vic+48                               ; set external sync mode
    44                          ; bne l282_5   ;       [910114]
    45                          ; lda vic+63  ;       [910111]
    46                          ; dec a   ;  adjust vert. position (chip bug ????)
    47                          ; dec a   ;  (to be handled by a custom C65 genlock board)
    48                          ; dec a
    49                          ; sta vic+63
    50                          
    51  b48b 208322             l282_5           jsr chrget                               ; eat token
    52  b48e 202679             l282_6           jsr optbyt                               ; get (optional) color reg# in .X
    53  b491 90ee                                bcc l282_3                               ; if not present (eol), exit
    54  b493 a910                                lda #%00010000                           ; if present, set FGBG bit in red palette
    55  b495 9d00d1                              sta _red,x
    56  b498 80f4                                bra l282_6                               ; loop

; ******** Source: basic.asm

; ******** Source: command/color.asm
     1                          
     2                          
     3                          
     4                          
     5                          ;*****************************************************************
     6                          ;* COLOR       <ON | OFF> Enable|Disable SW & HW color
     7                          ;* FOREGROUND  color# Set Foreground color (text)
     8                          ;* HIGHLIGHT   color# Set Highlight color (text)
     9                          ;* BACKGROUND  color# Set VIC Background color
    10                          ;* BORDER      color# Set VIC Border color
    11                          ;*****************************************************************
    12                          
    13  b49a c92c               color            cmp #','                                 ; optional first arg
    14  b49c f01f                                beq l283_3
    15  b49e c991                                cmp #on_token                            ; SOFTWARE (Editor) color mode
    16  b4a0 f00b                                beq l283_2
    17  b4a2 2016b5                              jsr chkesc
    18  b4a5 c924                                cmp #off_token
    19  b4a7 d3a179             l283_1           +lbne snerr
    20                          
    21  b4aa a05b                                ldy #'['                                 ; OFF (color & attributes)
    22  b4ac 2c                                  !text $2c
    23  b4ad a05d               l283_2           ldy #']'                                 ; ON
    24  b4af a91b                                lda #esc
    25  b4b1 20d2ff                              jsr _bsout                               ; do it
    26  b4b4 98                                  tya
    27  b4b5 20d2ff                              jsr _bsout
    28  b4b8 208322                              jsr chrget                               ; eat token
    29  b4bb f01d                                beq l283_6                               ; eol- exit
    30                          
    31  b4bd 205b4e             l283_3           jsr chkcom                               ; else must be comma, eat & get next
    32                          ; jsr chrgot  ;      [910930]
    33  b4c0 c991                                cmp #on_token                            ; HARDWARE (Vic) color mode
    34  b4c2 f00e                                beq l283_4
    35  b4c4 2016b5                              jsr chkesc
    36  b4c7 c924                                cmp #off_token
    37  b4c9 d0dc                                bne l283_1
    38                          
    39  b4cb a902                                lda #%00000010                           ; OFF (monochrome)
    40  b4cd 0c31d0                              tsb vic+49
    41  b4d0 8005                                bra l283_5
    42                          
    43  b4d2 a902               l283_4           lda #%00000010                           ; ON
    44  b4d4 1c31d0                              trb vic+49
    45  b4d7 83aa6d             l283_5           +lbra chrget                             ; exit after eating last token
    46                          
    47  b4da 60                 l283_6           rts                                      ; exit after encountering eol
    48                          
    49                          
    50                          foreground
    51  b4db 200db5                              jsr getnyb                               ; Set text foreground color
    52  b4de 86f1                                stx _color
    53  b4e0 60                                  rts
    54                          
    55                          
    56                          
    57                          highlight
    58  b4e1 f36779                              +lbeq snerr                              ; missing args??     [911017]
    59  b4e4 c92c                                cmp #','
    60  b4e6 f006                                beq l284_1                               ; options byte only
    61                          
    62  b4e8 206c5d                              jsr getbyt                               ; Set text highlight color
    63  b4eb 8ed802                              stx highlight_color
    64                          
    65  b4ee 202479             l284_1           jsr optzer                               ; set options:     [911001]
    66  b4f1 9008                                bcc l284_2                               ; comma but no value not given??
    67  b4f3 8a                                  txa
    68  b4f4 2903                                and #3                                   ; 0= error msgs only
    69  b4f6 0a                                  asl                                      ; 1= REMs
    70  b4f7 0a                                  asl                                      ; 2= tokens
    71  b4f8 0a                                  asl
    72  b4f9 8555                                sta helper
    73  b4fb 60                 l284_2           rts
    74                          
    75                          
    76                          
    77                          background
    78  b4fc 200db5                              jsr getnyb                               ; Set Vic background color
    79  b4ff 8e21d0                              stx vic+33
    80  b502 60                                  rts
    81                          
    82                          
    83                          
    84                          border
    85  b503 200db5                              jsr getnyb                               ; Set Vic border color
    86  b506 8e20d0                              stx vic+32
    87  b509 60                                  rts
    88                          
    89                          
    90                          getcomnyb
    91  b50a 205b4e                              jsr chkcom                               ; check for comma
    92                          getnyb
    93  b50d 206c5d                              jsr getbyt                               ; Get a nybble, check range (0-15)
    94                          chknyb
    95  b510 e010                                cpx #16
    96  b512 b3ea9c                              +lbcs fcerr
    97  b515 60                                  rts
    98                          
    99                          
   100                          
   101                          chkesc                                                    ; Check for escape token, error if not, else get next token
   102  b516 c9fe                                cmp #esc_command_token
   103  b518 d33079                              +lbne snerr
   104  b51b 208322                              jsr chrget
   105  b51e f32a79                              +lbeq snerr                              ; eos? report error if so
   106  b521 60                                  rts
   107                          
   108                          
   109                          
   110                          chkeos                                                    ; Check for next byte = end of statement, error if not
   111  b522 208322                              jsr chrget
   112  b525 d32379                              +lbne snerr                              ; eos? report error if not
   113  b528 60                                  rts
   114                          
   115                          

; ******** Source: basic.asm

; ******** Source: command/sprite.asm
     1                          
     2                          
     3                          
     4                          ;************************************************************************************
     5                          ; SPRITE CLR
     6                          ; SPRITE {LOAD|SAVE} "filename" [,Ddrive] [,Udevice]
     7                          ; SPRITE sprite [,enable [,color [,priority [,xexp [,yexp [,resolution] ]]]]]
     8                          ;
     9                          ; where: sprite  :== sprite number (1-8)
    10                          ;  enable  :== enable  (0=off, 1=on)
    11                          ;  color  :== color  (0-15)
    12                          ;  priority :== sprite/bgnd  (0=sprite, 1=bgnd)
    13                          ;  xexp  :== expand x direction (0=no, 1=yes)
    14                          ;  yexp  :== expand y direction (0=no, 1=yes)
    15                          ;  resolution :== resolution  (0=hires, 1=multicolor)
    16                          ;************************************************************************************
    17                          
    18  b529 c99c               sprite           cmp #clr_token                           ; SPRITE CLR: init environment   [910717]
    19  b52b f3a709                              +lbeq Sprite_CLR                         ; yes
    20  b52e c994                                cmp #save_token                          ; SPRITE SAVE: save sprite data   [911001]
    21  b530 f048                                beq Sprite_Save                          ; yes
    22  b532 c993                                cmp #load_token                          ; SPRITE LOAD: load sprite data   [911001]
    23  b534 f057                                beq Sprite_Load                          ; yes
    24                          
    25  b536 20b5b5                              jsr get_sprite_number                    ; get sprite number in z_p_temp_1
    26  b539 202679                              jsr optbyt                               ; look for (optional) enable
    27  b53c 9005                                bcc l285_1                               ; none here, don't change
    28  b53e a015                                ldy #21
    29  b540 209fb5                              jsr sprbit                               ; set/clear sprite bit
    30                          
    31  b543 202679             l285_1           jsr optbyt                               ; get (optional) color
    32  b546 9009                                bcc l285_2                               ; branch if no arg
    33  b548 2010b5                              jsr chknyb                               ; [910109]
    34  b54b 8a                                  txa
    35  b54c a676                                ldx z_p_temp_1                           ; get back sprite number
    36                          ; jsr put_io_in_map
    37  b54e 9d27d0                              sta vic+39,x
    38                          
    39  b551 202679             l285_2           jsr optbyt                               ; look for (optional) priority
    40  b554 9005                                bcc l285_3
    41  b556 a01b                                ldy #27
    42  b558 209fb5                              jsr sprbit
    43                          
    44  b55b 202679             l285_3           jsr optbyt                               ; look for (optional) x expansion
    45  b55e 9005                                bcc l285_4
    46  b560 a01d                                ldy #29
    47  b562 209fb5                              jsr sprbit
    48                          
    49  b565 202679             l285_4           jsr optbyt                               ; look for (optional) y expansion
    50  b568 9005                                bcc l285_5
    51  b56a a017                                ldy #23
    52  b56c 209fb5                              jsr sprbit
    53                          
    54  b56f 202679             l285_5           jsr optbyt                               ; look for (optional) resolution
    55  b572 9005                                bcc l285_6
    56  b574 a01c                                ldy #28
    57  b576 209fb5                              jsr sprbit
    58                          
    59  b579 60                 l285_6           rts
    60                          
    61                          
    62                          Sprite_Save                                               ; Just like Key_Save     [911001]
    63  b57a 202e47                              jsr GetSaveChannel
    64  b57d a95a                                lda #highds                              ; set starting & ending addresses
    65  b57f a006                                ldy #>sprite_base                        ; start address & pointer to it
    66  b581 a200                                ldx #<sprite_base
    67  b583 845b                                sty highds+1
    68  b585 865a                                stx highds
    69  b587 c8                                  iny                                      ; end address = start address + 512 + 1
    70  b588 c8                                  iny
    71  b589 e8                                  inx
    72  b58a 83dfb2                              +lbra savenb                             ; [910925]
    73                          
    74                          
    75                          
    76                          Sprite_Load
    77  b58d 20c946                              jsr GetLoadChannel                       ; get a channel      [911001]
    78  b590 a006                                ldy #>sprite_base
    79  b592 a900                                lda #<sprite_base
    80  b594 20fa46                              jsr LoadBlock                            ; load first block
    81  b597 e65b                                inc highds+1
    82  b599 20fe46                              jsr LoadBlockNext                        ; load second block
    83  b59c 83897d                              +lbra list_err                           ; release channel, close file, return to main
    84                          
    85                          
    86                          ;  Set or clear a bit in a VIC register
    87                          ;
    88                          ; .X = 1 to set, 0 to clear
    89                          ; .Y = register in VIC to operate opon
    90                          
    91  b59f 8a                 sprbit           txa
    92  b5a0 4a                                  lsr                                      ; put lsb in .C (0 clear, 1 set sprite bit)
    93  b5a1 d35b9c                              +lbne fcerr                              ; only 0 or 1, please.
    94                          ; jsr put_io_in_map
    95  b5a4 a676                                ldx z_p_temp_1                           ; get sprite number
    96  b5a6 bd6579                              lda sbits,x
    97  b5a9 1900d0                              ora vic,y
    98  b5ac b003                                bcs l286_1
    99  b5ae 5d6579                              eor sbits,x
   100  b5b1 9900d0             l286_1           sta vic,y
   101  b5b4 60                                  rts
   102                          
   103                          
   104                          get_sprite_number
   105  b5b5 206c5d                              jsr getbyt
   106                          ; dex        [910221]
   107  b5b8 e008                                cpx #8
   108  b5ba b3429c                              +lbcs fcerr
   109  b5bd 8676                                stx z_p_temp_1
   110  b5bf 60                                  rts
   111                          

; ******** Source: basic.asm

; ******** Source: command/movspr.asm
     1                          
     2                          
     3                          
     4                          ;****************************************************************
     5                          ; Move Sprite.  Position sprite and optionally animate it.
     6                          ;
     7                          ;   MOVSPR n, [ p | x#y ]   or   MOVSPR n, p1 TO p2, speed
     8                          ;
     9                          ;  n = Sprite number (0-7)
    10                          ; p = (x,y) coordinate.
    11                          ;  Relative and angular distances  are relative to
    12                          ;  current sprite position and scaled if scaling is on.
    13                          ; x#y = Constant movement at an angle-x with speed-y.
    14                          ;****************************************************************
    15                          
    16  b5c0 a900               movspr           lda #0                                   ; flag 'movspr' initial coord   [910808]
    17  b5c2 8587                                sta op                                   ; (0=movspr, $80=movspr_to, $7f=mouse)
    18  b5c4 20b5b5                              jsr get_sprite_number                    ; get sprite #
    19  b5c7 20c3b7                              jsr sprcor                               ; get first coordinate (y,a)
    20                          movspr_1                                                  ; entry to eval destination coordinate  [910808]
    21  b5ca 2cf411                              bit numcnt                               ; test coordinate type
    22  b5cd 737b78                              +lbvs snerr                              ; syntax error
    23  b5d0 8cf011                              sty xdest                                ; save coordinate value
    24  b5d3 8cf211                              sty xdest+2
    25  b5d6 8df111                              sta xdest+1
    26  b5d9 8df311                              sta xdest+3
    27                          
    28  b5dc 20c3b7                              jsr sprcor                               ; get second coordinate (y,a)
    29  b5df 2cf411                              bit numcnt                               ; test coordinate type & dispatch accordingly
    30  b5e2 5060                                bvc movspr_normal                        ; normal coordinates
    31  b5e4 3040                                bmi movspr_angle                         ; angular coordinates
    32                          
    33  b5e6 2487                                bit op                                   ; angle#speed, test if allowed
    34  b5e8 336078                              +lbmi snerr                              ; ng- movspr_to call
    35  b5eb 5a                                  phy                                      ; ok- save speed value
    36  b5ec a004                                ldy #xdest-vwork
    37  b5ee 20b5ba                              jsr getang                               ; get angle of movement
    38  b5f1 a676                                ldx z_p_temp_1                           ; get sprite number
    39  b5f3 bcfeb7                              ldy sproff,x                             ; get offset to speed data
    40  b5f6 a900                                lda #0
    41  b5f8 990512                              sta sprite_data,y                        ; turn off sprite speed
    42  b5fb c8                                  iny
    43                          
    44  b5fc a203                                ldx #3
    45  b5fe 5efb11             l287_1           lsr sinval,x
    46  b601 ca                                  dex
    47  b602 7efb11                              ror sinval,x
    48  b605 ca                                  dex
    49  b606 10f6                                bpl l287_1
    50                          
    51  b608 78                 l287_2           sei
    52  b609 e8                                  inx                                      ; x=0
    53  b60a bdfa11                              lda angsgn,x                             ; move angle data to speed data
    54  b60d c8                                  iny
    55  b60e 990512                              sta sprite_data,y
    56  b611 e004                                cpx #4
    57  b613 d0f3                                bne l287_2
    58                          
    59  b615 a900                                lda #0                                   ; clear speed angle counts
    60  b617 c8                 l287_3           iny
    61  b618 990512                              sta sprite_data,y
    62  b61b ca                                  dex
    63  b61c d0f9                                bne l287_3
    64                          
    65  b61e 68                                  pla                                      ; restore speed value
    66  b61f 293f                                and #$3f                                 ; limit range (0-63) ????  [910806]
    67  b621 99fb11                              sta sprite_data-10,y                     ; start sprite movement
    68  b624 58                                  cli
    69  b625 60                                  rts
    70                          
    71                          movspr_angle
    72                          ; jsr swapxy  ;swap y and a (eventually) : y ==> x
    73                          ; tay   ;        a ==> y
    74                          ; txa   ;        x ==> a
    75  b626 48                                  pha
    76  b627 98                                  tya
    77  b628 7a                                  ply
    78                          
    79  b629 20b8ba                              jsr gtang1                               ; get angle values
    80                          ; ldx #xdest-vwork
    81                          ; jsr scalxy  ;scale lengths
    82  b62c a204                                ldx #xdest-vwork
    83  b62e 18                                  clc
    84                          
    85  b62f 2011bb             l288_1           jsr angmlt                               ; multiply lengths*angles for x and y
    86  b632 9dec11                              sta vwork,x
    87  b635 98                                  tya
    88  b636 9ded11                              sta vwork+1,x
    89  b639 e8                                  inx
    90  b63a e8                                  inx
    91  b63b e006                                cpx #ydest-vwork
    92  b63d f0f0                                beq l288_1                               ; loop to do y-position
    93                          
    94  b63f 6ef411                              ror numcnt                               ; shift in carry to set msb
    95  b642 8006                                bra movspr_position                      ; go place sprite
    96                          
    97                          
    98                          movspr_normal                                             ; [910122]
    99  b644 8cf211                              sty xdest+2                              ; save second coordinate (y,a)
   100  b647 8df311                              sta xdest+3
   101                          ; ldx #xdest-vwork
   102                          ; jsr scalxy  ;scale the coordinates
   103                          
   104                          
   105                          movspr_position
   106  b64a 78                                  sei                                      ; [910123]
   107  b64b a576                                lda z_p_temp_1                           ; get sprite number
   108  b64d aa                                  tax                                      ; use as an index
   109  b64e 0a                                  asl
   110  b64f a8                                  tay                                      ; get sprite-number * 2 as another index
   111                          
   112  b650 7f8701                              bbr7 op,l289_1
   113  b653 60                                  rts                                      ; >>>exit here if movspr_to call   [910808]
   114                          
   115  b654 adf211             l289_1           lda xdest+2                              ; get y-coordinate
   116  b657 0ef411                              asl numcnt                               ; test if relative
   117  b65a 9009                                bcc l289_3                               ; skip if absolute
   118  b65c 18                                  clc
   119  b65d 1003                                bpl l289_2                               ; skip if normal coordinates
   120  b65f 49ff                                eor #$ff
   121  b661 38                                  sec                                      ; invert to subtract if angular
   122  b662 7901d0             l289_2           adc vic+1,y                              ; add to current sprite y-value  ???vic_save
   123                          
   124  b665 9901d0             l289_3           sta vic+1,y                              ; save new sprite y-position  ???vic_save
   125  b668 adf011                              lda xdest                                ; get low byte of x-coordinate
   126  b66b 0ef411                              asl numcnt                               ; test if relative
   127  b66e 1011                                bpl l289_5                               ; skip if absolute
   128  b670 18                                  clc
   129  b671 7900d0                              adc vic,y                                ; add current sprite x-position  ???vic_save
   130  b674 9900d0                              sta vic,y                                ; save sprite x-position   ???vic_save
   131  b677 b003                                bcs l289_4                               ; skip if carry
   132  b679 eef111                              inc xdest+1                              ; invert lsb
   133                          
   134  b67c ad10d0             l289_4           lda vic+16                               ; get x-position msb bits  ???vic_save
   135  b67f 8009                                bra l289_6                               ; test if need to invert msb bit
   136                          
   137  b681 9900d0             l289_5           sta vic,y                                ; save new sprite x-position  ???vic_save
   138  b684 ad10d0                              lda vic+16                               ; ???vic_save
   139  b687 1d6579                              ora sbits,x                              ; set x-position msb bit
   140                          
   141  b68a 4ef111             l289_6           lsr xdest+1                              ; match to lsb of x-coordinate high byte
   142  b68d b003                                bcs l289_7                               ; skip if should be set
   143  b68f 5d6579                              eor sbits,x                              ; reset bit
   144                          
   145  b692 8d10d0             l289_7           sta vic+16                               ; save position msb bits   ???vic_save
   146                          ; cli
   147                          ;1l289_1 rts   ; mouse or movspr_to
   148                          
   149                          
   150                          movspr_to                                                 ; setup for moving sprite to a particular position
   151                          ;we have already positioned the sprite onscreen
   152  b695 208522                              jsr chrgot                               ; reget terminating character
   153  b698 c9a4                                cmp #to_token
   154  b69a f002                                beq l290_1                               ; not our call
   155  b69c 58                                  cli
   156  b69d 60                                  rts
   157                          
   158  b69e f787               l290_1           smb7 op                                  ; it's for us- let everybody else know we're in charge
   159  b6a0 208322                              jsr chrget                               ; move to next non-space character
   160  b6a3 18                                  clc
   161  b6a4 20c6b7                              jsr sprcor_1                             ; go get & evaluate destination coordinate
   162  b6a7 20cab5                              jsr movspr_1                             ; returns with sprite# in .x, VIC sprite index in .y,
   163                          ;P1 in VIC sprite regs, and P2 in x,ydest
   164  b6aa 0ef411                              asl numcnt                               ; Y: handle specific coordinate types
   165  b6ad 900f                                bcc l290_3                               ; skip if absolute
   166  b6af 18                                  clc
   167  b6b0 adf211                              lda xdest+2                              ; get y-coordinate
   168  b6b3 1003                                bpl l290_2                               ; skip if normal coordinates
   169  b6b5 49ff                                eor #$ff
   170  b6b7 38                                  sec                                      ; invert to subtract if angular
   171  b6b8 7901d0             l290_2           adc vic+1,y                              ; add to current sprite y-value ???vic_save
   172  b6bb 8df211                              sta xdest+2                              ; save sprite destination y-position
   173                          
   174  b6be 0ef411             l290_3           asl numcnt                               ; X: handle specific coordinate types
   175  b6c1 100f                                bpl l290_4                               ; skip if absolute
   176  b6c3 18                                  clc
   177  b6c4 adf011                              lda xdest                                ; get low byte of x-coordinate
   178  b6c7 7900d0                              adc vic,y                                ; add current sprite x-position  ???vic_save
   179  b6ca 8df011                              sta xdest                                ; save sprite destination x-position
   180  b6cd 9003                                bcc l290_4
   181  b6cf eef111                              inc xdest+1
   182                          
   183  b6d2 5a                 l290_4           phy
   184  b6d3 20825d                              jsr combyt                               ; get speed parameter
   185  b6d6 8a                                  txa
   186  b6d7 293f                                and #$3f                                 ; limit range (0-63) ????
   187  b6d9 0980                                ora #$80
   188  b6db 8d8411                              sta xcnt                                 ; save in temp.
   189  b6de 7a                                  ply
   190                          
   191  b6df b900d0                              lda vic,y                                ; copy current sprite pos'n to line vars
   192  b6e2 8dec11                              sta xpos                                 ; in preparation for line calculations
   193  b6e5 b901d0                              lda vic+1,y
   194  b6e8 8dee11                              sta ypos
   195  b6eb a900                                lda #0
   196  b6ed 8ded11                              sta xpos+1
   197  b6f0 8def11                              sta ypos+1
   198  b6f3 98                                  tya
   199  b6f4 4a                                  lsr
   200  b6f5 a8                                  tay
   201  b6f6 b96579                              lda sbits,y
   202  b6f9 2d10d0                              and vic+16
   203  b6fc f003                                beq l290_5
   204  b6fe eeed11                              inc xpos+1
   205                          l290_5
   206                          
   207                          ;******************************************************************
   208                          ;  MOVSPR n, p1 TO p2 - move a sprite along line from p1 to p2
   209                          ;
   210                          ; The following is performed now:
   211                          ;
   212                          ;           absx    = abs(destx-posx) : absy = abs(desty-posy)
   213                          ;           sgnx    = sgn(destx-posx) : sgny = sgn(desty-posy)
   214                          ;                     ( sgn=(1,0,-1) if (+,0,-) )
   215                          ;           greatr  = index to the greatr of absx,absy
   216                          ;           lesser  = index to the smaller of absx,absy
   217                          ;
   218                          ;           fct1    = 2*min(absx,absy)
   219                          ;           fct2    = fct1 - 2*max(absx,absy)
   220                          ;           error   = fct1 - max(absx,absy)
   221                          ;
   222                          ; The following is performed during IRQ:
   223                          ;
   224                          ;           for i:= 1 to max(absx,absy) do begin
   225                          ;                 movspr n, posx, posy
   226                          ;                 if error > 0 then begin
   227                          ;                      pos(lesser):= pos(lesser) + sgn(lesser)
   228                          ;                      error:= error + fct2
   229                          ;                      end
   230                          ;                      else error:= error + fct1
   231                          ;                 pos(greatr):= pos(greatr) + sgn(greatr)
   232                          ;           end;
   233                          ;
   234                          ; (modification of C128 Bresenham DrawLn algorithm 910808 F.Bowen)
   235                          ;******************************************************************
   236                          
   237                          movspr_line
   238  b701 a202                                ldx #ypos-vwork
   239  b703 a006                                ldy #ydest-vwork
   240  b705 a900               l291_1           lda #0
   241  b707 9d9511                              sta xsgn,x                               ; init direction pointers
   242  b70a 9d9611                              sta xsgn+1,x
   243  b70d 207fbb                              jsr abstwo                               ; get absolute value of coordinate differences
   244  b710 1008                                bpl l291_2                               ; and determine direction
   245  b712 de9511                              dec xsgn,x                               ; negative direction
   246  b715 de9611                              dec xsgn+1,x
   247  b718 800b                                bra l291_4
   248                          
   249  b71a c900               l291_2           cmp #0
   250  b71c d004                                bne l291_3
   251  b71e c000                                cpy #0
   252  b720 f003                                beq l291_4                               ; zero direction
   253  b722 fe9511             l291_3           inc xsgn,x                               ; positive direction
   254  b725 9d9111             l291_4           sta xabs,x
   255  b728 0a                                  asl
   256  b729 9d9911                              sta fct,x                                ; fct(x,y) = 2*abs(x,y)
   257  b72c 98                                  tya
   258  b72d 9d9211                              sta xabs+1,x
   259  b730 2a                                  rol
   260  b731 9d9a11                              sta fct+1,x
   261  b734 ca                                  dex
   262  b735 ca                                  dex
   263  b736 a004                                ldy #xdest-vwork                         ; loop to do in x-direction
   264  b738 e000                                cpx #xpos-vwork
   265  b73a f0c9                                beq l291_1
   266                          
   267  b73c a202                                ldx #yabs-savram                         ; determine max(xabs,yabs)
   268  b73e a000                                ldy #xabs-savram
   269  b740 205cbb                              jsr subtwo_savram
   270  b743 a900                                lda #0
   271  b745 2a                                  rol
   272  b746 2a                                  rol                                      ; a = c * 2
   273  b747 8d0312                              sta lesser                               ; index to smaller delta
   274  b74a 4902                                eor #2
   275  b74c 8d0412                              sta greatr                               ; index to greater delta
   276                          
   277  b74f 18                                  clc
   278  b750 a908                                lda #fct-savram
   279  b752 6d0312                              adc lesser
   280  b755 48                                  pha
   281  b756 a8                                  tay
   282  b757 4902                                eor #2
   283  b759 aa                                  tax
   284  b75a 205cbb                              jsr subtwo_savram                        ; fct(greatr) = fct(lesser)-fct(greatr)
   285  b75d 9d9111                              sta savram,x
   286  b760 8b9211                              sty savram+1,x
   287                          
   288  b763 7a                                  ply                                      ; fct(lesser)
   289  b764 18                                  clc
   290  b765 a900                                lda #xabs-savram
   291  b767 6d0412                              adc greatr
   292  b76a aa                                  tax
   293  b76b 205cbb                              jsr subtwo_savram                        ; error = fct(lesser) - abs(greatr)
   294  b76e 8d9d11                              sta errval
   295  b771 8c9e11                              sty errval+1
   296                          
   297                          ; At this point, we've positioned the sprite at the start position, and have
   298                          ; calculated everything we need to move it along a line towards the destination
   299                          ; position.  All that's left is to copy the working vars into the sprite_data
   300                          ; tables where the IRQ routine can find & diddle with our data.
   301                          ;
   302                          ;    move ang/dist move line
   303                          ;  offset= 0 b7=0+speed b7=1+speed
   304                          ;   1 counter  counter lo
   305                          ;   2 angle sign         hi
   306                          ;   3,4 delta-X  dir+min/max
   307                          ;   5,6 delta-Y  fct1
   308                          ;   7,8 total-X  fct2
   309                          ;   9,10 total-Y  error
   310                          
   311  b774 a476                                ldy z_p_temp_1                           ; sprite #
   312  b776 befeb7                              ldx sproff,y                             ; sprite IRQ table offset
   313                          
   314  b779 ad8411                              lda xcnt                                 ; set speed factor
   315  b77c 9d0512                              sta sprite_data,x
   316  b77f ac0412                              ldy greatr
   317  b782 b99111                              lda xabs,y                               ; set counter = max(xyabs)
   318  b785 9d0612                              sta sprite_data+1,x
   319  b788 b99211                              lda xabs+1,y
   320  b78b 9d0712                              sta sprite_data+2,x
   321  b78e b99511                              lda xsgn,y                               ; set dir(max) and max
   322  b791 199611                              ora xsgn+1,y
   323  b794 2903                                and #3
   324  b796 4a                                  lsr
   325  b797 6a                                  ror
   326  b798 0d0412                              ora greatr
   327  b79b 6a                                  ror
   328  b79c 9d0912                              sta sprite_data+4,x
   329  b79f ac0312                              ldy lesser
   330  b7a2 b99511                              lda xsgn,y                               ; set dir(min) and min
   331  b7a5 199611                              ora xsgn+1,y
   332  b7a8 2903                                and #3
   333  b7aa 4a                                  lsr
   334  b7ab 6a                                  ror
   335  b7ac 0d0312                              ora lesser
   336  b7af 6a                                  ror
   337  b7b0 9d0812                              sta sprite_data+3,x
   338  b7b3 a000                                ldy #0                                   ; set f1, f2, and e
   339  b7b5 b99911             l291_5           lda fct,y
   340  b7b8 9d0a12                              sta sprite_data+5,x
   341  b7bb e8                                  inx
   342  b7bc c8                                  iny
   343  b7bd c006                                cpy #6
   344  b7bf 90f4                                bcc l291_5
   345                          
   346  b7c1 58                                  cli
   347  b7c2 60                                  rts                                      ; done!

; ******** Source: basic.asm

; ******** Source: command/sprcor.asm
     1                          
     2                          
     3                          ;  SPRCOR  -- Get sprite position coordinate
     4                          ;
     5                          
     6  b7c3 20ebb7             sprcor           jsr chkcom_1                             ; check for a comma
     7                          sprcor_1
     8  b7c6 6ef411                              ror numcnt                               ; reset msb if comma else set msb
     9  b7c9 100b                                bpl l292_1                               ; skip if got a comma
    10  b7cb c93b                                cmp #';'                                 ; test if angular data
    11  b7cd f013                                beq l292_3                               ; skip if yes - 2 msb's = 1 1
    12  b7cf c923                                cmp #'#'                                 ; test if speed type
    13  b7d1 f00e                                beq l292_2                               ; skip if yes - 2 msb's = 0 1
    14  b7d3 837576                              +lbra snerr                              ; syntax error if none of above
    15                          
    16  b7d6 208522             l292_1           jsr chrgot                               ; test for relative coordinate
    17  b7d9 c9aa                                cmp #plus_token                          ; test if plus sign
    18  b7db f005                                beq l292_3                               ; skip if yes - show relative
    19  b7dd c9ab                                cmp #minus_token                         ; test if minus sign
    20  b7df f001                                beq l292_3                               ; skip if yes - show relative
    21  b7e1 18                 l292_2           clc                                      ; reset to show absolute
    22  b7e2 6ef411             l292_3           ror numcnt                               ; shift in second flag bit
    23                          
    24  b7e5 20d84c             sadwrd           jsr frmnum                               ; get number     label [910307]
    25  b7e8 83a8a5                              +lbra getsad                             ; get signed 2 byte coordinate,do rts
    26                          
    27                          
    28                          ;*************************************************************
    29                          ; CHKCOM_1  --  Check for a comma
    30                          ;
    31                          ;  carry set & eq = end of string
    32                          ;  carry set & neq = not a comma
    33                          ;  carry clear = a comma
    34                          ;*************************************************************
    35                          
    36                          chkcom_1
    37  b7eb 208522                              jsr chrgot                               ; get character in input stream
    38  b7ee f00d                                beq l293_2                               ; skip if end of string
    39  b7f0 c92c                                cmp #','                                 ; check if a comma
    40  b7f2 18                                  clc
    41  b7f3 f001                                beq l293_1                               ; skip if yes
    42  b7f5 38                                  sec                                      ; set carry if not
    43  b7f6 08                 l293_1           php
    44  b7f7 48                                  pha
    45  b7f8 208322                              jsr chrget                               ; move to next non-space character
    46  b7fb 68                                  pla
    47  b7fc 28                                  plp
    48  b7fd 60                 l293_2           rts
    49                          
    50                          
    51  b7fe 000b16212c37424d   sproff           !text 0,11,22,33,44,55,66,77             ; sprite offsets into speed table
    52                          

; ******** Source: basic.asm

; ******** Source: command/sprcolor.asm
     1                          
     2                          
     3                          
     4                          ;**************************************************************
     5                          ;*
     6                          ;*   SPRCOLOR - Set sprite multicolor registers
     7                          ;*
     8                          ;* syntax : SPRCOLOR [multicolor_1] [,multicolor_2]
     9                          ;*
    10                          ;**************************************************************
    11                          
    12                          sprcolor
    13  b806 c92c                                cmp #','                                 ; is there a first arg?
    14  b808 f006                                beq l294_1                               ; nope, skip to second
    15                          
    16  b80a 200db5                              jsr getnyb                               ; get 1 byte arg in .X, range 0-15
    17                          ; jsr put_io_in_map
    18  b80d 8e25d0                              stx vic+37
    19                          
    20  b810 202679             l294_1           jsr optbyt                               ; get (optional) 1 byte arg in .X
    21  b813 9006                                bcc l294_2
    22  b815 2010b5                              jsr chknyb                               ; range 0-15
    23                          ; jsr put_io_in_map
    24  b818 8e26d0                              stx vic+38
    25                          
    26  b81b 60                 l294_2           rts
    27                          
    28                          ;.end
    29                          
    30                          
    31                          
    32                          ;***************************************************************
    33                          ;  SPRSAV ( n1 / s1$ ) , ( n2 / s2$ )
    34                          ;   - move string(s1) or sprite(n1) to string(s2) or sprite(n2)
    35                          ;               n1 & n2 = a sprite number (1-8)
    36                          ;                   s1$ = a string variable or expression
    37                          ;                   s2$ = a string variable
    38                          ;***************************************************************
    39                          
    40  b81c 20a9b8             sprsav           jsr savinp                               ; evaluate 1st expression
    41  b81f b02f                                bcs l295_2                               ; skip if source is a string
    42  b821 854b                                sta forpnt
    43  b823 844c                                sty forpnt+1                             ; save sprite address
    44  b825 a03e                                ldy #62
    45                          
    46  b827 b14b               l295_1           lda (forpnt),y                           ; move sprite def to save area
    47  b829 999111                              sta savram,y
    48  b82c 88                                  dey
    49  b82d 10f8                                bpl l295_1
    50                          
    51  b82f c8                                  iny                                      ; (0)
    52  b830 8cd111                              sty savram+64                            ; save sprite column length
    53  b833 8cd311                              sty savram+66                            ; save sprite row length
    54  b836 a917                                lda #23
    55  b838 8dd011                              sta savram+63
    56  b83b a914                                lda #20
    57  b83d 8dd211                              sta savram+65
    58  b840 a291                                ldx #<savram                             ; set ptr to start of sprite def
    59  b842 a011                                ldy #>savram
    60  b844 8670                                stx strng1                               ; **
    61  b846 8471                                sty strng1+1                             ; **
    62                          
    63  b848 a943                                lda #67                                  ; set sprite length including lengths
    64  b84a 20b75a                              jsr strlit_1                             ; **get string space, copy savram to it
    65  b84d 20c2b8                              jsr desc_free                            ; **free up temp descriptor
    66                          
    67  b850 8eff11             l295_2           stx savsiz                               ; save source length
    68  b853 8d0012                              sta savsiz+1
    69  b856 8c0112                              sty savsiz+2                             ; save source start address
    70                          
    71  b859 205b4e                              jsr chkcom                               ; check for a comma
    72  b85c a53d                                lda txtptr                               ; save basic text pointer
    73  b85e 8d0312                              sta sprtmp_1
    74  b861 a53e                                lda txtptr+1
    75  b863 8d0412                              sta sprtmp_2
    76  b866 20a9b8                              jsr savinp                               ; get next destination parameter
    77  b869 b022                                bcs savs50                               ; skip if string
    78                          
    79  b86b 8587                                sta grapnt
    80  b86d 8488                                sty grapnt+1                             ; save sprite address
    81  b86f ad0012                              lda savsiz+1
    82  b872 854b                                sta forpnt                               ; get source address
    83  b874 ad0112                              lda savsiz+2
    84  b877 854c                                sta forpnt+1
    85  b879 a000                                ldy #0
    86  b87b ccff11             l295_3           cpy savsiz                               ; test index vs source length
    87  b87e f00c                                beq l295_4                               ; exit if source depleted
    88  b880 a94b                                lda #forpnt                              ; move source byte to sprite
    89  b882 20d722                              jsr lda_far_ram1                         ; (from ram bank 1)
    90                          ; sta sw_rom_ram0
    91  b885 9187                                sta (grapnt),y                           ; (to sprite area in bank 0)????
    92  b887 c8                                  iny
    93  b888 c03f                                cpy #63
    94  b88a d0ef                                bne l295_3
    95  b88c 60                 l295_4           rts
    96                          
    97                          
    98  b88d ad0312             savs50           lda sprtmp_1                             ; restore basic text pointer
    99  b890 853d                                sta txtptr
   100  b892 ad0412                              lda sprtmp_2
   101  b895 853e                                sta txtptr+1
   102  b897 207c4f                              jsr ptrget                               ; get symbol table descriptor for string dest.
   103  b89a 854b                                sta forpnt
   104  b89c 844c                                sty forpnt+1                             ; save symbol table address
   105  b89e a9ff                                lda #<savsiz
   106  b8a0 8566                                sta facmo                                ; save descriptor address of source
   107  b8a2 a911                                lda #>savsiz
   108  b8a4 8567                                sta facmo+1
   109  b8a6 830d7e                              +lbra inpcom                             ; move source to dest, do rts (snerr if not eol)
   110                          
   111                          
   112  b8a9 20ef4c             savinp           jsr frmevl                               ; evaluate expression
   113  b8ac ff0f13                              bbs7 valtyp,desc_free                    ; exit if a string
   114  b8af 206f5d                              jsr conint                               ; get one byte integer in .X
   115                          ; dex    ;adjust sprite 1..8 to 0..7  [910220]
   116  b8b2 e008                                cpx #8
   117  b8b4 b34899                              +lbcs fcerr                              ; bad value
   118  b8b7 8a                                  txa                                      ; move sprite number to .A
   119  b8b8 4a                                  lsr
   120  b8b9 6a                                  ror
   121  b8ba 6a                                  ror                                      ; get sprite address
   122  b8bb a006                                ldy #>sprite_base
   123  b8bd 9001                                bcc l296_1
   124  b8bf c8                                  iny
   125  b8c0 18                 l296_1           clc                                      ; flag 'sprite' (as opposed to 'string')
   126  b8c1 60                                  rts
   127                          
   128                          
   129                          desc_free                                                 ; free temporary descriptor, set up pointers to string.
   130  b8c2 a566                                lda facmo                                ; get address of temp descriptor
   131  b8c4 a467                                ldy facmo+1
   132  b8c6 20cc5b                              jsr fretms
   133  b8c9 a000                                ldy #0                                   ; get len, addr of string
   134  b8cb 20a922                              jsr indfmo
   135  b8ce aa                                  tax
   136  b8cf c8                                  iny
   137  b8d0 20a922                              jsr indfmo
   138  b8d3 48                                  pha
   139  b8d4 c8                                  iny
   140  b8d5 20a922                              jsr indfmo
   141  b8d8 a8                                  tay
   142  b8d9 68                                  pla
   143  b8da 38                                  sec                                      ; flag 'string found'
   144  b8db 60                                  rts                                      ; return w/ x=len, (a,y)==> string
   145                          

; ******** Source: basic.asm

; ******** Source: command/collision.asm
     1                          
     2                          
     3                          
     4                          ;*****************************************************************
     5                          ; COLLISION Command
     6                          ;
     7                          ; Syntax:  COLLISION n [,address]
     8                          ;
     9                          ; Where:   n= 1 ==> sprite / sprite
    10                          ;   2 ==> sprite / background
    11                          ;   3 ==> light pen
    12                          ;
    13                          ; Address ==> BASIC line number to trap to on interrupt
    14                          ;      (no address ==> disable trapping)
    15                          ;*****************************************************************
    16                          
    17                          collision
    18  b8dc 206c5d                              jsr getbyt                               ; get type in .X
    19  b8df ca                                  dex                                      ; adjust 1..3 to 0..2
    20  b8e0 e003                                cpx #3
    21  b8e2 b31a99                              +lbcs fcerr                              ; value error
    22                          
    23  b8e5 da                                  phx                                      ; save collision type
    24  b8e6 20f278                              jsr optwrd                               ; get address (line number) in .Y,.A (optional)
    25  b8e9 fa                                  plx
    26                          ; php   ;save .C (.C == 1 ==> real value)
    27  b8ea 9de302                              sta int_adr_hi,x                         ; save address given
    28  b8ed 8be002                              sty int_adr_lo,x
    29                          
    30  b8f0 addc02                              lda intval                               ; this records valid interrupts
    31  b8f3 1d6579                              ora sbits,x                              ; set correct bit
    32                          ; plp
    33  b8f6 b003                                bcs l297_1                               ; ..unless this is a 'clear',
    34  b8f8 5d6579                              eor sbits,x                              ; ..in which case we'll reset bit
    35  b8fb 8ddc02             l297_1           sta intval
    36  b8fe 60                                  rts
    37                          

; ******** Source: basic.asm

; ******** Source: function/rcolor.asm
     1                          
     2                          
     3                          
     4                          ;************************************************************************
     5                          ;  RCOLOR (source)  --  return current color assigned to source
     6                          ;   0  :  Background color
     7                          ;   1  :  Foreground color
     8                          ;   2  :  Highlight color
     9                          ;   3  :  Border color
    10                          ;************************************************************************
    11                          
    12  b8ff 206f5d             rcolor           jsr conint                               ; evaluate integer argument, put in .X
    13                          ; jsr put_io_in_map
    14                          
    15  b902 e004                                cpx #4
    16  b904 b3f898                              +lbcs fcerr                              ; illegal qty
    17  b907 8a                                  txa
    18  b908 0a                                  asl                                      ; make into word pointer
    19  b909 aa                                  tax
    20  b90a bd1eb9                              lda color_source,x                       ; get address of source
    21  b90d 8587                                sta grapnt
    22  b90f bd1fb9                              lda color_source+1,x
    23  b912 8588                                sta grapnt+1
    24  b914 a000                                ldy #0
    25  b916 b187                                lda (grapnt),y                           ; read source (aways system space or I/O????)
    26  b918 290f                                and #$0f                                 ; mask unused bits
    27  b91a a8                                  tay
    28                          ; iny   ; make color match keytops
    29  b91b 83b59f                              +lbra sngflt                             ; float 1 byte in .Y
    30                          
    31                          color_source
    32  b91e 21d0f100d80220d0                    !word vic+33,_color,highlight_color,vic+32

; ******** Source: basic.asm

; ******** Source: function/rgraphic.asm
     1                          
     2                          
     3                          
     4                          ; Return graphic screen status & parameters      [910826]
     5                          ; RGRAPHIC (screen, param) where param = 0 open (1), closed (0), or invalid (>1)
     6                          ;            1 width  (0=320, 1=640, 2=1280)
     7                          ;            2 height (0=200, 1=400)
     8                          ;            3 depth (1-8 bitplanes)
     9                          ;            4 bitplanes used  (bitmask)
    10                          ;            5 bank A blocks used (bitmask)
    11                          ;            6 bank B blocks used (bitmask)
    12                          ;            7 drawscreen # (0-3)
    13                          ;            8 viewscreen # (0-3)
    14                          ;            9 drawmodes  (bitmask)
    15                          ;           10 pattern type  (bitmask)
    16                          ;
    17                          ; Requires a kludge, because RGR used to be a normal 1-arg function in the C128
    18                          ; but now it takes two args.
    19                          
    20                          rgraphic
    21                          ; jsr CheckGraphicMode ;verify screen open
    22  b926 68                                  pla                                      ; remove token from stack
    23  b927 20e8b9                              jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820]
    24                          
    25  b92a 20584e                              jsr chkopn                               ; check for open paren
    26  b92d 206c5d                              jsr getbyt                               ; get screen # in .X
    27  b930 8e001f                              stx GKI__parm1
    28  b933 20825d                              jsr combyt                               ; get param # in .X
    29  b936 e00b                                cpx #10+1                                ; [911028]
    30  b938 b007                                bcs l298_1                               ; illegal param #
    31  b93a da                                  phx
    32  b93b 20554e                              jsr chkcls                               ; check for closing parens
    33                          
    34  b93e 223880                              jsr ($8038)                              ; read screen params
    35  b941 b3bb98             l298_1           +lbcs fcerr                              ; bad input????
    36                          
    37  b944 ad011f                              lda GKI__parm2
    38  b947 fa                                  plx                                      ; get back desired param #
    39  b948 ca                                  dex
    40  b949 1006                                bpl l298_2
    41  b94b 4980                                eor #$80                                 ; make 0=closed, 1=open, >1=invalid
    42  b94d 4a                                  lsr
    43  b94e 4a                                  lsr
    44  b94f 8003                                bra l298_3                               ; return screen open status
    45                          
    46  b951 ca                 l298_2           dex
    47  b952 1008                                bpl l298_5
    48  b954 4a                 l298_3           lsr
    49  b955 4a                 l298_4           lsr
    50  b956 4a                                  lsr
    51  b957 4a                                  lsr
    52  b958 2903                                and #3
    53  b95a 8012                                bra l298_8                               ; return width, height
    54                          
    55  b95c ca                 l298_5           dex
    56  b95d 1004                                bpl l298_6
    57  b95f 2908                                and #8
    58  b961 80f2                                bra l298_4
    59  b963 ca                 l298_6           dex
    60  b964 1005                                bpl l298_7
    61  b966 2907                                and #7                                   ; return depth
    62  b968 1a                                  inc                                      ; make depth 1-8
    63  b969 8003                                bra l298_8
    64                          
    65  b96b bd021f             l298_7           lda GKI__parm3,x                         ; return bp bask, banks, etc.
    66  b96e a8                 l298_8           tay
    67  b96f 20d258                              jsr sngflt                               ; float 1 byte arg in .y
    68                          
    69  b972 20f9b9                              jsr PopParms                             ; restore Graphics parameters & LINNUM
    70  b975 60                                  rts

; ******** Source: basic.asm

; ******** Source: function/pixel.asm
     1                          
     2                          ; Return the color of a given X,Y pixel location on the drawscreen  [910801]
     3                          ;  PIXEL (x,y)
     4                          
     5  b976 201caf             pixel            jsr CheckGraphicMode                     ; verify screen open
     6  b979 20e8b9                              jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820]
     7                          
     8  b97c 20925d                              jsr getsad                               ; get x
     9  b97f 8c001f                              sty GKI__parm1
    10  b982 8d011f                              sta GKI__parm2
    11  b985 200879                              jsr comsad                               ; get y
    12  b988 8c021f                              sty GKI__parm3
    13  b98b 8d031f                              sta GKI__parm4
    14  b98e 20554e                              jsr chkcls                               ; check for closing parens
    15                          
    16  b991 223280                              jsr ($8032)                              ; get Bitplane data at pixel (x,y), returned in .y
    17  b994 20d258                              jsr sngflt                               ; go float 1 byte arg in .Y
    18                          
    19  b997 20f9b9                              jsr PopParms                             ; restore graphics parameters
    20  b99a 60                                  rts

; ******** Source: basic.asm

; ******** Source: function/rpen.asm
     1                          
     2                          ; Return the color of a drawscreen's PEN      [910820]
     3                          ;  RPEN (pen#) where pen# = 0,1,2
     4                          
     5  b99b 201caf             rpen             jsr CheckGraphicMode                     ; verify screen open
     6  b99e 20e8b9                              jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820]
     7                          
     8  b9a1 206f5d                              jsr conint                               ; get 1 byte arg in .x (old style single arg function)
     9  b9a4 e003                                cpx #3
    10  b9a6 b006                                bcs l299_1                               ; illegal pen #?
    11  b9a8 8e001f                              stx GKI__parm1
    12                          
    13  b9ab 223680                              jsr ($8036)                              ; convert to logical color# (palette index#)
    14  b9ae b34e98             l299_1           +lbcs fcerr                              ; drawscreen not set or illegal quantity somewhere
    15                          
    16  b9b1 20d258                              jsr sngflt                               ; go float 1 byte arg in .Y
    17                          
    18  b9b4 20f9b9                              jsr PopParms                             ; restore graphics parameters
    19  b9b7 60                                  rts
    20                          

; ******** Source: basic.asm

; ******** Source: function/rpalette.asm
     1                          ; Return the R,G, or B component of a color     [910820]
     2                          ; RPALETTE (screen#, color#, rgb)
     3                          
     4                          rpalette
     5  b9b8 201caf                              jsr CheckGraphicMode                     ; verify screen open
     6  b9bb 20e8b9                              jsr PushParms                            ; Save graphics parameters
     7                          
     8  b9be 206f5d                              jsr conint                               ; get screen# in .x
     9  b9c1 e004                                cpx #4
    10  b9c3 b013                                bcs l300_1                               ; illegal screen#
    11  b9c5 8e001f                              stx GKI__parm1
    12                          
    13  b9c8 20825d                              jsr combyt                               ; get color# in .x ????check for legal color#
    14  b9cb 8e011f                              stx GKI__parm2
    15                          
    16  b9ce 223480                              jsr ($8034)                              ; get RGB components of color# in PARM3,4,5
    17  b9d1 b005                                bcs l300_1                               ; something is wrong????
    18                          
    19  b9d3 20825d                              jsr combyt                               ; get r,g,b component#
    20  b9d6 e003                                cpx #3
    21  b9d8 b32498             l300_1           +lbcs fcerr                              ; illegal value
    22                          
    23  b9db bc021f                              ldy GKI__parm3,x                         ; get r,g,b value
    24  b9de 20d258                              jsr sngflt                               ; float 1 byte arg in .y
    25                          
    26  b9e1 20554e                              jsr chkcls                               ; check for closing paren
    27  b9e4 20f9b9                              jsr PopParms                             ; restore graphics parameters
    28  b9e7 60                                  rts
    29                          
    30                          
    31                          PushParms                                                 ; [910820]
    32  b9e8 7a                                  ply                                      ; Grab return address
    33  b9e9 fb                                  plz
    34                          
    35  b9ea fc1600                              phw linnum                               ; Save 'poker' value
    36                          
    37  b9ed a210                                ldx #17-1
    38  b9ef bd001f             l301_1           lda GKI__parm1,x                         ; Save Graphics parameters
    39  b9f2 48                                  pha                                      ; [eg: CHAR x,y,1,1,2,str$(PIXEL(x,y))]
    40  b9f3 ca                                  dex
    41  b9f4 10f9                                bpl l301_1
    42                          
    43  b9f6 db                                  phz                                      ; Restore return address
    44  b9f7 5a                                  phy
    45  b9f8 60                                  rts
    46                          
    47                          
    48                          PopParms                                                  ; [910820]
    49  b9f9 7a                                  ply                                      ; Grab return address
    50  b9fa fb                                  plz
    51                          
    52  b9fb a200                                ldx #0
    53  b9fd 68                 l302_1           pla                                      ; Restore Graphics parameters
    54  b9fe 9d001f                              sta GKI__parm1,x
    55  ba01 e8                                  inx
    56  ba02 e011                                cpx #17
    57  ba04 90f7                                bcc l302_1
    58                          
    59  ba06 68                                  pla                                      ; Restore 'poker' value
    60  ba07 8517                                sta linnum+1
    61  ba09 68                                  pla
    62  ba0a 8516                                sta linnum
    63                          
    64  ba0c db                                  phz                                      ; Restore return address
    65  ba0d 5a                                  phy
    66  ba0e 60                                  rts
    67                          

; ******** Source: basic.asm

; ******** Source: function/rsprite.asm
     1                          
     2                          
     3                          
     4                          ;******************************************************************
     5                          ;* RSPRITE - Return sprite information
     6                          ;*
     7                          ;* Syntax : RSPRITE (sprite_number, argument)
     8                          ;*
     9                          ;* Where  : sprite_number = [0..7]
    10                          ;*   argument = [0..5]
    11                          ;*   0 : enabled?   (y(1)/n(0))
    12                          ;*   1 : color?     (0-15)
    13                          ;*   2 : priority over background? (y(1)/n(0))
    14                          ;*   3 : expand in x direction? (y(1)/n(0))
    15                          ;*   4 : expand in Y direction? (y(1)/n(0))
    16                          ;*   5 : multicolor sprite?  (y(1)/n(0))
    17                          ;******************************************************************
    18                          
    19  ba0f 206f5d             rsprite          jsr conint                               ; get first arg, sprite #, in .X
    20                          ; dex  ;adjust [1..8] to [0..7]   [910220]
    21  ba12 e008                                cpx #8  ; (318018-03 mod                 ; fab)
    22  ba14 b00a                                bcs l303_1                               ; value error
    23  ba16 8a                                  txa
    24  ba17 48                                  pha                                      ; save sprite number
    25                          
    26                          ; jsr chkcom ;check for proper delimiter
    27                          ; jsr getbyt ;do frmevl, get 1 byte arg (arg) in .X
    28  ba18 20825d                              jsr combyt                               ; [910820]
    29  ba1b 20554e                              jsr chkcls                               ; look for closing paren
    30  ba1e e006                                cpx #6
    31  ba20 b3dc97             l303_1           +lbcs fcerr                              ; value error
    32                          
    33  ba23 7a                                  ply                                      ; sprite number
    34                          ; jsr put_io_in_map
    35  ba24 b927d0                              lda vic+39,y                             ; assume 'color'
    36  ba27 290f                                and #$0f                                 ; range 0-15
    37                          ; inc a  ;adjust to 'keyboard' colors   [910724]
    38  ba29 e001                                cpx #1
    39  ba2b f00e                                beq l303_2                               ; it was color. set up for float
    40                          
    41  ba2d bd3fba                              lda rspmod,x                             ; get index for this function
    42  ba30 aa                                  tax
    43  ba31 b96579                              lda sbits,y                              ; get mask for this sprite number
    44  ba34 3d00d0                              and vic,x
    45  ba37 f002                                beq l303_2
    46  ba39 a901                                lda #1                                   ; return all non-zeros as '1'
    47                          
    48  ba3b a8                 l303_2           tay
    49  ba3c 83949e                              +lbra sngflt                             ; go float 1 byte arg in .Y
    50                          
    51                          
    52  ba3f 15271b1d171c       rspmod           !text 21,39,27,29,23,28                  ; VIC registers associated with arg#
    53                          
    54                          ;.end
    55                          
    56                          
    57                          
    58                          ;******************************************************************
    59                          ;* RSPCOLOR - return sprite multicolor reg's
    60                          ;*
    61                          ;* Syntax : RSPCOLOR (argument)
    62                          ;*
    63                          ;* Where  : argument = [1..2]
    64                          ;*   1 : return multicolor #1
    65                          ;*   2 : return multicolor #2
    66                          ;******************************************************************
    67                          
    68                          rspcolor
    69  ba45 20554e                              jsr chkcls                               ; check for closing paren
    70  ba48 206f5d                              jsr conint                               ; get arg in .X
    71  ba4b ca                                  dex                                      ; adjust [1..2] to [0..1
    72  ba4c e002                                cpx #2
    73  ba4e b3ae97                              +lbcs fcerr                              ; value error
    74                          
    75                          ; jsr put_io_in_map
    76  ba51 bd25d0                              lda vic+37,x
    77  ba54 290f                                and #$0f
    78  ba56 a8                                  tay
    79                          ; iny  ;range 0-15     [910724]
    80  ba57 83799e                              +lbra sngflt                             ; float 1 byte arg in .Y
    81                          

; ******** Source: basic.asm

; ******** Source: function/rsppos.asm
     1                          
     2                          
     3                          
     4                          ;******************************************************************
     5                          ;* RSPPOS - Return sprite location / speed data
     6                          ;*
     7                          ;* Syntax:  RSPPOS (sprite_number, argument)
     8                          ;*
     9                          ;* Where:   sprite_number = [0..7]
    10                          ;*    argument = [0..2]
    11                          ;*   0 : return X position
    12                          ;*   1 : return Y position
    13                          ;*   2 : return current speed
    14                          ;******************************************************************
    15                          
    16  ba5a 206f5d             rsppos           jsr conint                               ; get first arg, sprite #, in .X
    17                          ; dex  ;adjust [1..8] to [0..7]   [910220]
    18  ba5d e008                                cpx #8  ; (318018-03 mod                 ; fab)
    19  ba5f b009                                bcs l304_1                               ; value error
    20                          
    21  ba61 da                                  phx                                      ; save sprite number
    22                          ; jsr chkcom ;check for proper delimiter
    23                          ; jsr getbyt ;do frmevl, get 1 byte arg (arg) in .X
    24  ba62 20825d                              jsr combyt                               ; [910820]
    25  ba65 20554e                              jsr chkcls                               ; look for closing paren
    26  ba68 e003                                cpx #3
    27  ba6a b39297             l304_1           +lbcs fcerr                              ; value error
    28                          
    29  ba6d 7a                                  ply                                      ; sprite number
    30  ba6e e002                                cpx #2
    31  ba70 d009                                bne l304_2                               ; branch if x or y position
    32                          
    33  ba72 befeb7                              ldx sproff,y                             ; get offset into speed data
    34  ba75 bc0512                              ldy sprite_data,x                        ; get speed data
    35  ba78 83589e                              +lbra sngflt                             ; go float 1 byte arg in .Y
    36                          
    37                          ; Get msb of sprite position (in case this is for x position)
    38                          
    39  ba7b 78                 l304_2           sei
    40  ba7c b96579                              lda sbits,y                              ; get bit mask for this sprite
    41  ba7f 2d10d0                              and vic+16                               ; ???vic_save
    42  ba82 f002                                beq l304_3
    43  ba84 a901                                lda #1                                   ; change any non-zero to a '1'
    44  ba86 48                 l304_3           pha                                      ; save msb
    45                          
    46  ba87 98                                  tya                                      ; y = sprite# * 2
    47  ba88 0a                                  asl
    48  ba89 a8                                  tay
    49  ba8a 8a                                  txa                                      ; see if this is y position
    50  ba8b 4a                                  lsr                                      ; .C = 0 for x pos'n, 1 for y pos'n
    51  ba8c 9005                                bcc l304_4                               ; branch if x pos'n
    52                          
    53  ba8e c8                                  iny                                      ; adjust pointer to point to y pos'n in register data
    54  ba8f 68                                  pla
    55  ba90 a900                                lda #0                                   ; ..and force 'msb' to be zero
    56  ba92 48                                  pha
    57                          
    58  ba93 b900d0             l304_4           lda vic,y                                ; get correct location lsb   ???vic_save
    59  ba96 58                                  cli
    60  ba97 a8                                  tay
    61  ba98 68                                  pla                                      ; ..and get msb,
    62  ba99 832c9e                              +lbra nosflt                             ; ..and go float 2 byte value in y,a
    63                          

; ******** Source: basic.asm

; ******** Source: function/bump.asm
     1                          
     2                          
     3                          
     4                          ;******************************************************************
     5                          ;* BUMP - read sprite collision
     6                          ;*
     7                          ;* Syntax : BUMP (argument)
     8                          ;*
     9                          ;* Where  : argument = [1..2]
    10                          ;*   1 : sprite/sprite collision
    11                          ;*   2 : sprite/background collision
    12                          ;******************************************************************
    13                          
    14  ba9c 20554e             bump             jsr chkcls
    15  ba9f 206f5d                              jsr conint                               ; get arg in .X
    16  baa2 ca                                  dex                                      ; adjust [1..2] to [0..1]
    17  baa3 e002                                cpx #2
    18  baa5 b35797                              +lbcs fcerr                              ; value error
    19                          
    20  baa8 78                                  sei
    21  baa9 bce602                              ldy collisions,x                         ; get recorded collisions
    22  baac a900                                lda #0                                   ; reset them
    23  baae 9de602                              sta collisions,x
    24  bab1 58                                  cli
    25  bab2 831e9e                              +lbra sngflt                             ; float 1 byte arg in .Y
    26                          
    27                          ;.end
    28                          
    29                          
    30                          
    31                          ; GRAPHIC3.SRC
    32                          ;****************************************************************
    33                          ;  getang  -  set cosine & sine values
    34                          ;             results in sinval & cosval based as a fraction
    35                          ;             - over 65536
    36                          ;             angsgn = angle phase (0-3)
    37                          ;    on input vwork+y = 2 byte angle
    38                          ;***************************************************************
    39                          
    40                          getang
    41  bab5 2075bb                              jsr settwo                               ; move angle value into y/a
    42                          
    43  bab8 a200               gtang1           ldx #0                                   ; init count of phase
    44                          
    45  baba e8                 l305_1           inx
    46  babb 38                                  sec
    47  babc e95a                                sbc #90                                  ; subtract 90 until less than 0
    48  babe b0fa                                bcs l305_1
    49  bac0 88                                  dey
    50  bac1 10f7                                bpl l305_1
    51  bac3 8efa11                              stx angsgn                               ; save phase (here it is 1-4)
    52  bac6 48                                  pha
    53  bac7 695a                                adc #90                                  ; make positive
    54  bac9 20d5ba                              jsr l305_2                               ; do division by 10
    55  bacc 68                                  pla                                      ; get 2's comp of angle
    56  bacd 18                                  clc
    57  bace 49ff                                eor #$ff
    58  bad0 6901                                adc #1                                   ; make positive
    59  bad2 cefa11                              dec angsgn                               ; correct phase
    60                          
    61  bad5 a2ff               l305_2           ldx #$ff
    62  bad7 e8                 l305_3           inx                                      ; do division by 10
    63  bad8 38                                  sec
    64  bad9 e90a                                sbc #10
    65  badb b0fa                                bcs l305_3
    66  badd 690a                                adc #10                                  ; make positive
    67  badf 8df511                              sta vtemp1                               ; save remainder
    68  bae2 8a                                  txa
    69  bae3 0a                                  asl                                      ; get quotient*2 as index
    70  bae4 aa                                  tax
    71  bae5 bda2bc                              lda angval+1,x                           ; get low byte base
    72  bae8 bca1bc                              ldy angval,x                             ; get high byte value
    73                          
    74  baeb 18                 l305_4           clc
    75  baec cef511                              dec vtemp1
    76  baef 300c                                bmi l305_5                               ; done - remainder = 0
    77  baf1 7db6bc                              adc incval+1,x                           ; add low byte increment
    78  baf4 48                                  pha
    79  baf5 98                                  tya
    80  baf6 7db5bc                              adc incval,x                             ; add high byte increment
    81  baf9 a8                                  tay
    82  bafa 68                                  pla
    83  bafb 90ee                                bcc l305_4                               ; ...always
    84                          
    85  bafd 48                 l305_5           pha                                      ; save low byte of result
    86  bafe a200                                ldx #0                                   ; point to sinval
    87  bb00 adfa11                              lda angsgn
    88  bb03 4a                                  lsr
    89  bb04 b002                                bcs l305_6                               ; skip if sine value
    90  bb06 a202                                ldx #2                                   ; point to cosval
    91                          
    92  bb08 68                 l305_6           pla
    93  bb09 9dfb11                              sta sinval,x                             ; save low byte result
    94  bb0c 98                                  tya
    95  bb0d 9dfc11                              sta sinval+1,x                           ; save high byte result
    96  bb10 60                                  rts
    97                          
    98                          
    99                          ;*************************************************************
   100                          ;  angmlt  -  multiple 2-byte integer times angle
   101                          ;       carry set/reset = cosine/sine
   102                          ;
   103                          ;       vwork+x = 2-byte integer
   104                          ;       result left in y/a
   105                          ;*************************************************************
   106                          
   107                          angmlt
   108  bb11 a00f                                ldy #sinval-vwork                        ; get offset to angle value
   109  bb13 9002                                bcc l306_1                               ; get cosine/sine offset
   110  bb15 a011                                ldy #cosval-vwork
   111                          
   112  bb17 adfa11             l306_1           lda angsgn
   113  bb1a 6902                                adc #2                                   ; correct phase for cosine to look as sine
   114  bb1c 4a                                  lsr
   115  bb1d 4a                                  lsr
   116  bb1e 08                                  php                                      ; save if carry - means negative angle value
   117  bb1f 2075bb                              jsr settwo                               ; get angle fraction in y/a
   118  bb22 c0ff                                cpy #$ff                                 ; test if value should be 1
   119  bb24 9007                                bcc l306_2                               ; skip if not
   120  bb26 8a                                  txa
   121  bb27 a8                                  tay                                      ; get offset to integer
   122  bb28 2075bb                              jsr settwo                               ; just get integer - multiplied by 1
   123  bb2b b003                                bcs l306_3
   124                          
   125  bb2d 2094bb             l306_2           jsr twobyt                               ; multiply integer times angle value
   126  bb30 28                 l306_3           plp                                      ; get sign of angle
   127  bb31 9051                                bcc invert                               ; invert result if negative,do rts
   128  bb33 60                                  rts
   129                          
   130                          
   131                          ;*************************************************************
   132                          ;  angdst  -  set up values for distance * angles
   133                          ;       vwork+x = x & y distances
   134                          ;       a = angles : ang1,ang2,ang3,ang4,0,0,0,0
   135                          ;       get  xdist1 = xdist1 * angle-1
   136                          ;     ydist1 = ydist1 * angle-2
   137                          ;     xdist2 = xdist2 * angle-3
   138                          ;     ydist2 = ydist2 * angle-4
   139                          ;*************************************************************
   140                          ;
   141                          ;angdst
   142                          ; sta angcnt      ;save angles
   143                          ; ldx #xdist1-vwork
   144                          ;angd10
   145                          ; asl angcnt
   146                          ; jsr angmlt      ;multiply angle * distance
   147                          ; sta vwork,x
   148                          ; tya  ;save results
   149                          ; sta vwork+1,x
   150                          ; inx  ;point to next distance
   151                          ; inx
   152                          ; cpx #disend-vwork
   153                          ; bcc angd10 ;loop 4 times
   154                          ;angd20 rts
   155                          
   156                          ;.end
   157                          
   158                          ; GRAPHIC8.SRC
   159                          ;****************************************************************
   160                          ;  docolr  --  set up color for 8x8 charcater cell
   161                          ;   x = row number  --  y = column number
   162                          ;****************************************************************
   163                          ;
   164                          ;docolr lda _ldtb2,x      ;put address of video ram into grapnt
   165                          ; sta grapnt
   166                          ; lda graphic_ldtb1,x ;point to bit mapped color area
   167                          ; sta grapnt+1
   168                          ;
   169                          ; lda colsel  ;get current color source selected
   170                          ;
   171                          ; bne l306_1   ;branch if NOT background
   172                          ; lda fg_bg
   173                          ; bit _graphm  ;test if mode = hires
   174                          ; bpl 25$   ;if so, go set up byte
   175                          ; rts   ;else exit
   176                          ;
   177                          ;l306_1 cmp #2
   178                          ; bne l306_3   ;branch if NOT multi-color 1
   179                          ;
   180                          ;l306_2 lda fg_mc1  ;get correct packed colors for multicolor mode.
   181                          ;25$ and #$0f
   182                          ; sta z_p_temp_1
   183                          ; lda (grapnt),y
   184                          ; and #$f0
   185                          ; ora z_p_temp_1
   186                          ; sta (grapnt),y
   187                          ; rts
   188                          ;
   189                          ;l306_3 bcs 40$   ;branch if multicolor 2
   190                          ;
   191                          ; lda fg_bg  ;here for foreground. get packed colors.
   192                          ; and #$f0
   193                          ; sta z_p_temp_1
   194                          ; lda (grapnt),y  ;do foreground
   195                          ; and #$0f
   196                          ; ora z_p_temp_1
   197                          ; sta (grapnt),y
   198                          ; rts
   199                          ;
   200                          ;40$ lda grapnt+1  ;do multicolor 2
   201                          ; and #3
   202                          ; ora #>color_ram_hi ;set up to point to high color area
   203                          ; sta grapnt+1
   204                          ;
   205                          ; lda #0   ;put i/o in map
   206                          ; sta mmu_config_reg
   207                          ;
   208                          ; sei
   209                          ; lda _6510_data_reg
   210                          ; pha
   211                          ; and #%11111110  ;point cpu at correct nybble bank
   212                          ; sta _6510_data_reg
   213                          ; lda multicolor_2
   214                          ; sta (grapnt),y
   215                          ; pla
   216                          ; sta _6510_data_reg
   217                          ; cli
   218                          ; rts
   219                          ;
   220                          ;
   221                          ;
   222                          ;graphic_ldtb1   ;_ldtb1 adjusted for an org at color_ram_lo
   223                          ;99$=color_ram_lo
   224                          ;1$=color_ram_lo+40*1
   225                          ;2$=color_ram_lo+40*2
   226                          ;3$=color_ram_lo+40*3
   227                          ;4$=color_ram_lo+40*4
   228                          ;5$=color_ram_lo+40*5
   229                          ;6$=color_ram_lo+40*6
   230                          ;7$=color_ram_lo+40*7
   231                          ;8$=color_ram_lo+40*8
   232                          ;9$=color_ram_lo+40*9
   233                          ;l306_1=color_ram_lo+40*10
   234                          ;11$=color_ram_lo+40*11
   235                          ;12$=color_ram_lo+40*12
   236                          ;13$=color_ram_lo+40*13
   237                          ;14$=color_ram_lo+40*14
   238                          ;15$=color_ram_lo+40*15
   239                          ;16$=color_ram_lo+40*16
   240                          ;17$=color_ram_lo+40*17
   241                          ;18$=color_ram_lo+40*18
   242                          ;19$=color_ram_lo+40*19
   243                          ;l306_2=color_ram_lo+40*20
   244                          ;21$=color_ram_lo+40*21
   245                          ;22$=color_ram_lo+40*22
   246                          ;23$=color_ram_lo+40*23
   247                          ;24$=color_ram_lo+40*24
   248                          ;
   249                          ; .byte >99$,>1$,>2$,>3$,>4$,>5$,>6$,>7$,>8$,>9$,>l306_1
   250                          ; .byte >11$,>12$,>13$,>14$,>15$,>16$,>17$,>18$,>19$
   251                          ; .byte >l306_2,>21$,>22$,>23$,>24$
   252                          
   253                          
   254                          ;******************************************************************
   255                          ;  getpos - get address in graphic bit map into grapnt
   256                          ;      x = bit offset into byte specified (0-7)
   257                          ;      y = offset to byte within 8x8 character cell
   258                          ;      a = bit mask to the bit (or bits if multicolor mode)
   259                          ;******************************************************************
   260                          ;
   261                          ;getpos jsr divpos      ;get xpos/ypos to column/row position
   262                          ; bcs grprts      ;abort if position too large
   263                          ;
   264                          ;getps1 tya  ;get addr for row (X) and col (Y) in grapnt
   265                          ; clc
   266                          ; adc _ldtb2,x ;add column position to low byte offset
   267                          ; sta grapnt
   268                          ; lda _ldtb1,x ;get high byte screen address
   269                          ; adc #0  ;add any carry
   270                          ; asl grapnt
   271                          ; rol a
   272                          ; asl grapnt ;mult by 8 to get offset into 8k area
   273                          ; rol a
   274                          ; asl grapnt
   275                          ; rol a
   276                          ; sta grapnt+1
   277                          ;
   278                          ; lda ypos
   279                          ; and #07
   280                          ; tay  ;get byte offset into 8x8 char cell
   281                          ; lda xpos
   282                          ; bit _graphm
   283                          ; php
   284                          ; bpl grpos3 ;skip if not multicolor mode
   285                          ; asl a  ;shift x-pos for multicolor mode
   286                          ;
   287                          ;grpos3 and #07
   288                          ; tax
   289                          ; lda rbits,x ;get bit mask
   290                          ; plp
   291                          ; bpl grprts ;done if not multicolor mode
   292                          ; inx
   293                          ; ora rbits,x ;mask for 2 bits if multicolor mode
   294                          ;grprts rts
   295                          ;
   296                          ;rbits .byte   $80,$40,$20,$10,$08,$04,$02,$01
   297                          
   298                          
   299                          ;**************************************************************
   300                          ;  divpos  --  convert xpos to column number
   301                          ;  convert ypos to row number
   302                          ;  return carry set if either above limits
   303                          ;**************************************************************
   304                          ;
   305                          ;divpos lda xpos+1
   306                          ; lsr a
   307                          ; bne l306_2       ;out of bounds if greater than 1
   308                          ; lda xpos
   309                          ; ror a
   310                          ; lsr a  ;get column position = xpos/8
   311                          ; bit _graphm
   312                          ; bmi l306_1  ;skip if multicolor mode
   313                          ; lsr a  ;divide by 8 if a hires or text mode
   314                          ;l306_1 tay
   315                          ; cpy #llen
   316                          ; bcs l306_2  ;error exit if out of bounds
   317                          ; lda ypos+1
   318                          ; bne l306_2  ;out of bounds error if not = 0
   319                          ; lda ypos
   320                          ; lsr a
   321                          ; lsr a  ;get row number = ypos/8
   322                          ; lsr a
   323                          ; tax
   324                          ; cmp #nlines ;compare to max number of rows
   325                          ; rts  ;carry clr if okay
   326                          ;l306_2 sec
   327                          ; rts
   328                          
   329                          
   330                          ;***************************************************************
   331                          ;   SCALXY  - Scale the x & y coordinates found in vwork+x
   332                          ;***************************************************************
   333                          ;
   334                          ;scalxy lda scalem
   335                          ; beq sclrts      ;do nothing if scaling off
   336                          ;
   337                          ; lda scale_x
   338                          ; ldy scale_x+1
   339                          ; jsr doscal      ;scale in the x-direction
   340                          ;
   341                          ; lda scale_y
   342                          ; ldy scale_y+1 ;scale in the y direction
   343                          ;
   344                          ;doscal jsr twobyt ;multiply * coordinate
   345                          ; sta vwork,x
   346                          ; tya
   347                          ; inx  ;store back into original position
   348                          ; sta vwork,x
   349                          ; inx
   350                          ;sclrts
   351                          ; rts
   352                          
   353                          ;.end
   354                          
   355                          ;GRAPHICS9.SRC
   356                          ;***************************************************************
   357                          ;   DOTWO  - Add      two 2-byte values if carry clear
   358                          ;  Subtract two 2-byte values if carry set
   359                          ;***************************************************************
   360                          
   361                          dotwo2
   362  bb34 9007                                bcc addtw2                               ; go do addition
   363  bb36 b014                                bcs subtw2                               ; go do subtraction
   364                          dotwo
   365  bb38 b00f                                bcs subtwo                               ; go do subtraction
   366                          
   367                          ;***************************************************************
   368                          ;  ADDTWO  - Add vwork+y and vwork+x  Result in y/a
   369                          ;***************************************************************
   370                          
   371                          addtwo
   372  bb3a 2075bb                              jsr settwo                               ; put vwrok+y into y/a
   373                          
   374                          addtw2                                                    ; enter here to add y/a to vwork+x
   375  bb3d 18                                  clc
   376  bb3e 7dec11                              adc vwork,x
   377  bb41 48                                  pha
   378  bb42 98                                  tya
   379  bb43 7ded11                              adc vwork+1,x
   380  bb46 a8                                  tay
   381  bb47 68                                  pla
   382  bb48 60                                  rts
   383                          
   384                          
   385                          ;****************************************************************
   386                          ;  SUBTWO  - Subtract vwork+y - vwork+x Result in y/a
   387                          ;****************************************************************
   388                          
   389                          subtwo
   390  bb49 2075bb                              jsr settwo                               ; move vwork+y into y/a
   391                          
   392                          subtw2                                                    ; enter here with 1st value in y/a
   393  bb4c 38                                  sec
   394  bb4d fdec11                              sbc vwork,x
   395  bb50 8559                                sta tempf1
   396  bb52 98                                  tya
   397  bb53 fded11                              sbc vwork+1,x
   398  bb56 a8                                  tay
   399  bb57 08                                  php
   400  bb58 a559                                lda tempf1
   401  bb5a 28                                  plp
   402  bb5b 60                                  rts
   403                          
   404                          
   405                          subtwo_savram
   406  bb5c b99111                              lda savram,y                             ; load value into y,a
   407  bb5f 48                                  pha
   408  bb60 b99211                              lda savram+1,y
   409  bb63 a8                                  tay
   410  bb64 68                                  pla
   411  bb65 38                                  sec
   412  bb66 fd9111                              sbc savram,x
   413  bb69 8559                                sta tempf1
   414  bb6b 98                                  tya
   415  bb6c fd9211                              sbc savram+1,x
   416  bb6f a8                                  tay
   417  bb70 08                                  php
   418  bb71 a559                                lda tempf1
   419  bb73 28                                  plp
   420  bb74 60                                  rts
   421                          
   422                          
   423                          ;************************************************************
   424                          ;  SETTWO  - Move value in vwork+y into y/a
   425                          ;************************************************************
   426                          
   427                          settwo
   428  bb75 b9ec11                              lda vwork,y
   429  bb78 48                                  pha
   430  bb79 b9ed11                              lda vwork+1,y
   431  bb7c a8                                  tay
   432  bb7d 68                                  pla
   433  bb7e 60                                  rts
   434                          
   435                          ;******************************************************************
   436                          ;  ABSTWO  - Get absolute value of vwork+y - vwork+x
   437                          ;  Result in y/a  -  carry === vwork+y >= vwork+x
   438                          ;******************************************************************
   439                          
   440                          abstwo                                                    ; movspr_to [910809]
   441  bb7f 2049bb                              jsr subtwo                               ; subtract vwork+y - vwork+x
   442                          abstw2                                                    ; entrance with vwork+y in y/a
   443  bb82 100f                                bpl absrts                               ; done if result is positive
   444  bb84 08                 invert           php
   445  bb85 18                                  clc
   446  bb86 49ff                                eor #$ff                                 ; invert low byte result and add 1
   447  bb88 6901                                adc #1
   448  bb8a 48                                  pha
   449  bb8b 98                                  tya
   450  bb8c 49ff                                eor #$ff                                 ; invert high byte result
   451  bb8e 6900                                adc #0                                   ; add back any carry
   452  bb90 a8                                  tay
   453  bb91 68                                  pla
   454  bb92 28                                  plp
   455  bb93 60                 absrts           rts
   456                          
   457                          
   458                          ;****************************************************************
   459                          ;  TWOBYT  - Multiply 2 byte fraction in y/a times 2 bytes
   460                          ;  Integer found in vwork+x-reg.  Result = y/a
   461                          ;****************************************************************
   462                          
   463                          twobyt
   464  bb94 8cf511                              sty vtemp1                               ; save fraction
   465  bb97 8df611                              sta vtemp2
   466  bb9a bdec11                              lda vwork,x
   467  bb9d bced11                              ldy vwork+1,x
   468  bba0 08                                  php                                      ; save sign of integer
   469  bba1 2082bb                              jsr abstw2                               ; absolute value
   470  bba4 9dec11                              sta vwork,x
   471  bba7 98                                  tya
   472  bba8 9ded11                              sta vwork+1,x
   473  bbab a900                                lda #0
   474  bbad 8df711                              sta vtemp3                               ; initialize result to zero
   475                          
   476  bbb0 a010                                ldy #16                                  ; initialize count
   477  bbb2 4ef511             l307_1           lsr vtemp1
   478  bbb5 6ef611                              ror vtemp2
   479  bbb8 900f                                bcc l307_2                               ; skip if no bit set
   480  bbba 18                                  clc
   481  bbbb 7dec11                              adc vwork,x                              ; add integer low byte
   482  bbbe 48                                  pha
   483  bbbf adf711                              lda vtemp3
   484  bbc2 7ded11                              adc vwork+1,x                            ; add integer high byte to total
   485  bbc5 8df711                              sta vtemp3
   486  bbc8 68                                  pla
   487                          
   488  bbc9 4ef711             l307_2           lsr vtemp3                               ; divide by 2
   489  bbcc 6a                                  ror
   490  bbcd 88                                  dey
   491  bbce d0e2                                bne l307_1                               ; loop 16 times - test all bits in 2 bytes
   492                          
   493  bbd0 6900                                adc #0                                   ; add back round factor
   494  bbd2 acf711                              ldy vtemp3
   495  bbd5 9001                                bcc l307_3
   496  bbd7 c8                                  iny
   497  bbd8 28                 l307_3           plp                                      ; pop sign
   498  bbd9 80a7                                bra abstw2                               ; return with signed product in y/a
   499                          
   500                          
   501                          ;******************************************************************
   502                          ;  dstpos  -  move xdest/ydest to xpos/ypos
   503                          ;******************************************************************
   504                          ;
   505                          ;dstpos
   506                          ; ldy #0
   507                          ; jsr dstmov
   508                          ; ldy #2
   509                          ;dstmov
   510                          ; lda xdest,y
   511                          ; sta xpos,y
   512                          ; lda xdest+1,y
   513                          ; sta xpos+1,y
   514                          ; rts
   515                          
   516                          ;.end
   517                          
   518                          ;GRAPHICS10.SRC
   519                          ;************************************************************
   520                          ;   incolr  --  get color selection parameter into colsel
   521                          ;************************************************************
   522                          ;
   523                          ;incolr
   524                          ; ldx #1   ;get an optional 1 byte val, def=fg(1)
   525                          ; jsr chrgot
   526                          ;incol1
   527                          ; beq incol2       ;eol, use default
   528                          ; cmp #','
   529                          ; beq incol2       ;just ',', use default
   530                          ; jsr getbyt
   531                          ; cpx #4   ;must be 0-3
   532                          ; bcs illval       ;..else illegal value
   533                          ; cpx #2
   534                          ; bit _graphm       ;if hires, must be 0 or 1
   535                          ; bmi incol2
   536                          ; bcs illval
   537                          ;incol2
   538                          ; stx colsel
   539                          ; rts
   540                          ;
   541                          ;illval
   542                          ; jmp fcerr  ;illegal value
   543                          
   544                          
   545                          
   546                          ;******************************************************************
   547                          ;  INCORD  ---  Get X,Y coordinate from input stream into vwork+x
   548                          ;
   549                          ;  Coordinate may have any of the forms:
   550                          ;    x,y  = absolute xpos & absolute ypos
   551                          ; +/-x,y  = relative xpos & absolute ypos
   552                          ;    x,+/-y = absolute xpos & relative ypos
   553                          ; +/-x,+/-y = relative xpos & relative ypos
   554                          ;    x;y  = x-distance at an angle y
   555                          ;
   556                          ;  Relative and angle distances are relative to current x,ypos.
   557                          ;  Values are scaled to current mode parameters if required.
   558                          ;******************************************************************
   559                          
   560                          
   561                          incor2                                                    ; enter here for optional argument
   562  bbdb 208522                              jsr chrgot                               ; end of line?
   563  bbde f007                                beq l308_1                               ; yes, use defaults
   564  bbe0 205b4e                              jsr chkcom
   565  bbe3 c92c                                cmp #','                                 ; is there really an arg?
   566  bbe5 d00f                                bne incord                               ; yes, let'er rip
   567                          
   568  bbe7 a000               l308_1           ldy #0                                   ; set default pos = current pos
   569  bbe9 b9ec11             l308_2           lda xpos,y
   570  bbec 9dec11                              sta vwork,x
   571  bbef e8                                  inx
   572  bbf0 c8                                  iny
   573  bbf1 c004                                cpy #4
   574  bbf3 90f4                                bcc l308_2
   575  bbf5 60                                  rts
   576                          
   577                          
   578                          ;incor3    ;enter here for non-optional arg preceded by a comma
   579                          ; jsr chkcom
   580                          incord
   581  bbf6 8ef811                              stx vtemp4                               ; save offset to destination
   582  bbf9 2081bc                              jsr cordsb                               ; get 2-byte x-parameter
   583  bbfc 208522                              jsr chrgot
   584  bbff c92c                                cmp #','
   585  bc01 f051                                beq docord                               ; skip ahead if have comma
   586                          
   587  bc03 c93b                                cmp #';'                                 ; check for semi-colon
   588  bc05 d34372                              +lbne snerr                              ; missing angle param- show syntax message
   589  bc08 208322                              jsr chrget       ;skip over '            ; '
   590  bc0b 208a5d                              jsr getwrd                               ; get 2-byte angle in a,y
   591  bc0e 8576                                sta z_p_temp_1                           ; swap a,y
   592  bc10 98                                  tya
   593  bc11 a476                                ldy z_p_temp_1
   594  bc13 20b8ba                              jsr gtang1                               ; get sine & cosine values for the angle
   595  bc16 aef811                              ldx vtemp4
   596  bc19 bdec11                              lda vwork,x
   597  bc1c 9dee11                              sta vwork+2,x                            ; move length to y-parameter
   598  bc1f bded11                              lda vwork+1,x
   599  bc22 9def11                              sta vwork+3,x
   600                          ; jsr scalxy       ;scale the values
   601  bc25 a90e                                lda #$0e
   602  bc27 8df911                              sta vtemp5
   603  bc2a 18                                  clc
   604  bc2b aef811                              ldx vtemp4
   605                          
   606  bc2e 2011bb             l309_1           jsr angmlt                               ; multiply length * angle
   607  bc31 9dec11                              sta vwork,x                              ; save angle result
   608  bc34 98                                  tya
   609  bc35 9ded11                              sta vwork+1,x
   610  bc38 a000                                ldy #xpos-vwork
   611  bc3a 4ef911                              lsr vtemp5
   612  bc3d 9002                                bcc l309_2
   613  bc3f a002                                ldy #ypos-vwork
   614                          
   615  bc41 2038bb             l309_2           jsr dotwo                                ; add/subtract value to current position
   616  bc44 9dec11                              sta vwork,x
   617  bc47 98                                  tya                                      ; save result in destination
   618  bc48 9ded11                              sta vwork+1,x
   619  bc4b e8                                  inx
   620  bc4c e8                                  inx
   621  bc4d 4ef911                              lsr vtemp5
   622  bc50 d0dc                                bne l309_1                               ; do y-coordinate
   623  bc52 18                                  clc
   624  bc53 60                                  rts
   625                          
   626                          
   627  bc54 208322             docord           jsr chrget                               ; skip over comma
   628  bc57 eef811                              inc vtemp4                               ; point to y-destination
   629  bc5a eef811                              inc vtemp4
   630  bc5d 2081bc                              jsr cordsb                               ; get y-paramter
   631                          ; ldx vtemp4
   632                          ; dex
   633                          ; dex
   634                          ; jsr scalxy       ;scale the values
   635  bc60 a002                                ldy #ypos-vwork
   636  bc62 aef811                              ldx vtemp4
   637  bc65 e8                                  inx
   638  bc66 e8                                  inx
   639                          
   640  bc67 ca                 docor1           dex
   641  bc68 ca                                  dex
   642  bc69 4ef911                              lsr vtemp5
   643  bc6c 900a                                bcc docor2                               ; skip if not relative
   644  bc6e 203abb                              jsr addtwo                               ; add to current position
   645  bc71 9dec11                              sta vwork,x
   646  bc74 98                                  tya
   647  bc75 9ded11                              sta vwork+1,x
   648                          
   649  bc78 a000               docor2           ldy #xpos-vwork
   650  bc7a ecf811                              cpx vtemp4
   651  bc7d f0e8                                beq docor1                               ; loop to do x-coordinate
   652  bc7f 18                                  clc
   653  bc80 60                                  rts
   654                          
   655                          ;
   656                          ; CORDSB -- Get the next 2-byte parameter
   657                          ;
   658                          
   659  bc81 208522             cordsb           jsr chrgot                               ; read character
   660  bc84 c9aa                                cmp #plus_token                          ; check if relative - plus sign
   661  bc86 f005                                beq l310_1                               ; skip if yes
   662  bc88 c9ab                                cmp #minus_token
   663  bc8a f001                                beq l310_1                               ; skip if relative - minus sign
   664  bc8c 18                                  clc                                      ; .c=1 if relative coord, .c=0 if absolute
   665  bc8d 2ef911             l310_1           rol vtemp5                               ; save coord type for later
   666  bc90 20d84c                              jsr frmnum
   667  bc93 20925d                              jsr getsad                               ; get signed 2 byte coordinate (y,a), do rts
   668  bc96 aef811                              ldx vtemp4
   669  bc99 9ded11                              sta vwork+1,x                            ; save 2-byte parameter
   670  bc9c 98                                  tya
   671  bc9d 9dec11                              sta vwork,x
   672  bca0 60                                  rts
   673                          
   674                          ;.end
   675                          
   676                          ;GRAPHICS11.SRC
   677                          
   678                          ;  ANGVAL  -- Table of angle values on 10 degree boundaries
   679                          ;  Values based as fraction of 65536
   680                          
   681                          angval
   682  bca1 0000                                !text $00,$00                            ; sine 00 degrees -  .0000
   683  bca3 2c71                                !text $2c,$71                            ; sine 10 degrees -  .1736
   684  bca5 578d                                !text $57,$8d                            ; sine 20 degrees -  .3420
   685  bca7 8000                                !text $80,$00                            ; sine 30 degrees -  .5000
   686  bca9 a48f                                !text $a4,$8f                            ; sine 40 degrees -  .6428
   687  bcab c419                                !text $c4,$19                            ; sine 50 degrees -  .7660
   688  bcad ddb2                                !text $dd,$b2                            ; sine 60 degrees -  .8660
   689  bcaf f090                                !text $f0,$90                            ; sine 70 degrees -  .9397
   690  bcb1 fc1c                                !text $fc,$1c                            ; sine 80 degrees -  .9848
   691  bcb3 ffff                                !text $ff,$ff                            ; sine 90 degrees - 1.0000
   692                          
   693                          ;  INCVAL  -- Table of incremental values between 10 degrees
   694                          ;  Values based on fraction of 65536
   695                          
   696                          incval
   697  bcb5 0472                                !text $04,$72                            ; 01 - 09 degrees -  .01739
   698  bcb7 0450                                !text $04,$50                            ; 11 - 19 degrees -  .01692
   699  bcb9 040b                                !text $04,$0b                            ; 21 - 29 degrees -  .01592
   700  bcbb 03a8                                !text $03,$a8                            ; 31 - 39 degrees -  .01443
   701  bcbd 0328                                !text $03,$28                            ; 41 - 49 degrees -  .01252
   702  bcbf 0290                                !text $02,$90                            ; 51 - 59 degrees -  .01023
   703  bcc1 01e3                                !text $01,$e3                            ; 61 - 69 degrees -  .00762
   704  bcc3 0128                                !text $01,$28                            ; 71 - 79 degrees -  .00477
   705  bcc5 0063                                !text $00,$63                            ; 81 - 89 degrees -  .00179
   706                          
   707                          ;.end

; ******** Source: basic.asm

; ******** Source: edit/mode.asm
     1                          
     2                          
     3                          ; Edit mode is simply a poor man's word processor.  Text is entered normally
     4                          ; as if the user were typing in a program, but tokenization is turned off.
     5                          ; This affects only that text which follows a line number.  CRUNCH and QPLOP
     6                          ; test for this mode, and deal with the text accordingly.  RUN, GOTO, etc.
     7                          ; test for this mode and error-out if it's enabled.  LOADing a text file
     8                          ; will automatically add line numbers, SAVEing a text file will remove them.
     9                          ;
    10                          ; Syntax:  EDIT < ON | OFF >
    11                          ;
    12                          ; F. Bowen        [910620]
    13                          
    14  bcc7 20ed58             edit             jsr errind                               ; direct mode only command
    15  bcca c991                                cmp #on_token
    16  bccc d004                                bne l311_1
    17  bcce a910                                lda #%00010000                           ; EDIT ON
    18  bcd0 800a                                bra l311_3                               ; (this kills trace mode, too)
    19                          
    20  bcd2 2016b5             l311_1           jsr chkesc                               ; [910930]
    21                          ; cmp #esc_command_token
    22                          ; bne l311_2
    23                          ; jsr chrget
    24  bcd5 c924                                cmp #off_token
    25  bcd7 d37171             l311_2           +lbne snerr
    26  bcda a900                                lda #0                                   ; EDIT OFF
    27  bcdc 857e               l311_3           sta runmod
    28  bcde 4c8322                              jmp chrget                               ; exit
    29                          
    30                          
    31                          edit_crunch                                               ; Edit mode only, find end of plain text in input buffer
    32  bce1 fc3d00                              phw txtptr                               ; save current position in input buffer
    33  bce4 205635                              jsr rem                                  ; find the end of the line
    34  bce7 a63d                                ldx txtptr
    35  bce9 68                                  pla                                      ; restore buffer pointer
    36  bcea 853e                                sta txtptr+1
    37  bcec 68                                  pla
    38  bced 853d                                sta txtptr
    39  bcef 38                                  sec                                      ; compute length of line
    40  bcf0 8a                                  txa
    41  bcf1 e53d                                sbc txtptr
    42  bcf3 a8                                  tay
    43  bcf4 c8                                  iny
    44  bcf5 60                                  rts                                      ; done
    45                          
    46                          
    47                          edit_p1line                                               ; Edit mode only, list a line of plain text
    48  bcf6 207f64                              jsr linprt                               ; print line number in (a,x)
    49  bcf9 a920                                lda #' '                                 ; print a space
    50                          
    51  bcfb a003                                ldy #3                                   ; start printing at text following line number
    52  bcfd 203d68             l312_1           jsr outch                                ; print character
    53  bd00 c8                                  iny
    54  bd01 5f5503                              bbr5 helper,l312_2                       ; if called from FIND/CHANGE check for highlighting
    55  bd04 20963c                              jsr helpsb
    56  bd07 20ad22             l312_2           jsr indlow                               ; get next character
    57  bd0a d0f1                                bne l312_1                               ; loop until eol
    58  bd0c 60                                  rts                                      ; done
    59                          
    60                          
    61                          ;.end
    62                          
    63                          ; EDIT LOAD/SAVE  Load or Save a plain text SEQ file in memory
    64                          
    65                          edit_load                                                 ; Called by DLOAD/DVERIFY when in EDIT mode
    66  bd0d a301                                ldz #1
    67  bd0f 20196f                              jsr open_SEQ_file                        ; Open the file just like TYPE: filename [,U#] [,D#]
    68  bd12 200e78                              jsr Check_DS                             ; check current disk error message
    69  bd15 a000                                ldy #0
    70  bd17 a97a                                lda #dsdesc+1
    71  bd19 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y peek at first character
    72  bd1c c932                                cmp #'2'
    73  bd1e b3bb00                              +lbcs l313_12                            ; exit if error
    74  bd21 208278                              jsr Clear_DS                             ; else zap 'ok' message so user gets fresh one
    75  bd24 ae8111                              ldx dosla
    76  bd27 20c6ff                              jsr _chkin                               ; get input channel
    77  bd2a b3af00                              +lbcs l313_12                            ; error
    78                          
    79  bd2d 8f0c0e                              bbs0 verck,l313_1
    80  bd30 207dff                              jsr _primm
    81  bd33 0d4c4f4144494e47...                 !text cr,"LOADING",0
    82  bd3c 800e                                bra l313_2
    83  bd3e 207dff             l313_1           jsr _primm
    84  bd41 0d56455249465949...                 !text cr,"VERIFYING",0
    85                          
    86  bd4c a9e8               l313_2           lda #<1000                               ; default starting line #
    87  bd4e a203                                ldx #>1000
    88  bd50 8516                                sta linnum
    89  bd52 8617                                stx linnum+1
    90                          
    91  bd54 a52d                                lda txttab                               ; load address
    92  bd56 a62e                                ldx txttab+1
    93  bd58 8524                                sta index
    94  bd5a 8625                                stx index+1
    95                          
    96  bd5c a000               l313_3           ldy #0                                   ; Input one line of text
    97  bd5e 20e1ff                              jsr _stop                                ; check stop key
    98  bd61 f072                                beq l313_11                              ; exit if down
    99  bd63 20b7ff                              jsr _readst                              ; check channel status
   100  bd66 d06d                                bne l313_11                              ; exit if eof or error
   101                          
   102  bd68 0f0c04                              bbr0 verck,l313_4
   103  bd6b a003                                ldy #3
   104  bd6d 8020                                bra l313_5                               ; skip ahead if verify op
   105                          
   106  bd6f a901               l313_4           lda #1                                   ; install fake line links for this line
   107  bd71 200623                              jsr sta_far_in1
   108  bd74 c8                                  iny                                      ; 1
   109  bd75 200623                              jsr sta_far_in1
   110  bd78 c8                                  iny                                      ; 2
   111  bd79 a516                                lda linnum                               ; install line number for this line
   112  bd7b 200623                              jsr sta_far_in1
   113  bd7e c8                                  iny                                      ; 3
   114  bd7f a517                                lda linnum+1
   115  bd81 200623                              jsr sta_far_in1
   116  bd84 18                                  clc
   117  bd85 a516                                lda linnum                               ; generate next line number
   118  bd87 690a                                adc #10
   119  bd89 8516                                sta linnum
   120  bd8b 9002                                bcc l313_5
   121  bd8d e617                                inc linnum+1
   122                          
   123                          
   124  bd8f c8                 l313_5           iny                                      ; bump buffer pointer
   125  bd90 c0a1                                cpy #buflen                              ; check buffer (160 max. input buffer size to edit)
   126  bd92 f01e                                beq l313_8                               ; split long lines into two????
   127  bd94 20cfff                              jsr _basin                               ; read file data
   128  bd97 f019                                beq l313_8                               ; CR or null terminates line
   129  bd99 c90d                                cmp #cr
   130  bd9b f015                                beq l313_8
   131                          ; cmp #$20  ;adjust invisible characters less than space
   132                          ; bcc l313_6   ; ????make them appear in reverse field, but note
   133                          ; ora #$80  ; that these lines can't be edited without losing them.
   134                          
   135  bd9d 0f0c0d             l313_6           bbr0 verck,l313_7
   136  bda0 201723                              jsr indcmp_in1                           ; Compare to memory
   137  bda3 f0ea                                beq l313_5                               ; ok
   138  bda5 202033                              jsr list_exit
   139  bda8 a21c                                ldx #ervfy                               ; verify error
   140  bdaa 83a370                              +lbra error
   141                          
   142  bdad 200623             l313_7           jsr sta_far_in1                          ; Load into memory
   143  bdb0 80dd                                bra l313_5                               ; loop until eol or error (kernel returns CR in case of error)
   144                          
   145  bdb2 8f0c05             l313_8           bbs0 verck,l313_9
   146  bdb5 a900                                lda #0
   147  bdb7 200623                              jsr sta_far_in1                          ; terminate line with null (replaces CR)
   148  bdba c8                 l313_9           iny
   149  bdbb 98                                  tya
   150  bdbc 18                                  clc
   151  bdbd 6524                                adc index
   152  bdbf 8524                                sta index
   153  bdc1 9002                                bcc l313_10
   154  bdc3 e625                                inc index+1
   155  bdc5 a525               l313_10          lda index+1
   156  bdc7 cdd002                              cmp max_mem_0+1                          ; out of memory????
   157  bdca 9090                                bcc l313_3                               ; no, continue until eof
   158  bdcc 631000                              bsr edit_load_done                       ; yes, patch things up best we can
   159  bdcf 202033                              jsr list_exit                            ; close disk
   160  bdd2 836d70                              +lbra omerr                              ; report error & exit
   161                          
   162  bdd5 8f0c03             l313_11          bbs0 verck,l313_12
   163  bdd8 20debd                              jsr edit_load_done                       ; EOF: terminate memory with a pair of nulls
   164  bddb 834375             l313_12          +lbra list_exit                          ; release channel, close file, etc.
   165                          
   166                          ; bbr0 verck,40$
   167                          ; jsr verify_ok  ;if Verify, report 'ok'
   168                          ;40$ lda #0   ;exit directly to main????
   169                          ; bra end
   170                          
   171                          edit_load_done
   172  bdde a900                                lda #0                                   ; EOF: terminate memory with a pair of nulls
   173  bde0 a8                                  tay
   174  bde1 200623                              jsr sta_far_in1
   175  bde4 c8                                  iny
   176  bde5 200623                              jsr sta_far_in1
   177  bde8 e324                                inw index
   178  bdea e324                                inw index
   179  bdec a624                                ldx index                                ; set top
   180  bdee a425                                ldy index+1
   181  bdf0 8682                                stx text_top
   182  bdf2 8483                                sty text_top+1
   183  bdf4 83c372                              +lbra link_program                       ; relink & RTS
   184                          
   185                          
   186                          edit_save
   187  bdf7 a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
   188  bdf9 202074                              jsr dosprs                               ; (like dopen:      0 0 0 *  * 0 0 1 )
   189  bdfc 20dc77                              jsr chk1                                 ; check parameters
   190  bdff 201d71                              jsr find_la                              ; find an available LA
   191  be02 200d71                              jsr find_sa                              ; find an available SA
   192  be05 a017                                ldy #fsavseq
   193  be07 a208                                ldx #8
   194  be09 20fd70                              jsr open_file                            ; open the file
   195  be0c b31975                              +lbcs list_err                           ; exit if error
   196  be0f ae8111                              ldx dosla
   197  be12 20c9ff                              jsr _chkout                              ; get output channel
   198  be15 b03b                                bcs l314_5                               ; error
   199                          
   200  be17 a52d                                lda txttab                               ; save address
   201  be19 a62e                                ldx txttab+1
   202  be1b 8524                                sta index
   203  be1d 8625                                stx index+1
   204                          
   205  be1f 20e1ff             l314_1           jsr _stop                                ; check stop key
   206  be22 f02e                                beq l314_5                               ; exit if down
   207  be24 20b7ff                              jsr _readst                              ; check channel status
   208  be27 d029                                bne l314_5                               ; exit if eof or error????
   209                          
   210  be29 a003                                ldy #3                                   ; save a line, starting past links & line#
   211  be2b c8                 l314_2           iny                                      ; bump buffer pointer
   212                          ; cpy #buflen  ;check buffer (160 max. input buffer size to edit)
   213                          ; beq ??$   ; split long lines into two????
   214  be2c 20c122                              jsr indin1
   215  be2f aa                                  tax                                      ; save character for eol check
   216  be30 d002                                bne l314_3
   217  be32 a90d                                lda #cr                                  ; eol: substitute CR ???? allow some other terminator
   218  be34 20d2ff             l314_3           jsr _bsout                               ; write file data
   219  be37 8a                                  txa
   220  be38 d0f1                                bne l314_2                               ; loop until eol
   221                          
   222  be3a c8                                  iny                                      ; advance text index to start of next line
   223  be3b 98                                  tya
   224  be3c 18                                  clc
   225  be3d 6524                                adc index
   226  be3f 8524                                sta index
   227  be41 9002                                bcc l314_4
   228  be43 e625                                inc index+1
   229                          
   230  be45 a000               l314_4           ldy #0                                   ; check for EOF: a pair of null links
   231  be47 20c122                              jsr indin1
   232  be4a d0d3                                bne l314_1
   233  be4c c8                                  iny
   234  be4d 20c122                              jsr indin1
   235  be50 d0cd                                bne l314_1                               ; loop until end of text
   236                          
   237  be52 83cc74             l314_5           +lbra list_exit                          ; release channel, close file, exit
   238                          
   239                          ;.end
   240                          
   241                          
   242                          Sound_CLR
   243  be55 2022b5                              jsr chkeos                               ; eat CLR token, check eos   [910717] new
   244                          Sound_CLR_1
   245  be58 08                                  php
   246  be59 78                                  sei
   247                          ; jsr go_slow  ;      [910716] 4567R7A
   248  be5a a900                                lda #0
   249  be5c a217                                ldx #24-1
   250  be5e 9d00d4             l315_1           sta sid1,x                               ; initialize SID chips
   251  be61 9d20d4                              sta sid2,x
   252  be64 ca                                  dex
   253  be65 10f7                                bpl l315_1
   254                          
   255  be67 8d7a12                              sta filters1+2                           ; set filters off
   256  be6a 8d7e12                              sta filters2+2
   257                          
   258  be6d a908                                lda #8                                   ; set default volume
   259  be6f 8d7b12                              sta filters1+3
   260  be72 8d7f12                              sta filters2+3                           ; [910612]
   261                          ; sta filters+4  ;why?      [910612]
   262  be75 8d18d4                              sta sid1+24
   263  be78 8d38d4                              sta sid2+24
   264                          
   265                          ; jsr go_fast  ;      [910716] 4567R7A
   266                          
   267  be7b 2c0311                              bit _pal_ntsc                            ; determine if PAL or NTSC system  [910724]
   268  be7e 3006                                bmi l315_2                               ; ...branch if PAL
   269  be80 a928                                lda #(<beats_ntsc)/4                     ; set beat to quarter note (4/4 time = .5 sec)
   270  be82 a001                                ldy #>beats_ntsc/4
   271  be84 8004                                bra l315_3
   272  be86 a92c               l315_2           lda #<beats_pal/4
   273  be88 a001                                ldy #>beats_pal/4
   274  be8a 8d7612             l315_3           sta ntime
   275  be8d 8c7712                              sty ntime+1
   276                          
   277  be90 a904                                lda #4                                   ; set default octave
   278  be92 8d7012                              sta octave
   279  be95 a90c                                lda #12                                  ; set default tempo    [910220]
   280  be97 8d7312                              sta tempo_rate                           ; 12 makes whole note in 4/4 time last 2 seconds
   281                          
   282  be9a a01d                                ldy #30-1                                ; initialize music tables
   283  be9c b9d849             l315_4           lda atkmus,y
   284  be9f 998912                              sta atktab,y
   285  bea2 88                                  dey
   286  bea3 10f7                                bpl l315_4
   287                          
   288  bea5 a209                                ldx #10-1                                ; initialize pulse widths
   289  bea7 bdf649             l315_5           lda pwhmus,x
   290  beaa 9db112                              sta pulshi,x
   291  bead ca                                  dex
   292  beae 10f7                                bpl l315_5
   293                          
   294  beb0 8a                                  txa                                      ; $ff
   295  beb1 a205                                ldx #6-1                                 ; stereo SIDs   (save space) [911119]
   296  beb3 a001                                ldy #1
   297  beb5 9dc412             l315_6           sta sound_time_hi,x                      ; turn all SOUND counters off
   298  beb8 995d12                              sta voices,y                             ; turn all PLAY counters off
   299  bebb c8                                  iny
   300  bebc c8                                  iny
   301  bebd ca                                  dex
   302  bebe 10f5                                bpl l315_6
   303                          
   304  bec0 a005                                ldy #6-1                                 ; set default envelope (piano) for all voices (6)
   305  bec2 8c6f12                              sty voice
   306  bec5 a200               l315_7           ldx #0
   307  bec7 200748                              jsr set_envelope_1
   308  beca ce6f12                              dec voice
   309  becd 10f6                                bpl l315_7
   310  becf ee6f12                              inc voice                                ; set default voice (0)
   311                          
   312  bed2 28                                  plp
   313  bed3 60                                  rts

; ******** Source: basic.asm

; ******** Source: initialise/sprites.asm
     1                          
     2                          Sprite_CLR
     3  bed4 2022b5                              jsr chkeos                               ; eat CLR token, check eos   [910717] new
     4                          Sprite_CLR_1
     5  bed7 08                                  php
     6  bed8 78                                  sei
     7  bed9 a900                                lda #0
     8  bedb 8d15d0                              sta vic+21                               ; Turn off all sprites
     9  bede 8d17d0                              sta vic+23                               ; Unexpand them     [910828]
    10  bee1 8d1bd0                              sta vic+27                               ; Sprite priority
    11  bee4 8d1cd0                              sta vic+28                               ; Hires sprites
    12  bee7 8d1dd0                              sta vic+29
    13                          
    14  beea a257                                ldx #init_as_0                           ; Init sprite tables
    15  beec 9d0512             l316_1           sta sprite_data,x
    16  beef ca                                  dex
    17  bef0 10fa                                bpl l316_1
    18                          
    19  bef2 a91f                                lda #sprite_base/64+7                    ; Set up sprite pointers
    20  bef4 a007                                ldy #7
    21  bef6 7fd705             l316_2           bbr7 _mode,l316_3
    22  bef9 99f80b                              sta sprite_ptrs_40,y                     ; 40 col screen
    23  befc 8003                                bra l316_4
    24  befe 99f80f             l316_3           sta sprite_ptrs_80,y                     ; 80 col screen
    25  bf01 3a                 l316_4           dec
    26  bf02 88                                  dey
    27  bf03 10f1                                bpl l316_2
    28                          
    29  bf05 28                                  plp
    30                          ; rts
    31                          

; ******** Source: basic.asm

; ******** Source: handler/nmi.asm
     1                          
     2                          
     3                          
     4                          basic_nmi                                                 ; removed [910826]
     5                          ; lda nmi_wrap_flag ;filter out wrapped NMI calls   [910523] audio
     6                          ; beq 1$   ; it's ok
     7                          ; rts   ; exit- we're already handling one interrupt
     8                          ;
     9                          ;1$ inc nmi_wrap_flag ;shut the door to NMI
    10                          ;
    11                          ;basic_nmi_end
    12                          ; dec nmi_wrap_flag ;open the door to NMI
    13  bf06 60                                  rts
    14                          
    15                          
    16                          
    17                          

; ******** Source: basic.asm

; ******** Source: system/jumptable.asm
     1                          
     2                          
     3                          
     4                                           * = $7f00
     5                          
     6                          
     7                          ; Format Conversions     [6]
     8                          
     9  7f00 83b2d9                              +lbra ayint                              ; convert floating point to integer
    10  7f03 833acf                              +lbra givayf                             ; convert integer to floating point
    11  7f06 8387e5                              +lbra fout                               ; convert floating point to PETSCII string
    12  7f09 8341d6                              +lbra val_1                              ; convert PETSCII string to floating point
    13  7f0c 837fde                              +lbra getadr                             ; convert floating point to an address
    14  7f0f 83cee3                              +lbra floatc                             ; convert address to floating point
    15                          
    16                          ; Math Functions     [24]
    17                          
    18  7f12 8391de                              +lbra fsub                               ; MEM - FACC
    19  7f15 8391de                              +lbra fsubt                              ; ARG - FACC
    20  7f18 83a1de                              +lbra fadd                               ; MEM + FACC
    21  7f1b 83ffe4                              +lbra faddt_c65                          ; ARG - FACC      [910402]
    22  7f1e 834de1                              +lbra fmult                              ; MEM * FACC
    23  7f21 8340e1                              +lbra fmultt_c65                         ; ARG * FACC      [910402]
    24  7f24 835ce2                              +lbra fdiv                               ; MEM / FACC
    25  7f27 834fe2                              +lbra fdivt_c65                          ; ARG / FACC      [910402]
    26  7f2a 83e2e0                              +lbra log                                ; compute natural log of FACC
    27  7f2d 8334e4                              +lbra int                                ; perform BASIC INT() on FACC
    28  7f30 838ae6                              +lbra sqr                                ; compute square root of FACC
    29  7f33 83c7e6                              +lbra negop                              ; negate FACC
    30  7f36 838be6                              +lbra fpwr                               ; raise ARG to the MEM power
    31  7f39 838be6                              +lbra fpwrt                              ; raise ARG to the FACC power
    32  7f3c 83c9e6                              +lbra exp                                ; compute EXP of FACC
    33  7f3f 835de7                              +lbra cos                                ; compute COS of FACC
    34  7f42 8361e7                              +lbra sin                                ; compute SIN of FACC
    35  7f45 83a7e7                              +lbra tan                                ; compute TAN of FACC
    36  7f48 83d5e7                              +lbra atn                                ; compute ATN of FACC
    37  7f4b 8365e3                              +lbra round                              ; round FACC
    38  7f4e 839ee3                              +lbra abs                                ; absolute value of FACC
    39  7f51 836ee3                              +lbra sign                               ; test sign of FACC
    40  7f54 839be3                              +lbra fcomp                              ; compare FACC with MEM
    41  7f57 83cdd8                              +lbra rnd_0                              ; generate random floating point number
    42                          
    43                          ; Movement      [22]
    44                          
    45  7f5a 839be1                              +lbra conupk                             ; move RAM MEM to ARG
    46  7f5d 836de1                              +lbra romupk                             ; move ROM MEM to ARG
    47  7f60 83f0cf                              +lbra movfrm                             ; move RAM MEM to FACC
    48  7f63 83a9e2                              +lbra movfm                              ; move ROM MEM to FACC
    49  7f66 83d2e2                              +lbra movmf                              ; move FACC to MEM
    50  7f69 8328e3                              +lbra movfa                              ; move ARG to FACC
    51  7f6c 8335e3                              +lbra movaf                              ; move FACC to ARG
    52                          
    53                          ; bra optab ;????not executable
    54                          ; bra drawln
    55                          ; bra gplot
    56                          ; bra cirsub
    57  7f6f 8343be                              +lbra run
    58  7f72 832db5                              +lbra runc
    59  7f75 8354b5                              +lbra clearc                             ; [910410]
    60  7f78 83dbb4                              +lbra new
    61  7f7b 833cb1                              +lbra link_program
    62  7f7e 839fa3                              +lbra crunch
    63  7f81 8377b2                              +lbra FindLine
    64  7f84 8387ac                              +lbra newstt
    65  7f87 8359ce                              +lbra eval
    66  7f8a 8363cd                              +lbra frmevl
    67  7f8d 8334be                              +lbra run_a_program
    68  7f90 8309be                              +lbra setexc
    69  7f93 8399b2                              +lbra linget
    70  7f96 839bdc                              +lbra garba2
    71  7f99 8376af                              +lbra execute_a_line
    72                          
    73                          ; Temporaries for C65 development (???? used by graphics) [12]
    74                          
    75  7f9c 83e5a2                              +lbra chrget
    76  7f9f 83e4a2                              +lbra chrgot
    77  7fa2 83b7ce                              +lbra chkcom
    78  7fa5 8331cd                              +lbra frmnum
    79  7fa8 83e3dd                              +lbra getadr
    80  7fab 83cfdd                              +lbra getnum
    81  7fae 83bcdd                              +lbra getbyt
    82  7fb1 8372e9                              +lbra plsv
    83                          
    84  7fb4 8311a3                              +lbra lda_far_ram0                       ; lda (.x),y from BASIC text bank [910716]
    85  7fb7 831ea3                              +lbra lda_far_ram1                       ; lda (.x),y from BASIC variable bank [910716]
    86  7fba 8350a3                              +lbra sta_far_ram0                       ; sta (.x),y to   BASIC text bank [910716]
    87  7fbd 8331a3                              +lbra sta_far_ram1                       ; sta (.x),y to   BASIC variable bank [910716]
    88                          
    89                          
    90                          ; Graphic Kernel Call. (Temporary for C65 development ????)
    91                          ;
    92                          ;  syntax:  GRAPHIC command# [,args]
    93                          ;
    94                          ; Basically this is a modified C64-type SYS command, minus the address.
    95                          ; In the final C65 system, this will represent the ML interface, not the
    96                          ; BASIC 10.0 interface which is implemented here in the development system.
    97                          
    98                          
    99                          graphic
   100  7fc0 c99c                                cmp #clr_token                           ; GRAPHIC CLR (graphic system initialize)
   101  7fc2 d006                                bne l317_1                               ; no
   102  7fc4 208322                              jsr chrget                               ; yes advance past token
   103  7fc7 6c0080                              jmp ($8000)                              ; go initialize graphic kernel
   104                          
   105                          l317_1
   106                          ; tax
   107                          ; bmi snerr  ;Syntax error if any other secondary token
   108                          ;
   109                          ;
   110  7fca 6cfe02                              jmp (graphic_vector)                     ; Else, call the Graphics Kernel's Parser...
   111                          ;
   112                          ;
   113                          graphic_kernel                                            ; ...via indirect
   114  7fcd 6c0280                              jmp ($8002)
   115                          
   116                          
   117                          ; C65 Graphic Kernel Jump Table      [910826]
   118                          ;
   119                          ; 8000 init   ;sets up graphic vars
   120                          ; 8002 parser   ;GRAPHIC ML Parser????
   121                          ;
   122                          ; 8004 kg65.start-1  ;0 commands
   123                          ; 8006 kg65.screendef-1 ;1
   124                          ; 8008 kg65.screenopen-1 ;2
   125                          ; 800a kg65.screenclose-1 ;3
   126                          ; 800c kg65.screenclear-1 ;4
   127                          ; 800e kg65.screen-1  ;5
   128                          ; 8010 kg65.setpen-1  ;6
   129                          ; 8012 kg65.setpalette-1 ;7
   130                          ; 8014 kg65.setdmode-1  ;8
   131                          ; 8016 kg65.setdpat-1  ;9
   132                          ; 8018 kg65.line-1  ;10
   133                          ; 801a kg65.box-1  ;11
   134                          ; 801c kg65.circle-1  ;12
   135                          ; 801e kg65.polygon-1  ;13
   136                          ; 8020 kg65.ellipse-1  ;14
   137                          ; 8022 kg65.viewpclr-1  ;15
   138                          ; 8024 kg65.copy-1  ;16
   139                          ; 8026 kg65.cut-1  ;17
   140                          ; 8028 kg65.paste-1  ;18
   141                          ; 802a kg65.load-1  ;19
   142                          ; 802c kg65.char-1  ;20
   143                          ; 802e kg65.paint-1  ;21
   144                          ; 8030 kg65.viewpdef-1  ;22
   145                          ; 8032 kg65.f.pixel-1  ;23
   146                          ; 8034 kg65.f.rpalette-1 ;24
   147                          ; 8036 kg65.f.index2color-1 ;25
   148                          ; 8038 kg65.f.rgraphic  ;26
   149                          
   150                          
   151                          
   152                          

; ******** Source: basic.asm
