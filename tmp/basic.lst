
; ******** Source: tmp/basic.asm
     1                          ; .nam C65 Development BASIC 10.0 (C)1991 CBM
     2                          ; .subttl *** Copyright (C) 1991  by  Commodore Business Machines, Inc. ***
     3                          
     4                          ;  ***************************************************************************
     5                          ;  *                               //                                        *
     6                          ;  *              CCCCCCC         //    6666666     555555555                *
     7                          ;  *             CCC   CCC       //    666   666    555                      *
     8                          ;  *            CCC             //    666           555                      *
     9                          ;  *            CCC            //     666 6666      55555555                 *
    10                          ;  *            CCC           //      6666   666          555                *
    11                          ;  *            CCC          //       666     666          555               *
    12                          ;  *             CCC   CCC  //         666   666    555   555                *
    13                          ;  *              CCCCCCC  //           6666666      5555555                 *
    14                          ;  *                      //                                                 *
    15                          ;  *                                                                         *
    16                          ;  *          BBBBBBBBB      AAAA      SSSSSSSS   III    CCCCCCC             *
    17                          ;  *          BBB    BBB   AAA  AAA   SSS    SSS  III   CCC   CCC            *
    18                          ;  *          BBB    BBB  AAA    AAA  SSS         III  CCC                   *
    19                          ;  *          BBBBBBBBB   AAAAAAAAAA   SSSSSSSS   III  CCC                   *
    20                          ;  *          BBB    BBB  AAA    AAA         SSS  III  CCC                   *
    21                          ;  *          BBB    BBB  AAA    AAA  SSS    SSS  III   CCC   CCC            *
    22                          ;  *          BBBBBBBBB   AAA    AAA   SSSSSSSS   III    CCCCCCC             *
    23                          ;  *                                                                         *
    24                          ;  *                       V E R S I O N   1 0 . 0                           *
    25                          ;  *              *
    26                          ;  *        Copyright (C)1991  by   Commodore Business Machines, Inc.        *
    27                          ;  *              *
    28                          ;  *       All  Rights  Reserved        *
    29                          ;  *              *
    30                          ;  ***************************************************************************
    31                          
    32                          ;   ROM VERSION  911115  (ver 0.9B)
    33                          
    34                          ; ******************************************************************
    35                          ; *                                                                *
    36                          ; * This listing contains confidential and proprietary information *
    37                          ; * of CBM, Inc.  The reproduction, dissemination or disclosure to *
    38                          ; * others without express written permission is prohibited.  This *
    39                          ; * software is for use in prototype Commodore C/65 systems only.  *
    40                          ; *                                                                *
    41                          ; *  The information in this document will change without notice.  *
    42                          ; *                                                                *
    43                          ; *  No  responsibility  is  assumed  for the reliability of this  *
    44                          ; *                          software.                             *
    45                          ; *                                                                *
    46                          ; ******************************************************************
    47                          
    48                          ; .STORE $2000,$a000,"b65.rom"
    49                          
    50                          ; This version written and assembled by Fred Bowen using BSO format.
    51                          ; .page
    52                          ; Adapted from the following C128 files, ROM part numbers 318018-04, 3180194-04:
    53                          ;
    54                          ; disclaim  resume   hexfunc
    55                          ; declare   doloop   rgr
    56                          ; entries   key   rclr
    57                          ; header   paint   joy
    58                          ; init   box   penpot
    59                          ; indjumps  sshape   pointer
    60                          ; crunch   gshape   rsprite
    61                          ; tokens1   circle   rspcolor
    62                          ; tokens2   draw   bump
    63                          ; disptable  char   rsppos
    64                          ; errmsgs   locate   xor
    65                          ; errprint  scale   rwindow
    66                          ; execute   color   rnd
    67                          ; functions  scnclr   code12
    68                          ; code0   graphic   stringfns
    69                          ; rtstack   bank   code17
    70                          ; findline  sleep   code18
    71                          ; lineget   wait   code19
    72                          ; list   sprite   code21
    73                          ; newclr   movspr   code22
    74                          ; return   play   code23
    75                          ; remdata   filter   code24
    76                          ; if   envelope  code26
    77                          ; ongoto   collision  grbcol
    78                          ; let   sprcolor  trig
    79                          ; print   width   using
    80                          ; input   volume   instring
    81                          ; next   sound   graphic3
    82                          ; dim   window   rdot
    83                          ; sys   boot   graphic7
    84                          ; trontroff  sprdef   graphic8
    85                          ; rreg   sprsav   graphic9
    86                          ; midequal  fast   graphic10
    87                          ; auto   slow   graphic11
    88                          ; help   checkval  sethires
    89                          ; gosubgoto  formeval  clrhires
    90                          ; go   variables  dos1
    91                          ; continue  getpointr  dos2
    92                          ; run   array   dos3
    93                          ; restore   patcheslo  dos4
    94                          ; renumber  fre   overflow
    95                          ; for   val   irq
    96                          ; delete   dec   stash
    97                          ; pudef   peekpoke  fetch
    98                          ; trap   errfunc   swap
    99                          ; patcheshi  jumptable  def
   100                          ; strings
   101                          ; .page
   102                          ; .subttl C65 BASIC 10.0 Macro Definitions
   103                          
   104                          ; .blist
   105                          
   106                          ; .page
   107                          ; .subttl C65 BASIC 10.0 Declarations
   108                          
   109                          ; General assignments and equates
   110                          
   111                          doslfn           = 0                                      ; DOS' private logical file number
   112                          dosffn           = 8                                      ; DOS' default drive number
   113                          
   114                          strsiz           = 3                                      ; string descriptor size in temps. and arrays
   115                          lengos           = 5                                      ; length of a GOSUB entry on the runtime stack
   116                          lenfor           = 18                                     ; length of a FOR entry in the runtime stack
   117                          
   118                          ; maxchr = 80  ;misc. command equates
   119                          ; llen  = 40
   120                          ; nlines = 25
   121                          column_width     = 10                                     ; print comma spacing
   122                          
   123                          beats_pal        = 1200                                   ; whole note (4/4 time = 2sec.)    [910724]
   124                          beats_ntsc       = 1440                                   ;
   125                          
   126                          lf               = $0a                                    ; line feed
   127                          cr               = $0d                                    ; carriage return
   128                          esc              = $1b                                    ; escape
   129                          pi               = $ff
   130                          
   131                          basbgn           = $2000                                  ; bottom of BASIC text bank
   132                          baswrk           = basbgn+1                               ; where BASIC text starts
   133                          varbgn           = $2000                                  ; bottom of BASIC data bank (C65: DOS RAM below $12000)
   134                          bank_0_top       = $8000                                  ; top of BASIC text bank ($FF00)    [910528]
   135                          bank_1_top       = $8000                                  ; top of BASIC data bank ($f800, VIC attributes)  [910528]
   136                          
   137                          ; graphic_base = $2000
   138                          ; color_ram_lo = $1c00
   139                          ; color_ram_hi = $d800
   140                          
   141                          vic              = $d000                                  ; Video controller
   142                          
   143                          fdc              = $d080                                  ; Built-in floppy disk controller
   144                          
   145                          sid1             = $d400                                  ; Audio processors (right)
   146                          sid2             = $d420                                  ; (left)
   147                          
   148                          d1_6526          = $dc00                                  ; Ports, peripheral control
   149                          d1pra            = d1_6526
   150                          d2_6526          = $dd00
   151                          d2pra            = d2_6526
   152                          
   153                          dma_ctlr         = $d700                                  ; DMA Controller
   154                          
   155                          ; .page
   156                          ;  BASIC base page storage
   157                          
   158                                           * = $0000
   159                          
   160  0000 0000                                !fill 2                                  ; '4510' registers (not used in C65 mode)
   161  0002 00                 srchtk           !fill 1                                  ; token 'search' looks for (run-time stack) / SYS 'bank#'
   162                          
   163                                           * = $000a                                ; skip over SYS address, status, a/x/y/z registers
   164                          
   165                          integr                                                    ; used by math routines (this & following location)
   166  000a 00                 charac           !fill 1
   167  000b 00                 endchr           !fill 1
   168  000c 00                 verck            !fill 1                                  ; LOAD/VERIFY flag
   169  000d 00                 count            !fill 1                                  ; temp used all over
   170  000e 00                 dimflg           !fill 1                                  ; DIM flag used by variable search
   171  000f 00                 valtyp           !fill 1                                  ; 0=numeric, $FF=string
   172  0010 00                 intflg           !fill 1                                  ; b7: (0=float,1=integer), b6: (1=get flag)
   173                          garbfl                                                    ; garbage collection temporary
   174  0011 00                 dores            !fill 1                                  ; b7: P1LINE quote flag
   175  0012 00                 subflg           !fill 1                                  ; b7: subscript flag (set to disallow subscripts() & integers%)
   176  0013 00                 input_flag       !fill 1                                  ; READ($98), GET($40), or INPUT($00)
   177                          domask
   178  0014 00                 tansgn           !fill 1
   179  0015 00                 channl           !fill 1                                  ; active I/O channel
   180                          poker                                                     ; temp used all over
   181  0016 0000               linnum           !fill 2                                  ; line number
   182                          
   183  0018 00                 temppt           !fill 1                                  ; pointer to next temporary descriptor in tempst
   184  0019 0000               lastpt           !fill 2                                  ; pointer to last used temporary string
   185  001b 0000000000000000...tempst           !fill 9                                  ; temporary descriptor pointers (3 at 3 bytes each)
   186                          
   187                          index
   188  0024 0000               index1           !fill 2
   189  0026 0000               index2           !fill 2
   190                          
   191                          multiplicand                                              ; 2 bytes wide, for unsigned integer multiply
   192  0028 00                 resho            !fill 1
   193  0029 00                 resmoh           !fill 1
   194                          product                                                   ; 3 bytes wide, for unsigned integer multiply
   195                          addend
   196  002a 00                 resmo            !fill 1
   197  002b 00                 reslo            !fill 1
   198  002c 00                                  !fill 1
   199  002d 0000               txttab           !fill 2                                  ; where BASIC program begins   (text_bank)
   200  002f 0000               vartab           !fill 2                                  ; where variable descriptors begin  (var_bank)
   201  0031 0000               arytab           !fill 2                                  ; where array table begins   (var_bank)
   202  0033 0000               strend           !fill 2                                  ; where arrays table ends   (var_bank)
   203  0035 0000               fretop           !fill 2                                  ; bottom of string storage   (var_bank)
   204  0037 0000               frespc           !fill 2                                  ; where temporary strings begin   (var_bank)
   205  0039 0000               max_mem_1        !fill 2                                  ; highest address available to BASIC in RAM 1 (var_bank)
   206  003b 0000               curlin           !fill 2
   207  003d 0000               txtptr           !fill 2                                  ; pointer to BASIC text used by CHRGET, etc.
   208                          form                                                      ; used by print using
   209  003f 0000               fndpnt           !fill 2                                  ; pointer to item found by search
   210  0041 0000               datlin           !fill 2
   211  0043 0000               datptr           !fill 2
   212  0045 0000               inpptr           !fill 2
   213  0047 0000               varnam           !fill 2
   214                          fdecpt
   215  0049 0000               varpnt           !fill 2
   216                          lstpnt
   217                          andmsk
   218  004b 0000               forpnt           !fill 2
   219                          eormsk           =forpnt+1
   220                          vartxt
   221  004d 0000               opptr            !fill 2
   222  004f 00                 opmask           !fill 1
   223                          grbpnt
   224                          tempf3
   225  0050 0000               defpnt           !fill 2
   226  0052 0000               dscpnt           !fill 2
   227                          token_saver                                               ; temp used by P1LINE/HELPSB (was spare????) [910628]
   228  0054 00                 trmpos           !fill 1                                  ; temp used by SPC(), TAB()   [910628]
   229                          
   230  0055 00                 helper           !fill 1                                  ; P1LINE flag b7: HELP vs. LIST
   231                          ;  b6: memory vs. file
   232                          ;  b5: FIND/CHANGE
   233                          ;  b4: highlight tokens
   234                          ;  b3: highlight REM
   235                          ;  b1: LINGET flag for AUTOSCROLL
   236                          ;  b0: token in progress
   237                          
   238  0056 00                 jmper            !fill 1                                  ; 3 locations used by Function handler
   239  0057 00                                  !fill 1                                  ;
   240  0058 00                 oldov            !fill 1                                  ;
   241                          
   242  0059 00                 tempf1           !fill 1                                  ; used by math routines
   243                          ptarg1           =tempf1                                  ; multiply defined for INSTR thru FACexp
   244                          ptarg2           =tempf1+2                                ; (also used by Monitor Utility, thru lowtr)
   245                          str1             =tempf1+4
   246                          str2             =tempf1+7
   247                          positn           =tempf1+10
   248                          match            =tempf1+11
   249                          
   250                          arypnt
   251  005a 0000               highds           !fill 2
   252  005c 0000               hightr           !fill 2
   253                          
   254  005e 00                 tempf2           !fill 1                                  ; used by math routines
   255  005f 0000               deccnt           !fill 2
   256                          tenexp           = deccnt+1
   257                          grbtop
   258                          dptflg
   259  0061 00                 lowtr            !fill 1
   260  0062 00                 expsgn           !fill 1
   261                          
   262                          fac                                                       ; Floating point accumulator (primary) FAC1
   263                          dsctmp
   264  0063 00                 facexp           !fill 1
   265  0064 00                 facho            !fill 1
   266  0065 00                 facmoh           !fill 1
   267                          indice
   268  0066 00                 facmo            !fill 1
   269  0067 00                 faclo            !fill 1
   270  0068 00                 facsgn           !fill 1
   271                          degree
   272  0069 00                 sgnflg           !fill 1
   273                          
   274  006a 00                 argexp           !fill 1                                  ; Floating point accumulator (secondary) FAC2
   275  006b 00                 argho            !fill 1
   276  006c 00                 argmoh           !fill 1
   277  006d 00                 argmo            !fill 1
   278  006e 00                 arglo            !fill 1
   279  006f 00                 argsgn           !fill 1
   280                          
   281                          strng1
   282  0070 00                 arisgn           !fill 1
   283  0071 00                 facov            !fill 1
   284                          
   285                          strng2
   286                          polypt
   287                          curtol
   288  0072 0000               fbufpt           !fill 2
   289                          
   290  0074 0000               autinc           !fill 2                                  ; incremental value for AUTO (0=off)
   291                          
   292  0076 00                 z_p_temp_1       !fill 1                                  ; USING's leading zero counter
   293                          ;GET, RENUMBER, KEY temporary
   294                          ;MOVSPR, SPRITE, PLAY, VOL temporary
   295                          ;MID$= temporary
   296                          
   297                          hulp                                                      ; counter
   298  0077 00                 keysiz           !fill 1
   299                          
   300  0078 00                 syntmp           !fill 1                                  ; used as temp all over the place
   301  0079 000000             dsdesc           !fill 3                                  ; descriptor for DS$
   302  007c 0000               tos              !fill 2                                  ; top of run time stack
   303  007e 00                 runmod           !fill 1                                  ; flags run/direct(b7), load(b6), trace(b5), edit(b4) modes
   304                          ; autoboot wedge (b0)
   305                          point                                                     ; USING's pointer to decimal point, 2 bytes used by AutoScroll
   306  007f 00                 parsts           !fill 1                                  ; DOS parser status word
   307  0080 00                 parstx           !fill 1                                  ; DOS parser status extensions
   308                          
   309  0081 00                 oldstk           !fill 1                                  ; BASIC saves uP stack pointer here
   310                          
   311  0082 0000               text_top         !fill 2                                  ; top of BASIC text pointer  (in text_bank)
   312  0084 00                 text_bank        !fill 1                                  ; where BASIC text lives   (RAM0 default)
   313  0085 00                 var_bank         !fill 1                                  ; where BASIC vars live   (RAM1 default)
   314                          sys_bank         = 0                                      ; where system space is  ???? (RAM0, make this a var?)
   315                          
   316  0086 00                 sid_speed_flag   !fill 1                                  ; saves system speed during SID ops (used during IRQ)
   317                          
   318                          time                                                      ; temporaries for TI, TI$, SLEEP (4 bytes)
   319                          grapnt                                                    ; used by SPRSAV, RMOUSE, RCOLOR
   320                          op
   321  0087 00                 column           !fill 1                                  ; temporaries for FIND/CHANGE, [L]INPUT, [L]READ, CURSOR
   322                          srow
   323  0088 000000             fstr1            !fill 3                                  ;
   324  008b 000000             fstr2            !fill 3                                  ;
   325                          
   326                          ; .page
   327                                           * = $00ff
   328                          
   329  00ff 00                 lofbuf           !fill 1
   330  0100 0000000000000000...fbuffr           !fill 16                                 ; MathPack builds numbers here, USING, RENUMBER
   331                          
   332                          ;  Kernel MAP configurations & DMA lists
   333                          
   334  0110 0000000000000000...                 !fill 16+36                              ; (4 configs + 3 DMA lists)
   335                          
   336                          ;  BASIC DMA lists  (2 @ 12bytes each = 24 bytes)
   337                          
   338  0144 00                 dma1_cmd         !fill 1                                  ; This list is used by BASIC OS
   339  0145 00                 dma1_cnt_lo      !fill 1
   340  0146 00                 dma1_cnt_hi      !fill 1
   341  0147 00                 dma1_src_lo      !fill 1
   342  0148 00                 dma1_src_hi      !fill 1
   343  0149 00                 dma1_src_bank    !fill 1
   344  014a 00                 dma1_dest_lo     !fill 1
   345  014b 00                 dma1_dest_hi     !fill 1
   346  014c 00                 dma1_dest_bank   !fill 1
   347  014d 00                 dma1_subcmd      !fill 1                                  ; (from here on not supported until F018A) [910520] F018A
   348  014e 00                 dma1_mod_lo      !fill 1
   349  014f 00                 dma1_mod_hi      !fill 1
   350                          
   351  0150 00                 dma2_cmd         !fill 1                                  ; This list is used by DMA command & Graphics
   352  0151 00                 dma2_cnt_lo      !fill 1
   353  0152 00                 dma2_cnt_hi      !fill 1
   354  0153 00                 dma2_src_lo      !fill 1
   355  0154 00                 dma2_src_hi      !fill 1
   356  0155 00                 dma2_src_bank    !fill 1
   357  0156 00                 dma2_dest_lo     !fill 1
   358  0157 00                 dma2_dest_hi     !fill 1
   359  0158 00                 dma2_dest_bank   !fill 1
   360  0159 00                 dma2_subcmd      !fill 1                                  ; (from here on not supported until F018A) [910520] F018A
   361  015a 00                 dma2_mod_lo      !fill 1
   362  015b 00                 dma2_mod_hi      !fill 1
   363                          
   364  015c 00                                  !fill 1                                  ; Kernel's dma_byte
   365                          
   366                          sysstk                                                    ; bottom of system stack
   367                          stkend           = $1fb                                   ; top of system stack
   368                          
   369                          ; .page
   370                                           * = $0200
   371                          
   372                          buflen           = 161                                    ; input buffer size (2 80-column lines + 1)
   373  0200 0000000000000000...buf              !fill buflen                             ; BASIC/Monitor line input buffer
   374                          buf_txtptr       = buf-1
   375                          
   376                          ; .page
   377                                           * = $02c0
   378                          ; BASIC RAM code  (RAM code not needed- following moved to ROM)
   379                          ;
   380                          ; chrget *=*+42  ;get byte from text bank after incrementing TXTPTR
   381                          ; chrgot = chrget+2 ;get byte from text bank at TXTPTR
   382                          ; qnum  = chrget+27 ;evaluate byte as a number & set flags accordingly
   383                          
   384  02c0 0000               adray1           !fill 2                                  ; ptr to routine:  convert float -> integer ???? why keep
   385  02c2 0000               adray2           !fill 2                                  ; ptr to routine:  convert integer -> float ???? why keep
   386  02c4 000000             zero             !fill 3                                  ; numeric constant for BASIC, downloaded from ROM
   387                          
   388  02c7 00                 errnum           !fill 1                                  ; used by error trapping routine-last error number
   389  02c8 0000               errlin           !fill 2                                  ; line # of last error ($FFFF if no error)
   390  02ca 0000               trapno           !fill 2                                  ; line to go to on error ($FFxx if none set)
   391  02cc 00                 tmptrp           !fill 1                                  ; hold trap # temporary
   392  02cd 0000               errtxt           !fill 2                                  ; pointer to statement causing last error
   393  02cf 0000               max_mem_0        !fill 2                                  ; highest address available to BASIC in RAM 0 (text bank)
   394                          
   395  02d1 00                 current_bank     !fill 1                                  ; context for PEEK,POKE,BOOT,SYS,WAIT,BLOAD/SAVE set by BANK.
   396  02d2 00                 fin_bank         !fill 1                                  ; bank pointer for string->number conversion routine FIN
   397  02d3 00000000           tmpdes           !fill 4                                  ; pointers to temporary descriptors for INSTR
   398  02d7 00                 bits             !fill 1                                  ; flag for math bit/byte shifter
   399  02d8 00                 highlight_color  !fill 1                                  ; color for highlighting text
   400  02d9 00                 highlight_save   !fill 1                                  ; saves normal color during highlighting, msb=flag
   401  02da 00                 find_count       !fill 1                                  ; count for LIST to highlight FIND text
   402                          
   403                          ; Interrupt stuff
   404                          
   405  02db 00                 irq_wrap_flag    !fill 1                                  ; used by BASIC_IRQ to block all but one IRQ call
   406  02dc 00                 intval           !fill 1                                  ; BASIC interrupts enabled (via collision command)
   407  02dd 000000             int_trip_flag    !fill 3                                  ; flags which interrupts occurred
   408  02e0 000000             int_adr_lo       !fill 3                                  ; where to go for each type of collision (line number)
   409  02e3 000000             int_adr_hi       !fill 3                                  ;
   410  02e6 0000               collisions       !fill 2                                  ; sprite collisions, s/s and s/bgnd, recorded during IRQ
   411  02e8 00                 lightpen_xpos    !fill 1                                  ; lightpen position recorded during IRQ
   412  02e9 00                 lightpen_ypos    !fill 1
   413                          
   414                          ; dejavu *=*+1  ;'cold' or 'warm' reset status (must be in page 5!)????
   415                          
   416                          ; nmi_wrap_flag *=*+1  ;used by BASIC_NMI to block all but one NMI call [910523]
   417                          ;    ; (removed)      [910826]
   418                          ;(leaving 12 bytes)
   419                          ; .page
   420                          ; BASIC indirect vectors
   421                          
   422                                           * = $02f7
   423                          
   424  02f7 000000             usrpok           !fill 3                                  ; USR vector (must be set by application)
   425                          
   426                          vectors_begin
   427  02fa 0000               iAutoScroll      !fill 2                                  ; AutoScroll vector
   428  02fc 0000               esc_fn_vec       !fill 2                                  ; Escape Function vector
   429  02fe 0000               graphic_vector   !fill 2                                  ; Graphic Kernel vector (was 'bnkvec')
   430  0300 0000               ierror           !fill 2                                  ; indirect error (output error in .x)
   431  0302 0000               imain            !fill 2                                  ; indirect main (system direct loop)
   432  0304 0000               icrnch           !fill 2                                  ; indirect crunch (tokenization routine)
   433  0306 0000               iqplop           !fill 2                                  ; indirect list (char list)
   434  0308 0000               igone            !fill 2                                  ; indirect gone (char dispatch)
   435  030a 0000               ieval            !fill 2                                  ; indirect eval (symbol evaluation)
   436  030c 0000               iesclk           !fill 2                                  ; escape token crunch
   437  030e 0000               iescpr           !fill 2                                  ; escape token list
   438  0310 0000               iescex           !fill 2                                  ; escape token execute
   439  0312 0000               itime            !fill 2                                  ; 60Hz interrupt vector (before jiffy)
   440  0314 0000               cinv             !fill 2                                  ; IRQ RAM vector
   441  0316 0000               cbinv            !fill 2                                  ; BRK RAM vector
   442                          
   443                          ; Remainder of this area reserved for Kernel indirects & Kernel RAM code
   444                          
   445                          ; .page
   446                                           * = $0400                                ; BASIC's run-time stack (2 pages)
   447                          stktop                                                    ; (also used by BOOT SYS and Monitor)
   448                          stkbot           = $05ff
   449                          
   450                          
   451                                           * = $0600                                ; Sprite definitions (2 pages, must be below $1000)
   452                          sprite_base
   453                          
   454                          
   455                                           * = $0800
   456                          screen_start                                              ; Text display screen
   457                                           * = *+2000
   458                          
   459                          sprite_ptrs_40   = screen_start+$3f8
   460                          sprite_ptrs_80   = screen_start+$7f8
   461                          
   462                          ; .page
   463                                           * = $1170                                ; previous to this used by Kernel
   464                          
   465  1170 0000               oldlin           !fill 2                                  ; BASIC storage
   466  1172 0000               oldtxt           !fill 2                                  ; BASIC storage
   467  1174 0000000000         rndx             !fill 5                                  ; Floating Point representation of last random #
   468                          
   469                          
   470                          ; Yet more temporaries shared by various routines
   471                          
   472                          window_temp                                               ; window  (4 bytes)
   473                          t3                                                        ; dcat  (1 byte)
   474                          renum_tmp_1                                               ; renumber (2 bytes)
   475  1179 0000               tmptxt           !fill 2                                  ; do/loop (2 bytes)
   476                          
   477                          t4                                                        ; dcat  (2 bytes)
   478                          renum_tmp_2                                               ; renumber (2 bytes)
   479  117b 0000               tmplin           !fill 2                                  ; do/loop (2 bytes)
   480                          
   481                          
   482                          ;  BASIC/DOS interface vars  (20 bytes)
   483                          
   484  117d 0000               dosofl           !fill 2                                  ; BLOAD/BSAVE starting addr
   485  117f 0000               dosofh           !fill 2                                  ; BSAVE ending addr
   486  1181 00                 dosla            !fill 1                                  ; DOS logical addr
   487  1182 00                 dosfa            !fill 1                                  ; DOS physical addr
   488  1183 00                 dossa            !fill 1                                  ; DOS secondary addr
   489                          
   490  1184 00                 xcnt             !fill 1                                  ; DOS loop counter------ this area zeroed-out each DOS call -----
   491  1185 00                 dosf1l           !fill 1                                  ; DOS filename 1 len
   492  1186 00                 dosds1           !fill 1                                  ; DOS disk drive 1
   493  1187 00                 dosf2l           !fill 1                                  ; DOS filename 2 len
   494  1188 00                 dosds2           !fill 1                                  ; DOS disk drive 2
   495  1189 0000               dosf2a           !fill 2                                  ; DOS filename 2 addr
   496  118b 00                 dosrcl           !fill 1                                  ; DOS record length
   497  118c 00                 dosbnk           !fill 1                                  ; DOS load/save bank
   498  118d 0000               dosdid           !fill 2                                  ; DOS ID identifier
   499  118f 00                 dosflags         !fill 1                                  ; DOS flags  7:ID,  6:recover
   500  1190 00                 dossa_temp       !fill 1                                  ; temp storage for file's sa during RECORD command
   501                          dosspc           = *-xcnt                                 ; space used by DOS routines-------------------------------------
   502                          
   503  1191 0000000000000000...savram           !fill 67                                 ; buffer used by MOVSPR, SPRDEF, SAVSPR, and DOS parser
   504                          
   505                          xabs             = savram                                 ; movspr_line calculations   [910809]
   506                          yabs             = savram+2
   507                          xsgn             = savram+4
   508                          ysgn             = savram+6
   509                          fct              = savram+8
   510                          errval           = savram+12
   511                          
   512                          ; .page
   513                          ; PRINT USING definitions & storage  (24 bytes)
   514                          
   515                          puchrs                                                    ; Declarations for PRINT USING...
   516  11d4 00                 pufill           !fill 1                                  ; print using fill symbol
   517  11d5 00                 pucoma           !fill 1                                  ; print using comma symbol
   518  11d6 00                 pudot            !fill 1                                  ; print using decimal point symbol
   519  11d7 00                 pumony           !fill 1                                  ; print using monetary symbol
   520                          
   521  11d8 00                 bnr              !fill 1                                  ; pointer to begin #
   522  11d9 00                 enr              !fill 1                                  ; pointer to end #
   523  11da 00                 dolr             !fill 1                                  ; dollar flag
   524  11db 00                 flag             !fill 1                                  ; comma flag (also used by PLAY)????
   525  11dc 00                 swe              !fill 1                                  ; counter
   526  11dd 00                 usgn             !fill 1                                  ; sign exponent
   527  11de 00                 uexp             !fill 1                                  ; pointer to exponent
   528  11df 00                 vn               !fill 1                                  ; # of digits before decimal point
   529  11e0 00                 chsn             !fill 1                                  ; justify flag
   530  11e1 00                 vf               !fill 1                                  ; # of positions before decimal point (field)
   531  11e2 00                 nf               !fill 1                                  ; # of positions after decimal point (field)
   532  11e3 00                 posp             !fill 1                                  ; +/- flag (field)
   533  11e4 00                 fesp             !fill 1                                  ; exponent flag (field)
   534  11e5 00                 etof             !fill 1                                  ; switch
   535  11e6 00                 cform            !fill 1                                  ; char counter (field)
   536  11e7 00                 sno              !fill 1                                  ; sign no
   537  11e8 00                 blfd             !fill 1                                  ; blank/star flag
   538  11e9 00                 begfd            !fill 1                                  ; pointer to begin of field
   539  11ea 00                 lfor             !fill 1                                  ; length of format
   540  11eb 00                 endfd            !fill 1                                  ; pointer to end of field
   541                          
   542                          ; .page
   543                          ;  * = $1200 ;BASIC Graphic, Sprite, Music, & Sound storage
   544                          
   545                          ;  The following 24 bytes are multiply defined...
   546                          ;
   547                          ; params = *
   548                          
   549                          ;  Circle drawing variables  (multiply defined).
   550                          ;
   551                          ; xcircl *=*+2  ;circle center, x coordinate
   552                          ; ycircl *=*+2  ;circle center, y coordinate
   553                          ; xradus *=*+2  ;x radius
   554                          ; yradus *=*+2  ;y radius
   555                          ; rotang *=*+4  ;rotation angle
   556                          ; angbeg *=*+2  ;arc angle start
   557                          ; angend *=*+2  ;arc angle end
   558                          ; xrcos  *=*+2  ;x radius * cos(rotation angle)
   559                          ; yrsin  *=*+2  ;y radius * sin(rotation angle)
   560                          ; xrsin  *=*+2  ;x radius * sin(rotation angle)
   561                          ; yrcos  *=*+2  ;y radius * cos(rotation angle)
   562                          
   563                          ; parend = *
   564                          
   565                          ;  Box drawing variables  (multiply defined).
   566                          ;
   567                          ;  *=params
   568                          ; xcord1 *=*+2  ;point 1 x-coord.
   569                          ; ycord1 *=*+2  ;point 1 y-coord.
   570                          ; boxang *=*+2  ;rotation angle
   571                          ; xcount *=*+2
   572                          ; ycount *=*+2
   573                          ; bxleng *=*+2  ;length of a side
   574                          ; xcord2 *=*+2
   575                          ; ycord2 *=*+2
   576                          
   577                          ; .page
   578                          ;  Shape variables  (multiply defined).
   579                          ;
   580                          ;  *=params
   581                          ;  *=*+1  ;placeholder
   582                          ; keylen *=*+1
   583                          ; keynxt *=*+1
   584                          ; strsz  *=*+1  ;string len
   585                          ; gettyp *=*+1  ;replace shape mode
   586                          ; strptr *=*+1  ;string pos'n counter
   587                          ; oldbyt *=*+1  ;old bit map byte
   588                          ; newbyt *=*+1  ;new string or bit map byte
   589                          ;  *=*+1  ;placeholder
   590                          ; xsize  *=*+2  ;shape column length
   591                          ; ysize  *=*+2  ;shape row length
   592                          ; xsave  *=*+2  ;temp for column length
   593                          ; stradr *=*+2  ;save shape string descriptor
   594                          ; bitidx *=*+1  ;bit index into byte
   595                          
   596                          ;  General use parameters  (multiply defined).
   597                          ;
   598                          ;  *=params
   599                          ; xcentr *=*+2
   600                          ; ycentr *=*+2
   601                          ; xdist1 *=*+2
   602                          ; ydist1 *=*+2
   603                          ; xdist2 *=*+2
   604                          ; ydist2 *=*+2
   605                          ; disend
   606                          ;  *=*+2  ;placeholder
   607                          ; colcnt *=*+1  ;char's col. counter
   608                          ; rowcnt *=*+1
   609                          ; strcnt *=*+1
   610                          
   611                          ; .page
   612                          ;  General  graphic & sound  buffers & assignments
   613                          ;
   614                          ;  * = parend
   615                          
   616                          ;  General graphic storage (used by C128-type sprite routines in C65)
   617                          
   618                          vwork                                                     ; graphics & sprite vars
   619  11ec 0000               xpos             !fill 2                                  ; current x position
   620  11ee 0000               ypos             !fill 2                                  ; current y position
   621  11f0 0000               xdest            !fill 2                                  ; x-coordinate destination
   622  11f2 0000               ydest            !fill 2                                  ; y-coordinate destination
   623                          
   624  11f4 00                 numcnt           !fill 1                                  ; temp, usually coordinate type
   625  11f5 00                 vtemp1           !fill 1                                  ; used by sprite math stuff ????was base page
   626  11f6 00                 vtemp2           !fill 1                                  ; ????was base page
   627  11f7 00                 vtemp3           !fill 1                                  ; misc. graphic temp storage
   628  11f8 00                 vtemp4           !fill 1
   629  11f9 00                 vtemp5           !fill 1
   630                          
   631                          ; mvdflg *=*+1  ;flag if 10k hires allocated ???? this stuff was base page
   632                          ; colsel *=*+1  ;current color selected
   633                          ; multicolor_1 *=*+1
   634                          ; multicolor_2 *=*+1
   635                          ; foreground *=*+1
   636                          ; scalem *=*+1  ;scale mode flag
   637                          ; scale_x *=*+2  ;scale factor in x
   638                          ; scale_y *=*+2  ;scale factor in y
   639                          ; stopnb *=*+1  ;stop paint if not background/not same color
   640                          ; fg_bg  *=*+1  ;packed foreground/background color nybbles
   641                          ; fg_mc1 *=*+1  ;packed foreground/multicolor 1 color nybbles
   642                          
   643                          ; bitcnt *=*+1  ;temp for gshape
   644                          ; width  *=*+1  ;double width flag
   645                          ; filflg *=*+1  ;box fill flag
   646                          ; circle_segment *=*+1  ;degrees per circle segment
   647                          ; bitmsk *=*+1  ;temp for bit mask
   648                          
   649                          ; character_rom *=*+1  ;high byte of address of char rom for 'char' command
   650                          ; upper_lower *=*+1  ;pointer to upper/lower case for char command
   651                          ; upper_graphic *=*+1  ;   "       upper/graphic
   652                          
   653                          ;  DrawLine stuff
   654                          ;
   655                          ; xabs  *=*+2  ;16 bytes
   656                          ; yabs  *=*+2
   657                          ; xsgn  *=*+2
   658                          ; ysgn  *=*+2
   659                          ; fct  *=*+4
   660                          ; errval *=*+2
   661                          ; lesser *=*+1
   662                          ; greatr *=*+1
   663                          ; .page
   664                          ;  Angle stuff (used by sprites)
   665                          
   666  11fa 00                 angsgn           !fill 1                                  ; sign of angle
   667  11fb 0000               sinval           !fill 2                                  ; sine of value of angle
   668  11fd 0000               cosval           !fill 2                                  ; cosine of value of angle
   669                          ; angcnt *=*+2  ;temps for angle distance routines
   670                          
   671                          
   672                          ; Sprite stuff
   673                          
   674  11ff 00000000           savsiz           !fill 4                                  ; temp work locations for SSHAPE, SPRSAV, MOVSPR_TO
   675                          lesser
   676  1203 00                 sprtmp_1         !fill 1                                  ; temp for SPRSAV
   677                          greatr
   678  1204 00                 sprtmp_2         !fill 1
   679                          
   680  1205 0000000000000000...sprite_data      !fill 88                                 ; speed/direction tables for 8 sprites, 11 bytes each
   681                          ;   move ang/dist move line
   682                          ; offset= 0 b7=0+speed b7=1+speed
   683                          ;  1 counter  counter lo
   684                          ;  2 angle sign         hi
   685                          ;  3,4 delta-X  dir+min/max
   686                          ;  5,6 delta-Y  fct1
   687                          ;  7,8 total-X  fct2
   688                          ;  9,10 total-Y  error
   689                          
   690                          init_as_0        = *-sprite_data-1
   691                          
   692                          ; vic_save *=*+21  ;copy of VIC reg's, used to update chip during retrace
   693                          
   694                          ; defmod *=*+1  ;for SPRDEF
   695                          ; lincnt *=*+1  ; "
   696                          ; sprite_number *=*+1  ; "
   697                          
   698                          ; .page
   699                          ; Music stuff driving stereo SIDs, 3 voices each
   700                          
   701  125d 0000000000000000...voices           !fill 12                                 ; Voice counters (activity flags)  [910612] stereo
   702  1269 000000000000       waveform         !fill 6                                  ; Waveforms for each voice   [910612] stereo
   703                          
   704  126f 00                 voice            !fill 1                                  ; Play note parameters
   705  1270 00                 octave           !fill 1
   706  1271 00                 sharp            !fill 1
   707  1272 00                 dnote            !fill 1
   708  1273 00                 tempo_rate       !fill 1                                  ; duration of whole note 4/4 time = 24/rate
   709  1274 0000               pitch            !fill 2
   710  1276 0000               ntime            !fill 2
   711                          
   712  1278 00000000           filters1         !fill 4                                  ; Volume & Filter parameters   [910612] was 5
   713  127c 00000000           filters2         !fill 4                                  ; [910612] stereo
   714  1280 00000000           fltsav           !fill 4                                  ; temps
   715  1284 00                 fltflg           !fill 1                                  ; temp
   716                          
   717  1285 00                 tonnum           !fill 1                                  ; Tune Envelope stuff
   718  1286 000000             tonval           !fill 3
   719                          
   720  1289 0000000000000000...atktab           !fill 10                                 ; Tune Envelopes
   721  1293 0000000000000000...sustab           !fill 10
   722  129d 0000000000000000...wavtab           !fill 10
   723  12a7 0000000000000000...pulslw           !fill 10
   724  12b1 0000000000000000...pulshi           !fill 10
   725                          
   726  12bb 00                 parcnt           !fill 1                                  ; temp: envelope
   727  12bc 00                 nibble           !fill 1                                  ; temp: envelope, filter
   728                          
   729                          ; .page
   730                          ; SOUND command stuff
   731                          
   732  12bd 00                 sound_voice      !fill 1
   733  12be 000000000000       sound_time_lo    !fill 3+3                                ; [910612] stereo
   734  12c4 000000000000       sound_time_hi    !fill 3+3                                ; [910612] stereo
   735  12ca 000000000000       sound_max_lo     !fill 3+3                                ; [910612] stereo
   736  12d0 000000000000       sound_max_hi     !fill 3+3                                ; [910612] stereo
   737  12d6 000000000000       sound_min_lo     !fill 3+3                                ; [910612] stereo
   738  12dc 000000000000       sound_min_hi     !fill 3+3                                ; [910612] stereo
   739  12e2 000000000000       sound_direction  !fill 3+3                                ; [910612] stereo
   740  12e8 000000000000       sound_step_lo    !fill 3+3                                ; [910612] stereo
   741  12ee 000000000000       sound_step_hi    !fill 3+3                                ; [910612] stereo
   742  12f4 000000000000       sound_freq_lo    !fill 3+3                                ; [910612] stereo
   743  12fa 000000000000       sound_freq_hi    !fill 3+3                                ; [910612] stereo
   744                          
   745                          ;above must end before $1300
   746                                           * = $1160
   747                          ;below must end before $1170
   748                          
   749  1160 00                 temp_time_lo     !fill 1
   750  1161 00                 temp_time_hi     !fill 1
   751  1162 00                 temp_max_lo      !fill 1
   752  1163 00                 temp_max_hi      !fill 1
   753  1164 00                 temp_min_lo      !fill 1
   754  1165 00                 temp_min_hi      !fill 1
   755  1166 00                 temp_direction   !fill 1
   756  1167 00                 temp_step_lo     !fill 1
   757  1168 00                 temp_step_hi     !fill 1
   758  1169 00                 temp_freq_lo     !fill 1
   759  116a 00                 temp_freq_hi     !fill 1
   760  116b 00                 temp_pulse_lo    !fill 1
   761  116c 00                 temp_pulse_hi    !fill 1
   762  116d 00                 temp_waveform    !fill 1
   763                          
   764  116e 00                 pot_temp_1       !fill 1                                  ; temporaries for 'POT' function
   765  116f 00                 pot_temp_2       !fill 1
   766                          
   767                          ; .page
   768                                           * = $1300
   769                          
   770  1300 0000000000000000...dosstr           !fill 256                                ; DOS input/output string buffer
   771                          
   772                          ; .page
   773                                           * = $1f00                                ; Graphics Kernel Interface
   774                          
   775  1f00 00                 GKI__parm1       !fill 1                                  ; ml interface parm values
   776  1f01 00                 GKI__parm2       !fill 1
   777  1f02 00                 GKI__parm3       !fill 1
   778  1f03 00                 GKI__parm4       !fill 1
   779  1f04 00                 GKI__parm5       !fill 1
   780  1f05 00                 GKI__parm6       !fill 1
   781  1f06 00                 GKI__parm7       !fill 1
   782  1f07 00                 GKI__parm8       !fill 1
   783  1f08 00                 GKI__parm9       !fill 1
   784  1f09 00                 GKI__parm10      !fill 1
   785  1f0a 00                 GKI__parm11      !fill 1
   786  1f0b 00                 GKI__parm12      !fill 1
   787  1f0c 00                 GKI__parm13      !fill 1
   788  1f0d 00                 GKI__parm14      !fill 1
   789  1f0e 00                 GKI__parm15      !fill 1
   790  1f0f 00                 GKI__parm16      !fill 1
   791  1f10 00                 GKI__parm17      !fill 1
   792                          
   793  1f11 00                 GKI__subparm1    !fill 1                                  ; subroutine parm values
   794  1f12 00                 GKI__subparm2    !fill 1
   795  1f13 00                 GKI__subparm3    !fill 1
   796  1f14 00                 GKI__subparm4    !fill 1
   797  1f15 00                 GKI__subparm5    !fill 1
   798                          
   799  1f16 00                 GKI__temp1       !fill 1                                  ; local variables within subroutines
   800  1f17 00                 GKI__temp2       !fill 1
   801  1f18 00                 GKI__temp3       !fill 1
   802  1f19 00                 GKI__temp4       !fill 1
   803  1f1a 00                 GKI__temp5       !fill 1
   804  1f1b 00                 GKI__temp6       !fill 1
   805  1f1c 00                 GKI__temp7       !fill 1
   806  1f1d 00                 GKI__temp8       !fill 1
   807  1f1e 00                 GKI__temp9       !fill 1
   808  1f1f 00                 GKI__temp10      !fill 1
   809  1f20 00                 GKI__temp11      !fill 1
   810  1f21 00                 GKI__temp12      !fill 1
   811  1f22 00                 GKI__temp13      !fill 1
   812  1f23 00                 GKI__temp14      !fill 1
   813  1f24 00                 GKI__temp15      !fill 1
   814  1f25 00                 GKI__temp16      !fill 1
   815  1f26 00                 GKI__temp17      !fill 1
   816                          
   817                          ;.end
   818                          ; .page
   819                          ; .subttl C65 Kernal Entry Points
   820                          
   821                          ; Addresses of OS parameters referenced by BASIC:
   822                          
   823                          _6510_data_reg   = $01
   824                          _bank            = $02                                    ; reg's for Kernel xxx_FAR routines (used by SYS)
   825                          _pchi            = $03
   826                          _pclo            = $04
   827                          _s_reg           = $05
   828                          _a_reg           = $06
   829                          _x_reg           = $07
   830                          _y_reg           = $08
   831                          _z_reg           = $09
   832                          
   833                          _vicIRQ          = $a0                                    ; VIC IRQ flag register at time of IRQ
   834                          _starting_addr   = $ac                                    ; address BLOAD loaded to
   835                          _sa              = $b9                                    ; I/O channel secondary address
   836                          _fa              = $ba                                    ; I/O channel device number
   837                          _ndx             = $d0                                    ; number of characters in keyboard buffer
   838                          _kyndx           = $d1                                    ; fkey active flag
   839                          _mode            = $d7                                    ; 40/80 mode
   840                          _graphm          = $d8                                    ; graphic mode switch (multi/hires/split)
   841                          _pnt             = $e0                                    ; Editor screen address at cursor
   842                          
   843                          _screen_bottom   = $e4                                    ; these describe the current window
   844                          _screen_top      = $e5
   845                          _screen_left     = $e6
   846                          _screen_right    = $e7
   847                          
   848                          _color           = $f1                                    ; text color      [910722]
   849                          _autoinsert      = $f6                                    ; enable/disable auto insert mode
   850                          _locks           = $f7                                    ; Editor keyboard locks     [910722]
   851                          
   852                          _keyd            = $02b0                                  ; keyboard buffer     [910710]
   853                          ;_split = $0a34  ;line to start split at
   854                          
   855                          number_fkeys     = 16                                     ; max of 14 prog. fn. keys
   856                          _pky_lengths     = $1000                                  ; table of prog. fn. key sizes
   857                          _pky_buffer      = _pky_lengths+number_fkeys              ; actual buffer
   858                          
   859                          _restart_vector  = $1100                                  ; Kernel restart vector
   860                          _pal_ntsc        = $1103                                  ; PAL=$ff, NTSC=$00 indicator    [910107]
   861                          _init_status     = $1104                                  ; msb set tells Kernel to let BASIC have IRQs
   862                          _default_drive   = $1106                                  ; system default disk drive
   863                          _expansion       = $1107                                  ; expansion RAM (# banks????)    [910107]
   864                          _sleep_counter   = $110c                                  ; binary frame counter maintained by Kernel  [910730]
   865                          _mouse_enable    = $1135                                  ; port# used by mouse (b7=port2, b6=port1, or both) [910107]
   866                          _mouse_pointer   = $1136                                  ; sprite pointer (sprite*2) by Kernel mouse driver "
   867                          _mouse_top       = $113b                                  ; margins for mouse pointer    "
   868                          _mouse_bottom    = $113c                                  ; "
   869                          _mouse_left      = $113d                                  ; "
   870                          _mouse_right     = $113e                                  ; "
   871                          
   872                          ; Addresses of I/O areas referenced by BASIC:
   873                          
   874                          _red             = $d100                                  ; VIC palette (I/O block)
   875                          _green           = $d200
   876                          _blue            = $d300
   877                          
   878                          ; Addresses of Kernel entry points referenced by BASIC:
   879                          
   880                          _print           = $e00c
   881                          _mouse           = $e01b                                  ; [910122]
   882                          _set_window      = $e02d
   883                          _palette_init    = $e027
   884                          _cursor          = $e030                                  ; [910228]
   885                          ;_ldtb2 = $e033
   886                          ;_ldtb1 = $e04c
   887                          
   888                          _close_all       = $ff50                                  ; close all channels assigned to device .a
   889                          _go_64           = $ff53                                  ; C64 mode
   890                          _monitor         = $ff56                                  ; ML Monitor
   891                          _bootsys         = $ff59                                  ; Boot alternate OS     [910110]
   892                          _phoenix         = $ff5c                                  ; jump to 'post-BASIC initialize' routine
   893                          _lkupla          = $ff5f                                  ; find an available Logical Address
   894                          _lkupsa          = $ff62                                  ; find an available Secondary Address
   895                          _swapper         = $ff65                                  ; switch 80/40 column
   896                          _doakey          = $ff68                                  ; add/remove a definition from the p.f. key table
   897                          _setbank         = $ff6b                                  ; set bank for load/save/verify/open
   898                          _jsr_far         = $ff6e                                  ; call a subroutine in any bank
   899                          _jmp_far         = $ff71                                  ; jump to code in any bank
   900                          _lda_far         = $ff74                                  ; write a byte to any bank
   901                          _sta_far         = $ff77                                  ; read a byte from any bank
   902                          _cmp_far         = $ff7a                                  ; compare a byte to any bank
   903                          _primm           = $ff7d                                  ; print immediate
   904                          
   905                          _setmsg          = $ff90
   906                          _readst          = $ffb7
   907                          _setlfs          = $ffba
   908                          _setnam          = $ffbd
   909                          _open            = $ffc0
   910                          _close           = $ffc3
   911                          _chkin           = $ffc6
   912                          _chkout          = $ffc9
   913                          _clrch           = $ffcc
   914                          _basin           = $ffcf
   915                          _bsout           = $ffd2
   916                          _loadsp          = $ffd5
   917                          _savesp          = $ffd8
   918                          _SetTime         = $ffdb
   919                          _ReadTime        = $ffde
   920                          _stop            = $ffe1
   921                          _getin           = $ffe4
   922                          _clall           = $ffe7
   923                          _screen_org      = $ffed
   924                          _plot            = $fff0
   925                          
   926                          ;.end
   927                          ; .page
   928                          ; .subttl C65 BASIC 10.0 Initilaization
   929                          
   930                          ; ***************************************************************************************************************
   931                          ; ***************************************************************************************************************
   932                          ;
   933                          ;      Name:       patch.asm
   934                          ;      Purpose:    Fixes
   935                          ;      Created:    4th January 2020
   936                          ;      Author:     Paul Robson (paul@robsons.org.uk)
   937                          ;
   938                          ; ***************************************************************************************************************
   939                          ; ***************************************************************************************************************
   940                          
   941                          ; ***************************************************************************************************************
   942                          ;
   943                          ;				At present ACME does not support BRA opcode $83. BRL replaces this.
   944                          ;
   945                          ; ***************************************************************************************************************
   946                          
   947                          !macro lbra addr {
   948                          	!byte $83
   949                          	!word (addr-*-1) & $FFFF
   950                          }
   951                          
   952                          !macro lbcc addr {
   953                          	!byte $93
   954                          	!word (addr-*-1) & $FFFF
   955                          }
   956                          
   957                          !macro lbcs addr {
   958                          	!byte $B3
   959                          	!word (addr-*-1) & $FFFF
   960                          }
   961                          
   962                          !macro lbne addr {
   963                          	!byte $D3
   964                          	!word (addr-*-1) & $FFFF
   965                          }
   966                          
   967                          !macro lbeq addr {
   968                          	!byte $F3
   969                          	!word (addr-*-1) & $FFFF
   970                          }
   971                          
   972                          !macro lbpl addr {
   973                          	!byte $13
   974                          	!word (addr-*-1) & $FFFF
   975                          }
   976                          
   977                          !macro lbmi addr {
   978                          	!byte $33
   979                          	!word (addr-*-1) & $FFFF
   980                          }
   981                          
   982                          !macro lbvs addr {
   983                          	!byte $73
   984                          	!word (addr-*-1) & $FFFF
   985                          }
   986                          
   987                          !macro lbvc addr {
   988                          	!byte $53
   989                          	!word (addr-*-1) & $FFFF
   990                          }
   991                                           * = $2000
   992                          
   993                          basic
   994  2000 4c2520                              jmp hard_reset
   995  2003 4c0c20                              jmp soft_reset
   996  2006 4c7579                              jmp basic_irq
   997  2009 4c06bf                              jmp basic_nmi                            ; (removed)    [910523] audio
   998                          
   999                          soft_reset                                                ; warm start BASIC...
  1000  200c 20b438                              jsr release_channels                     ; restore default terminal I/O channels
  1001  200f a900                                lda #doslfn                              ; restore reserved disk channel
  1002  2011 38                                  sec                                      ; not a real close
  1003  2012 20c3ff                              jsr _close
  1004  2015 208278                              jsr Clear_DS                             ; zap DS$ just in case
  1005                          ; (might have been in Monitor or building DS$)
  1006  2018 200d21                              jsr init_sound_sprites                   ; init interrupt & dma stuff   [910523]
  1007  201b 200935                              jsr init_stack                           ; restore stack
  1008  201e a901                                lda #1
  1009  2020 0c0411                              tsb _init_status                         ; tell Kernel to give BASIC a call at IRQ time
  1010  2023 802e                                bra go_ready                             ; enable IRQ, print READY, and go MAIN
  1011                          
  1012                          
  1013                          hard_reset
  1014  2025 205f22                              jsr init_vectors                         ; init vectors
  1015  2028 205720                              jsr init_storage                         ; init variables, voices,  & download RAM code
  1016  202b 203321                              jsr signon_message                       ; print initialization message
  1017                          
  1018  202e a900                                lda #0                                   ; init bank pointers   [900509]
  1019  2030 8584                                sta text_bank
  1020  2032 8555                                sta helper                               ; reset all LIST flags
  1021  2034 a901                                lda #1
  1022  2036 8585                                sta var_bank
  1023  2038 a902                                lda #2
  1024  203a 8dd802                              sta highlight_color                      ; set highlight color (2=red)
  1025  203d a203                                ldx #<basic+3
  1026  203f 8e0011                              stx _restart_vector                      ; point system restart vector at warm start entry
  1027  2042 200935                              jsr init_stack                           ; initialize system stack pointer
  1028  2045 a901                                lda #1
  1029  2047 0c0411                              tsb _init_status                         ; tell Kernel to give BASIC a call at IRQ time
  1030  204a 220080                              jsr ($8000)                              ; initialize graphics
  1031  204d 205cff                              jsr _phoenix                             ; call cartridges, check out expansion card
  1032  2050 20a467                              jsr autobootCSG                          ; attempt to boot program from disk
  1033                          
  1034                          go_ready
  1035  2053 58                                  cli                                      ; enable IRQ
  1036  2054 83f70d                              +lbra ready
  1037                          
  1038                          ; .page
  1039                          init_storage
  1040  2057 a94c                                lda #76                                  ; 'jmp' opcode
  1041  2059 8556                                sta jmper
  1042  205b 8df702                              sta usrpok
  1043                          
  1044  205e a9e8                                lda #<errguf                             ; init USR vector to 'undef'd function'  [910226] FAB
  1045  2060 a058                                ldy #>errguf
  1046  2062 8df802                              sta usrpok+1
  1047  2065 8cf902                              sty usrpok+2
  1048                          
  1049  2068 a99f                                lda #<flpint                             ; ???? why keep
  1050  206a a058                                ldy #>flpint
  1051  206c 8dc002                              sta adray1
  1052  206f 8cc102                              sty adray1+1
  1053                          
  1054  2072 a93f                                lda #<givayf                             ; ???? why keep
  1055  2074 a04e                                ldy #>givayf
  1056  2076 8dc202                              sta adray2
  1057  2079 8cc302                              sty adray2+1
  1058                          
  1059                          ; Download CHRGET (and INDSUB code????) to RAM
  1060                          ;
  1061                          ; ldx #endmov-chrget_pattern
  1062                          ;1$ lda chrget_pattern-1,x
  1063                          ; sta chrget-1,x
  1064                          ; dex
  1065                          ; bne 1$
  1066                          
  1067  207c a200                                ldx #0
  1068  207e 8ec402                              stx zero                                 ; zero constant
  1069  2081 8ec502                              stx zero+1
  1070  2084 8ec602                              stx zero+2
  1071  2087 8ed702                              stx bits                                 ; reset bit/byte shifter
  1072  208a 8615                                stx channl                               ; default channels
  1073  208c 867e                                stx runmod                               ; direct mode
  1074  208e 861a                                stx lastpt+1
  1075  2090 8674                                stx autinc                               ; turn off auto increment
  1076  2092 8675                                stx autinc+1
  1077  2094 8e7411                              stx rndx                                 ; zero-ing MSB will guarantee a legal value
  1078                          ; stx dosfa  ;zero device number     [910429]
  1079                          
  1080  2097 8edc02                              stx intval                               ; reset all BASIC IRQ stuff
  1081  209a 8edd02                              stx int_trip_flag                        ; (BASIC IRQ enabled in init_voices)
  1082  209d 8ede02                              stx int_trip_flag+1
  1083  20a0 8edf02                              stx int_trip_flag+2
  1084  20a3 8ee802                              stx lightpen_xpos
  1085  20a6 8ee902                              stx lightpen_ypos
  1086                          
  1087                          ; stx mvdflg  ;flag '8k graphics screen not allocated'
  1088                          ; stx width  ;init to single-width lines
  1089                          ; stx scalem  ;turn off scaleing
  1090                          ; stx filflg
  1091                          
  1092                          ; inx   ;.x=1 ???? why init stack with $0101 ????
  1093                          ; stx buf-3
  1094                          ; stx buf-4
  1095                          
  1096                          ; ldy #88   ;zero out sprite information area
  1097                          ;2$ sta sprite_data,y ;???? this is done later at init_as_0
  1098                          ; dey
  1099                          ; bpl 2$
  1100                          
  1101                          ; ldx #13
  1102                          ; stx foreground  ;init bit map's fg color to light green
  1103                          ; ldx #1
  1104                          ; stx multicolor_1 ;init mc1 to white
  1105                          ; ldx #2
  1106                          ; stx multicolor_2 ;init mc2 to red
  1107                          ; jsr set_packed_color ;set up packed fg/bg and fg/mc1 bytes
  1108                          
  1109  20a9 ae0611                              ldx _default_drive
  1110  20ac 8e8211                              stx dosfa                                ; init device number to system default   [910429]
  1111                          
  1112  20af a280                                ldx #$80                                 ; bank 0 with I/O????
  1113  20b1 8ed102                              stx current_bank                         ; set default bank for PEEK,POKE,BOOT,SYS,WAIT,BLOAD/SAVE
  1114                          
  1115  20b4 a21b                                ldx #tempst
  1116  20b6 8618                                stx temppt                               ; init temp descriptor pointer
  1117                          
  1118  20b8 a201                                ldx #<baswrk                             ; set up bottom of bank 0 (text area)
  1119  20ba a020                                ldy #>baswrk
  1120  20bc 862d                                stx txttab
  1121  20be 842e                                sty txttab+1
  1122                          
  1123  20c0 a900                                lda #<varbgn                             ; set up bottom of bank 1 (storage area)
  1124  20c2 a020                                ldy #>varbgn
  1125  20c4 852f                                sta vartab
  1126  20c6 8430                                sty vartab+1
  1127                          
  1128  20c8 a900                                lda #<bank_0_top                         ; set up top of bank 0
  1129  20ca a080                                ldy #>bank_0_top
  1130  20cc 8dcf02                              sta max_mem_0
  1131  20cf 8cd002                              sty max_mem_0+1
  1132                          
  1133  20d2 a900                                lda #<bank_1_top                         ; set up  top of bank 1
  1134  20d4 a080                                ldy #>bank_1_top
  1135  20d6 8539                                sta max_mem_1
  1136  20d8 843a                                sty max_mem_1+1
  1137                          
  1138  20da a900                                lda #0                                   ; init text input buffer  (these are for autoboot)
  1139  20dc 8d0002                              sta buf
  1140  20df 3a                                  dec
  1141  20e0 853c                                sta curlin+1                             ; init line pointer
  1142  20e2 a2ff                                ldx #<buf_txtptr                         ; init txtptr
  1143  20e4 a001                                ldy #>buf_txtptr
  1144  20e6 863d                                stx txtptr
  1145  20e8 843e                                sty txtptr+1
  1146                          
  1147                          ; Set up sprite pointers
  1148                          
  1149  20ea a91f                                lda #sprite_base/64+7
  1150  20ec a007                                ldy #7
  1151  20ee 7fd705             l1_1             bbr7 _mode,l1_2
  1152  20f1 99f80b                              sta sprite_ptrs_40,y                     ; 40 col screen
  1153  20f4 8003                                bra l1_3
  1154  20f6 99f80f             l1_2             sta sprite_ptrs_80,y                     ; 80 col screen
  1155  20f9 3a                 l1_3             dec
  1156  20fa 88                                  dey
  1157  20fb 10f1                                bpl l1_1
  1158                          
  1159                          ; Zero out sprite movement stuff and some VIC stuff too
  1160                          
  1161  20fd a900                                lda #0
  1162  20ff a257                                ldx #init_as_0
  1163  2101 9d0512             l1_4             sta sprite_data,x
  1164  2104 ca                                  dex
  1165  2105 10fa                                bpl l1_4
  1166                          
  1167  2107 200d21                              jsr init_sound_sprites                   ; init misc. interrupt & dma stuff
  1168                          
  1169                          ; lda #$d0  ;initialize pointers to character ROM
  1170                          ; sta upper_graphic
  1171                          ; lda #$d8
  1172                          ; sta upper_lower
  1173                          
  1174  210a 836c13                              +lbra init_text                          ; go to 'new'
  1175                          
  1176                          ; .page
  1177                          init_sound_sprites                                          ; [910523]
  1178                          ;; init_voices   ;Initialize music stuff
  1179                          ; bit _pal_ntsc  ;determine if PAL or NTSC system  [910724]
  1180                          ; bmi 1$   ;...branch if PAL
  1181                          ; lda #<beats_ntsc/4 ;set beat to quarter note (4/4 time = .5 sec)
  1182                          ; ldy #>beats_ntsc/4
  1183                          ; bra 2$
  1184                          ;1$ lda #<beats_pal/4
  1185                          ; ldy #>beats_pal/4
  1186                          ;2$ sta ntime
  1187                          ; sty ntime+1
  1188                          ;
  1189                          ; lda #4   ;set default octave
  1190                          ; sta octave
  1191                          ;
  1192                          ; lda #12   ;set default tempo    [910220]
  1193                          ; sta tempo_rate  ; 12 makes whole note in 4/4 time last 2 seconds
  1194                          ;----
  1195                          ;; jsr go_slow  ;      [910716] 4567R7A
  1196                          ; lda #0   ;make sure all gates are off
  1197                          ; sta sid1+4
  1198                          ; sta sid1+11
  1199                          ; sta sid1+18
  1200                          ; sta sid2+4
  1201                          ; sta sid2+11
  1202                          ; sta sid2+18
  1203                          ; sta filters1+2  ;set filters off, volume to max????  [910612]
  1204                          ; sta filters2+2
  1205                          ;
  1206                          ; lda #8
  1207                          ; sta sid1+24
  1208                          ; sta sid2+24
  1209                          ; sta filters1+3
  1210                          ; sta filters2+3  ;      [910612]
  1211                          ;; sta filters+4  ;why?      [910612]
  1212                          ;; jsr go_fast  ;      [910716] 4567R7A
  1213                          ;----
  1214                          ; ldy #29   ;initialize music tables
  1215                          ;10$ lda atkmus,y
  1216                          ; sta atktab,y
  1217                          ; dey
  1218                          ; bpl 10$
  1219                          ;
  1220                          ; ldx #9   ;initialize pulse widths
  1221                          ;20$ lda pwhmus,x
  1222                          ; sta pulshi,x
  1223                          ; dex
  1224                          ; bpl 20$
  1225                          ;
  1226                          ; stx sound_time_hi ;turn all SOUND counters off (.X = $ff)
  1227                          ; stx sound_time_hi+1
  1228                          ; stx sound_time_hi+2
  1229                          ; stx sound_time_hi+3 ;stereo SIDs     [910612]
  1230                          ; stx sound_time_hi+4
  1231                          ; stx sound_time_hi+5
  1232                          ; stx voices+1  ;turn all PLAY counters off
  1233                          ; stx voices+3
  1234                          ; stx voices+5
  1235                          ; stx voices+7  ;stereo SIDs     [910612]
  1236                          ; stx voices+9
  1237                          ; stx voices+11
  1238                          ;
  1239                          ; ldy #6-1  ;set default envelope (piano) for all voices (6)
  1240                          ; sty voice
  1241                          ;30$ ldx #0
  1242                          ; jsr set_envelope_1
  1243                          ; dec voice
  1244                          ; bpl 30$
  1245                          ; inc voice  ;set default voice (0)
  1246                          ;-----
  1247  210d 2058be                              jsr Sound_CLR_1                          ; [910724]
  1248                          
  1249  2110 a9e7                                lda #%11100111                           ; [910626]
  1250  2112 1455                                trb helper                               ; reset LIST/HELP/FIND flags
  1251  2114 0cd902                              tsb highlight_save                       ; mark saved color as invalid
  1252                          
  1253  2117 a900                                lda #0                                   ; [910523] F018A
  1254  2119 a217                                ldx #12+12-1                             ; init DMA lists
  1255  211b 9d4401             l2_1             sta dma1_cmd,x
  1256  211e ca                                  dex
  1257  211f 10fa                                bpl l2_1
  1258                          
  1259                          ; stop_sprites   ;Stop all moving sprites (a=0)   [910523]
  1260  2121 a007                                ldy #7                                   ; for sprites 0...7
  1261  2123 befeb7             l2_2             ldx sproff,y                             ; get table offset
  1262  2126 9d0512                              sta sprite_data,x                        ; reset speed for this sprite
  1263  2129 88                                  dey
  1264  212a 10f7                                bpl l2_2                                 ; loop until done
  1265                          
  1266  212c 8d15d0                              sta vic+21                               ; Turn off all sprites    [910717]
  1267                          
  1268  212f 8ddb02                              sta irq_wrap_flag                        ; enable BASIC IRQ handler
  1269                          ; sta nmi_wrap_flag ;enable BASIC NMI handler   [910523]
  1270  2132 60                                  rts                                      ; (removed)    [910826]
  1271                          
  1272                          ; .page
  1273                          signon_message
  1274  2133 207dff             l3_1             jsr _primm
  1275  2136 93121c2020202020...                 !text 147,18,028,"                     ",146,169
  1276  2150 0509202020202020...                 !text 5,9,"       THE COMMODORE C65 DEVELOPMENT SYSTEM",cr
  1277  217e 1296202020202020...                 !text 18,150,"                  ",146,169,cr
  1278  2195 129e202020202020...                 !text 18,158,"               ",146,169
  1279  21a8 0509202020434f50...                 !text 5,9,"   COPYRIGHT  1991  COMMODORE ELECTRONICS, LTD.",cr
  1280  21da 121e202020202020...                 !text 18,030,"            ",146,169
  1281  21ea 0509090920202020...                 !text 5,9,9,9,"    COPYRIGHT  1977  MICROSOFT",cr
  1282  220d 129a202020202020...                 !text 18,154,"          ",146,169,cr
  1283  221c 129c202020202020...                 !text 18,156,"        ",146,169
  1284  2228 0509092042415349...                 !text 5,9,9," BASIC 10.0   V0.9B.911119    ALL RIGHTS RESERVED",cr,0
  1285                          
  1286  225e 60                                  rts
  1287                          
  1288                          ; .page
  1289                          init_vectors
  1290  225f a217                                ldx #l4_3-l4_2-1
  1291  2261 bd6b22             l4_1             lda l4_2,x
  1292  2264 9dfa02                              sta vectors_begin,x
  1293  2267 ca                                  dex
  1294  2268 10f7                                bpl l4_1
  1295                          
  1296  226a 60                                  rts
  1297                          
  1298                          
  1299  226b c37d               l4_2             !word AutoScroll                         ; autoscroll vector
  1300  226d 8f2d                                !word n_esc_fn_vec                       ; escape function vector
  1301  226f cd7f                                !word graphic_kernel                     ; graphic extension vector
  1302  2271 522e0a2f2223be33...                 !word nerror,nmain,ncrnch,nqplop,ngone,neval ; traditional vectors
  1303  227d 32234e34c02c                        !word nesclk,nescpr,nescex               ; escape command vectors
  1304                          l4_3
  1305                          
  1306                          ; .page
  1307                          ;; CHRGET/CHRGOT code.  It is downloaded to RAM.
  1308                          ;;
  1309                          ;chrget_pattern
  1310                          ; inw txtptr ;CHRGET entry
  1311                          ; phz  ;CHRGOT entry (chrget+2)
  1312                          ; phx
  1313                          ; lda #0
  1314                          ; ldx #$f0
  1315                          ; ldy #0
  1316                          ; ldz #$f0
  1317                          ; map
  1318                          ; ldy #0
  1319                          ; lda (txtptr),y
  1320                          ; phy
  1321                          ; pha
  1322                          ; jsr _restore_sys
  1323                          ; nop  ;unmap
  1324                          ; pla
  1325                          ; ply
  1326                          ; plx
  1327                          ; plz
  1328                          ;
  1329                          ; cmp #':' ;QNUM entry (chrget+27)
  1330                          ; bcs l4_2
  1331                          ; cmp #' '
  1332                          ; beq chrget_pattern
  1333                          ; sec
  1334                          ; sbc #'0'
  1335                          ; sec
  1336                          ; sbc #$d0
  1337                          ;l4_2 rts  ;(42 bytes to here)
  1338                          ;
  1339                          ;
  1340                          ;
  1341                          ;; Constants which must be moved to RAM
  1342                          ;
  1343                          ; .byte   0,0,0 ;zero, of course!
  1344                          ;
  1345                          ;endmov   ;(45 bytes to here)
  1346                          
  1347                          ; .page
  1348                          ; CHRGET/CHRGOT code.
  1349                          ;
  1350                          
  1351  2283 e33d               chrget           inw txtptr                               ; get next character from text
  1352  2285 a000               chrgot           ldy #0                                   ; re-get current character from text
  1353  2287 20c522                              jsr indtxt                               ; lda (txtptr),y from RAM0
  1354  228a c920               qnum             cmp #' '
  1355  228c f0f5                                beq chrget                               ; skip spaces
  1356  228e c93a               chrtst           cmp #':'                                 ; [910513]
  1357  2290 b006                                bcs l5_1                                 ; eol
  1358  2292 38                                  sec
  1359  2293 e930                                sbc #'0'                                 ; alpha or numeric?
  1360  2295 38                                  sec
  1361  2296 e9d0                                sbc #$d0
  1362  2298 60                 l5_1             rts
  1363                          
  1364                          
  1365                          ;.end
  1366                          ; .page
  1367                          ; C65 BASIC Indirect Load Subroutines
  1368                          
  1369                          
  1370                          inddef
  1371  2299 a950                                lda #defpnt
  1372  229b 803a                                bra lda_far_ram1
  1373                          
  1374                          indfrm
  1375  229d a93f                                lda #form
  1376  229f 8036                                bra lda_far_ram1
  1377                          
  1378                          inddpt
  1379  22a1 a952                                lda #dscpnt
  1380  22a3 8032                                bra lda_far_ram1
  1381                          
  1382                          ;indhtr
  1383                          ; lda #hightr
  1384                          ; bra lda_far_ram0
  1385                          
  1386                          indhtr_ram1
  1387  22a5 a95c                                lda #hightr
  1388  22a7 802e                                bra lda_far_ram1
  1389                          
  1390                          indfmo
  1391  22a9 a966                                lda #facmo
  1392  22ab 802a                                bra lda_far_ram1
  1393                          
  1394                          indlow
  1395  22ad a961                                lda #lowtr
  1396  22af 8016                                bra lda_far_ram0
  1397                          
  1398                          indst1
  1399  22b1 a970                                lda #strng1
  1400  22b3 8012                                bra lda_far_ram0
  1401                          
  1402                          indst1_ram1
  1403  22b5 a970                                lda #strng1
  1404  22b7 801e                                bra lda_far_ram1
  1405                          
  1406                          indgrb
  1407  22b9 a950                                lda #grbpnt
  1408  22bb 801a                                bra lda_far_ram1
  1409                          
  1410                          indlow_ram1
  1411  22bd a961                                lda #lowtr
  1412  22bf 8016                                bra lda_far_ram1
  1413                          
  1414                          indin1
  1415  22c1 a924                                lda #index1
  1416  22c3 8002                                bra lda_far_ram0
  1417                          
  1418                          ;indin2
  1419                          ; lda #index2
  1420                          ; bra lda_far_ram0
  1421                          
  1422                          indtxt
  1423  22c5 a93d                                lda #txtptr
  1424                          ; bra lda_far_ram0
  1425                          
  1426                          ; .page
  1427                          ; C65 BASIC Indirect Load Subroutines
  1428                          
  1429                          lda_far_ram0
  1430  22c7 db                                  phz                                      ; save registers
  1431  22c8 da                                  phx
  1432  22c9 aa                                  tax                                      ; pointer
  1433  22ca ab8400                              ldz text_bank                            ; RAM0
  1434  22cd 2074ff                              jsr _lda_far                             ; LDA (.x),Y from bank .z
  1435  22d0 fa                                  plx
  1436  22d1 fb                                  plz
  1437  22d2 29ff                                and #$ff                                 ; set processor status per byte fetched
  1438  22d4 60                                  rts
  1439                          
  1440                          
  1441                          
  1442                          indin1_ram1
  1443  22d5 a924                                lda #index1
  1444                          ; bra lda_far_ram1
  1445                          
  1446                          lda_far_ram1
  1447  22d7 08                                  php                                      ; save .c
  1448  22d8 db                                  phz                                      ; save registers
  1449  22d9 da                                  phx
  1450  22da aa                                  tax                                      ; pointer
  1451  22db ab8500                              ldz var_bank                             ; RAM1
  1452  22de b501                                lda 1,x                                  ; check to see if pointer points to "common"
  1453  22e0 c920                                cmp #$20
  1454  22e2 b003                                bcs l6_1                                 ; branch if not
  1455  22e4 ab8400                              ldz text_bank                            ; else select RAM0
  1456                          
  1457  22e7 2074ff             l6_1             jsr _lda_far                             ; LDA (.x),Y from bank .z
  1458  22ea fa                                  plx
  1459  22eb fb                                  plz
  1460  22ec 28                                  plp                                      ; restore .c
  1461  22ed 29ff                                and #$ff                                 ; set processor status per byte fetched
  1462  22ef 60                                  rts
  1463                          
  1464                          ; .page
  1465                          ; C65 BASIC Indirect Save Subroutines
  1466                          
  1467                          sta_far_ram1
  1468  22f0 08                                  php                                      ; save registers
  1469  22f1 db                                  phz
  1470  22f2 48                                  pha
  1471  22f3 ab8500                              ldz var_bank                             ; RAM1
  1472  22f6 b501                                lda 1,x                                  ; check to see if pointer points to "common"
  1473  22f8 c920                                cmp #$20
  1474  22fa b003                                bcs l7_1                                 ; branch if not
  1475  22fc ab8400                              ldz text_bank                            ; else select RAM0
  1476                          
  1477  22ff 68                 l7_1             pla
  1478  2300 2077ff                              jsr _sta_far                             ; STA (.x),Y to bank .z
  1479  2303 fb                                  plz
  1480  2304 28                                  plp
  1481  2305 60                                  rts
  1482                          
  1483                          
  1484                          sta_far_in1                                               ; [910624]
  1485  2306 a224                                ldx #index1
  1486  2308 8002                                bra sta_far_ram0
  1487                          
  1488                          sta_far_txt
  1489  230a a23d                                ldx #txtptr
  1490                          
  1491                          sta_far_ram0
  1492  230c 08                                  php                                      ; save registers
  1493  230d db                                  phz
  1494  230e ab8400                              ldz text_bank                            ; RAM0
  1495  2311 2077ff                              jsr _sta_far                             ; STA (.x),Y to bank .z
  1496  2314 fb                                  plz
  1497  2315 28                                  plp
  1498  2316 60                                  rts
  1499                          
  1500                          
  1501                          indcmp_in1                                                ; [910620]
  1502  2317 a224                                ldx #index1
  1503  2319 ab8400                              ldz text_bank                            ; RAM0
  1504  231c 4c7aff                              jmp _cmp_far                             ; STA (.x),Y to bank .z
  1505                          
  1506                          ;.end
  1507                          ; .page
  1508                          ; .subttl Crunch - Tokenization Routine
  1509                          
  1510                          ;        CRUNCH
  1511                          ;
  1512                          ;  Entry:  TXTPTR points to start of text to crunch
  1513                          ;  Exit:   TXTPTR points to start of crunched text
  1514                          ;
  1515                          ;  Calls:  CHRGET
  1516                          ;          CHRGOT
  1517                          ;          RESER
  1518                          ;          KLOOP
  1519                          ;          REM
  1520                          ;          DATA
  1521                          ;
  1522                          ;  CRUNCH collapses all reserved words into tokens.  It removes all graphic
  1523                          ;  characters (characters with msb set) not in quoted strings, DATA or REM
  1524                          ;  statements.
  1525                          ;
  1526                          ;  An escape token is implemented as follows:
  1527                          ;
  1528                          ; As each character on a line of text to be crunched is scanned, an
  1529                          ; indirect jump is performed.  Anyone wishing to scan for their own
  1530                          ; commands should grab off this vector, saving the return vector.
  1531                          ; On entry, if the carry flag is set, it is still up for grabs.
  1532                          ; The current text pointer is at TXTPTR.  If the escape routine
  1533                          ; recognizes the command, it should:
  1534                          ;
  1535                          ;  ) put the length of the reserved word in .y
  1536                          ;  ) put the desired 'second' token in .a
  1537                          ;  ) clear the carry flag
  1538                          ;  ) put type of token in x: 0==>command, ff==>function
  1539                          ;
  1540                          ; If it is not your command, leave .a and the carry flag intact.
  1541                          ; NOTE:  The reserved word must be >= 2 characters long.  Exit through
  1542                          ; the old vector (for daisy chaining).  If the carry flag is clear on
  1543                          ; entry it means someone else before you recognized this command.  In
  1544                          ; this case, just pass control through the old vector.
  1545                          
  1546                          
  1547  231f 6c0403             crunch           jmp (icrnch)
  1548                          
  1549                          
  1550  2322 fc3d00             ncrnch           phw txtptr                               ; save old text pointer
  1551                          
  1552  2325 208522             crun05           jsr chrgot
  1553  2328 8003                                bra crun20
  1554                          
  1555  232a 208322             crun10           jsr chrget
  1556                          
  1557                          
  1558  232d 90fb               crun20           bcc crun10                               ; don't crunch numbers
  1559  232f 6c0c03                              jmp (iesclk)                             ; give others a chance at this.  (carry is set)
  1560                          
  1561                          nesclk
  1562  2332 938e00                              +lbcc l8_12                              ; carry clear if someone wanted it
  1563  2335 c900                                cmp #0                                   ; end of line?
  1564  2337 f078                                beq l8_10                                ; yes
  1565  2339 c93a                                cmp #':'                                 ; multi-stmt char?
  1566  233b f0ed                                beq crun10                               ; yes
  1567  233d c93f                                cmp #'?'                                 ; print ('?') abreviation?
  1568  233f d004                                bne l8_1                                 ; no
  1569  2341 a999                                lda #print_token                         ; yes- substitute print token
  1570  2343 8050                                bra l8_8
  1571                          
  1572  2345 c980               l8_1             cmp #$80                                 ; graphics?
  1573  2347 900b                                bcc l8_2                                 ; no
  1574  2349 c9ff                                cmp #pi                                  ; pi? (special case)
  1575  234b f0dd                                beq crun10                               ; yes, leave alone
  1576  234d a001                                ldy #1
  1577  234f 20de23                              jsr kloop                                ; crunch out graphics
  1578  2352 80d1                                bra crun05
  1579                          
  1580                          
  1581  2354 c922               l8_2             cmp #'"'                                 ; quote string?
  1582  2356 d00d                                bne l8_4                                 ; no- try escape token
  1583                          
  1584  2358 208322             l8_3             jsr chrget
  1585  235b c900                                cmp #0                                   ; end of line?
  1586  235d f052                                beq l8_10                                ; yes
  1587  235f c922                                cmp #'"'                                 ; close quote?
  1588  2361 f0c7                                beq crun10                               ; yes
  1589  2363 80f3                                bra l8_3                                 ; no, continue skipping characters
  1590                          
  1591                          
  1592                          ; Crunch escape token
  1593                          
  1594  2365 a926               l8_4             lda #>esc_command_list                   ; look for token in escape-command list
  1595  2367 a029                                ldy #<esc_command_list
  1596  2369 20f423                              jsr reser
  1597  236c 9006                                bcc l8_5                                 ; not found
  1598  236e a981                                lda #first_esc_command_token+$80-1       ; set up for common escape routine
  1599  2370 a200                                ldx #0                                   ; ..flag 'cmd' type escape
  1600  2372 804c                                bra l8_11                                ; ..and go to it.
  1601                          
  1602  2374 a927               l8_5             lda #>esc_function_list                  ; look for token in escape-function list
  1603  2376 a09a                                ldy #<esc_function_list
  1604  2378 20f423                              jsr reser
  1605  237b 9006                                bcc l8_6                                 ; not found
  1606  237d a981                                lda #first_esc_function_token+$80-1      ; set up for common escape routine
  1607  237f a2ff                                ldx #$ff                                 ; ..flag 'function' type escape
  1608  2381 803d                                bra l8_11                                ; ..and go to it
  1609                          
  1610  2383 a924               l8_6             lda #>keyword_list                       ; look for token in normal list
  1611  2385 a03a                                ldy #<keyword_list
  1612  2387 20f423                              jsr reser
  1613  238a 909e                                bcc crun10                               ; not found
  1614  238c c000                                cpy #0                                   ; anything to move?
  1615  238e f003                                beq l8_7                                 ; no
  1616  2390 20de23                              jsr kloop                                ; crunch it out
  1617  2393 a50d               l8_7             lda count
  1618                          
  1619  2395 a000               l8_8             ldy #0
  1620  2397 200a23                              jsr sta_far_txt                          ; put token into text  (bleed-thru)
  1621  239a c98f                                cmp #rem_token
  1622  239c f00d                                beq l8_9
  1623  239e c983                                cmp #data_token
  1624  23a0 d088                                bne crun10
  1625  23a2 208322                              jsr chrget
  1626  23a5 204835                              jsr data
  1627  23a8 837bff                              +lbra crun05
  1628                          
  1629  23ab 208322             l8_9             jsr chrget
  1630  23ae 205635                              jsr rem
  1631                          
  1632                          
  1633                          ;  No other statements can follow a REM
  1634                          
  1635  23b1 a63d               l8_10            ldx txtptr
  1636  23b3 68                                  pla
  1637  23b4 853e                                sta txtptr+1
  1638  23b6 68                                  pla
  1639  23b7 853d                                sta txtptr
  1640  23b9 38                                  sec                                      ; compute length of line
  1641  23ba 8a                                  txa
  1642  23bb e53d                                sbc txtptr
  1643  23bd a8                                  tay
  1644  23be c8                                  iny
  1645  23bf 60                                  rts
  1646                          
  1647                          
  1648                          ; Crunch out old text, install an escape token
  1649                          
  1650  23c0 650d               l8_11            adc count                                ; make pointer into a token
  1651  23c2 48                 l8_12            pha                                      ; save second token
  1652  23c3 88                                  dey                                      ; waste (# of chars) - 1
  1653  23c4 20de23                              jsr kloop
  1654                          
  1655                          ; See if this is function (x=ff) or command (x=0)
  1656                          
  1657  23c7 a9fe                                lda #esc_command_token                   ; assume command
  1658  23c9 e8                                  inx
  1659  23ca d002                                bne l8_13                                ; branch if command
  1660  23cc a9ce                                lda #esc_function_token                  ; ..else get correct token
  1661                          
  1662  23ce a000               l8_13            ldy #0
  1663  23d0 200a23                              jsr sta_far_txt                          ; install escape token... (bleed-thru)
  1664  23d3 c8                                  iny
  1665  23d4 68                                  pla
  1666  23d5 200a23                              jsr sta_far_txt                          ; ..and second token  (bleed-thru)
  1667  23d8 208322                              jsr chrget                               ; skip over token,
  1668  23db 834dff                              +lbra crun10                             ; ..and continue with line.
  1669                          
  1670                          ; .page
  1671                          ;      KLOOP
  1672                          ;
  1673                          ;  Crunch loop.  Moves offset .y characters from txtptr to end of line.
  1674                          ;  .x is preserved
  1675                          
  1676  23de 18                 kloop            clc                                      ; compute source address
  1677  23df 98                                  tya
  1678  23e0 653d                                adc txtptr
  1679  23e2 8524                                sta index1
  1680  23e4 a53e                                lda txtptr+1
  1681  23e6 6900                                adc #0
  1682  23e8 8525                                sta index1+1
  1683  23ea a0ff                                ldy #$ff
  1684                          
  1685  23ec c8                 l9_1             iny
  1686  23ed b124                                lda (index1),y                           ; move source..  ????assumes text in common area
  1687  23ef 913d                                sta (txtptr),y                           ; to destination offset ????assumes text in common area
  1688  23f1 d0f9                                bne l9_1                                 ; not end of line
  1689  23f3 60                                  rts
  1690                          
  1691                          ; .page
  1692                          ;      RESER
  1693                          ;
  1694                          ;  Search reserved word list for a match
  1695                          ;
  1696                          ;  Entry:  (txtptr) is first char of word to match
  1697                          ;    (y,a) is start of table to check
  1698                          ;
  1699                          ;  Exit:   .y  length of word matched
  1700                          ;    .c  success/fail (set/clear) flag
  1701                          ;    count token value
  1702                          
  1703  23f4 8525               reser            sta index1+1
  1704  23f6 8424                                sty index1
  1705  23f8 a000                                ldy #0
  1706  23fa 840d                                sty count
  1707  23fc 88                                  dey
  1708  23fd c8                 l10_1            iny
  1709  23fe b13d               l10_2            lda (txtptr),y                           ; assumes common memory
  1710  2400 3029                                bmi l10_7                                ; abrieviation    [900510]
  1711  2402 38                                  sec
  1712  2403 f124                                sbc (index1),y                           ; does letter match? (ind.ok)
  1713  2405 f0f6                                beq l10_1                                ; yes...continue
  1714  2407 c980                                cmp #$80                                 ; end of word?
  1715  2409 f01b                                beq l10_6                                ; yes...c set...done
  1716                          
  1717                          
  1718                          ;  find next word
  1719                          
  1720  240b b124               l10_3            lda (index1),y                           ; ind.ok
  1721  240d 3003                                bmi l10_4                                ; found end of current
  1722  240f c8                                  iny
  1723  2410 d0f9                                bne l10_3
  1724  2412 c8                 l10_4            iny                                      ; start of next
  1725  2413 e60d                                inc count                                ; value of token
  1726  2415 18                                  clc
  1727  2416 98                                  tya
  1728  2417 6524                                adc index1
  1729  2419 8524                                sta index1
  1730  241b 9002                                bcc l10_5
  1731  241d e625                                inc index1+1
  1732  241f 18                 l10_5            clc
  1733  2420 a000                                ldy #0
  1734  2422 b124                                lda (index1),y                           ; end of list? ind.ok
  1735  2424 d0d8                                bne l10_2                                ; no
  1736                          
  1737                          
  1738                          ;  yes...carry clear...fail
  1739                          
  1740  2426 050d               l10_6            ora count                                ; .a=$80 if match
  1741  2428 850d                                sta count                                ; token is formed
  1742  242a 60                                  rts
  1743                          
  1744                          
  1745                          ; special case- last character is shifted (necessary for 'diR' compatibility)
  1746                          
  1747  242b 38                 l10_7            sec                                      ; allow last chr to be shifted   [900510]
  1748  242c f124                                sbc (index1),y                           ; does letter match? (ind.ok)
  1749  242e f006                                beq l10_8                                ; yes- end of word
  1750  2430 c980                                cmp #$80                                 ; end of word?
  1751  2432 f0f2                                beq l10_6                                ; yes
  1752  2434 d0d5                                bne l10_3                                ; no- next word
  1753                          
  1754  2436 a980               l10_8            lda #$80                                 ; last chr is shifted & so is end of current word
  1755  2438 80ec                                bra l10_6
  1756                          
  1757                          ;.end
  1758                          ; .page
  1759                          ; .subttl Non-Escape Keyword List
  1760                          
  1761                          keyword_list
  1762  243a 454ec4                              !text "EN",'D'+$80                       ; $80
  1763  243d 464fd2                              !text "FO",'R'+$80                       ; $81
  1764  2440 4e4558d4                            !text "NEX",'T'+$80                      ; $82
  1765  2444 444154c1                            !text "DAT",'A'+$80                      ; $83
  1766  2448 494e505554a3                        !text "INPUT",'#'+$80                    ; $84
  1767  244e 494e5055d4                          !text "INPU",'T'+$80                     ; $85
  1768  2453 4449cd                              !text "DI",'M'+$80                       ; $86
  1769  2456 524541c4                            !text "REA",'D'+$80                      ; $87
  1770  245a 4c45d4                              !text "LE",'T'+$80                       ; $88
  1771  245d 474f54cf                            !text "GOT",'O'+$80                      ; $89
  1772  2461 5255ce                              !text "RU",'N'+$80                       ; $8A
  1773  2464 49c6                                !text "I",'F'+$80                        ; $8B
  1774  2466 524553544f52c5                      !text "RESTOR",'E'+$80                   ; $8C
  1775  246d 474f5355c2                          !text "GOSU",'B'+$80                     ; $8D
  1776  2472 5245545552ce                        !text "RETUR",'N'+$80                    ; $8E
  1777  2478 5245cd                              !text "RE",'M'+$80                       ; $8F
  1778  247b 53544fd0                            !text "STO",'P'+$80                      ; $90
  1779  247f 4fce                                !text "O",'N'+$80                        ; $91
  1780  2481 574149d4                            !text "WAI",'T'+$80                      ; $92
  1781  2485 4c4f41c4                            !text "LOA",'D'+$80                      ; $93
  1782  2489 534156c5                            !text "SAV",'E'+$80                      ; $94
  1783  248d 5645524946d9                        !text "VERIF",'Y'+$80                    ; $95
  1784  2493 4445c6                              !text "DE",'F'+$80                       ; $96
  1785  2496 504f4bc5                            !text "POK",'E'+$80                      ; $97
  1786  249a 5052494e54a3                        !text "PRINT",'#'+$80                    ; $98
  1787  24a0 5052494ed4                          !text "PRIN",'T'+$80                     ; $99
  1788  24a5 434f4ed4                            !text "CON",'T'+$80                      ; $9A
  1789  24a9 4c4953d4                            !text "LIS",'T'+$80                      ; $9B
  1790  24ad 434cd2                              !text "CL",'R'+$80                       ; $9C
  1791  24b0 434dc4                              !text "CM",'D'+$80                       ; $9D
  1792  24b3 5359d3                              !text "SY",'S'+$80                       ; $9E
  1793  24b6 4f5045ce                            !text "OPE",'N'+$80                      ; $9F
  1794  24ba 434c4f53c5                          !text "CLOS",'E'+$80                     ; $A0
  1795  24bf 4745d4                              !text "GE",'T'+$80                       ; $A1
  1796  24c2 4e45d7                              !text "NE",'W'+$80                       ; $A2
  1797  24c5 544142a8                            !text "TAB",'('+$80                      ; $A3
  1798  24c9 54cf                                !text "T",'O'+$80                        ; $A4
  1799  24cb 46ce                                !text "F",'N'+$80                        ; $A5
  1800  24cd 535043a8                            !text "SPC",'('+$80                      ; $A6
  1801  24d1 544845ce                            !text "THE",'N'+$80                      ; $A7
  1802  24d5 4e4fd4                              !text "NO",'T'+$80                       ; $A8
  1803  24d8 535445d0                            !text "STE",'P'+$80                      ; $A9
  1804  24dc ab                                  !text '+'+$80                            ; $AA operators
  1805  24dd ad                                  !text '-'+$80                            ; $AB
  1806  24de aa                                  !text '*'+$80                            ; $AC
  1807  24df af                                  !text '/'+$80                            ; $AD
  1808  24e0 de                                  !text '^'+$80                            ; $AE
  1809  24e1 414ec4                              !text "AN",'D'+$80                       ; $AF
  1810  24e4 4fd2                                !text "O",'R'+$80                        ; $B0
  1811  24e6 be                                  !text '>'+$80                            ; $B1
  1812  24e7 bd                                  !text '='+$80                            ; $B2
  1813  24e8 bc                                  !text '<'+$80                            ; $B3
  1814  24e9 5347ce                              !text "SG",'N'+$80                       ; $B4 first numeric function
  1815  24ec 494ed4                              !text "IN",'T'+$80                       ; $B5
  1816  24ef 4142d3                              !text "AB",'S'+$80                       ; $B6
  1817  24f2 5553d2                              !text "US",'R'+$80                       ; $B7
  1818  24f5 4652c5                              !text "FR",'E'+$80                       ; $B8
  1819  24f8 504fd3                              !text "PO",'S'+$80                       ; $B9
  1820  24fb 5351d2                              !text "SQ",'R'+$80                       ; $BA
  1821  24fe 524ec4                              !text "RN",'D'+$80                       ; $BB
  1822  2501 4c4fc7                              !text "LO",'G'+$80                       ; $BC
  1823  2504 4558d0                              !text "EX",'P'+$80                       ; $BD
  1824  2507 434fd3                              !text "CO",'S'+$80                       ; $BE
  1825  250a 5349ce                              !text "SI",'N'+$80                       ; $BF
  1826  250d 5441ce                              !text "TA",'N'+$80                       ; $C0
  1827  2510 4154ce                              !text "AT",'N'+$80                       ; $C1
  1828  2513 504545cb                            !text "PEE",'K'+$80                      ; $C2
  1829  2517 4c45ce                              !text "LE",'N'+$80                       ; $C3
  1830  251a 535452a4                            !text "STR",'$'+$80                      ; $C4
  1831  251e 5641cc                              !text "VA",'L'+$80                       ; $C5
  1832  2521 4153c3                              !text "AS",'C'+$80                       ; $C6 last numeric function
  1833  2524 434852a4                            !text "CHR",'$'+$80                      ; $C7 last single-arg function
  1834  2528 4c454654a4                          !text "LEFT",'$'+$80                     ; $C8
  1835  252d 5249474854a4                        !text "RIGHT",'$'+$80                    ; $C9
  1836  2533 4d4944a4                            !text "MID",'$'+$80                      ; $CA
  1837  2537 47cf                                !text "G",'O'+$80                        ; $CB
  1838                          ; beginning of new C128 keywords------------
  1839  2539 52475241504849c3                    !text "RGRAPHI",'C'+$80                  ; $CC was 'rgr'   [910701]
  1840  2541 52434f4c4fd2                        !text "RCOLO",'R'+$80                    ; $CD was 'rclr'   [910701]
  1841  2547 80                                  !text $80                                ; $CE null to skip over escape_function token
  1842  2548 4a4fd9                              !text "JO",'Y'+$80                       ; $CF
  1843  254b 525045ce                            !text "RPE",'N'+$80                      ; $D0 (was rdot in c128)
  1844  254f 4445c3                              !text "DE",'C'+$80                       ; $D1
  1845  2552 484558a4                            !text "HEX",'$'+$80                      ; $D2
  1846  2556 455252a4                            !text "ERR",'$'+$80                      ; $D3
  1847  255a 494e5354d2                          !text "INST",'R'+$80                     ; $D4 last function
  1848                          
  1849  255f 454c53c5                            !text "ELS",'E'+$80                      ; $D5
  1850  2563 524553554dc5                        !text "RESUM",'E'+$80                    ; $D6
  1851  2569 545241d0                            !text "TRA",'P'+$80                      ; $D7
  1852  256d 54524fce                            !text "TRO",'N'+$80                      ; $D8
  1853  2571 54524f46c6                          !text "TROF",'F'+$80                     ; $D9
  1854  2576 534f554ec4                          !text "SOUN",'D'+$80                     ; $DA
  1855  257b 564fcc                              !text "VO",'L'+$80                       ; $DB
  1856  257e 415554cf                            !text "AUT",'O'+$80                      ; $DC
  1857  2582 50554445c6                          !text "PUDE",'F'+$80                     ; $DD
  1858  2587 475241504849c3                      !text "GRAPHI",'C'+$80                   ; $DE
  1859  258e 5041494ed4                          !text "PAIN",'T'+$80                     ; $DF
  1860  2593 434841d2                            !text "CHA",'R'+$80                      ; $E0
  1861  2597 424fd8                              !text "BO",'X'+$80                       ; $E1
  1862  259a 434952434cc5                        !text "CIRCL",'E'+$80                    ; $E2
  1863  25a0 50415354c5                          !text "PAST",'E'+$80                     ; $E3 (was gshape in C128)
  1864  25a5 4355d4                              !text "CU",'T'+$80                       ; $E4 (was sshape in C128)
  1865  25a8 4c494ec5                            !text "LIN",'E'+$80                      ; $E5 (was draw in C128)
  1866  25ac 4c4f434154c5                        !text "LOCAT",'E'+$80                    ; $E6
  1867  25b2 434f4c4fd2                          !text "COLO",'R'+$80                     ; $E7
  1868  25b7 53434e434cd2                        !text "SCNCL",'R'+$80                    ; $E8
  1869  25bd 5343414cc5                          !text "SCAL",'E'+$80                     ; $E9
  1870  25c2 48454cd0                            !text "HEL",'P'+$80                      ; $EA
  1871  25c6 44cf                                !text "D",'O'+$80                        ; $EB
  1872  25c8 4c4f4fd0                            !text "LOO",'P'+$80                      ; $EC
  1873  25cc 455849d4                            !text "EXI",'T'+$80                      ; $ED
  1874  25d0 4449d2                              !text "DI",'R'+$80                       ; $EE
  1875  25d3 44534156c5                          !text "DSAV",'E'+$80                     ; $EF
  1876  25d8 444c4f41c4                          !text "DLOA",'D'+$80                     ; $F0
  1877  25dd 4845414445d2                        !text "HEADE",'R'+$80                    ; $F1
  1878  25e3 534352415443c8                      !text "SCRATC",'H'+$80                   ; $F2
  1879  25ea 434f4c4c4543d4                      !text "COLLEC",'T'+$80                   ; $F3
  1880  25f1 434f50d9                            !text "COP",'Y'+$80                      ; $F4
  1881  25f5 52454e414dc5                        !text "RENAM",'E'+$80                    ; $F5
  1882  25fb 4241434b55d0                        !text "BACKU",'P'+$80                    ; $F6
  1883  2601 44454c4554c5                        !text "DELET",'E'+$80                    ; $F7
  1884  2607 52454e554d4245d2                    !text "RENUMBE",'R'+$80                  ; $F8
  1885  260f 4b45d9                              !text "KE",'Y'+$80                       ; $F9
  1886  2612 4d4f4e49544fd2                      !text "MONITO",'R'+$80                   ; $FA
  1887  2619 5553494ec7                          !text "USIN",'G'+$80                     ; $FB
  1888  261e 554e5449cc                          !text "UNTI",'L'+$80                     ; $FC
  1889  2623 5748494cc5                          !text "WHIL",'E'+$80                     ; $FD
  1890  2628 00                                  !text 0                                  ; $FE skip over the escape_command token
  1891                          
  1892                          ;.end
  1893                          
  1894                          ; .page
  1895                          ; .subttl Escape Tokens and Keywords
  1896                          
  1897                          ; Escape Command Tokens
  1898                          
  1899                          esc_command_list
  1900  2629 42414ecb                            !text "BAN",'K'+$80                      ; $02: set bank number
  1901  262d 46494c5445d2                        !text "FILTE",'R'+$80                    ; $03: set up filter
  1902  2633 504c41d9                            !text "PLA",'Y'+$80                      ; $04: play a tune
  1903  2637 54454d50cf                          !text "TEMP",'O'+$80                     ; $05: set rate for playing
  1904  263c 4d4f565350d2                        !text "MOVSP",'R'+$80                    ; $06: sprite position/movement
  1905  2642 5350524954c5                        !text "SPRIT",'E'+$80                    ; $07: turn on/set up sprite
  1906  2648 535052434f4c4fd2                    !text "SPRCOLO",'R'+$80                  ; $08: set sprite multicolor registers
  1907  2650 525245c7                            !text "RRE",'G'+$80                      ; $09: retreive register values after 'SYS'
  1908  2654 454e56454c4f50c5                    !text "ENVELOP",'E'+$80                  ; $0A: set up SID envelopes
  1909  265c 534c4545d0                          !text "SLEE",'P'+$80                     ; $0B: delay
  1910  2661 434154414c4fc7                      !text "CATALO",'G'+$80                   ; $0C: disk directory
  1911  2668 444f5045ce                          !text "DOPE",'N'+$80                     ; $0D: open a disk file
  1912  266d 415050454ec4                        !text "APPEN",'D'+$80                    ; $0E: open a disk file for appending
  1913  2673 44434c4f53c5                        !text "DCLOS",'E'+$80                    ; $0F: close a file opened w/ DOPEN
  1914  2679 42534156c5                          !text "BSAV",'E'+$80                     ; $10: binary (non-program) save
  1915  267e 424c4f41c4                          !text "BLOA",'D'+$80                     ; $11: binary load
  1916  2683 5245434f52c4                        !text "RECOR",'D'+$80                    ; $12:
  1917  2689 434f4e4341d4                        !text "CONCA",'T'+$80                    ; $13: concatenate 2 files
  1918  268f 445645524946d9                      !text "DVERIF",'Y'+$80                   ; $14: verify a saved program
  1919  2696 44434c4541d2                        !text "DCLEA",'R'+$80                    ; $15: re-initialize a drive
  1920  269c 5350525341d6                        !text "SPRSA",'V'+$80                    ; $16: sprite/string to sprite/string
  1921  26a2 434f4c4c4953494f...                 !text "COLLISIO",'N'+$80                 ; $17: set traps for sprite & light pen collisions
  1922  26ab 42454749ce                          !text "BEGI",'N'+$80                     ; $18: mark start of a b-block
  1923  26b0 42454ec4                            !text "BEN",'D'+$80                      ; $19: ..and its end, too!
  1924  26b4 57494e444fd7                        !text "WINDO",'W'+$80                    ; $1A: set screen window
  1925  26ba 424f4fd4                            !text "BOO",'T'+$80                      ; $1B: load&run ML or autoboot a disk
  1926  26be 57494454c8                          !text "WIDT",'H'+$80                     ; $1C: single/double width drawing
  1927  26c3 5350524445c6                        !text "SPRDE",'F'+$80                    ; $1D: define a sprite
  1928  26c9 515549d4                            !text "QUI",'T'+$80                      ; $1E: (UNIMPLEMENTED)
  1929  26cd 444dc1                              !text "DM",'A'+$80                       ; $1F: access memory
  1930  26d0 a0                                  !text ' '+$80                            ; $20: POISON - space character
  1931  26d1 444dc1                              !text "DM",'A'+$80                       ; $21: access memory
  1932  26d4 a0                                  !text ' '+$80                            ; $22: POISON - quote character
  1933  26d5 444dc1                              !text "DM",'A'+$80                       ; $23: access memory
  1934  26d8 4f46c6                              !text "OF",'F'+$80                       ; $24: KEY OFF
  1935  26db 464153d4                            !text "FAS",'T'+$80                      ; $25: go to 2 MHz. mode
  1936  26df 534c4fd7                            !text "SLO",'W'+$80                      ; $26: go to 1 MHz. mode
  1937  26e3 545950c5                            !text "TYP",'E'+$80                      ; $27: type SEQ file
  1938  26e7 425645524946d9                      !text "BVERIF",'Y'+$80                   ; $28: verify a saved program
  1939  26ee 4543544f52d9                        !text "ECTOR",'Y'+$80                    ; $29: dirECTORY
  1940  26f4 45524153c5                          !text "ERAS",'E'+$80                     ; $2A: alias for scratch
  1941  26f9 46494ec4                            !text "FIN",'D'+$80                      ; $2B: find string
  1942  26fd 4348414e47c5                        !text "CHANG",'E'+$80                    ; $2C: change string
  1943  2703 5345d4                              !text "SE",'T'+$80                       ; $2D:
  1944  2706 5343524545ce                        !text "SCREE",'N'+$80                    ; $2E:
  1945  270c 504f4c59474fce                      !text "POLYGO",'N'+$80                   ; $2F:
  1946  2713 454c4c495053c5                      !text "ELLIPS",'E'+$80                   ; $30:
  1947  271a 56494557504f52d4                    !text "VIEWPOR",'T'+$80                  ; $31:
  1948  2722 47434f50d9                          !text "GCOP",'Y'+$80                     ; $32:
  1949  2727 5045ce                              !text "PE",'N'+$80                       ; $33:
  1950  272a 50414c455454c5                      !text "PALETT",'E'+$80                   ; $34:
  1951  2731 444d4f44c5                          !text "DMOD",'E'+$80                     ; $35:
  1952  2736 445041d4                            !text "DPA",'T'+$80                      ; $36:
  1953  273a 464f524d41d4                        !text "FORMA",'T'+$80                    ; $37: alias for HEADER command  [911017]
  1954  2740 47454e4c4f43cb                      !text "GENLOC",'K'+$80                   ; $38:     [910108]
  1955  2747 464f524547524f55...                 !text "FOREGROUN",'D'+$80                ; $39:     [910109]
  1956  2751 a0                                  !text ' '+$80                            ; $3A: POISON - colon character  "
  1957  2752 4241434b47524f55...                 !text "BACKGROUN",'D'+$80                ; $3B:     "
  1958  275c 424f524445d2                        !text "BORDE",'R'+$80                    ; $3C:     "
  1959  2762 484947484c494748...                 !text "HIGHLIGH",'T'+$80                 ; $3D:     "
  1960  276b 4d4f5553c5                          !text "MOUS",'E'+$80                     ; $3E:     [910122]
  1961  2770 524d4f5553c5                        !text "RMOUS",'E'+$80                    ; $3F: return coordinates of mouse [910123]
  1962  2776 444953cb                            !text "DIS",'K'+$80                      ; $40:     [910123]
  1963  277a 435552534fd2                        !text "CURSO",'R'+$80                    ; $41:     [910228]
  1964  2780 52435552534fd2                      !text "RCURSO",'R'+$80                   ; $42: return cursor position  [910228]
  1965  2787 4c4f41444946c6                      !text "LOADIF",'F'+$80                   ; $43: load IFF picture from disk [910402]
  1966  278e 534156454946c6                      !text "SAVEIF",'F'+$80                   ; $44: save IFF picture to   disk [910402]
  1967  2795 454449d4                            !text "EDI",'T'+$80                      ; $45: Edit mode on/off   [910620]
  1968                          
  1969  2799 00                                  !text 0                                  ; End marker
  1970                          ;(don't forget to change last_command_token!)
  1971                          ; .page
  1972                          ; Escape Function Tokens
  1973                          
  1974                          esc_function_list
  1975  279a 504fd4                              !text "PO",'T'+$80                       ; $02: return paddle value
  1976  279d 42554dd0                            !text "BUM",'P'+$80                      ; $03: read sprite collision
  1977  27a1 4c5045ce                            !text "LPE",'N'+$80                      ; $04: read light pen value
  1978  27a5 525350504fd3                        !text "RSPPO",'S'+$80                    ; $05: read sprite position
  1979  27ab 525350524954c5                      !text "RSPRIT",'E'+$80                   ; $06: read sprite value
  1980  27b2 525350434f4c4fd2                    !text "RSPCOLO",'R'+$80                  ; $07: read sprite multicolor value
  1981  27ba 584fd2                              !text "XO",'R'+$80                       ; $08: exclusive or
  1982  27bd 5257494e444fd7                      !text "RWINDO",'W'+$80                   ; $09: read window size
  1983  27c4 504f494e5445d2                      !text "POINTE",'R'+$80                   ; $0a: return address of descriptor
  1984  27cb 4d4fc4                              !text "MO",'D'+$80                       ; $0b: modulus    [910402]
  1985  27ce 50495845cc                          !text "PIXE",'L'+$80                     ; $0c: return BP data at pixel  [910820]
  1986  27d3 5250414c455454c5                    !text "RPALETT",'E'+$80                  ; $0d: return RGB component of color [910820]
  1987  27db 00                                  !text 0
  1988                          
  1989                          ;.end
  1990                          ; .page
  1991                          ; .subttl Jump Table For Dispatch Routine
  1992                          stmdsp
  1993  27dc dc2c                                !word end-1
  1994  27de 5c41                                !word for-1
  1995  27e0 743a                                !word next-1
  1996  27e2 4735                                !word data-1
  1997  27e4 a138                                !word inputn-1
  1998  27e6 bf38                                !word input-1
  1999  27e8 f33a                                !word dim-1
  2000  27ea 0f39                                !word read-1
  2001  27ec 7536                                !word let-1
  2002  27ee fa3c                                !word goto-1
  2003  27f0 b33d                                !word run-1
  2004  27f2 7d35                                !word if-1
  2005  27f4 e63d                                !word restor-1
  2006  27f6 eb3c                                !word gosub-1
  2007  27f8 2c35                                !word return-1
  2008  27fa 5535                                !word rem-1
  2009  27fc da2c                                !word stop-1
  2010  27fe 5436                                !word ongoto-1
  2011  2800 e654                                !word wait-1
  2012  2802 8968                                !word load-1
  2013  2804 6168                                !word save-1
  2014  2806 8668                                !word verify-1
  2015  2808 f458                                !word def-1
  2016  280a ed55                                !word poke-1
  2017  280c a737                                !word printn-1
  2018  280e c837                                !word print-1
  2019  2810 793d                                !word cont-1
  2020  2812 8932                                !word list-1
  2021  2814 a534                                !word clear-1
  2022  2816 ad37                                !word cmd-1
  2023  2818 fd3a                                !word sys-1
  2024  281a 0069                                !word open-1
  2025  281c 0869                                !word close-1
  2026  281e 6638                                !word get-1
  2027  2820 5434                                !word new-1
  2028                          
  2029  2822 4236                                !word else-1
  2030  2824 6744                                !word resume-1
  2031  2826 5544                                !word trap-1
  2032  2828 993b                                !word tron-1
  2033  282a 9c3b                                !word troff-1
  2034  282c 7c4b                                !word sound-1
  2035  282e 454b                                !word volume-1
  2036  2830 593c                                !word auto-1
  2037  2832 4144                                !word puctrl-1
  2038  2834 bf7f                                !word graphic-1
  2039                          
  2040  2836 5ab3                                !word C65__paint-1
  2041  2838 efb2                                !word C65__char-1
  2042  283a 06b1                                !word C65__box-1
  2043  283c 5ab1                                !word C65__circle-1
  2044  283e 4fb4                                !word C65__paste-1                       ; gshape
  2045  2840 4fb4                                !word C65__cut-1                         ; sshape
  2046  2842 b1b0                                !word C65__line-1                        ; draw
  2047                          
  2048  2844 3a2e                                !word bad_command-1                      ; escape - SYSTEM - unimplemented command
  2049                          ; .word  locate-1
  2050                          
  2051  2846 99b4                                !word color-1
  2052  2848 34af                                !word scnclr-1
  2053                          
  2054  284a 3a2e                                !word bad_command-1                      ; escape - SYSTEM - unimplemented command
  2055                          ; .word  scale-1
  2056                          
  2057  284c 683c                                !word help-1
  2058  284e ec44                                !word do-1
  2059  2850 8e45                                !word loop-1
  2060  2852 4145                                !word exit-1
  2061  2854 9f6f                                !word directory-1
  2062  2856 4671                                !word dsave-1
  2063  2858 6871                                !word dload-1
  2064  285a 4a72                                !word header-1
  2065  285c d372                                !word scratch-1
  2066  285e 6473                                !word collect-1
  2067  2860 7b73                                !word dcopy-1
  2068  2862 c773                                !word rename-1
  2069  2864 d973                                !word backup-1
  2070  2866 e741                                !word delete-1
  2071  2868 123e                                !word renumber-1
  2072  286a d445                                !word key-1
  2073  286c 55ff                                !word _monitor-1
  2074  286e 4647                                !word bank-1                             ; escape
  2075  2870 154a                                !word filter-1                           ; escape
  2076  2872 4d47                                !word play-1                             ; escape
  2077  2874 8449                                !word tempo-1                            ; escape
  2078                          
  2079  2876 bfb5                                !word movspr-1                           ; escape
  2080  2878 28b5                                !word sprite-1                           ; escape
  2081  287a 05b8                                !word sprcolor-1                         ; escape
  2082                          
  2083  287c 9f3b                                !word rreg-1                             ; escape
  2084  287e a34a                                !word envelope-1                         ; escape
  2085  2880 c054                                !word sleep-1                            ; escape
  2086  2882 9f6f                                !word directory-1                        ; escape
  2087  2884 d170                                !word dopen-1                            ; escape
  2088  2886 e770                                !word append-1                           ; escape
  2089  2888 2f71                                !word dclose-1                           ; escape
  2090  288a 9071                                !word bsave-1                            ; escape
  2091  288c e171                                !word bload-1                            ; escape
  2092  288e 0a73                                !word record-1                           ; escape
  2093  2890 b773                                !word concat-1                           ; escape
  2094  2892 6571                                !word dverify-1                          ; escape
  2095  2894 5473                                !word dclear-1                           ; escape
  2096                          
  2097  2896 1bb8                                !word sprsav-1                           ; escape
  2098  2898 dbb8                                !word collision-1                        ; escape
  2099                          
  2100  289a 4735                                !word data-1                             ; escape - BEGIN
  2101  289c 4735                                !word data-1                             ; escape - BEND
  2102  289e 5f4c                                !word window-1                           ; escape
  2103  28a0 4e67                                !word boot-1                             ; escape
  2104                          
  2105  28a2 3a2e                                !word bad_command-1
  2106                          ; .word  set_width-1 ;escape - WIDTH
  2107                          
  2108  28a4 3a2e                                !word bad_command-1
  2109                          ; .word  sprdef-1  ;escape - Sprite Definition mode
  2110                          
  2111  28a6 3a2e                                !word bad_command-1                      ; escape - QUIT - unimplemented command
  2112  28a8 333b                                !word dma-1                              ; escape
  2113  28aa 0000                                !word 0                                  ; placeholder to skip over the space character
  2114  28ac 333b                                !word dma-1                              ; escape
  2115  28ae 0000                                !word 0                                  ; placeholder to skip over the quote character
  2116  28b0 333b                                !word dma-1                              ; escape
  2117  28b2 3a2e                                !word bad_command-1                      ; escape - OFF - unimplemented command
  2118  28b4 c54c                                !word fast-1                             ; escape
  2119  28b6 ce4c                                !word slow-1                             ; escape
  2120  28b8 166f                                !word type-1                             ; escape (C65: type SEQ file)
  2121  28ba de71                                !word bverify-1                          ; escape (C65: verify BINary file)
  2122  28bc 492e                                !word snerr-1                            ; escape (C65: kludge- dirECTORY)
  2123  28be d372                                !word scratch-1                          ; escape (C65: erase alias for scratch)
  2124  28c0 8842                                !word find-1                             ; escape (C65: find BASIC text)
  2125  28c2 8b42                                !word change-1                           ; escape (C65: change BASIC text)
  2126                          
  2127  28c4 1ab2                                !word C65__set-1                         ; escape (C65: multi-purpose command)
  2128  28c6 ffae                                !word Screen-1                           ; escape (C65: SCREEN)
  2129  28c8 bbb1                                !word C65__polygon-1                     ; escape (C65: POLYGON)
  2130  28ca 86b1                                !word C65__ellipse-1                     ; escape (C65: ELLIPSE)
  2131  28cc 14b4                                !word C65__Viewport-1                    ; escape (C65: VIEWPORT)
  2132  28ce 4fb4                                !word C65__copy-1                        ; escape (C65: GCOPY)
  2133  28d0 b7af                                !word C65__setpen-1                      ; escape (C65: PEN)
  2134  28d2 45b0                                !word C65__setpalette-1                  ; escape (C65: PALETTE)
  2135  28d4 cbaf                                !word C65__setdmode-1                    ; escape (C65: DMODE)
  2136  28d6 01b0                                !word C65__setdpat-1                     ; escape (C65: DPAT)
  2137  28d8 4a72                                !word header-1                           ; format alias for header command [911017]
  2138  28da 52b4                                !word genlock-1                          ; [910108]
  2139                          
  2140                          stmdsp2
  2141  28dc dab4                                !word foreground-1                       ; this is the 128th command!  [910109]
  2142  28de 0000                                !word 0                                  ; placeholder to skip over the colon character
  2143  28e0 fbb4                                !word background-1
  2144  28e2 02b5                                !word border-1
  2145  28e4 e0b4                                !word highlight-1
  2146  28e6 ef7b                                !word mouse-1                            ; [910122]
  2147  28e8 8c7c                                !word rmouse-1                           ; [910123]
  2148  28ea 796f                                !word disk-1                             ; [910123]
  2149  28ec 277d                                !word cursor-1                           ; [910228]
  2150  28ee 807d                                !word rcursor-1                          ; [910228]
  2151  28f0 aeb3                                !word loadiff-1                          ; [910402]
  2152  28f2 eab3                                !word saveiff-1                          ; [910930]
  2153  28f4 c6bc                                !word edit-1                             ; [910620]
  2154                          
  2155                          ; .page
  2156                          fundsp
  2157  28f6 cf62                                !word sgn
  2158  28f8 6363                                !word int
  2159  28fa ee62                                !word abs
  2160  28fc f702                                !word usrpok
  2161  28fe 1355                                !word fre
  2162  2900 ce58                                !word pos
  2163  2902 bc65                                !word sqr
  2164  2904 2358                                !word rnd
  2165  2906 0e60                                !word log
  2166  2908 0766                                !word exp
  2167  290a 9e66                                !word cos
  2168  290c a566                                !word sin
  2169  290e ee66                                !word tan
  2170  2910 1f67                                !word atn
  2171  2912 c755                                !word peek
  2172  2914 565a                                !word len
  2173  2916 a559                                !word strd
  2174  2918 4655                                !word val
  2175  291a 655a                                !word asc
  2176  291c b659                                !word chrd
  2177  291e cc59                                !word leftd
  2178  2920 ff59                                !word rightd
  2179  2922 105a                                !word midd
  2180  2924 26b9                                !word rgraphic                           ; [910701]
  2181  2926 ffb8                                !word rcolor                             ; [910701]
  2182  2928 0000                                !word 0                                  ; placeholder for escape function token
  2183  292a ae56                                !word joy
  2184  292c 9bb9                                !word rpen                               ; was rdot     [910820]
  2185  292e 7855                                !word dcml                               ; dec
  2186  2930 6f56                                !word hexd
  2187  2932 1856                                !word errd
  2188  2934 f356                                !word pot                                ; escape
  2189  2936 9cba                                !word bump                               ; escape
  2190  2938 5257                                !word lpen                               ; escape
  2191  293a 5aba                                !word rsppos                             ; escape
  2192  293c 0fba                                !word rsprite                            ; escape
  2193  293e 45ba                                !word rspcolor                           ; escape
  2194  2940 9557                                !word xor                                ; escape
  2195  2942 fa57                                !word rwindow                            ; escape
  2196  2944 7457                                !word pointer                            ; escape
  2197  2946 b757                                !word mod                                ; escape c65     [910402]
  2198  2948 76b9                                !word pixel                              ; escape c65     [910820]
  2199  294a b8b9                                !word rpalette                           ; escape c65     [910820]
  2200                          
  2201                          ; .page
  2202  294c 79                 optab            !text 121
  2203  294d bd5d                                !word faddt-1
  2204  294f 79                                  !text 121
  2205  2950 a75d                                !word fsubt-1
  2206  2952 7b                                  !text 123
  2207  2953 6f60                                !word fmultt-1
  2208  2955 7b                                  !text 123
  2209  2956 8461                                !word fdivt-1
  2210  2958 7f                                  !text 127
  2211  2959 c565                                !word fpwrt-1
  2212  295b 50                                  !text 80
  2213  295c 9a2d                                !word andop-1
  2214  295e 46                                  !text 70
  2215  295f 972d                                !word orop-1
  2216  2961 7d                 negtab           !text 125
  2217  2962 fb65                                !word negop-1
  2218  2964 5a                                  !text 90
  2219  2965 324e                                !word notop-1
  2220  2967 64                 ptdorl           !text 100
  2221  2968 c72d                                !word dorel-1
  2222                          
  2223                          ;.end
  2224                          ; .page
  2225                          ; .subttl  Keyword Equates
  2226                          
  2227                          end_token        = $80                                    ; v2 commands
  2228                          for_token        = $81
  2229                          next_token       = $82
  2230                          data_token       = $83
  2231                          input_token      = $84
  2232                          goto_token       = $89
  2233                          run_token        = $8a
  2234                          restore_token    = $8c
  2235                          gosub_token      = $8d
  2236                          rem_token        = $8f
  2237                          on_token         = $91
  2238                          load_token       = $93
  2239                          save_token       = $94
  2240                          verify_token     = $95
  2241                          def_token        = $96
  2242                          print_token      = $99
  2243                          clr_token        = $9c
  2244                          sys_token        = $9e
  2245                          open_token       = $9f
  2246                          close_token      = $a0
  2247                          new_token        = $a2
  2248                          tab_token        = $a3
  2249                          to_token         = $a4
  2250                          fn_token         = $a5
  2251                          spc_token        = $a6
  2252                          then_token       = $a7
  2253                          not_token        = $a8
  2254                          step_token       = $a9
  2255                          plus_token       = $aa                                    ; operators
  2256                          minus_token      = $ab
  2257                          greater_token    = $b1
  2258                          equal_token      = $b2
  2259                          less_token       = $b3
  2260                          first_function_token = $b4                                    ; v2 functions
  2261                          left_token       = $c8
  2262                          mid_token        = $ca
  2263                          go_token         = $cb                                    ; kludges
  2264                          rgraphic_token   = $cc                                    ; first new v7 token
  2265                          esc_function_token = $ce
  2266                          err_token        = $d3
  2267                          instr_token      = $d4
  2268                          last_function_token = $d4
  2269                          else_token       = $d5
  2270                          resume_token     = $d6
  2271                          trap_token       = $d7
  2272                          color_token      = $e7
  2273                          do_token         = $eb
  2274                          loop_token       = $ec
  2275                          key_token        = $f9
  2276                          monitor_token    = $fa
  2277                          using_token      = $fb
  2278                          until_token      = $fc
  2279                          while_token      = $fd
  2280                          esc_command_token = $fe
  2281                          ; .page
  2282                          first_esc_command_token = $02
  2283                          collision_token  = $17
  2284                          begin_token      = $18
  2285                          bend_token       = $19
  2286                          off_token        = $24
  2287                          ectory_token     = $29
  2288                          set_token        = $2d
  2289                          pic_token        = $37
  2290                          disk_token       = $40
  2291                          last_esc_command_token = $45                                    ; <<<< last_command_token
  2292                          
  2293                          first_esc_function_token = $02
  2294                          pointer_token    = $0a
  2295                          last_esc_function_token = $0d                                    ; [910820]
  2296                          
  2297                          ; .page
  2298                          ; .subttl Error Messages
  2299                          
  2300                          ok_error_message
  2301  296a 4fcb                                !text "O",'K'+$80                        ; 0 for ERR$ [910911]
  2302                          error_message_list
  2303  296c 544f4f204d414e59...                 !text "TOO MANY FILE",'S'+$80            ; 1
  2304  297a 46494c45204f5045...                 !text "FILE OPE",'N'+$80                 ; 2
  2305  2983 46494c45204e4f54...                 !text "FILE NOT OPE",'N'+$80             ; 3
  2306  2990 46494c45204e4f54...                 !text "FILE NOT FOUN",'D'+$80            ; 4
  2307  299e 444556494345204e...                 !text "DEVICE NOT PRESEN",'T'+$80        ; 5
  2308  29b0 4e4f5420494e5055...                 !text "NOT INPUT FIL",'E'+$80            ; 6
  2309  29be 4e4f54204f555450...                 !text "NOT OUTPUT FIL",'E'+$80           ; 7
  2310  29cd 4d495353494e4720...                 !text "MISSING FILE NAM",'E'+$80         ; 8
  2311  29de 494c4c4547414c20...                 !text "ILLEGAL DEVICE NUMBE",'R'+$80     ; 9
  2312  29f3 4e45585420574954...                 !text "NEXT WITHOUT FO",'R'+$80          ; 10
  2313  2a03 53594e5441d8                        !text "SYNTA",'X'+$80                    ; 11
  2314  2a09 52455455524e2057...                 !text "RETURN WITHOUT GOSU",'B'+$80      ; 12
  2315  2a1d 4f5554204f462044...                 !text "OUT OF DAT",'A'+$80               ; 13
  2316  2a28 494c4c4547414c20...                 !text "ILLEGAL QUANTIT",'Y'+$80          ; 14
  2317  2a38 4f564552464c4fd7                    !text "OVERFLO",'W'+$80                  ; 15
  2318  2a40 4f5554204f46204d...                 !text "OUT OF MEMOR",'Y'+$80             ; 16
  2319  2a4d 554e444546274420...                 !text "UNDEF",$27,"D STATEMEN",'T'+$80   ; 17
  2320  2a5e 4241442053554253...                 !text "BAD SUBSCRIP",'T'+$80             ; 18
  2321  2a6b 524544494d274420...                 !text "REDIM",$27,"D ARRA",'Y'+$80       ; 19
  2322  2a78 4449564953494f4e...                 !text "DIVISION BY ZER",'O'+$80          ; 20
  2323  2a88 494c4c4547414c20...                 !text "ILLEGAL DIREC",'T'+$80            ; 21
  2324  2a96 54595045204d4953...                 !text "TYPE MISMATC",'H'+$80             ; 22
  2325  2aa3 535452494e472054...                 !text "STRING TOO LON",'G'+$80           ; 23
  2326  2ab2 46494c4520444154...                 !text "FILE DAT",'A'+$80                 ; 24
  2327  2abb 464f524d554c4120...                 !text "FORMULA TOO COMPLE",'X'+$80       ; 25
  2328  2ace 43414e275420434f...                 !text "CAN",$27,"T CONTINU",'E'+$80      ; 26
  2329  2adc 554e444546274420...                 !text "UNDEF'D FUNCTIO",'N'+$80          ; 27
  2330  2aec 5645524946d9                        !text "VERIF",'Y'+$80                    ; 28
  2331  2af2 4c4f41c4                            !text "LOA",'D'+$80                      ; 29
  2332  2af6 42524541cb                          !text "BREA",'K'+$80                     ; 30 ???? null & space [910925]
  2333  2afb 43414e2754205245...                 !text "CAN'T RESUM",'E'+$80              ; 31
  2334  2b07 4c4f4f50204e4f54...                 !text "LOOP NOT FOUN",'D'+$80            ; 32
  2335  2b15 4c4f4f5020574954...                 !text "LOOP WITHOUT D",'O'+$80           ; 33
  2336  2b24 444952454354204d...                 !text "DIRECT MODE ONL",'Y'+$80          ; 34
  2337                          ; .byte 'NO GRAPHICS ARE','A'+$80   ;35
  2338  2b34 53435245454e204e...                 !text "SCREEN NOT OPE",'N'+$80           ; 35    [911001]
  2339  2b43 42414420444953cb                    !text "BAD DIS",'K'+$80                  ; 36 ???? used for failed bootsys
  2340  2b4b 42454e44204e4f54...                 !text "BEND NOT FOUN",'D'+$80            ; 37
  2341  2b59 4c494e45204e554d...                 !text "LINE NUMBER TOO LARG",'E'+$80     ; 38
  2342  2b6e 554e5245534f4c56...                 !text "UNRESOLVED REFERENC",'E'+$80      ; 39
  2343  2b82 554e494d504c454d...                 !text "UNIMPLEMENTED COMMAN",'D'+$80     ; 40
  2344  2b97 46494c4520524541...                 !text "FILE REA",'D'+$80                 ; 41
  2345  2ba0 45444954204d4f44...                 !text "EDIT MOD",'E'+$80                 ; 42    [910620]
  2346                          
  2347                          ; .page
  2348                          ; .subttl  Error Message Numbers
  2349                          
  2350                          errtmf           = 1
  2351                          errfno           = 3
  2352                          errfnf           = 4
  2353                          err_missing_fname = 8
  2354                          err_illegal_device = 9
  2355                          errnf            = 10
  2356                          errsn            = 11
  2357                          errrg            = 12
  2358                          errod            = 13
  2359                          errfc            = 14
  2360                          errov            = 15
  2361                          errom            = 16
  2362                          errus            = 17
  2363                          errbs            = 18
  2364                          errdd            = 19
  2365                          errdvo           = 20
  2366                          errid            = 21
  2367                          errtm            = 22
  2368                          errls            = 23
  2369                          errbd            = 24
  2370                          errst            = 25
  2371                          errcn            = 26
  2372                          erruf            = 27
  2373                          ervfy            = 28
  2374                          erload           = 29
  2375                          erbrk            = 30
  2376                          errcr            = 31
  2377                          errlnf           = 32
  2378                          errlwd           = 33
  2379                          erroid           = 34
  2380                          errng            = 35
  2381                          errbdk           = 36
  2382                          err_no_bend      = 37
  2383                          err_too_large    = 38
  2384                          err_ref          = 39
  2385                          err_bad_command  = 40
  2386                          err_file_read    = 41
  2387                          edit_mode_error  = 42                                     ; [910620]
  2388                          last_error_message = 42                                     ; # of last error msg
  2389                          
  2390                          ;.end
  2391                          ; .page
  2392                          ; .subttl Error message output
  2393                          
  2394                          ; Routine to translate error message # in .a
  2395                          ; into address of string containing message in index2
  2396                          
  2397  2ba9 aa                 erstup           tax                                      ; error set up
  2398  2baa a000                                ldy #0                                   ; start with address of first error message
  2399  2bac a96c                                lda #<error_message_list
  2400  2bae 8526                                sta index2
  2401  2bb0 a929                                lda #>error_message_list
  2402  2bb2 8527                                sta index2+1
  2403                          
  2404  2bb4 ca                 l11_1            dex
  2405  2bb5 300a                                bmi l11_3                                ; finished when .x decrements out
  2406                          
  2407  2bb7 b126               l11_2            lda (index2),y                           ; look at msg, and find end (msb set) (ind.ok)
  2408  2bb9 e326                                inw index2
  2409  2bbb 29ff                                and #$ff                                 ; was msb set?
  2410  2bbd 10f8                                bpl l11_2                                ; no, not end of message
  2411  2bbf 80f3                                bra l11_1                                ; yes, tick off another msg
  2412                          
  2413  2bc1 60                 l11_3            rts
  2414                          
  2415                          ;.end
  2416                          ; .page
  2417                          ; .subttl Execute Dispatcher
  2418                          
  2419                          ; Here for new statement. Character -> by txtptr is ':' or eol. The adr of
  2420                          ; this loc is left on the stack when a statement is executed so that it can
  2421                          ; merely do a rts when it is done.
  2422                          ; Get char, exit via xeqcm3, and return to newstt.
  2423                          
  2424  2bc2 6c0803             xeqcm            jmp (igone)
  2425                          
  2426                          ; Check if there is an interrupt from VIC that needs to be serviced
  2427                          
  2428  2bc5 7f7e3f             ngone            bbr7 runmod,l12_3                        ; get off here if we are in direct mode
  2429  2bc8 addc02                              lda intval                               ; check if there is an interrupt already in progress
  2430  2bcb 303a                                bmi l12_3                                ; yes, don't go any further
  2431                          
  2432  2bcd a202                                ldx #2                                   ; check for 3 types of interrupts: s/s, s/b, & lp
  2433  2bcf bddd02             l12_1            lda int_trip_flag,x
  2434  2bd2 f030                                beq l12_2                                ; this wasn't set, go check next
  2435                          
  2436  2bd4 a900                                lda #0
  2437  2bd6 9ddd02                              sta int_trip_flag,x                      ; reset this flag to show 'serviced'
  2438  2bd9 bde002                              lda int_adr_lo,x                         ; install the trap address as linnum
  2439  2bdc 8516                                sta linnum
  2440  2bde bde302                              lda int_adr_hi,x
  2441  2be1 8517                                sta linnum+1
  2442  2be3 da                                  phx                                      ; save counter & text pointer
  2443  2be4 fc3d00                              phw txtptr
  2444  2be7 a980                                lda #$80                                 ; flag 'no other interrupt traps, please'
  2445  2be9 0cdc02                              tsb intval
  2446                          
  2447  2bec 208322                              jsr chrget                               ; skip over 2nd byte of line number
  2448  2bef 20393d                              jsr gosub_sub                            ; fake a 'gosub' from here, so trap rx can do a RETURN
  2449  2bf2 20063d                              jsr goto_1
  2450  2bf5 200d2c                              jsr newstt
  2451                          
  2452  2bf8 a980                                lda #$80
  2453  2bfa 1cdc02                              trb intval
  2454  2bfd 68                                  pla
  2455  2bfe 853e                                sta txtptr+1
  2456  2c00 68                                  pla
  2457  2c01 853d                                sta txtptr
  2458  2c03 fa                                  plx
  2459                          
  2460  2c04 ca                 l12_2            dex
  2461  2c05 10c8                                bpl l12_1
  2462                          
  2463                          
  2464  2c07 208322             l12_3            jsr chrget                               ; get statement type
  2465  2c0a 20522c             xeqdir           jsr xeqcm3
  2466                          
  2467  2c0d 20cc2c             newstt           jsr is_stop_key_down
  2468  2c10 7f7e06                              bbr7 runmod,l13_1                        ; branch if direct mode
  2469                          
  2470                          ; In run mode...save txtptr for CONTinue command
  2471                          
  2472  2c13 20472c                              jsr tto                                  ; transfer txtptr to oldtxt
  2473  2c16 ba                                  tsx
  2474  2c17 8681                                stx oldstk
  2475                          
  2476  2c19 a000               l13_1            ldy #0
  2477  2c1b 20c522                              jsr indtxt                               ; end of the line?
  2478  2c1e d3a500                              +lbne morsts                             ; no...out of statement
  2479                          
  2480  2c21 247e               l13_2            bit runmod                               ; in direct mode?
  2481  2c23 132802                              +lbpl ready                              ; yes, go to ready
  2482  2c26 a002                                ldy #2
  2483  2c28 20c522                              jsr indtxt                               ; end of text?
  2484  2c2b f32002                              +lbeq ready                              ; yes...finished
  2485  2c2e c8                                  iny                                      ; y=3
  2486  2c2f 20c522                              jsr indtxt                               ; extract line# lo byte
  2487  2c32 853b                                sta curlin
  2488  2c34 c8                                  iny
  2489  2c35 20c522                              jsr indtxt                               ; extract line # hi byte
  2490  2c38 853c                                sta curlin+1
  2491  2c3a 98                                  tya                                      ; y=4
  2492  2c3b 18                                  clc
  2493  2c3c 653d                                adc txtptr                               ; point @ character before line start
  2494  2c3e 853d                                sta txtptr
  2495  2c40 9002                                bcc l13_3
  2496  2c42 e63e                                inc txtptr+1
  2497  2c44 837cff             l13_3            +lbra xeqcm                              ; execute new line
  2498                          
  2499                          
  2500                          
  2501  2c47 a53d               tto              lda txtptr
  2502  2c49 a43e                                ldy txtptr+1
  2503  2c4b 8d7211                              sta oldtxt
  2504  2c4e 8c7311                              sty oldtxt+1
  2505  2c51 60                 xeqrts           rts
  2506                          
  2507                          ; .page
  2508                          ; Set up for command processing and set processor address on stack.
  2509                          ; Exit via jmp to CHRGET
  2510                          
  2511  2c52 f0fd               xeqcm3           beq xeqrts                               ; nothing here...null statement
  2512  2c54 5f7e12                              bbr5 runmod,xeqcm2                       ; trcflg. branch if trace not enabled
  2513  2c57 7f7e0f                              bbr7 runmod,xeqcm2                       ; branch if direct mode- can't trace
  2514                          
  2515  2c5a 48                                  pha                                      ; save token
  2516  2c5b a95b                                lda #'['                                 ; print '[line-number]'
  2517  2c5d 203d68                              jsr outch                                ; outdo
  2518  2c60 207b64                              jsr curprt                               ; print curlin
  2519  2c63 a95d                                lda #']'
  2520  2c65 203d68                              jsr outch                                ; outdo
  2521  2c68 68                                  pla                                      ; restore token
  2522                          
  2523                          
  2524  2c69 c9fe               xeqcm2           cmp #esc_command_token                   ; special case: escape token
  2525  2c6b f03e                                beq xeqesc
  2526  2c6d c9cb                                cmp #go_token                            ; special case: go to
  2527  2c6f f3ed10                              +lbeq go_without_to
  2528  2c72 c9ca                                cmp #mid_token                           ; special case: mid$()=
  2529  2c74 f02c                                beq xeqmid
  2530                          
  2531                          ; Command can be in the range END...NEW (old BASIC) & ELSE...MONITOR
  2532                          ; (new extensions).  Although there is a gap between these two blocks,
  2533                          ; it will be quickest & easiest to collapse them into one continuous block.
  2534                          
  2535  2c76 c9fb                                cmp #monitor_token+1
  2536  2c78 b048                                bcs snerr1
  2537  2c7a c9a3                                cmp #new_token+1
  2538  2c7c 9006                                bcc xeqcm4                               ; no need to collapse
  2539  2c7e c9d5                                cmp #else_token
  2540  2c80 9040                                bcc snerr1
  2541  2c82 e932                                sbc #else_token-new_token-1
  2542                          
  2543  2c84 38                 xeqcm4           sec                                      ; convert adjusted token into an index into a jump table.
  2544  2c85 e980                                sbc #end_token
  2545  2c87 93ed09                              +lbcc let                                ; it wasn't a token after all!  assume an assignment
  2546                          
  2547  2c8a 0a                 xeqcm5           asl                                      ; *2 to convert into word pointer
  2548  2c8b a8                                  tay
  2549  2c8c b009                                bcs l14_1                                ; dispatch table 1 or 2?     [901212]
  2550  2c8e b9dd27                              lda stmdsp+1,y                           ; one
  2551  2c91 48                                  pha
  2552  2c92 b9dc27                              lda stmdsp,y
  2553  2c95 8007                                bra l14_2
  2554                          
  2555  2c97 b9dd28             l14_1            lda stmdsp2+1,y                          ; two      [901212]
  2556  2c9a 48                                  pha
  2557  2c9b b9dc28                              lda stmdsp2,y
  2558                          
  2559  2c9e 48                 l14_2            pha
  2560  2c9f 4c8322                              jmp chrget                               ; execution will commence after chrget's RTS
  2561                          
  2562                          
  2563                          
  2564                          xeqmid                                                    ; handle special case of MID$= (what we call a kludge)
  2565  2ca2 a93b                                lda #>midwrk                             ; midd2-1
  2566  2ca4 48                                  pha
  2567  2ca5 a9e1                                lda #<midwrk
  2568  2ca7 48                                  pha
  2569                          xeqchr
  2570  2ca8 4c8322                              jmp chrget
  2571                          
  2572                          
  2573                          
  2574                          
  2575                          xeqesc                                                    ; execute escape token
  2576  2cab 208322                              jsr chrget                               ; let's have us a look at the second char
  2577  2cae f012                                beq snerr1                               ; oops, there wasn't any!
  2578  2cb0 c902                                cmp #first_esc_command_token             ; is it one of our esc tokens?
  2579  2cb2 9008                                bcc l15_1                                ; no, foreign.
  2580  2cb4 c946                                cmp #last_esc_command_token+1
  2581  2cb6 b004                                bcs l15_1                                ; foreign
  2582                          
  2583                          ; It's one of our own.  Convert to index into command dispatch table
  2584                          
  2585  2cb8 6947                                adc #monitor_token-else_token+new_token-end_token-first_esc_command_token+2
  2586  2cba 80ce                                bra xeqcm5                               ; always
  2587                          
  2588  2cbc 38                 l15_1            sec                                      ; set up flag for a trip into the users code
  2589  2cbd 6c1003                              jmp (iescex)
  2590                          
  2591  2cc0 90e6               nescex           bcc xeqchr                               ; jmp chrget
  2592                          
  2593  2cc2 838601             snerr1           +lbra snerr
  2594                          
  2595  2cc5 c93a               morsts           cmp #':'
  2596  2cc7 f3f9fe                              +lbeq xeqcm                              ; if ':', continue statement
  2597  2cca 80f6                                bra snerr1
  2598                          
  2599                          ; .page
  2600                          ; STOP, STOP KEY, and END handlers
  2601                          ;
  2602                          
  2603                          is_stop_key_down
  2604  2ccc 20e1ff                              jsr _stop                                ; test stop key
  2605  2ccf d03b                                bne do_rts                               ; not down, exit
  2606                          
  2607                          ; ldy trapno+1  ;test if trap on????   removed [910925]
  2608                          ; iny
  2609                          ; beq stop_1  ;no, do a normal stop
  2610                          
  2611                          
  2612                          break_exit                                                ; STOP KEY:     [910104]
  2613  2cd1 20e1ff             l16_1            jsr _stop                                ; wait for the user to release the key
  2614  2cd4 f0fb                                beq l16_1
  2615  2cd6 a21e                                ldx #erbrk                               ; take the vector thru error to ready
  2616  2cd8 837501                              +lbra error
  2617                          
  2618                          
  2619                          
  2620  2cdb b001               stop             bcs stopc                                ; STOP: .c=1
  2621                          
  2622  2cdd 18                 end              clc                                      ; END: .c=0
  2623  2cde d36a01             stopc            +lbne snerr                              ; error if args present   [910410]
  2624                          
  2625  2ce1 7f7e0d             stop_1           bbr7 runmod,l17_1                        ; branch if direct mode
  2626  2ce4 20472c                              jsr tto                                  ; transfer txtptr to oldtxt
  2627  2ce7 a53b                                lda curlin
  2628  2ce9 a43c                                ldy curlin+1
  2629  2ceb 8d7011                              sta oldlin
  2630  2cee 8c7111                              sty oldlin+1
  2631  2cf1 68                 l17_1            pla                                      ; .diris
  2632  2cf2 68                                  pla
  2633  2cf3 935801                              +lbcc ready                              ; say 'ready' if END, say 'break' if STOP
  2634                          
  2635                          
  2636  2cf6 20b438             break            jsr release_channels                     ; make sure we're in text mode????  [910909]
  2637  2cf9 2027af                              jsr RestoreTextScreen
  2638  2cfc 20dc3c                              jsr highlight_text                       ; ????      [910624]
  2639  2cff 207dff                              jsr _primm
  2640  2d02 0d425245414b00                      !text cr,"BREAK",0
  2641  2d09 83ce01                              +lbra errfin                             ; exit via 'in line #'
  2642                          
  2643  2d0c 60                 do_rts           rts
  2644                          
  2645                          ;.end
  2646                          ; .page
  2647                          ; .subttl Function Handler
  2648                          
  2649                          ; At this point, eval has determined that the token in a has to be a
  2650                          ; function.  It must therefor be in the range SGN...MID$ (old BASIC),
  2651                          ; or RGR...INSTR (new extensions).  We will collapse these two disjoint
  2652                          ; blocks into one continuous range.
  2653                          ;
  2654                          ; On entry, we can assume the token is >= 'sgn'
  2655                          
  2656  2d0d c9ce               isfun            cmp #esc_function_token                  ; is this an escape function?
  2657  2d0f f059                                beq do_esc_fn                            ; yes
  2658  2d11 c9d5                                cmp #last_function_token+1
  2659  2d13 b0ad                                bcs snerr1                               ; no- must be syntax error
  2660  2d15 c9cb                                cmp #mid_token+1
  2661  2d17 9002                                bcc l18_1                                ; no need to adjust
  2662  2d19 e901                                sbc #rgraphic_token-mid_token-1
  2663                          
  2664  2d1b 48                 l18_1            pha                                      ; save token
  2665  2d1c aa                                  tax
  2666  2d1d 208322                              jsr chrget                               ; set up for synchk.
  2667  2d20 e0d3                                cpx #instr_token-1                       ; look for (adjusted) instr token
  2668  2d22 f00d                                beq l18_2                                ; yes
  2669  2d24 e0cb                                cpx #rgraphic_token-1                    ; look for rgraphic which now takes 2 args [910801]
  2670  2d26 f3fe8b                              +lbeq rgraphic                           ; yes
  2671                          
  2672  2d29 e0cb                                cpx #mid_token+1
  2673  2d2b b024                                bcs oknorm                               ; LEFT$,RIGHT$,MID$ require multiple args
  2674  2d2d e0c8                                cpx #left_token                          ; is it past last single-arg function?
  2675  2d2f 9020                                bcc oknorm                               ; no, must be normal function
  2676                          
  2677                          
  2678                          ; Most functions take a single argument.  The return address of these functions
  2679                          ; is CHKNUM, which ascertains that VALTYP=0 (numeric).  Normal functions which
  2680                          ; return string results (eg. CHR$) must pop off that return address and return
  2681                          ; directly to FRMEVL.
  2682                          ;
  2683                          ; The so called "funny" functions can take more than one argument, the first
  2684                          ; of which must be string and the second of which must be a number between 0
  2685                          ; and 255.  The closed parenthesis must be checked and return is directly to
  2686                          ; FRMEVL with the text pointer pointing beyond the ")".  The pointer to the
  2687                          ; description of the string argument is stored on the stack underneath the
  2688                          ; value of the integer argument.
  2689                          
  2690  2d31 20584e             l18_2            jsr chkopn                               ; check for an open parenthesis
  2691  2d34 20ef4c                              jsr frmevl                               ; eat open paren and first argument
  2692  2d37 205b4e                              jsr chkcom                               ; two args so comma must delimit
  2693  2d3a 20dd4c                              jsr chkstr                               ; make sure first was string
  2694                          
  2695  2d3d 68                                  pla                                      ; check token
  2696  2d3e c9d3                                cmp #instr_token-1                       ; special case: INSTR() bails out here
  2697  2d40 f32b41                              +lbeq instr
  2698  2d43 a667                                ldx facmo+1                              ; push address of string arg1
  2699  2d45 da                                  phx
  2700  2d46 a666                                ldx facmo
  2701  2d48 da                                  phx
  2702  2d49 48                                  pha                                      ; push token
  2703  2d4a 206c5d                              jsr getbyt                               ; get arg2
  2704  2d4d 68                                  pla                                      ; retrieve token
  2705  2d4e da                                  phx                                      ; push value of arg2
  2706  2d4f 8004                                bra fingo                                ; go set up to evaluate fn
  2707                          
  2708                          
  2709                          
  2710                          oknorm
  2711  2d51 204f4e                              jsr parchk                               ; check for open parens, evaluate argument
  2712  2d54 68                                  pla                                      ; restore token
  2713                          
  2714                          fingo
  2715  2d55 38                                  sec                                      ; convert token to index into jump table
  2716  2d56 e9b4                                sbc #first_function_token
  2717  2d58 0a                                  asl
  2718  2d59 a8                                  tay
  2719  2d5a b9f728                              lda fundsp+1,y
  2720  2d5d 8558                                sta jmper+2
  2721  2d5f b9f628                              lda fundsp,y
  2722  2d62 8557                                sta jmper+1
  2723  2d64 205600                              jsr jmper                                ; dispatch
  2724                          ;string functions remove this ret addr
  2725  2d67 83721f                              +lbra chknum                             ; check for "numeric-ness" and return
  2726                          
  2727                          ; .page
  2728                          ; Escape Function handler
  2729                          
  2730                          do_esc_fn
  2731  2d6a 208322                              jsr chrget                               ; get second token
  2732  2d6d f3db00                              +lbeq snerr                              ; error if no second token
  2733  2d70 c90a                                cmp #pointer_token
  2734  2d72 f00b                                beq l19_1                                ; skip pre-parse if 'POINTER()'
  2735  2d74 48                                  pha
  2736  2d75 208322                              jsr chrget                               ; should be '('
  2737  2d78 20584e                              jsr chkopn
  2738  2d7b 20ef4c                              jsr frmevl                               ; evaluate first argument
  2739  2d7e 68                                  pla
  2740  2d7f c902               l19_1            cmp #first_esc_function_token            ; see if this esc fn is one of ours
  2741  2d81 9008                                bcc foreign_esc_fn                       ; nope.
  2742  2d83 c90e                                cmp #last_esc_function_token+1
  2743  2d85 b004                                bcs foreign_esc_fn                       ; nope
  2744                          
  2745                          ; Convert to index into the function dispatch table
  2746                          
  2747  2d87 69d1                                adc #last_function_token-first_esc_function_token-1
  2748  2d89 80ca                                bra fingo                                ; always
  2749                          
  2750                          
  2751                          foreign_esc_fn
  2752  2d8b 38                                  sec                                      ; flag 'up for grabs'
  2753  2d8c 20952d                              jsr go_foreign_esc_fn
  2754                          n_esc_fn_vec
  2755  2d8f b3b900                              +lbcs snerr                              ; it's unwanted. off to the refuse pile
  2756  2d92 83471f                              +lbra chknum
  2757                          
  2758                          go_foreign_esc_fn
  2759  2d95 6cfc02                              jmp (esc_fn_vec)
  2760                          
  2761                          ; .page
  2762  2d98 a0ff               orop             ldy #255                                 ; must always complement
  2763  2d9a 2c                                  !text $2c
  2764                          
  2765  2d9b a000               andop            ldy #0
  2766  2d9d 840d                                sty count                                ; operator
  2767  2d9f 20b458                              jsr ayint                                ; (facmo&lo)=int value and check size
  2768  2da2 a566                                lda facmo                                ; use Demorgan's Law on high
  2769  2da4 450d                                eor count
  2770  2da6 850a                                sta integr
  2771  2da8 a567                                lda faclo                                ; and low
  2772  2daa 450d                                eor count
  2773  2dac 850b                                sta integr+1
  2774  2dae 209362                              jsr movfa
  2775  2db1 20b458                              jsr ayint                                ; (facmo&lo)=int of arg
  2776  2db4 a567                                lda faclo
  2777  2db6 450d                                eor count
  2778  2db8 250b                                and integr+1
  2779  2dba 450d                                eor count                                ; finish out Demorgan
  2780  2dbc a8                                  tay                                      ; save high
  2781  2dbd a566                                lda facmo
  2782  2dbf 450d                                eor count
  2783  2dc1 250a                                and integr
  2784  2dc3 450d                                eor count
  2785  2dc5 837820                              +lbra givayf                             ; float (a,y) and return to user
  2786                          
  2787                          
  2788                          
  2789                          ; Time to perform a relational operator.
  2790                          ; (domask) contains the bits as to which relational operator it was.
  2791                          ; Carry bit on = string compare.
  2792                          
  2793                          
  2794  2dc8 20de4c             dorel            jsr chkval                               ; check for match
  2795  2dcb b012                                bcs strcmp                               ; is it a string?
  2796  2dcd a56f                                lda argsgn                               ; pack argument for fcomp
  2797  2dcf 097f                                ora #$7f
  2798  2dd1 256b                                and argho
  2799  2dd3 856b                                sta argho
  2800  2dd5 a96a                                lda #<argexp
  2801  2dd7 a000                                ldy #>argexp
  2802  2dd9 20f162                              jsr fcomp
  2803  2ddc aa                                  tax
  2804  2ddd 8033                                bra qcomp
  2805                          
  2806                          ; .page
  2807  2ddf a900               strcmp           lda #0
  2808  2de1 850f                                sta valtyp
  2809  2de3 c64f                                dec opmask
  2810  2de5 206d5b                              jsr frefac                               ; free the faclo string
  2811  2de8 8563                                sta dsctmp                               ; save it for later
  2812  2dea 8664                                stx dsctmp+1
  2813  2dec 8465                                sty dsctmp+2
  2814  2dee a56d                                lda argmo                                ; get pointer to other string
  2815  2df0 a46e                                ldy argmo+1
  2816  2df2 20715b                              jsr fretmp                               ; frees first desc pointer
  2817  2df5 866d                                stx argmo
  2818  2df7 846e                                sty argmo+1
  2819  2df9 aa                                  tax                                      ; copy count into x
  2820  2dfa 38                                  sec
  2821  2dfb e563                                sbc dsctmp                               ; which is greater. if 0, all set up
  2822  2dfd f008                                beq stasgn                               ; just put sign of difference away
  2823  2dff a901                                lda #1
  2824  2e01 9004                                bcc stasgn                               ; sign is positive
  2825  2e03 a663                                ldx dsctmp                               ; length of fac is shorter
  2826  2e05 a9ff                                lda #$ff                                 ; get a minus one for negatives
  2827  2e07 8568               stasgn           sta facsgn                               ; keep for later
  2828  2e09 a0ff                                ldy #255                                 ; set pointer to first string. (arg)
  2829  2e0b e8                                  inx                                      ; to loop properly
  2830  2e0c c8                 nxtcmp           iny
  2831  2e0d ca                                  dex                                      ; any characters left to compare?
  2832  2e0e d007                                bne getcmp                               ; not done yet
  2833  2e10 a668                                ldx facsgn                               ; use sign of length difference
  2834                          ;since all characters are the same
  2835  2e12 301b               qcomp            bmi docmp                                ; c is always set then
  2836  2e14 18                                  clc
  2837  2e15 8018                                bra docmp                                ; always branch
  2838                          
  2839                          ; .page
  2840  2e17 a96d               getcmp           lda #argmo
  2841  2e19 20d722                              jsr lda_far_ram1                         ; lda (argmo),y from RAM1
  2842  2e1c 48                                  pha
  2843  2e1d a964                                lda #dsctmp+1
  2844  2e1f 20d722                              jsr lda_far_ram1                         ; lda (dsctmp+1),y from RAM1
  2845  2e22 8578                                sta syntmp
  2846  2e24 68                                  pla
  2847  2e25 c578                                cmp syntmp
  2848  2e27 f0e3                                beq nxtcmp
  2849  2e29 a2ff                                ldx #$ff
  2850  2e2b b002                                bcs docmp
  2851  2e2d a201                                ldx #1
  2852                          
  2853                          
  2854                          
  2855                          docmp
  2856  2e2f e8                                  inx                                      ; -1 to 1, 0 to 2, 1 to 4
  2857  2e30 8a                                  txa
  2858  2e31 2a                                  rol
  2859  2e32 2514                                and domask
  2860  2e34 f002                                beq l20_1
  2861  2e36 a9ff                                lda #$ff                                 ; map 0 to 0, map all others to -1
  2862  2e38 839834             l20_1            +lbra float                              ; float the one-byte result into FAC
  2863                          
  2864                          
  2865                          ;.end
  2866                          ; .page
  2867                          ; .subttl  Ready, Error, Main (CODE 0)
  2868                          
  2869                          bad_command
  2870  2e3b a228                                ldx #err_bad_command                     ; unimplemented command
  2871  2e3d 2c                                  !text $2c
  2872                          
  2873  2e3e a211               userr            ldx #errus                               ; undefined statement
  2874  2e40 2c                                  !text $2c
  2875                          
  2876  2e41 a210               omerr            ldx #errom                               ; out of memory
  2877  2e43 2c                                  !text $2c
  2878                          
  2879  2e44 a214               doverr           ldx #errdvo                              ; division by zero
  2880  2e46 2c                                  !text $2c
  2881                          
  2882  2e47 a20f               overr            ldx #errov                               ; overflow
  2883  2e49 2c                                  !text $2c
  2884                          
  2885  2e4a a20b               snerr            ldx #errsn                               ; syntax error
  2886  2e4c 2c                                  !text $2c
  2887                          
  2888  2e4d a280               ready            ldx #$80                                 ; no error
  2889                          
  2890  2e4f 6c0003             error            jmp (ierror)
  2891                          
  2892  2e52 8a                 nerror           txa
  2893  2e53 338f00                              +lbmi ready_1                            ; ...branch if no error (from 'ready')
  2894  2e56 8ec702                              stx errnum                               ; save error # for 'er'
  2895  2e59 7f7e3c                              bbr7 runmod,errisd                       ; branch if direct mode- always display error
  2896                          
  2897  2e5c a001                                ldy #1                                   ; copy curlin to errlin, oldtxt to errtxt
  2898  2e5e b93b00             l21_1            lda curlin,y
  2899  2e61 99c802                              sta errlin,y                             ; line# where error occurred
  2900  2e64 b97211                              lda oldtxt,y
  2901  2e67 99cd02                              sta errtxt,y                             ; statement where error occured
  2902  2e6a 88                                  dey
  2903  2e6b 10f1                                bpl l21_1
  2904  2e6d eecd02                              inc errtxt                               ; point to a token, not ':' for HELP
  2905  2e70 d003                                bne l21_2
  2906  2e72 eece02                              inc errtxt+1
  2907                          
  2908  2e75 accb02             l21_2            ldy trapno+1                             ; is trap set?
  2909  2e78 c0ff                                cpy #$ff
  2910  2e7a f01c                                beq errisd                               ; no
  2911  2e7c 8417                                sty linnum+1
  2912  2e7e 8ccc02                              sty tmptrp                               ; save until a resume is executed
  2913  2e81 acca02                              ldy trapno
  2914  2e84 8416                                sty linnum
  2915                          
  2916  2e86 a2ff                                ldx #$ff
  2917  2e88 8ecb02                              stx trapno+1                             ; flag no more traps
  2918  2e8b a21b                                ldx #tempst                              ; clear any accumulated string temps
  2919  2e8d 8618                                stx temppt
  2920  2e8f a681                                ldx oldstk
  2921  2e91 9a                                  txs
  2922  2e92 201f3d                              jsr luk4it
  2923  2e95 8376fd                              +lbra newstt
  2924                          
  2925                          ; .page
  2926  2e98 ca                 errisd           dex
  2927  2e99 8a                                  txa
  2928  2e9a 20a92b                              jsr erstup                               ; set up address of error msg in .a in index2
  2929                          
  2930  2e9d ff7e08                              bbs7 runmod,l22_1                        ; reset error line if direct mode error
  2931  2ea0 a9ff                                lda #$ff
  2932  2ea2 8dc802                              sta errlin                               ;
  2933  2ea5 8dc902                              sta errlin+1
  2934                          
  2935  2ea8 20b438             l22_1            jsr release_channels                     ; restore output to screen    [910909]
  2936  2eab 2027af                              jsr RestoreTextScreen                    ; make sure we're in text mode    [910404]
  2937  2eae 200935                              jsr init_stack
  2938                          
  2939  2eb1 20f737             l22_2            jsr crdo                                 ; Print error message- start a new line with '?'
  2940  2eb4 20dc3c                              jsr highlight_text                       ; use highlight color????    [910624]
  2941  2eb7 206238                              jsr outqst
  2942  2eba a000                                ldy #0
  2943  2ebc b126               l22_3            lda (index2),y                           ; Read error msg from ROM  (ind.ok????)
  2944  2ebe 48                                  pha
  2945  2ebf 297f                                and #$7f
  2946  2ec1 203d68                              jsr outch                                ; Print it
  2947  2ec4 c8                                  iny
  2948  2ec5 68                                  pla
  2949  2ec6 10f4                                bpl l22_3
  2950  2ec8 aec702                              ldx errnum                               ; retrieve error #     [910925]
  2951  2ecb e01e                                cpx #erbrk
  2952  2ecd f00a                                beq errfin                               ; skip 'error' crap if 'break'
  2953  2ecf 207dff                              jsr _primm
  2954  2ed2 204552524f5200                      !text " ERROR",0
  2955                          
  2956  2ed9 a43c               errfin           ldy curlin+1                             ; direct mode?
  2957  2edb c8                                  iny
  2958  2edc f003                                beq l23_1                                ; yes...no line #
  2959  2ede 207364                              jsr inprt
  2960  2ee1 20cb3c             l23_1            jsr highlight_done                       ; restore normal text color????    [910624]
  2961                          
  2962                          ; .page
  2963                          ready_1
  2964  2ee4 a980                                lda #%10000000
  2965  2ee6 2090ff                              jsr _setmsg                              ; turn Kernel messages on
  2966  2ee9 a9c0                                lda #%11000000
  2967  2eeb 147e                                trb runmod                               ; turn run modes off, leave trace mode on????
  2968                          
  2969                          ready_2
  2970  2eed cf7e0e                              bbs4 runmod,l24_1                        ; print appropriate system prompt
  2971  2ef0 207dff                              jsr _primm                               ; Program mode: print 'ready.'
  2972  2ef3 0d52454144592e0d...                 !text cr,"READY.",cr,0
  2973  2efc 8009                                bra main
  2974                          
  2975  2efe 207dff             l24_1            jsr _primm                               ; Edit mode: print 'ok.'
  2976  2f01 0d4f4b2e0d00                        !text cr,"OK.",cr,0
  2977                          
  2978                          
  2979  2f07 6c0203             main             jmp (imain)                              ; MAIN INPUT LOOP
  2980                          
  2981  2f0a a2ff               nmain            ldx #$ff                                 ; set direct mode flag
  2982  2f0c 863c                                stx curlin+1
  2983  2f0e 201c31                              jsr InputLine                            ; get a line of input & buffer it
  2984                          
  2985                          execute_a_line                                            ; EXECUTE PLAIN TEXT IN BUFFER
  2986  2f11 863d                                stx txtptr                               ; init buffer pointer
  2987  2f13 843e                                sty txtptr+1
  2988  2f15 208322                              jsr chrget                               ; get first character of null-terminated string
  2989  2f18 aa                                  tax
  2990  2f19 f0ec                                beq main                                 ; got null input
  2991  2f1b 9009                                bcc l25_1                                ; got line number
  2992  2f1d 201f23                              jsr crunch                               ; got text- tokenize buffer,
  2993  2f20 208522                              jsr chrgot                               ; get first command (token),
  2994  2f23 83e5fc                              +lbra xeqdir                             ; and execute it
  2995                          
  2996                          ;ADD or DELETE NEW LINE
  2997  2f26 202e32             l25_1            jsr linget                               ; evaluate line number, put into into linnum
  2998  2f29 4f7e05                              bbr4 runmod,l25_2
  2999  2f2c 20e1bc                              jsr edit_crunch                          ; if edit mode, find end of input   [910620]
  3000  2f2f 8003                                bra l25_3
  3001                          
  3002  2f31 201f23             l25_2            jsr crunch                               ; tokenize rest of input if not edit mode
  3003  2f34 840d               l25_3            sty count                                ; save length
  3004  2f36 20fa31                              jsr FindLine                             ; locate line in program
  3005  2f39 938300                              +lbcc nodel                              ; not found, go insert line into program
  3006                          ; else delete current line and insert this one
  3007                          ; .page
  3008                          ; Test: IF new line is longer than the line it replaces,
  3009                          ;  THEN IF there isn't enough room in memory to add this new line,
  3010                          ;   THEN out-of-memory error
  3011                          ;
  3012                          ; Before this fix, the old line was deleted BEFORE testing if the new line fit.
  3013                          ;
  3014                          ; N.B.: I am assuming that lines cannot be greater than 255 chars, as is the
  3015                          ; case where the line was entered "normally", that is, using LINGET.  The only
  3016                          ; consequence of this assumption is that lines > 255 will fall prey to the
  3017                          ; pre-fix problem mentioned above.
  3018                          
  3019  2f3c a000                                ldy #0
  3020  2f3e 20ad22                              jsr indlow                               ; get lsb of the next line's starting address
  3021  2f41 38                                  sec
  3022  2f42 e561                                sbc lowtr                                ; subtract lsb of this line's starting address
  3023  2f44 38                                  sec                                      ; ignore borrow (gives abs. value)
  3024  2f45 e904                                sbc #4                                   ; allow for link & line number
  3025  2f47 e50d                                sbc count                                ; compare with new length
  3026  2f49 b016                                bcs l25_5                                ; new line is shorter, no problem
  3027  2f4b 42                                  neg                                      ; convert to positive delta
  3028                          
  3029  2f4c a483                                ldy text_top+1                           ; get msb of end of text (.c=0)
  3030  2f4e 6582                                adc text_top                             ; add our calculated delta to end of text
  3031  2f50 9001                                bcc l25_4
  3032  2f52 c8                                  iny
  3033  2f53 ccd002             l25_4            cpy max_mem_0+1
  3034  2f56 9009                                bcc l25_5                                ; result is less than top-of-memory: ok
  3035  2f58 d3e7fe                              +lbne omerr                              ; msb >  top, overflow
  3036  2f5b cdcf02                              cmp max_mem_0                            ; msb's the same, test lsb's
  3037  2f5e b3e1fe                              +lbcs omerr                              ; lsb >= top, overflow
  3038                          
  3039                          ; Using DMA device to move text downwards (to delete or replace a line)...
  3040                          ;
  3041                          ; lowtr     = destination
  3042                          ; (lowtr)    = pointer to source (via link bytes of line to be removed)
  3043                          ; text_top-(lowtr) = number of bytes to move (text_top points to old top of text)
  3044                          ; new text_top     = text_top -( (lowtr)-lowtr )
  3045                          
  3046  2f61 a561               l25_5            lda lowtr                                ; set up DMA destination
  3047  2f63 8d4a01                              sta dma1_dest_lo
  3048  2f66 a562                                lda lowtr+1
  3049  2f68 8d4b01                              sta dma1_dest_hi
  3050  2f6b a000                                ldy #0
  3051  2f6d 20ad22                              jsr indlow                               ; set up DMA source (& delta)
  3052  2f70 8d4701                              sta dma1_src_lo
  3053  2f73 38                                  sec
  3054  2f74 e561                                sbc lowtr
  3055  2f76 8524                                sta index1                               ; (delta lo)
  3056  2f78 c8                                  iny
  3057  2f79 20ad22                              jsr indlow
  3058  2f7c 8d4801                              sta dma1_src_hi
  3059  2f7f e562                                sbc lowtr+1
  3060  2f81 8525                                sta index1+1                             ; (delta hi)
  3061  2f83 38                                  sec
  3062  2f84 a582                                lda text_top                             ; set up DMA count
  3063  2f86 ed4701                              sbc dma1_src_lo
  3064  2f89 8d4501                              sta dma1_cnt_lo
  3065  2f8c a583                                lda text_top+1
  3066  2f8e ed4801                              sbc dma1_src_hi
  3067  2f91 8d4601                              sta dma1_cnt_hi
  3068                          
  3069  2f94 a584                                lda text_bank
  3070                          ; and #%00001111  ;      [910102]
  3071                          ; and #%01111111  ;      [910520] F018A
  3072  2f96 8d4901                              sta dma1_src_bank
  3073  2f99 8d4c01                              sta dma1_dest_bank
  3074                          
  3075  2f9c a900                                lda #0
  3076  2f9e 8d4401                              sta dma1_cmd                             ; dma command (copy, source=start)
  3077  2fa1 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
  3078  2fa4 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
  3079                          
  3080  2fa7 a201                                ldx #>dma1_cmd                           ; dma_list
  3081  2fa9 a944                                lda #<dma1_cmd
  3082  2fab 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
  3083  2fae 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
  3084                          
  3085  2fb1 38                                  sec                                      ; calculate & set new text_top
  3086  2fb2 a582                                lda text_top
  3087  2fb4 e524                                sbc index1
  3088  2fb6 8582                                sta text_top                             ; lo
  3089  2fb8 a583                                lda text_top+1
  3090  2fba e525                                sbc index1+1
  3091  2fbc 8583                                sta text_top+1                           ; hi
  3092                          ;fall into routine to insert new line (if any)
  3093                          
  3094                          ; .page
  3095  2fbe 200935             nodel            jsr init_stack                           ; 'clearc' removed since text changes don't require trashing variables
  3096  2fc1 20b930                              jsr link_program                         ; fix links
  3097  2fc4 20dc44                              jsr error_clear                          ; clear HELP/error flag, assuming he fixed whatever caused current error, if any
  3098                          
  3099  2fc7 a000                                ldy #0
  3100  2fc9 b13d                                lda (txtptr),y                           ; delete line? ("common")
  3101  2fcb f33aff                              +lbeq main                               ; yes
  3102                          
  3103  2fce 18                 l26_1            clc                                      ; no...something to insert
  3104  2fcf a483                                ldy text_top+1
  3105  2fd1 a582                                lda text_top
  3106  2fd3 845d                                sty hightr+1                             ; top of block to move (old text_top)
  3107  2fd5 855c                                sta hightr
  3108  2fd7 650d                                adc count                                ; number of characters in line to be inserted
  3109  2fd9 9001                                bcc l26_2
  3110  2fdb c8                                  iny
  3111  2fdc 18                 l26_2            clc
  3112  2fdd 6904                                adc #4                                   ; plus link and line #
  3113  2fdf 9001                                bcc l26_3                                ; gives us destination of move (new text_top)
  3114  2fe1 c8                                  iny
  3115                          
  3116  2fe2 855a               l26_3            sta highds                               ; destination of top
  3117  2fe4 845b                                sty highds+1
  3118  2fe6 ccd002                              cpy max_mem_0+1                          ; make sure new top doesn't crash into top of available ram
  3119  2fe9 9009                                bcc l26_4                                ; ok
  3120  2feb d354fe                              +lbne omerr                              ; out of memory, don't insert
  3121  2fee cdcf02                              cmp max_mem_0
  3122  2ff1 b34efe                              +lbcs omerr                              ; out of memory, don't insert
  3123                          
  3124  2ff4 8582               l26_4            sta text_top                             ; set new top of text
  3125  2ff6 8483                                sty text_top+1
  3126  2ff8 38                                  sec                                      ; compute number of things to move up
  3127  2ff9 a55c                                lda hightr
  3128  2ffb e561                                sbc lowtr                                ; (old top) - (adr where new line goes)
  3129  2ffd a8                                  tay                                      ; lowtr was setup previously by FindLine call
  3130  2ffe a55d                                lda hightr+1
  3131  3000 e562                                sbc lowtr+1
  3132  3002 aa                                  tax
  3133                          
  3134                          ; Using DMA device to copy data upwards...
  3135                          ;
  3136                          ; (hightr)   = source  (old top)
  3137                          ; (highds)   = destination (new top)
  3138                          ; .y, .x     = number of bytes to move
  3139                          ; (lowtr)    = where to insert new line (starting with link bytes)
  3140                          
  3141  3003 c35c                                dew hightr                               ; (text_top-1) points to actual last byte
  3142  3005 c35a                                dew highds
  3143                          
  3144                          ; lda dma_ctlr+3  ;dma controller version    [910520] F018A
  3145                          ; and #1
  3146                          ; beq l26_5   ; F018    removed [910808] F018B
  3147  3007 a930                                lda #%00110000                           ; F018A, B
  3148  3009 8d4401             l26_5            sta dma1_cmd                             ; command=copy, source=endpt   [910102]
  3149  300c 8c4501                              sty dma1_cnt_lo                          ; count
  3150  300f 8e4601                              stx dma1_cnt_hi
  3151  3012 98                                  tya
  3152  3013 0d4601                              ora dma1_cnt_hi
  3153  3016 f02e                                beq l26_7                                ; special case= nothing to move???? should not happen
  3154                          
  3155  3018 a55c                                lda hightr
  3156  301a a45d                                ldy hightr+1
  3157  301c 8d4701                              sta dma1_src_lo                          ; source
  3158  301f 8c4801                              sty dma1_src_hi
  3159  3022 a55a                                lda highds
  3160  3024 a45b                                ldy highds+1
  3161  3026 8d4a01                              sta dma1_dest_lo                         ; destination
  3162  3029 8c4b01                              sty dma1_dest_hi
  3163  302c a584                                lda text_bank                            ; [910520] F018A
  3164                          ; ldx dma1_cmd  ;version?    removed [910808] F018B
  3165                          ; bne l26_6   ; F018A
  3166                          ; and #%00001111  ;      [910102]
  3167                          ; ora #%01000000  ;(copy source=endpoint)    [910102]
  3168  302e 8d4901             l26_6            sta dma1_src_bank                        ; banks
  3169  3031 8d4c01                              sta dma1_dest_bank
  3170  3034 a900                                lda #0
  3171  3036 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
  3172  3039 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
  3173  303c a201                                ldx #>dma1_cmd                           ; dma_list
  3174  303e a944                                lda #<dma1_cmd
  3175  3040 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
  3176  3043 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
  3177                          
  3178                          ; Make links non-null to fool 'chead'
  3179                          
  3180  3046 a000               l26_7            ldy #0
  3181  3048 a901                                lda #1
  3182  304a a261                                ldx #lowtr
  3183  304c 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=0 (bleed-thru)
  3184  304f c8                                  iny
  3185  3050 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=1 (bleed-thru)
  3186                          
  3187                          ; Put line number in text
  3188                          
  3189  3053 c8                                  iny
  3190  3054 a516                                lda linnum
  3191  3056 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=2 (bleed-thru)
  3192  3059 c8                                  iny
  3193  305a a517                                lda linnum+1
  3194  305c 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=3 (bleed-thru)
  3195                          
  3196                          ; Advance 'lowtr' to start of line (past link bytes & line #)
  3197                          
  3198  305f 18                                  clc
  3199  3060 a561                                lda lowtr
  3200  3062 6904                                adc #4
  3201  3064 8561                                sta lowtr
  3202  3066 9002                                bcc l26_8
  3203  3068 e662                                inc lowtr+1
  3204                          
  3205                          
  3206                          ; Block move line to text
  3207                          
  3208  306a a40d               l26_8            ldy count                                ; use dma ???? [910925]
  3209  306c 88                                  dey
  3210                          
  3211  306d b13d               l26_9            lda (txtptr),y                           ; (from common area)
  3212  306f 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y   (bleed-thru)
  3213  3072 88                                  dey
  3214  3073 c0ff                                cpy #$ff
  3215  3075 d0f6                                bne l26_9
  3216                          
  3217                          ; beq l26_9   ;special case= nothing to move???? should not happen
  3218                          ; lda #0   ; F018A, B
  3219                          ; sta dma1_cmd  ;command=copy, source=start
  3220                          ; sty dma1_cnt_lo  ;count
  3221                          ; sta dma1_cnt_hi
  3222                          ;
  3223                          ; lda txtptr
  3224                          ; ldy txtptr+1
  3225                          ; sta dma1_src_lo  ;source
  3226                          ; sty dma1_src_hi
  3227                          ; lda lowtr
  3228                          ; ldy lowtr+1
  3229                          ; sta dma1_dest_lo ;destination
  3230                          ; sty dma1_dest_hi
  3231                          ; lda text_bank  ;banks
  3232                          ; sta dma1_dest_bank
  3233                          ; lda #sys_bank  ;????
  3234                          ; sta dma1_src_bank
  3235                          ; sta dma1_subcmd  ;      [910520] F018A
  3236                          ; sta dma_ctlr+2  ;dma_list bank
  3237                          ; ldx #>dma1_cmd  ;dma_list
  3238                          ; lda #<dma1_cmd
  3239                          ; stx dma_ctlr+1  ;dma_list hi
  3240                          ; sta dma_ctlr  ;dma_list lo & trigger
  3241                          ;l26_9
  3242  3077 20b930                              jsr link_program
  3243  307a 201f35                              jsr reset_txtptr                         ; set up txtptr (was jsr runc)
  3244                          
  3245                          ; Test if AUTO in effect
  3246                          
  3247  307d a574                                lda autinc                               ; if in auto mode, increment val <> 0
  3248  307f 0575                                ora autinc+1
  3249  3081 f033                                beq l26_12                               ; not in
  3250                          
  3251  3083 a516                                lda linnum                               ; yes, construct new line number
  3252  3085 18                                  clc
  3253  3086 6574                                adc autinc
  3254  3088 8565                                sta facho+1
  3255  308a a517                                lda linnum+1
  3256  308c 6575                                adc autinc+1
  3257  308e b026                                bcs l26_12                               ; no auto if wrapped
  3258  3090 c9fa                                cmp #$fa                                 ; test if # >= 64000
  3259  3092 b022                                bcs l26_12                               ; no auto if so.
  3260  3094 8564                                sta facho
  3261  3096 a290                                ldx #$90
  3262  3098 38                                  sec
  3263  3099 20df62                              jsr floatc                               ; float it
  3264  309c 208f64                              jsr fout                                 ; make it into a string
  3265                          
  3266  309f 78                                  sei                                      ; [910710]
  3267  30a0 a200                                ldx #0                                   ; move string into kbd buffer
  3268  30a2 bd0101             l26_10           lda fbuffr+1,x                           ; copy number formed into buffer, ignoring leading space
  3269  30a5 f006                                beq l26_11                               ; a null marks end
  3270  30a7 9db002                              sta _keyd,x
  3271  30aa e8                                  inx
  3272  30ab d0f5                                bne l26_10                               ; always
  3273                          
  3274  30ad a91d               l26_11           lda #29                                  ; cursor right
  3275  30af 9db002                              sta _keyd,x
  3276  30b2 e8                                  inx
  3277  30b3 86d0                                stx _ndx
  3278  30b5 58                                  cli                                      ; [910710]
  3279                          
  3280  30b6 834ffe             l26_12           +lbra main
  3281                          
  3282                          
  3283                          ; .page
  3284                          link_program
  3285  30b9 a52d                                lda txttab
  3286  30bb a42e                                ldy txttab+1
  3287  30bd 8524                                sta index
  3288  30bf 8425                                sty index+1
  3289  30c1 18                                  clc
  3290                          
  3291  30c2 a000               chead            ldy #0
  3292  30c4 20c122                              jsr indin1                               ; lda (index),y .. check for null link
  3293  30c7 d006                                bne l27_1
  3294  30c9 c8                                  iny
  3295  30ca 20c122                              jsr indin1                               ; lda (index),y
  3296  30cd f042                                beq lnkrts
  3297                          
  3298  30cf a003               l27_1            ldy #3                                   ; [900524]
  3299  30d1 c8                 l27_2            iny                                      ; ???? very expensive loop ????
  3300  30d2 c0fe                                cpy #254
  3301  30d4 b01f                                bcs link_error                           ; failsafe- program is mangled  [910103]
  3302  30d6 20c122                              jsr indin1                               ; lda (index),y
  3303  30d9 d0f6                                bne l27_2
  3304  30db c8                                  iny
  3305  30dc 98                                  tya
  3306  30dd 6524                                adc index
  3307  30df 48                                  pha
  3308  30e0 a000                                ldy #0
  3309  30e2 a224                                ldx #index
  3310  30e4 200c23                              jsr sta_far_ram0                         ; sta (index),y   (bleed-thru)
  3311  30e7 98                                  tya
  3312  30e8 6525                                adc index+1
  3313  30ea c8                                  iny
  3314  30eb 200c23                              jsr sta_far_ram0                         ; sta (index),y   (bleed-thru)
  3315  30ee fa                                  plx
  3316  30ef 8624                                stx index
  3317  30f1 8525                                sta index+1
  3318  30f3 80cd                                bra chead                                ; always
  3319                          
  3320                          
  3321                          link_error                                                ; [910103]
  3322  30f5 20dc3c                              jsr highlight_text                       ; [911119]
  3323  30f8 207dff                              jsr _primm
  3324  30fb 0d3f50524f475241...                 !text cr,"?PROGRAM MANGLED",cr,0
  3325  310e 20cb3c                              jsr highlight_done                       ; [911119]
  3326                          
  3327                          
  3328  3111 60                 lnkrts           rts
  3329                          
  3330                          ; .page
  3331                          ; Function to get a line one character at a time from the input
  3332                          ; channel and build it in the input buffer.
  3333                          ;
  3334                          
  3335                          PromptedInput                                             ; qinlin.
  3336  3112 a515                                lda channl                               ; entry for things line INPUT, wanting a prompt
  3337  3114 d006                                bne InputLine                            ; prompt only if terminal
  3338  3116 206238                              jsr outqst                               ; yes- print '? '
  3339  3119 205f38                              jsr realsp
  3340                          
  3341                          
  3342                          InputLine                                                 ; inlin.
  3343  311c a200                                ldx #0                                   ; read & buffer data until 'return' or buffer full
  3344  311e 204368             l28_1            jsr inchr                                ; get a character
  3345  3121 c900                                cmp #0
  3346  3123 f00f                                beq l28_2
  3347  3125 c90d                                cmp #cr                                  ; a carriage return?
  3348  3127 f00b                                beq l28_2                                ; yes...done build
  3349                          
  3350  3129 9d0002                              sta buf,x                                ; no...buffer it
  3351  312c e8                                  inx
  3352  312d e0a1                                cpx #buflen                              ; buffer full?
  3353  312f 90ed                                bcc l28_1                                ; no...continue
  3354  3131 833d45                              +lbra errlen                             ; yes...string too long error
  3355                          
  3356                          
  3357  3134 a900               l28_2            lda #0                                   ; fininl.  terminate input with a null
  3358  3136 9d0002                              sta buf,x
  3359  3139 a2ff                                ldx #<buf_txtptr                         ; set up pointer to start of buffer-1 (for chrget)
  3360  313b a001                                ldy #>buf_txtptr
  3361  313d a515                                lda channl                               ; print 'return' only if terminal
  3362  313f f3b606                              +lbeq crdo
  3363  3142 60                                  rts
  3364                          
  3365                          ;.end
  3366                          ; .page
  3367                          ; .subttl Runtime Stack Routines
  3368                          
  3369                          ; Find a specific token in the run-time stack. token to be found is in srchtk.
  3370                          ;
  3371                          ; If called by 'for' or 'next', scan entries in stack, looking for a specific
  3372                          ; 'for-variable' (in (forpnt)).  If found, (fndpnt) will point to it, and z is
  3373                          ; set.  Otherwise, (fndpnt) will point to either:
  3374                          ;  1) the non-for token
  3375                          ;  2) bottom-of-stack
  3376                          ;
  3377                          ; Special case: 'next' with no argument will match first 'for' entry on stack
  3378                          ; found, if any.  This case is signaled by a (forpnt) with a msb of $ff (an
  3379                          ; impossible value).
  3380                          ;
  3381                          ; All other calls to search will result in either:
  3382                          ;  1) (success) z = 1, (fndpnt) = address
  3383                          ;  2) (failure) z = 0
  3384                          
  3385                          
  3386                          ; Set up temporary pointer with current top of stack
  3387                          
  3388  3143 8502               search           sta srchtk                               ; save token to search for
  3389  3145 20dd31                              jsr movtos                               ; tos => fndpnt
  3390                          
  3391                          
  3392                          ; Test if pointer is at bottom of stack.  If so, the item was not found.
  3393                          
  3394  3148 a53f               l29_1            lda fndpnt
  3395  314a c9ff                                cmp #<stkbot
  3396  314c d006                                bne l29_2                                ; (fndpnt) <> bottom, ok
  3397  314e a540                                lda fndpnt+1                             ; lsb's the same, test msb's
  3398  3150 c905                                cmp #>stkbot
  3399  3152 f03d                                beq l29_6                                ; stack empty, rts
  3400                          
  3401  3154 a000               l29_2            ldy #0
  3402  3156 a502                                lda srchtk                               ; what are we looking for?
  3403  3158 c981                                cmp #for_token                           ; 'for' tokens are special cases
  3404  315a d01b                                bne l29_4
  3405                          
  3406                          ; Looking for a 'for' token.  If next token examined is not a 'for' token,
  3407                          ; return with z = 0.  Otherwise, check the pointer to its 'for' variable.
  3408                          ; If the variable pointer = (forpnt) or if (forpnt) = $FFxx, return with z=1.
  3409                          ; Otherwise, set up x with length of a 'for' entry, and use the usual
  3410                          ; mechanisim for examining the next entry.
  3411                          
  3412  315c d13f                                cmp (fndpnt),y                           ; indirect ok- looking at runtime stack????
  3413  315e d033                                bne l29_7                                ; not 'for', do rts with z = 0
  3414  3160 a002                                ldy #2                                   ; point to msb of 'for' variable
  3415  3162 a54c                                lda forpnt+1
  3416  3164 c9ff                                cmp #$ff
  3417  3166 f02b                                beq l29_7                                ; do rts with z = 1
  3418  3168 d13f                                cmp (fndpnt),y
  3419  316a d007                                bne l29_3                                ; not right variable, keep looking.
  3420  316c 88                                  dey
  3421  316d a54b                                lda forpnt                               ; test lsb
  3422  316f d13f                                cmp (fndpnt),y
  3423  3171 f020                                beq l29_7                                ; a hit! rts with z = 1
  3424                          
  3425  3173 a212               l29_3            ldx #lenfor
  3426  3175 800e                                bra l29_5                                ; keep looking
  3427                          
  3428  3177 b13f               l29_4            lda (fndpnt),y
  3429  3179 c502                                cmp srchtk                               ; is this the correct type of entry?
  3430  317b f016                                beq l29_7                                ; rts with z = 1
  3431                          
  3432                          ; The entry on top of the run-time stack is not the entry we are looking for.
  3433                          ; Find out what is there, and advance temp. pointer past it.
  3434                          
  3435  317d a212                                ldx #lenfor                              ; is it a 'for' entry?
  3436  317f c981                                cmp #for_token
  3437  3181 f002                                beq l29_5
  3438  3183 a205                                ldx #5                                   ; must be gosub or do by default
  3439                          
  3440  3185 8a                 l29_5            txa
  3441  3186 18                                  clc
  3442  3187 653f                                adc fndpnt
  3443  3189 853f                                sta fndpnt
  3444  318b 90bb                                bcc l29_1
  3445  318d e640                                inc fndpnt+1
  3446  318f 80b7                                bra l29_1                                ; always
  3447                          
  3448  3191 a001               l29_6            ldy #1                                   ; clear z flag
  3449  3193 60                 l29_7            rts
  3450                          
  3451                          ; .page
  3452                          ; GETSTK
  3453                          ;
  3454                          ; Add (.A) elements to top of run-time stack.  Error if result exceeds tos.
  3455                          
  3456  3194 49ff               getstk           eor #$ff                                 ; make value 2's comp.
  3457  3196 38                                  sec
  3458  3197 657c                                adc tos
  3459  3199 857c                                sta tos
  3460  319b a47d                                ldy tos+1
  3461  319d b001                                bcs l30_1
  3462  319f 88                                  dey
  3463  31a0 847d               l30_1            sty tos+1
  3464  31a2 c004                                cpy #>stktop
  3465  31a4 939bfc                              +lbcc omerr
  3466  31a7 d005                                bne l30_2
  3467  31a9 c57c                                cmp tos
  3468  31ab 9394fc                              +lbcc omerr
  3469  31ae 60                 l30_2            rts
  3470                          
  3471                          ; .page
  3472                          ; (a,y) is a certain address.  REASON makes sure it is less than (fretop).
  3473                          
  3474  31af c436               reason           cpy fretop+1
  3475  31b1 9029                                bcc l31_4
  3476  31b3 d004                                bne l31_1                                ; go garbage collect
  3477  31b5 c535                                cmp fretop
  3478  31b7 9023                                bcc l31_4
  3479                          
  3480  31b9 48                 l31_1            pha
  3481  31ba a209                                ldx #9                                   ; if tempf2 has zero in between
  3482  31bc 98                                  tya
  3483                          
  3484  31bd 48                 l31_2            pha
  3485  31be b559                                lda highds-1,x                           ; save highds on stack
  3486  31c0 ca                                  dex
  3487  31c1 10fa                                bpl l31_2                                ; put 8 of them on stack
  3488  31c3 20335c                              jsr garba2                               ; go garbage collect
  3489  31c6 a2f7                                ldx #$f7
  3490                          
  3491  31c8 68                 l31_3            pla
  3492  31c9 9563                                sta highds+9,x                           ; restore after garbage collect
  3493  31cb e8                                  inx
  3494  31cc 30fa                                bmi l31_3
  3495  31ce 7a                                  ply
  3496  31cf 68                                  pla                                      ; restore .a and .y
  3497  31d0 c436                                cpy fretop+1                             ; compare highs
  3498  31d2 9008                                bcc l31_4
  3499  31d4 d36bfc                              +lbne omerr                              ; higher is bad
  3500  31d7 c535                                cmp fretop                               ; compare the lows
  3501  31d9 b366fc                              +lbcs omerr
  3502  31dc 60                 l31_4            rts
  3503                          
  3504                          ; .page
  3505                          
  3506                          ;  Utilities involved in the operation of the BASIC run-time stack.
  3507                          
  3508                          
  3509                          ; Move top-of-stack pointer to (fndpnt)
  3510                          
  3511  31dd a57c               movtos           lda tos
  3512  31df 853f                                sta fndpnt
  3513  31e1 a57d                                lda tos+1
  3514  31e3 8540                                sta fndpnt+1
  3515  31e5 60                                  rts
  3516                          
  3517                          
  3518                          
  3519                          ; move (fndpnt) to (tos)
  3520                          
  3521  31e6 a53f               movfnd           lda fndpnt
  3522  31e8 857c                                sta tos
  3523  31ea a540                                lda fndpnt+1
  3524  31ec 857d                                sta tos+1
  3525  31ee 60                                  rts
  3526                          
  3527                          ; Reduce size of run-time stack by (y).  No error checking performed!
  3528                          
  3529  31ef 98                 rlsstk           tya
  3530  31f0 18                                  clc
  3531  31f1 657c                                adc tos
  3532  31f3 857c                                sta tos
  3533  31f5 9002                                bcc l32_1
  3534  31f7 e67d                                inc tos+1
  3535  31f9 60                 l32_1            rts
  3536                          
  3537                          ;.end
  3538                          ; .page
  3539                          ; .subttl FindLine
  3540                          
  3541                          ; FindLine
  3542                          ; Searches the program text for the line whose number is passed in "linnum".
  3543                          ; There are two possible returns:
  3544                          ;
  3545                          ; 1) carry set.
  3546                          ;  Line found.  (lowtr) points to the link bytes of line sought.
  3547                          ;
  3548                          ; 2) carry clear.
  3549                          ;  Line not found.  (lowtr) points to the link bytes of the next
  3550                          ;  line greater than the one sought.
  3551                          
  3552                          FindLine
  3553  31fa a52d                                lda txttab                               ; init pointer to beginning of program
  3554  31fc a62e                                ldx txttab+1
  3555                          
  3556                          FindLink
  3557  31fe 8561                                sta lowtr                                ; current position in program
  3558  3200 8662                                stx lowtr+1
  3559  3202 a001                                ldy #1
  3560  3204 20ad22                              jsr indlow                               ; end of program (null link)?
  3561  3207 f023                                beq l33_3                                ; yes, exit with .c=0 (not found)
  3562  3209 c8                                  iny
  3563  320a c8                                  iny
  3564  320b 20ad22                              jsr indlow                               ; get line number of this line (high byte first)
  3565                          ; sta syntmp
  3566                          ; lda linnum+1 ;is this the line we're looking for?
  3567                          ; cmp syntmp
  3568                          ; bcc l33_4  ; no- too high, so the line does not exist, exit
  3569                          ; beq l33_1
  3570                          ; dey  ; no- too low, so get link to next line
  3571                          ; bra l33_2
  3572  320e c517                                cmp linnum+1                             ; is this the line we're looking for?   [910925]
  3573  3210 f005                                beq l33_1                                ; maybe
  3574  3212 b018                                bcs l33_3                                ; no- too high, so the line does not exist, exit with .c=0
  3575  3214 88                                  dey                                      ; no- too low, so get link to next line
  3576  3215 800a                                bra l33_2
  3577                          
  3578  3217 88                 l33_1            dey                                      ; maybe- have to check low byte
  3579  3218 20ad22                              jsr indlow
  3580                          ; sta syntmp
  3581                          ; lda linnum
  3582                          ; cmp syntmp
  3583                          ; bcc l33_4  ; no- too high, exit
  3584                          ; beq l33_4  ; yes- got it, exit
  3585  321b c516                                cmp linnum                               ; is this the line we're looking for?   [910925]
  3586  321d f00e                                beq l33_4                                ; yes- got it, exit with .c=1
  3587  321f b00b                                bcs l33_3                                ; no- too high, so the line does not exist, exit with .c=0
  3588                          
  3589  3221 88                 l33_2            dey                                      ; get link to next line
  3590  3222 20ad22                              jsr indlow
  3591  3225 aa                                  tax
  3592  3226 88                                  dey
  3593  3227 20ad22                              jsr indlow
  3594  322a 80d2                                bra FindLink                             ; continue looking
  3595                          
  3596                          
  3597  322c 18                 l33_3            clc                                      ; exit, line not found (.c=0)
  3598  322d 60                 l33_4            rts                                      ; exit, line found (.c=1)
  3599                          
  3600                          ;.end
  3601                          ; .page
  3602                          ; .subttl LinGet
  3603                          
  3604                          ; LINGET  Reads a line # from the current txtptr position
  3605                          ;   and stores it in linnum  (valid range is 0-63999).
  3606                          ;
  3607                          ;   On exit txtptr is pointing to the terminating char
  3608                          ;   which is in .a with condition codes set.
  3609                          ;   Endchr will be =0 if no digit input, else >0.  Use it
  3610                          ;   to distinguish between line # 0 & null input.
  3611                          
  3612  322e a200               linget           ldx #0                                   ; enter with CHRGET flags set
  3613  3230 860b                                stx endchr                               ; flags line # input
  3614  3232 8616                                stx linnum                               ; init line # to 0
  3615  3234 8617                                stx linnum+1
  3616                          
  3617  3236 b04b               l34_1            bcs l34_5                                ; it's not a digit, do rts
  3618  3238 e60b               l34_2            inc endchr                               ; indicate line # input
  3619  323a e92f                                sbc #$2f                                 ; '0'-1 since .c=0
  3620  323c 850a                                sta charac                               ; save for later
  3621  323e a517                                lda linnum+1
  3622  3240 8524                                sta index
  3623  3242 c919                                cmp #25                                  ; line number will be < 64000?
  3624  3244 9006                                bcc l34_3                                ; yes, continue
  3625  3246 9f553a                              bbs1 helper,l34_5                        ; no, if called by AutoScroll it's okay
  3626  3249 83fffb                              +lbra snerr                              ; else syntax error
  3627                          
  3628  324c a516               l34_3            lda linnum
  3629  324e 0a                                  asl                                      ; multiply by 10
  3630  324f 2624                                rol index
  3631  3251 0a                                  asl
  3632  3252 2624                                rol index
  3633  3254 6516                                adc linnum
  3634  3256 8516                                sta linnum
  3635  3258 a524                                lda index
  3636  325a 6517                                adc linnum+1
  3637  325c 8517                                sta linnum+1
  3638  325e 0616                                asl linnum
  3639  3260 2617                                rol linnum+1
  3640  3262 a516                                lda linnum
  3641  3264 650a                                adc charac                               ; add in digit
  3642  3266 8516                                sta linnum
  3643  3268 9002                                bcc l34_4
  3644  326a e617                                inc linnum+1
  3645                          l34_4
  3646                          ; jsr chrget  ;ALLOW SPACES to terminate number  [910620]
  3647                          ; bra l34_1
  3648  326c e33d                                inw txtptr                               ; get next character from text
  3649  326e a000                                ldy #0                                   ; re-get current character from text
  3650  3270 20c522                              jsr indtxt                               ; lda (txtptr),y from RAM0
  3651  3273 c920                                cmp #' '                                 ; space=eol    [910708]
  3652  3275 f00d                                beq l34_6
  3653  3277 c93a                                cmp #':'                                 ;
  3654  3279 b008                                bcs l34_5                                ; eol
  3655  327b 38                                  sec
  3656  327c e930                                sbc #'0'                                 ; alpha or numeric?
  3657  327e 38                                  sec
  3658  327f e9d0                                sbc #$d0
  3659  3281 90b5                                bcc l34_2                                ; numeric
  3660  3283 60                 l34_5            rts                                      ; exit
  3661                          
  3662  3284 20a540             l34_6            jsr chargt                               ; terminating character is a space, eat it just this once
  3663  3287 8305f0                              +lbra chrtst                             ; return with flags set appropriately (esp. for 'range')
  3664                          
  3665                          ;.end
  3666                          ; .page
  3667                          ; .subttl LIST
  3668                          
  3669  328a 7755               list             rmb7 helper                              ; clear 'help' flag for p1line
  3670                          
  3671                          ; Determine which form of LIST we have...
  3672                          
  3673  328c f3aa00                              +lbeq list_memory                        ; branch if terminator (no parameter)
  3674  328f 93a700                              +lbcc list_memory                        ; branch if a number (assume range parameter)
  3675  3292 c9ab                                cmp #minus_token
  3676  3294 f3a200                              +lbeq list_memory                        ; branch if a dash (assume range parameter)
  3677                          
  3678                          
  3679                          ; LIST command is of the form  LIST filename [,U#] [,D#]
  3680                          
  3681                          list_file
  3682  3297 a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
  3683  3299 202074                              jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 )
  3684  329c 20dc77                              jsr chk1                                 ; check parameters
  3685  329f a900                                lda #0
  3686  32a1 8d8311                              sta dossa                                ; setup as dload would (0 = load channel)
  3687  32a4 201d71                              jsr find_la                              ; find an available la to use (cannot use reserved one)
  3688  32a7 a009                                ldy #fopn
  3689  32a9 a204                                ldx #4
  3690  32ab 20fd70                              jsr open_file                            ; open the file
  3691  32ae b077                                bcs list_err                             ; exit if error
  3692                          
  3693  32b0 ae8111                              ldx dosla
  3694  32b3 20c6ff                              jsr _chkin                               ; get input channel
  3695  32b6 b06f                                bcs list_err                             ; exit if bad??
  3696  32b8 20cfff                              jsr _basin                               ; waste 'load address'
  3697  32bb 20cfff                              jsr _basin
  3698                          
  3699  32be 20cfff             l35_1            jsr _basin                               ; get link bytes
  3700  32c1 8d0013                              sta dosstr
  3701  32c4 20cfff                              jsr _basin
  3702  32c7 8d0113                              sta dosstr+1
  3703  32ca 0d0013                              ora dosstr
  3704  32cd f051                                beq list_exit                            ; done if null pointer
  3705  32cf 20b7ff                              jsr _readst
  3706  32d2 d04c                                bne list_exit                            ; done if eof or bad status
  3707                          ; ???? assumes serial bus
  3708  32d4 a913                                lda #>dosstr                             ; point p1line's pointer at our line buffer
  3709  32d6 a200                                ldx #<dosstr
  3710  32d8 8562                                sta lowtr+1
  3711  32da 8661                                stx lowtr
  3712                          
  3713  32dc a202                                ldx #2
  3714  32de 20cfff                              jsr _basin                               ; read line into buffer
  3715  32e1 9d0013                              sta dosstr,x
  3716  32e4 e8                                  inx
  3717  32e5 20cfff                              jsr _basin                               ; 2-byte line #
  3718  32e8 9d0013                              sta dosstr,x
  3719  32eb e8                                  inx
  3720  32ec e0ff               l35_2            cpx #255                                 ; check buffer (buflen????)
  3721  32ee b38043                              +lbcs errlen                             ; 'too long' error
  3722  32f1 20cfff                              jsr _basin
  3723  32f4 9d0013                              sta dosstr,x
  3724  32f7 e8                                  inx
  3725  32f8 a8                                  tay                                      ; save char
  3726  32f9 20b7ff                              jsr _readst                              ; check channel status (serial bus????)
  3727  32fc d022                                bne list_exit                            ; exit if eof or error
  3728  32fe 20e1ff                              jsr _stop
  3729  3301 f01d                                beq list_exit                            ; exit if stop key down
  3730  3303 98                                  tya
  3731  3304 d0e6                                bne l35_2                                ; loop until eol
  3732                          
  3733  3306 20c770                              jsr dcato                                ; get output channel
  3734  3309 20f737                              jsr crdo                                 ; start new line
  3735  330c ae0213                              ldx dosstr+2                             ; get line #
  3736  330f ad0313                              lda dosstr+3
  3737  3312 207733                              jsr p1line                               ; print line #, space, and the line of code
  3738  3315 20ccff                              jsr _clrch
  3739  3318 ae8111                              ldx dosla
  3740  331b 20c6ff                              jsr _chkin                               ; get input channel
  3741  331e 909e                                bcc l35_1                                ; [900730]
  3742                          
  3743                          list_exit
  3744  3320 20c770                              jsr dcato                                ; flush last line with a <cr>
  3745  3323 20f737                              jsr crdo                                 ; flush current line
  3746  3326 18                                  clc                                      ; no errors    [910404]
  3747                          list_err
  3748  3327 08                                  php                                      ; save error status   [910404]
  3749  3328 48                                  pha
  3750  3329 20b438                              jsr release_channels                     ; release cmd channel, restore terminal
  3751  332c ad8111                              lda dosla
  3752                          ; bra close_out  ;    removed [900725]
  3753  332f 18                                  clc                                      ; a real close   new [910404]
  3754  3330 20c3ff                              jsr _close
  3755  3333 68                                  pla                                      ; pop error status, if any
  3756  3334 28                                  plp
  3757  3335 833735                              +lbra exit_disk_op
  3758                          
  3759                          ; .page
  3760                          ; LIST command is of the form  LIST [range]
  3761                          
  3762                          list_memory
  3763  3338 205042                              jsr range                                ; set up line range
  3764                          
  3765  333b a001               l36_1            ldy #1
  3766  333d 20ad22                              jsr indlow                               ; get ms byte of line to list's pointer
  3767  3340 d007                                bne l36_2                                ; ok if not zero, but..
  3768  3342 88                                  dey
  3769  3343 20ad22                              jsr indlow
  3770  3346 f3af04                              +lbeq crdo                               ; ..if ls byte is also zero, we're done
  3771                          
  3772  3349 20cc2c             l36_2            jsr is_stop_key_down
  3773  334c 20f737                              jsr crdo                                 ; new line
  3774  334f a002                                ldy #2
  3775  3351 20ad22                              jsr indlow                               ; get ms byte of line number
  3776  3354 aa                                  tax
  3777  3355 c8                                  iny
  3778  3356 20ad22                              jsr indlow                               ; get ls byte
  3779                          
  3780  3359 c517                                cmp linnum+1                             ; test if we are past the last line requested
  3781  335b d004                                bne l36_3
  3782  335d e416                                cpx linnum
  3783  335f f003                                beq l36_4
  3784  3361 b39404             l36_3            +lbcs crdo                               ; next line is > last line requested, exit
  3785  3364 207733             l36_4            jsr p1line                               ; print line #, space, and the line of code
  3786  3367 a000                                ldy #0                                   ; move 'pointer to next line' into (lowtr)
  3787  3369 20ad22                              jsr indlow
  3788  336c aa                                  tax
  3789  336d c8                                  iny
  3790  336e 20ad22                              jsr indlow
  3791  3371 8661                                stx lowtr
  3792  3373 8562                                sta lowtr+1
  3793  3375 80c4                                bra l36_1
  3794                          
  3795                          ; .page
  3796                          ;******************************************************
  3797                          ; P1LINE Print 1 line of BASIC text
  3798                          ;
  3799                          ; Entry: (a,x) contains line number low,high
  3800                          ;  (lowtr) points to beginning of line
  3801                          ;
  3802                          ; next-line   line-num  BASIC text......  null
  3803                          ; lo    hi    lo    hi  byte byte...byte   00
  3804                          ;        ^           ^     ^
  3805                          ;    (lowtr)        .A    .X
  3806                          ;******************************************************
  3807                          
  3808  3377 4f7e03             p1line           bbr4 runmod,l37_1                        ; [910620]
  3809  337a 837a89                              +lbra edit_p1line                        ; handle things differently for plain text
  3810                          
  3811  337d a003               l37_1            ldy #3
  3812  337f 844b                                sty lstpnt
  3813  3381 8411                                sty dores                                ; reset quote-switch
  3814  3383 207f64                              jsr linprt                               ; print line number
  3815  3386 a920                                lda #' '                                 ; print a space
  3816                          
  3817  3388 a44b               p1l010           ldy lstpnt
  3818  338a 297f                                and #$7f
  3819                          
  3820  338c c93a               p1l015           cmp #':'                                 ; end-of-stmt?     [900516]
  3821  338e d00b                                bne l38_1                                ; no
  3822  3390 7f5508                              bbr7 helper,l38_1                        ; yes, but skip e-o-s check if not HELP...
  3823  3393 ff1105                              bbs7 dores,l38_1                         ; or ':' is inside quotes
  3824  3396 20cb3c                              jsr highlight_done                       ; yes, restore normal text color
  3825  3399 a93a                                lda #':'
  3826                          
  3827  339b 203d68             l38_1            jsr outch                                ; outdo
  3828  339e c922                                cmp #'"'                                 ; if quote character, toggle quote-switch
  3829  33a0 d006                                bne l38_2
  3830  33a2 a511                                lda dores
  3831  33a4 49ff                                eor #$ff
  3832  33a6 8511                                sta dores
  3833                          
  3834  33a8 c8                 l38_2            iny                                      ; point to next character (should never wrap)
  3835  33a9 8f5506                              bbs0 helper,l38_3                        ; branch if highlighting tokens
  3836  33ac df5503                              bbs5 helper,l38_3                        ; branch if called by FIND/CHANGE
  3837  33af 7f5503                              bbr7 helper,l38_4                        ; branch if called by LIST or HELP satisfied
  3838  33b2 20963c             l38_3            jsr helpsb
  3839                          
  3840  33b5 20ad22             l38_4            jsr indlow
  3841  33b8 f31109                              +lbeq highlight_done                     ; finished when trailing null is found
  3842  33bb 6c0603                              jmp (iqplop)                             ; usually points to nqplop
  3843                          
  3844                          ; .page
  3845                          nqplop                                                    ; <<<<<<< vector entry
  3846  33be 10cc                                bpl p1l015                               ; not a token, just print character
  3847  33c0 ff11c9                              bbs7 dores,p1l015                        ; branch if inside quotes, print chr as is
  3848                          
  3849                          ;  At this point, we know we're talking token.  Scan the token text
  3850                          ;  list until the correct text is found, and print that text.
  3851                          
  3852  33c3 8554                                sta token_saver                          ; save token for REM check   [910626]
  3853  33c5 c9fe                                cmp #esc_command_token                   ; is this an escape token?
  3854  33c7 f042                                beq print_esc_cmd                        ; yes- escape command
  3855  33c9 c9ce                                cmp #esc_function_token
  3856  33cb f059                                beq print_esc_fn                         ; yes- escape function
  3857  33cd c9ff                                cmp #pi
  3858  33cf f0bb                                beq p1l015                               ; no- pi is >$80, but should be printed 'as is'
  3859  33d1 aa                                  tax
  3860  33d2 844b                                sty lstpnt                               ; no- use the token as index into ROM keyword list
  3861  33d4 a924                                lda #>keyword_list
  3862  33d6 a03a                                ldy #<keyword_list
  3863                          
  3864                          ; Scan list pointed to by (y,a) for token in (x), and print token's text
  3865                          
  3866  33d8 8525               p1l026           sta index1+1                             ; index1 points to token text list in ROM
  3867  33da 8424                                sty index1
  3868  33dc a000                                ldy #0                                   ; begin scanning lists for this token's text
  3869  33de ca                                  dex
  3870  33df 1014                                bpl p1l070                               ; what luck! it's the first one
  3871                          
  3872  33e1 e324               l39_1            inw index1                               ; scan text until next command found
  3873  33e3 b124                                lda (index1),y                           ; ind.ok (ROM)
  3874  33e5 10fa                                bpl l39_1                                ; loop until terminal char (msb=1)
  3875  33e7 ca                                  dex                                      ; is next text the one we want?
  3876  33e8 30f7                                bmi l39_1                                ; no, keep scanning
  3877  33ea e324                                inw index1                               ; yes, point to first character
  3878                          
  3879  33ec 3f5506                              bbr3 helper,p1l070                       ; found text for this token, is it REM?  [910626]
  3880  33ef a554                                lda token_saver                          ; [910628]
  3881  33f1 c98f                                cmp #rem_token
  3882  33f3 f009                                beq p1l071                               ; yes, and REM highlighting is enabled
  3883                          
  3884                          p1l070                                                    ; found text for this token
  3885  33f5 4f5509                              bbr4 helper,p1l072                       ; branch if not highlighting tokens
  3886  33f8 b124                                lda (index1),y                           ; peek at first character
  3887  33fa 308c                                bmi p1l010                               ; branch if operator (1-byte, msb=1)
  3888  33fc 8755                                smb0 helper                              ; else begin highlight
  3889  33fe 20dc3c             p1l071           jsr highlight_text
  3890                          
  3891  3401 b124               p1l072           lda (index1),y                           ; get char from ROM table
  3892  3403 3083                                bmi p1l010                               ; msb=1=last char this token, contine line
  3893  3405 203d68                              jsr outch                                ; else print it
  3894  3408 c8                                  iny
  3895  3409 80f6                                bra p1l072
  3896                          
  3897                          ; .page
  3898                          ; Print Escape Command
  3899                          
  3900                          print_esc_cmd
  3901  340b aa                                  tax                                      ; save type (cmd) in case it is a foreign esc token
  3902  340c c8                                  iny
  3903  340d 20ad22                              jsr indlow                               ; look at second token
  3904  3410 f37aff                              +lbeq p1l015                             ; none?  print funny character
  3905  3413 844b                                sty lstpnt
  3906  3415 c902                                cmp #first_esc_command_token             ; is this one of ours?
  3907  3417 9028                                bcc print_foreign_esc                    ; nope
  3908  3419 c946                                cmp #last_esc_command_token+1
  3909  341b b024                                bcs print_foreign_esc                    ; nope
  3910  341d 697e                                adc #$80-first_esc_command_token         ; yes- make a pointer p1l will be proud of
  3911  341f aa                                  tax
  3912  3420 a029                                ldy #<esc_command_list
  3913  3422 a926                                lda #>esc_command_list
  3914  3424 80b2                                bra p1l026                               ; go scan list and print it
  3915                          
  3916                          
  3917                          
  3918                          ; Print Escape Function
  3919                          
  3920                          print_esc_fn
  3921  3426 aa                                  tax                                      ; save type (function) in case it's a foreign esc token
  3922  3427 c8                                  iny
  3923  3428 20ad22                              jsr indlow                               ; look at second token
  3924  342b f35fff                              +lbeq p1l015                             ; none?  print funny character
  3925  342e 844b                                sty lstpnt
  3926  3430 c902                                cmp #first_esc_function_token            ; is this one of ours?
  3927  3432 900d                                bcc print_foreign_esc                    ; nope
  3928  3434 c90e                                cmp #last_esc_function_token+1
  3929  3436 b009                                bcs print_foreign_esc                    ; nope
  3930  3438 697e                                adc #$80-first_esc_function_token        ; yes- make a pointer p1l will be proud of
  3931  343a aa                                  tax
  3932  343b a09a                                ldy #<esc_function_list
  3933  343d a927                                lda #>esc_function_list
  3934  343f 8097                                bra p1l026                               ; go scan list and print it
  3935                          
  3936                          ; .page
  3937                          ; The token to be printed is an escape token which is NOT recognized by BASIC.
  3938                          ; We will jump through the indirect chain and see if anyone claims this token.
  3939                          ;
  3940                          ; At this point:
  3941                          ; .C = 1 to signal 'unclaimed'
  3942                          ; .X = type (0==>command, ff==>function)
  3943                          ; .A = second token character
  3944                          ;
  3945                          ; If anyone claims this token, they should:
  3946                          ;
  3947                          ; > Clear .C to flag 'taken'
  3948                          ; > Point (INDEX1) at the string to be printed (with msb of last char set)
  3949                          ; > Note: string to print MUST be in RAM-0!
  3950                          
  3951                          print_foreign_esc
  3952  3441 e0fe                                cpx #esc_command_token
  3953  3443 d003                                bne l40_1
  3954  3445 a200                                ldx #0
  3955  3447 2c                                  !text $2c
  3956                          
  3957  3448 a2ff               l40_1            ldx #$ff
  3958  344a 38                                  sec
  3959  344b 6c0e03                              jmp (iescpr)
  3960                          
  3961  344e b33cff             nescpr           +lbcs p1l015                             ; no takers, print a funny graphic character
  3962  3451 a000                                ldy #0
  3963  3453 80a0                                bra p1l070
  3964                          
  3965                          
  3966                          ;.end
  3967                          ; .page
  3968                          ; .subttl NEW  CLR
  3969                          ;
  3970                          ; The NEW command clears the program text as well as variable space.
  3971                          ;
  3972                          
  3973  3455 f021               new              beq init_text                            ; Erase program in memory
  3974  3457 c98c                                cmp #restore_token                       ; Restore an erased program?    [910103]
  3975  3459 d3eff9                              +lbne snerr                              ; no- syntax error    [910410]
  3976  345c 2022b5                              jsr chkeos                               ; yes- eat token, error if not eos  [910429]
  3977  345f a52d                                lda txttab                               ; "seed" first link to fool 'chead'
  3978  3461 a62e                                ldx txttab+1
  3979  3463 8524                                sta index
  3980  3465 8625                                stx index+1
  3981  3467 a900                                lda #0
  3982  3469 a001                                ldy #1
  3983  346b a224                                ldx #index
  3984  346d 200c23                              jsr sta_far_ram0                         ; clear msb  (bleed-thru)
  3985  3470 88                                  dey
  3986  3471 1a                                  inc
  3987  3472 200c23                              jsr sta_far_ram0                         ; set lsb   (bleed-thru)
  3988  3475 839c09                              +lbra renumber                           ; make renumber check it for us (not 100%) & relink
  3989                          
  3990                          
  3991                          init_text
  3992  3478 a52d                                lda txttab                               ; find the bottom of basic text
  3993  347a a62e                                ldx txttab+1
  3994  347c 8524                                sta index
  3995  347e 8625                                stx index+1
  3996  3480 c324                                dew index                                ; (the absolute bottom)
  3997                          
  3998  3482 a900                                lda #0
  3999  3484 a8                                  tay
  4000  3485 a224                                ldx #index
  4001  3487 200c23                              jsr sta_far_ram0                         ; clear bottom     (bleed-thru)
  4002  348a c8                                  iny
  4003  348b 200c23                              jsr sta_far_ram0                         ; clear first link bytes    (bleed-thru)
  4004  348e c8                                  iny
  4005  348f 200c23                              jsr sta_far_ram0                         ; (bleed-thru)
  4006  3492 18                                  clc
  4007  3493 a52d                                lda txttab
  4008  3495 6902                                adc #2
  4009  3497 8582                                sta text_top                             ; set up (text_top), the end of text
  4010  3499 a52e                                lda txttab+1
  4011  349b 6900                                adc #0
  4012  349d 8583                                sta text_top+1
  4013                          
  4014  349f 577e                                rmb5 runmod                              ; trcflg. reset trace flag
  4015                          
  4016                          
  4017  34a1 201f35             runc             jsr reset_txtptr                         ; load (txtptr) with (txttab)-1
  4018  34a4 8025                                bra clearc                               ; "CLR" to clear vars    [910410]
  4019                          
  4020                          ; .page
  4021                          ; CLeaR Routines
  4022                          ;
  4023                          
  4024                          ; Special forms of CLR command:
  4025                          ;
  4026                          ; CLR ERR$ Clears program error status, useful in TRAP handlers which
  4027                          ;   have resolved an error & wish to RESUME with a clean status.
  4028                          ;
  4029                          ; CLR DS$  Clears the currently buffered DS,DS$ messages.  The next
  4030                          ;   use of DS or DS$ will make BASIC re a new message from DOS.
  4031                          
  4032  34a6 f023               clear            beq clearc                               ; branch if no args    [910410]
  4033                          
  4034  34a8 c9d3                                cmp #err_token                           ; CLR ERR$
  4035  34aa d006                                bne l41_1                                ; no
  4036  34ac 2022b5                              jsr chkeos                               ; yes- eat token & error if not eos
  4037  34af 832b10                              +lbra error_clear                        ; and go clear ERR$
  4038                          
  4039  34b2 c944               l41_1            cmp #'D'                                 ; CLR DS$     [910717]
  4040  34b4 d00c                                bne l41_2                                ; no- error
  4041  34b6 208322                              jsr chrget
  4042  34b9 c953                                cmp #'S'
  4043  34bb d005                                bne l41_2
  4044  34bd 208322                              jsr chrget
  4045  34c0 c924                                cmp #'$'
  4046  34c2 d386f9             l41_2            +lbne snerr                              ; no- error
  4047  34c5 2022b5                              jsr chkeos
  4048  34c8 83b843                              +lbra Clear_DS                           ; yes- clear current DS$
  4049                          
  4050                          ; .page
  4051                          ; Clearc is a subroutine which initializes the variable and array space by
  4052                          ; resetting STREND (the end of array storage).  It falls into INIT_STACK,
  4053                          ; which resets the stack.
  4054                          
  4055  34cb 20e7ff             clearc           jsr _clall                               ; close all files
  4056  34ce a000                                ldy #0
  4057  34d0 8479                                sty dsdesc                               ; flag 'no DS$ string'
  4058  34d2 88                                  dey                                      ; (y=$ff)
  4059  34d3 8ccb02                              sty trapno+1                             ; flag no current trap line
  4060  34d6 8cc802                              sty errlin                               ; reset last error pointers
  4061  34d9 8cc902                              sty errlin+1
  4062  34dc 8cc702                              sty errnum
  4063                          
  4064  34df a539                                lda max_mem_1                            ; clear string space
  4065  34e1 a43a                                ldy max_mem_1+1
  4066  34e3 8535                                sta fretop
  4067  34e5 8436                                sty fretop+1
  4068                          
  4069  34e7 a9ff                                lda #<stkbot                             ; empty run-time stack
  4070  34e9 a005                                ldy #>stkbot
  4071  34eb 857c                                sta tos
  4072  34ed 847d                                sty tos+1
  4073                          
  4074  34ef a52f                                lda vartab
  4075  34f1 a430                                ldy vartab+1
  4076  34f3 8531                                sta arytab                               ; this will delete all variables,
  4077  34f5 8432                                sty arytab+1
  4078  34f7 8533                                sta strend                               ; ..and arrays
  4079  34f9 8434                                sty strend+1
  4080                          
  4081  34fb a203                                ldx #pumony-puchrs                       ; reset print using chars
  4082  34fd bddb69             l42_1            lda pudefs,x
  4083  3500 9dd411                              sta puchrs,x
  4084  3503 ca                                  dex
  4085  3504 10f7                                bpl l42_1
  4086                          
  4087  3506 20fc3d             fload            jsr restore__1                           ; reset pointer for DATA statements
  4088                          
  4089                          ; .page
  4090                          ; INIT_STACK Routine (formerly STKINI)
  4091                          ;
  4092                          ;   Init_Stack resets the stack pointer.  String temporaries are freed up,
  4093                          ;   SUBFLG is reset, continuing is prohibited.
  4094                          
  4095                          init_stack
  4096  3509 7a                                  ply                                      ; pop return address
  4097  350a 68                                  pla
  4098  350b a2fa                                ldx #stkend-257                          ; reset system stack pointer
  4099  350d 9a                                  txs
  4100  350e 48                                  pha                                      ; push return address
  4101  350f 5a                                  phy
  4102  3510 a21b                                ldx #tempst                              ; reset string temporaries
  4103  3512 8618                                stx temppt
  4104  3514 a900                                lda #0
  4105  3516 8512                                sta subflg                               ; allow subscripted & integer vars
  4106  3518 8d7311                              sta oldtxt+1                             ; disallow continuing
  4107  351b 8dd702                              sta bits                                 ; reset math bit/byte flag
  4108                          
  4109  351e 60                 stkrts           rts
  4110                          
  4111                          
  4112                          
  4113                          reset_txtptr
  4114  351f 18                                  clc                                      ; load (txtptr) with (txttab)-1
  4115  3520 a52d                                lda txttab
  4116  3522 69ff                                adc #$ff
  4117  3524 853d                                sta txtptr
  4118  3526 a52e                                lda txttab+1
  4119  3528 69ff                                adc #$ff
  4120  352a 853e                                sta txtptr+1                             ; set up text pointers
  4121  352c 60                                  rts
  4122                          
  4123                          ;.end
  4124                          ; .page
  4125                          ; .subttl RETURN
  4126                          ;*********************************************************************
  4127                          ; RETURN Routine
  4128                          ;
  4129                          ; Restores the line number and text pointer from the stack, and
  4130                          ; eliminates all the FOR entries in front of the GOSUB entry.
  4131                          ;
  4132                          ;*********************************************************************
  4133                          
  4134                          return
  4135                          
  4136                          ; Ok, pay attention: we got here by a pseudo-jsr which left a return to NEWSTT
  4137                          ; on the stack for us to return to.  There is also a return to NEWSTT left on
  4138                          ; the stack from the GOSUB we are returning from.  This is true UNLESS we got
  4139                          ; here on a sprite collision, in which case we still have the NEWSUB return
  4140                          ; recently left by our current call, but the second return goes back to the
  4141                          ; trapping mechanism.  The bottom line is: we have an extra return address on
  4142                          ; the stack, which we have to get rid of before leaving.
  4143                          
  4144  352d 68                                  pla                                      ; mea culpa, mea culpa, mea culpa
  4145  352e 68                                  pla
  4146  352f a98d                                lda #gosub_token
  4147  3531 204331                              jsr search                               ; look for GOSUB on runtime stack
  4148  3534 f005                                beq ret010                               ; found
  4149  3536 a20c                                ldx #errrg                               ; else error
  4150  3538 8315f9                              +lbra error
  4151                          
  4152  353b 20e631             ret010           jsr movfnd                               ; (fndpnt) => (tos)
  4153  353e a005                                ldy #lengos
  4154  3540 20ef31                              jsr rlsstk                               ; effectivly pop GOSUB off run-time stack
  4155                          ; dey
  4156                          ; lda (fndpnt),y
  4157                          ; sta txtptr+1
  4158                          ; dey
  4159                          ; lda (fndpnt),y
  4160                          ; sta txtptr
  4161                          ; dey
  4162                          ; lda (fndpnt),y
  4163  3543 204279                              jsr retpat                               ; 01/18/84 patch: correct RETURN to GOSUB from direct mode
  4164                          ; lda (fndpnt),y
  4165                          ; sta curlin ;jump to DATA to waste rest of stmt (in case of ON..GOSUB)
  4166  3546 8000                                bra data
  4167                          
  4168                          ;.end
  4169                          ; .page
  4170                          ; .subttl DATA
  4171                          
  4172                          data
  4173  3548 205b35                              jsr datan                                ; skip to end of statement- offset in .y
  4174  354b 98                 addon            tya
  4175  354c 18                                  clc
  4176  354d 653d                                adc txtptr                               ; add offset to end to txtptr
  4177  354f 853d                                sta txtptr
  4178  3551 9002                                bcc remrts
  4179  3553 e63e                                inc txtptr+1
  4180  3555 60                 remrts           rts                                      ; NEWSTT rts addr is still there
  4181                          
  4182                          
  4183                          
  4184  3556 205e35             rem              jsr remn                                 ; skip rest of statement
  4185  3559 80f0                                bra addon                                ; will always branch
  4186                          
  4187                          
  4188  355b a23a               datan            ldx #':'                                 ; DATA terminates on ":" and null
  4189  355d 2c                                  !text $2c
  4190                          
  4191  355e a200               remn             ldx #0                                   ; REM terminates on null only
  4192  3560 860a                                stx charac                               ; preserve terminator
  4193  3562 a000                                ldy #0                                   ; this makes charac=0 after swap
  4194  3564 840b                                sty endchr
  4195                          
  4196  3566 a50b               l43_1            lda endchr
  4197  3568 a60a                                ldx charac
  4198  356a 850a                                sta charac
  4199  356c 860b                                stx endchr
  4200  356e 20c522             l43_2            jsr indtxt
  4201  3571 f0e2                                beq remrts                               ; null always terminates
  4202  3573 c50b                                cmp endchr                               ; is it some another terminator?
  4203  3575 f0de                                beq remrts                               ; yes, it's finished
  4204  3577 c8                                  iny                                      ; progress to next character
  4205  3578 c922                                cmp #'"'                                 ; is it a quote?
  4206  357a d0f2                                bne l43_2                                ; no, just continue
  4207  357c f0e8                                beq l43_1                                ; yes, time to change
  4208                          
  4209                          ;.end
  4210                          ; .page
  4211                          ; .subttl IF  THEN  ELSE
  4212                          
  4213                          ;****************************************************************
  4214                          ;*
  4215                          ;* IF Statment
  4216                          ;*
  4217                          ;* IF exp {GOTO line#  | THEN {line# | statements | b-block} }
  4218                          ;*  [:ELSE {line# | statements | b-block} ]
  4219                          ;*
  4220                          ;* B-block
  4221                          ;*
  4222                          ;* BEGIN : [statement(s) on one or more lines] : BEND
  4223                          ;*
  4224                          ;****************************************************************
  4225                          
  4226  357e 20ef4c             if               jsr frmevl                               ; evaluate the conditional expression
  4227  3581 208522                              jsr chrgot                               ; re-get current character
  4228  3584 c989                                cmp #goto_token                          ; is terminating character a GOTO?
  4229  3586 f005                                beq l44_1                                ; yes
  4230  3588 a9a7                                lda #then_token                          ; no, it must be THEN
  4231  358a 205d4e                              jsr synchr
  4232                          
  4233  358d a563               l44_1            lda facexp                               ; test truth value of argument
  4234  358f d026                                bne if_true                              ; branch if true
  4235                          
  4236                          if_false
  4237  3591 208522                              jsr chrgot                               ; is there a b-block?
  4238  3594 c9fe                                cmp #esc_command_token
  4239  3596 d00b                                bne l45_1                                ; no, must be an escape command
  4240  3598 c8                                  iny                                      ; might be, look at escape token
  4241  3599 20c522                              jsr indtxt
  4242  359c c918                                cmp #begin_token
  4243  359e d003                                bne l45_1                                ; branch if not
  4244  35a0 20d935                              jsr find_bend                            ; skip to end of b-block
  4245                          
  4246  35a3 204835             l45_1            jsr data                                 ; may be 'else' clause. first skip over 'then' clause..
  4247  35a6 a000                                ldy #0
  4248  35a8 20c522                              jsr indtxt                               ; ..and see if end of stmt or end of line
  4249  35ab f0a9                                beq rem                                  ; end of line, no 'else'. go to next line
  4250  35ad 208322                              jsr chrget                               ; another statement on this line.. is it 'else'?
  4251  35b0 c9d5                                cmp #else_token
  4252  35b2 d0ef                                bne l45_1                                ; no, keep looking on this line
  4253  35b4 208322                              jsr chrget                               ; yes! skip over token and execute clause (below)
  4254                          
  4255  35b7 208522             if_true          jsr chrgot
  4256  35ba f017                                beq l46_2                                ; branch if end of statement
  4257  35bc b003                                bcs l46_1                                ; branch if not a number
  4258  35be 833b07                              +lbra goto                               ; here if of the form 'THEN line#'
  4259                          
  4260  35c1 c9fe               l46_1            cmp #esc_command_token                   ; is this the beginning of a b-block?
  4261  35c3 d00e                                bne l46_2                                ; no, must be an escape command
  4262  35c5 c8                                  iny                                      ; might be, look at escape token
  4263  35c6 20c522                              jsr indtxt
  4264  35c9 c918                                cmp #begin_token
  4265  35cb d006                                bne l46_2
  4266  35cd 208322                              jsr chrget                               ; skip over 'BEGIN' if so...
  4267  35d0 208322                              jsr chrget                               ; ..and the second token, as well.
  4268                          
  4269  35d3 208522             l46_2            jsr chrgot                               ; get back original character, & set up flags
  4270  35d6 837af6                              +lbra xeqcm3                             ; ..and go execute whatever it is
  4271                          
  4272                          ; .page
  4273                          find_bend                                                 ; ... subroutine to find end of current b-block
  4274  35d9 208322                              jsr chrget
  4275  35dc d026                                bne l47_3
  4276                          
  4277                          ; End of statement.. set up next
  4278                          
  4279  35de c93a               l47_1            cmp #':'                                 ; is this EOL?
  4280  35e0 f0f7                                beq find_bend                            ; no, keep looking
  4281                          
  4282  35e2 7f7e48             l47_2            bbr7 runmod,l47_7                        ; EOL: branch if direct mode, 'block terminator not found' error
  4283                          
  4284  35e5 a002                                ldy #2
  4285  35e7 20c522                              jsr indtxt                               ; end of text?
  4286  35ea f041                                beq l47_7                                ; yes, msb of next stmt pointer = 0. error
  4287                          
  4288  35ec c8                                  iny
  4289  35ed 20c522                              jsr indtxt
  4290  35f0 853b                                sta curlin                               ; set up next line of text
  4291  35f2 c8                                  iny
  4292  35f3 20c522                              jsr indtxt
  4293  35f6 853c                                sta curlin+1
  4294  35f8 98                                  tya
  4295  35f9 18                                  clc
  4296  35fa 653d                                adc txtptr
  4297  35fc 853d                                sta txtptr
  4298  35fe 90d9                                bcc find_bend
  4299  3600 e63e                                inc txtptr+1
  4300  3602 80d5                                bra find_bend                            ; always
  4301                          
  4302  3604 c922               l47_3            cmp #'"'
  4303  3606 d007                                bne l47_4
  4304  3608 203236                              jsr un_quote                             ; look for terminating quote, or EOL
  4305  360b f0d1                                beq l47_1                                ; EOL or ':' after closing quote
  4306  360d d0ca                                bne find_bend                            ; ..else normal char, keep looking
  4307                          
  4308  360f c98f               l47_4            cmp #rem_token                           ; REM?
  4309  3611 d005                                bne l47_5                                ; no
  4310  3613 205635                              jsr rem                                  ; yes, trash this line
  4311  3616 80ca                                bra l47_2                                ; and go test for end of text
  4312                          
  4313  3618 c9fe               l47_5            cmp #esc_command_token                   ; is this a BEND?
  4314  361a d0bd                                bne find_bend                            ; can't be, has to be an escape
  4315                          
  4316  361c 208322                              jsr chrget                               ; skip over esc token
  4317  361f c919                                cmp #bend_token
  4318  3621 f009                                beq l47_6                                ; this is what we came for, bye!
  4319                          
  4320  3623 c918                                cmp #begin_token                         ; not a BEND. is it a BEGIN?
  4321  3625 d0b2                                bne find_bend                            ; it's just a normal, stick-in-the-mud char. keep looking.
  4322                          
  4323  3627 20d935                              jsr find_bend                            ; oh-oh, recursion. Dr. Ja-Ja warned me about this.
  4324  362a 80ad                                bra find_bend
  4325                          
  4326  362c 60                 l47_6            rts
  4327                          
  4328  362d a225               l47_7            ldx #err_no_bend
  4329  362f 831ef8                              +lbra error
  4330                          
  4331                          un_quote                                                  ; txtptr points to a '"'. look for closing '"', or EOL
  4332  3632 a000                                ldy #0
  4333  3634 e33d               l48_1            inw txtptr
  4334  3636 20c522                              jsr indtxt
  4335  3639 f007                                beq l48_2                                ; EOL, get out here with .z set and a '00' in .a
  4336  363b c922                                cmp #'"'
  4337  363d d0f5                                bne l48_1                                ; keep looking until quote
  4338  363f 4c8322                              jmp chrget                               ; got closing quote, get byte after quote, set flags
  4339                          
  4340  3642 60                 l48_2            rts
  4341                          
  4342                          ; .page
  4343                          
  4344  3643 c9fe               else             cmp #esc_command_token                   ; is this of the form "ELSE b-block"?
  4345  3645 d00b                                bne l49_1                                ; no, must be an escape command
  4346  3647 c8                                  iny                                      ; might be, look at escape token
  4347  3648 20c522                              jsr indtxt
  4348  364b c918                                cmp #begin_token
  4349  364d d003                                bne l49_1                                ; no, justa plain-old "ELSE statement"
  4350  364f 20d935                              jsr find_bend                            ; yes, it is a b-block. skip over the b-block.
  4351  3652 8302ff             l49_1            +lbra rem
  4352                          
  4353                          
  4354                          ;.end
  4355                          ; .page
  4356                          ; .subttl ON...GOTO  ON...GOSUB
  4357                          
  4358                          ;*********************************************************
  4359                          ;* ON expression {GOTO | GOSUB} line_number
  4360                          ;*********************************************************
  4361                          ongoto
  4362  3655 206c5d                              jsr getbyt                               ; get & save GOTO/GOSUB
  4363  3658 48                                  pha
  4364  3659 c989                                cmp #goto_token                          ; GOTO?
  4365  365b f005                                beq l50_1                                ; yes
  4366  365d c98d                                cmp #gosub_token                         ; GOSUB?
  4367  365f d3e9f7                              +lbne snerr                              ; no, syntax error
  4368                          
  4369  3662 c667               l50_1            dec faclo
  4370  3664 d004                                bne l50_2                                ; skip another line number
  4371  3666 68                                  pla                                      ; get dispatch character
  4372  3667 8300f6                              +lbra xeqcm2
  4373                          
  4374  366a 208322             l50_2            jsr chrget                               ; advance and set codes
  4375  366d 202e32                              jsr linget                               ; read next line
  4376  3670 c92c                                cmp #','                                 ; is it a "comma"?
  4377  3672 f0ee                                beq l50_1
  4378  3674 68                                  pla                                      ; remove stack entry (token)
  4379  3675 60                                  rts                                      ; either end of line or syntax error
  4380                          
  4381                          ;.end
  4382                          ; .page
  4383                          ; .subttl LET
  4384                          
  4385                          ;****************************************************************
  4386                          ;*
  4387                          ;*  [LET] variable = expression
  4388                          ;*
  4389                          ;****************************************************************
  4390                          
  4391  3676 207c4f             let              jsr ptrget                               ; get pntr to variable into "varpnt"
  4392  3679 854b                                sta forpnt                               ; preserve pointer
  4393  367b 844c                                sty forpnt+1
  4394  367d a9b2                                lda #equal_token
  4395  367f 205d4e                              jsr synchr                               ; "=" is necessary
  4396                          
  4397  3682 a510                                lda intflg                               ; save type for later
  4398  3684 48                                  pha
  4399  3685 a50f                                lda valtyp                               ; retain the variable's value type too
  4400  3687 48                                  pha
  4401                          
  4402  3688 20ef4c                              jsr frmevl                               ; get value of formula into FAC
  4403  368b 68                                  pla
  4404  368c 2a                                  rol                                      ; carry set for string, off for numeric
  4405  368d 20de4c                              jsr chkval                               ; make sure VALTYP matches carry
  4406                          ;and set zero flag for numeric
  4407  3690 d022                                bne copstr                               ; if numeric, copy it
  4408  3692 68                                  pla                                      ; get number type
  4409                          
  4410  3693 1018               qintgr           bpl copflt                               ; store a floating point number
  4411  3695 20b262                              jsr round                                ; round integer
  4412  3698 20b458                              jsr ayint                                ; make two-byte number
  4413  369b a000                                ldy #0
  4414  369d a566                                lda facmo                                ; get high
  4415  369f da                                  phx
  4416  36a0 a24b                                ldx #forpnt
  4417  36a2 20f022                              jsr sta_far_ram1 ;sta (forpnt),y         ; store it
  4418  36a5 c8                                  iny
  4419  36a6 a567                                lda faclo                                ; get low
  4420  36a8 20f022                              jsr sta_far_ram1                         ; sta (forpnt),y
  4421  36ab fa                                  plx
  4422  36ac 60                                  rts
  4423                          
  4424                          
  4425                          
  4426  36ad a64b               copflt           ldx forpnt
  4427  36af a44c                                ldy forpnt+1
  4428  36b1 83af2b                              +lbra movmf_ram1                         ; put number @forpnt in var bank
  4429                          
  4430                          
  4431                          
  4432  36b4 68                 copstr           pla                                      ; if string, no INTFLG
  4433                          
  4434  36b5 a44c               inpcom           ldy forpnt+1                             ; TI$?
  4435  36b7 c002                                cpy #>zero                               ; (only TI$ can be this on assign)
  4436  36b9 f3c21c                              +lbeq Set_TI_String                      ; yes
  4437  36bc 8024                                bra getspt                               ; no
  4438                          
  4439                          ; .page
  4440  36be 68                 dskx1            pla
  4441  36bf c8                                  iny
  4442                          
  4443  36c0 c536               dskx2            cmp fretop+1
  4444  36c2 9018                                bcc l51_2
  4445  36c4 d008                                bne l51_1
  4446  36c6 88                                  dey
  4447  36c7 20a922                              jsr indfmo
  4448  36ca c535                                cmp fretop
  4449  36cc 900e                                bcc l51_2
  4450                          
  4451  36ce a467               l51_1            ldy faclo                                ; qvaria
  4452  36d0 c430                                cpy vartab+1                             ; if (vartab) > (facmo), don't copy
  4453  36d2 9008                                bcc l51_2
  4454  36d4 d023                                bne copy                                 ; it is less
  4455  36d6 a566                                lda facmo
  4456  36d8 c52f                                cmp vartab                               ; compare low orders
  4457  36da b01d                                bcs copy
  4458                          
  4459  36dc a566               l51_2            lda facmo                                ; dntcpy
  4460  36de a467                                ldy facmo+1
  4461  36e0 8035                                bra copyc
  4462                          
  4463                          ; .page
  4464  36e2 a002               getspt           ldy #2                                   ; get pntr to descriptor
  4465  36e4 20a922                              jsr indfmo
  4466  36e7 c57b                                cmp dsdesc+2                             ; check for DS$ hi
  4467  36e9 d0d5                                bne dskx2                                ; nope
  4468  36eb 48                                  pha
  4469  36ec 88                                  dey
  4470  36ed 20a922                              jsr indfmo
  4471  36f0 c57a                                cmp dsdesc+1                             ; check for DS$ lo
  4472  36f2 d0ca                                bne dskx1                                ; nope
  4473  36f4 a579                                lda dsdesc                               ; check if len=0
  4474  36f6 f0c6                                beq dskx1                                ; yup
  4475  36f8 68                                  pla                                      ; fall through to copy
  4476                          
  4477                          
  4478  36f9 a000               copy             ldy #0
  4479  36fb 20a922                              jsr indfmo
  4480  36fe 20735a                              jsr strini                               ; get room to copy string into
  4481  3701 a552                                lda dscpnt                               ; get pointer to old descriptor, so
  4482  3703 a453                                ldy dscpnt+1
  4483  3705 8570                                sta strng1                               ; movins can find string
  4484  3707 8471                                sty strng1+1
  4485  3709 20355b                              jsr movins                               ; copy it
  4486                          
  4487  370c a570                                lda strng1                               ; fix to free get strings
  4488  370e a471                                ldy strng1+1
  4489  3710 20cc5b                              jsr fretms                               ; free the string, if it is a temp
  4490                          
  4491  3713 a963                                lda #<dsctmp
  4492  3715 a000                                ldy #>dsctmp
  4493                          
  4494  3717 8552               copyc            sta dscpnt
  4495  3719 8453                                sty dscpnt+1
  4496  371b 8524                                sta index                                ; index points to new descriptor
  4497  371d 8425                                sty index+1
  4498  371f 20cc5b                              jsr fretms
  4499                          
  4500                          ; .page
  4501                          ;   Fix the strings by flagging the old string as garbage and the new
  4502                          ;   string by pointing it to its new descriptor.
  4503                          
  4504  3722 206737                              jsr stradj                               ; set up new string
  4505  3725 9011                                bcc l52_1                                ; leave it alone
  4506  3727 a000                                ldy #0
  4507  3729 a54b                                lda forpnt                               ; put in backwards link
  4508  372b da                                  phx
  4509  372c a224                                ldx #index
  4510  372e 20f022                              jsr sta_far_ram1
  4511  3731 c8                                  iny
  4512  3732 a54c                                lda forpnt+1
  4513  3734 20f022                              jsr sta_far_ram1
  4514  3737 fa                                  plx
  4515                          
  4516  3738 a54b               l52_1            lda forpnt                               ; fix old string
  4517  373a 8524                                sta index
  4518  373c a54c                                lda forpnt+1
  4519  373e 8525                                sta index+1
  4520  3740 206737                              jsr stradj                               ; point to old string
  4521  3743 9010                                bcc l52_2                                ; in text do not fix
  4522  3745 88                                  dey                                      ; restore y
  4523  3746 da                                  phx
  4524  3747 a224                                ldx #index
  4525  3749 a9ff                                lda #$ff                                 ; garbage flag
  4526  374b 20f022                              jsr sta_far_ram1
  4527  374e 88                                  dey
  4528  374f 68                                  pla                                      ; (was txa)
  4529  3750 48                                  pha
  4530  3751 20f022                              jsr sta_far_ram1                         ; store length
  4531  3754 fa                                  plx
  4532                          
  4533  3755 a002               l52_2            ldy #2                                   ; set the descriptor
  4534  3757 da                                  phx
  4535  3758 a24b                                ldx #forpnt
  4536  375a a952               l52_3            lda #dscpnt
  4537  375c 20d722                              jsr lda_far_ram1                         ; lda (dscpnt),y from RAM1
  4538  375f 20f022                              jsr sta_far_ram1                         ; sta (forpnt),y to   RAM1
  4539  3762 88                                  dey
  4540  3763 10f5                                bpl l52_3
  4541  3765 fa                                  plx
  4542  3766 60                                  rts
  4543                          
  4544                          ; .page
  4545                          ;   STRADJ takes the pointer index which points to a descriptor and
  4546                          ;   indexes to the desciptor's string data.  If the string is not in
  4547                          ;   string space (no action to take) we return with carry clear, else
  4548                          ;   we return with the pointer set to the link bytes in the string, the
  4549                          ;   length in .a and the carry set.
  4550                          
  4551  3767 a000               stradj           ldy #0
  4552  3769 20d522                              jsr indin1_ram1                          ; push length on stack
  4553  376c 48                                  pha
  4554  376d f036                                beq l53_5                                ; if length=0 do nothing
  4555  376f c8                                  iny
  4556  3770 20d522                              jsr indin1_ram1                          ; get low byte (into .x)
  4557  3773 aa                                  tax
  4558  3774 c8                                  iny
  4559  3775 20d522                              jsr indin1_ram1                          ; get high byte
  4560  3778 c53a                                cmp max_mem_1+1
  4561  377a 9006                                bcc l53_1                                ; ok
  4562  377c d027                                bne l53_5                                ; if above top of memory
  4563  377e e439                                cpx max_mem_1                            ; msb the same, test lsb
  4564  3780 b023                                bcs l53_5                                ; if above top of memory
  4565                          
  4566  3782 c536               l53_1            cmp fretop+1
  4567  3784 901f                                bcc l53_5                                ; if below fretop
  4568  3786 d004                                bne l53_2
  4569  3788 e435                                cpx fretop
  4570  378a 9019                                bcc l53_5                                ; if below fretop
  4571                          
  4572  378c c57b               l53_2            cmp dsdesc+2
  4573  378e d004                                bne l53_3                                ; fix
  4574  3790 e47a                                cpx dsdesc+1
  4575  3792 f011                                beq l53_5
  4576                          
  4577  3794 8624               l53_3            stx index                                ; ok set pointer
  4578  3796 8525                                sta index+1
  4579  3798 68                                  pla                                      ; get back length
  4580  3799 aa                                  tax                                      ; into x also
  4581  379a 18                                  clc
  4582  379b 6524                                adc index
  4583  379d 8524                                sta index
  4584  379f 9002                                bcc l53_4
  4585  37a1 e625                                inc index+1
  4586  37a3 38                 l53_4            sec                                      ; carry set
  4587  37a4 60                                  rts
  4588                          
  4589  37a5 68                 l53_5            pla                                      ; clean up stack
  4590  37a6 18                                  clc
  4591  37a7 60                                  rts
  4592                          
  4593                          ;.end
  4594                          ; .page
  4595                          ; .subttl PRINT  PRINT#  CMD
  4596                          
  4597                          ;***********************************************************
  4598                          ;*
  4599                          ;* PRINT   PRINT#   CMD
  4600                          ;*
  4601                          ;**********************************************************
  4602                          
  4603  37a8 20ae37             printn           jsr cmd                                  ; docmd
  4604  37ab 830701                              +lbra release_channels                   ; restore terminal
  4605                          
  4606                          
  4607  37ae 206c5d             cmd              jsr getbyt
  4608  37b1 f005                                beq l54_1
  4609  37b3 a92c                                lda #','                                 ; comma?
  4610  37b5 205d4e                              jsr synchr
  4611                          
  4612  37b8 08                 l54_1            php                                      ; save stat (beq=eof)
  4613  37b9 48                                  pha                                      ; save char
  4614  37ba 8615                                stx channl                               ; channel to output on
  4615  37bc 204968                              jsr coout
  4616  37bf 68                                  pla                                      ; get char back
  4617  37c0 28                                  plp                                      ; get stat back
  4618  37c1 8006                                bra print
  4619                          
  4620                          
  4621  37c3 203e38             strdon           jsr strprt
  4622                          
  4623  37c6 208522             newchr           jsr chrgot                               ; reget last character
  4624                          
  4625  37c9 f02c               print            beq crdo                                 ; terminator only, so print crlf
  4626  37cb c9fb                                cmp #using_token
  4627  37cd f31032                              +lbeq using
  4628                          
  4629                          
  4630                          
  4631  37d0 f032               printc           beq prtrts  ;here after seeing TAB(x) or "," or " ; " in which case
  4632                          ;a terminator does not mean a crlf but just RTS
  4633  37d2 c9a3                                cmp #tab_token                           ; TAB function?
  4634  37d4 f03f                                beq taber                                ; yes (c=1)
  4635  37d6 c9a6                                cmp #spc_token                           ; space function?
  4636  37d8 18                                  clc                                      ; clear carry
  4637  37d9 f03a                                beq taber                                ; yes (c=0)
  4638  37db c92c                                cmp #','                                 ; comma?
  4639  37dd f026                                beq comprt                               ; yes
  4640  37df c93b                                cmp #';'                                 ; a semicolon?
  4641  37e1 f04e                                beq notabr                               ; yes
  4642                          
  4643  37e3 20ef4c                              jsr frmevl                               ; evaluate the formula
  4644  37e6 ff0fda                              bbs7 valtyp,strdon                       ; branch if a string
  4645  37e9 208f64                              jsr fout
  4646  37ec 20855a                              jsr strlit                               ; build descriptor
  4647  37ef 203e38                              jsr strprt                               ; print the number
  4648  37f2 205838                              jsr outspc                               ; print a space
  4649  37f5 80cf                                bra newchr                               ; always goes
  4650                          
  4651                          
  4652                          
  4653  37f7 a90d               crdo             lda #cr
  4654  37f9 203d68                              jsr outch                                ; outdo
  4655                          
  4656  37fc 7f1505             crfin            bbr7 channl,prtrts
  4657  37ff a90a                                lda #lf
  4658  3801 203d68                              jsr outch                                ; outdo
  4659                          ; eor #$ff  ;????
  4660                          
  4661  3804 60                 prtrts           rts
  4662                          
  4663                          
  4664                          
  4665  3805 38                 comprt           sec
  4666  3806 20f0ff                              jsr _plot                                ; get tab position in x
  4667  3809 98                                  tya
  4668  380a 38                                  sec
  4669  380b e90a               morco1           sbc #column_width
  4670  380d b0fc                                bcs morco1
  4671  380f 49ff                                eor #$ff
  4672  3811 6901                                adc #1
  4673  3813 d017                                bne aspac
  4674                          
  4675  3815 08                 taber            php                                      ; remember if SPC(c=0) or TAB(c=1) function
  4676  3816 38                                  sec
  4677  3817 20f0ff                              jsr _plot                                ; read tab position
  4678  381a 8454                                sty trmpos
  4679  381c 20695d                              jsr gtbytc                               ; get value into accx
  4680  381f c929                                cmp #')'
  4681  3821 d327f6                              +lbne snerr
  4682  3824 28                                  plp
  4683  3825 9006                                bcc xspac
  4684  3827 8a                                  txa
  4685  3828 e554                                sbc trmpos
  4686  382a 9005                                bcc notabr                               ; negative, don't print any
  4687  382c aa                 aspac            tax
  4688  382d e8                 xspac            inx
  4689  382e ca                 xspac2           dex
  4690  382f d005                                bne xspac1
  4691                          
  4692                          
  4693  3831 208322             notabr           jsr chrget                               ; reget last character
  4694  3834 809a                                bra printc                               ; don't call crdo
  4695                          
  4696                          
  4697  3836 205838             xspac1           jsr outspc
  4698  3839 d0f3                                bne xspac2
  4699                          
  4700                          ; .page
  4701                          ; STROUT Routine
  4702                          ;
  4703                          ; Print the string pointed to by .x.  It must end with a null byte.
  4704                          
  4705  383b 20855a             strout           jsr strlit                               ; get a string literal
  4706                          
  4707  383e 206d5b             strprt           jsr frefac                               ; return temp pointer
  4708  3841 aa                                  tax                                      ; put count into counter
  4709  3842 a000                                ldy #0
  4710  3844 e8                                  inx                                      ; move one ahead
  4711  3845 ca                 strpr2           dex
  4712  3846 f0bc                                beq prtrts                               ; all done
  4713  3848 20d522                              jsr indin1_ram1                          ; lda (index),y
  4714  384b 203d68                              jsr outch                                ; outdo
  4715  384e c8                                  iny
  4716  384f c90d                                cmp #cr
  4717  3851 d0f2                                bne strpr2
  4718  3853 20fc37                              jsr crfin                                ; type rest of carriage return
  4719  3856 80ed                                bra strpr2                               ; and on and on
  4720                          
  4721  3858 a515               outspc           lda channl                               ; if terminal print skip chr., else print space
  4722  385a d003                                bne realsp
  4723  385c a91d                                lda #29                                  ; CBM cursor right (non-destructive skip char)
  4724  385e 2c                                  !text $2c
  4725                          
  4726  385f a920               realsp           lda #' '                                 ; space
  4727  3861 2c                                  !text $2c
  4728                          
  4729  3862 a93f               outqst           lda #'?'
  4730                          
  4731                          ;outdo
  4732  3864 4c3d68                              jmp outch                                ; output char in .a
  4733                          ; and #$ff ;????
  4734                          ; rts
  4735                          
  4736                          ;.end
  4737                          ; .page
  4738                          ; .subttl INPUT  GET  READ  LINPUT
  4739                          
  4740  3867 20e258             get              jsr errdir                               ; direct mode illegal
  4741  386a 8576                                sta z_p_temp_1                           ; flag to distinguish between GET and GETKEY
  4742                          
  4743  386c c923                                cmp #'#'                                 ; is it GET# ?
  4744  386e f009                                beq getn                                 ; yes
  4745  3870 c9f9                                cmp #key_token                           ; is it GETKEY ?
  4746  3872 d015                                bne gettty                               ; no, must be plain GET
  4747  3874 208322                              jsr chrget                               ; yes, skip over KEY token
  4748  3877 8010                                bra gettty
  4749                          
  4750                          
  4751  3879 208322             getn             jsr chrget                               ; GET# move up to next byte
  4752  387c 206c5d                              jsr getbyt                               ; get channel into x
  4753  387f a92c                                lda #','                                 ; comma?
  4754  3881 205d4e                              jsr synchr
  4755  3884 8615                                stx channl
  4756  3886 205268                              jsr coin                                 ; chkin
  4757                          
  4758                          
  4759                          gettty                                                    ; GET
  4760  3889 a201                                ldx #<buf+1                              ; point to 0
  4761  388b a002                                ldy #>buf
  4762  388d a900                                lda #0                                   ; to stuff and to point
  4763  388f 8d0102                              sta buf+1                                ; zero it
  4764  3892 a940                                lda #$40                                 ; turn on v-bit
  4765  3894 201b39                              jsr inpco1                               ; do the get
  4766  3897 a615                                ldx channl
  4767  3899 d019                                bne release_channels                     ; restore terminal channels
  4768  389b 60                                  rts
  4769                          
  4770                          ; .page
  4771                          linputn                                                   ; input line from channel into a string var
  4772  389c 208322                              jsr chrget                               ; (eat input# token)
  4773  389f f787                                smb7 op
  4774  38a1 2c                                  !text $2c
  4775                          
  4776  38a2 7787               inputn           rmb7 op                                  ; flag INPUT# vs. LINPUT#
  4777  38a4 206c5d                              jsr getbyt                               ; get channel number
  4778  38a7 a92c                                lda #','                                 ; a comma?
  4779  38a9 205d4e                              jsr synchr
  4780  38ac 8615                                stx channl
  4781  38ae 205268                              jsr coin                                 ; chkin
  4782  38b1 20e938                              jsr notqti                               ; do input to variables
  4783                          
  4784                          
  4785                          release_channels                                          ; iodone, iorele.
  4786  38b4 20ccff                              jsr _clrch                               ; clear I/O channels
  4787                          ; ldx #0   ;restore normal terminal channels
  4788  38b7 8515                                sta channl                               ; (was stx)     [910909]
  4789  38b9 60                                  rts
  4790                          
  4791                          
  4792                          linput                                                    ; input line from console into a string var
  4793  38ba 208322                              jsr chrget                               ; (eat input token)
  4794  38bd f787                                smb7 op
  4795  38bf 2c                                  !text $2c
  4796                          
  4797  38c0 7787               input            rmb7 op                                  ; flag INPUT vs. LINPUT
  4798  38c2 c922                                cmp #'"'                                 ; a quote?
  4799  38c4 d023                                bne notqti                               ; no message
  4800  38c6 20164e                              jsr strtxt                               ; literalize the string in text
  4801                          
  4802  38c9 208522                              jsr chrgot                               ; looking for prompt string terminator  [910219]
  4803  38cc c92c                                cmp #','
  4804  38ce d011                                bne l55_1
  4805  38d0 8dff01                              sta buf_txtptr                           ; is comma- supress '?' after prompt  [910219]
  4806  38d3 208322                              jsr chrget                               ; eat comma
  4807  38d6 203e38                              jsr strprt                               ; print prompt
  4808  38d9 20e258                              jsr errdir                               ; error if direct mode
  4809  38dc 201c31                              jsr InputLine                            ; get first item
  4810  38df 8013                                bra getagn1                              ; see if there's more to do
  4811                          
  4812  38e1 a93b               l55_1            lda #';'                                 ; must end in semicolon
  4813  38e3 205d4e                              jsr synchr
  4814  38e6 203e38                              jsr strprt                               ; print prompt
  4815                          
  4816  38e9 20e258             notqti           jsr errdir                               ; use common routine since def direct
  4817  38ec a92c                                lda #','                                 ; get comma
  4818  38ee 8dff01                              sta buf_txtptr                           ; (data reader expects buffer to start with terminator)
  4819                          
  4820  38f1 201231             getagn           jsr PromptedInput                        ; type "?" and input a line of text
  4821  38f4 a515               getagn1          lda channl
  4822  38f6 f00d                                beq l56_1
  4823  38f8 20b7ff                              jsr _readst                              ; get status byte
  4824                          ; and #2   ; (assumes serial bus????)  [910618] eoi ok
  4825  38fb 2987                                and #%10000111                           ; serial: err if dnp, r/w timeout errors
  4826  38fd f006                                beq l56_1                                ; a-ok rs232: err if brk, ovr, frm, par errors
  4827  38ff 20b438                              jsr release_channels                     ; bad, close channel
  4828  3902 8344fc                              +lbra data                               ; skip rest of input
  4829                          
  4830  3905 ad0002             l56_1            lda buf                                  ; bufful. get anything?
  4831  3908 d00f                                bne inpcon                               ; yes- process input
  4832                          ; lda channl  ;didn't get anything.  is this keyboard? [901212]
  4833                          ; bne getagn  ; no- keep looking for data ????
  4834  390a 205b35                              jsr datan                                ; skip to end of statement
  4835  390d 833cfc                              +lbra addon
  4836                          
  4837                          ; .page
  4838  3910 7787               read             rmb7 op                                  ; flag READ vs. LREAD    [910102]
  4839  3912 a643                                ldx datptr                               ; get last data location
  4840  3914 a444                                ldy datptr+1
  4841  3916 a998                                lda #$98                                 ; initiator= read
  4842  3918 2c                                  !text $2c
  4843                          
  4844  3919 a900               inpcon           lda #0                                   ; initiator= input
  4845  391b 8513               inpco1           sta input_flag                           ; $98=read, $40=get, $00=input
  4846                          
  4847                          ; In the processing of DATA and READ statements, one pointer points to the data
  4848                          ; (i.e., the numbers being fetched) and another points to the list of variables.
  4849                          ;
  4850                          ; The pointer into the data always starts pointing to a terminator- a ",", ":", or EOL.
  4851                          ; At this point TXTPTR points to list of variables and (x,y) points to data or input line.
  4852                          
  4853  391d 8645                                stx inpptr                               ; pointer to data
  4854  391f 8446                                sty inpptr+1
  4855                          
  4856  3921 207c4f             inloop           jsr ptrget                               ; get a pointer to the variable
  4857  3924 854b                                sta forpnt                               ; store its address
  4858  3926 844c                                sty forpnt+1
  4859                          
  4860  3928 a201                                ldx #1
  4861  392a b53d               l57_1            lda txtptr,x                             ; move variable list pointer to 'vartxt'
  4862  392c 954d                                sta vartxt,x
  4863  392e b545                                lda inpptr,x                             ; move data line pointer to 'txtptr'
  4864  3930 953d                                sta txtptr,x
  4865  3932 ca                                  dex
  4866  3933 10f5                                bpl l57_1
  4867                          
  4868  3935 208522                              jsr chrgot                               ; get first data byte
  4869  3938 d02f                                bne datbk1                               ; not null, so we got something
  4870  393a 2413                                bit input_flag                           ; READ($98), GET($40), or INPUT($00)?
  4871  393c 501a                                bvc qdata                                ; branch if READ or INPUT
  4872  393e a576                                lda z_p_temp_1                           ; GET or GETKEY?
  4873  3940 c9f9                                cmp #key_token
  4874  3942 d008                                bne l57_3                                ; branch if GET
  4875                          
  4876  3944 205b68             l57_2            jsr cgetl                                ; GETKEY
  4877  3947 aa                                  tax                                      ; test if null
  4878  3948 f0fa                                beq l57_2                                ; it is null, keep scanning
  4879  394a d003                                bne l57_4                                ; got a key, go put it in var
  4880                          
  4881  394c 205b68             l57_3            jsr cgetl                                ; get a key if pressed, otherwise gets a zero
  4882  394f 8d0002             l57_4            sta buf
  4883  3952 a2ff                                ldx #<buf_txtptr
  4884  3954 a001                                ldy #>buf_txtptr
  4885  3956 800d                                bra datbk
  4886                          
  4887                          ; .page
  4888  3958 33f000             qdata            +lbmi datlop                             ; branch if READ
  4889  395b a515                                lda channl                               ; else it's INPUT
  4890  395d d003                                bne l58_1
  4891  395f 206238                              jsr outqst                               ; console input, so display '? ' prompt
  4892                          
  4893  3962 201231             l58_1            jsr PromptedInput                        ; get another line
  4894                          
  4895  3965 863d               datbk            stx txtptr                               ; set for CHRGET
  4896  3967 843e                                sty txtptr+1
  4897                          
  4898  3969 7f8708             datbk1           bbr7 op,l59_1                            ; no chrgot if LINPUT (want leading spaces) [910513]
  4899  396c 20a540                              jsr chargt
  4900  396f 208e22                              jsr chrtst
  4901  3972 8003                                bra l59_2
  4902                          
  4903  3974 208322             l59_1            jsr chrget                               ; get next data byte
  4904  3977 7f0f32             l59_2            bbr7 valtyp,l59_8                        ; get value type, input a number if numeric
  4905  397a 6f1309                              bbr6 input_flag,l59_4                    ; branch if not get, set quote
  4906  397d e8                                  inx
  4907  397e 863d                                stx txtptr
  4908  3980 a900               l59_3            lda #0                                   ; [901212]
  4909  3982 850a                                sta charac
  4910  3984 800f                                bra l59_5
  4911                          
  4912  3986 ff87f7             l59_4            bbs7 op,l59_3                            ; no terminators if LINPUT or LREAD  [901212]
  4913  3989 850a                                sta charac                               ; setqut.  assume quoted string
  4914  398b c922                                cmp #'"'                                 ; terminators ok?
  4915  398d f007                                beq l59_6                                ; yes (sets .c)
  4916  398f a93a                                lda #':'                                 ; set terminators to ":" and...
  4917  3991 850a                                sta charac
  4918  3993 a92c                                lda #','                                 ; ...comma
  4919                          
  4920  3995 18                 l59_5            clc                                      ; resetc
  4921  3996 850b               l59_6            sta endchr                               ; nowget
  4922  3998 a53d                                lda txtptr
  4923  399a a43e                                ldy txtptr+1
  4924  399c 6900                                adc #0                                   ; .c is set properly above
  4925  399e 9001                                bcc l59_7
  4926  39a0 c8                                  iny
  4927  39a1 208b5a             l59_7            jsr strlt2                               ; make a string descriptor for the value & copy if needed
  4928  39a4 20224e                              jsr st2txt                               ; copy strng2 to txtptr (st-2-txt... get it?)
  4929  39a7 20b536                              jsr inpcom                               ; do assignment
  4930  39aa 800d                                bra l59_9
  4931                          
  4932  39ac ff871d             l59_8            bbs7 op,l59_10                           ; error if LINPUT (string input only)  [901212]
  4933  39af a200                                ldx #0                                   ; numins. flag 'text bank' (0)
  4934  39b1 208d63                              jsr fin
  4935  39b4 a510                                lda intflg                               ; set codes on flags
  4936  39b6 209336                              jsr qintgr                               ; go decide on float
  4937                          
  4938  39b9 208522             l59_9            jsr chrgot                               ; strdn2. read last character
  4939  39bc f041                                beq trmok                                ; ":" or EOL is ok
  4940  39be c92c                                cmp #','                                 ; a comma?
  4941  39c0 f03d                                beq trmok
  4942                          
  4943  39c2 a513                                lda input_flag                           ; is this get, read, or input?
  4944  39c4 f00a                                beq l59_11                               ; input
  4945  39c6 3004                                bmi l59_10                               ; read
  4946  39c8 a615                                ldx channl                               ; get. if not kbd, go use 'bad file data error'
  4947  39ca d008                                bne l59_12
  4948                          
  4949  39cc a216               l59_10           ldx #errtm                               ; tmerr. 'get from kbd' or 'read' saw a bad type
  4950  39ce 8006                                bra l59_13                               ; always
  4951                          
  4952  39d0 a515               l59_11           lda channl
  4953  39d2 f005                                beq l59_14                               ; do again if keybd input
  4954  39d4 a218               l59_12           ldx #errbd                               ; input saw bad file data
  4955  39d6 8377f4             l59_13           +lbra error
  4956                          
  4957                          
  4958  39d9 20dc3c             l59_14           jsr highlight_text                       ; [911119]
  4959  39dc 207dff                              jsr _primm
  4960  39df 3f5245444f204652...                 !text "?REDO FROM START",cr,0
  4961  39f1 20cb3c                              jsr highlight_done                       ; [911119]
  4962                          
  4963  39f4 ad7211             ott              lda oldtxt
  4964  39f7 ac7311                              ldy oldtxt+1
  4965  39fa 853d                                sta txtptr                               ; put user back to beginning of input
  4966  39fc 843e                                sty txtptr+1
  4967  39fe 60                                  rts
  4968                          
  4969                          
  4970                          
  4971  39ff a201               trmok            ldx #1
  4972  3a01 b53d               l60_1            lda txtptr,x
  4973  3a03 9545                                sta inpptr,x                             ; save for more reads
  4974  3a05 b54d                                lda vartxt,x
  4975  3a07 953d                                sta txtptr,x                             ; point to variable list
  4976  3a09 ca                                  dex
  4977  3a0a 10f5                                bpl l60_1
  4978                          
  4979  3a0c 208522                              jsr chrgot                               ; look at last vartab character
  4980  3a0f f006                                beq l60_2                                ; that's the end of the list
  4981  3a11 205b4e                              jsr chkcom                               ; not end. check for comma
  4982  3a14 830bff                              +lbra inloop
  4983                          
  4984  3a17 a545               l60_2            lda inpptr                               ; put away a new data pntr name
  4985  3a19 a446                                ldy inpptr+1
  4986  3a1b 7f1305                              bbr7 input_flag,l60_3
  4987  3a1e 8543                                sta datptr
  4988  3a20 8444                                sty datptr+1
  4989  3a22 60                                  rts
  4990                          
  4991  3a23 a000               l60_3            ldy #0                                   ; last data chr could have been ',' or ':' but should be null
  4992  3a25 a945                                lda #inpptr
  4993  3a27 20c722                              jsr lda_far_ram0
  4994  3a2a f01d                                beq l60_4                                ; it is null
  4995  3a2c a515                                lda channl                               ; if not terminal, no type
  4996  3a2e d019                                bne l60_4
  4997                          
  4998  3a30 20dc3c                              jsr highlight_text                       ; [911119]
  4999  3a33 207dff                              jsr _primm
  5000  3a36 3f45585452412049...                 !text "?EXTRA IGNORED", cr,0
  5001  3a46 20cb3c                              jsr highlight_done                       ; [911119]
  5002                          
  5003  3a49 60                 l60_4            rts                                      ; do next statement
  5004                          
  5005                          ; .page
  5006                          ; DATLOP Routine Subroutine to find data.
  5007                          ;
  5008                          ; The search is made by using the execution code for data to skip over
  5009                          ; statements, the start word of each statement is compared with "data_token".
  5010                          ; Each new line number is stored in "datlin" so that if any error occurs while
  5011                          ; reading data the error message can give the line number of the bad data.
  5012                          
  5013  3a4a 205b35             datlop           jsr datan                                ; skip some text
  5014  3a4d c8                                  iny
  5015  3a4e aa                                  tax                                      ; end of line?
  5016  3a4f d016                                bne l61_1                                ; no
  5017  3a51 a20d                                ldx #errod                               ; yes, "no data" error
  5018  3a53 c8                                  iny
  5019  3a54 20c522                              jsr indtxt
  5020  3a57 f3f6f3                              +lbeq error
  5021                          
  5022  3a5a c8                                  iny
  5023  3a5b 20c522                              jsr indtxt                               ; get high byte of line number
  5024  3a5e 8541                                sta datlin
  5025  3a60 c8                                  iny
  5026  3a61 20c522                              jsr indtxt                               ; get low byte
  5027  3a64 c8                                  iny
  5028  3a65 8542                                sta datlin+1
  5029                          
  5030  3a67 204b35             l61_1            jsr addon                                ; nowlin.  txtptr+.y
  5031  3a6a 208522                              jsr chrgot                               ; span blanks
  5032  3a6d aa                                  tax                                      ; used later
  5033  3a6e e083                                cpx #data_token                          ; is it a DATA statement?
  5034  3a70 d0d8                                bne datlop                               ; not quite right, keep looking
  5035  3a72 83f5fe                              +lbra datbk1                             ; this is the one
  5036                          
  5037                          
  5038                          ;.end
  5039                          ; .page
  5040                          ; .subttl NEXT
  5041                          
  5042                          ; Next routine
  5043                          ;
  5044                          ; 'FOR' entry on the stack has the following format:
  5045                          ;
  5046                          ; Low address
  5047                          ;  token (for_token) 1 byte
  5048                          ;  a pointer to the loop variable 2 bytes
  5049                          ;  the step 5 bytes
  5050                          ;  a byte reflecting the sign of the incr. 2 bytes
  5051                          ;  the upper value (packed) 5 bytes
  5052                          ;  the line number of the FOR statement 2 bytes
  5053                          ;  a text pointer into the FOR statement 2 bytes
  5054                          ; High address
  5055                          ;
  5056                          ; (total 16 bytes)
  5057                          
  5058  3a75 d013               next             bne l62_2                                ; hop if 'next' variable given
  5059  3a77 a0ff                                ldy #$ff                                 ; flag no specific 'for' variable
  5060  3a79 8014                                bra l62_3                                ; always
  5061                          
  5062  3a7b a012               l62_1            ldy #lenfor                              ; done, clean up stack
  5063  3a7d 20ef31                              jsr rlsstk                               ; release (y) items from stack
  5064  3a80 208522                              jsr chrgot
  5065  3a83 c92c                                cmp #','                                 ; ie., NEXT j,k
  5066  3a85 d069                                bne l62_7
  5067  3a87 208322                              jsr chrget
  5068                          
  5069  3a8a 207c4f             l62_2            jsr ptrget                               ; get pointer to variable in (a,y)
  5070  3a8d 854b                                sta forpnt
  5071                          
  5072  3a8f 844c               l62_3            sty forpnt+1
  5073  3a91 a981                                lda #for_token
  5074  3a93 204331                              jsr search                               ; look for FOR entry in run-time stack
  5075  3a96 f005                                beq l62_4                                ; branch if found
  5076  3a98 a20a                                ldx #errnf                               ; otherwise 'error, not found'
  5077  3a9a 83b3f3                              +lbra error
  5078                          
  5079                          
  5080                          ; Set up to move STEP value to FAC
  5081                          
  5082  3a9d 20e631             l62_4            jsr movfnd                               ; (fndpnt) => (tos)
  5083  3aa0 a53f                                lda fndpnt
  5084  3aa2 18                                  clc
  5085  3aa3 6903                                adc #3                                   ; offset to step value
  5086  3aa5 a440                                ldy fndpnt+1
  5087  3aa7 9001                                bcc l62_5
  5088  3aa9 c8                                  iny
  5089                          
  5090  3aaa 200e62             l62_5            jsr movfm                                ; actually "move from ROM", but sys stack is in "common"
  5091  3aad a008                                ldy #8                                   ; MOVFM doesn't move sign.  Get it
  5092  3aaf b13f                                lda (fndpnt),y
  5093  3ab1 8568                                sta facsgn
  5094                          
  5095                          ; Get pointer to FOR variable
  5096                          
  5097  3ab3 a001                                ldy #1
  5098  3ab5 b13f                                lda (fndpnt),y                           ; get lsb
  5099  3ab7 48                                  pha
  5100  3ab8 aa                                  tax
  5101  3ab9 c8                                  iny
  5102  3aba b13f                                lda (fndpnt),y                           ; get msb
  5103  3abc 48                                  pha
  5104  3abd a8                                  tay                                      ; msb in y
  5105  3abe 8a                                  txa                                      ; lsb in a
  5106  3abf 20bb5d                              jsr fadd                                 ; add STEP value to FOR variable (fadd gets from bank 1)
  5107  3ac2 7a                                  ply                                      ; msb in y
  5108  3ac3 fa                                  plx                                      ; lsb in x
  5109  3ac4 206262                              jsr movmf_ram1                           ; put result back into FOR variable in var bank
  5110                          
  5111                          ; Make (a,y) point at TO value in stack
  5112                          
  5113  3ac7 a53f                                lda fndpnt
  5114  3ac9 18                                  clc
  5115  3aca 6909                                adc #9
  5116  3acc a440                                ldy fndpnt+1
  5117  3ace 9001                                bcc l62_6
  5118  3ad0 c8                                  iny
  5119                          
  5120                          ; Test if loop done
  5121                          
  5122                          l62_6
  5123                          ; sta sw_rom_ram0 ;????
  5124  3ad1 20f162                              jsr fcomp                                ; compare FAC to value pointed to by (a,y)
  5125  3ad4 a008                                ldy #8
  5126  3ad6 38                                  sec
  5127  3ad7 f13f                                sbc (fndpnt),y                           ; (common area????)
  5128  3ad9 f0a0                                beq l62_1                                ; branch taken if done
  5129                          
  5130  3adb a011                                ldy #17                                  ; not done, set pointers to re-execute loop
  5131  3add b13f                                lda (fndpnt),y                           ; (common area????)
  5132  3adf 853d                                sta txtptr
  5133  3ae1 88                                  dey
  5134  3ae2 b13f                                lda (fndpnt),y
  5135  3ae4 853e                                sta txtptr+1
  5136  3ae6 88                                  dey
  5137  3ae7 b13f                                lda (fndpnt),y
  5138  3ae9 853c                                sta curlin+1
  5139  3aeb 88                                  dey
  5140  3aec b13f                                lda (fndpnt),y
  5141  3aee 853b                                sta curlin
  5142  3af0 60                 l62_7            rts
  5143                          
  5144                          ;.end
  5145                          ; .page
  5146                          ; .subttl DIM
  5147                          
  5148                          ; The DIMension code sets DIMFLG and then falls into the variable search
  5149                          ; routine, which looks at DIMFLG at 3 different points:
  5150                          ;
  5151                          ; 1) If an entry is found, DIMFLG being on indicates a
  5152                          ;    doubly-defined variable.
  5153                          ; 2) When a new entry is being built, DIMFLG being on indicates
  5154                          ;    the indices should be used for the size of each index.
  5155                          ;    Otherwise the default of ten is used.
  5156                          ; 3) When the build entry code finishes, indexing will be done
  5157                          ;    only if DIMFLG is off.
  5158                          
  5159                          
  5160  3af1 205b4e             dim3             jsr chkcom                               ; must be a comma
  5161                          
  5162  3af4 aa                 dim              tax                                      ; make .x non-zero (.a must be non-zero to work correctly)
  5163  3af5 20814f                              jsr ptrgt1
  5164  3af8 208522                              jsr chrgot                               ; get last character
  5165  3afb d0f4                                bne dim3
  5166  3afd 60                                  rts
  5167                          
  5168                          ;.end
  5169                          ; .page
  5170                          ; .subttl SYS
  5171                          
  5172  3afe 208a5d             sys              jsr getwrd                               ; convert arg to integer value
  5173  3b01 a516                                lda linnum                               ; set up arg's for call to 'long jsr'
  5174  3b03 8504                                sta _pclo
  5175  3b05 a517                                lda linnum+1
  5176  3b07 8503                                sta _pchi
  5177  3b09 add102                              lda current_bank
  5178  3b0c 8502                                sta _bank
  5179                          
  5180  3b0e 202679                              jsr optbyt                               ; (optional) .A reg arg
  5181  3b11 9002                                bcc l63_1
  5182  3b13 8606                                stx _a_reg
  5183                          
  5184  3b15 202679             l63_1            jsr optbyt                               ; (optional) .X reg arg
  5185  3b18 9002                                bcc l63_2
  5186  3b1a 8607                                stx _x_reg
  5187                          
  5188  3b1c 202679             l63_2            jsr optbyt                               ; (optional) .Y reg arg
  5189  3b1f 9009                                bcc l63_4
  5190  3b21 8608                                stx _y_reg
  5191                          
  5192  3b23 202679             l63_3            jsr optbyt                               ; (optional) .Z reg arg
  5193  3b26 9002                                bcc l63_4
  5194  3b28 8609                                stx _z_reg
  5195                          
  5196  3b2a 202679             l63_4            jsr optbyt                               ; (optional) .S reg arg
  5197  3b2d 9002                                bcc l63_5
  5198  3b2f 8605                                stx _s_reg
  5199                          
  5200  3b31 4c6eff             l63_5            jmp _jsr_far                             ; far, far away
  5201                          ;If returns, Kernel will update _reg's for us
  5202                          
  5203                          ;.end
  5204                          ; .page
  5205                          ; .subttl DMA
  5206                          
  5207                          ; DMA - Set up for DMA operation (FETCH/STASH/SWAP)
  5208                          ;
  5209                          ;  Syntax:  DMA  command,length,source(l/h/b),destination(l/h/b)[,subcmd,mod(l/h)] [,...]
  5210                          
  5211                          
  5212                          dma                                                       ; params are not longer optional-  [910520] F018A
  5213  3b34 206c5d                              jsr getbyt                               ; get command
  5214  3b37 9009               l64_1            bcc l64_2
  5215  3b39 8a                                  txa                                      ; [910102]
  5216  3b3a 2904                                and #%00000100                           ;
  5217  3b3c d3c016                              +lbne fcerr                              ; (disallow chained DMA lists)
  5218  3b3f 8e5001                              stx dma2_cmd
  5219                          
  5220  3b42 20875d             l64_2            jsr comwrd                               ; get length
  5221                          ; bcc l64_3
  5222  3b45 8c5101                              sty dma2_cnt_lo
  5223  3b48 8d5201                              sta dma2_cnt_hi
  5224                          
  5225  3b4b 20875d             l64_3            jsr comwrd                               ; get source address & bank
  5226                          ; bcc l64_4
  5227  3b4e 8c5301                              sty dma2_src_lo
  5228  3b51 8d5401                              sta dma2_src_hi
  5229  3b54 20825d             l64_4            jsr combyt
  5230                          ; bcc l64_5
  5231  3b57 8e5501                              stx dma2_src_bank
  5232                          
  5233  3b5a 20875d             l64_5            jsr comwrd                               ; get destination address & bank
  5234                          ; bcc l64_6
  5235  3b5d 8c5601                              sty dma2_dest_lo
  5236  3b60 8d5701                              sta dma2_dest_hi
  5237  3b63 20825d             l64_6            jsr combyt
  5238                          ; bcc l64_7
  5239  3b66 8e5801                              stx dma2_dest_bank
  5240                          
  5241  3b69 202479             l64_7            jsr optzer                               ; get subcmd, default=0    [910520] F018A
  5242                          ; bcc l64_8
  5243  3b6c 8e5901                              stx dma2_subcmd
  5244                          
  5245  3b6f 202479             l64_8            jsr optzer                               ; get mod lo/hi, default=0   [910102]
  5246                          ; bcc l64_9
  5247  3b72 8e5a01                              stx dma2_mod_lo
  5248  3b75 202479             l64_9            jsr optzer
  5249                          ; bcc l64_10
  5250  3b78 8e5b01                              stx dma2_mod_hi
  5251                          
  5252  3b7b a000               l64_10           ldy #0                                   ; dma_list (bank 0)
  5253  3b7d a201                                ldx #>dma2_cmd
  5254  3b7f a950                                lda #<dma2_cmd
  5255  3b81 8c02d7                              sty dma_ctlr+2                           ; dma_list bank
  5256  3b84 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
  5257  3b87 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
  5258  3b8a 2c03d7             l64_11           bit dma_ctlr+3                           ; check status (in case IRQ enabled)  [910103]
  5259  3b8d 30fb                                bmi l64_11                               ; busy
  5260                          
  5261  3b8f 208522                              jsr chrgot                               ; eol?
  5262  3b92 f005                                beq l64_12                               ; yes
  5263  3b94 202679                              jsr optbyt                               ; no- continue after getting comma & next cmd byte
  5264  3b97 809e                                bra l64_1
  5265                          
  5266  3b99 60                 l64_12           rts
  5267                          
  5268                          ;.end
  5269                          ; .page
  5270                          ; .subttl  TRON  TROFF
  5271                          
  5272                          
  5273                          tron                                                      ; trace mode on
  5274  3b9a d77e                                smb5 runmod                              ; trcflg
  5275  3b9c 60                                  rts
  5276                          
  5277                          
  5278                          troff                                                     ; trace mode off
  5279  3b9d 577e                                rmb5 runmod                              ; trcflg
  5280  3b9f 60                                  rts
  5281                          
  5282                          
  5283                          ;.end
  5284                          ; .page
  5285                          ; .subttl  RREG
  5286                          
  5287                          ; RREG - Return values of 6502 registers following a SYS call.
  5288                          ;
  5289                          ; Syntax : RREG [.A variable [,[.X[...Z] variable] [,[.S variable] ]]]
  5290                          
  5291  3ba0 a900               rreg             lda #0
  5292  3ba2 850d                                sta count
  5293                          
  5294  3ba4 208522             l65_1            jsr chrgot
  5295  3ba7 f038                                beq l65_4                                ; reached end of statement- done
  5296  3ba9 c92c                                cmp #','                                 ; skip this arg?
  5297  3bab f022                                beq l65_3                                ; branch if so
  5298  3bad 207c4f                              jsr ptrget                               ; get pointer to target variable
  5299  3bb0 854b                                sta forpnt                               ; a little bit of set up so we can share LET code
  5300  3bb2 844c                                sty forpnt+1
  5301  3bb4 a50f                                lda valtyp                               ; what kind of variable name did ptrget find?
  5302  3bb6 d32f11                              +lbne chkerr                             ; type mismatch error if string
  5303                          
  5304  3bb9 a40d                                ldy count                                ; which register's value are we looking for?
  5305  3bbb b90600                              lda _a_reg,y                             ; .A, .X, .Y, & .Z are contiguious
  5306  3bbe c004                                cpy #4
  5307  3bc0 d002                                bne l65_2
  5308  3bc2 a505                                lda _s_reg                               ; but .S isn't
  5309                          
  5310  3bc4 a8                 l65_2            tay                                      ; low byte in .Y
  5311  3bc5 a900                                lda #0                                   ; high byte of zero
  5312  3bc7 203f4e                              jsr givayf                               ; go float it
  5313  3bca a510                                lda intflg                               ; set conditions for type of var (int/float)
  5314  3bcc 209336                              jsr qintgr                               ; ..and use part of LET to do the work
  5315                          
  5316  3bcf e60d               l65_3            inc count                                ; 5 registers to do
  5317  3bd1 a50d                                lda count
  5318  3bd3 c905                                cmp #5
  5319  3bd5 b00a                                bcs l65_4
  5320  3bd7 208522                              jsr chrgot                               ; was this e-o-statement?
  5321  3bda f005                                beq l65_4
  5322  3bdc 208322                              jsr chrget                               ; not e-o-s, skip over comma,
  5323  3bdf d0c3                                bne l65_1                                ; ..and go do next
  5324                          
  5325  3be1 60                 l65_4            rts
  5326                          
  5327                          ;.end
  5328                          ; .page
  5329                          ; .subttl MID$
  5330                          
  5331                          ; Alternate use of the MID$ function, as the target of an assignment.
  5332                          ;
  5333                          ; MID$(string_var,starting_position [,length]) = string_expression
  5334                          
  5335                          midd2
  5336                          midwrk           =midd2-1
  5337                          
  5338  3be2 20584e                              jsr chkopn                               ; check for '('
  5339  3be5 207c4f                              jsr ptrget                               ; get pointer to descriptor of string-var
  5340  3be8 854b                                sta forpnt                               ; store for later use
  5341  3bea 844c                                sty forpnt+1
  5342  3bec 20dd4c                              jsr chkstr                               ; check if string
  5343                          
  5344  3bef 20825d                              jsr combyt                               ; look for comma, followed by 1 byte starting address
  5345  3bf2 ca                                  dex                                      ; adjust starting addr
  5346  3bf3 8677                                stx hulp                                 ; store    " "
  5347                          
  5348  3bf5 c929                                cmp #')'                                 ; finished?
  5349  3bf7 f004                                beq l66_1                                ; branch if so (use default length)
  5350  3bf9 20825d                              jsr combyt                               ; ..else get length
  5351  3bfc 2c                                  !text $2c
  5352                          
  5353  3bfd a2ff               l66_1            ldx #$ff                                 ; default length
  5354  3bff 8676                                stx z_p_temp_1
  5355  3c01 20554e                              jsr chkcls                               ; look for ')'
  5356  3c04 a9b2                                lda #equal_token                         ; look for '='
  5357  3c06 205d4e                              jsr synchr
  5358  3c09 20ef4c                              jsr frmevl                               ; bring on the source!
  5359  3c0c 20dd4c                              jsr chkstr                               ; nothing funny
  5360                          
  5361  3c0f a002                                ldy #2                                   ; get string descriptors
  5362  3c11 a94b               l66_2            lda #forpnt                              ; target
  5363  3c13 20d722                              jsr lda_far_ram1                         ; lda (forpnt),y
  5364  3c16 995d00                              sta str1,y
  5365  3c19 20a922                              jsr indfmo                               ; source
  5366  3c1c 996000                              sta str2,y
  5367  3c1f 88                                  dey
  5368  3c20 10ef                                bpl l66_2
  5369                          
  5370                          ; Test for target string in text was removed-  all strings are copied to
  5371                          ; string RAM when they are created.
  5372                          
  5373  3c22 38                                  sec                                      ; adjust pointer to source string so that the same
  5374  3c23 a561                                lda str2+1                               ; ..index can load & save
  5375  3c25 e577                                sbc hulp
  5376  3c27 8561                                sta str2+1
  5377  3c29 b002                                bcs l66_3
  5378  3c2b c662                                dec str2+2
  5379                          
  5380  3c2d a576               l66_3            lda z_p_temp_1                           ; get specified length (or default)
  5381  3c2f c560                                cmp str2                                 ; compare with length of source
  5382  3c31 9002                                bcc l66_4                                ; ok if less,
  5383  3c33 a560                                lda str2                                 ; ..else use length of source
  5384  3c35 aa                 l66_4            tax
  5385  3c36 f01f                                beq l66_7                                ; done if length=0
  5386  3c38 18                                  clc
  5387  3c39 6577                                adc hulp                                 ; add length to starting posn.
  5388  3c3b b3c115                              +lbcs fcerr                              ; illegal quantity error if > 256
  5389  3c3e c55d                                cmp str1
  5390  3c40 9003                                bcc l66_5
  5391  3c42 d3ba15                              +lbne fcerr                              ; ...or if > target length
  5392                          
  5393  3c45 a477               l66_5            ldy hulp                                 ; get adjusted starting address
  5394  3c47 da                 l66_6            phx
  5395  3c48 a25e                                ldx #str1+1
  5396  3c4a a961                                lda #str2+1
  5397  3c4c 20d722                              jsr lda_far_ram1                         ; fetch from string bank
  5398  3c4f 20f022                              jsr sta_far_ram1                         ; this is what it's all about
  5399  3c52 c8                                  iny
  5400  3c53 fa                                  plx
  5401  3c54 ca                                  dex
  5402  3c55 d0f0                                bne l66_6                                ; keep going for specified length
  5403                          
  5404  3c57 83141f             l66_7            +lbra frefac                             ; free up temp. string, rts
  5405                          
  5406                          ;.end
  5407                          
  5408                          ; .page
  5409                          ; .subttl  AUTO
  5410                          
  5411                          ; AUTO Increment
  5412                          ;   Syntax :    auto {line-number} (line-number = 0 means turn off)
  5413                          
  5414                          auto
  5415  3c5a 20ed58                              jsr errind
  5416  3c5d 202e32                              jsr linget
  5417  3c60 a516                                lda linnum
  5418  3c62 8574                                sta autinc
  5419  3c64 a517                                lda linnum+1
  5420  3c66 8575                                sta autinc+1
  5421  3c68 60                                  rts
  5422                          
  5423                          ;.end
  5424                          ; .page
  5425                          ; .subttl  HELP
  5426                          
  5427  3c69 aec702             help             ldx errnum                               ; check for error status
  5428  3c6c e8                                  inx
  5429  3c6d f022                                beq l67_1                                ; exit if there is no current error
  5430  3c6f adc802                              lda errlin
  5431  3c72 acc902                              ldy errlin+1
  5432  3c75 8516                                sta linnum
  5433  3c77 8417                                sty linnum+1
  5434  3c79 20fa31                              jsr FindLine                             ; find the beginning of line with error
  5435  3c7c 9013                                bcc l67_1                                ; exit if line not found?
  5436                          
  5437  3c7e 20f737                              jsr crdo                                 ; begin a new line
  5438  3c81 a616                                ldx linnum
  5439  3c83 a517                                lda linnum+1
  5440  3c85 ab5500                              ldz helper
  5441  3c88 4755                                rmb4 helper                              ; temporarily disable token highlighting
  5442  3c8a f755                                smb7 helper                              ; set 'help' flag for P1LINE
  5443  3c8c 207733                              jsr p1line                               ; display line & highlight error
  5444  3c8f 6455                                stz helper
  5445  3c91 7755               l67_1            rmb7 helper                              ; reset 'help' flag
  5446  3c93 8362fb                              +lbra crdo                               ; and return to caller
  5447                          
  5448                          
  5449                          
  5450                          helpsb                                                    ; logic to highlight error or find string
  5451  3c96 cf5532                              bbs4 helper,highlight_done               ; branch if highlighting tokens
  5452  3c99 df5514                              bbs5 helper,l68_3                        ; branch if FIND
  5453                          
  5454  3c9c a662                                ldx lowtr+1                              ; has P1LINE reached code in error?
  5455  3c9e 98                                  tya
  5456  3c9f 18                                  clc
  5457  3ca0 6561                                adc lowtr                                ; add character pointer to line pointer...
  5458  3ca2 9001                                bcc l68_1
  5459  3ca4 e8                                  inx
  5460  3ca5 ecce02             l68_1            cpx errtxt+1                             ; and compare to error pointer
  5461  3ca8 d005                                bne l68_2                                ; not there
  5462  3caa cdcd02                              cmp errtxt
  5463  3cad b02d                                bcs highlight_text                       ; we're there- begin highlighting
  5464  3caf 60                 l68_2            rts
  5465                          
  5466                          
  5467  3cb0 c43f               l68_3            cpy fndpnt                               ; at first character of find string?
  5468  3cb2 9013                                bcc l68_5                                ; before it
  5469  3cb4 adda02                              lda find_count
  5470  3cb7 f00e                                beq l68_5                                ; past it
  5471  3cb9 300d                                bmi l68_6                                ; at last character
  5472  3cbb c58a                                cmp fstr1+2
  5473  3cbd 9003                                bcc l68_4                                ; in middle of string
  5474  3cbf 20dc3c                              jsr highlight_text                       ; at first char- start highlight
  5475  3cc2 ceda02             l68_4            dec find_count                           ; one less character to highlight
  5476  3cc5 f0fb                                beq l68_4                                ; special case-
  5477                          ;make it negative for next time around
  5478  3cc7 60                 l68_5            rts
  5479                          
  5480  3cc8 eeda02             l68_6            inc find_count                           ; make it zero
  5481                          
  5482                          
  5483                          highlight_done                                            ; nasty kludge to colorize error or found text
  5484  3ccb add902                              lda highlight_save
  5485  3cce 300b                                bmi l69_1                                ; (unless it's already normal)
  5486  3cd0 85f1                                sta _color                               ; restore normal color
  5487  3cd2 0980                                ora #$80
  5488  3cd4 8dd902                              sta highlight_save                       ; mark highlight_save invalid
  5489  3cd7 7755                                rmb7 helper                              ; remove HELP flag
  5490  3cd9 1755                                rmb1 helper                              ; remove token flag
  5491  3cdb 60                 l69_1            rts
  5492                          
  5493                          
  5494                          highlight_text                                            ; nasty kludge to colorize error or found text
  5495  3cdc 2cd902                              bit highlight_save
  5496  3cdf 100a                                bpl l70_1                                ; (unless it's already highlighted)
  5497  3ce1 a5f1                                lda _color                               ; save current (normal) color
  5498  3ce3 8dd902                              sta highlight_save                       ; msb=0 to mark highlight_save valid
  5499  3ce6 add802                              lda highlight_color
  5500  3ce9 85f1                                sta _color                               ; change color to highlight
  5501  3ceb 60                 l70_1            rts
  5502                          
  5503                          ;.end
  5504                          ; .page
  5505                          ; .subttl  GOSUB  GOTO
  5506                          
  5507                          ; GOSUB-  Push text pointer, line #, & gosub token on stack:
  5508                          ;
  5509                          ;  (bottom) highest memory
  5510                          ;===========================================================
  5511                          ;  txtptr+1 address of next statement
  5512                          ;  txtptr
  5513                          ;  ========
  5514                          ;  curlin+1 current line number
  5515                          ;  curlin
  5516                          ;  ========
  5517                          ;  'gosub' token <== (tos) top of stack pointer
  5518                          ;===========================================================
  5519                          ;  (top of stack) lowest memory
  5520                          
  5521                          
  5522  3cec cf7e6a             gosub            bbs4 runmod,edit_err                     ; [910620]
  5523  3cef 20393d                              jsr gosub_sub
  5524  3cf2 208522                              jsr chrgot                               ; get character and set carry for linget
  5525  3cf5 20fb3c                              jsr goto
  5526  3cf8 8313ef                              +lbra newstt
  5527                          
  5528                          ; .page
  5529  3cfb cf7e5b             goto             bbs4 runmod,edit_err                     ; [910620]
  5530  3cfe 202e32                              jsr linget                               ; pick up the line number in LINNUM
  5531  3d01 a50b                                lda endchr                               ; test if linget found any number
  5532  3d03 f345f1                              +lbeq snerr                              ; no number error
  5533                          
  5534  3d06 205e35             goto_1           jsr remn                                 ; jump to end of line (entry for interrupt code)
  5535  3d09 38                                  sec
  5536  3d0a a53b                                lda curlin
  5537  3d0c e516                                sbc linnum
  5538  3d0e a53c                                lda curlin+1
  5539  3d10 e517                                sbc linnum+1
  5540  3d12 b00b                                bcs luk4it
  5541  3d14 98                                  tya
  5542  3d15 38                                  sec
  5543  3d16 653d                                adc txtptr
  5544  3d18 a63e                                ldx txtptr+1
  5545  3d1a 9007                                bcc lukall
  5546  3d1c e8                                  inx
  5547  3d1d 8004                                bra lukall                               ; always goes
  5548                          
  5549                          
  5550  3d1f a52d               luk4it           lda txttab
  5551  3d21 a62e                                ldx txttab+1
  5552                          
  5553  3d23 20fe31             lukall           jsr FindLink                             ; (a,x) are all set up
  5554  3d26 9316f1                              +lbcc userr                              ; undefined statement error
  5555  3d29 a561                                lda lowtr
  5556  3d2b e901                                sbc #1
  5557  3d2d 853d                                sta txtptr
  5558  3d2f a562                                lda lowtr+1
  5559  3d31 e900                                sbc #0
  5560  3d33 853e                                sta txtptr+1
  5561  3d35 7f7e63                              bbr7 runmod,setexc                       ; branch if in direct mode
  5562  3d38 60                                  rts
  5563                          
  5564                          
  5565                          
  5566                          gosub_sub
  5567  3d39 a905                                lda #lengos                              ; free up necessary space on stack
  5568  3d3b 209431                              jsr getstk                               ; make sure there is room
  5569  3d3e a004                                ldy #lengos-1
  5570  3d40 a53e                                lda txtptr+1                             ; push on the text pointer
  5571  3d42 917c                                sta (tos),y                              ; (common area)
  5572  3d44 88                                  dey
  5573  3d45 a53d                                lda txtptr
  5574  3d47 917c                                sta (tos),y                              ; (common area)
  5575  3d49 88                                  dey
  5576  3d4a a53c                                lda curlin+1                             ; push on the current line number
  5577  3d4c 917c                                sta (tos),y                              ; (common area)
  5578  3d4e 88                                  dey
  5579  3d4f a53b                                lda curlin
  5580  3d51 917c                                sta (tos),y                              ; (common area)
  5581  3d53 88                                  dey
  5582  3d54 a98d                                lda #gosub_token                         ; (a) was smashed by GETSTK
  5583  3d56 917c                                sta (tos),y                              ; (common area)
  5584  3d58 60                                  rts
  5585                          
  5586                          
  5587                          edit_err
  5588  3d59 a22a                                ldx #edit_mode_error                     ; [910620]
  5589  3d5b 83f2f0                              +lbra error
  5590                          
  5591                          ;.end
  5592                          ; .page
  5593                          ; .subttl  GO  GO64
  5594                          
  5595                          go_without_to
  5596  3d5e 208322                              jsr chrget                               ; what is next character?
  5597  3d61 c9a4                                cmp #to_token                            ; ..is it GO TO?
  5598  3d63 d005                                bne l71_1
  5599  3d65 208322                              jsr chrget                               ; ..yes, set up for goto
  5600  3d68 8091                                bra goto                                 ; ..bye!
  5601                          
  5602  3d6a 206c5d             l71_1            jsr getbyt                               ; is it GO 64?
  5603  3d6d e040                                cpx #64
  5604  3d6f d3d9f0                              +lbne snerr                              ; ...no, error
  5605                          
  5606                          ; The user wants to go to C64 mode.
  5607                          
  5608  3d72 20c378             l71_2            jsr are_you_sure
  5609  3d75 d03c                                bne cont_rts                             ; must have had second thoughts. never mind
  5610                          ; jsr put_io_in_map
  5611  3d77 4c53ff                              jmp _go_64
  5612                          
  5613                          
  5614                          ;.end
  5615                          ; .page
  5616                          ; .subttl  CONTINUE
  5617                          ;**********************************************************
  5618                          ;*
  5619                          ;* CONTINUE Execution after STOP/END
  5620                          ;*
  5621                          ;**********************************************************
  5622                          
  5623  3d7a d037               cont             bne cont_rts                             ; make sure there is a terminator
  5624  3d7c cf7eda                              bbs4 runmod,edit_err                     ; [910620]
  5625  3d7f ff7e31                              bbs7 runmod,cont_rts                     ; if in run-mode just rts
  5626                          
  5627  3d82 a21a                                ldx #errcn                               ; continue error.
  5628  3d84 ac7311                              ldy oldtxt+1                             ; a stored txtptr of zero set up by INIT_STACK
  5629  3d87 f3c6f0                              +lbeq error                              ; indicates there is nothing to continue
  5630                          
  5631  3d8a ad7211                              lda oldtxt                               ; STOP, END, typing crlf to INPUT, and STOP key
  5632  3d8d 853d                                sta txtptr
  5633  3d8f 843e                                sty txtptr+1
  5634  3d91 ad7011                              lda oldlin
  5635  3d94 ac7111                              ldy oldlin+1
  5636  3d97 853b                                sta curlin
  5637  3d99 843c                                sty curlin+1
  5638                          
  5639  3d9b f77e               setexc           smb7 runmod                              ; set up run mode
  5640  3d9d a900                                lda #0
  5641  3d9f 8574                                sta autinc                               ; turn auto increment off
  5642  3da1 8575                                sta autinc+1
  5643  3da3 8ddc02                              sta intval                               ; enable & reset collision-trapping mechanism
  5644  3da6 85f6                                sta _autoinsert                          ; disable auto-insert mode ?????
  5645                          
  5646  3da8 a202                                ldx #2                                   ; turn off all interrupt trip flags
  5647  3daa 9ddd02             l72_1            sta int_trip_flag,x
  5648  3dad ca                                  dex
  5649  3dae 10fa                                bpl l72_1
  5650                          
  5651  3db0 2090ff                              jsr _setmsg                              ; turn kernel messages off & rts
  5652                          
  5653                          cont_rts
  5654  3db3 60                                  rts
  5655                          
  5656                          ;.end
  5657                          ; .page
  5658                          ; .subttl  RUN
  5659                          ;***********************************************************
  5660                          ;*
  5661                          ;* RUN Command
  5662                          ;*
  5663                          ;* RUN [line_number]
  5664                          ;* RUN filename [[ON] Ddrive_number[,Uunit_number]]
  5665                          ;*
  5666                          ;* Entry:  RUN_A_PROGRAM sets up, links, and executes
  5667                          ;*  a program previously loaded into RAM.
  5668                          ;*
  5669                          ;***********************************************************
  5670                          
  5671  3db4 cf7ea2             run              bbs4 runmod,edit_err                     ; [910620]
  5672  3db7 f019                                beq run__10                              ; branch if no arguments
  5673  3db9 901d                                bcc run__20                              ; branch if number (i.e., RUN line_number)
  5674                          
  5675                          
  5676                          ; Here if of the form "RUN file_name"
  5677                          
  5678  3dbb e77e                                smb6 runmod                              ; set flag for load not to go to ready
  5679  3dbd 206971                              jsr dload                                ; use DLOAD's parser, and load the program
  5680  3dc0 b3742a                              +lbcs erexit                             ; if problem loading   [900801]
  5681                          
  5682                          run_a_program
  5683  3dc3 20f737                              jsr crdo                                 ; [911010]
  5684  3dc6 203e42                              jsr fix_links                            ; re-link the program
  5685  3dc9 209b3d                              jsr setexc                               ; set various run modes
  5686  3dcc 20a134                              jsr runc
  5687  3dcf 833cee                              +lbra newstt                             ; start executing
  5688                          
  5689                          
  5690                          ; Here if of the form "RUN"
  5691                          
  5692  3dd2 209b3d             run__10          jsr setexc                               ; set various run codes
  5693  3dd5 83caf6                              +lbra runc                               ; ..and start executing
  5694                          
  5695                          
  5696                          ; Here if of the form "RUN line_number"
  5697                          
  5698  3dd8 20cb34             run__20          jsr clearc                               ; first trash all variables
  5699  3ddb 208522                              jsr chrgot
  5700  3dde 20fb3c                              jsr goto                                 ; set up to execute from new line number
  5701  3de1 209b3d                              jsr setexc                               ; ..and do a little housekeeping,
  5702  3de4 8327ee                              +lbra newstt                             ; ..otherwise it's business as usual
  5703                          
  5704                          ;.end
  5705                          ; .page
  5706                          ; .subttl  RESTORE
  5707                          ;*********************************************************************
  5708                          ;*
  5709                          ;* RESTORE Command
  5710                          ;*
  5711                          ;* Reset pointers to next DATA statement.  Allows optional argument
  5712                          ;* specifying a specific line number, otherwise the default is the
  5713                          ;* beginning of text area.
  5714                          ;*
  5715                          ;*********************************************************************
  5716                          
  5717                          restor
  5718  3de7 f013                                beq restore__1                           ; branch if no argument...use default
  5719  3de9 208a5d                              jsr getwrd                               ; get 2 byte argument (???? no check for real number means a var legal)
  5720  3dec 8416                                sty linnum
  5721  3dee 8517                                sta linnum+1
  5722  3df0 20fa31                              jsr FindLine                             ; get pointer to specified line
  5723  3df3 9349f0                              +lbcc userr                              ; error if not found
  5724                          
  5725  3df6 a561                                lda lowtr                                ; decrement 2 byte pointer, and save it
  5726  3df8 a462                                ldy lowtr+1
  5727  3dfa 8005                                bra restore__2                           ; always
  5728                          
  5729                          
  5730                          restore__1                                                ; entry from FLOAD
  5731  3dfc 38                                  sec
  5732  3dfd a52d                                lda txttab
  5733  3dff a42e                                ldy txttab+1
  5734                          
  5735                          restore__2
  5736  3e01 e901                                sbc #1
  5737  3e03 b001                                bcs l73_1
  5738  3e05 88                                  dey
  5739  3e06 8543               l73_1            sta datptr
  5740  3e08 8444                                sty datptr+1
  5741  3e0a 60                                  rts
  5742                          
  5743                          ;.end
  5744                          ; .page
  5745                          ; .subttl  RENUMBER
  5746                          ;***********************************************************************
  5747                          ;
  5748                          ; RENUMBER Command
  5749                          ;
  5750                          ; Syntax:  RENUMBER [n1 [,[n2] ,n3]]
  5751                          ;
  5752                          ;  n1 = new start line number, default 10
  5753                          ;  n2 = line increment, default 10
  5754                          ;  n3 = start line, default first
  5755                          ;
  5756                          ; - Syntax error may occur for missing commas or bad line numbers.
  5757                          ; - Illegal quantity error for line increment of 0 or for bad range.
  5758                          ; - Overflow error if increment wraps line number during renumber,
  5759                          ;  line number too large error if renumbering would force line
  5760                          ;  numbers greater than 63999.
  5761                          ; - Out of memory error if the renumbered program would be too large.
  5762                          ; - Unresolved reference error if an imbedded line number references
  5763                          ;  a line which does not exist.
  5764                          ;
  5765                          ; Otherwise returns to "ready" mode upon completion.
  5766                          ;
  5767                          ;***********************************************************************
  5768                          
  5769                          
  5770                          ; Before any data is changed in any way, two preliminary passes are
  5771                          ; made to insure no errors would occur during the actual renumbering
  5772                          ; process (as detailed below).
  5773                          ;
  5774                          ; Pass 1 makes sure that the renumbered program would have no line
  5775                          ; numbers greater than 63999 (nothing is actually renumbered; the
  5776                          ; statement table is not modified).
  5777                          ;
  5778                          ; Pass 2 checks if the renumbered program would be too long and also
  5779                          ; checks for non-existant line number destinations.
  5780                          ;
  5781                          ; Pass 3 examines the entire statement table first for imbedded line
  5782                          ; numbers (branches) to fix. This is done by looking for keywords (GOTO,
  5783                          ; GOSUB, THEN, RUN) which are usually followed by line numbers. The old
  5784                          ; line number is mapped to a new value and the string representing the
  5785                          ; new branch label replaces the original text.
  5786                          ;
  5787                          ; Pass 4 then replaces the statement number bytes by their final values.
  5788                          ; and the table is relinked.
  5789                          
  5790                          
  5791                          testwd
  5792  3e0b 898a8da7                            !text goto_token,run_token,gosub_token,then_token
  5793  3e0f 8cd6d7d5                            !text restore_token,resume_token,trap_token,else_token
  5794                          
  5795                          renumber
  5796  3e13 20ed58                              jsr errind                               ; allowed only in direct mode
  5797                          
  5798                          ; Set up default values for n1, n2, and n3
  5799                          
  5800  3e16 a900                                lda #0                                   ; line #10...
  5801  3e18 a20a                                ldx #10
  5802  3e1a 8e7911                              stx renum_tmp_1                          ; default renum origin (n1)
  5803  3e1d 8d7a11                              sta renum_tmp_1+1
  5804  3e20 8e7b11                              stx renum_tmp_2                          ; default increment (n2)
  5805  3e23 8d7c11                              sta renum_tmp_2+1
  5806  3e26 855c                                sta hightr                               ; default start line # (n3)
  5807  3e28 855d                                sta hightr+1
  5808                          
  5809  3e2a 208522                              jsr chrgot                               ; any parameters?
  5810  3e2d f053                                beq ren_pass_1                           ; no...
  5811                          
  5812                          
  5813                          ; Check for new starting line number (n1)
  5814                          
  5815  3e2f 202e32                              jsr linget                               ; check for a number
  5816  3e32 a50b                                lda endchr                               ; was there one?
  5817  3e34 f00a                                beq renum_10                             ; no...use default
  5818  3e36 a516                                lda linnum
  5819  3e38 a617                                ldx linnum+1
  5820  3e3a 8d7911                              sta renum_tmp_1
  5821  3e3d 8e7a11                              stx renum_tmp_1+1
  5822                          
  5823                          ; Check for new increment
  5824                          
  5825                          renum_10
  5826  3e40 20f278                              jsr optwrd                               ; an increment given?
  5827  3e43 900c                                bcc renum_30                             ; no...use default
  5828                          
  5829  3e45 8c7b11                              sty renum_tmp_2
  5830  3e48 8d7c11                              sta renum_tmp_2+1
  5831  3e4b 0d7b11                              ora renum_tmp_2                          ; increment must be >0
  5832  3e4e f3ae13                              +lbeq fcerr                              ; illegal quantity error
  5833                          
  5834                          ; Check for starting line number
  5835                          
  5836                          renum_30
  5837  3e51 20f278                              jsr optwrd                               ; starting line number given?
  5838  3e54 902c                                bcc ren_pass_1                           ; no...
  5839                          
  5840  3e56 845c                                sty hightr
  5841  3e58 8416                                sty linnum
  5842  3e5a 855d                                sta hightr+1
  5843  3e5c 8517                                sta linnum+1
  5844  3e5e 20fa31                              jsr FindLine                             ; test for illegal renumber range
  5845  3e61 a561                                lda lowtr                                ; (n1 must be >= n3)
  5846  3e63 a662                                ldx lowtr+1
  5847  3e65 855a                                sta highds                               ; pointer to first statement to renumber
  5848  3e67 865b                                stx highds+1
  5849  3e69 ad7911                              lda renum_tmp_1
  5850  3e6c ae7a11                              ldx renum_tmp_1+1
  5851  3e6f 8516                                sta linnum
  5852  3e71 8617                                stx linnum+1
  5853  3e73 20fa31                              jsr FindLine                             ; lowtr = ptr to 1st stmt to be overlapped
  5854  3e76 38                                  sec
  5855  3e77 a561                                lda lowtr                                ; can't be smaller
  5856  3e79 e55a                                sbc highds
  5857  3e7b a562                                lda lowtr+1
  5858  3e7d e55b                                sbc highds+1
  5859  3e7f 937d13                              +lbcc fcerr                              ; bad...
  5860                          
  5861                          ; .page
  5862                          ;***********************************************************************
  5863                          ;**************  R E N U M B E R    P A S S    O N E  ******************
  5864                          ;***********************************************************************
  5865                          
  5866                          ; Pass 1 makes sure that the renumbered program will not have any line numbers
  5867                          ; greater than 63999 (however, nothing is actually renumbered in this pass).
  5868                          
  5869                          ren_pass_1
  5870  3e82 20472c                              jsr tto                                  ; save txtptr for restoration when done
  5871  3e85 207240                              jsr n1_reset                             ; put n1 in FAC, reset txtptr
  5872  3e88 20a540                              jsr chargt                               ; skip low link
  5873  3e8b c8                                  iny                                      ; (.y=1)
  5874  3e8c 20c522                              jsr indtxt                               ; skip high link
  5875  3e8f f03a                                beq ren_pass_2                           ; end of program => begin pass 2 (assumes txttab > 0)
  5876                          
  5877                          r_pass1_10
  5878  3e91 c8                                  iny                                      ; (.y=2)
  5879  3e92 20c522                              jsr indtxt                               ; line number low
  5880  3e95 38                                  sec
  5881  3e96 e55c                                sbc hightr                               ; in line range which is to be renumbered?
  5882  3e98 c8                                  iny                                      ; (.y=3)
  5883  3e99 20c522                              jsr indtxt                               ; line number high
  5884  3e9c e55d                                sbc hightr+1
  5885  3e9e b007                                bcs r_pass1_20                           ; yes => fake renumbering
  5886  3ea0 20ba3e                              jsr set_next                             ; goto next line
  5887  3ea3 d0ec                                bne r_pass1_10                           ; if z=0 then not end-of-text => keep going
  5888  3ea5 f024                                beq ren_pass_2                           ; else end
  5889                          
  5890                          r_pass1_20
  5891  3ea7 20ba3e                              jsr set_next                             ; goto next line
  5892  3eaa f01f                                beq ren_pass_2                           ; if z=1 then end-of-text => exit
  5893  3eac 209340                              jsr new_num                              ; create next line number
  5894  3eaf b004                                bcs r_pass1_30                           ; if c=1 then it wrapped => error
  5895  3eb1 c9f9                                cmp #>63999                              ; can't have lines > 63999
  5896  3eb3 90f2                                bcc r_pass1_20                           ; if c=0 then ok
  5897                          
  5898                          r_pass1_30                                                ; renumbering will generate an illegal line #
  5899  3eb5 a226                                ldx #err_too_large                       ; 'line number too large' error
  5900  3eb7 8396ef                              +lbra error
  5901                          
  5902                          set_next
  5903  3eba a000                                ldy #0                                   ; set for next BASIC line
  5904  3ebc 20c522                              jsr indtxt                               ; low link
  5905  3ebf aa                                  tax
  5906  3ec0 c8                                  iny                                      ; (.y=1)
  5907  3ec1 20c522                              jsr indtxt                               ; high link
  5908  3ec4 f004                                beq set_end                              ; if z=1 then end of program => exit
  5909  3ec6 863d                                stx txtptr
  5910  3ec8 853e                                sta txtptr+1
  5911  3eca 60                 set_end          rts
  5912                          
  5913                          ; .page
  5914                          ;***********************************************************************
  5915                          ;**************  R E N U M B E R    P A S S    T W O  ******************
  5916                          ;***********************************************************************
  5917                          
  5918                          ; Pass 2 checks if the renumbered program will be too long and also
  5919                          ; checks for non-existant line number destinations.
  5920                          
  5921                          ren_pass_2
  5922  3ecb 4f7e05                              bbr4 runmod,l74_1                        ; skip pass two and three if plain text (edit mode) [910620]
  5923  3ece 207240                              jsr n1_reset                             ; yes- just setup up starting line # and reset txtptr
  5924  3ed1 8014                                bra ren_pass_4                           ; then renumber just the text's line numbers
  5925                          
  5926  3ed3 a901               l74_1            lda #$01                                 ; set flag for 'pass 2'
  5927  3ed5 8576                                sta z_p_temp_1
  5928  3ed7 a582                                lda text_top                             ; copy top-of-text pointer for later use
  5929  3ed9 a683                                ldx text_top+1                           ; (we don't want to change original here)
  5930  3edb 853f                                sta fndpnt
  5931  3edd 8640                                stx fndpnt+1
  5932  3edf 20293f                              jsr imbed_lines                          ; search for imbedded lines (but don't change)
  5933                          
  5934                          
  5935                          
  5936                          ;***********************************************************************
  5937                          ;************  R E N U M B E R    P A S S    T H R E E  ****************
  5938                          ;***********************************************************************
  5939                          
  5940                          ; Pass 3 actually renumbers the imbedded destination line numbers
  5941                          ; which follow goto, gosub, trap, etc.
  5942                          
  5943                          ren_pass_3
  5944  3ee2 c676                                dec z_p_temp_1                           ; z_p_temp_1 = 0 (for pass 3)
  5945  3ee4 20293f                              jsr imbed_lines                          ; search for and update imbedded line #'s
  5946                          
  5947                          ; .page
  5948                          ;***********************************************************************
  5949                          ;*************  R E N U M B E R    P A S S    F O U R  *****************
  5950                          ;***********************************************************************
  5951                          
  5952                          ; Pass 4 actually renumbers the program line numbers & exits
  5953                          
  5954                          ren_pass_4
  5955  3ee7 20a340                              jsr chargt_x2                            ; skip link
  5956  3eea f031                                beq renumber_exit                        ; null link=> end-of-text, exit (assumes txttab > 0)
  5957  3eec 20a540                              jsr chargt                               ; not null...
  5958  3eef 8516                                sta linnum                               ; if line# >= start#, replace with facho
  5959  3ef1 c8                                  iny
  5960  3ef2 20c522                              jsr indtxt
  5961  3ef5 38                                  sec
  5962  3ef6 e55d                                sbc hightr+1
  5963  3ef8 901b                                bcc r_pass4_20                           ; no, let alone
  5964  3efa d006                                bne r_pass4_10                           ; yes, replace
  5965  3efc a516                                lda linnum
  5966  3efe e55c                                sbc hightr
  5967  3f00 9013                                bcc r_pass4_20                           ; no, let alone
  5968                          
  5969                          r_pass4_10
  5970  3f02 a564                                lda facho
  5971                          ; phx
  5972  3f04 200a23                              jsr sta_far_txt                          ; sta (txtptr),y  hi  (bleed-thru)
  5973  3f07 88                                  dey
  5974  3f08 a565                                lda facho+1
  5975  3f0a 200a23                              jsr sta_far_txt                          ; sta (txtptr),y  lo (bleed-thru)
  5976                          ; plx
  5977  3f0d 20a540                              jsr chargt                               ; skip past 2nd byte of line#
  5978  3f10 208a40                              jsr line_inc                             ; incr line# and scan to eol
  5979  3f13 80d2                                bra ren_pass_4                           ; always...
  5980                          
  5981                          r_pass4_20
  5982  3f15 20a540                              jsr chargt                               ; skip past line#
  5983  3f18 208d40                              jsr scan_thru                            ; scan to eol
  5984  3f1b 80ca                                bra ren_pass_4                           ; always...
  5985                          
  5986                          
  5987                          renumber_exit
  5988  3f1d 203e42                              jsr fix_links                            ; patch things up: relink & set eot
  5989                          
  5990                          direct_mode_exit
  5991  3f20 20f439                              jsr ott                                  ; restore txtptr for next command in buffer
  5992  3f23 a900                                lda #0                                   ; but disallow continuing
  5993  3f25 8d7311                              sta oldtxt+1
  5994  3f28 60                                  rts
  5995                          
  5996                          ; .page
  5997                          ;***********************************************************************
  5998                          ;*************  R E N U M B E R   S U B R O U T I N E S  ***************
  5999                          ;***********************************************************************
  6000                          
  6001                          ; Look for imbedded line #'s (after GOTO, GOSUB, etc.)
  6002                          ; but only change them in pass 3 (ie. z_p_temp_1 = 0)
  6003                          
  6004                          imbed_lines
  6005  3f29 201f35                              jsr reset_txtptr                         ; start at first line: load (txtptr) with (txttab)-1
  6006                          
  6007                          next_line
  6008  3f2c 20a340                              jsr chargt_x2                            ; skip link (assumes txttab > 0)
  6009  3f2f f34101                              +lbeq n1_reset                           ; null link: put current line # in fac, reset txtptr, exit
  6010  3f32 20a540                              jsr chargt                               ; line number
  6011  3f35 854b                                sta forpnt                               ; save in case there is an error
  6012  3f37 20a540                              jsr chargt
  6013  3f3a 854c                                sta forpnt+1
  6014                          
  6015                          next_char
  6016  3f3c 20a540                              jsr chargt                               ; first character in the line
  6017                          
  6018                          chk_quote
  6019  3f3f c922                                cmp #'"'                                 ; opening double quote?
  6020  3f41 d00b                                bne not_quote                            ; no...
  6021  3f43 20a540             l75_1            jsr chargt                               ; scan line
  6022  3f46 f0e4                                beq next_line                            ; end...
  6023  3f48 c922                                cmp #'"'                                 ; close double quote
  6024  3f4a d0f7                                bne l75_1                                ; no... continue
  6025  3f4c 80ee                                bra next_char                            ; yes... resume renumber
  6026                          
  6027                          not_quote
  6028  3f4e aa                                  tax                                      ; end of line?
  6029  3f4f f0db                                beq next_line                            ; yes...
  6030  3f51 10e9                                bpl next_char                            ; not a token...
  6031                          
  6032  3f53 a208                                ldx #8                                   ; check special token list
  6033  3f55 dd0a3e             l76_1            cmp testwd-1,x
  6034  3f58 f028                                beq iline_10                             ; a match...
  6035  3f5a ca                                  dex
  6036  3f5b d0f8                                bne l76_1                                ; continue until zero
  6037                          
  6038  3f5d c9cb                                cmp #go_token                            ; wasn't in the token list. check for 'go to'
  6039  3f5f d00b                                bne chk_escape                           ; not 'go', go check for 'collision' *c128 fix*
  6040  3f61 208322             hop_1            jsr chrget                               ; got a 'go', look for 'to'
  6041  3f64 f0c6                                beq next_line                            ; end of line, abort
  6042  3f66 c9a4                                cmp #to_token
  6043  3f68 f018                                beq iline_10                             ; got it! go to fix number routine
  6044  3f6a 80d0                                bra next_char                            ; no 'to', keep looking
  6045                          
  6046                          ; Look for 'COLLISION'.  This is an escape command. *c128 fix* ?????????
  6047                          
  6048                          chk_escape
  6049  3f6c c9fe                                cmp #esc_command_token
  6050  3f6e d0cc                                bne next_char
  6051  3f70 208322                              jsr chrget
  6052  3f73 f0ec                                beq hop_1                                ; end of line ,abort
  6053  3f75 c917                                cmp #collision_token
  6054  3f77 d0c3                                bne next_char
  6055  3f79 208322             l77_1            jsr chrget                               ; got it! skip over first argument
  6056  3f7c f0e3                                beq hop_1                                ; end of line, abort
  6057  3f7e c92c                                cmp #','
  6058  3f80 d0f7                                bne l77_1                                ; not there yet
  6059                          
  6060                          
  6061                          iline_10
  6062  3f82 a53d                                lda txtptr                               ; save current txtptr
  6063  3f84 8d7011                              sta oldlin
  6064  3f87 a53e                                lda txtptr+1
  6065  3f89 8d7111                              sta oldlin+1
  6066  3f8c 208322                              jsr chrget
  6067  3f8f b0ae                                bcs chk_quote                            ; not a #...
  6068  3f91 202e32                              jsr linget                               ; get line # from text
  6069  3f94 202340                              jsr form_line                            ; replace if this line # > n3
  6070  3f97 ad7011                              lda oldlin                               ; restore old txtptr
  6071  3f9a 853d                                sta txtptr
  6072  3f9c ad7111                              lda oldlin+1
  6073  3f9f 853e                                sta txtptr+1
  6074                          
  6075  3fa1 208322                              jsr chrget                               ; skip over leading spaces
  6076  3fa4 c33d                                dew txtptr                               ; then backup (txtptr) by 1
  6077  3fa6 a2ff                                ldx #$ff
  6078  3fa8 a576                                lda z_p_temp_1                           ; if this is pass2 then don't actually change
  6079  3faa f037                                beq p3code                               ; if z=1 then pass3 => ok to change
  6080  3fac 20b83f                              jsr p2code                               ; renumber 'pass two': trial run to see if enough room
  6081  3faf 208522                              jsr chrgot                               ; re-get last character from BASIC text & rts
  6082                          
  6083                          iline_20
  6084  3fb2 c92c                                cmp #','                                 ; comma from 'on'?
  6085  3fb4 f0cc                                beq iline_10                             ; it is...
  6086  3fb6 8087                                bra chk_quote                            ; no...
  6087                          
  6088                          ; .page
  6089                          ;*********** This part of imbed_lines executed in pass 2 only **********
  6090                          
  6091                          p2code                                                    ; updates text_top without actually changing lines
  6092  3fb8 e8                                  inx
  6093  3fb9 bd0101                              lda fbuffr+1,x                           ; get character from number
  6094  3fbc f01c                                beq l78_3                                ; end of number
  6095  3fbe 208322                              jsr chrget                               ; get digit from old number
  6096  3fc1 90f5                                bcc p2code                               ; digit...move on
  6097                          
  6098  3fc3 e33f               l78_1            inw fndpnt
  6099  3fc5 38                                  sec                                      ; have we run out of memory (theoretically)?
  6100  3fc6 a53f                                lda fndpnt                               ; (compare with limit-of-memory pointer)
  6101  3fc8 edcf02                              sbc max_mem_0
  6102  3fcb a540                                lda fndpnt+1
  6103  3fcd edd002                              sbc max_mem_0+1
  6104  3fd0 b36fee                              +lbcs omerr                              ; yes- out of memory error
  6105  3fd3 e8                                  inx                                      ; no - next...
  6106  3fd4 bd0101                              lda fbuffr+1,x
  6107  3fd7 d0ea                                bne l78_1
  6108  3fd9 60                 l78_2            rts                                      ; no more
  6109                          
  6110  3fda 208322             l78_3            jsr chrget
  6111  3fdd b0fa                                bcs l78_2                                ; old stuff after # is other char
  6112  3fdf c33f                                dew fndpnt                               ; digit...move down
  6113  3fe1 80f7                                bra l78_3                                ; still digits...
  6114                          
  6115                          ; .page
  6116                          ;*********** This part of imbed_lines executed in pass 3 only **********
  6117                          
  6118                          p3code
  6119  3fe3 e8                                  inx
  6120  3fe4 bd0101                              lda fbuffr+1,x                           ; get character from number
  6121  3fe7 f026                                beq l79_3                                ; end of number
  6122                          
  6123  3fe9 48                                  pha                                      ; save digit from new number
  6124  3fea 20a540                              jsr chargt                               ; get digit from old number
  6125  3fed c93a                                cmp #':'                                 ; command terminator or letter?
  6126  3fef b00c                                bcs l79_1
  6127  3ff1 c920                                cmp #' '                                 ; space? (fix for goto10 :rem)
  6128  3ff3 f008                                beq l79_1
  6129  3ff5 38                                  sec
  6130  3ff6 e930                                sbc #'0'                                 ; number?
  6131  3ff8 38                                  sec
  6132  3ff9 e9d0                                sbc #$d0
  6133  3ffb 9008                                bcc l79_2                                ; digit...move on
  6134                          
  6135  3ffd 20ac40             l79_1            jsr move_init                            ; other char...move up
  6136  4000 201741                              jsr moveup
  6137  4003 e382                                inw text_top
  6138                          
  6139  4005 68                 l79_2            pla
  6140  4006 da                                  phx
  6141  4007 a000                                ldy #0
  6142  4009 200a23                              jsr sta_far_txt                          ; put new digit in new number (bleed-thru)
  6143  400c fa                                  plx
  6144  400d 80d4                                bra p3code
  6145                          
  6146                          
  6147  400f 208322             l79_3            jsr chrget
  6148  4012 b09e                                bcs iline_20                             ; old stuff after # is other char
  6149                          
  6150  4014 20ac40             l79_4            jsr move_init                            ; digit...move down
  6151  4017 20c440                              jsr movedown
  6152  401a c382                                dew text_top
  6153  401c 208522                              jsr chrgot
  6154  401f 90f3                                bcc l79_4                                ; still digits...
  6155                          
  6156  4021 808f                                bra iline_20                             ; branch always
  6157                          
  6158                          ; .page
  6159                          ;*************************** FORM_LINE *********************************
  6160                          
  6161                          ; Remaps the destination line if it is greater than n3
  6162                          
  6163                          form_line
  6164  4023 207240                              jsr n1_reset
  6165                          find_it
  6166  4026 20a340                              jsr chargt_x2                            ; new line, skip over link
  6167  4029 d00d                                bne l80_1                                ; if we get to end-of-text without finding the
  6168  402b a227                                ldx #err_ref                             ; line # then 'unresolved reference' error
  6169  402d a54b                                lda forpnt
  6170  402f 853b                                sta curlin                               ; fake error routine into saying 'in line xxxxx'
  6171  4031 a54c                                lda forpnt+1
  6172  4033 853c                                sta curlin+1
  6173  4035 8318ee                              +lbra error
  6174                          
  6175  4038 20a540             l80_1            jsr chargt                               ; get line number low
  6176  403b 855a                                sta highds                               ; highds = current line# in loop
  6177  403d c516                                cmp linnum
  6178  403f d027                                bne l80_4
  6179  4041 20a540                              jsr chargt                               ; get line number high
  6180  4044 855b                                sta highds+1
  6181  4046 c517                                cmp linnum+1
  6182  4048 d023                                bne l80_5
  6183  404a 38                                  sec                                      ; if linnum < start#, no remapping
  6184  404b e55d                                sbc hightr+1
  6185  404d 9008                                bcc l80_2
  6186  404f d00e                                bne l80_3
  6187  4051 a516                                lda linnum
  6188  4053 e55c                                sbc hightr
  6189  4055 b008                                bcs l80_3
  6190                          
  6191  4057 a516               l80_2            lda linnum                               ; use same line#
  6192  4059 8565                                sta facho+1
  6193  405b a517                                lda linnum+1
  6194  405d 8564                                sta facho
  6195                          
  6196  405f a290               l80_3            ldx #$90                                 ; make replacement string
  6197  4061 38                                  sec
  6198  4062 20df62                              jsr floatc
  6199  4065 832824                              +lbra fout
  6200                          
  6201                          
  6202  4068 20a540             l80_4            jsr chargt
  6203  406b 855b                                sta highds+1                             ; (** 01/27/84 fix)
  6204                          
  6205  406d 207f40             l80_5            jsr line_add                             ; scan to end of line
  6206  4070 80b4                                bra find_it                              ; always
  6207                          
  6208                          ; .page
  6209                          ;*************************** N1_RESET **********************************
  6210                          
  6211                          ; Copies n1 (new renumber origin) into facho & sets (txtptr) = (txttab)-1
  6212                          
  6213                          n1_reset
  6214  4072 ad7911                              lda renum_tmp_1
  6215  4075 8565                                sta facho+1
  6216  4077 ad7a11                              lda renum_tmp_1+1
  6217  407a 8564                                sta facho
  6218  407c 83a1f4                              +lbra reset_txtptr
  6219                          
  6220                          
  6221                          ;*************************** LINE_ADD **********************************
  6222                          
  6223                          ; Adds n2 (new line increment) to line number stored in facho if the
  6224                          ; current line number (highds) >= n3 (line to start renumbering with).
  6225                          ; The line is then scanned.
  6226                          
  6227                          line_add
  6228  407f a55a                                lda highds                               ; if line# >= start# then incr new#
  6229  4081 38                                  sec
  6230  4082 e55c                                sbc hightr
  6231  4084 a55b                                lda highds+1
  6232  4086 e55d                                sbc hightr+1
  6233  4088 9003                                bcc scan_thru
  6234                          
  6235                          line_inc
  6236  408a 209340                              jsr new_num
  6237                          
  6238                          scan_thru
  6239  408d 20a540                              jsr chargt                               ; scan to end of line
  6240  4090 d0fb                                bne scan_thru
  6241  4092 60                                  rts
  6242                          
  6243                          
  6244                          ;**************************** NEW_NUM **********************************
  6245                          
  6246                          ; Adds n2 (the new line increment) to the line number stored in facho.
  6247                          
  6248                          new_num
  6249  4093 a565                                lda facho+1                              ; increment new line#
  6250  4095 18                                  clc
  6251  4096 6d7b11                              adc renum_tmp_2
  6252  4099 8565                                sta facho+1
  6253  409b a564                                lda facho
  6254  409d 6d7c11                              adc renum_tmp_2+1
  6255  40a0 8564                                sta facho
  6256  40a2 60                                  rts
  6257                          
  6258                          
  6259                          ;********************** CHARGT & CHARGT_X2 *****************************
  6260                          
  6261                          ; Chargt simulates chrget but doesn't ignore spaces & carry has no
  6262                          ; significance.  Chargt_x2 executes chargt twice.
  6263                          ; Used by Renumber, Find/Change, etc.
  6264                          
  6265                          chargt_x2
  6266  40a3 e33d                                inw txtptr                               ; jsr chargt
  6267                          chargt
  6268  40a5 a000                                ldy #0                                   ; increment txtptr
  6269  40a7 e33d                                inw txtptr
  6270  40a9 831ae2                              +lbra indtxt
  6271                          
  6272                          ; .page
  6273                          ;***********************************************************************
  6274                          ;************************* MEMORY MOVE ROUTINES ************************
  6275                          ;***********************************************************************
  6276                          
  6277                          ;****************************** MOVEINIT *******************************
  6278                          
  6279                          ; Setup for Renumber memory move.
  6280                          
  6281                          move_init
  6282  40ac a53d                                lda txtptr                               ; index1 = txtptr
  6283  40ae 8524                                sta index1
  6284  40b0 a53e                                lda txtptr+1
  6285  40b2 8525                                sta index1+1
  6286                          
  6287  40b4 a582                                lda text_top                             ; index2 = text_top
  6288  40b6 8526                                sta index2
  6289  40b8 a583                                lda text_top+1
  6290  40ba 8527                                sta index2+1
  6291                          
  6292  40bc a901                                lda #1                                   ; move 1 character
  6293  40be 850d                                sta count                                ; lo
  6294  40c0 3a                                  dec
  6295  40c1 856d                                sta argmo                                ; hi
  6296                          
  6297  40c3 60                                  rts
  6298                          
  6299                          ; .page
  6300                          ;****************************** MOVEDOWN *******************************
  6301                          
  6302                          ; Move block of BASIC text from INDEX1+COUNT to INDEX2 down to INDEX1.
  6303                          ; Used by commands Renumber, Find/Change.
  6304                          
  6305                          movedown
  6306  40c4 38                                  sec                                      ; set up DMA list:   [900524]
  6307  40c5 a526                                lda index2
  6308  40c7 e524                                sbc index1
  6309  40c9 8d4501                              sta dma1_cnt_lo                          ; cnt = index2-index1-count
  6310  40cc a527                                lda index2+1
  6311  40ce e525                                sbc index1+1
  6312  40d0 8d4601                              sta dma1_cnt_hi
  6313  40d3 38                                  sec
  6314  40d4 ad4501                              lda dma1_cnt_lo
  6315  40d7 e50d                                sbc count                                ; lo
  6316  40d9 8d4501                              sta dma1_cnt_lo
  6317  40dc ad4601                              lda dma1_cnt_hi
  6318  40df e56d                                sbc argmo                                ; hi
  6319  40e1 8d4601                              sta dma1_cnt_hi
  6320                          
  6321  40e4 18                                  clc
  6322  40e5 a524                                lda index1
  6323  40e7 8d4a01                              sta dma1_dest_lo                         ; dest = index1
  6324  40ea 650d                                adc count
  6325  40ec 8d4701                              sta dma1_src_lo                          ; src = index1+count
  6326  40ef a525                                lda index1+1
  6327  40f1 8d4b01                              sta dma1_dest_hi
  6328  40f4 656d                                adc argmo
  6329  40f6 8d4801                              sta dma1_src_hi
  6330                          
  6331  40f9 a584                                lda text_bank                            ; bank = BASIC text bank
  6332                          ; and #%00001111  ;      [910520] F018A
  6333  40fb 8d4901                              sta dma1_src_bank
  6334  40fe 8d4c01                              sta dma1_dest_bank
  6335                          
  6336                          execute_DMA1                                              ; [910620] Edit
  6337  4101 a900                                lda #0
  6338  4103 8d4401                              sta dma1_cmd                             ; command = copy from startpoint
  6339  4106 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
  6340                          
  6341  4109 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
  6342  410c a901                                lda #>dma1_cmd
  6343  410e 8d01d7                              sta dma_ctlr+1                           ; dma_list hi
  6344  4111 a944                                lda #<dma1_cmd
  6345  4113 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
  6346  4116 60                                  rts
  6347                          
  6348                          ; .page
  6349                          ;******************************* MOVEUP ********************************
  6350                          
  6351                          ; Move block of BASIC text from INDEX1 to INDEX2 up to INDEX2+COUNT.
  6352                          ; Used by commands Renumber, Find/Change.
  6353                          
  6354                          moveup
  6355  4117 38                                  sec                                      ; set up DMA list:   [900524]
  6356  4118 a526                                lda index2
  6357  411a e524                                sbc index1
  6358  411c 8d4501                              sta dma1_cnt_lo                          ; cnt = index2-index1
  6359  411f a527                                lda index2+1
  6360  4121 e525                                sbc index1+1
  6361  4123 8d4601                              sta dma1_cnt_hi
  6362                          
  6363  4126 c326                                dew index2                               ; (index2 = text_top = end+1)
  6364  4128 18                                  clc
  6365  4129 a526                                lda index2
  6366  412b 8d4701                              sta dma1_src_lo                          ; src = index2
  6367  412e 650d                                adc count
  6368  4130 8d4a01                              sta dma1_dest_lo                         ; dest = index2+count
  6369  4133 a527                                lda index2+1
  6370  4135 8d4801                              sta dma1_src_hi
  6371  4138 656d                                adc argmo
  6372  413a 8d4b01                              sta dma1_dest_hi
  6373                          
  6374                          ; lda dma_ctlr+3  ;dma controller version    [910520] F018A
  6375                          ; and #1
  6376                          ; beq l81_1   ; F018    removed [910808] F018B
  6377  413d a930                                lda #%00110000                           ; F018A,B
  6378  413f 8d4401             l81_1            sta dma1_cmd                             ; command=copy, source=start   [910102]
  6379                          ; php
  6380  4142 a584                                lda text_bank                            ; bank = BASIC text bank   [910520] F018A
  6381                          ; plp   ;version?    removed [910808] F018B
  6382                          ; bne l81_2   ; F018A
  6383                          ; and #%00001111  ; F018     [910102]
  6384                          ; ora #%01000000  ;(copy source=endpoint)    [910102]
  6385  4144 8d4901             l81_2            sta dma1_src_bank                        ; banks
  6386  4147 8d4c01                              sta dma1_dest_bank
  6387                          
  6388  414a a900                                lda #0                                   ; [910219]
  6389                          ; sta dma1_cmd  ; command = copy, source=endpoint
  6390  414c 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
  6391                          ; dec a   ;      [910219]
  6392  414f 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
  6393  4152 a001                                ldy #>dma1_cmd                           ; dma_list
  6394  4154 a944                                lda #<dma1_cmd
  6395  4156 8c01d7                              sty dma_ctlr+1                           ; dma_list hi
  6396  4159 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
  6397  415c 60                                  rts
  6398                          
  6399                          ;.end
  6400                          ; .page
  6401                          ; .subttl  FOR
  6402                          ; FOR
  6403                          ;
  6404                          ; Push the following information on the run-time stack:
  6405                          ;
  6406                          ; (bottom)   highest memory
  6407                          ; =========================
  6408                          ;  txtptr    address of next statement
  6409                          ;  txtptr+1
  6410                          ;  ========
  6411                          ;  curlin+1  current line number
  6412                          ;  curlin
  6413                          ;  ========
  6414                          ;  to lo
  6415                          ;  to mo
  6416                          ;  to moh    'to' value
  6417                          ;  to ho
  6418                          ;  to exp
  6419                          ;  ========
  6420                          ;  step sign
  6421                          ;  step lo
  6422                          ;  step mo
  6423                          ;  step moh  'step' value
  6424                          ;  step ho
  6425                          ;  step exp
  6426                          ;  ========
  6427                          ;  forpnt+1  'for' variable pointer
  6428                          ;  forpnt
  6429                          ;  ========
  6430                          ;  'for' token       <== (tos) top of stack pointer
  6431                          ; ============================
  6432                          ; (top of stack)  lowest memory
  6433                          
  6434                          
  6435  415d a980               for              lda #$80
  6436  415f 8512                                sta subflg                               ; no arrays(), no integers%
  6437  4161 207636                              jsr let                                  ; get & set FOR variables
  6438  4164 a981                                lda #for_token                           ; set up for call to see if
  6439  4166 204331                              jsr search                               ; ..this 'for' variable is unique
  6440  4169 f008                                beq l82_1                                ; branch if not
  6441                          
  6442                          ; If the variable is not unique, (fndpnt) will point to last occurance
  6443                          ; in stack, and we will reset the stack to that point.  Otherwise we
  6444                          ; will adjust the pointer by 'lenfor' and start from that point.
  6445                          
  6446  416b a912                                lda #lenfor
  6447  416d 209431                              jsr getstk                               ; updates stack pointer, error if overflow
  6448  4170 20dd31                              jsr movtos                               ; (tos) => (fndpnt)
  6449                          
  6450  4173 20e631             l82_1            jsr movfnd                               ; (fndpnt) => (tos)   (redundant for new entries)
  6451  4176 205b35                              jsr datan                                ; find address of next statement
  6452  4179 98                                  tya                                      ; offset from (txtptr) in y
  6453  417a a011                                ldy #lenfor-1
  6454                          
  6455  417c 18                                  clc                                      ; Push address of next statement on stack
  6456  417d 653d                                adc txtptr
  6457  417f 917c                                sta (tos),y                              ; (common area)
  6458  4181 a53e                                lda txtptr+1
  6459  4183 6900                                adc #0
  6460  4185 88                                  dey
  6461  4186 917c                                sta (tos),y                              ; (common area)
  6462                          
  6463  4188 a53c                                lda curlin+1                             ; Push current line number on stack
  6464  418a 88                                  dey
  6465  418b 917c                                sta (tos),y                              ; (common area)
  6466  418d a53b                                lda curlin
  6467  418f 88                                  dey
  6468  4190 917c                                sta (tos),y                              ; (common area)
  6469                          
  6470  4192 a9a4                                lda #to_token                            ; Look for TO, must appear
  6471  4194 205d4e                              jsr synchr
  6472  4197 20db4c                              jsr chknum                               ; get TO value
  6473  419a 20d84c                              jsr frmnum
  6474  419d a568                                lda facsgn
  6475  419f 097f                                ora #$7f
  6476  41a1 2564                                and facho
  6477  41a3 8564                                sta facho
  6478                          
  6479  41a5 a204                                ldx #4
  6480  41a7 a00d                                ldy #lenfor-5
  6481  41a9 b563               l82_2            lda facexp,x                             ; Push faclo,mo,moh,ho,exp
  6482  41ab 917c                                sta (tos),y                              ; (common area)
  6483  41ad ca                                  dex
  6484  41ae 88                                  dey
  6485  41af 10f8                                bpl l82_2
  6486                          
  6487  41b1 a999                                lda #<fone                               ; Push STEP value
  6488  41b3 a05f                                ldy #>fone                               ; (point to default 'one' in ROM)
  6489  41b5 200e62                              jsr movfm
  6490  41b8 208522                              jsr chrgot
  6491  41bb c9a9                                cmp #step_token
  6492  41bd d006                                bne l82_3                                ; branch if no step given
  6493  41bf 208322                              jsr chrget
  6494  41c2 20d84c                              jsr frmnum
  6495                          
  6496  41c5 20c162             l82_3            jsr sign
  6497  41c8 48                                  pha                                      ; save sign for a moment
  6498  41c9 20b262                              jsr round
  6499  41cc 68                                  pla
  6500                          
  6501  41cd a008                                ldy #lenfor-10
  6502  41cf a205                                ldx #5
  6503  41d1 917c               l82_4            sta (tos),y                              ; (common area)
  6504  41d3 b562                                lda facexp-1,x
  6505  41d5 88                                  dey
  6506  41d6 ca                                  dex
  6507  41d7 10f8                                bpl l82_4
  6508                          
  6509  41d9 a54c                                lda forpnt+1                             ; Finally push pointer to 'for' variable, & 'for' token
  6510  41db 917c                                sta (tos),y                              ; (common area)
  6511  41dd a54b                                lda forpnt
  6512  41df 88                                  dey
  6513  41e0 917c                                sta (tos),y                              ; (common area)
  6514  41e2 a981                                lda #for_token
  6515  41e4 88                                  dey
  6516  41e5 917c                                sta (tos),y                              ; (common area)
  6517  41e7 60                                  rts
  6518                          
  6519                          ;.end
  6520                          ; .page
  6521                          ; .subttl  DELETE
  6522                          
  6523                          ; Delete a range of source   -or-   Delete a disk file
  6524                          ;
  6525                          ; Syntax: DELETE from# - to# (same range parameters as LIST)
  6526                          ;  DELETE "filename" (same parameters as SCRATCH)
  6527                          
  6528                          ; Determine which form of DELETE we have...
  6529                          
  6530  41e8 9007               delete           bcc delete_line                          ; branch if a number (assume range parameter)
  6531  41ea c9ab                                cmp #minus_token
  6532  41ec f003                                beq delete_line                          ; branch if a dash (assume range parameter)
  6533  41ee 83e430                              +lbra scratch                            ; branch if string (assume filename or U#)
  6534                          
  6535                          delete_line
  6536  41f1 20ed58                              jsr errind                               ; direct mode only command
  6537  41f4 208522                              jsr chrgot                               ; requires line# or range, no default
  6538  41f7 f351ec                              +lbeq snerr                              ; error, none given
  6539                          
  6540  41fa 205042                              jsr range                                ; parse range, find starting line, ptr to ending line
  6541  41fd a561                                lda lowtr
  6542  41ff a662                                ldx lowtr+1
  6543  4201 8524                                sta index1                               ; (destination)
  6544  4203 8625                                stx index1+1
  6545                          
  6546  4205 20fa31                              jsr FindLine                             ; find ending line
  6547  4208 9015                                bcc l83_2                                ; branch if not found
  6548  420a a001                                ldy #1
  6549  420c 20ad22                              jsr indlow                               ; if eot, use this ptr.  else, need ptr to next
  6550  420f 88                                  dey
  6551  4210 aa                                  tax                                      ; save it in case of swap
  6552  4211 d005                                bne l83_1                                ; branch if not eot (end-of-text)
  6553  4213 20ad22                              jsr indlow
  6554  4216 f007                                beq l83_2                                ; branch if eot (null link bytes)
  6555                          
  6556  4218 20ad22             l83_1            jsr indlow
  6557  421b 8561                                sta lowtr                                ; (source)
  6558  421d 8662                                stx lowtr+1
  6559                          
  6560  421f a561               l83_2            lda lowtr                                ; check that start <= end
  6561  4221 38                                  sec
  6562  4222 e524                                sbc index1                               ; calculate delta
  6563  4224 850d                                sta count                                ; (count)
  6564  4226 a562                                lda lowtr+1                              ; (does not catch case where
  6565  4228 e525                                sbc index1+1                             ; start>end when end=start+1,
  6566  422a 856d                                sta argmo                                ; but it does no harm)
  6567  422c 050d                                ora count
  6568  422e f00e                                beq fix_links                            ; all done- nothing to move!?
  6569  4230 9318ec                              +lbcc snerr                              ; error- bad range (start > end)
  6570                          
  6571  4233 a582                                lda text_top                             ; setup for common DMA move routine: [900530]
  6572  4235 a683                                ldx text_top+1
  6573  4237 8526                                sta index2                               ; index2 = top
  6574  4239 8627                                stx index2+1                             ; index1 = destination
  6575                          ; count  = delta
  6576                          
  6577  423b 20c440                              jsr movedown                             ; delete the text, then relink & exit
  6578                          
  6579                          
  6580                          
  6581                          fix_links                                                 ; <<<<<<<<<<<<<<<<<<<<<<<<<<< entry from renumber
  6582                          
  6583  423e 20b930                              jsr link_program                         ; relink program
  6584  4241 a524                                lda index1
  6585  4243 a625                                ldx index1+1
  6586  4245 18                                  clc
  6587  4246 6902                                adc #2
  6588  4248 9001                                bcc l84_1
  6589  424a e8                                  inx
  6590  424b 8582               l84_1            sta text_top                             ; set eot pointer
  6591  424d 8683                                stx text_top+1
  6592  424f 60                                  rts                                      ; C128-04 fix: was 'jmp ready' (FAB)
  6593                          
  6594                          ; .page
  6595                          ;********************************
  6596                          ;*
  6597                          ;*    Input Range Parameters
  6598                          ;*
  6599                          ;********************************
  6600                          
  6601  4250 f012               range            beq l85_1                                ; a terminator from chrgot?
  6602  4252 9010                                bcc l85_1                                ; a number?
  6603  4254 c9ab                                cmp #minus_token                         ; a dash?
  6604  4256 d02e                                bne l85_4   ;if it's not a dash, error (C128-03 fix ; FAB)
  6605  4258 a001                                ldy #1
  6606  425a 20c522                              jsr indtxt                               ; let's peek, and see what follows the dash!
  6607  425d f027                                beq l85_4                                ; uh-oh! it's of the form 'delete -' - error
  6608  425f c93a                                cmp #':'                                 ; the other terminator
  6609  4261 f023                                beq l85_4                                ; ..still bad
  6610  4263 38                                  sec                                      ; set up for linget
  6611                          
  6612  4264 202e32             l85_1            jsr linget                               ; get first #
  6613  4267 20fa31                              jsr FindLine                             ; find it & set ptrs
  6614  426a 208522                              jsr chrgot                               ; get last char
  6615  426d f00c                                beq l85_2                                ; skip done
  6616  426f c9ab                                cmp #minus_token                         ; a dash?
  6617  4271 d013                                bne l85_4                                ; no- syntax error
  6618  4273 208322                              jsr chrget                               ; yes- skip dash
  6619  4276 202e32                              jsr linget                               ; get second #
  6620  4279 d00b                                bne l85_4                                ; error- wasn't a number
  6621                          
  6622  427b a50b               l85_2            lda endchr                               ; was a # input?
  6623  427d d006                                bne l85_3                                ; yes
  6624  427f a9ff                                lda #$ff                                 ; no - make max
  6625  4281 8516                                sta linnum
  6626  4283 8517                                sta linnum+1
  6627  4285 60                 l85_3            rts
  6628                          
  6629                          
  6630  4286 83c2eb             l85_4            +lbra snerr                              ; syntax error
  6631                          
  6632                          ;.end
  6633                          ; .page
  6634                          ; .subttl  FIND  CHANGE
  6635                          
  6636                          ; FIND   "string"                    [,line_range]
  6637                          ; CHANGE "oldstring" TO "newstring"  [,line_range]
  6638                          ;
  6639                          ; where <"> delimiter can be any character, but only
  6640                          ; double-quotes will prevent tokenization of strings.
  6641                          ;
  6642                          ; N.B.: I am assuming that lines cannot be greater than 255 chars, as is
  6643                          ; the case where the line was entered "normally", that is, using LINGET.
  6644                          
  6645                          find
  6646  4289 7787                                rmb7 op                                  ; FIND flag
  6647  428b 2c                                  !text $2c
  6648                          
  6649                          change
  6650  428c f787                                smb7 op                                  ; CHANGE flag
  6651  428e 6787                                rmb6 op                                  ; reset change-all mode
  6652  4290 20ed58                              jsr errind                               ; report error if not in direct mode
  6653                          
  6654  4293 208522                              jsr chrgot                               ; get delimeter
  6655  4296 a200                                ldx #0                                   ; evaluate string args
  6656  4298 202644                              jsr delimit_string                       ; string1
  6657  429b a58a                                lda fstr1+2
  6658  429d f35f0f                              +lbeq fcerr                              ; error if string1 null
  6659  42a0 7f8713                              bbr7 op,l86_1                            ; branch if no string2
  6660  42a3 208322                              jsr chrget                               ; pick up required 'to' token
  6661  42a6 c9a4                                cmp #to_token
  6662  42a8 d3a0eb                              +lbne snerr                              ; error if missing
  6663  42ab 208322                              jsr chrget
  6664  42ae f39aeb                              +lbeq snerr                              ; error if eol
  6665  42b1 a203                                ldx #3
  6666  42b3 202644                              jsr delimit_string                       ; string2
  6667                          
  6668  42b6 208322             l86_1            jsr chrget                               ; line number range given?
  6669  42b9 f003                                beq l86_2                                ; no, eol
  6670  42bb 205b4e                              jsr chkcom                               ; yes, pick up required comma
  6671  42be 205042             l86_2            jsr range                                ; set up line number range (lowtr,linnum)
  6672  42c1 20472c                              jsr tto                                  ; save txtptr for restoration when done
  6673  42c4 7755                                rmb7 helper                              ; clear 'help' flag for 'p1line'
  6674  42c6 a555                                lda helper
  6675  42c8 48                                  pha
  6676  42c9 4755                                rmb4 helper                              ; temporarily disable token highlighting
  6677  42cb d755                                smb5 helper                              ; set   'find' flag for 'p1line'
  6678  42cd 800e                                bra find_loop_1                          ; begin
  6679                          
  6680                          ; .page
  6681                          find_loop
  6682  42cf a000                                ldy #0                                   ; move to next line (copy link bytes to lowtr)
  6683  42d1 20ad22                              jsr indlow
  6684  42d4 aa                                  tax
  6685  42d5 c8                                  iny
  6686  42d6 20ad22                              jsr indlow
  6687  42d9 8661                                stx lowtr
  6688  42db 8562                                sta lowtr+1
  6689                          
  6690                          find_loop_1
  6691  42dd a001                                ldy #1
  6692  42df 20ad22                              jsr indlow                               ; check link
  6693  42e2 d007                                bne l87_1                                ; not null- continue
  6694  42e4 88                                  dey
  6695  42e5 20ad22                              jsr indlow
  6696  42e8 f31e01                              +lbeq find_exit                          ; null- exit
  6697                          
  6698  42eb a002               l87_1            ldy #2
  6699  42ed 20ad22                              jsr indlow                               ; check line number
  6700  42f0 aa                                  tax
  6701  42f1 c8                                  iny
  6702  42f2 20ad22                              jsr indlow
  6703  42f5 c517                                cmp linnum+1
  6704  42f7 d004                                bne l87_2
  6705  42f9 e416                                cpx linnum
  6706  42fb f003                                beq l87_3                                ; line is <= last line requested, continue
  6707  42fd b30901             l87_2            +lbcs find_exit                          ; line is >  last line requested, exit
  6708                          
  6709  4300 a203               l87_3            ldx #3                                   ; set initial position - 1 (past link & line#)
  6710  4302 863f                                stx fndpnt
  6711                          
  6712                          ; .page
  6713                          find_loop_2
  6714  4304 20e1ff                              jsr _stop                                ; check stop key
  6715  4307 f31101                              +lbeq find_break                         ; exit if down
  6716                          
  6717  430a a63f                                ldx fndpnt                               ; duh, where are we?
  6718  430c 18                                  clc
  6719  430d 8a                                  txa                                      ; program:
  6720  430e 6561                                adc lowtr                                ; txtptr = line start + position in line
  6721  4310 853d                                sta txtptr
  6722  4312 a900                                lda #0
  6723  4314 6562                                adc lowtr+1
  6724  4316 853e                                sta txtptr+1                             ; search string:
  6725  4318 a300                                ldz #0                                   ; at the beginning
  6726                          
  6727  431a 20a540             l88_1            jsr chargt                               ; get next character from text
  6728  431d f0b0                                beq find_loop                            ; eol (no match this line)
  6729  431f e8                                  inx                                      ; bump pointer to next character
  6730  4320 d288                                cmp (fstr1),z                            ; character match?  ind okay- buffer
  6731  4322 d0f6                                bne l88_1                                ; no
  6732  4324 863f                                stx fndpnt                               ; yes- save next position
  6733                          
  6734  4326 1b                 l88_2            inz                                      ; bump position in search string
  6735  4327 d48a                                cpz fstr1+2                              ; string match?
  6736  4329 b00b                                bcs print_line                           ; yes
  6737  432b 20a540                              jsr chargt
  6738  432e f09f                                beq find_loop                            ; no- eol
  6739  4330 d288                                cmp (fstr1),z                            ; ind okay- buffer
  6740  4332 d0d0                                bne find_loop_2                          ; no- rewind to beginning of search string
  6741  4334 f0f0                                beq l88_2                                ; maybe- still more chars to compare
  6742                          
  6743                          
  6744                          ; Print the line of text at LOWTR, highlighting the section of code
  6745                          ; beginning at LOWTR+FNDPNT and running for FIND_COUNT characters.
  6746                          
  6747                          print_line
  6748  4336 20f737                              jsr crdo                                 ; get a new display line
  6749  4339 a58a                                lda fstr1+2                              ; length of string to highlight
  6750  433b 8dda02                              sta find_count
  6751  433e a002                                ldy #2
  6752  4340 20ad22                              jsr indlow                               ; get ms byte of line number
  6753  4343 aa                                  tax
  6754  4344 c8                                  iny
  6755  4345 20ad22                              jsr indlow                               ; get ls byte
  6756  4348 207733                              jsr p1line                               ; print #, space, and the line of code
  6757  434b 7f87b6                              bbr7 op,find_loop_2                      ; Find op? branch if so and continue search
  6758                          
  6759                          ; .page
  6760                          ; Change operation
  6761                          ; Query the user and replace string1 with string2 if he wants to.
  6762                          ; Options are  'Y' (yes),  '*' (do all),  'CR' (quit),  anything else means no.
  6763                          
  6764                          change_line
  6765  434e ef8720                              bbs6 op,l89_1                            ; branch if change-all mode set
  6766  4351 207dff                              jsr _primm                               ; prompt & get response
  6767  4354 0d204348414e4745...                 !text cr," CHANGE? ",0
  6768  435f 20d878                              jsr response_get
  6769  4362 c959                                cmp #'Y'
  6770  4364 f00b                                beq l89_1                                ; yes, change it
  6771  4366 c90d                                cmp #cr
  6772  4368 f39e00                              +lbeq find_exit                          ; cr only, abort entire operation
  6773  436b c92a                                cmp #'*'
  6774  436d d095                                bne find_loop_2                          ; *, change all.  else don't change
  6775  436f e787                                smb6 op
  6776                          
  6777                          ; Replace string1 with string2.  Requires moving text up/down beginning at
  6778                          ; LOWTR+FNDPNT+(LEN(string1)-LEN(string2)) through TEXT_TOP and copying
  6779                          ; string1 into text beginning at LOWTR+FNDPNT for LEN(string2) characters.
  6780                          
  6781  4371 a582               l89_1            lda text_top                             ; setup upper address of text to move (index2)
  6782  4373 8526                                sta index2
  6783  4375 a583                                lda text_top+1                           ; TEXT_TOP
  6784  4377 8527                                sta index2+1
  6785                          
  6786  4379 18                                  clc                                      ; setup lower address of text to move (index1)
  6787  437a a53f                                lda fndpnt
  6788  437c 6561                                adc lowtr
  6789  437e 8524                                sta index1                               ; LOWTR+FNDPNT
  6790  4380 a900                                lda #0
  6791  4382 856d                                sta argmo                                ; count hi
  6792  4384 6562                                adc lowtr+1
  6793  4386 8525                                sta index1+1
  6794                          
  6795  4388 38                                  sec                                      ; calc number of chars to insert/delete
  6796  4389 a58a                                lda fstr1+2                              ; LEN(string1)-LEN(string2)
  6797  438b e58d                                sbc fstr2+2
  6798  438d f052                                beq l89_6                                ; branch if string1 = string2 (no move)
  6799  438f 103d                                bpl l89_4                                ; branch if string1 > string2 (delete)
  6800                          ; else      string1 < string2 (insert)
  6801                          
  6802  4391 42                                  neg                                      ; Move memory up to make room for larger string2
  6803  4392 850d                                sta count
  6804  4394 a000                                ldy #0                                   ; first check for line too long
  6805  4396 20ad22                              jsr indlow
  6806  4399 650d                                adc count
  6807  439b 4b                                  taz
  6808  439c c8                                  iny
  6809  439d 20ad22                              jsr indlow                               ; (link+#chr)-line_sa must be <256
  6810  43a0 6900                                adc #0
  6811  43a2 a8                                  tay
  6812  43a3 38                                  sec
  6813  43a4 6b                                  tza
  6814  43a5 e561                                sbc lowtr
  6815  43a7 98                                  tya
  6816  43a8 e562                                sbc lowtr+1
  6817  43aa d3c432                              +lbne errlen                             ; error, line > 255 characters
  6818                          
  6819  43ad 18                                  clc                                      ; now check for sufficient memory
  6820  43ae a483                                ldy text_top+1
  6821  43b0 a50d                                lda count
  6822  43b2 6582                                adc text_top
  6823  43b4 9001                                bcc l89_2
  6824  43b6 c8                                  iny
  6825  43b7 ccd002             l89_2            cpy max_mem_0+1
  6826  43ba 9009                                bcc l89_3                                ; result is less than top-of-memory: ok
  6827  43bc d383ea                              +lbne omerr                              ; msb >  top, overflow
  6828  43bf cdcf02                              cmp max_mem_0                            ; msb's the same, test lsb's
  6829  43c2 b37dea                              +lbcs omerr                              ; lsb >= top, overflow
  6830  43c5 8582               l89_3            sta text_top
  6831  43c7 8483                                sty text_top+1                           ; set new top of text pointer
  6832  43c9 201741                              jsr moveup                               ; make room
  6833  43cc 8013                                bra l89_6                                ; go copy string2 into area
  6834                          
  6835  43ce 850d               l89_4            sta count                                ; Move memory down for smaller string2
  6836  43d0 a483                                ldy text_top+1
  6837  43d2 a582                                lda text_top
  6838  43d4 38                                  sec
  6839  43d5 e50d                                sbc count
  6840  43d7 b001                                bcs l89_5
  6841  43d9 88                                  dey
  6842  43da 8582               l89_5            sta text_top
  6843  43dc 8483                                sty text_top+1                           ; set new top of text pointer
  6844  43de 20c440                              jsr movedown                             ; squish out excess space
  6845                          
  6846  43e1 a58d               l89_6            lda fstr2+2                              ; Copy string2 into text
  6847  43e3 f015                                beq l89_8                                ; branch if null, nothing to copy
  6848  43e5 8dda02                              sta find_count                           ; how many characters to copy
  6849  43e8 a261                                ldx #lowtr
  6850  43ea a43f                                ldy fndpnt                               ; index into text
  6851  43ec a300                                ldz #0                                   ; index into string2
  6852  43ee b28b               l89_7            lda (fstr2),z                            ; ind okay- buffer
  6853  43f0 200c23                              jsr sta_far_ram0                         ; do the copy
  6854  43f3 c8                                  iny
  6855  43f4 1b                                  inz
  6856  43f5 ceda02                              dec find_count
  6857  43f8 d0f4                                bne l89_7
  6858                          
  6859  43fa 20b930             l89_8            jsr link_program                         ; relink program
  6860  43fd 18                                  clc
  6861  43fe a53f                                lda fndpnt                               ; place find position after new text
  6862  4400 658d                                adc fstr2+2
  6863  4402 3a                                  dec
  6864  4403 853f                                sta fndpnt
  6865  4405 83fdfe                              +lbra find_loop_2                        ; and resume searching
  6866                          
  6867                          ; .page
  6868                          find_exit
  6869  4408 20f737                              jsr crdo                                 ; normal exit
  6870  440b 68                                  pla
  6871  440c 8555                                sta helper                               ; restore token highlight status
  6872  440e 5755                                rmb5 helper                              ; remove 'find' flag
  6873  4410 830efb                              +lbra direct_mode_exit                   ; done
  6874                          
  6875                          
  6876                          
  6877                          find_omerr                                                ; out of memory
  6878  4413 a210                                ldx #errom
  6879  4415 2c                                  !text $2c
  6880                          find_errlen                                               ; string too long
  6881  4416 a217                                ldx #errls
  6882  4418 38                                  sec
  6883  4419 89                                  !text $89
  6884                          find_break                                                ; stop key break
  6885  441a 18                                  clc
  6886  441b 68                                  pla
  6887  441c 8555                                sta helper                               ; restore token highlight status
  6888  441e 5755                                rmb5 helper                              ; remove 'find' flag
  6889  4420 93afe8                              +lbcc break_exit                         ; [910925]
  6890  4423 832aea                              +lbra error
  6891                          
  6892                          
  6893                          delimit_string                                            ; command is in buffer, .x = ptr to strptr
  6894  4426 8564                                sta match                                ; delimiter character
  6895  4428 a53d                                lda txtptr                               ; point to first character in string
  6896  442a 1a                                  inc                                      ; (never wraps- string in input buffer)
  6897  442b 9588                                sta fstr1,x                              ; set pointer to string data
  6898  442d a53e                                lda txtptr+1
  6899  442f 9589                                sta fstr1+1,x
  6900  4431 a9ff                                lda #$ff                                 ; set string length
  6901  4433 958a                                sta fstr1+2,x
  6902                          
  6903  4435 f68a               l90_1            inc fstr1+2,x
  6904  4437 20a540                              jsr chargt                               ; build string
  6905  443a f30eea                              +lbeq snerr                              ; error if eol encountered inside string
  6906  443d c564                                cmp match
  6907  443f d0f4                                bne l90_1                                ; continue until matching delimiter found
  6908  4441 60                                  rts
  6909                          
  6910                          ;.end
  6911                          ; .page
  6912                          ; .subttl  PUDEF
  6913                          
  6914  4442 20675b             puctrl           jsr frmstr                               ; do frmevl,frestr. return with a=len, index=~string
  6915  4445 a8                                  tay
  6916  4446 88                                  dey
  6917  4447 c004                                cpy #4
  6918  4449 b3b30d                              +lbcs fcerr                              ; len > 4 is illegal value error
  6919                          
  6920  444c 20d522             l91_1            jsr indin1_ram1                          ; lda (index),y
  6921  444f 99d411                              sta puchrs,y
  6922  4452 88                                  dey
  6923  4453 10f7                                bpl l91_1
  6924  4455 60                                  rts
  6925                          
  6926                          ;.end
  6927                          ; .page
  6928                          ; .subttl  TRAP
  6929                          
  6930                          trap
  6931                          ; jsr errdir ;why not????      [910925]
  6932  4456 208522                              jsr chrgot                               ; if no #, means 'turn off trap'
  6933  4459 f007                                beq l92_1
  6934  445b 208a5d                              jsr getwrd
  6935  445e 8cca02                              sty trapno
  6936  4461 2c                                  !text $2c
  6937                          
  6938  4462 a9ff               l92_1            lda #$ff                                 ; flag no trap
  6939  4464 8dcb02                              sta trapno+1
  6940  4467 60                                  rts
  6941                          
  6942                          ;.end
  6943                          
  6944                          ; .page
  6945                          ; .subttl  RESUME
  6946                          
  6947                          ; RESUME command
  6948                          ;
  6949                          ; Used to resume execution following a TRAPped error.
  6950                          ;
  6951                          ; Syntax: RESUME [line_number | NEXT]
  6952                          ;
  6953                          ; Can take the following forms:
  6954                          ;
  6955                          ; RESUME   :resume executing at the statement which caused
  6956                          ;     the error.
  6957                          ; RESUME NEXT  :resume execution at the statement FOLLOWING
  6958                          ;     the statement which caused the error.
  6959                          ; RESUME line_number :resume at the specified line number.
  6960                          
  6961                          
  6962  4468 20e258             resume           jsr errdir                               ; no direct mode
  6963  446b aec902                              ldx errlin+1                             ; is there an error to resume from?
  6964  446e e8                                  inx
  6965  446f f077                                beq rescnt                               ; can't resume!
  6966  4471 208522                              jsr chrgot                               ; look for arguments
  6967  4474 f046                                beq resswp                               ; no arg's...restart err'd line
  6968  4476 9039                                bcc l93_3                                ; numeric argument
  6969  4478 c982                                cmp #next_token                          ; only other choice is 'next'
  6970  447a d3cee9                              +lbne snerr                              ; if not, syntax error
  6971                          
  6972  447d 20bc44                              jsr resswp                               ; resume execution with next stm't
  6973  4480 a000                                ldy #0
  6974  4482 20c522                              jsr indtxt
  6975  4485 d024                                bne l93_2                                ; must be a ':'
  6976  4487 c8                                  iny                                      ; must be a null,get next line
  6977  4488 20c522                              jsr indtxt                               ; make sure its not end-of-text
  6978  448b d007                                bne l93_1
  6979  448d c8                                  iny
  6980  448e 20c522                              jsr indtxt
  6981  4491 f3bae9                              +lbeq ready                              ; 2 nulls, eot. bye!
  6982                          
  6983  4494 a003               l93_1            ldy #3                                   ; new line, update pointers
  6984  4496 20c522                              jsr indtxt
  6985  4499 853b                                sta curlin
  6986  449b c8                                  iny
  6987  449c 20c522                              jsr indtxt
  6988  449f 853c                                sta curlin+1
  6989  44a1 98                                  tya
  6990  44a2 18                                  clc
  6991  44a3 653d                                adc txtptr
  6992  44a5 853d                                sta txtptr
  6993  44a7 9002                                bcc l93_2
  6994  44a9 e63e                                inc txtptr+1
  6995  44ab 208322             l93_2            jsr chrget                               ; skip over this character, into body of statement
  6996  44ae 8398f0                              +lbra data                               ; advance until null or ':', then rts
  6997                          
  6998                          
  6999  44b1 208a5d             l93_3            jsr getwrd                               ; resnum. numeric argument
  7000  44b4 8517                                sta linnum+1
  7001  44b6 20d644                              jsr resend
  7002  44b9 8364f8                              +lbra luk4it
  7003                          
  7004                          
  7005  44bc adcd02             resswp           lda errtxt                               ; backup one so chrget will work
  7006  44bf d003                                bne l94_1
  7007  44c1 cece02                              dec errtxt+1
  7008  44c4 cecd02             l94_1            dec errtxt
  7009                          
  7010  44c7 a201                                ldx #1
  7011  44c9 bdc802             l94_2            lda errlin,x                             ; restore line#
  7012  44cc 953b                                sta curlin,x
  7013  44ce bdcd02                              lda errtxt,x                             ; restore text pointer to statement
  7014  44d1 953d                                sta txtptr,x
  7015  44d3 ca                                  dex
  7016  44d4 10f3                                bpl l94_2
  7017                          
  7018                          
  7019  44d6 aecc02             resend           ldx tmptrp                               ; restore trap line to allow traps again
  7020  44d9 8ecb02                              stx trapno+1
  7021                          error_clear
  7022  44dc a2ff                                ldx #$ff
  7023  44de 8ec702                              stx errnum                               ; reset error status- he's saying he's fixed it
  7024  44e1 8ec802                              stx errlin
  7025  44e4 8ec902                              stx errlin+1                             ; flag 'no further resumes until next error'
  7026  44e7 60                                  rts
  7027                          
  7028                          
  7029  44e8 a21f               rescnt           ldx #errcr
  7030  44ea 8363e9                              +lbra error
  7031                          
  7032                          ;.end
  7033                          ; .page
  7034                          ; .subttl  DO  LOOP  UNTIL  WHILE  EXIT
  7035                          
  7036  44ed a001               do               ldy #1
  7037  44ef b93d00             l95_1            lda txtptr,y                             ; save current pointers for stack entry
  7038  44f2 997911                              sta tmptxt,y
  7039  44f5 b93b00                              lda curlin,y
  7040  44f8 997b11                              sta tmplin,y
  7041  44fb 88                                  dey
  7042  44fc 10f1                                bpl l95_1
  7043                          
  7044  44fe 208522                              jsr chrgot                               ; look for 'while' or 'until'
  7045  4501 f01b                                beq doyes                                ; unconditional
  7046  4503 c9fc                                cmp #until_token
  7047  4505 f010                                beq do10
  7048  4507 c9fd                                cmp #while_token
  7049  4509 d03f                                bne snrjmp
  7050                          
  7051                          
  7052                          ;  Here for WHILE
  7053                          
  7054  450b 20cf45                              jsr frmjmp
  7055  450e a563                                lda facexp
  7056  4510 d00c                                bne doyes                                ; conditional evaluated true
  7057                          
  7058  4512 208522             dono             jsr chrgot
  7059  4515 8039                                bra fnd010                               ; advance to end of block, do rts
  7060                          
  7061                          
  7062                          ;  Here for UNTIL
  7063                          
  7064  4517 20cf45             do10             jsr frmjmp
  7065  451a a563                                lda facexp
  7066  451c d0f4                                bne dono
  7067                          
  7068  451e a905               doyes            lda #5                                   ; 'do' needs 5 bytes on the run-time stack
  7069  4520 209431                              jsr getstk
  7070  4523 a004                                ldy #4                                   ; ..now stuff those 5 bytes!
  7071  4525 ad7a11                              lda tmptxt+1
  7072  4528 917c                                sta (tos),y                              ; (common area)
  7073  452a 88                                  dey
  7074  452b ad7911                              lda tmptxt
  7075  452e 917c                                sta (tos),y                              ; (common area)
  7076  4530 88                                  dey
  7077  4531 ad7c11                              lda tmplin+1
  7078  4534 917c                                sta (tos),y                              ; (common area)
  7079  4536 88                                  dey
  7080  4537 ad7b11                              lda tmplin
  7081  453a 917c                                sta (tos),y                              ; (common area)
  7082  453c 88                                  dey
  7083  453d a9eb                                lda #do_token
  7084  453f 917c                                sta (tos),y                              ; (common area)
  7085  4541 60                                  rts
  7086                          
  7087                          
  7088                          ;  Here for EXIT
  7089                          
  7090  4542 20a045             exit             jsr popdgo                               ; pop do entry off stack
  7091  4545 208522                              jsr chrgot
  7092  4548 f006                                beq fnd010
  7093  454a 83fee8             snrjmp           +lbra snerr
  7094                          
  7095                          
  7096                          
  7097                          ;  Find end of current block
  7098                          
  7099  454d 208322             fndend           jsr chrget
  7100                          
  7101  4550 f017               fnd010           beq l96_2                                ; end of statement
  7102  4552 c9ec                                cmp #loop_token
  7103  4554 f3f2ef                              +lbeq data                               ; a hit!  read to end of statement, rts
  7104  4557 c922                                cmp #'"'                                 ; quote
  7105  4559 f009                                beq l96_1
  7106  455b c9eb                                cmp #do_token
  7107  455d d0ee                                bne fndend                               ; keep looking
  7108  455f 204d45                              jsr fndend                               ; recursivly
  7109  4562 80ae                                bra dono                                 ; do a chrgot, go to fnd010
  7110                          
  7111                          
  7112  4564 203236             l96_1            jsr un_quote                             ; look for terminating quote, or end of statement
  7113  4567 d0e4                                bne fndend                               ; character after quote wasn't terminator, keep going
  7114                          
  7115  4569 c93a               l96_2            cmp #':'                                 ; end of line or end of stmt?
  7116  456b f0e0                                beq fndend                               ; just stmt, keep going
  7117  456d 7f7e3f                              bbr7 runmod,fnderr                       ; if direct mode, not found error
  7118  4570 a002                                ldy #2
  7119  4572 20c522                              jsr indtxt                               ; end of text?
  7120  4575 f038                                beq fnderr                               ; 'fraid so
  7121  4577 c8                                  iny                                      ; y=3
  7122  4578 20c522                              jsr indtxt                               ; update pointers
  7123  457b 853b                                sta curlin
  7124  457d c8                                  iny
  7125  457e 20c522                              jsr indtxt
  7126  4581 853c                                sta curlin+1
  7127  4583 98                                  tya
  7128  4584 18                                  clc
  7129  4585 653d                                adc txtptr
  7130  4587 853d                                sta txtptr
  7131  4589 90c2                                bcc fndend
  7132  458b e63e                                inc txtptr+1
  7133  458d 80be                                bra fndend
  7134                          
  7135                          ; .page
  7136  458f f035               loop             beq popngo                               ; no conditionals, just do it
  7137  4591 c9fd                                cmp #while_token
  7138  4593 f02c                                beq loop10
  7139  4595 c9fc                                cmp #until_token
  7140  4597 d0b1                                bne snrjmp
  7141                          
  7142                          ;  Here for UNTIL
  7143                          
  7144  4599 20cf45                              jsr frmjmp
  7145  459c a563                                lda facexp
  7146  459e f026                                beq popngo                               ; false, do it again!
  7147                          
  7148  45a0 a9eb               popdgo           lda #do_token                            ; pop, but don't go
  7149  45a2 204331                              jsr search
  7150  45a5 d015                                bne poperr                               ; branch if not found
  7151  45a7 20e631                              jsr movfnd
  7152  45aa a005                                ldy #5
  7153  45ac 8341ec                              +lbra rlsstk
  7154                          
  7155                          
  7156                          fnderr
  7157  45af ad7b11                              lda tmplin                               ; loop not found error: must make curlin match oldtxt
  7158  45b2 ae7c11                              ldx tmplin+1
  7159  45b5 853b                                sta curlin
  7160  45b7 863c                                stx curlin+1
  7161                          
  7162  45b9 a220                                ldx #errlnf
  7163  45bb 2c                                  !text $2c
  7164                          poperr
  7165  45bc a221                                ldx #errlwd                              ; loop without do
  7166  45be 838fe8                              +lbra error
  7167                          
  7168                          
  7169                          
  7170                          ;  Here for WHILE
  7171                          
  7172                          loop10
  7173  45c1 20cf45                              jsr frmjmp
  7174  45c4 f0da                                beq popdgo                               ; false, exit
  7175                          popngo
  7176  45c6 63d8ff                              bsr popdgo
  7177                          ; dey
  7178                          ; lda (fndpnt),y ;restore pointers
  7179                          ; sta txtptr+1
  7180                          ; dey
  7181                          ; lda (fndpnt),y
  7182                          ; sta txtptr
  7183                          ; dey
  7184                          ; lda (fndpnt),y
  7185  45c9 204279                              jsr retpat                               ; (** 01/18/84 fixes 'loop' to a direct mode 'do')
  7186                          ; lda (fndpnt),y
  7187                          ; sta curlin
  7188  45cc 831fff                              +lbra do
  7189                          
  7190                          frmjmp
  7191  45cf 208322                              jsr chrget
  7192  45d2 831b07                              +lbra frmevl
  7193                          
  7194                          ;.end
  7195                          ; .page
  7196                          ; .subttl  KEY
  7197                          
  7198                          ;**************************************************************
  7199                          ;
  7200                          ;   KEY  Programmable Key Functions    [900725]
  7201                          ;
  7202                          ;**************************************************************
  7203                          
  7204  45d5 f033               key              beq Key_List                             ; KEY ? yes- no args
  7205                          
  7206  45d7 a6d1               l97_1            ldx _kyndx                               ; is function key buffered?
  7207  45d9 d0fc                                bne l97_1                                ; yes- hang until IRQ finishes processing it ????
  7208                          
  7209  45db c991                                cmp #on_token                            ; KEY ON ?
  7210  45dd d004                                bne l97_2
  7211  45df 57f7                                rmb5 _locks                              ; yes- reset Editor's lock bit
  7212  45e1 8024                                bra l97_4                                ; exit
  7213                          
  7214  45e3 c993               l97_2            cmp #load_token                          ; KEY LOAD <filename>[,D#,U#]
  7215  45e5 f3d500                              +lbeq Key_load
  7216                          
  7217  45e8 c994                                cmp #save_token                          ; KEY SAVE <filename>[,D#,U#]
  7218  45ea f33001                              +lbeq Key_Save
  7219                          
  7220  45ed c98c                                cmp #restore_token                       ; KEY RESTORE ?      [910925]
  7221  45ef d007                                bne l97_3                                ; no
  7222  45f1 57f7                                rmb5 _locks                              ; yes- reset Editor's lock bit (enable keys)
  7223  45f3 20b546                              jsr key_restore                          ; init key definitions
  7224  45f6 800f                                bra l97_4                                ; exit
  7225                          
  7226  45f8 c9fe               l97_3            cmp #esc_command_token                   ; KEY OFF ?
  7227  45fa d39f00                              +lbne Key_Change                         ; no- must be new key definition
  7228  45fd 208322                              jsr chrget
  7229  4600 c924                                cmp #off_token
  7230  4602 d346e8                              +lbne snerr                              ; no- bad syntax
  7231  4605 d7f7                                smb5 _locks                              ; yes- set Editor's lock bit
  7232  4607 837adc             l97_4            +lbra chrget                             ; exit
  7233                          
  7234                          ; .page
  7235                          ;**************************************************************
  7236                          ;
  7237                          ;   Key_List  List all function key definitions
  7238                          ;
  7239                          ;**************************************************************
  7240                          
  7241                          Key_List
  7242  460a a200                                ldx #0                                   ; display all key definitions
  7243  460c a000                                ldy #0
  7244                          
  7245  460e e8                 lstky1           inx                                      ; get key number = 1-16
  7246  460f bdff0f                              lda _pky_lengths-1,x                     ; get key size
  7247  4612 f05a                                beq lstest                               ; skip if key not defined
  7248  4614 8577                                sta keysiz                               ; save size
  7249  4616 8676                                stx z_p_temp_1                           ; save key number
  7250                          
  7251  4618 5a                                  phy
  7252  4619 a203                                ldx #3
  7253  461b bd8c46             l98_1            lda preamb,x                             ; print key preamble:
  7254  461e 20d2ff                              jsr _bsout
  7255  4621 ca                                  dex                                      ; 'KEY '
  7256  4622 10f7                                bpl l98_1
  7257  4624 a676                                ldx z_p_temp_1                           ; key number
  7258  4626 a900                                lda #0
  7259  4628 207f64                              jsr linprt
  7260  462b a92c                                lda #','
  7261  462d 20d2ff                              jsr _bsout                               ; comma
  7262                          
  7263  4630 7a                                  ply
  7264  4631 a207                                ldx #7                                   ; (length of 'keydat' string)
  7265  4633 b91010             lsloop           lda _pky_buffer,y                        ; print key definition
  7266  4636 c8                                  iny
  7267  4637 48                                  pha                                      ; save character
  7268  4638 da                                  phx                                      ; save position in output string
  7269                          
  7270  4639 a204                                ldx #4                                   ; check for special (non-printable) characters
  7271  463b dd9646             l99_1            cmp keychr-1,x
  7272  463e f033                                beq list_special                         ; yes, display it as 'CHR$(...)'
  7273  4640 ca                                  dex
  7274  4641 d0f8                                bne l99_1
  7275                          
  7276  4643 fa                                  plx                                      ; restore position
  7277  4644 e008                                cpx #8
  7278  4646 9007                                bcc l99_2                                ; 1st time thru- display leading quote
  7279  4648 d00a                                bne l99_3                                ; previous was a character- no additions needed
  7280  464a a92b                                lda #'+'                                 ; add since previous was quote or return
  7281  464c 20d2ff                              jsr _bsout
  7282  464f a922               l99_2            lda #'"'
  7283  4651 20d2ff                              jsr _bsout                               ; add leading quote
  7284  4654 68                 l99_3            pla                                      ; restore character
  7285  4655 20d2ff                              jsr _bsout                               ; display it
  7286  4658 a209                                ldx #9                                   ; mark normal character
  7287                          
  7288  465a c677               lstnd            dec keysiz
  7289  465c d0d5                                bne lsloop                               ; loop to end of definition
  7290  465e e009                                cpx #9
  7291  4660 9005                                bcc l100_1                               ; skip if previous not normal character
  7292  4662 a922                                lda #'"'
  7293  4664 20d2ff                              jsr _bsout                               ; add ending quote
  7294                          
  7295  4667 a98d               l100_1           lda #$8d
  7296  4669 20d2ff                              jsr _bsout                               ; add ending return (shifted)
  7297                          
  7298  466c a676                                ldx z_p_temp_1                           ; key number
  7299  466e e010               lstest           cpx #number_fkeys
  7300  4670 d09c                                bne lstky1                               ; ...loop until done all keys
  7301  4672 60                                  rts
  7302                          
  7303                          
  7304                          list_special
  7305  4673 fa                                  plx                                      ; restore .x
  7306  4674 bd8d46             l101_1           lda keydat-3,x                           ; display something like  ' "+CHR$( '
  7307  4677 20d2ff                              jsr _bsout
  7308  467a ca                                  dex
  7309  467b e003                                cpx #3
  7310  467d b0f5                                bcs l101_1
  7311  467f 68                                  pla                                      ; restore character
  7312  4680 203779                              jsr prtdec                               ; display decimal value of chr in .a
  7313  4683 a929                                lda #')'                                 ; finish off with closing paren.
  7314  4685 20d2ff                              jsr _bsout
  7315  4688 a208                                ldx #8                                   ; mark end of special
  7316  468a 80ce                                bra lstnd                                ; ..always
  7317                          
  7318                          
  7319  468c 2059454b           preamb           !text " YEK"                             ; key preamble
  7320                          
  7321  4690 28245248432b22     keydat           !text "($RHC+",$22                       ; chr$( string
  7322                          
  7323  4697 0d8d221b           keychr           !text cr,$8d,$22,esc                     ; special KEY chars- return, sft-return, quote, esc
  7324                          
  7325                          ; .page
  7326                          ;************************************************************************
  7327                          ;
  7328                          ;   Key_Change  Add, Delete or Change function key definition
  7329                          ;
  7330                          ;************************************************************************
  7331                          
  7332                          Key_Change
  7333  469b 206c5d                              jsr getbyt                               ; get key number (1-16)
  7334  469e 8676                                stx z_p_temp_1                           ; save key number     [910925]
  7335  46a0 ca                                  dex
  7336  46a1 e010                                cpx #number_fkeys
  7337  46a3 b3590b                              +lbcs fcerr                              ; exit - key number invalid
  7338                          
  7339                          ; stx z_p_temp_1 ;save key number
  7340  46a6 205b4e                              jsr chkcom                               ; look for comma
  7341  46a9 20675b                              jsr frmstr                               ; do frmevl, frestr. returns len in .a, addr in 'index'
  7342  46ac a8                                  tay                                      ; set up for call to do-a-key
  7343  46ad a901                                lda #1                                   ; tell do-a-key that string is in bank 1
  7344  46af 8526                                sta index+2
  7345  46b1 a924                                lda #index                               ; now .A points to (adr lo, adr hi, bank #)
  7346  46b3 a676                                ldx z_p_temp_1
  7347                          ; inx         [910925]
  7348                          key_restore
  7349                          ; jsr put_io_in_map
  7350  46b5 2068ff                              jsr _doakey                              ; re-define the key
  7351  46b8 b387e7                              +lbcs omerr                              ; bad return (.c=1)
  7352  46bb 60                                  rts                                      ; ok return  (.c=0)
  7353                          
  7354                          ; .page
  7355                          ;************************************************************************
  7356                          ;   Key_Load  Load function key definitions (from disk)   [900725]
  7357                          ;************************************************************************
  7358                          
  7359                          Key_load
  7360  46bc 20c946                              jsr GetLoadChannel                       ; get a channel      [911001]
  7361  46bf a010                                ldy #>_pky_lengths
  7362  46c1 a900                                lda #<_pky_lengths
  7363  46c3 20fa46                              jsr LoadBlock                            ; load it
  7364  46c6 835fec                              +lbra list_err                           ; release channel, close file, return to main
  7365                          
  7366                          
  7367                          GetLoadChannel                                            ; Used by KeyLoad and SpriteLoad    [911001]
  7368  46c9 208322                              jsr chrget                               ; eat LOAD token
  7369  46cc a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
  7370  46ce 202074                              jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 )
  7371  46d1 20dc77                              jsr chk1                                 ; check parameters
  7372  46d4 a900                                lda #0
  7373  46d6 8d8311                              sta dossa                                ; setup as dload would (0 = load channel)
  7374  46d9 201d71                              jsr find_la                              ; find an unused LA to use (cannot use reserved one)
  7375  46dc a009                                ldy #fopn
  7376  46de a204                                ldx #4
  7377  46e0 20fd70                              jsr open_file                            ; open the file
  7378  46e3 b033                                bcs LoadEOF                              ; exit if problem
  7379  46e5 ae8111                              ldx dosla
  7380  46e8 20c6ff                              jsr _chkin                               ; get input channel
  7381  46eb b02b                                bcs LoadEOF                              ; exit if bad??
  7382  46ed 20cfff                              jsr _basin                               ; waste dummy load address
  7383  46f0 20cfff                              jsr _basin
  7384  46f3 20b7ff                              jsr _readst                              ; prevent corruption if there's a problem
  7385  46f6 d01c                                bne LoadERR                              ; exit if problem
  7386  46f8 18                                  clc
  7387  46f9 60                                  rts
  7388                          
  7389                          ; .page
  7390                          LoadBlock
  7391  46fa 855a                                sta highds                               ; where to put data
  7392  46fc 845b                                sty highds+1
  7393                          LoadBlockNext
  7394  46fe a000                                ldy #0
  7395  4700 20cfff             l102_1           jsr _basin                               ; read definitions
  7396  4703 915a                                sta (highds),y
  7397  4705 20b7ff                              jsr _readst                              ; check channel status
  7398  4708 d00e                                bne LoadEOF                              ; exit if eof or error
  7399  470a 20e1ff                              jsr _stop
  7400  470d f009                                beq LoadEOF                              ; exit if stop key down
  7401  470f c8                                  iny
  7402  4710 d0ee                                bne l102_1                               ; continue up to 1 page maximum
  7403  4712 18                                  clc                                      ; indicate "more"
  7404  4713 60                                  rts
  7405                          
  7406                          
  7407                          LoadERR
  7408  4714 a21d                                ldx #erload                              ; Load Error
  7409  4716 38                                  sec
  7410  4717 89                                  !text $89
  7411                          
  7412                          LoadEOF
  7413  4718 18                                  clc
  7414  4719 830cec                              +lbra list_err                           ; release channel, close file, return to main
  7415                          
  7416                          ; .page
  7417                          ;************************************************************************
  7418                          ;   Key_Save  Save function key definitions (from disk)   [900725]
  7419                          ;************************************************************************
  7420                          
  7421                          Key_Save
  7422  471c 202e47                              jsr GetSaveChannel                       ; [910930]
  7423  471f a95a                                lda #highds                              ; set starting & ending addresses
  7424  4721 a010                                ldy #>_pky_lengths                       ; start address & pointer to it
  7425  4723 a200                                ldx #<_pky_lengths
  7426  4725 845b                                sty highds+1
  7427  4727 865a                                stx highds
  7428  4729 c8                                  iny                                      ; end address = start address + 256 + 1
  7429  472a e8                                  inx
  7430  472b 833e21                              +lbra savenb                             ; [910925]
  7431                          ; jsr _savesp  ;save it
  7432                          ;; clc   ; return no error  ????why not  [910404]
  7433                          ; bra exit_disk_op ; but if direct mode print DOS error  [910404]
  7434                          
  7435                          
  7436                          
  7437                          GetSaveChannel                                            ; Used by KeySave and SpriteSave    [910930]
  7438  472e 208322                              jsr chrget                               ; eat SAVE token
  7439  4731 a966                                lda #$66                                 ; parse:  filename [,U#] [,D#]
  7440  4733 202074                              jsr dosprs                               ; parse options
  7441  4736 20e177                              jsr chk2                                 ; check required parameters
  7442                          
  7443  4739 a009                                ldy #fopn                                ; DOS table offset
  7444  473b a904                                lda #4                                   ; length
  7445  473d 20f276                              jsr sendp
  7446  4740 a900                                lda #sys_bank                            ; set banks ???? buffer in system bank ????
  7447  4742 a200                                ldx #sys_bank
  7448  4744 4c6bff                              jmp _setbank
  7449                          
  7450                          ;.end
  7451                          ; .page
  7452                          ; .subttl  BANK
  7453                          
  7454                          ;************************************************************************
  7455                          ;*  Set Memory Bank for PEEK,POKE,WAIT,BLOAD,BSAVE and SYS,BOOT Commands
  7456                          ;*
  7457                          ;*  Syntax: BANK DATA  n  for PEEK,POKE,WAIT,BLOAD,BSAVE
  7458                          ;*  BANK SYS  [a,x,y,z] for SYS,BOOT Commands
  7459                          ;*
  7460                          ;* where   n=  %11111111  to access I/O area (System MAP)
  7461                          ;*      %0xxxxxxx to use physical bank n
  7462                          ;*
  7463                          ;* or      a,x,y,z  describe precise configuration for MAPper
  7464                          ;*    if omitted, the System MAP is to be used.
  7465                          ;*
  7466                          ;* The DATA option is to access data,  i.e., LDA/STA_far
  7467                          ;* The SYS  option is to execute code, i.e., JMP/JSR_far
  7468                          ;*
  7469                          ;*  Idea: BANK SCREEN n  when REC is finalized????
  7470                          ;************************************************************************
  7471                          
  7472  4747 206c5d             bank             jsr getbyt                               ; get bank number in .x
  7473  474a 8ed102                              stx current_bank
  7474  474d 60                                  rts
  7475                          
  7476                          
  7477                          ;.end
  7478                          ; .page
  7479                          ; .subttl  PLAY
  7480                          
  7481                          ; C65 Music Interpreter
  7482                          ;
  7483                          ; Syntax : PLAY "music_string"
  7484                          ;
  7485                          ; Where : music_string is a string of characters composed of:
  7486                          ;
  7487                          ; A..G   : notes
  7488                          ; W,H,Q,I,S : set note lengths to whole,half,quarter,eighth,sixteenth
  7489                          ; U   : set volume level   (0-9)
  7490                          ; O   : set octave    (0-6)
  7491                          ; T   : set current envelope  (0-9)
  7492                          ; V   : select voice to play  (1-6: 1-3 right, 4-6 left)
  7493                          ; X   : filter    (0-1: 0=off, 1=on)
  7494                          ; M   : measure
  7495                          ; R   : rest
  7496                          ; .   : dot
  7497                          ; #   : sharp
  7498                          ; $   : flat
  7499                          
  7500                          
  7501  474e 20675b             play             jsr frmstr                               ; frmevl,frestr,return w/ .A=len, (index)=>string
  7502                          ; sta sw_rom_ram0  ;????
  7503  4751 8576                                sta z_p_temp_1                           ; save number of characters
  7504  4753 207b49                              jsr clear_play_flags                     ; set 'dot' and 'sharp' to 0. return with Acc=0
  7505  4756 8577                                sta hulp                                 ; zero counter
  7506                          
  7507  4758 a477               l103_1           ldy hulp
  7508  475a c476                                cpy z_p_temp_1
  7509  475c f00a                                beq play_rts                             ; done!
  7510  475e 20d522                              jsr indin1_ram1
  7511  4761 206947                              jsr play_one_character
  7512  4764 e677                                inc hulp
  7513  4766 d0f0                                bne l103_1                               ; always
  7514                          play_rts
  7515  4768 60                                  rts
  7516                          
  7517                          ; .page
  7518                          play_one_character
  7519  4769 c920                                cmp #' '                                 ; spaces are a 'no-op'
  7520  476b f0fb                                beq play_rts
  7521                          
  7522  476d c941               l104_1           cmp #'A'                                 ; note name a-g?
  7523  476f 9005                                bcc l104_2
  7524  4771 c948                                cmp #'H'
  7525  4773 934601                              +lbcc play_note                          ; yes...play it
  7526                          
  7527  4776 a204               l104_2           ldx #4                                   ; test for notes,'w,h,q,i,s'
  7528  4778 dd9649             l104_3           cmp notes,x
  7529  477b f31d01                              +lbeq set_note_length
  7530  477e ca                                  dex
  7531  477f 10f7                                bpl l104_3
  7532                          
  7533  4781 c952                                cmp #'R'                                 ; rest?
  7534  4783 f3a101                              +lbeq play_rest
  7535  4786 c92e                                cmp #'.'                                 ; dotted note?
  7536  4788 f30c01                              +lbeq play_dot
  7537                          
  7538  478b a205                                ldx #5                                   ; test for v,o,t,x,u,m commands
  7539  478d dd9b49             l104_4           cmp mutabl,x
  7540  4790 f36c01                              +lbeq play_command
  7541  4793 ca                                  dex
  7542  4794 10f7                                bpl l104_4                               ; test all 5 characters in table
  7543                          
  7544  4796 c923                                cmp #'#'                                 ; sharp?
  7545  4798 f37d01                              +lbeq play_sharp
  7546  479b c924                                cmp #'$'                                 ; flat?
  7547  479d f37b01                              +lbeq play_flat
  7548                          
  7549                          ; .page
  7550                          ; Must be a digit here for Octave, Voice, envelope (T), filter (X), or volume (U)
  7551                          
  7552  47a0 38                                  sec
  7553  47a1 e930                                sbc #'0'                                 ; mask nybble
  7554  47a3 c90a                                cmp #10                                  ; must be in range 0..9
  7555  47a5 b3e900                              +lbcs play_bad_value
  7556                          
  7557  47a8 0edb11                              asl flag                                 ; octave, voice, envelope, filter, or volume?
  7558  47ab b041                                bcs set_voice
  7559  47ad 0edb11                              asl flag                                 ; octave, envelope, filter, or volume?
  7560  47b0 b047                                bcs set_octave
  7561  47b2 0edb11                              asl flag                                 ; envelope, filter, or volume?
  7562  47b5 b04c                                bcs set_envelope
  7563  47b7 0edb11                              asl flag                                 ; filter or volume?
  7564  47ba 9072                                bcc set_volume
  7565                          
  7566                          set_filter
  7567  47bc 207648                              jsr wait_for_all_quiet                   ; [910722]
  7568  47bf c902                                cmp #2
  7569  47c1 b3cd00                              +lbcs play_bad_value                     ; value too large
  7570  47c4 4a                                  lsr                                      ; .c=on/off
  7571  47c5 ac6f12                              ldy voice                                ; 0-5
  7572  47c8 be064a                              ldx filter_offset,y                      ; 0 0 0 4 4 4
  7573  47cb bd7a12                              lda filters1+2,x                         ; get current filter data for this SID  [910612]
  7574  47ce 195f79                              ora vbits,y                              ; update filter voice bit
  7575  47d1 b003                                bcs l105_1                               ; branch to turn filter on
  7576  47d3 595f79                              eor vbits,y                              ; else, turn filter off   [910612]
  7577                          
  7578  47d6 9d7a12             l105_1           sta filters1+2,x
  7579                          ; lda filters1+3,x ;why????     [910612]
  7580                          ; sta filters1+4,x ;save new filter-type/volume
  7581                          
  7582                          ; jsr put_io_in_map
  7583  47d9 b9004a                              lda SID_offset,y                         ; get hardware offset for current voice
  7584  47dc 29f0                                and #$f0                                 ; $00 or $20
  7585  47de a8                                  tay
  7586                          ; jsr go_slow  ;      [910716] 4567R7A
  7587  47df a303                                ldz #3
  7588  47e1 bd7812             l105_2           lda filters1,x                           ; update the hardware
  7589  47e4 9915d4                              sta sid1+21,y
  7590  47e7 e8                                  inx
  7591  47e8 c8                                  iny
  7592  47e9 3b                                  dez
  7593  47ea 10f5                                bpl l105_2
  7594                          ; jsr go_fast  ;      [910716] 4567R7A
  7595  47ec 8063                                bra clear_flag                           ; always
  7596                          
  7597                          ; .page
  7598                          set_voice
  7599  47ee 3a                                  dec
  7600  47ef c906                                cmp #6                                   ; stereo SIDs: 0-2=right, 3-5=left  [910612]
  7601  47f1 b39d00                              +lbcs play_bad_value
  7602  47f4 8d6f12                              sta voice                                ; 0-5
  7603  47f7 8058                                bra clear_flag                           ; always
  7604                          
  7605                          
  7606                          set_octave
  7607  47f9 c907                                cmp #7
  7608  47fb b39300                              +lbcs play_bad_value                     ; too big octave
  7609  47fe 8d7012                              sta octave                               ; set octave
  7610  4801 804e                                bra clear_flag                           ; always
  7611                          
  7612                          
  7613                          set_envelope
  7614  4803 206a48                              jsr wait_for_quiet                       ; [910626]
  7615  4806 aa                                  tax
  7616                          set_envelope_1                                            ; entry for initialization code
  7617                          ; jsr put_io_in_map
  7618  4807 ac6f12                              ldy voice
  7619  480a bd9d12                              lda wavtab,x
  7620  480d 996912                              sta waveform,y                           ; set waveform
  7621  4810 b9004a                              lda SID_offset,y                         ; get hardware offset for this voice
  7622  4813 a8                                  tay
  7623                          ; jsr go_slow  ;      [910716] 4567R7A
  7624  4814 bd8912                              lda atktab,x
  7625  4817 9905d4                              sta sid1+5,y                             ; set attack/decay
  7626  481a bd9312                              lda sustab,x
  7627  481d 9906d4                              sta sid1+6,y                             ; set sustain/release
  7628  4820 bda712                              lda pulslw,x
  7629  4823 9902d4                              sta sid1+2,y                             ; set pulse width - low byte
  7630  4826 bdb112                              lda pulshi,x
  7631  4829 9903d4                              sta sid1+3,y                             ; set pulse width - high byte
  7632                          ; jsr go_fast  ;      [910716] 4567R7A
  7633  482c 8023                                bra clear_flag
  7634                          
  7635                          ; .page
  7636                          set_volume
  7637  482e 207648                              jsr wait_for_all_quiet                   ; [910626]
  7638  4831 aa                                  tax
  7639  4832 ac6f12                              ldy voice                                ; [910612]
  7640  4835 b9064a                              lda filter_offset,y                      ; get filter offset for this voice
  7641  4838 a8                                  tay
  7642  4839 b97b12                              lda filters1+3,y                         ; get mode/volume for this SID
  7643  483c 29f0                                and #$f0                                 ; mask out old volume
  7644  483e 1d0c4a                              ora voltab,x                             ; add new volume
  7645  4841 997b12                              sta filters1+3,y                         ; save for filter change
  7646                          ; lda filters1+4,y ;get current filter-type/volume ????why  [910612]
  7647                          ; and #$f0
  7648                          ; ora voltab,x
  7649  4844 aa                                  tax
  7650  4845 ac6f12                              ldy voice
  7651  4848 b9004a                              lda SID_offset,y                         ; get hardware offset for current voice
  7652  484b 29f0                                and #$f0                                 ; $00 or $20
  7653  484d a8                                  tay
  7654                          ; jsr go_slow  ;      [910716] 4567R7A
  7655  484e 9b18d4                              stx sid1+24,y                            ; set new volume
  7656                          ; jsr go_fast  ;      [910716] 4567R7A
  7657                          ;fall into clear_flag
  7658                          ; .page
  7659                          clear_flag
  7660  4851 a900                                lda #0
  7661  4853 8ddb11                              sta flag
  7662  4856 60                                  rts
  7663                          
  7664                          
  7665                          go_fast
  7666  4857 a586                                lda sid_speed_flag
  7667  4859 0c31d0                              tsb vic+49
  7668  485c 60                                  rts
  7669                          
  7670                          
  7671                          go_slow
  7672  485d 48                                  pha
  7673  485e a940                                lda #$40
  7674  4860 2d31d0                              and vic+49
  7675  4863 1c31d0                              trb vic+49
  7676  4866 8586                                sta sid_speed_flag
  7677  4868 68                                  pla
  7678  4869 60                                  rts
  7679                          
  7680                          
  7681                          wait_for_quiet                                            ; Wait for current voice to be quiet  [910626]
  7682  486a ac6f12                              ldy voice
  7683  486d be9049                              ldx times2,y                             ; voice*2
  7684  4870 3c5e12             l106_1           bit voices+1,x                           ; test if voice is active   [910617]
  7685  4873 10fb                                bpl l106_1                               ; loop until inactive (IRQ)
  7686  4875 60                                  rts
  7687                          
  7688                          
  7689                          wait_for_all_quiet                                          ; Wait for all voices on this SID to be quiet [910626]
  7690  4876 a003                                ldy #3
  7691  4878 ae6f12                              ldx voice
  7692  487b e003                                cpx #3                                   ; determine left/right SID
  7693  487d b002                                bcs l107_1
  7694  487f a000                                ldy #0
  7695  4881 a303               l107_1           ldz #3                                   ; for each of 3 voices
  7696  4883 be9049             l107_2           ldx times2,y
  7697  4886 3c5e12             l107_3           bit voices+1,x                           ; wait for voice to be inactive (IRQ)
  7698  4889 10fb                                bpl l107_3
  7699  488b c8                                  iny                                      ; next voice
  7700  488c 3b                                  dez
  7701  488d d0f4                                bne l107_2                               ; until done 3 voices
  7702  488f 60                                  rts
  7703                          
  7704                          ; .page
  7705                          play_bad_value
  7706  4890 205148                              jsr clear_flag
  7707  4893 836909                              +lbra fcerr                              ; illegal quantity
  7708                          
  7709                          play_dot
  7710  4896 8d7212                              sta dnote
  7711  4899 60                                  rts
  7712                          
  7713                          
  7714                          
  7715                          set_note_length
  7716                          ; ldy #<beats  ;found note (.x), divide beats accordingly
  7717                          ; sty ntime
  7718                          ; ldy #>beats
  7719                          ; sty ntime+1
  7720                          
  7721  489a 2c0311                              bit _pal_ntsc                            ; determine if PAL or NTSC system  [910724]
  7722  489d 3006                                bmi l108_1                               ; ...branch if PAL
  7723  489f a3a0                                ldz #<beats_ntsc                         ; (whole note 4/4 time = 2 sec)
  7724  48a1 a005                                ldy #>beats_ntsc
  7725  48a3 8004                                bra l108_2
  7726  48a5 a3b0               l108_1           ldz #<beats_pal
  7727  48a7 a004                                ldy #>beats_pal
  7728  48a9 9c7612             l108_2           stz ntime
  7729  48ac 8c7712                              sty ntime+1
  7730                          
  7731  48af ca                 l108_3           dex
  7732  48b0 3008                                bmi l108_4                               ; finished dividing, exit
  7733  48b2 4e7712                              lsr ntime+1
  7734  48b5 6e7612                              ror ntime
  7735  48b8 80f5                                bra l108_3
  7736                          
  7737  48ba 60                 l108_4           rts
  7738                          
  7739                          ; .page
  7740                          play_note
  7741  48bb 38                                  sec
  7742  48bc e941                                sbc #'A'
  7743  48be aa                                  tax
  7744  48bf bda149                              lda scalen,x                             ; note #0-11
  7745  48c2 aa                                  tax
  7746  48c3 a906                                lda #6
  7747  48c5 38                                  sec
  7748  48c6 ed7012                              sbc octave
  7749  48c9 a8                                  tay
  7750  48ca 8a                                  txa
  7751  48cb 18                                  clc
  7752  48cc 6d7112                              adc sharp
  7753  48cf 1003                                bpl l109_1                               ; added sharp or nat
  7754  48d1 a90b                                lda #11                                  ; underflow
  7755  48d3 c8                                  iny                                      ; bump octave down
  7756  48d4 c90c               l109_1           cmp #12                                  ; overflow?
  7757  48d6 9003                                bcc l109_2                               ; no...
  7758  48d8 a900                                lda #0
  7759  48da 88                                  dey                                      ; bump octave up
  7760  48db aa                 l109_2           tax
  7761  48dc bda849                              lda scalel,x
  7762  48df 8d7412                              sta pitch
  7763                          
  7764  48e2 2c0311                              bit _pal_ntsc                            ; determine if PAL or NTSC system
  7765  48e5 3005                                bmi l109_3                               ; ...branch if PAL
  7766  48e7 bdb449                              lda scaleh,x                             ; continue as before patch
  7767  48ea 8009                                bra l109_4
  7768                          
  7769  48ec bdc049             l109_3           lda scalelp,x                            ; load from PAL tables
  7770  48ef 8d7412                              sta pitch
  7771  48f2 bdcc49                              lda scalehp,x
  7772                          
  7773  48f5 88                 l109_4           dey
  7774  48f6 3028                                bmi play_note_1                          ; go play note
  7775  48f8 4a                                  lsr
  7776  48f9 6e7412                              ror pitch
  7777  48fc 80f7                                bra l109_4
  7778                          
  7779                          ; .page
  7780                          play_command
  7781  48fe c94d                                cmp #'M'                                 ; measure?
  7782  4900 f007                                beq l110_1
  7783                          
  7784  4902 bd6d79                              lda rbits,x                              ; all others, set flag for next number
  7785  4905 8ddb11                              sta flag
  7786  4908 60                                  rts
  7787                          
  7788                          ; Wait for msb of all 3 voice counters to underflow
  7789                          
  7790                          ;l110_1 ldy #5
  7791                          ;l110_2 lda voices,y
  7792                          ; bpl l110_2
  7793                          ; dey
  7794                          ; dey
  7795                          ; bpl l110_2
  7796                          ; rts
  7797                          
  7798  4909 a005               l110_1           ldy #5                                   ; [910626]
  7799  490b be9049             l110_2           ldx times2,y
  7800  490e 3c5e12             l110_3           bit voices+1,x                           ; wait for voice to be inactive (IRQ)
  7801  4911 10fb                                bpl l110_3
  7802  4913 88                                  dey                                      ; next voice
  7803  4914 10f5                                bpl l110_2                               ; until done 6 voices
  7804  4916 60                                  rts
  7805                          
  7806                          
  7807                          
  7808                          play_sharp
  7809  4917 a901                                lda #1
  7810  4919 2c                                  !text $2c
  7811                          play_flat
  7812  491a a9ff                                lda #$ff
  7813  491c 8d7112                              sta sharp
  7814  491f 60                                  rts
  7815                          
  7816                          ; .page
  7817                          play_note_1                                               ; play a note
  7818  4920 8d7512                              sta pitch+1
  7819  4923 a900                                lda #0                                   ; flag 'not rest'
  7820  4925 2c                                  !text $2c                                ; hop
  7821                          play_rest
  7822  4926 a9ff                                lda #$ff                                 ; flag 'rest'
  7823  4928 48                                  pha                                      ; save flag
  7824  4929 ae6f12                              ldx voice
  7825  492c bc9049                              ldy times2,x                             ; y=x*2
  7826  492f b95e12             l111_1           lda voices+1,y                           ; test if there is a note playing
  7827  4932 10fb                                bpl l111_1                               ; and loop if so
  7828                          
  7829  4934 78                                  sei
  7830  4935 ad7612                              lda ntime                                ; load counter for current length
  7831  4938 995d12                              sta voices,y
  7832  493b ad7712                              lda ntime+1
  7833  493e 995e12                              sta voices+1,y
  7834  4941 ad7212                              lda dnote                                ; test if this is a dotted note
  7835  4944 f017                                beq l111_2                               ; no
  7836  4946 ad7712                              lda ntime+1
  7837  4949 4a                                  lsr                                      ; duration is 1.5 x current length
  7838  494a 48                                  pha
  7839  494b ad7612                              lda ntime
  7840  494e 6a                                  ror
  7841  494f 18                                  clc
  7842  4950 795d12                              adc voices,y
  7843  4953 995d12                              sta voices,y
  7844  4956 68                                  pla
  7845  4957 795e12                              adc voices+1,y
  7846  495a 995e12                              sta voices+1,y
  7847                          
  7848  495d 68                 l111_2           pla                                      ; test if this is a rest
  7849  495e 301a                                bmi l111_3                               ; and branch if so- clear play flags and exit [910722]
  7850                          
  7851                          ; jsr put_io_in_map
  7852                          ; jsr go_slow  ;      [910716] 4567R7A
  7853  4960 bc004a                              ldy SID_offset,x                         ; get offset to voice hardware
  7854  4963 ad7412                              lda pitch
  7855  4966 9900d4                              sta sid1,y
  7856  4969 ad7512                              lda pitch+1
  7857  496c 9901d4                              sta sid1+1,y
  7858  496f a908                                lda #$08                                 ; reset this voice
  7859  4971 9904d4                              sta sid1+4,y
  7860  4974 bd6912                              lda waveform,x                           ; and finally, turn on gate
  7861  4977 9904d4                              sta sid1+4,y
  7862                          ; jsr go_fast  ;      [910716] 4567R7A
  7863  497a 58                 l111_3           cli
  7864                          
  7865                          ; .page
  7866                          clear_play_flags
  7867  497b a900                                lda #0
  7868  497d 8d7112                              sta sharp                                ; clear flags
  7869  4980 8d7212                              sta dnote
  7870  4983 58                                  cli
  7871  4984 60                                  rts
  7872                          
  7873                          
  7874  4985 206c5d             tempo            jsr getbyt                               ; duration of whole note 4/4 time = 24/rate
  7875  4988 8a                                  txa
  7876  4989 f37308                              +lbeq fcerr                              ; can't be zero- illegal quantity error
  7877  498c 8e7312                              stx tempo_rate
  7878  498f 60                                  rts
  7879                          
  7880                          ; .page
  7881  4990 00020406080a       times2           !text 0,2,4,6,8,10                       ; [910612] stereo
  7882                          
  7883  4996 5748514953         notes            !text "WHQIS"                            ; sixteenth,eigth,quarter,half,and whole notes
  7884                          
  7885  499b 564f5458554d       mutabl           !text "VOTXUM"                           ; voice,octave,envelope,filter,volume,& measure
  7886                          
  7887  49a1 090b0002040507     scalen           !text 9,11,0,2,4,5,7                     ; a,b,c,d,e,f,g
  7888                          
  7889  49a8 0f0c46bf7d83       scalel           !text $0f,$0c,$46,$bf,$7d,$83            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (NTSC, octave 6)
  7890  49ae d67a73c87c97                        !text $d6,$7a,$73,$c8,$7c,$97            ; [910729]
  7891                          
  7892  49b4 43474b4f5459       scaleh           !text $43,$47,$4b,$4f,$54,$59            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (NTSC, octave 6)
  7893  49ba 5e646a70777e                        !text $5e,$64,$6a,$70,$77,$7e            ; [910729]
  7894                          
  7895  49c0 878bcc4e1424       scalelp          !text $87,$8b,$cc,$4e,$14,$24            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (PAL,  octave 6)
  7896  49c6 802d3291527a                        !text $80,$2d,$32,$91,$52,$7a            ; [910729]
  7897                          
  7898  49cc 43474b50555a       scalehp          !text $43,$47,$4b,$50,$55,$5a            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (PAL,  octave 6)
  7899  49d2 5f656b71787f                        !text $5f,$65,$6b,$71,$78,$7f            ; [910729]
  7900                          
  7901                          ;  Music envelope tables, default values downloaded to RAM:
  7902                          ;
  7903                          ; 0: piano   1: accordion    2: calliope  3: drum     4: flute
  7904                          ; 5: guitar  6: harpsichord  7: organ     8: trumpet  9: xylophone
  7905                          
  7906                          ;  Attack/decay rates
  7907                          
  7908  49d8 09c0000594090909...atkmus           !text $09,$c0,$00,$05,$94,$09,$09,$09,$89,$09
  7909                          
  7910                          ;  Sustain/release rates
  7911                          
  7912  49e2 00c0f05040210090...susmus           !text $00,$c0,$f0,$50,$40,$21,$00,$90,$41,$00
  7913                          
  7914                          ;  Waveform table
  7915                          
  7916  49ec 4121118111214141...wavmus           !text $41,$21,$11,$81,$11,$21,$41,$41,$41,$11
  7917                          
  7918                          ;  Pulse width hi table
  7919                          
  7920  49f6 0600000000000208...pwhmus           !text $06,$00,$00,$00,$00,$00,$02,$08,$02,$00
  7921                          
  7922                          ;  Offset tables
  7923                          
  7924                          SID_offset
  7925  4a00 00070e20272e                        !text $00,$07,$0e,$20,$27,$2e            ; [910612] stereo
  7926                          filter_offset
  7927  4a06 000000040404                        !text 0,0,0,4,4,4
  7928                          
  7929                          ;  Volume levels
  7930                          
  7931  4a0c 0001030507080a0c...voltab           !text 0,1,3,5,7,8,10,12,14,15
  7932                          
  7933                          ;.end
  7934                          ; .page
  7935                          ; .subttl  FILTER
  7936                          
  7937                          ;******************************************************************
  7938                          ;
  7939                          ;  FILTER  sid, freq, lp, bp, hp, res   --  set values for filter
  7940                          ;
  7941                          ;     sid =  right (1), left (2)
  7942                          ;          freq =  filter frequency (0-1023)
  7943                          ;            lp =  low pass filter on (1) or off (0)
  7944                          ;            bp =  band pass filter on (1) or off (0)
  7945                          ;            hp =  high pass filter on (1) or off (0)
  7946                          ;           res =  resonance (0-15)
  7947                          ;
  7948                          ;******************************************************************
  7949                          
  7950  4a16 206c5d             filter           jsr getbyt                               ; get left/right SID    [910612]
  7951  4a19 ca                                  dex
  7952  4a1a e002                                cpx #2
  7953  4a1c b3e007                              +lbcs fcerr
  7954  4a1f bd084a                              lda filter_offset+2,x                    ; get filter offset for specified SID
  7955  4a22 8576                                sta z_p_temp_1
  7956  4a24 aa                                  tax
  7957                          
  7958  4a25 a000                                ldy #0
  7959  4a27 bd7812             l112_1           lda filters1,x                           ; save current voice's filter params
  7960  4a2a 998012                              sta fltsav,y
  7961  4a2d e8                                  inx
  7962  4a2e c8                                  iny
  7963  4a2f c004                                cpy #4
  7964  4a31 90f4                                bcc l112_1
  7965                          
  7966  4a33 20f278                              jsr optwrd                               ; get filter frequency
  7967  4a36 9017                                bcc l112_2                               ; skip if no value given
  7968  4a38 c908                                cmp #8                                   ; test m.s. byte
  7969  4a3a b3c207                              +lbcs fcerr                              ; error if > 2047
  7970  4a3d 8c8012                              sty fltsav                               ; save lower byte
  7971                          
  7972                          ; Idea: shift lower 3 bits of upper byte into lower byte, forming bits 10-3
  7973                          
  7974  4a40 8c8112                              sty fltsav+1
  7975  4a43 4a                                  lsr
  7976  4a44 6e8112                              ror fltsav+1
  7977  4a47 4a                                  lsr
  7978  4a48 6e8112                              ror fltsav+1                             ; save upper 7 bits (10-3)
  7979  4a4b 4a                                  lsr
  7980  4a4c 6e8112                              ror fltsav+1
  7981                          
  7982  4a4f a910               l112_2           lda #$10                                 ; start at type=LP
  7983  4a51 8d8412                              sta fltflg
  7984  4a54 ad8012                              lda fltsav
  7985                          
  7986  4a57 202679             l112_3           jsr optbyt                               ; get filter types (LP,BP,HP)
  7987  4a5a 9017                                bcc l112_6                               ; skip if no value input
  7988  4a5c e001                                cpx #1                                   ; (set .c: 0=0, 1=1)
  7989  4a5e 9005                                bcc l112_4
  7990  4a60 f003                                beq l112_4
  7991  4a62 839a07                              +lbra fcerr                              ; error if >1
  7992                          
  7993  4a65 ad8312             l112_4           lda fltsav+3                             ; get filter flags byte
  7994  4a68 0d8412                              ora fltflg                               ; set filter on
  7995  4a6b b003                                bcs l112_5                               ; skip if it should be on
  7996  4a6d 4d8412                              eor fltflg                               ; turn filter off
  7997  4a70 8d8312             l112_5           sta fltsav+3                             ; save value
  7998                          
  7999  4a73 0e8412             l112_6           asl fltflg                               ; shift for next filter
  8000  4a76 10df                                bpl l112_3                               ; loop 3 times
  8001                          
  8002  4a78 202679                              jsr optbyt                               ; get resonance value
  8003  4a7b 9016                                bcc l112_7                               ; skip if no value given
  8004                          ; cpx #16
  8005                          ; bcs fcerr  ;error if >15
  8006  4a7d 2010b5                              jsr chknyb                               ; [910930]
  8007  4a80 8a                                  txa
  8008  4a81 0a                                  asl                                      ; shift to upper nibble
  8009  4a82 0a                                  asl
  8010  4a83 0a                                  asl
  8011  4a84 0a                                  asl
  8012  4a85 8dbc12                              sta nibble
  8013  4a88 ad8212                              lda fltsav+2                             ; get current value
  8014  4a8b 290f                                and #$0f                                 ; mask it out
  8015  4a8d 0dbc12                              ora nibble                               ; add new value
  8016  4a90 8d8212                              sta fltsav+2                             ; save it
  8017                          
  8018  4a93 a676               l112_7           ldx z_p_temp_1                           ; hardware offset for this voice's filter [910612]
  8019  4a95 a000                                ldy #0
  8020  4a97 b98012             l112_8           lda fltsav,y                             ; copy new filter params to hardware
  8021  4a9a 9d7812                              sta filters1,x
  8022  4a9d e8                                  inx
  8023  4a9e c8                                  iny
  8024  4a9f c004                                cpy #4
  8025  4aa1 90f4                                bcc l112_8
  8026  4aa3 60                                  rts
  8027                          
  8028                          ;.end
  8029                          ; .page
  8030                          ; .subttl  ENVELOPE
  8031                          
  8032                          ;****************************************************************
  8033                          ;
  8034                          ;  ENVELOPE n, attack, decay, sustain, release, waveform, pulse width
  8035                          ;        set music envelope
  8036                          ;                n = envelope number (0-9)
  8037                          ;            wave  =   0 : triangle waveform
  8038                          ;                      1 : sawtooth waveform
  8039                          ;                      2 : pulse waveform
  8040                          ;                      3 : noise waveform
  8041                          ;                      4 : ring modulation
  8042                          ;            pulse = pulse width if pulse waveform is selected (0-4095)
  8043                          ;
  8044                          ;******************************************************************
  8045                          
  8046                          envelope
  8047  4aa4 206c5d                              jsr getbyt                               ; get envelope number
  8048  4aa7 e00a                                cpx #10
  8049  4aa9 b35307                              +lbcs fcerr                              ; exit - invalid tone number
  8050  4aac 8e8512                              stx tonnum                               ; save number
  8051  4aaf bd8912                              lda atktab,x                             ; get attack/decay rates
  8052  4ab2 8d8612                              sta tonval
  8053  4ab5 bd9312                              lda sustab,x                             ; get sustain/release rates
  8054  4ab8 8d8712                              sta tonval+1
  8055  4abb bd9d12                              lda wavtab,x                             ; get waveform and filter
  8056  4abe 8d8812                              sta tonval+2
  8057                          
  8058  4ac1 a200                                ldx #0
  8059  4ac3 8ebb12             l113_1           stx parcnt
  8060  4ac6 202679                              jsr optbyt                               ; get parameter - attack or sustain
  8061  4ac9 9016                                bcc l113_2                               ; skip if no input
  8062  4acb 8a                                  txa
  8063  4acc 0a                                  asl
  8064  4acd 0a                                  asl                                      ; shift to upper nibble
  8065  4ace 0a                                  asl
  8066  4acf 0a                                  asl
  8067  4ad0 8dbc12                              sta nibble                               ; save it
  8068  4ad3 aebb12                              ldx parcnt
  8069  4ad6 bd8612                              lda tonval,x                             ; get current value
  8070  4ad9 290f                                and #$0f                                 ; mask it out
  8071  4adb 0dbc12                              ora nibble                               ; add new value
  8072  4ade 9d8612                              sta tonval,x                             ; save it
  8073                          
  8074  4ae1 202679             l113_2           jsr optbyt                               ; get decay or release rate
  8075  4ae4 9014                                bcc l113_3                               ; skip if no input
  8076  4ae6 8a                                  txa
  8077  4ae7 290f                                and #$0f                                 ; use only lower nibble
  8078  4ae9 8dbc12                              sta nibble                               ; save it
  8079  4aec aebb12                              ldx parcnt
  8080  4aef bd8612                              lda tonval,x                             ; get current value
  8081  4af2 29f0                                and #$f0                                 ; mask it out
  8082  4af4 0dbc12                              ora nibble                               ; add new value
  8083  4af7 9d8612                              sta tonval,x                             ; save it
  8084                          
  8085  4afa aebb12             l113_3           ldx parcnt
  8086  4afd e8                                  inx
  8087  4afe e001                                cpx #1
  8088  4b00 f0c1                                beq l113_1                               ; loop to do sustain/release rates
  8089  4b02 202679                              jsr optbyt                               ; get waveform
  8090  4b05 9011                                bcc l113_5                               ; skip if no value
  8091  4b07 a915                                lda #$15                                 ; assume ring modulation
  8092  4b09 e004                                cpx #4
  8093  4b0b f008                                beq l113_4                               ; skip if correct
  8094  4b0d b3ef06                              +lbcs fcerr                              ; error if >4
  8095  4b10 bd6979                              lda sbits+4,x                            ; get waveform bit
  8096  4b13 0901                                ora #1                                   ; set gate bit
  8097                          
  8098  4b15 8d8812             l113_4           sta tonval+2                             ; save waveform
  8099                          
  8100  4b18 20f278             l113_5           jsr optwrd                               ; is there a pulse width arg?
  8101  4b1b 9013                                bcc l113_6                               ; nope, done
  8102                          
  8103  4b1d aa                                  tax                                      ; save msb
  8104  4b1e ad8812                              lda tonval+2                             ; get waveform
  8105  4b21 2940                                and #$40
  8106  4b23 f00b                                beq l113_6                               ; skip if not pulse waveform
  8107  4b25 8a                                  txa
  8108  4b26 ae8512                              ldx tonnum                               ; get envelope number
  8109  4b29 9db112                              sta pulshi,x                             ; save high byte of pulse width
  8110  4b2c 98                                  tya
  8111  4b2d 9da712                              sta pulslw,x                             ; save low byte
  8112                          
  8113  4b30 ae8512             l113_6           ldx tonnum
  8114  4b33 ad8612                              lda tonval                               ; set inputted values
  8115  4b36 9d8912                              sta atktab,x
  8116  4b39 ad8712                              lda tonval+1
  8117  4b3c 9d9312                              sta sustab,x
  8118  4b3f ad8812                              lda tonval+2
  8119  4b42 9d9d12                              sta wavtab,x
  8120                          volrts
  8121  4b45 60                                  rts
  8122                          
  8123                          ;.end
  8124                          ; .page
  8125                          ; .subttl  VOLUME
  8126                          
  8127                          ;***************************************************************
  8128                          ;*
  8129                          ;*  VOLUME - set volume of SID chips
  8130                          ;*
  8131                          ;* Syntax : VOLUME [right] [,left]
  8132                          ;*
  8133                          ;* Where  : vol in 0..15
  8134                          ;*
  8135                          ;***************************************************************
  8136                          
  8137  4b46 f302e3             volume           +lbeq snerr                              ; stereo parameters    [910612]
  8138  4b49 c92c                                cmp #','
  8139  4b4b f017                                beq l114_1                               ; left volume only
  8140                          ; jsr getbyt  ;right volume in .x
  8141                          ; cpx #16
  8142                          ; bcs fcerr  ;too large
  8143  4b4d 200db5                              jsr getnyb                               ; [910930]
  8144  4b50 8676                                stx z_p_temp_1                           ; a temp (sorry fred)
  8145                          
  8146                          ; The way this is done must work with 'PLAY' without too much conflict.
  8147                          ; So, along with setting the SID 'volume' reg, we'll also set up PLAY's
  8148                          ; record of current volume as well.
  8149                          
  8150  4b52 ad7b12                              lda filters1+3
  8151  4b55 29f0                                and #$f0
  8152  4b57 0576                                ora z_p_temp_1
  8153  4b59 8d7b12                              sta filters1+3
  8154                          
  8155                          ; lda filters1+4  ;???? why     [910612]
  8156                          ; and #$f0
  8157                          ; ora z_p_temp_1
  8158                          ; sta filters1+4
  8159                          
  8160                          ; jsr put_io_in_map
  8161                          ; jsr go_slow  ;      [910716] 4567R7A
  8162  4b5c 8d18d4                              sta sid1+24
  8163                          ; jsr go_fast  ;      [910716] 4567R7A
  8164  4b5f 208522                              jsr chrgot
  8165  4b62 f0e1                                beq volrts
  8166                          
  8167  4b64 202679             l114_1           jsr optbyt                               ; get optional left parameter   [910612]
  8168  4b67 93e1e2                              +lbcc snerr                              ; comma but no value not given??
  8169  4b6a 2010b5                              jsr chknyb                               ; [910930]
  8170                          ; cpx #16
  8171                          ; bcs fcerr  ;too large
  8172  4b6d 8676                                stx z_p_temp_1                           ; a temp (sorry fred)
  8173                          
  8174  4b6f ad7f12                              lda filters2+3
  8175  4b72 29f0                                and #$f0
  8176  4b74 0576                                ora z_p_temp_1
  8177  4b76 8d7f12                              sta filters2+3
  8178                          
  8179                          ; lda filters2+4  ;???? why     [910612]
  8180                          ; and #$f0
  8181                          ; ora z_p_temp_1
  8182                          ; sta filters2+4
  8183                          
  8184                          ; jsr put_io_in_map
  8185                          ; jsr go_slow  ;      [910716] 4567R7A
  8186  4b79 8d38d4                              sta sid2+24
  8187                          ; jsr go_fast  ;      [910716] 4567R7A
  8188  4b7c 60                                  rts
  8189                          
  8190                          ;.end
  8191                          ; .page
  8192                          ; .subttl  SOUND
  8193                          
  8194                          ;*****************************************************************************
  8195                          ;*
  8196                          ;*  SOUND - Produce sound effects
  8197                          ;*
  8198                          ;* Syntax : SOUND v, f, d [,[dir] [,[m] [,[s] [,[w] [,p] ]]]]
  8199                          ;*
  8200                          ;* Where : v   = voice    (1..6)
  8201                          ;*  f   = frequency    (0..65535)
  8202                          ;*  d   = duration    (0..32767 jiffys)
  8203                          ;*  dir = step direction  (0(up) ,1(down) or 2(oscillate)) default=0
  8204                          ;*  m   = minimum frequency  (if sweep is used) (0..65535) default=0
  8205                          ;*  s   = step value for effects  (0..32767) default=0
  8206                          ;*  w   = waveform  (0=triangle,1=saw,2=square,3=noise) default=2
  8207                          ;*  p   = pulse width  (0..4095) default=2048 (50% duty cycle)
  8208                          ;*
  8209                          ;*****************************************************************************
  8210                          
  8211  4b7d c99c               sound            cmp #clr_token                           ; SOUND CLR: init sound/music environment [910717]
  8212  4b7f f3d472                              +lbeq Sound_CLR                          ; yes
  8213                          
  8214  4b82 206c5d                              jsr getbyt                               ; get voice number in .X
  8215  4b85 ca                                  dex                                      ; adjust 1..3 to 0..2
  8216  4b86 e006                                cpx #6                                   ; [910612]
  8217  4b88 b37406             l115_1           +lbcs fcerr                              ; illegal value
  8218                          
  8219  4b8b 8ebd12             l115_2           stx sound_voice
  8220                          
  8221                          ; Get frequency
  8222                          
  8223  4b8e 20875d                              jsr comwrd                               ; eat comma, get frequency in y,a
  8224  4b91 8c6211                              sty temp_max_lo                          ; save our copy of max, also set up as current
  8225  4b94 8d6311                              sta temp_max_hi
  8226  4b97 8c6911                              sty temp_freq_lo
  8227  4b9a 8d6a11                              sta temp_freq_hi
  8228                          
  8229                          ; Get duration
  8230                          
  8231  4b9d 20875d                              jsr comwrd                               ; eat comma, get number of jiffys to play
  8232  4ba0 c980                                cmp #$80
  8233  4ba2 b0e4                                bcs l115_1
  8234  4ba4 8c6011                              sty temp_time_lo
  8235  4ba7 8d6111                              sta temp_time_hi
  8236                          
  8237                          ; Get sweep direction
  8238                          
  8239  4baa 202479                              jsr optzer                               ; get optional sweep (default = 0, up)
  8240  4bad e003                                cpx #3
  8241  4baf b0d7                                bcs l115_1
  8242  4bb1 8a                                  txa
  8243  4bb2 8d6611                              sta temp_direction
  8244  4bb5 2901                                and #1                                   ; set .Z if sweep up or oscillate
  8245  4bb7 08                                  php                                      ; save .Z for step (below)
  8246                          
  8247                          ; Get minimum frequency value (sweep lo)
  8248                          
  8249  4bb8 20f278                              jsr optwrd
  8250  4bbb 8c6411                              sty temp_min_lo
  8251  4bbe 8d6511                              sta temp_min_hi
  8252                          
  8253                          ; Get step value for sweep
  8254                          
  8255  4bc1 20f278                              jsr optwrd                               ; get optional step, default is zero
  8256  4bc4 28                                  plp                                      ; get flags from direction
  8257  4bc5 f00d                                beq l115_3                               ; branch if 'up' or oscillate
  8258  4bc7 48                                  pha                                      ; if 'down', make step 2's complement
  8259  4bc8 98                                  tya
  8260  4bc9 49ff                                eor #$ff
  8261  4bcb 18                                  clc
  8262  4bcc 6901                                adc #1
  8263  4bce a8                                  tay
  8264  4bcf 68                                  pla
  8265  4bd0 49ff                                eor #$ff
  8266  4bd2 6900                                adc #0
  8267  4bd4 8d6811             l115_3           sta temp_step_hi
  8268  4bd7 98                                  tya
  8269  4bd8 8d6711                              sta temp_step_lo
  8270                          
  8271                          ; Get waveform
  8272                          
  8273  4bdb a202                                ldx #2                                   ; get waveform. default is square (2)
  8274  4bdd 202679                              jsr optbyt
  8275  4be0 e004                                cpx #4
  8276  4be2 b0a4                                bcs l115_1                               ; illegal value
  8277  4be4 bd6979                              lda sbits+4,x                            ; get bit pattern for selected waveform
  8278  4be7 0901                                ora #1                                   ; add in the gate bit
  8279  4be9 8d6d11                              sta temp_waveform
  8280                          
  8281                          ; Get pulse width
  8282                          
  8283  4bec 20f278                              jsr optwrd                               ; get optional pulse width in y,a
  8284  4bef b004                                bcs l115_4
  8285  4bf1 a908                                lda #8                                   ; no arg's given, use default pulse width
  8286  4bf3 a000                                ldy #0
  8287  4bf5 c910               l115_4           cmp #16
  8288  4bf7 b08f                                bcs l115_1
  8289  4bf9 8c6b11                              sty temp_pulse_lo
  8290  4bfc 8d6c11                              sta temp_pulse_hi
  8291                          
  8292                          ; All arg's in, time to get to work
  8293                          
  8294  4bff ad6011                              lda temp_time_lo
  8295  4c02 0d6111                              ora temp_time_hi
  8296  4c05 f046                                beq l115_9                               ; special case: time=0 means 'kill it NOW'
  8297                          
  8298                          ; Wait for all current uses of this voice to time out
  8299                          
  8300  4c07 aebd12                              ldx sound_voice                          ; first test 'PLAY'
  8301  4c0a 8a                                  txa                                      ; make an index into PLAY's tables
  8302  4c0b 0a                                  asl
  8303  4c0c a8                                  tay
  8304  4c0d b95e12             l115_5           lda voices+1,y
  8305  4c10 10fb                                bpl l115_5
  8306                          
  8307  4c12 bdc412             l115_6           lda sound_time_hi,x                      ; now test 'SOUND'
  8308  4c15 10fb                                bpl l115_6
  8309                          
  8310                          ; All clear, now set up for current effect
  8311                          
  8312  4c17 a000                                ldy #0                                   ; download max freq l&h, min freq l&h,
  8313  4c19 b96211             l115_7           lda temp_max_lo,y                        ; ..sweep direction, step value l&h, & freq l&h
  8314  4c1c 9dca12                              sta sound_max_lo,x
  8315  4c1f e8                                  inx
  8316  4c20 e8                                  inx
  8317  4c21 e8                                  inx
  8318  4c22 e8                                  inx                                      ; [910612] stereo
  8319  4c23 e8                                  inx
  8320  4c24 e8                                  inx
  8321  4c25 c8                                  iny
  8322  4c26 c009                                cpy #9
  8323  4c28 90ef                                bcc l115_7
  8324                          
  8325                          ; Now set up SID
  8326                          
  8327  4c2a aebd12                              ldx sound_voice
  8328  4c2d bc004a                              ldy SID_offset,x                         ; get index to SID voices
  8329                          ; jsr put_io_in_map
  8330                          ; jsr go_slow  ;      [910716] 4567R7A
  8331                          
  8332  4c30 a908                                lda #$08                                 ; turn off SID gate
  8333  4c32 9904d4                              sta sid1+4,y
  8334                          
  8335  4c35 a900                                lda #0                                   ; set up attack & decay,
  8336  4c37 9905d4                              sta sid1+5,y
  8337  4c3a a9f0                                lda #$f0                                 ; ..and sustain & release
  8338  4c3c 9906d4                              sta sid1+6,y
  8339                          
  8340  4c3f a200                                ldx #0                                   ; set up freq (l&h), pulse width (l&h), & waveform
  8341  4c41 bd6911             l115_8           lda temp_freq_lo,x
  8342  4c44 9900d4                              sta sid1,y
  8343  4c47 c8                                  iny
  8344  4c48 e8                                  inx
  8345  4c49 e005                                cpx #5
  8346  4c4b d0f4                                bne l115_8
  8347                          ; jsr go_fast  ;      [910716] 4567R7A
  8348                          
  8349                          ; Now set up time to play
  8350                          
  8351  4c4d aebd12             l115_9           ldx sound_voice
  8352  4c50 ac6011                              ldy temp_time_lo
  8353  4c53 ad6111                              lda temp_time_hi
  8354                          
  8355  4c56 78                                  sei
  8356  4c57 9dc412                              sta sound_time_hi,x
  8357  4c5a 98                                  tya
  8358  4c5b 9dbe12                              sta sound_time_lo,x
  8359  4c5e 58                                  cli
  8360                          
  8361  4c5f 60                                  rts
  8362                          
  8363                          ;.end
  8364                          ; .page
  8365                          ; .subttl  WINDOW
  8366                          
  8367                          ;****************************************************************
  8368                          ;*
  8369                          ;*  WINDOW Command
  8370                          ;*
  8371                          ;*  Syntax : WINDOW upper-left col, upper-left row,
  8372                          ;*      lower-left col, lower-right row [,clear]
  8373                          ;*
  8374                          ;*  Where  :  0 <= row <= 24
  8375                          ;*       0 <= column <= (80/40)
  8376                          ;*       clear : 0 (no) or 1 (yes)
  8377                          ;*
  8378                          ;****************************************************************
  8379                          
  8380  4c60 206c5d             window           jsr getbyt                               ; get u.l. col
  8381  4c63 e050                                cpx #80
  8382  4c65 7fd702                              bbr7 _mode,l116_1
  8383  4c68 e028                                cpx #40
  8384  4c6a b057               l116_1           bcs l116_4
  8385  4c6c 8e7911                              stx window_temp
  8386                          
  8387  4c6f 20825d                              jsr combyt                               ; get u.l. row
  8388  4c72 e019                                cpx #25
  8389  4c74 b04d                                bcs l116_4
  8390  4c76 8e7a11                              stx window_temp+1
  8391                          
  8392  4c79 20825d                              jsr combyt                               ; get l.r. column
  8393  4c7c e050                                cpx #80
  8394  4c7e 7fd702                              bbr7 _mode,l116_2
  8395  4c81 e028                                cpx #40
  8396  4c83 b03e               l116_2           bcs l116_4
  8397  4c85 8e7b11                              stx window_temp+2
  8398  4c88 ec7911                              cpx window_temp                          ; can't be less than u.l. column
  8399  4c8b 9036                                bcc l116_4
  8400                          
  8401  4c8d 20825d                              jsr combyt                               ; get l.r. row
  8402  4c90 e019                                cpx #25
  8403  4c92 b02f                                bcs l116_4
  8404  4c94 8e7c11                              stx window_temp+3
  8405  4c97 ec7a11                              cpx window_temp+1                        ; can't be less than u.l. row
  8406  4c9a 9027                                bcc l116_4
  8407                          
  8408  4c9c 202479                              jsr optzer                               ; get optional clear flag
  8409  4c9f e002                                cpx #2
  8410  4ca1 b020                                bcs l116_4
  8411  4ca3 da                                  phx
  8412                          
  8413  4ca4 ae7911                              ldx window_temp
  8414  4ca7 ad7a11                              lda window_temp+1
  8415  4caa 18                                  clc
  8416  4cab 202de0                              jsr _set_window
  8417                          
  8418  4cae ae7b11                              ldx window_temp+2
  8419  4cb1 ad7c11                              lda window_temp+3
  8420  4cb4 38                                  sec
  8421  4cb5 202de0                              jsr _set_window
  8422                          
  8423  4cb8 a213                                ldx #19                                  ; assume 'home', not 'cls'
  8424  4cba 68                                  pla
  8425  4cbb f002                                beq l116_3
  8426  4cbd a293                                ldx #147
  8427  4cbf 8a                 l116_3           txa
  8428  4cc0 4cd2ff                              jmp _bsout
  8429                          
  8430  4cc3 833905             l116_4           +lbra fcerr                              ; illegal value error
  8431                          
  8432                          ;.end
  8433                          ; .page
  8434                          ; .subttl  FAST  SLOW
  8435                          
  8436                          ;***********************************************************************
  8437                          ;
  8438                          ;    FAST - put the system in FAST (4 MHz?) mode.
  8439                          ;
  8440                          ;***********************************************************************
  8441                          
  8442                          fast
  8443  4cc6 d382e1                              +lbne snerr                              ; no args      [910410]
  8444                          ; jsr put_io_in_map
  8445  4cc9 a940                                lda #%01000000
  8446  4ccb 0c31d0                              tsb vic+49                               ; set FAST (4MHz?) mode
  8447  4cce 60                                  rts
  8448                          
  8449                          
  8450                          
  8451                          ;***********************************************************************
  8452                          ;
  8453                          ;    SLOW - put the system in SLOW (1 MHz) mode.
  8454                          ;
  8455                          ;***********************************************************************
  8456                          
  8457                          slow
  8458  4ccf d379e1                              +lbne snerr                              ; no args      [910410]
  8459                          ; jsr put_io_in_map
  8460  4cd2 a940                                lda #%01000000
  8461  4cd4 1c31d0                              trb vic+49
  8462  4cd7 60                                  rts
  8463                          
  8464                          ;.end
  8465                          ; .page
  8466                          ; .subttl Check Value Types
  8467                          
  8468                          ; These routines check for certain VALTYP.   (c) is not preserved.
  8469                          
  8470                          
  8471                          
  8472  4cd8 20ef4c             frmnum           jsr frmevl
  8473                          
  8474  4cdb 18                 chknum           clc
  8475  4cdc 89                                  !text $89
  8476                          
  8477  4cdd 38                 chkstr           sec
  8478                          
  8479                          chkval
  8480                          ; bbs7 valtyp,docstr ;cannot do this- return status +/-/= needed!
  8481  4cde 240f                                bit valtyp
  8482  4ce0 3003                                bmi docstr
  8483  4ce2 b003                                bcs chkerr
  8484  4ce4 60                 chkok            rts
  8485                          
  8486  4ce5 b0fd               docstr           bcs chkok
  8487                          
  8488  4ce7 a216               chkerr           ldx #errtm
  8489  4ce9 2c                                  !text $2c
  8490                          
  8491  4cea a219               sterr            ldx #errst
  8492  4cec 8361e1                              +lbra error
  8493                          
  8494                          ;.end
  8495                          ; .page
  8496                          ; .subttl Formula Evaluator
  8497                          
  8498                          ; Formula Evaluator Routine
  8499                          ;
  8500                          ; The formula evaluator starts with (txtptr) pointing to the first character
  8501                          ; in the formula.  At the end (txtptr) points to the terminator.
  8502                          ; The result is left in the FAC.  On return (a) does not reflect the terminator.
  8503                          ;
  8504                          ; The formula evaluator uses the operator (optab) to determine precedence and
  8505                          ; dispatch addresses for each operator.
  8506                          ; A temporary result on the stack has the following format:
  8507                          ;
  8508                          ;     * The address of the operator routine.
  8509                          ;     * The floating point temporary result.
  8510                          ;     * The precedence of the operator.
  8511                          
  8512                          
  8513  4cef c33d               frmevl           dew txtptr                               ; txtptr points to 1st char. in formula
  8514  4cf1 a200                                ldx #0                                   ; dummy precedence = 0
  8515  4cf3 89                                  !text $89
  8516                          
  8517  4cf4 48                 lpoper           pha                                      ; save precedence
  8518  4cf5 da                                  phx
  8519  4cf6 ba                                  tsx                                      ; confirm enough system stack available (recursive calls)
  8520  4cf7 e089                                cpx #<sysstk+44                          ; bottom of stack + room for error handling
  8521  4cf9 90ef                                bcc sterr                                ; formula too complex
  8522  4cfb 20e24d                              jsr eval
  8523  4cfe a900                                lda #0
  8524  4d00 854f                                sta opmask
  8525                          
  8526  4d02 208522             tstop            jsr chrgot                               ; last char
  8527  4d05 38                 loprel           sec                                      ; prepare to subtract
  8528  4d06 e9b1                                sbc #greater_token                       ; is current character a relation?
  8529  4d08 9017                                bcc endrel                               ; no, relations all through
  8530  4d0a c903                                cmp #less_token-greater_token+1
  8531  4d0c b013                                bcs endrel                               ; really relational?  no, just big
  8532  4d0e c901                                cmp #1                                   ; reset carry for zero only
  8533  4d10 2a                                  rol                                      ; 0 to 1, 1 to 2, 2 to 4
  8534  4d11 4901                                eor #1
  8535  4d13 454f                                eor opmask                               ; bring in the old bits
  8536  4d15 c54f                                cmp opmask                               ; make sure that the new mask is bigger
  8537  4d17 9331e1                              +lbcc snerr                              ; syntax error, because two of the same
  8538  4d1a 854f                                sta opmask                               ; save mask
  8539  4d1c 208322                              jsr chrget
  8540  4d1f 80e4                                bra loprel                               ; get the next candidate
  8541                          
  8542                          ; .page
  8543  4d21 a64f               endrel           ldx opmask                               ; were there any?
  8544  4d23 d02c                                bne finrel                               ; yes, handle as special op
  8545  4d25 b39000                              +lbcs qop                                ; not an operator
  8546  4d28 6907                                adc #greater_token-plus_token
  8547  4d2a 938b00                              +lbcc qop                                ; not an operator
  8548  4d2d 650f                                adc valtyp                               ; (c)=1
  8549  4d2f f3c50d                              +lbeq cat                                ; only if (a)=0 and VALTYP=$FF (a string)
  8550                          
  8551  4d32 69ff                                adc #$ff                                 ; get back original (a)
  8552  4d34 8524                                sta index1
  8553  4d36 0a                                  asl                                      ; multiply by two
  8554  4d37 6524                                adc index1                               ; by three
  8555  4d39 a8                                  tay                                      ; set up for later
  8556                          
  8557  4d3a 68                 qprec            pla                                      ; get previous precedence
  8558  4d3b d94c29                              cmp optab,y                              ; is old precedence greater or equal?
  8559  4d3e b07c                                bcs qchnum                               ; yes, go operate
  8560  4d40 20db4c                              jsr chknum                               ; can't be string here
  8561                          
  8562  4d43 48                 doprec           pha                                      ; save old precedence
  8563                          
  8564  4d44 20644d             negprc           jsr dopre1                               ; save a return for op
  8565  4d47 68                                  pla                                      ; pull off previous precedence
  8566  4d48 a44d                                ldy opptr                                ; get pointer to op
  8567  4d4a 1011                                bpl qprec1                               ; that's a real operator
  8568  4d4c aa                                  tax                                      ; done?
  8569  4d4d f06b                                beq qopgo                                ; done!
  8570  4d4f 8074                                bra pulstk
  8571                          
  8572                          ; .page
  8573  4d51 460f               finrel           lsr valtyp                               ; get value type into (c)
  8574  4d53 8a                                  txa
  8575  4d54 2a                                  rol                                      ; put VALTYP into low order bit of mask
  8576  4d55 c33d                                dew txtptr                               ; decrement text pointer
  8577  4d57 a01b                                ldy #ptdorl-optab                        ; make (y) point at operator entry
  8578  4d59 854f                                sta opmask                               ; save the operation mask
  8579  4d5b 80dd                                bra qprec                                ; branch always
  8580                          
  8581                          
  8582                          qprec1                                                    ; note b7(VALTYP)=0 so CHKNUM call is ok
  8583  4d5d d94c29                              cmp optab,y                              ; last precedence is greater?
  8584  4d60 b063                                bcs pulstk                               ; yes, go operate
  8585  4d62 90df                                bcc doprec                               ; no, save argument and get other operand
  8586                          
  8587                          
  8588  4d64 b94e29             dopre1           lda optab+2,y
  8589  4d67 48                                  pha                                      ; disp addr goes on stack
  8590  4d68 b94d29                              lda optab+1,y
  8591  4d6b 48                                  pha
  8592  4d6c 20734d                              jsr pushf1                               ; save FAC on stack unpacked, precedence in (x)
  8593  4d6f a54f                                lda opmask                               ; (a) may be mask for rel
  8594  4d71 8081                                bra lpoper
  8595                          
  8596                          ; .page
  8597                          pushf1                                                    ; save FAC on stack unpacked
  8598  4d73 68                                  pla                                      ; first grab return address off stack
  8599  4d74 8524                                sta index1
  8600  4d76 68                                  pla
  8601  4d77 8525                                sta index1+1
  8602  4d79 e324                                inw index1
  8603                          
  8604  4d7b be4c29                              ldx optab,y                              ; precedence
  8605  4d7e a468                                ldy facsgn
  8606  4d80 5a                                  phy
  8607  4d81 20b262                              jsr round                                ; put rounded FAC on stack
  8608  4d84 a567                                lda faclo
  8609  4d86 48                                  pha
  8610  4d87 a566                                lda facmo
  8611  4d89 48                                  pha
  8612  4d8a a565                                lda facmoh
  8613  4d8c 48                                  pha
  8614  4d8d a564                                lda facho
  8615  4d8f 48                                  pha
  8616  4d90 a563                                lda facexp
  8617  4d92 48                                  pha
  8618  4d93 6c2400                              jmp (index1)                             ; return
  8619                          
  8620                          
  8621                          pullf1                                                    ; retrieve FAC from stack unpacked  [910402]
  8622  4d96 68                                  pla                                      ; first grab return address off stack
  8623  4d97 8524                                sta index1
  8624  4d99 68                                  pla
  8625  4d9a 8525                                sta index1+1
  8626  4d9c e324                                inw index1
  8627                          
  8628  4d9e a900                                lda #0                                   ; it's been rounded
  8629  4da0 8571                                sta facov
  8630  4da2 68                                  pla
  8631  4da3 8563                                sta facexp
  8632  4da5 68                                  pla
  8633  4da6 8564                                sta facho
  8634  4da8 68                                  pla
  8635  4da9 8565                                sta facmoh
  8636  4dab 68                                  pla
  8637  4dac 8566                                sta facmo
  8638  4dae 68                                  pla
  8639  4daf 8567                                sta faclo
  8640  4db1 68                                  pla
  8641  4db2 8568                                sta facsgn
  8642  4db4 6c2400                              jmp (index1)                             ; return
  8643                          
  8644                          ; .page
  8645  4db7 a0ff               qop              ldy #255
  8646  4db9 68                                  pla                                      ; get high precedence of last op
  8647  4dba f023               qopgo            beq qoprts                               ; done!
  8648                          
  8649  4dbc c964               qchnum           cmp #100                                 ; relational operator?
  8650  4dbe f003                                beq unpstk                               ; yes, don't check operand
  8651  4dc0 20db4c                              jsr chknum                               ; must be number
  8652                          
  8653  4dc3 844d               unpstk           sty opptr                                ; save operator's pointer for next time
  8654  4dc5 68                 pulstk           pla                                      ; get mask for rel op if it is one
  8655  4dc6 4a                                  lsr                                      ; setup .c for dorel's chkval
  8656  4dc7 8514                                sta domask                               ; save for "docmp"
  8657  4dc9 68                                  pla                                      ; unpack stack into arg
  8658  4dca 856a                                sta argexp
  8659  4dcc 68                                  pla
  8660  4dcd 856b                                sta argho
  8661  4dcf 68                                  pla
  8662  4dd0 856c                                sta argmoh
  8663  4dd2 68                                  pla
  8664  4dd3 856d                                sta argmo
  8665  4dd5 68                                  pla
  8666  4dd6 856e                                sta arglo
  8667  4dd8 68                                  pla
  8668  4dd9 856f                                sta argsgn
  8669  4ddb 4568                                eor facsgn                               ; get probable result sign
  8670  4ddd 8570                                sta arisgn                               ; sign used by add, sub, mul, div
  8671                          
  8672  4ddf a563               qoprts           lda facexp                               ; get it and set codes
  8673  4de1 60                                  rts                                      ; return
  8674                          ; .page
  8675  4de2 6c0a03             eval             jmp (ieval)
  8676                          
  8677  4de5 a900               neval            lda #0                                   ; assume numeric
  8678  4de7 850f                                sta valtyp
  8679                          
  8680  4de9 208322             eval0            jsr chrget                               ; get a character
  8681  4dec b005                                bcs eval2
  8682  4dee a200               eval1            ldx #0                                   ; flag 'bank 0' (text bank)
  8683  4df0 839b15                              +lbra fin                                ; it is a number
  8684                          
  8685  4df3 200250             eval2            jsr isletc                               ; variable name?
  8686  4df6 b07b                                bcs is_variable                          ; yes.
  8687  4df8 c9ff                                cmp #pi                                  ; pi?
  8688  4dfa d00a                                bne qdot
  8689  4dfc a91e                                lda #<pival
  8690  4dfe a05f                                ldy #>pival
  8691  4e00 200e62                              jsr movfm                                ; put value in for p1.
  8692  4e03 4c8322                              jmp chrget
  8693                          
  8694                          
  8695  4e06 c92e               qdot             cmp #'.'                                 ; constant?
  8696  4e08 f0e4                                beq eval1
  8697  4e0a c9ab                                cmp #minus_token                         ; negation?
  8698  4e0c f05e                                beq domin                                ; yes.
  8699  4e0e c9aa                                cmp #plus_token
  8700  4e10 f0d7                                beq eval0
  8701  4e12 c922                                cmp #'"'                                 ; string?
  8702  4e14 d015                                bne eval3
  8703                          
  8704  4e16 a53d               strtxt           lda txtptr
  8705  4e18 a43e                                ldy txtptr+1
  8706  4e1a 6900                                adc #0                                   ; c=1
  8707  4e1c 9001                                bcc strtx2
  8708  4e1e c8                                  iny
  8709  4e1f 20855a             strtx2           jsr strlit                               ; process string
  8710                          
  8711  4e22 a672               st2txt           ldx strng2
  8712  4e24 a473                                ldy strng2+1
  8713  4e26 863d                                stx txtptr
  8714  4e28 843e                                sty txtptr+1
  8715  4e2a 60                                  rts
  8716                          
  8717                          ; .page
  8718  4e2b c9a8               eval3            cmp #not_token                           ; not?
  8719  4e2d d016                                bne eval4
  8720  4e2f a018                                ldy #24
  8721  4e31 d03b                                bne gonprc                               ; branch always
  8722                          
  8723                          
  8724  4e33 20b458             notop            jsr ayint                                ; integerize
  8725  4e36 a567                                lda faclo                                ; get argument
  8726  4e38 49ff                                eor #$ff
  8727  4e3a a8                                  tay
  8728  4e3b a566                                lda facmo
  8729  4e3d 49ff                                eor #$ff
  8730                          
  8731  4e3f 20d758             givayf           jsr stoint                               ; integer to float routine
  8732  4e42 839614                              +lbra floats
  8733                          
  8734                          
  8735  4e45 c9a5               eval4            cmp #fn_token                            ; user defined function?
  8736  4e47 f3ec0a                              +lbeq fndoer                             ; yes
  8737  4e4a c9b4                                cmp #first_function_token                ; function name?
  8738  4e4c b3bfde                              +lbcs isfun                              ; yes
  8739                          ; (functions are the highest numbered
  8740                          ; tokens so no need to check further)
  8741                          ; .page
  8742  4e4f 20584e             parchk           jsr chkopn                               ; only thing left is formula in parens
  8743  4e52 20ef4c                              jsr frmevl                               ; a formula in parens
  8744                          
  8745  4e55 a929               chkcls           lda #')'                                 ; close paren?
  8746  4e57 2c                                  !text $2c
  8747                          
  8748  4e58 a928               chkopn           lda #'('                                 ; open paren?
  8749  4e5a 2c                                  !text $2c
  8750                          
  8751  4e5b a92c               chkcom           lda #','                                 ; comma?
  8752                          
  8753                          
  8754                          ; SYNCHR looks at the current character to make sure it is the specific
  8755                          ; thing loaded into (a) just before the call to SYNCHR.  If not, it calls
  8756                          ; the "syntax error" routine.  Otherwise it gobbles the next char and returns.
  8757                          ;
  8758                          ; (a)=new char and TXTPTR is advanced by CHRGET.
  8759                          
  8760                          
  8761  4e5d a000               synchr           ldy #0
  8762  4e5f 8578                                sta syntmp
  8763  4e61 20c522                              jsr indtxt
  8764  4e64 c578                                cmp syntmp
  8765  4e66 d3e2df                              +lbne snerr
  8766  4e69 4c8322                              jmp chrget                               ; ok
  8767                          
  8768                          
  8769                          
  8770                          domin
  8771                          l117_1           =negtab-optab                            ; negoff
  8772  4e6c a015                                ldy #l117_1                              ; precedence below '-'
  8773                          
  8774  4e6e 68                 gonprc           pla                                      ; get rid of rts addr.
  8775  4e6f 68                                  pla
  8776  4e70 83d2fe                              +lbra negprc                             ; do negation
  8777                          
  8778                          ;.end
  8779                          ; .page
  8780                          ; .subttl Variable Assignment
  8781                          
  8782                          is_variable
  8783  4e73 207c4f                              jsr ptrget                               ; parse variable name, put name in varnam
  8784                          
  8785  4e76 8566               isvret           sta facmo                                ; save pointer to variable
  8786  4e78 8467                                sty facmo+1
  8787  4e7a a647                                ldx varnam
  8788  4e7c a448                                ldy varnam+1
  8789  4e7e a50f                                lda valtyp
  8790  4e80 f050                                beq is_numeric                           ; branch if numeric
  8791                          
  8792  4e82 a900                                lda #0
  8793  4e84 8571                                sta facov
  8794  4e86 e054                                cpx #'T'                                 ; TI$ is a special case. look for it
  8795  4e88 d013                                bne isvds                                ; no- go test for DS$
  8796  4e8a c0c9                                cpy #'I'+$80                             ; shifted I?
  8797  4e8c d043                                bne ds_rts                               ; no- and it's not DS$ either
  8798                          
  8799                          ; Variable name is TI$.  To see if this is 'the' TI$ and not an
  8800                          ; array TI$(), test to see if it has a pointer to the zero in "ROM".
  8801                          ; If it is an array item, its pointer will be to a real value, or
  8802                          ; a real zero.  If it isn't an array item, its pointer will point
  8803                          ; to a dummy zero in "ROM".
  8804                          
  8805  4e8e a567                                lda facmo+1
  8806  4e90 c902                                cmp #>zero
  8807  4e92 d03d                                bne ds_rts                               ; not TI$, not DS$
  8808  4e94 a566                                lda facmo
  8809  4e96 c9c4                                cmp #<zero
  8810  4e98 d037                                bne ds_rts
  8811  4e9a 835905                              +lbra Get_TI_String                      ; the one and only TI$
  8812                          
  8813                          ; .page
  8814  4e9d e044               isvds            cpx #'D'                                 ; is this DS$?
  8815  4e9f d030                                bne ds_rts                               ; no
  8816  4ea1 c0d3                                cpy #'S'+$80                             ; shifted S?
  8817  4ea3 d02c                                bne ds_rts                               ; no
  8818                          
  8819  4ea5 200e78                              jsr Check_DS                             ; yes- check DS$ allocation,
  8820                          ;  and get it if not in memory
  8821  4ea8 a0ff                                ldy #$ff
  8822  4eaa c8                 l118_1           iny                                      ; copy DS$ to a temp.
  8823  4eab a97a                                lda #dsdesc+1                            ; must first determine how big it is
  8824  4ead 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
  8825  4eb0 d0f8                                bne l118_1                               ; loop until terminating null found
  8826                          
  8827  4eb2 98                                  tya                                      ; length of string required
  8828  4eb3 20735a                              jsr strini                               ; get temp. string space & descriptor
  8829  4eb6 a8                                  tay
  8830  4eb7 f015                                beq l118_3                               ; (don't bother copying if length is 0)
  8831                          
  8832  4eb9 da                                  phx
  8833                          
  8834  4eba a264                                ldx #dsctmp+1                            ; ???? was ldx #frespc
  8835  4ebc a97a               l118_2           lda #dsdesc+1                            ; copy DS$ into temp
  8836  4ebe 88                                  dey
  8837  4ebf 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
  8838  4ec2 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
  8839  4ec5 98                                  tya
  8840  4ec6 d0f4                                bne l118_2
  8841  4ec8 fa                                  plx
  8842  4ec9 a579                                lda dsdesc                               ; a=length     [901014] FAB
  8843  4ecb 205d5b                              jsr mvdone                               ; ???? (does nothing on C128 - bug or oversight?)
  8844                          
  8845  4ece 83000c             l118_3           +lbra putnew
  8846                          
  8847  4ed1 60                 ds_rts           rts
  8848                          
  8849                          ; .page
  8850                          is_numeric
  8851  4ed2 7f100f                              bbr7 intflg,is_floating                  ; branch if not an integer
  8852  4ed5 a000                                ldy #0
  8853  4ed7 20a922                              jsr indfmo                               ; fetch high
  8854  4eda aa                                  tax
  8855  4edb c8                                  iny
  8856  4edc 20a922                              jsr indfmo                               ; fetch low
  8857  4edf a8                                  tay                                      ; put low in y
  8858  4ee0 8a                                  txa                                      ; get high in a
  8859  4ee1 835cff                              +lbra givayf                             ; float and return
  8860                          
  8861                          
  8862                          ; Screen out TI, ST, ER, and EL, and assign values to them.  First test
  8863                          ; if the pointer points to "ROM" zero.  If not, it can't be any of the above.
  8864                          
  8865                          is_floating
  8866  4ee4 a567                                lda facmo+1
  8867  4ee6 c902                                cmp #>zero
  8868  4ee8 d064                                bne gomovf                               ; not TI, etc.
  8869  4eea a566                                lda facmo
  8870  4eec c9c4                                cmp #<zero
  8871  4eee d05e                                bne gomovf                               ; not TI, etc.
  8872                          
  8873                          ; .page
  8874                          ; The pointer does point to the ROM zero.  Now it is necessary to
  8875                          ; examine the actual variable name case by case.
  8876                          
  8877  4ef0 e054                                cpx #'T'                                 ; TI?
  8878  4ef2 d007                                bne qstatv                               ; no
  8879  4ef4 c049                                cpy #'I'
  8880  4ef6 d056                                bne gomovf                               ; no, and it can't be ST either
  8881  4ef8 f34805                              +lbeq Get_TI
  8882                          
  8883                          
  8884  4efb e053               qstatv           cpx #'S'                                 ; ST?
  8885  4efd d00a                                bne qdsav                                ; no, go test DS
  8886  4eff c054                                cpy #'T'
  8887  4f01 d04b                                bne gomovf
  8888  4f03 20b7ff                              jsr _readst                              ; (???? system bank for rs232 st)
  8889  4f06 83ca13                              +lbra float
  8890                          
  8891                          
  8892  4f09 e044               qdsav            cpx #'D'                                 ; DS?
  8893  4f0b d026                                bne qerlin                               ; no, go test ER & EL
  8894  4f0d c053                                cpy #'S'
  8895  4f0f d03d                                bne gomovf
  8896                          
  8897                          ; Get disk status - make the first two characters of DS$ string into a number.
  8898                          
  8899  4f11 200e78                              jsr Check_DS                             ; get a DS$ string if one doesn't exist already
  8900  4f14 a000                                ldy #0
  8901  4f16 a97a                                lda #dsdesc+1
  8902  4f18 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
  8903  4f1b 290f                                and #$0f
  8904  4f1d 0a                                  asl
  8905  4f1e 8511                                sta garbfl
  8906  4f20 0a                                  asl
  8907  4f21 0a                                  asl
  8908  4f22 6511                                adc garbfl
  8909  4f24 8511                                sta garbfl
  8910  4f26 c8                                  iny
  8911  4f27 a97a                                lda #dsdesc+1
  8912  4f29 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
  8913  4f2c 290f                                and #$0f
  8914  4f2e 6511                                adc garbfl
  8915  4f30 83a013                              +lbra float
  8916                          
  8917                          
  8918  4f33 e045               qerlin           cpx #'E'                                 ; ER or EL?
  8919  4f35 d017                                bne gomovf
  8920  4f37 c052                                cpy #'R'
  8921  4f39 f00d                                beq qnumer
  8922  4f3b c04c                                cpy #'L'
  8923  4f3d d00f                                bne gomovf
  8924                          
  8925  4f3f adc902                              lda errlin+1                             ; want EL (last error line #)
  8926  4f42 acc802                              ldy errlin
  8927  4f45 838009                              +lbra nosflt
  8928                          
  8929  4f48 adc702             qnumer           lda errnum                               ; want ER (number of last error)
  8930  4f4b 838513                              +lbra float
  8931                          
  8932                          ; .page
  8933  4f4e a566               gomovf           lda facmo
  8934  4f50 a467                                ldy facmo+1
  8935                          
  8936  4f52 8524               movfrm           sta index1                               ; move value from RAM
  8937  4f54 8425                                sty index1+1
  8938                          
  8939  4f56 a000                                ldy #0
  8940  4f58 20d522                              jsr indin1_ram1
  8941  4f5b 8563                                sta facexp
  8942  4f5d 8471                                sty facov
  8943                          
  8944  4f5f c8                                  iny                                      ; (1)
  8945  4f60 20d522                              jsr indin1_ram1
  8946  4f63 8568                                sta facsgn
  8947  4f65 0980                                ora #$80
  8948  4f67 8564                                sta facho
  8949                          
  8950  4f69 c8                                  iny                                      ; (2)
  8951  4f6a 20d522                              jsr indin1_ram1
  8952  4f6d 8565                                sta facmoh
  8953                          
  8954  4f6f c8                                  iny                                      ; (3)
  8955  4f70 20d522                              jsr indin1_ram1
  8956  4f73 8566                                sta facmo
  8957                          
  8958  4f75 c8                                  iny                                      ; (4)
  8959  4f76 20d522                              jsr indin1_ram1
  8960  4f79 8567                                sta faclo
  8961  4f7b 60                                  rts
  8962                          
  8963                          ;.end
  8964                          ; .page
  8965                          ; .subttl Variable Search
  8966                          
  8967                          ;  Read the variable name at the current text position and put a pointer
  8968                          ;  to its value in VARPNT.   TXTPTR points to the terminating character.
  8969                          ;  Note that evaluating subscripts in a variable name can cause recursive
  8970                          ;  calls to PTRGET, so all values must be stored on the stack.
  8971                          
  8972  4f7c a200               ptrget           ldx #0
  8973  4f7e 208522                              jsr chrgot
  8974  4f81 860e               ptrgt1           stx dimflg                               ; store flag away
  8975  4f83 8547               ptrgt2           sta varnam
  8976  4f85 208522                              jsr chrgot                               ; get current character
  8977  4f88 200250                              jsr isletc                               ; check for a letter
  8978  4f8b 93bdde                              +lbcc snerr                              ; not a letter
  8979                          
  8980  4f8e a200                                ldx #0                                   ; assume no second character
  8981  4f90 860f                                stx valtyp                               ; default is numeric
  8982  4f92 8610                                stx intflg                               ; assume floating
  8983  4f94 208322                              jsr chrget                               ; get following character
  8984  4f97 9005                                bcc l119_1                               ; branch if numeric
  8985  4f99 200250                              jsr isletc                               ; is it alpha?
  8986  4f9c 900b                                bcc l119_3                               ; no, no second character. branch
  8987  4f9e aa                 l119_1           tax                                      ; issec. save second character of name
  8988                          
  8989  4f9f 208322             l119_2           jsr chrget                               ; skip over remainder of name. we only care about 2 chars.
  8990  4fa2 90fb                                bcc l119_2                               ; ..eat numbers,
  8991  4fa4 200250                              jsr isletc
  8992  4fa7 b0f6                                bcs l119_2                               ; ..and alphas, too!
  8993                          
  8994  4fa9 c924               l119_3           cmp #'$'                                 ; nosec. is this a string?
  8995  4fab d006                                bne l119_4                               ; if not, VALTYP = 0
  8996  4fad a9ff                                lda #$ff
  8997  4faf 850f                                sta valtyp                               ; ..else, flag 'string'
  8998  4fb1 800f                                bra l119_5
  8999                          
  9000  4fb3 c925               l119_4           cmp #'%'                                 ; notstr. isn't string. is it integer?
  9001  4fb5 d012                                bne l119_6                               ; branch if not
  9002  4fb7 a512                                lda subflg
  9003                          ; bne snerr ; syntax error if integers disabled
  9004  4fb9 d32cfd                              +lbne chkerr                             ; integers disallowed- type mismatch error  [910114]
  9005  4fbc a980                                lda #$80                                 ; flag integer by turning on both high bits
  9006  4fbe 8510                                sta intflg
  9007  4fc0 0447                                tsb varnam
  9008                          
  9009  4fc2 8a                 l119_5           txa                                      ; turnon. turn on msb of second character
  9010  4fc3 0980                                ora #$80
  9011  4fc5 aa                                  tax
  9012  4fc6 208322                              jsr chrget                               ; get character after $ or %
  9013                          
  9014  4fc9 8648               l119_6           stx varnam+1                             ; strnam. store away second character
  9015  4fcb 38                                  sec
  9016  4fcc 0512                                ora subflg                               ; add flag whether to allow arrays
  9017  4fce e928                                sbc #'('
  9018  4fd0 f3b101                              +lbeq is_array                           ; note: won't match if SUBFLG set
  9019                          
  9020  4fd3 a000                                ldy #0
  9021  4fd5 8412                                sty subflg                               ; allow subscripts again
  9022  4fd7 a52f                                lda vartab                               ; place to start search
  9023  4fd9 a630                                ldx vartab+1
  9024                          
  9025  4fdb 8662               l119_7           stx lowtr+1                              ; stxfnd.
  9026  4fdd 8561               l119_8           sta lowtr
  9027  4fdf e432                                cpx arytab+1                             ; at end of table yet?
  9028  4fe1 d004                                bne l119_9
  9029  4fe3 c531                                cmp arytab
  9030  4fe5 f025                                beq notfns                               ; yes, we couldn't find it
  9031                          
  9032  4fe7 20bd22             l119_9           jsr indlow_ram1                          ; lda (lowtr),y
  9033  4fea c547                                cmp varnam                               ; compare high orders
  9034  4fec d00a                                bne l119_10
  9035  4fee c8                                  iny
  9036  4fef 20bd22                              jsr indlow_ram1
  9037  4ff2 c548                                cmp varnam+1                             ; and the low part?
  9038  4ff4 f32f01                              +lbeq finptr                             ; !!that's it!!
  9039                          
  9040  4ff7 88                                  dey
  9041  4ff8 18                 l119_10          clc
  9042  4ff9 a561                                lda lowtr
  9043  4ffb 6907                                adc #7                                   ; makes no difference among types
  9044  4ffd 90de                                bcc l119_8
  9045  4fff e8                                  inx
  9046  5000 80d9                                bra l119_7                               ; branch always
  9047                          
  9048                          
  9049                          
  9050                          
  9051                          ; Test for a letter: (c)=0 not a letter
  9052                          ;   (c)=1 a letter
  9053                          
  9054  5002 c941               isletc           cmp #'A'
  9055  5004 9005                                bcc l120_1                               ; if less than "a", return
  9056  5006 e95b                                sbc #'Z'+1                               ; $5a + 1
  9057  5008 38                                  sec
  9058  5009 e9a5                                sbc #$a5                                 ; reset carry if (a) .gt. "z".
  9059  500b 60                 l120_1           rts
  9060                          
  9061                          
  9062  500c ba                 notfns           tsx                                      ; check who's calling????
  9063  500d bd0201                              lda $102,x                               ; sniff processor stack
  9064  5010 c957                                cmp #>pointer_ret
  9065  5012 f004                                beq ldzr                                 ; special case if called by pointer function
  9066                          
  9067                          l121_1           = isvret-1
  9068  5014 c94e                                cmp #>l121_1                             ; is eval calling????
  9069  5016 d02a                                bne notevl                               ; no, carry on
  9070                          
  9071  5018 a9c4               ldzr             lda #<zero                               ; set up pointer to simulated zero
  9072  501a a002                                ldy #>zero
  9073  501c 60                                  rts                                      ; for strings or numeric
  9074                          
  9075                          
  9076  501d c0c9               qst001           cpy #'I'+$80                             ; we know first is T, is second <shift>I (TI$)?
  9077  501f f0f7                                beq ldzr
  9078  5021 c049                                cpy #'I'                                 ; or I (TI)?
  9079  5023 d031                                bne varok
  9080  5025 f018                                beq gobadv
  9081                          
  9082                          
  9083  5027 c0d3               qst004           cpy #'S'+$80                             ; check for DS$
  9084  5029 f014                                beq gobadv
  9085  502b c053                                cpy #'S'                                 ; check for DS
  9086  502d d027                                bne varok
  9087  502f f00e                                beq gobadv
  9088                          
  9089                          
  9090  5031 c054               qst002           cpy #'T'                                 ; check for ST
  9091  5033 d021                                bne varok
  9092  5035 f008                                beq gobadv
  9093                          
  9094                          
  9095  5037 c052               qst003           cpy #'R'                                 ; check for ER
  9096  5039 f004                                beq gobadv
  9097  503b c04c                                cpy #'L'                                 ; check for EL
  9098  503d d017                                bne varok
  9099                          
  9100                          
  9101  503f 8309de             gobadv           +lbra snerr
  9102                          
  9103                          
  9104                          
  9105  5042 a547               notevl           lda varnam
  9106  5044 a448                                ldy varnam+1
  9107  5046 c954                                cmp #'T'                                 ; screen out TI
  9108  5048 f0d3                                beq qst001
  9109  504a c953                                cmp #'S'                                 ; ...and ST
  9110  504c f0e3                                beq qst002
  9111  504e c945                                cmp #'E'                                 ; ...and ER and EL
  9112  5050 f0e5                                beq qst003
  9113  5052 c944                                cmp #'D'                                 ; ...and DS
  9114  5054 f0d1                                beq qst004
  9115                          
  9116                          
  9117  5056 a531               varok            lda arytab
  9118  5058 a432                                ldy arytab+1
  9119  505a 8561                                sta lowtr
  9120  505c 8462                                sty lowtr+1
  9121  505e a533                                lda strend
  9122  5060 a434                                ldy strend+1
  9123  5062 855c                                sta hightr
  9124  5064 845d                                sty hightr+1
  9125  5066 18                                  clc
  9126  5067 6907                                adc #7
  9127  5069 9001                                bcc l122_1                               ; not even
  9128  506b c8                                  iny
  9129                          
  9130  506c 855a               l122_1           sta highds
  9131  506e 845b                                sty highds+1
  9132  5070 203451                              jsr bltu
  9133  5073 a55a                                lda highds
  9134  5075 a45b                                ldy highds+1
  9135  5077 c8                                  iny
  9136  5078 8531                                sta arytab
  9137  507a 8432                                sty arytab+1
  9138                          
  9139                          
  9140                          ; Scan thru array entries for string arrays.  If any are found it will be
  9141                          ; necessary to adjust the back-links of the strings in that array, since
  9142                          ; the array descriptor block itself was moved.
  9143                          
  9144  507c 855a                                sta arypnt                               ; set pointer to arrays
  9145  507e 845b                                sty arypnt+1
  9146                          
  9147  5080 a55a               aryva2           lda arypnt
  9148  5082 a65b                                ldx arypnt+1
  9149                          
  9150  5084 e434               aryva3           cpx strend+1                             ; end of arrays?
  9151  5086 d004                                bne aryvgo
  9152  5088 c533                                cmp strend
  9153  508a f07e                                beq arydon                               ; ...finished
  9154                          
  9155                          
  9156  508c 8524               aryvgo           sta index1
  9157  508e 8625                                stx index1+1
  9158  5090 a000                                ldy #0
  9159  5092 20d522                              jsr indin1_ram1                          ; look at array name
  9160  5095 aa                                  tax
  9161  5096 c8                                  iny
  9162  5097 20d522                              jsr indin1_ram1                          ; name 2nd char
  9163  509a 08                                  php                                      ; save status reg
  9164  509b c8                                  iny
  9165  509c 20d522                              jsr indin1_ram1                          ; point to offset to next array
  9166  509f 655a                                adc arypnt
  9167  50a1 855a                                sta arypnt                               ; save start of next array in arypnt
  9168  50a3 c8                                  iny
  9169  50a4 20d522                              jsr indin1_ram1
  9170  50a7 655b                                adc arypnt+1
  9171  50a9 855b                                sta arypnt+1
  9172  50ab 28                                  plp                                      ; restore status
  9173  50ac 10d2                                bpl aryva2                               ; not a string type
  9174  50ae 8a                                  txa
  9175  50af 30cf                                bmi aryva2                               ; not a string array
  9176  50b1 c8                                  iny                                      ; ok we have a string array
  9177  50b2 20d522                              jsr indin1_ram1                          ; get number of dimensions
  9178  50b5 a000                                ldy #0
  9179  50b7 0a                                  asl                                      ; move index to ptr to 1st string (add 2*number of dims + 5)
  9180  50b8 6905                                adc #5
  9181  50ba 6524                                adc index1
  9182  50bc 8524                                sta index1
  9183  50be 9002                                bcc aryget
  9184  50c0 e625                                inc index1+1
  9185                          
  9186  50c2 a625               aryget           ldx index1+1
  9187  50c4 e45b                                cpx arypnt+1                             ; done with this array?
  9188  50c6 d004                                bne l123_1
  9189  50c8 c55a                                cmp arypnt
  9190  50ca f0b8                                beq aryva3                               ; yes
  9191                          
  9192  50cc a000               l123_1           ldy #0                                   ; process string pointer
  9193  50ce 20d522                              jsr indin1_ram1                          ; get length of string
  9194  50d1 f02a                                beq dvarts                               ; skip if null string
  9195  50d3 8578                                sta syntmp
  9196  50d5 c8                                  iny
  9197  50d6 20d522                              jsr indin1_ram1                          ; get lo byte of string ptr
  9198  50d9 18                                  clc
  9199  50da 6578                                adc syntmp                               ; and add string length
  9200  50dc 855c                                sta hightr
  9201  50de c8                                  iny
  9202  50df 20d522                              jsr indin1_ram1                          ; get hi byte of string ptr
  9203  50e2 6900                                adc #0                                   ; adjust high byte
  9204  50e4 855d                                sta hightr+1
  9205                          
  9206                          ; Fix backwards pointer by adding move length to it.
  9207                          
  9208  50e6 da                                  phx
  9209  50e7 a25c                                ldx #hightr
  9210  50e9 a000                                ldy #0
  9211  50eb 20a522                              jsr indhtr_ram1                          ; lda (hightr),y
  9212  50ee 6907                                adc #7                                   ; carry clear (careful!)
  9213  50f0 20f022                              jsr sta_far_ram1                         ; sta (hightr),y
  9214  50f3 c8                                  iny
  9215  50f4 20a522                              jsr indhtr_ram1                          ; lda (hightr),y
  9216  50f7 6900                                adc #0
  9217  50f9 20f022                              jsr sta_far_ram1                         ; sta (hightr),y
  9218  50fc fa                                  plx                                      ; done with this string
  9219                          
  9220                          ; Fix the next string in the array
  9221                          
  9222  50fd a903               dvarts           lda #strsiz
  9223  50ff 18                                  clc
  9224  5100 6524                                adc index1
  9225  5102 8524                                sta index1
  9226  5104 90bc                                bcc aryget
  9227  5106 e625                                inc index1+1
  9228  5108 80b8                                bra aryget                               ; branch always
  9229                          
  9230                          
  9231  510a da                 arydon           phx
  9232  510b a261                                ldx #lowtr
  9233  510d a000                                ldy #0
  9234  510f a547                                lda varnam
  9235  5111 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9236  5114 c8                                  iny                                      ; .y=1
  9237  5115 a548                                lda varnam+1
  9238  5117 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9239  511a a900                                lda #0
  9240  511c c8                 l124_1           iny
  9241  511d 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9242  5120 c006                                cpy #6
  9243  5122 d0f8                                bne l124_1
  9244  5124 fa                                  plx
  9245                          
  9246  5125 a561               finptr           lda lowtr
  9247  5127 18                                  clc
  9248  5128 6902                                adc #2
  9249  512a a462                                ldy lowtr+1
  9250  512c 9001                                bcc l125_1
  9251  512e c8                                  iny
  9252  512f 8549               l125_1           sta varpnt
  9253  5131 844a                                sty varpnt+1
  9254  5133 60                                  rts
  9255                          
  9256                          
  9257                          
  9258                          
  9259  5134 20af31             bltu             jsr reason
  9260  5137 8533                                sta strend
  9261  5139 8434                                sty strend+1
  9262  513b 38                                  sec
  9263  513c a55c                                lda hightr
  9264  513e e561                                sbc lowtr
  9265  5140 8524                                sta index
  9266  5142 a8                                  tay
  9267  5143 a55d                                lda hightr+1
  9268  5145 e562                                sbc lowtr+1
  9269  5147 aa                                  tax
  9270  5148 e8                                  inx
  9271  5149 98                                  tya
  9272  514a f02f                                beq decblt
  9273  514c a55c                                lda hightr
  9274  514e 38                                  sec
  9275  514f e524                                sbc index
  9276  5151 855c                                sta hightr
  9277  5153 b003                                bcs l126_1
  9278  5155 c65d                                dec hightr+1
  9279  5157 38                                  sec
  9280  5158 a55a               l126_1           lda highds
  9281  515a e524                                sbc index
  9282  515c 855a                                sta highds
  9283  515e b00e                                bcs moren1
  9284  5160 c65b                                dec highds+1
  9285  5162 900a                                bcc moren1
  9286                          
  9287  5164 20a522             bltlp            jsr indhtr_ram1                          ; lda (hightr),y
  9288  5167 da                                  phx
  9289  5168 a25a                                ldx #highds
  9290  516a 20f022                              jsr sta_far_ram1                         ; sta (highds),y
  9291  516d fa                                  plx
  9292                          
  9293  516e 88                 moren1           dey
  9294  516f d0f3                                bne bltlp
  9295  5171 20a522                              jsr indhtr_ram1                          ; lda (hightr),y
  9296  5174 da                                  phx
  9297  5175 a25a                                ldx #highds
  9298  5177 20f022                              jsr sta_far_ram1                         ; sta (highds),y
  9299  517a fa                                  plx
  9300                          
  9301  517b c65d               decblt           dec hightr+1
  9302  517d c65b                                dec highds+1
  9303  517f ca                                  dex
  9304  5180 d0ec                                bne moren1
  9305  5182 60                                  rts
  9306                          
  9307                          ;.end
  9308                          ; .page
  9309                          ; .subttl Array Routines
  9310                          
  9311                          ; The format of arrays in core:
  9312                          ;
  9313                          ; Descriptor: low  byte = first character
  9314                          ;   high byte = second character (msb is string flag)
  9315                          ; Length of array in memory in bytes (includes everything).
  9316                          ; Number of dimensions.
  9317                          ; For each dimension starting with the first a list (2 bytes each)
  9318                          ; of the max indice+1.
  9319                          ; The values.
  9320                          
  9321                          
  9322                          is_array
  9323  5183 a50e                                lda dimflg
  9324  5185 0510                                ora intflg
  9325  5187 48                                  pha                                      ; save DIMFLG for recursion
  9326  5188 a50f                                lda valtyp
  9327  518a 48                                  pha                                      ; save VALTYP for recursion
  9328  518b a000                                ldy #0                                   ; set number of dimensions to zero
  9329                          
  9330  518d 5a                 l127_1           phy                                      ; save number of dims
  9331  518e a548                                lda varnam+1
  9332  5190 48                                  pha
  9333  5191 a547                                lda varnam
  9334  5193 48                                  pha                                      ; save looks
  9335  5194 20a758                              jsr intidx                               ; evaluate indice into facmo&lo
  9336  5197 68                                  pla
  9337  5198 8547                                sta varnam
  9338  519a 68                                  pla
  9339  519b 8548                                sta varnam+1                             ; get back all...we're home
  9340  519d 7a                                  ply                                      ; (# of units)
  9341  519e ba                                  tsx
  9342  519f bd0201                              lda 258,x
  9343  51a2 48                                  pha                                      ; push DIMFLG and VALTYP further
  9344  51a3 bd0101                              lda 257,x
  9345  51a6 48                                  pha
  9346  51a7 a566                                lda indice                               ; put indice onto stack
  9347  51a9 9d0201                              sta 258,x                                ; under DIMFLG and VALTYP
  9348  51ac a567                                lda indice+1
  9349  51ae 9d0101                              sta 257,x
  9350  51b1 c8                                  iny                                      ; y counts # of subscripts
  9351  51b2 840d                                sty count                                ; protect y from chrget
  9352  51b4 208522                              jsr chrgot                               ; get terminating character
  9353  51b7 a40d                                ldy count
  9354  51b9 c92c                                cmp #','                                 ; more subscripts?
  9355  51bb f0d0                                beq l127_1                               ; yes
  9356                          
  9357                          
  9358  51bd 20554e                              jsr chkcls                               ; must be closed paren
  9359  51c0 68                                  pla
  9360  51c1 850f                                sta valtyp                               ; get VALTYP and
  9361  51c3 68                                  pla
  9362  51c4 8510                                sta intflg
  9363  51c6 297f                                and #$7f
  9364  51c8 850e                                sta dimflg                               ; DIMFLG off stack
  9365  51ca a631                                ldx arytab                               ; place to start search
  9366  51cc a532                                lda arytab+1
  9367                          
  9368                          
  9369  51ce 8661               l127_2           stx lowtr
  9370  51d0 8562                                sta lowtr+1
  9371  51d2 c534                                cmp strend+1                             ; end of arrays?
  9372  51d4 d004                                bne l127_3
  9373  51d6 e433                                cpx strend
  9374  51d8 f043                                beq notfdd                               ; a fine thing! no array!
  9375                          
  9376  51da a000               l127_3           ldy #0
  9377  51dc 20bd22                              jsr indlow_ram1                          ; get high of name from array bank (ram1)
  9378  51df c8                                  iny
  9379  51e0 c547                                cmp varnam                               ; compare high orders.
  9380  51e2 d007                                bne l127_4                               ; no way is it this. get the bite outta here
  9381  51e4 20bd22                              jsr indlow_ram1
  9382  51e7 c548                                cmp varnam+1                             ; low orders?
  9383  51e9 f018                                beq gotary                               ; well here it is
  9384                          
  9385  51eb c8                 l127_4           iny
  9386  51ec 20bd22                              jsr indlow_ram1                          ; get length
  9387  51ef 18                                  clc
  9388  51f0 6561                                adc lowtr
  9389  51f2 aa                                  tax
  9390  51f3 c8                                  iny
  9391  51f4 20bd22                              jsr indlow_ram1
  9392  51f7 6562                                adc lowtr+1
  9393  51f9 90d3                                bcc l127_2                               ; always branches
  9394                          
  9395                          
  9396  51fb a212               bserr            ldx #errbs                               ; get bad sub error number
  9397  51fd 2c                                  !text $2c
  9398                          
  9399  51fe a20e               fcerr            ldx #errfc                               ; too big. Illegal Quantity error
  9400  5200 834ddc                              +lbra error
  9401                          
  9402                          
  9403                          
  9404  5203 a213               gotary           ldx #errdd                               ; perhaps a "re-dimension" error
  9405  5205 a50e                                lda dimflg                               ; test the DIMFLG
  9406  5207 d346dc                              +lbne error
  9407  520a 206c53                              jsr fmaptr
  9408  520d a004                                ldy #4
  9409  520f 20bd22                              jsr indlow_ram1
  9410  5212 8578                                sta syntmp
  9411  5214 a50d                                lda count                                ; get number of dims input.
  9412  5216 c578                                cmp syntmp                               ; # of dims the same?
  9413  5218 d0e1                                bne bserr                                ; same so get definition.
  9414  521a 83b300                              +lbra getdef
  9415                          
  9416                          ; .page
  9417                          ; Come here when variable is not found in the array table to build an entry.
  9418                          ;
  9419                          ; Put down the descriptor.
  9420                          ; Setup number of dimensions.
  9421                          ; Make sure there is room for the new entry.
  9422                          ; Remember VARPNT.
  9423                          ; Tally=4.
  9424                          ; Skip two locs for later fill in of size.
  9425                          ; LOOP: Get an indice.
  9426                          ;  Put down number+1 and increment VARPTR.
  9427                          ;  Tally=tally*number+1
  9428                          ;  Decrement number of dims.
  9429                          ;  Bne LOOP
  9430                          ; Call REASON with (a,b) reflecting last loc of variable.
  9431                          ; Update STREND
  9432                          ; Zero all.
  9433                          ; Make tally include maxdims and descriptor.
  9434                          ; Put down tally
  9435                          ; If called by dimension, return.
  9436                          ;  Else index into the variable as if it were found on the initial search.
  9437                          
  9438                          notfdd
  9439  521d 206c53                              jsr fmaptr                               ; form ARYPNT
  9440  5220 20af31                              jsr reason
  9441  5223 a000                                ldy #0
  9442  5225 8473                                sty curtol+1
  9443  5227 a205                                ldx #5
  9444  5229 a547                                lda varnam
  9445  522b 08                                  php
  9446  522c da                                  phx
  9447  522d a261                                ldx #lowtr                               ; point to string/array bank
  9448  522f 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9449  5232 fa                                  plx
  9450  5233 28                                  plp
  9451  5234 1001                                bpl l128_1
  9452  5236 ca                                  dex
  9453                          
  9454  5237 c8                 l128_1           iny                                      ; notflt.
  9455  5238 a548                                lda varnam+1
  9456  523a 08                                  php
  9457  523b da                                  phx
  9458  523c a261                                ldx #lowtr                               ; point to string/array bank
  9459  523e 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9460  5241 fa                                  plx
  9461  5242 28                                  plp
  9462  5243 1002                                bpl l128_2
  9463  5245 ca                                  dex
  9464  5246 ca                                  dex
  9465                          
  9466  5247 8672               l128_2           stx curtol
  9467  5249 a50d                                lda count                                ; save number of dimensions
  9468  524b c8                                  iny
  9469  524c c8                                  iny
  9470  524d c8                                  iny
  9471  524e a261                                ldx #lowtr                               ; point to string/array bank
  9472  5250 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9473                          
  9474  5253 a20b               l128_3           ldx #11                                  ; loppta. default size
  9475  5255 a900                                lda #0
  9476  5257 6f0e08                              bbr6 dimflg,l128_4                       ; not in a dim statement
  9477  525a 68                                  pla                                      ; get low order of indice
  9478  525b 18                                  clc
  9479  525c 6901                                adc #1
  9480  525e aa                                  tax
  9481  525f 68                                  pla                                      ; get high order of indice
  9482  5260 6900                                adc #0
  9483                          
  9484  5262 c8                 l128_4           iny                                      ; notdim.
  9485  5263 da                                  phx
  9486  5264 a261                                ldx #lowtr
  9487  5266 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; store high part of indice
  9488  5269 fa                                  plx
  9489  526a c8                                  iny
  9490  526b 8a                                  txa
  9491  526c da                                  phx
  9492  526d a261                                ldx #lowtr
  9493  526f 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; store low part of indice
  9494  5272 fa                                  plx
  9495  5273 203753                              jsr umult                                ; (a,x)+(curtol)*(lowtr,y)
  9496  5276 8672                                stx curtol                               ; save new tally
  9497  5278 8573                                sta curtol+1
  9498  527a a424                                ldy index
  9499  527c c60d                                dec count                                ; any more indices left?
  9500  527e d0d3                                bne l128_3                               ; yes
  9501  5280 655b                                adc arypnt+1
  9502  5282 b3bddb                              +lbcs omerr                              ; overflow
  9503  5285 855b                                sta arypnt+1                             ; compute where to zero
  9504  5287 a8                                  tay
  9505  5288 8a                                  txa
  9506  5289 655a                                adc arypnt
  9507  528b 9004                                bcc l128_5
  9508  528d c8                                  iny
  9509  528e f3b1db                              +lbeq omerr
  9510                          
  9511  5291 20af31             l128_5           jsr reason                               ; grease.  get room
  9512  5294 8533                                sta strend
  9513  5296 8434                                sty strend+1                             ; new end of storage
  9514  5298 a900                                lda #0                                   ; storing (a) is faster than clear
  9515  529a e673                                inc curtol+1
  9516  529c a472                                ldy curtol
  9517  529e f00c                                beq l128_7
  9518                          
  9519  52a0 88                 l128_6           dey                                      ; zero out new entry
  9520  52a1 08                                  php
  9521  52a2 da                                  phx
  9522  52a3 a25a                                ldx #arypnt
  9523  52a5 20f022                              jsr sta_far_ram1                         ; sta (arypnt),y
  9524  52a8 fa                                  plx
  9525  52a9 28                                  plp
  9526  52aa d0f4                                bne l128_6                               ; no. continue
  9527                          
  9528  52ac c65b               l128_7           dec arypnt+1                             ; deccur.
  9529  52ae c673                                dec curtol+1
  9530  52b0 d0ee                                bne l128_6                               ; do another block
  9531  52b2 e65b                                inc arypnt+1                             ; bump back up. will use later
  9532  52b4 38                                  sec
  9533  52b5 a533                                lda strend                               ; restore (a)
  9534  52b7 e561                                sbc lowtr                                ; determine length
  9535  52b9 a002                                ldy #2
  9536  52bb da                                  phx
  9537  52bc a261                                ldx #lowtr
  9538  52be 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; low
  9539  52c1 a534                                lda strend+1
  9540  52c3 c8                                  iny
  9541  52c4 e562                                sbc lowtr+1
  9542  52c6 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; high
  9543  52c9 fa                                  plx
  9544  52ca a50e                                lda dimflg                               ; quit here if this is a DIM statement
  9545  52cc d068                                bne dimrts                               ; bye!
  9546  52ce c8                                  iny
  9547                          
  9548                          
  9549                          ; At this point (LOWTR,y) points beyond the size to the number of dimensions.
  9550                          ; Strategy:
  9551                          ;  NUMDIM = number of dimensions
  9552                          ;  curtol = 0
  9553                          ;  INLPNM: Get a new indice
  9554                          ;   Make sure indice is not too big
  9555                          ;   Multiply CURTOL by CURMAX
  9556                          ;   Add indice to CURTOL
  9557                          ;   NUMDIM=NUMDIM-1
  9558                          ;   bne INLPNM
  9559                          ;  Use (CURTOL)*4 as offset
  9560                          
  9561                          
  9562  52cf 20bd22             getdef           jsr indlow_ram1                          ; get # of dim's from string bank
  9563  52d2 850d                                sta count                                ; save a counter
  9564  52d4 a900                                lda #0                                   ; zero (curtol)
  9565  52d6 8572                                sta curtol
  9566                          
  9567  52d8 8573               inlpnm           sta curtol+1
  9568  52da fa                                  plx                                      ; get low indice
  9569  52db 8666                                stx indice
  9570  52dd c8                                  iny
  9571  52de 20bd22                              jsr indlow_ram1
  9572  52e1 8578                                sta syntmp
  9573  52e3 68                                  pla                                      ; and the high part
  9574  52e4 8567                                sta indice+1
  9575  52e6 c578                                cmp syntmp                               ; compare with max indice
  9576  52e8 900f                                bcc inlpn2
  9577  52ea d00a                                bne bserr7                               ; if greater, "bad subscript" error
  9578  52ec c8                                  iny
  9579  52ed 20bd22                              jsr indlow_ram1
  9580  52f0 8578                                sta syntmp
  9581  52f2 e478                                cpx syntmp
  9582  52f4 9004                                bcc inlpn1
  9583                          
  9584  52f6 8303ff             bserr7           +lbra bserr
  9585                          
  9586                          
  9587  52f9 c8                 inlpn2           iny
  9588  52fa a573               inlpn1           lda curtol+1                             ; don't multiply if curtol=0
  9589  52fc 0572                                ora curtol
  9590  52fe 18                                  clc                                      ; prepare to get indice back
  9591  52ff f00a                                beq l129_1                               ; get high part of indice back
  9592  5301 203753                              jsr umult                                ; multiply (curtol) by (5&6,lowtr)
  9593  5304 8a                                  txa
  9594  5305 6566                                adc indice                               ; add in (indice)
  9595  5307 aa                                  tax
  9596  5308 98                                  tya
  9597  5309 a424                                ldy index1
  9598                          
  9599  530b 6567               l129_1           adc indice+1
  9600  530d 8672                                stx curtol
  9601  530f c60d                                dec count                                ; any more?
  9602  5311 d0c5                                bne inlpnm                               ; yes
  9603  5313 8573                                sta curtol+1
  9604  5315 a205                                ldx #5
  9605  5317 a547                                lda varnam
  9606  5319 1001                                bpl l129_2
  9607  531b ca                                  dex
  9608  531c a548               l129_2           lda varnam+1
  9609  531e 1002                                bpl l129_3
  9610  5320 ca                                  dex
  9611  5321 ca                                  dex
  9612  5322 862a               l129_3           stx addend
  9613  5324 a900                                lda #0
  9614  5326 204253                              jsr umultd                               ; on rts, a & y = hi. x = lo.
  9615  5329 8a                                  txa
  9616  532a 655a                                adc arypnt
  9617  532c 8549                                sta varpnt
  9618  532e 98                                  tya
  9619  532f 655b                                adc arypnt+1
  9620  5331 854a                                sta varpnt+1
  9621  5333 a8                                  tay
  9622  5334 a549                                lda varpnt
  9623  5336 60                 dimrts           rts
  9624                          
  9625                          ; .page
  9626                          ; Integer arithmetic routines.
  9627                          ;
  9628                          ; Two byte unsigned integer multiply.
  9629                          ; This is for multiply dimensioned arrays.
  9630                          ; (a,b)=(curtol)*(5&6,x).
  9631                          
  9632                          umult
  9633  5337 8424                                sty index
  9634  5339 20bd22                              jsr indlow_ram1
  9635  533c 852a                                sta addend                               ; low, then high
  9636  533e 88                                  dey
  9637  533f 20bd22                              jsr indlow_ram1                          ; put (5&6,lowtr) in faster memory
  9638                          
  9639  5342 852b               umultd           sta addend+1
  9640  5344 a910                                lda #16
  9641  5346 855f                                sta deccnt
  9642  5348 a200                                ldx #0                                   ; clear the accs
  9643  534a a000                                ldy #0                                   ; result initially zero
  9644                          
  9645  534c 8a                 umultc           txa
  9646  534d 0a                                  asl                                      ; multiply by two
  9647  534e aa                                  tax
  9648  534f 98                                  tya
  9649  5350 2a                                  rol
  9650  5351 a8                                  tay
  9651  5352 b3edda                              +lbcs omerr                              ; to much!
  9652  5355 0672                                asl curtol
  9653  5357 2673                                rol curtol+1
  9654  5359 900c                                bcc umlcnt                               ; nothing in this position to multiply
  9655  535b 18                                  clc
  9656  535c 8a                                  txa
  9657  535d 652a                                adc addend
  9658  535f aa                                  tax
  9659  5360 98                                  tya
  9660  5361 652b                                adc addend+1
  9661  5363 a8                                  tay
  9662  5364 b3dbda                              +lbcs omerr                              ; man, just too much!
  9663                          
  9664  5367 c65f               umlcnt           dec deccnt                               ; done?
  9665  5369 d0e1                                bne umultc                               ; keep it up
  9666  536b 60                                  rts                                      ; yes, all done
  9667                          
  9668                          
  9669  536c a50d               fmaptr           lda count
  9670  536e 0a                                  asl
  9671  536f 6905                                adc #5                                   ; point to entries. ((c) cleared by asl)
  9672  5371 6561                                adc lowtr
  9673  5373 a462                                ldy lowtr+1
  9674  5375 9001                                bcc l130_1
  9675  5377 c8                                  iny
  9676  5378 855a               l130_1           sta arypnt
  9677  537a 845b                                sty arypnt+1
  9678  537c 60                                  rts
  9679                          
  9680                          ;.end
  9681                          ; .page
  9682                          ; .subttl  TIME functions
  9683                          
  9684                          ; TI$="hh:mm:ss.t" Allows optional colons to delimit parameters and
  9685                          ;   allows input to be abbrieviated (eg., TI$="h:mm" or
  9686                          ;   even TI$=""), defaulting to "00" for unspecified
  9687                          ;   parameters.  24-hour clock (00:00:00.0 to 23:59:59.9).
  9688                          ;   901010 F.Bowen
  9689                          
  9690                          Set_TI_String
  9691  537d 206d5b                              jsr frefac                               ; we won't need it
  9692  5380 850d                                sta count                                ; save length
  9693                          
  9694  5382 a000                                ldy #0                                   ; our pointer into TI$ assignment
  9695  5384 8487                                sty time                                 ; default time to zero, in case it's not fully specified
  9696  5386 8488                                sty time+1
  9697  5388 8489                                sty time+2
  9698  538a 848a                                sty time+3
  9699                          
  9700  538c a203                                ldx #3                                   ; parameter pointer (3=hr,2=min,1=sec,0=tenths)
  9701  538e 20d453             l131_1           jsr GetTimeDigit                         ; get first digit, convert to BCD
  9702  5391 b013                                bcs l131_2                               ; colon or eos
  9703  5393 9587                                sta time,x
  9704  5395 20d453                              jsr GetTimeDigit                         ; get second digit, convert to BCD
  9705  5398 b00c                                bcs l131_2                               ; colon or eos
  9706                          
  9707  539a 1687                                asl time,x                               ; move first digit to msd
  9708  539c 1687                                asl time,x
  9709  539e 1687                                asl time,x
  9710  53a0 1687                                asl time,x
  9711  53a2 1587                                ora time,x                               ; combine with second digit
  9712  53a4 9587                                sta time,x                               ; now we have a time element of packed BCD
  9713                          
  9714  53a6 b587               l131_2           lda time,x
  9715  53a8 ddf153                              cmp MaxTimeValues,x                      ; check for parameter too big
  9716  53ab b351fe                              +lbcs fcerr                              ; hr>23, min>59, sec>59, tenths>9
  9717                          
  9718  53ae ca                                  dex                                      ; check if done
  9719  53af 3012                                bmi l131_4                               ; yes- all parameters accounted for
  9720  53b1 c40d                                cpy count
  9721  53b3 b013                                bcs l131_5                               ; yes- end of string
  9722                          
  9723  53b5 20d522                              jsr indin1_ram1                          ; check for optional colon (or period)   [910103]
  9724  53b8 c93a                                cmp #':'
  9725  53ba f004                                beq l131_3
  9726  53bc c92e                                cmp #'.'
  9727  53be d0ce                                bne l131_1                               ; not there
  9728  53c0 c8                 l131_3           iny                                      ; it's there- skip over it
  9729                          
  9730  53c1 80cb                                bra l131_1                               ; loop until done
  9731                          
  9732                          
  9733  53c3 c40d               l131_4           cpy count                                ; done
  9734  53c5 93a922                              +lbcc errlen                             ; error if string too long
  9735                          
  9736  53c8 ab8700             l131_5           ldz time                                 ; tenths  0-9
  9737  53cb a588                                lda time+1                               ; seconds 0-59
  9738  53cd a689                                ldx time+2                               ; minutes 0-59
  9739  53cf a48a                                ldy time+3                               ; hours  0-23
  9740  53d1 4cdbff                              jmp _SetTime                             ; Go set time & exit
  9741                          
  9742                          ; .page
  9743                          ; Get an ASCII digit, make sure it's in range 0-9 or a colon.
  9744                          ; if no digit to get, default to '0'
  9745                          ;
  9746                          ; exit with .c=0 if okay  (.A contains BCD)
  9747                          ;    .c=1 if colon or eos (.A invalid)
  9748                          
  9749                          GetTimeDigit
  9750  53d4 a900                                lda #0                                   ; default to '0'
  9751  53d6 c40d                                cpy count
  9752  53d8 b014                                bcs l132_1                               ; exit if at end of string (carry set)
  9753                          
  9754  53da 20d522                              jsr indin1_ram1                          ; else get a character from string
  9755  53dd c8                                  iny                                      ; point to next character
  9756  53de c92e                                cmp #'.'                                 ; [910103]
  9757  53e0 f00c                                beq l132_1                               ; terminator (period) (carry set)
  9758  53e2 c930                                cmp #'0'                                 ; check character, only 0-9 allowed
  9759  53e4 9318fe                              +lbcc fcerr                              ; too small
  9760  53e7 c93a                                cmp #':'
  9761  53e9 9003                                bcc l132_1                               ; just right  (carry clear)
  9762  53eb d311fe                              +lbne fcerr                              ; too big
  9763                          ; falls through if colon (carry set)
  9764                          
  9765  53ee 290f               l132_1           and #$0f                                 ; make BCD
  9766  53f0 60                                  rts
  9767                          
  9768                          
  9769                          
  9770                          MaxTimeValues
  9771  53f1 10606024                            !text $10,$60,$60,$24                    ; t,s,m,h in packed BCD
  9772                          
  9773                          ; .page
  9774                          ; x$=TI$  Return a string of the form "hh:mm:ss.t", including colons.
  9775                          
  9776                          Get_TI_String
  9777  53f5 207054                              jsr ReadSystemClock                      ; get time as packed BCD
  9778                          
  9779  53f8 a90a                                lda #10                                  ; get string space for 10 characters
  9780  53fa 207b5a                              jsr strspa
  9781  53fd a8                                  tay                                      ; length
  9782  53fe 88                                  dey                                      ; index
  9783                          
  9784  53ff a587                                lda time                                 ; build TI$ string in 'fbuffr'
  9785  5401 0930                                ora #'0'                                 ; (build string backwards, from last chr to first)
  9786  5403 a264                                ldx #dsctmp+1
  9787  5405 20f022                              jsr sta_far_ram1                         ; put tenths (special case- only 1 digit)
  9788  5408 88                                  dey
  9789  5409 a92e                                lda #'.'
  9790  540b 20f022                              jsr sta_far_ram1                         ; put period (special case)   [910103]
  9791  540e 88                                  dey
  9792  540f a201                                ldx #1
  9793  5411 800a                                bra l133_2
  9794                          
  9795  5413 da                 l133_1           phx                                      ; element pointer (1=secs, 2=mins, 3=hrs)
  9796  5414 a264                                ldx #dsctmp+1
  9797  5416 a93a                                lda #':'
  9798  5418 20f022                              jsr sta_far_ram1                         ; put colon
  9799  541b 88                                  dey
  9800  541c fa                                  plx
  9801                          
  9802  541d b587               l133_2           lda time,x
  9803  541f 4b                                  taz
  9804  5420 290f                                and #$0f                                 ; do lsd first, since we're working backwards
  9805  5422 0930                                ora #'0'
  9806  5424 da                                  phx
  9807  5425 a264                                ldx #dsctmp+1
  9808  5427 20f022                              jsr sta_far_ram1                         ; put lsd
  9809  542a 88                                  dey
  9810  542b 6b                                  tza                                      ; then do msd
  9811  542c 4a                                  lsr
  9812  542d 4a                                  lsr
  9813  542e 4a                                  lsr
  9814  542f 4a                                  lsr
  9815  5430 0930                                ora #'0'
  9816  5432 20f022                              jsr sta_far_ram1                         ; put msd
  9817  5435 fa                                  plx
  9818  5436 e8                                  inx                                      ; next packed element
  9819  5437 88                                  dey
  9820  5438 10d9                                bpl l133_1                               ; loop until done
  9821                          
  9822  543a a90a                                lda #10                                  ; length
  9823  543c 205d5b                              jsr mvdone                               ; update frespc ????
  9824  543f 838f06                              +lbra putnew                             ; make descriptor in dsctmp real
  9825                          
  9826                          ; .page
  9827                          ; TI. Convert 24-hour TOD into tenths of seconds.  901010 F.Bowen
  9828                          
  9829                          Get_TI
  9830  5442 207054                              jsr ReadSystemClock                      ; glance at the clock, get time as h:m:s:t
  9831  5445 6467                                stz faclo                                ; init accumulator with tenths (0-9, so nothing to convert)
  9832  5447 a300                                ldz #0
  9833  5449 6466                                stz facmo
  9834  544b 6465                                stz facmoh
  9835                          
  9836  544d a203                                ldx #3                                   ; convert time (BCD) to tenths of seconds (binary) since midnight
  9837  544f 207c54             l134_1           jsr TimeMultiply
  9838  5452 18                                  clc
  9839  5453 6567                                adc faclo
  9840  5455 8567                                sta faclo
  9841  5457 a52b                                lda product+1
  9842  5459 6566                                adc facmo
  9843  545b 8566                                sta facmo
  9844  545d a52c                                lda product+2
  9845  545f 6565                                adc facmoh
  9846  5461 8565                                sta facmoh                               ; (can't overflow since 23:59:59:9 -> 863999 ($0D2EFF)
  9847  5463 ca                                  dex
  9848  5464 d0e9                                bne l134_1                               ; next factor
  9849                          
  9850  5466 a900                                lda #0                                   ; float value in FAC
  9851  5468 8564                                sta facho                                ; zero msb, facov, facsgn
  9852  546a a2a0                                ldx #160                                 ; set facov for time
  9853  546c 38                                  sec                                      ; normal fac
  9854  546d 83760e                              +lbra floatb                             ; do it
  9855                          
  9856                          
  9857                          
  9858                          ReadSystemClock
  9859  5470 20deff                              jsr _ReadTime                            ; get packed BCD, y=hrs, x=min, a=sec, z=tenths
  9860                          ; (assumes system clock was set properly!)
  9861  5473 6487                                stz time                                 ; tenths  0-9
  9862  5475 8588                                sta time+1                               ; seconds  0-59
  9863  5477 8689                                stx time+2                               ; minutes  0-59
  9864  5479 848a                                sty time+3                               ; hours  0-59
  9865  547b 60                                  rts
  9866                          
  9867                          ; .page
  9868                          ; Unsigned Integer Multiply: Time * Factor  -> Tenths_of_Seconds
  9869                          ;     A   *  (B,C)  ->      (D,E,F)
  9870                          
  9871                          TimeMultiply
  9872  547c b587                                lda time,x                               ; convert packed BCD to binary
  9873  547e 290f                                and #$0f
  9874  5480 8564                                sta facho
  9875  5482 b587                                lda time,x                               ; 10x = 8x + 2x
  9876  5484 29f0                                and #$f0
  9877  5486 4a                                  lsr                                      ; msd x 8
  9878  5487 9587                                sta time,x
  9879  5489 4a                                  lsr
  9880  548a 4a                                  lsr                                      ; msd x 2
  9881  548b 18                                  clc
  9882  548c 6564                                adc facho                                ; lsd
  9883  548e 7587                                adc time,x
  9884  5490 9587                                sta time,x                               ; can't overflow ($99->153)
  9885                          
  9886  5492 8a                                  txa                                      ; make a word pointer from byte pointer
  9887  5493 0a                                  asl
  9888  5494 a8                                  tay
  9889  5495 b9b954                              lda TimeFactor-2,y                       ; multiplicand = TimeFactor,y  (2 bytes)
  9890  5498 8528                                sta multiplicand                         ; multiplier = Time,x x (1 byte)
  9891  549a b9ba54                              lda TimeFactor-1,y                       ; -----------
  9892  549d 8529                                sta multiplicand+1
  9893  549f a900                                lda #0                                   ; product lo   (3 bytes)
  9894  54a1 852b                                sta product+1                            ; mid
  9895  54a3 852c                                sta product+2                            ; hi
  9896                          
  9897  54a5 a010                                ldy #16                                  ; 16-bit multiplicand
  9898  54a7 0a                 l135_1           asl
  9899  54a8 eb2b00                              row product+1
  9900  54ab eb2800                              row multiplicand                         ; multiplier * multiplicand -> product
  9901  54ae 9007                                bcc l135_2
  9902  54b0 18                                  clc
  9903  54b1 7587                                adc time,x
  9904  54b3 9002                                bcc l135_2
  9905  54b5 e32b                                inw product+1                            ; (does no error check, since using time factors
  9906  54b7 88                 l135_2           dey                                      ; in ROM and maximum time multiplier of 59 there
  9907  54b8 d0ed                                bne l135_1                               ; is no danger of overflow)
  9908                          
  9909                          ; sta product
  9910  54ba 60                                  rts                                      ; (.X is preserved)
  9911                          
  9912                          
  9913                          TimeFactor
  9914  54bb 0a00                                !word 10                                 ; tenths per second  (max    59*10 =    590 ($0024E)
  9915  54bd 5802                                !word 600                                ; per minute  (max   59*600 =  35400 ($08A48)
  9916  54bf a08c                                !word 36000                              ; per hour    (max 23*36000 = 828000 ($CA260)
  9917                          
  9918                          ; .page
  9919                          ; .subttl  SLEEP
  9920                          
  9921                          ;*******************************************************************************
  9922                          ;*
  9923                          ;* SLEEP Command - Postpone all activity for a specified number of seconds
  9924                          ;*
  9925                          ;* Syntax:  SLEEP n
  9926                          ;*
  9927                          ;* Where n is the number of seconds to remain inactive,
  9928                          ;* expressed as a positive value < 65536.
  9929                          ;*
  9930                          ;*******************************************************************************
  9931                          
  9932  54c1 208a5d             sleep            jsr getwrd                               ; get argument in (y,a)
  9933                          
  9934                          ; Multiply # of seconds to sleep by 60.  This will be the number of 'jiffies'
  9935                          ; to hibernate.  Store this value in 3 consecutive locations the kernel will
  9936                          ; decrement as a 24-bit binary value, and wait for an underflow.
  9937                          ;
  9938                          ; ldx #0   ;THIS CODE REPLACED    [910730]
  9939                          ; php
  9940                          ; sei   ;silence, please!
  9941                          ; sty _sleep_counter
  9942                          ; sta _sleep_counter+1
  9943                          ; stx _sleep_counter+2 ;sleep_counter = n
  9944                          ;
  9945                          ; jsr sleep_times_2 ;sleep_counter = 2n
  9946                          ; jsr add_xay_to_sleep ;sleep_counter = 3n
  9947                          ; jsr sleep_times_4 ;sleep_counter = 12n
  9948                          ;
  9949                          ; ldy _sleep_counter
  9950                          ; lda _sleep_counter+1
  9951                          ; ldx _sleep_counter+2 ;(xay) = 12n
  9952                          ;
  9953                          ; jsr sleep_times_4 ;sleep_counter = 48n
  9954                          ; jsr add_xay_to_sleep ;sleep_counter = 60n !!!!!
  9955                          ;
  9956                          ; plp
  9957                          ;
  9958                          ;1$ jsr is_stop_key_down
  9959                          ; ldx _sleep_counter+2
  9960                          ; inx   ;underflow?
  9961                          ; bne 1$   ;no, loop
  9962                          ; rts
  9963                          ;
  9964                          ;
  9965                          ;sleep_times_4
  9966                          ; jsr sleep_times_2
  9967                          ;sleep_times_2
  9968                          ; asl _sleep_counter
  9969                          ; rol _sleep_counter+1
  9970                          ; rol _sleep_counter+2
  9971                          ; rts
  9972                          ;
  9973                          ;add_xay_to_sleep
  9974                          ; pha
  9975                          ; tya
  9976                          ; adc _sleep_counter
  9977                          ; sta _sleep_counter
  9978                          ; pla
  9979                          ; adc _sleep_counter+1
  9980                          ; sta _sleep_counter+1
  9981                          ; txa
  9982                          ; adc _sleep_counter+2
  9983                          ; sta _sleep_counter+2
  9984                          ; rts
  9985                          
  9986                          ; .page
  9987                          ; SLEEP is now based upon the system hardware TOD clock (same one used by TI$).  This
  9988                          ; makes it accurate, something it was not when it was based upon the frame rate.
  9989                          
  9990  54c4 8487                                sty time                                 ; Number of seconds to "sleep"   [910730] new
  9991  54c6 8588                                sta time+1
  9992                          
  9993  54c8 20deff             l136_1           jsr _ReadTime                            ; Get current time
  9994  54cb 6489                                stz time+2                               ; tenths
  9995  54cd 858a                                sta time+3                               ; seconds
  9996                          
  9997  54cf 20cc2c             l136_2           jsr is_stop_key_down                     ; Allow user to abort
  9998  54d2 20deff                              jsr _ReadTime                            ; Wait for seconds to increment
  9999  54d5 c58a                                cmp time+3
 10000  54d7 f0f6                                beq l136_2
 10001  54d9 858a                                sta time+3
 10002                          
 10003  54db 20deff             l136_3           jsr _ReadTime                            ; Wait for tenths to increment
 10004  54de d489                                cpz time+2
 10005  54e0 d0f9                                bne l136_3
 10006                          
 10007  54e2 c387                                dew time                                 ; Decrement sleep period 1 second
 10008  54e4 d0e9                                bne l136_2                               ; Loop until sleep period over
 10009                          
 10010  54e6 60                                  rts
 10011                          
 10012                          ;.end
 10013                          ; .page
 10014                          ; .subttl  WAIT
 10015                          
 10016                          ; WAIT<location>,<mask1>[,<mask2>] statement waits until the contents of
 10017                          ; <location> is nonzero when XORed with mask2 and then ANDed with mask1.
 10018                          ; If mask2 is not present, it is assumed to be zero.
 10019                          
 10020  54e7 207c5d             wait             jsr getnum                               ; get required mask1
 10021  54ea 864b                                stx andmsk
 10022  54ec a200                                ldx #0
 10023  54ee 208522                              jsr chrgot
 10024  54f1 f003                                beq l137_1
 10025  54f3 20825d                              jsr combyt                               ; get optional mask2
 10026  54f6 864c               l137_1           stx eormsk
 10027                          
 10028  54f8 db                                  phz
 10029  54f9 abd102                              ldz current_bank                         ; set up bank number for fetch
 10030  54fc a216                                ldx #poker                               ; ..and address
 10031  54fe a000                                ldy #0                                   ; ..and index
 10032                          
 10033  5500 2cd102             l137_2           bit current_bank
 10034  5503 3004                                bmi l137_3                               ; NOMAP?
 10035  5505 2074ff                              jsr _lda_far                             ; lda (poker),y
 10036  5508 2c                                  !text $2c
 10037                          
 10038  5509 b116               l137_3           lda (poker),y
 10039  550b 454c                                eor eormsk
 10040  550d 254b                                and andmsk
 10041  550f f0ef                                beq l137_2
 10042  5511 fb                                  plz
 10043  5512 60                                  rts                                      ; got a nonzero
 10044                          
 10045                          ;.end
 10046                          ; .page
 10047                          ; .subttl  FRE
 10048                          
 10049                          ;*****************************************************************************
 10050                          ; FRE(n) Function
 10051                          ;
 10052                          ; Where: n=0 returns amount of free RAM in bank 0. This is the area
 10053                          ;  between top of text (TEXT_TOP) and top of RAM (MAX_MEM_0).
 10054                          ;
 10055                          ;  n=1 returns amount of free ram in bank 1. This is the area
 10056                          ;  between top of arrays (STREND) and bottom of strings (FRETOP).
 10057                          ;
 10058                          ;  n=2 returns the amount (???? presence) of expansion RAM.
 10059                          ;
 10060                          ;*****************************************************************************
 10061                          
 10062  5513 206f5d             fre              jsr conint                               ; get integer argument in .x
 10063  5516 e001                                cpx #1                                   ; which bank?
 10064  5518 f015                                beq l138_1                               ; go do bank one
 10065  551a e002                                cpx #2                                   ; go do expansion banks   [910107]
 10066  551c f020                                beq l138_2                               ; else it must be bank zero
 10067  551e b3defc                              +lbcs fcerr                              ; any other is unpleasant to talk about
 10068                          
 10069  5521 38                                  sec                                      ; FRE(text_bank)
 10070  5522 adcf02                              lda max_mem_0
 10071  5525 e582                                sbc text_top
 10072  5527 a8                                  tay                                      ; set up result for nosflt
 10073  5528 add002                              lda max_mem_0+1
 10074  552b e583                                sbc text_top+1
 10075  552d 8014                                bra l138_3                               ; assumes text_top < max_mem
 10076                          
 10077                          
 10078  552f 20335c             l138_1           jsr garba2                               ; FRE(var_bank) do garbage collect first
 10079  5532 38                                  sec
 10080  5533 a535                                lda fretop
 10081  5535 e533                                sbc strend
 10082  5537 a8                                  tay
 10083  5538 a536                                lda fretop+1
 10084  553a e534                                sbc strend+1
 10085  553c 8005                                bra l138_3
 10086                          
 10087  553e ac0711             l138_2           ldy _expansion                           ; FRE(expansion banks)    [910107]
 10088  5541 a900                                lda #0
 10089                          
 10090  5543 838203             l138_3           +lbra nosflt                             ; go float the number (y,a)=(lo,hi)
 10091                          
 10092                          ;.end
 10093                          ; .page
 10094                          ; .subttl  VAL
 10095                          
 10096                          ; The VAL function takes a string and turns it into a number by interpreting
 10097                          ; the PETSCII digits etc.  Except for the problem that a terminator must be
 10098                          ; supplied by replacing the character beyond the string, VAL is merely a call
 10099                          ; to floating point input (FIN).
 10100                          
 10101  5546 205c5a             val              jsr len1                                 ; get length
 10102  5549 f3fe08                              +lbeq zerofc                             ; return 0 if len=0
 10103                          
 10104                          ; Use text to fp number code by faking a new text poiner
 10105                          
 10106  554c 18                 val_1            clc                                      ; ///jump table entry.  convert PETSCII to floating point
 10107  554d 6524                                adc index1
 10108  554f 8572                                sta strng2                               ; add length to index1 and put in strng2
 10109  5551 a525                                lda index1+1
 10110  5553 6900                                adc #0
 10111  5555 8573                                sta strng2+1
 10112                          
 10113  5557 a000                                ldy #0
 10114  5559 a972                                lda #strng2
 10115  555b 20d722                              jsr lda_far_ram1                         ; replace character after string with $00 (fake EOL)
 10116  555e 48                                  pha                                      ; save old character
 10117  555f 98                                  tya                                      ; (.A=0)
 10118  5560 a272                                ldx #strng2
 10119  5562 20f022                              jsr sta_far_ram1 ;sta (strng2),y         ; ..and put in null
 10120  5565 205f64                              jsr fin_chrget_2                         ; get character pointed to and set flags.(sorta like chrgot)
 10121  5568 a201                                ldx #1                                   ; flag 'bank 1'
 10122  556a 208d63                              jsr fin                                  ; go do evaluation
 10123  556d 68                                  pla                                      ; get saved character
 10124  556e da                                  phx
 10125  556f a272                                ldx #strng2
 10126  5571 a000                                ldy #0
 10127  5573 20f022                              jsr sta_far_ram1 ;sta (strng2),y         ; restore zeroed-out character
 10128  5576 fa                                  plx
 10129  5577 60                                  rts
 10130                          
 10131                          ;.end
 10132                          ; .page
 10133                          ; .subttl  DEC
 10134                          
 10135                          ; DEC convert a hex string representing a 2-byte integer into decimal.
 10136                          
 10137  5578 205c5a             dcml             jsr len1                                 ; find length of string
 10138  557b 8526                                sta index2                               ; len ret. in a
 10139  557d a000                                ldy #0
 10140  557f 8427                                sty index2+1                             ; zero char counter
 10141  5581 8473                                sty strng2+1                             ; zero out value
 10142  5583 8472                                sty strng2
 10143                          
 10144  5585 c426               l139_1           cpy index2                               ; evaluated all characters?
 10145  5587 f034                                beq l139_4                               ; branch if so
 10146  5589 20d522                              jsr indin1_ram1                          ; get next character from string
 10147  558c c8                                  iny
 10148  558d c920                                cmp #' '                                 ; ignore spaces
 10149  558f f0f4                                beq l139_1
 10150  5591 e627                                inc index2+1
 10151  5593 a627                                ldx index2+1
 10152  5595 e005                                cpx #5
 10153  5597 b02b                                bcs decbad                               ; can't have more than 4 characters
 10154                          
 10155  5599 c930                                cmp #'0'
 10156  559b 9027                                bcc decbad                               ; bad if < 0
 10157  559d c93a                                cmp #':'                                 ; '9'+1
 10158  559f 900a                                bcc l139_2                               ; ok if  = 0-9
 10159  55a1 c941                                cmp #'A'
 10160  55a3 901f                                bcc decbad                               ; bad if > 9  and < A
 10161  55a5 c947                                cmp #'G'
 10162  55a7 b01b                                bcs decbad                               ; bad if > F
 10163                          
 10164  55a9 e907                                sbc #7                                   ; adjust if A-F  (.c is clr)
 10165  55ab e92f               l139_2           sbc #$2f                                 ; adjust to $00..$0f (.c is set)
 10166  55ad 0a                                  asl                                      ; shift low nibble to high
 10167  55ae 0a                                  asl
 10168  55af 0a                                  asl
 10169  55b0 0a                                  asl
 10170                          
 10171  55b1 a204                                ldx #4                                   ; mult. old val. by 16, add new
 10172  55b3 0a                 l139_3           asl
 10173  55b4 2672                                rol strng2
 10174  55b6 2673                                rol strng2+1
 10175  55b8 ca                                  dex
 10176  55b9 d0f8                                bne l139_3
 10177  55bb 80c8                                bra l139_1
 10178                          
 10179  55bd a472               l139_4           ldy strng2                               ; get lsb of value,
 10180  55bf a573                                lda strng2+1                             ; & msb,
 10181  55c1 830403                              +lbra nosflt                             ; go float 2 byte unsigned integer
 10182                          
 10183                          
 10184                          decbad
 10185  55c4 8338fc                              +lbra fcerr                              ; illegal qty error
 10186                          
 10187                          ;.end
 10188                          ; .page
 10189                          ; .subttl  PEEK  POKE
 10190                          
 10191                          
 10192  55c7 fc1600             peek             phw poker                                ; ..also happens to be LINNUM!   [910911]
 10193  55ca 20db4c                              jsr chknum
 10194  55cd 208d5d                              jsr getadr
 10195  55d0 a000                                ldy #0                                   ; index
 10196  55d2 2cd102                              bit current_bank
 10197  55d5 300b                                bmi l140_1                               ; NOMAP?
 10198                          
 10199  55d7 db                                  phz
 10200  55d8 abd102                              ldz current_bank                         ; set up bank number for Kernel's fetch
 10201  55db a216                                ldx #poker                               ; ..and address
 10202  55dd 2074ff                              jsr _lda_far                             ; lda (poker),y
 10203  55e0 fb                                  plz
 10204  55e1 2c                                  !text $2c
 10205                          
 10206  55e2 b116               l140_1           lda (poker),y
 10207  55e4 a8                                  tay                                      ; get byte into .y
 10208  55e5 68                                  pla
 10209  55e6 8517                                sta poker+1                              ; restore linnum
 10210  55e8 68                                  pla
 10211  55e9 8516                                sta poker
 10212  55eb 83e502                              +lbra sngflt                             ; float it
 10213                          
 10214                          ; .page
 10215  55ee 207c5d             poke             jsr getnum
 10216  55f1 8a                 l141_1           txa                                      ; set up value to store for Kernel 'stash' routine
 10217  55f2 a000                                ldy #0                                   ; ..and index
 10218  55f4 78                                  sei                                      ; to allow poking IRQ vector, etc.  [910612]
 10219  55f5 2cd102                              bit current_bank
 10220  55f8 300b                                bmi l141_2                               ; (anything >1Meg means NOMAP)
 10221                          
 10222  55fa db                                  phz
 10223  55fb a216                                ldx #poker                               ; ..and address
 10224  55fd abd102                              ldz current_bank                         ; ..finally, get the bank number
 10225  5600 2077ff                              jsr _sta_far                             ; sta (poker),y
 10226  5603 fb                                  plz
 10227  5604 2c                                  !text $2c
 10228                          
 10229  5605 9116               l141_2           sta (poker),y                            ; NoMap
 10230                          
 10231  5607 208522             l141_3           jsr chrgot                               ; eol?
 10232  560a f00a                                beq l141_4                               ; yes
 10233  560c e316                                inw poker                                ; no- increment address
 10234                          ; lda poker  ; check for segment wrap (FFFF->0000) [910911]
 10235                          ; ora poker+1
 10236  560e f331d8                              +lbeq omerr                              ; [910916]
 10237  5611 202679                              jsr optbyt                               ; & get next [,byte]
 10238  5614 b0db                                bcs l141_1
 10239                          
 10240  5616 58                 l141_4           cli                                      ; [910612]
 10241  5617 60                                  rts
 10242                          
 10243                          
 10244                          ;.end
 10245                          ; .page
 10246                          ; .subttl  ERR$
 10247                          
 10248  5618 20c162             errd             jsr sign                                 ; get sign
 10249  561b 300c                                bmi l142_1                               ; (allow err$(er) when er=-1)
 10250  561d 206f5d                              jsr conint                               ; get integer arg in x
 10251  5620 ca                                  dex
 10252  5621 8a                                  txa                                      ; error # (0 to max-1)
 10253  5622 c92a                                cmp #last_error_message                  ; check range
 10254  5624 900f                                bcc l142_2                               ; ok
 10255  5626 a200                                ldx #0                                   ; too high, return null
 10256  5628 2c                                  !text $2c
 10257                          
 10258  5629 a202               l142_1           ldx #2                                   ; no error, return "ok"    [910911]
 10259  562b a96a                                lda #<ok_error_message
 10260  562d a029                                ldy #>ok_error_message
 10261  562f 8526                                sta index2
 10262  5631 8427                                sty index2+1
 10263  5633 8013                                bra l142_5                               ; pass it
 10264                          
 10265  5635 20a92b             l142_2           jsr erstup                               ; look up the error, set up a pointer to it
 10266  5638 a0ff                                ldy #$ff                                 ; determine how long it is
 10267  563a a200                                ldx #0
 10268  563c e8                 l142_3           inx                                      ; count printing characters
 10269  563d c8                 l142_4           iny
 10270  563e b126                                lda (index2),y                           ; (rom: ind.ok)
 10271  5640 3006                                bmi l142_5                               ; msb set means last
 10272  5642 c920                                cmp #' '
 10273  5644 90f7                                bcc l142_4                               ; don't count non-printers
 10274  5646 80f4                                bra l142_3                               ; count all others
 10275                          
 10276  5648 8a                 l142_5           txa                                      ; message length
 10277  5649 207b5a                              jsr strspa                               ; get space
 10278  564c aa                                  tax
 10279  564d f01d                                beq l142_7                               ; null
 10280                          
 10281                          ; sta sw_rom_ram1  ;set up string bank????
 10282  564f a200                                ldx #0
 10283  5651 a0ff                                ldy #$ff
 10284  5653 c8                 l142_6           iny                                      ; copy message into memory
 10285  5654 b126                                lda (index2),y                           ; (rom: ind.ok)
 10286  5656 c920                                cmp #' '
 10287  5658 90f9                                bcc l142_6                               ; skip non-printers
 10288                          
 10289  565a 48                                  pha
 10290  565b 297f                                and #$7f
 10291  565d 5a                                  phy                                      ; swap x&y
 10292  565e da                                  phx
 10293  565f 7a                                  ply
 10294  5660 a264                                ldx #dsctmp+1
 10295  5662 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y to RAM1
 10296  5665 5a                                  phy                                      ; swap x&y
 10297  5666 fa                                  plx
 10298  5667 7a                                  ply
 10299  5668 e8                                  inx
 10300  5669 68                                  pla                                      ; test if msb was set
 10301  566a 10e7                                bpl l142_6
 10302                          
 10303  566c 835903             l142_7           +lbra chrd1                              ; pla,pla,jmp putnew
 10304                          
 10305                          
 10306                          ;.end
 10307                          ; .page
 10308                          ; .subttl  HEX$
 10309                          
 10310  566f 20db4c             hexd             jsr chknum
 10311  5672 fc1600                              phw poker                                ; save linnum    [910911]
 10312  5675 208d5d                              jsr getadr                               ; 2 byte val in (poker)
 10313  5678 a904                                lda #4
 10314  567a 207b5a                              jsr strspa
 10315  567d a000                                ldy #0
 10316  567f a517                                lda poker+1
 10317  5681 209256                              jsr hexit
 10318  5684 a516                                lda poker
 10319  5686 209256                              jsr hexit
 10320  5689 68                                  pla                                      ; restore linnum
 10321  568a 8517                                sta poker+1
 10322  568c 68                                  pla
 10323  568d 8516                                sta poker
 10324  568f 833603                              +lbra chrd1                              ; pla,pla,jmp putnew
 10325                          
 10326  5692 48                 hexit            pha
 10327  5693 4a                                  lsr
 10328  5694 4a                                  lsr
 10329  5695 4a                                  lsr
 10330  5696 4a                                  lsr
 10331  5697 209b56                              jsr dohex
 10332  569a 68                                  pla
 10333                          
 10334  569b 290f               dohex            and #$0f
 10335  569d c90a                                cmp #$0a
 10336  569f 9002                                bcc l143_1
 10337  56a1 6906                                adc #6
 10338  56a3 6930               l143_1           adc #'0'
 10339  56a5 da                                  phx
 10340  56a6 a264                                ldx #dsctmp+1
 10341  56a8 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
 10342  56ab fa                                  plx
 10343  56ac c8                                  iny
 10344  56ad 60                                  rts
 10345                          
 10346                          ;.end
 10347                          ; .page
 10348                          ; .subttl  JOY
 10349                          
 10350                          ;*************************************************************
 10351                          ; JOY (n)  -- Return joystick status
 10352                          ;
 10353                          ; where: n =  1  return position of joystick-1
 10354                          ;       2  return position of joystick-2
 10355                          ;
 10356                          ; result:      0  no direction, no button
 10357                          ;       1-8    direction (see below), no button
 10358                          ;       128 no direction, button
 10359                          ;       129-136 direction & button  128 + [1...8]
 10360                          ;
 10361                          ; button--->  128        1
 10362                          ;       8     2
 10363                          ; stick--->  7           3
 10364                          ;       6     4
 10365                          ;          5
 10366                          ;
 10367                          ;*************************************************************
 10368                          
 10369  56ae 206f5d             joy              jsr conint                               ; get 1 byte arg in x
 10370  56b1 ca                                  dex
 10371  56b2 e002                                cpx #2                                   ; make sure arg. is valid
 10372  56b4 b348fb                              +lbcs fcerr                              ; >1, error
 10373                          
 10374  56b7 8a                                  txa
 10375  56b8 4901                                eor #1                                   ; invert to match legends on case
 10376  56ba aa                                  tax
 10377  56bb 08                                  php                                      ; save status
 10378                          
 10379                          ; jsr put_io_in_map
 10380  56bc 78                                  sei                                      ; disable IRQ to inhibit kybd
 10381  56bd ad00dc                              lda d1pra
 10382  56c0 48                                  pha                                      ; save kybd output lines
 10383  56c1 a0ff                                ldy #$ff
 10384  56c3 8c00dc                              sty d1pra                                ; set to not read any kybd inputs
 10385                          
 10386  56c6 bd00dc             l144_1           lda d1pra,x                              ; read joystick values
 10387  56c9 dd00dc                              cmp d1pra,x                              ; debounce
 10388  56cc d0f8                                bne l144_1
 10389                          
 10390  56ce aa                                  tax                                      ; save joystick values
 10391  56cf 68                                  pla
 10392  56d0 8d00dc                              sta d1pra                                ; reset kybd output lines
 10393  56d3 8a                                  txa                                      ; restore joystick values
 10394  56d4 28                                  plp                                      ; restore status
 10395  56d5 290f                                and #$0f                                 ; test which direction
 10396  56d7 a8                                  tay
 10397  56d8 b9e356                              lda joytab-5,y                           ; get direction indicator
 10398  56db a8                                  tay                                      ; save direction : 0-8
 10399  56dc 8a                                  txa                                      ; restore joystick value
 10400  56dd 2910                                and #$10                                 ; test if button triggered
 10401  56df d004                                bne l144_2                               ; skip if not
 10402  56e1 98                                  tya
 10403  56e2 0980                                ora #$80                                 ; show trigger depressed
 10404  56e4 a8                                  tay
 10405  56e5 83eb01             l144_2           +lbra sngflt                             ; float 1 byte arg in y.
 10406                          
 10407  56e8 0402030006080700...joytab           !text 4,2,3,0,6,8,7,0,5,1,0
 10408                          
 10409                          ;.end
 10410                          ; .page
 10411                          ; .subttl  POT  LPEN
 10412                          
 10413                          ;***********************************************************
 10414                          ; POT(n)  --  Read paddles
 10415                          ;
 10416                          ;    n = 1 : paddle-1 - X-position
 10417                          ;  2 : paddle-1 - Y-position
 10418                          ;  3 : paddle-2 - X-position
 10419                          ;  4 : paddle-2 - Y-position
 10420                          ;
 10421                          ;     result >= 256 --  trigger set
 10422                          ;***********************************************************
 10423                          
 10424  56f3 20554e             pot              jsr chkcls                               ; look for closing paren
 10425  56f6 206f5d                              jsr conint                               ; get 1-byte arg in .x
 10426  56f9 ca                                  dex
 10427  56fa e004                                cpx #4
 10428  56fc b300fb                              +lbcs fcerr                              ; value error
 10429                          
 10430                          ; jsr put_io_in_map
 10431  56ff 8a                                  txa                                      ; convert arg (0-3) into paddle enables
 10432  5700 4a                                  lsr                                      ; .c= X/Y   .a= port 1/2
 10433  5701 aa                                  tax
 10434  5702 bd6b79                              lda sbits+6,x
 10435  5705 aa                                  tax                                      ; (CIA paddle port, $40/$80)
 10436  5706 a900                                lda #0
 10437  5708 2a                                  rol
 10438  5709 a8                                  tay                                      ; (SID x/y offset,  $00/$01)
 10439                          
 10440  570a 8e6e11                              stx pot_temp_1                           ; save which port
 10441  570d 08                                  php                                      ; save IRQ enable while we
 10442  570e 78                                  sei                                      ; disable IRQ to inhibit keyboard scan
 10443  570f ad00dc                              lda d1pra
 10444  5712 48                                  pha                                      ; save kybd output lines
 10445  5713 8e00dc                              stx d1pra                                ; turn on correct paddle
 10446                          
 10447  5716 205d48                              jsr go_slow
 10448  5719 a200                                ldx #0
 10449  571b e8                 l145_1           inx                                      ; delay to let pot be read by SID
 10450  571c d0fd                                bne l145_1
 10451                          
 10452  571e b919d4             l145_2           lda sid1+25,y                            ; read pot
 10453  5721 d919d4                              cmp sid1+25,y                            ; debounce
 10454  5724 d0f8                                bne l145_2
 10455  5726 8d6f11                              sta pot_temp_2                           ; save pot value
 10456  5729 205748                              jsr go_fast
 10457                          
 10458  572c a200                                ldx #0                                   ; set index to d1pra
 10459  572e 2c6e11                              bit pot_temp_1                           ; test if pot-0,1 or pot-2,3
 10460  5731 3001                                bmi l145_3                               ; skip if pot 2,3
 10461  5733 e8                                  inx                                      ; index to d1prb
 10462  5734 a904               l145_3           lda #04                                  ; use joy line-2
 10463  5736 88                                  dey                                      ; test if pot-x or pot-y
 10464  5737 3001                                bmi l145_4                               ; skip if pot-x
 10465  5739 0a                                  asl                                      ; use joy line-3
 10466  573a a0ff               l145_4           ldy #$ff
 10467  573c 8c00dc                              sty d1pra                                ; disable keybd inputs
 10468  573f c8                                  iny                                      ; set to zero for no trigger
 10469  5740 3d00dc                              and d1pra,x                              ; test if trigger set
 10470  5743 d001                                bne l145_5                               ; skip if not trigger
 10471  5745 c8                                  iny                                      ; return value >255 for trigger
 10472  5746 68                 l145_5           pla
 10473  5747 8d00dc                              sta d1pra                                ; restore keybd lines
 10474  574a 98                                  tya
 10475  574b ac6f11                              ldy pot_temp_2                           ; restore pot value
 10476  574e 28                                  plp                                      ; restore status
 10477  574f 837601                              +lbra nosflt                             ; output 2-byte result
 10478                          
 10479                          ; .page
 10480                          ;*************************************************************
 10481                          ;  LPEN(n)  --  Read light pen
 10482                          ;
 10483                          ; n = 0 x position
 10484                          ;     1 y position
 10485                          ;*************************************************************
 10486                          
 10487  5752 20554e             lpen             jsr chkcls                               ; look for closing parens
 10488  5755 206f5d                              jsr conint                               ; get 1 byte arg in .X
 10489                          ; dex   ;convert [1-2] to [0-1]
 10490  5758 e002                                cpx #2
 10491  575a b3a2fa                              +lbcs fcerr                              ; bad value
 10492                          
 10493  575d a900                                lda #0
 10494  575f 78                                  sei
 10495  5760 bce802                              ldy lightpen_xpos,x                      ; get latched light pen value (a=msb, y=lsb)
 10496  5763 9de802                              sta lightpen_xpos,x                      ; reset to zero (????preserve last latched position)
 10497  5766 58                                  cli
 10498  5767 e000                                cpx #0
 10499  5769 d006                                bne l146_1                               ; done if y position
 10500  576b 98                                  tya
 10501  576c 0a                                  asl                                      ; else multiply *2 to get correct x position
 10502  576d a8                                  tay                                      ; lsb
 10503  576e a900                                lda #0
 10504  5770 2a                                  rol                                      ; msb
 10505  5771 835401             l146_1           +lbra nosflt                             ; float it (y,a)
 10506                          
 10507                          
 10508                          ;.end
 10509                          ; .page
 10510                          ; .subttl  POINTER
 10511                          
 10512                          ;******************************************************************
 10513                          ;
 10514                          ; POINTER(var_name) - Return address of descriptor for var_name
 10515                          ;
 10516                          ;******************************************************************
 10517                          
 10518  5774 208322             pointer          jsr chrget                               ; skip over escape token
 10519  5777 20584e                              jsr chkopn                               ; test for open paren
 10520  577a 200250                              jsr isletc                               ; test if character follows parens
 10521  577d 93cbd6                              +lbcc snerr                              ; ...syntax error if not.
 10522  5780 207c4f                              jsr ptrget                               ; look for this varname in table
 10523                          
 10524                          pointer_ret      =*-1
 10525  5783 aa                                  tax
 10526  5784 5a                                  phy
 10527  5785 20554e                              jsr chkcls                               ; look for closing paren
 10528  5788 8a                                  txa
 10529  5789 a8                                  tay
 10530  578a 68                                  pla
 10531  578b c902                                cmp #>zero                               ; is this a dummy pointer?
 10532  578d d003                                bne l147_1
 10533  578f a900                                lda #0                                   ; if so, return 0
 10534  5791 a8                                  tay
 10535  5792 833301             l147_1           +lbra nosflt
 10536                          
 10537                          ;.end
 10538                          ; .page
 10539                          ; .subttl  XOR
 10540                          
 10541                          ;**************************************************************
 10542                          ;*
 10543                          ;*   XOR - Exclusive-or two 16 bit arguments
 10544                          ;*
 10545                          ;* Syntax : XOR (arg1, arg2)
 10546                          ;*
 10547                          ;**************************************************************
 10548                          
 10549  5795 fc1600             xor              phw poker                                ; protect the poker value (could be in use)  [910911]
 10550  5798 20db4c                              jsr chknum
 10551  579b 208d5d                              jsr getadr                               ; get first arg
 10552  579e 48                                  pha                                      ; save MSB
 10553  579f 5a                                  phy                                      ; save LSB
 10554                          
 10555  57a0 20875d                              jsr comwrd                               ; check for comma, get word
 10556  57a3 20554e                              jsr chkcls                               ; check for closing parens
 10557                          
 10558  57a6 68                                  pla
 10559  57a7 4516                                eor poker                                ; xor LSB (comwrd left a copy of its arg in POKER)
 10560  57a9 a8                                  tay
 10561  57aa 68                                  pla
 10562  57ab 4517                                eor poker+1                              ; ..and MSB
 10563  57ad 20c758                              jsr nosflt                               ; ..and go float 'em
 10564                          
 10565  57b0 68                                  pla
 10566  57b1 8517                                sta poker+1
 10567  57b3 68                                  pla
 10568  57b4 8516                                sta poker
 10569  57b6 60                                  rts
 10570                          
 10571                          ;.end
 10572                          ; .page
 10573                          ; .subttl  MOD
 10574                          
 10575                          ;**************************************************************
 10576                          ;*
 10577                          ;* MOD  -  Modulus of a number
 10578                          ;*
 10579                          ;* Syntax : MOD (number, range)
 10580                          ;*      910402 FAB
 10581                          ;**************************************************************
 10582                          
 10583                          ; Calculate   MOD = NUMBER-RANGE*INT(NUMBER/RANGE)
 10584                          
 10585  57b7 20db4c             mod              jsr chknum                               ; 1st arg in FAC1 (number)
 10586  57ba 20734d                              jsr pushf1                               ; save two copies of it for later
 10587  57bd 20734d                              jsr pushf1
 10588  57c0 205b4e                              jsr chkcom                               ; check for comma
 10589  57c3 20d84c                              jsr frmnum                               ; 2nd arg in FAC1 (range)
 10590  57c6 20554e                              jsr chkcls                               ; check for closing paren
 10591                          
 10592  57c9 20a362                              jsr movaf                                ; save range in FAC2
 10593  57cc 20964d                              jsr pullf1                               ; get back number in FAC1
 10594  57cf a205                                ldx #5                                   ; swap FAC1 and FAC2
 10595  57d1 b563               l148_1           lda facexp,x
 10596  57d3 b46a                                ldy argexp,x
 10597  57d5 956a                                sta argexp,x
 10598  57d7 9463                                sty facexp,x
 10599  57d9 ca                                  dex
 10600  57da 10f5                                bpl l148_1
 10601  57dc 20734d                              jsr pushf1                               ; save one copy of range for later
 10602                          
 10603  57df 207861                              jsr fdivt_c65                            ; number/range
 10604  57e2 206363                              jsr int                                  ; INT(number/range)
 10605  57e5 20a362                              jsr movaf                                ; round & move to FAC2
 10606  57e8 20964d                              jsr pullf1                               ; retrieve arg2 (range)
 10607  57eb 206360                              jsr fmultt_c65                           ; range*INT(number/range)
 10608  57ee 20fc65                              jsr negop                                ; -range*INT(number/range)
 10609  57f1 20a362                              jsr movaf                                ; move to FAC2
 10610  57f4 20964d                              jsr pullf1                               ; retrieve arg1 (number)
 10611  57f7 83230c                              +lbra faddt_c65                          ; number-range*INT(number/range)
 10612                          
 10613                          
 10614                          ;.end
 10615                          ; .page
 10616                          ; .subttl  RWINDOW
 10617                          
 10618                          ;******************************************************************************
 10619                          ;
 10620                          ; RWINDOW  - Returns information about the current console display environment.
 10621                          ;
 10622                          ;   Syntax : RWINDOW (n)
 10623                          ;
 10624                          ;   Where: n=0 : number of lines in the current window
 10625                          ;   =1 : number of rows in the current window
 10626                          ;   =2 : returns either 40 or 80, depending on the
 10627                          ;   current console device
 10628                          ;
 10629                          ;******************************************************************************
 10630                          
 10631  57fa 20554e             rwindow          jsr chkcls
 10632  57fd 206f5d                              jsr conint
 10633  5800 e002                                cpx #2
 10634  5802 f015                                beq l149_2                               ; return current console
 10635  5804 b3f8f9                              +lbcs fcerr
 10636                          
 10637  5807 e000                                cpx #0
 10638  5809 d007                                bne l149_1
 10639                          
 10640  580b a5e4                                lda _screen_bottom
 10641  580d 38                                  sec
 10642  580e e5e5                                sbc _screen_top
 10643  5810 800d                                bra l149_3                               ; always
 10644                          
 10645  5812 a5e7               l149_1           lda _screen_right
 10646  5814 38                                  sec
 10647  5815 e5e6                                sbc _screen_left
 10648  5817 8006                                bra l149_3                               ; always
 10649                          
 10650                          
 10651  5819 a950               l149_2           lda #80                                  ; assume 80 col
 10652  581b 7fd701                              bbr7 _mode,l149_3
 10653  581e 4a                                  lsr
 10654  581f a8                 l149_3           tay
 10655  5820 83b000                              +lbra sngflt                             ; float 1 byte arg in .Y
 10656                          
 10657                          ;.end
 10658                          ; .page
 10659                          ; .subttl  RND
 10660                          
 10661                          ;    Random Number Function  RND(x)
 10662                          ;
 10663                          ;  x=0 ==> generate a random number based on hardware clock & noisy POT lines
 10664                          ;  x<0 ==> seed a reproducable, pseudo-random number generator
 10665                          ;  x>0 ==> generate a reproducable pseudo-random # based upon seed value above
 10666                          
 10667                          
 10668  5823 20c162             rnd              jsr sign                                 ; get sign into .a
 10669                          
 10670  5826 3042               rnd_0            bmi l150_2                               ; /// entry from jump table
 10671  5828 d02b                                bne l150_1
 10672                          
 10673                          
 10674                          ; Get value from hardware
 10675                          
 10676  582a 205d48                              jsr go_slow                              ; Use CIA#1 timer B & SID#2 pot X & Y for seeds  [910314]
 10677  582d ad39d4                              lda sid2+25                              ; go slow to read POT-X
 10678  5830 0a                                  asl
 10679  5831 0a                                  asl
 10680  5832 0a                                  asl
 10681  5833 0a                                  asl
 10682  5834 0d3ad4                              ora sid2+26                              ; and POT-Y
 10683  5837 4d12d0                              eor vic+18                               ; ???? should be okay- we're in Slow mode
 10684  583a 8565                                sta facmoh
 10685  583c 205748                              jsr go_fast                              ; restore speed
 10686  583f ad06dc                              lda d1pra+6                              ; timer B is free-running
 10687  5842 8566                                sta facmo
 10688  5844 ad07dc                              lda d1pra+7
 10689  5847 8567                                sta faclo
 10690  5849 4564                                eor facho
 10691  584b 6565                                adc facmoh
 10692  584d 4566                                eor facmo
 10693  584f 6567                                adc faclo
 10694  5851 8564                                sta facho
 10695  5853 8025                                bra l150_3
 10696                          
 10697                          ; .page
 10698  5855 a974               l150_1           lda #<rndx                               ; get last one into FAC
 10699  5857 a011                                ldy #>rndx
 10700  5859 200e62                              jsr movfm
 10701  585c a990                                lda #<rmulc
 10702  585e a058                                ldy #>rmulc                              ; FAC was zero.  restore last one
 10703  5860 204860                              jsr rommlt                               ; multiply by random constant
 10704  5863 a995                                lda #<raddc
 10705  5865 a058                                ldy #>raddc
 10706  5867 205160                              jsr romadd                               ; add random constant
 10707                          
 10708  586a a667               l150_2           ldx faclo
 10709  586c a564                                lda facho
 10710  586e 8567                                sta faclo
 10711  5870 8664                                stx facho                                ; reverse hi and lo
 10712  5872 a665                                ldx facmoh
 10713  5874 a566                                lda facmo
 10714  5876 8565                                sta facmoh
 10715  5878 8666                                stx facmo
 10716                          
 10717  587a a900               l150_3           lda #0                                   ; strnex.  make number positive
 10718  587c 8568                                sta facsgn
 10719  587e a563                                lda facexp                               ; put exp where it will
 10720  5880 8571                                sta facov                                ; be shifted in by normal
 10721  5882 a980                                lda #$80
 10722  5884 8563                                sta facexp                               ; make result between 0 and 1
 10723  5886 20295e                              jsr normal                               ; normalize
 10724  5889 a274                                ldx #<rndx
 10725  588b a011                                ldy #>rndx
 10726  588d 83ab09                              +lbra movmf                              ; put new one into memory
 10727                          
 10728  5890 9835447a00         rmulc            !text 152,53,68,122,0
 10729  5895 6828b14600         raddc            !text 104,40,177,70,0
 10730                          
 10731                          ;.end
 10732                          ; .page
 10733                          ; .subttl Math Package (CODE12)
 10734                          
 10735  589a 9080000000         n32768           !text $90,$80,0,0,0
 10736                          
 10737                          
 10738  589f 20b458             flpint           jsr ayint
 10739  58a2 a566                                lda facmo
 10740  58a4 a467                                ldy  faclo
 10741  58a6 60                                  rts
 10742                          
 10743                          
 10744  58a7 208322             intidx           jsr chrget
 10745  58aa 20ef4c                              jsr frmevl                               ; get a number
 10746                          
 10747                          
 10748  58ad 20db4c             posint           jsr chknum
 10749  58b0 a568                                lda facsgn
 10750  58b2 300d                                bmi nonono                               ; if negative, blow him out
 10751                          
 10752                          
 10753  58b4 a563               ayint            lda facexp
 10754  58b6 c990                                cmp #$90                                 ; FAC > 32767?
 10755  58b8 900a                                bcc qintgo
 10756  58ba a99a                                lda #<n32768                             ; get address of -32768
 10757  58bc a058                                ldy #>n32768
 10758  58be 20f162                              jsr fcomp                                ; see if FAC=((x))
 10759                          
 10760  58c1 d33bf9             nonono           +lbne fcerr                              ; no, FAC is too big
 10761  58c4 836a0a             qintgo           +lbra qint                               ; go shove it
 10762                          ; .page
 10763                          
 10764                          ; Float an unsigned double byte integer
 10765                          ; Entry:  MSB in (a), LSB in (y)
 10766                          
 10767  58c7 20d758             nosflt           jsr stoint
 10768  58ca 38                                  sec                                      ; sign is positive
 10769  58cb 83120a                              +lbra floatc
 10770                          
 10771                          
 10772                          
 10773  58ce 38                 pos              sec
 10774  58cf 20f0ff                              jsr _plot                                ; get tab pos in .y
 10775                          
 10776  58d2 a900               sngflt           lda #0
 10777  58d4 8369f5                              +lbra givayf                             ; float it
 10778                          
 10779                          
 10780                          
 10781  58d7 a200               stoint           ldx #0                                   ; move int to fac & compute proper exponents
 10782  58d9 860f                                stx valtyp
 10783  58db 8564                                sta facho
 10784  58dd 8465                                sty facho+1
 10785  58df a290                                ldx #$90
 10786  58e1 60                 storts           rts
 10787                          
 10788                          
 10789                          
 10790                          ; See if we are in direct mode, and complain if so.
 10791                          
 10792  58e2 ff7efc             errdir           bbs7 runmod,storts                       ; goto error if not in run mode
 10793                          
 10794  58e5 a215                                ldx #errid                               ; input direct error code
 10795  58e7 2c                                  !text $2c
 10796                          
 10797  58e8 a21b               errguf           ldx #erruf
 10798  58ea 8363d5                              +lbra error
 10799                          
 10800                          
 10801  58ed 7f7ef1             errind           bbr7 runmod,storts                       ; goto error if not in direct mode
 10802  58f0 a222                                ldx #erroid
 10803  58f2 835bd5                              +lbra error
 10804                          
 10805                          ;.end
 10806                          ; .page
 10807                          ; .subttl User Defined Function
 10808                          
 10809                          ; User Defined Function Code
 10810                          ;
 10811                          ; Note only single arguments are allowed to functions, and functions must
 10812                          ; be of the single line form:
 10813                          ;
 10814                          ;  DEF FNA(x)=x~2 + x-2
 10815                          ;
 10816                          ; No strings may be involved with these functions.
 10817                          ;
 10818                          ; Idea: create a simple variable entry whose first character has the MSB set.
 10819                          ; The value will be:
 10820                          ;
 10821                          ;  A text pointer to the formula
 10822                          ;  A pointer to the argument variable
 10823                          
 10824  58f5 202259             def              jsr getfnm                               ; get a pointer to the function
 10825  58f8 20e258                              jsr errdir
 10826  58fb 20584e                              jsr chkopn                               ; must have a (
 10827  58fe a980                                lda #$80
 10828  5900 8512                                sta subflg                               ; prohibit subscripted & integer variables
 10829  5902 207c4f                              jsr ptrget                               ; get pointer to argument
 10830  5905 20db4c                              jsr chknum                               ; is it a number?
 10831  5908 20554e                              jsr chkcls                               ; must have )
 10832  590b a9b2                                lda #equal_token                         ; followed by =
 10833  590d 205d4e                              jsr synchr
 10834  5910 48                                  pha
 10835  5911 a54a                                lda varpnt+1
 10836  5913 48                                  pha
 10837  5914 a549                                lda varpnt
 10838  5916 48                                  pha
 10839  5917 a53e                                lda txtptr+1
 10840  5919 48                                  pha
 10841  591a a53d                                lda txtptr
 10842  591c 48                                  pha
 10843  591d 204835                              jsr data
 10844  5920 8073                                bra deffin
 10845                          
 10846                          ; .page
 10847                          ; Subroutine to get a pointer to a function name
 10848                          
 10849  5922 a9a5               getfnm           lda #fn_token                            ; must start with fn
 10850  5924 205d4e                              jsr synchr
 10851  5927 0980                                ora #$80                                 ; put function bit on
 10852  5929 8512                                sta subflg                               ; (disallows array & integer variables)
 10853  592b 20834f                              jsr ptrgt2                               ; get pointer to function or create anew
 10854  592e 8550                                sta defpnt
 10855  5930 8451                                sty defpnt+1
 10856  5932 83a7f3                              +lbra chknum                             ; make sure it's not a string, and return
 10857                          
 10858                          
 10859  5935 202259             fndoer           jsr getfnm                               ; get the function's name
 10860  5938 a551                                lda defpnt+1
 10861  593a 48                                  pha
 10862  593b a550                                lda defpnt
 10863  593d 48                                  pha
 10864  593e 204f4e                              jsr parchk                               ; evaluate parameter
 10865  5941 20db4c                              jsr chknum
 10866  5944 68                                  pla
 10867  5945 8550                                sta defpnt
 10868  5947 68                                  pla
 10869  5948 8551                                sta defpnt+1
 10870  594a a002                                ldy #2
 10871  594c 209922                              jsr inddef                               ; get pointer to the variable
 10872  594f 8549                                sta varpnt                               ; save variable pointer
 10873  5951 aa                                  tax
 10874  5952 c8                                  iny
 10875  5953 209922                              jsr inddef
 10876  5956 f090                                beq errguf
 10877  5958 854a                                sta varpnt+1
 10878  595a c8                                  iny                                      ; since def uses only 4
 10879                          
 10880                          ; .page
 10881  595b a949               defstf           lda #varpnt
 10882  595d 20d722                              jsr lda_far_ram1
 10883  5960 48                                  pha                                      ; push it all on the stack, since we might be recursing
 10884  5961 88                                  dey
 10885  5962 10f7                                bpl defstf
 10886  5964 a44a                                ldy varpnt+1
 10887                          
 10888  5966 206262                              jsr movmf_ram1                           ; put current FAC into our argument variable
 10889  5969 a53e                                lda txtptr+1                             ; save variable pointer
 10890  596b 48                                  pha
 10891  596c a53d                                lda txtptr
 10892  596e 48                                  pha
 10893  596f 209922                              jsr inddef                               ; get pointer to function
 10894  5972 853d                                sta txtptr
 10895  5974 c8                                  iny
 10896  5975 209922                              jsr inddef
 10897  5978 853e                                sta txtptr+1
 10898  597a a54a                                lda varpnt+1                             ; save variable pointer
 10899  597c 48                                  pha
 10900  597d a549                                lda varpnt
 10901  597f 48                                  pha
 10902  5980 20d84c                              jsr frmnum                               ; evaluate variable, and check numeric
 10903  5983 68                                  pla
 10904  5984 8550                                sta defpnt
 10905  5986 68                                  pla
 10906  5987 8551                                sta defpnt+1
 10907  5989 208522                              jsr chrgot
 10908  598c d3bcd4                              +lbne snerr                              ; it didn't terminate, syntax error
 10909                          
 10910  598f 68                                  pla                                      ; restore text pointer
 10911  5990 853d                                sta txtptr
 10912  5992 68                                  pla
 10913  5993 853e                                sta txtptr+1
 10914                          
 10915  5995 a000               deffin           ldy #0
 10916  5997 68                 l151_1           pla                                      ; get old arg value off stack,
 10917  5998 da                                  phx
 10918  5999 a250                                ldx #defpnt
 10919  599b 20f022                              jsr sta_far_ram1 ;sta (defpnt),y         ; and put it back in variable
 10920  599e fa                                  plx
 10921  599f c8                                  iny
 10922  59a0 c005                                cpy #5
 10923  59a2 d0f3                                bne l151_1
 10924  59a4 60                                  rts
 10925                          
 10926                          ;.end
 10927                          ; .page
 10928                          ; .subttl MID$  LEFT$  RIGHT$  ASC  STR$  LEN
 10929                          
 10930                          ; The STR$() function takes a number and gives a string with
 10931                          ; the characters the output of the number would have given.
 10932                          
 10933  59a5 20db4c             strd             jsr chknum                               ; arg has to be numeric
 10934  59a8 a000                                ldy #0
 10935  59aa 209164                              jsr foutc                                ; do its output
 10936  59ad 68                                  pla
 10937  59ae 68                                  pla
 10938                          
 10939  59af a9ff               timstr           lda #<lofbuf
 10940  59b1 a000                                ldy #>lofbuf
 10941  59b3 83d000                              +lbra strlit
 10942                          
 10943                          
 10944                          ; CHR$() creates a string which contains as its only character the PETSCII
 10945                          ; equivalent of the integer argument (#) which must be < 256.
 10946                          
 10947  59b6 206f5d             chrd             jsr conint                               ; get integer in range
 10948  59b9 da                                  phx
 10949  59ba a901                                lda #1                                   ; one-character string
 10950  59bc 207b5a                              jsr strspa                               ; get space for string
 10951  59bf a000                                ldy #0
 10952  59c1 68                                  pla
 10953                          ; phx   ;set up string bank
 10954  59c2 a264                                ldx #dsctmp+1
 10955  59c4 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
 10956                          ; plx
 10957                          
 10958  59c7 68                 chrd1            pla                                      ; get rid of "chknum" return address
 10959  59c8 68                                  pla
 10960  59c9 830501                              +lbra putnew                             ; setup FAC to point to desc
 10961                          ; .page
 10962                          
 10963                          ; The following is the LEFT$($,#) function.  It takes the leftmost # characters
 10964                          ; of the string.  If # > len of the string, it returns the whole string.
 10965                          
 10966  59cc 203e5a             leftd            jsr pream                                ; test parameters
 10967  59cf 48                                  pha                                      ; # arg
 10968  59d0 20a122                              jsr inddpt                               ; string len
 10969  59d3 8578                                sta syntmp
 10970  59d5 68                                  pla
 10971  59d6 c578                                cmp syntmp
 10972  59d8 98                                  tya                                      ; that's all there is to LEFT$
 10973                          
 10974  59d9 9005               rleft            bcc l152_1
 10975  59db 20a122                              jsr inddpt
 10976  59de aa                                  tax                                      ; put length into x
 10977  59df 98                                  tya                                      ; zero (a), the offset
 10978  59e0 48                 l152_1           pha                                      ; save offset
 10979  59e1 8a                 rleft2           txa
 10980  59e2 48                 rleft3           pha                                      ; save length
 10981  59e3 207b5a                              jsr strspa                               ; get space
 10982  59e6 a552                                lda dscpnt
 10983  59e8 a453                                ldy dscpnt+1
 10984  59ea 20715b                              jsr fretmp
 10985  59ed 7a                                  ply
 10986  59ee 68                                  pla
 10987  59ef 18                                  clc
 10988  59f0 6524                                adc index                                ; compute where to copy
 10989  59f2 8524                                sta index
 10990  59f4 9002                                bcc l153_1
 10991  59f6 e625                                inc index+1
 10992  59f8 98                 l153_1           tya
 10993  59f9 204a5b                              jsr movdo                                ; go move it
 10994  59fc 83d200                              +lbra putnew
 10995                          
 10996                          
 10997                          
 10998  59ff 203e5a             rightd           jsr pream
 10999  5a02 48                                  pha
 11000  5a03 20a122                              jsr inddpt
 11001  5a06 8578                                sta syntmp
 11002  5a08 68                                  pla
 11003  5a09 18                                  clc                                      ; (length des'd)-(length)-1
 11004  5a0a e578                                sbc syntmp
 11005  5a0c 49ff                                eor #$ff                                 ; negate
 11006  5a0e 80c9                                bra rleft
 11007                          
 11008                          
 11009                          ; MID$($,#) returns string with chars from # position onward. If # > LEN($)
 11010                          ; then return null string.  MID($,#,#) returns string with characters from
 11011                          ; # position for #2 characters.  If #2 goes past end of string return as much
 11012                          ; as possible.
 11013                          
 11014  5a10 a9ff               midd             lda #255                                 ; default
 11015  5a12 8567                                sta faclo                                ; save for later compare
 11016  5a14 208522                              jsr chrgot                               ; get current character
 11017  5a17 c929                                cmp #')'                                 ; is it a right paren )?
 11018  5a19 f003                                beq l154_1                               ; no third paren.
 11019                          ; jsr chkcom  ;must have comma
 11020                          ; jsr getbyt  ;get the length into "faclo"
 11021  5a1b 20825d                              jsr combyt                               ; [910820]
 11022                          
 11023  5a1e 203e5a             l154_1           jsr pream                                ; check it out
 11024  5a21 f3dbf7                              +lbeq fcerr                              ; illegal qty error
 11025  5a24 ca                                  dex                                      ; compute offset
 11026  5a25 da                                  phx
 11027  5a26 da                                  phx                                      ; preserve a while (2 copies)
 11028  5a27 a200                                ldx #0
 11029  5a29 20a122                              jsr inddpt                               ; get length of what's left
 11030  5a2c 8578                                sta syntmp
 11031  5a2e 68                                  pla
 11032  5a2f 18                                  clc
 11033  5a30 e578                                sbc syntmp
 11034  5a32 b0ad                                bcs rleft2                               ; give null string
 11035  5a34 49ff                                eor #$ff                                 ; in sub c was 0 so just complement
 11036  5a36 c567                                cmp faclo                                ; greater than what's desired
 11037  5a38 90a8                                bcc rleft3                               ; no, just copy that much
 11038  5a3a a567                                lda faclo                                ; get length of what's desired
 11039  5a3c b0a4                                bcs rleft3                               ; copy it
 11040                          
 11041                          
 11042                          
 11043                          
 11044                          ; Common routine used by RIGHT$, LEFT$, MID$, for parameter chk and setup.
 11045                          
 11046  5a3e 20554e             pream            jsr chkcls                               ; param list should end
 11047  5a41 7a                                  ply
 11048  5a42 68                                  pla
 11049  5a43 8557                                sta jmper+1                              ; get return address
 11050  5a45 68                                  pla                                      ; get rid of fingo's jsr ret addr
 11051  5a46 68                                  pla
 11052  5a47 fa                                  plx                                      ; get length
 11053  5a48 68                                  pla
 11054  5a49 8552                                sta dscpnt
 11055  5a4b 68                                  pla
 11056  5a4c 8553                                sta dscpnt+1
 11057  5a4e a557                                lda jmper+1
 11058  5a50 48                                  pha
 11059  5a51 5a                                  phy
 11060  5a52 a000                                ldy #0
 11061  5a54 8a                                  txa
 11062  5a55 60                                  rts
 11063                          
 11064                          
 11065                          
 11066                          ; The function LEN$() returns the length of the string passed as an argument.
 11067                          
 11068  5a56 630400             len              bsr len1
 11069  5a59 8377fe                              +lbra sngflt
 11070                          
 11071  5a5c 206a5b             len1             jsr frestr                               ; free up string
 11072  5a5f a200                                ldx #0
 11073  5a61 860f                                stx valtyp                               ; force numeric
 11074  5a63 a8                                  tay                                      ; set condition codes
 11075  5a64 60                                  rts                                      ; done
 11076                          
 11077                          
 11078                          
 11079                          
 11080                          
 11081                          ; The following is the ASC$() function.  It returns an integer which is the
 11082                          ; decimal equivalent of the PETSCII string argument.
 11083                          
 11084  5a65 205c5a             asc              jsr len1
 11085  5a68 f006                                beq l155_1                               ; it was null (zero length)
 11086  5a6a a000                                ldy #0
 11087  5a6c 20d522                              jsr indin1_ram1                          ; get 1st character
 11088  5a6f a8                                  tay
 11089  5a70 8360fe             l155_1           +lbra sngflt
 11090                          
 11091                          ;.end
 11092                          ; .page
 11093                          ; .subttl String Routines
 11094                          
 11095                          
 11096                          
 11097                          ; STRINI gets string space for the creation of a string and creates
 11098                          ; a descriptor for it in DSCTMP.
 11099                          
 11100                          strini
 11101  5a73 a666                                ldx facmo                                ; get facmo to store in dscpnt
 11102  5a75 a467                                ldy facmo+1
 11103  5a77 8652                                stx dscpnt                               ; retain the descriptor pointer
 11104  5a79 8453                                sty dscpnt+1
 11105                          
 11106  5a7b 20dd5b             strspa           jsr getspa                               ; get string space
 11107  5a7e 8664                                stx dsctmp+1                             ; save location
 11108  5a80 8465                                sty dsctmp+2
 11109  5a82 8563                                sta dsctmp                               ; save length
 11110  5a84 60                                  rts                                      ; done
 11111                          
 11112                          ; .page
 11113                          ; STRLT2 takes the string literal whose first character is pointed to by
 11114                          ; (xreg)+1 and builds a descriptor for it.  The descriptor is initially
 11115                          ; built in DSCTMP, but PUTNEW transfers it into a temporary and leaves a
 11116                          ; pointer to the temporary in FACMO & FACLO.  The characters other than the
 11117                          ; zero that terminates the string should be set up in CHARAC and ENDCHR.
 11118                          ; If the terminator is a quote, the quote is skipped over.  Leading quotes
 11119                          ; should be skipped before call.  On return, the character after the string
 11120                          ; literal is pointed to by (strng2).
 11121                          
 11122                          
 11123  5a85 a222               strlit           ldx #'"'                                 ; assume string ends on quote
 11124  5a87 860a                                stx charac
 11125  5a89 860b                                stx endchr
 11126                          
 11127  5a8b 8570               strlt2           sta strng1                               ; save pointer to string
 11128  5a8d 8471                                sty strng1+1
 11129  5a8f 8564                                sta dsctmp+1                             ; in case no strcpy
 11130  5a91 8465                                sty dsctmp+2
 11131                          
 11132  5a93 a0ff                                ldy #255                                 ; initialize character count
 11133  5a95 c8                 strget           iny
 11134  5a96 20b122                              jsr indst1                               ; get character
 11135  5a99 f00c                                beq l156_2                               ; if zero
 11136  5a9b c50a                                cmp charac                               ; this terminator?
 11137  5a9d f004                                beq l156_1                               ; yes
 11138  5a9f c50b                                cmp endchr
 11139  5aa1 d0f2                                bne strget                               ; look further
 11140                          
 11141  5aa3 c922               l156_1           cmp #'"'                                 ; strfin.  quote?
 11142  5aa5 f001                                beq l156_3
 11143                          
 11144  5aa7 18                 l156_2           clc
 11145  5aa8 8463               l156_3           sty dsctmp                               ; no, back up. retain count
 11146  5aaa 98                                  tya
 11147  5aab 6570                                adc strng1                               ; wishing to set (txtptr)
 11148  5aad 8572                                sta strng2
 11149  5aaf a671                                ldx strng1+1
 11150  5ab1 9001                                bcc l156_4
 11151  5ab3 e8                                  inx
 11152  5ab4 8673               l156_4           stx strng2+1
 11153  5ab6 98                                  tya
 11154                          
 11155                          ; .page
 11156                          strlit_1                                                  ; //// entry from SPRSAV
 11157  5ab7 20735a                              jsr strini
 11158  5aba a8                                  tay
 11159  5abb f013                                beq putnew                               ; length=0, don't bother copying
 11160  5abd 48                                  pha                                      ; save length
 11161  5abe da                                  phx
 11162  5abf a237                                ldx #frespc
 11163  5ac1 88                 l157_1           dey
 11164  5ac2 20b122                              jsr indst1                               ; lda (strng1),y in bank 0
 11165  5ac5 20f022                              jsr sta_far_ram1                         ; sta (frespc),y in bank 1
 11166  5ac8 98                                  tya
 11167  5ac9 d0f6                                bne l157_1
 11168  5acb fa                                  plx
 11169  5acc 68                                  pla                                      ; restore length
 11170  5acd 205d5b                              jsr mvdone                               ; finish up by updating frespc
 11171                          
 11172                          ; .page
 11173                          ; Some string function is returning a result in DSCTMP.  Set up a temp
 11174                          ; descriptor with DSCTMP in it.  Put a pointer to the descriptor in FACMO&LO
 11175                          ; and flag the result as a string type.
 11176                          
 11177  5ad0 a618               putnew           ldx temppt                               ; pointer to first free temp
 11178  5ad2 e024                                cpx #tempst+strsiz+strsiz+strsiz
 11179  5ad4 f314f2                              +lbeq sterr                              ; string temporary error
 11180                          
 11181  5ad7 a563                                lda dsctmp                               ; length
 11182  5ad9 9500                                sta 0,x
 11183  5adb a564                                lda dsctmp+1                             ; pointer to string lo
 11184  5add 9501                                sta 1,x
 11185  5adf a565                                lda dsctmp+2                             ; hi
 11186  5ae1 9502                                sta 2,x
 11187                          
 11188  5ae3 a000                                ldy #0                                   ; pointer to temp. descriptor
 11189  5ae5 8666                                stx facmo                                ; lo
 11190  5ae7 8467                                sty facmo+1                              ; hi
 11191  5ae9 8471                                sty facov
 11192  5aeb 88                                  dey                                      ; ($ff)
 11193  5aec 840f                                sty valtyp                               ; type is string
 11194  5aee 8619                                stx lastpt                               ; set pointer to last-used temp
 11195                          
 11196  5af0 e8                                  inx
 11197  5af1 e8                                  inx
 11198  5af2 e8                                  inx                                      ; point further
 11199  5af3 8618                                stx temppt                               ; save pointer to next temp, if any
 11200  5af5 60                                  rts                                      ; all done
 11201                          
 11202                          ; .page
 11203                          ; The following routine concatenates two strings.  At this point, the FAC
 11204                          ; contains the first one and (txtptr) points to the + sign.
 11205                          
 11206  5af6 a567               cat              lda faclo                                ; push high order onto stack
 11207  5af8 48                                  pha
 11208  5af9 a566                                lda facmo                                ; and the low
 11209  5afb 48                                  pha
 11210  5afc 20e24d                              jsr eval                                 ; can come back here since operator is known
 11211  5aff 20dd4c                              jsr chkstr                               ; must be string
 11212  5b02 68                                  pla
 11213  5b03 8570                                sta strng1                               ; get high order of old descriptor
 11214  5b05 68                                  pla
 11215  5b06 8571                                sta strng1+1
 11216  5b08 a000                                ldy #0
 11217  5b0a 20b522                              jsr indst1_ram1                          ; get length of old string
 11218  5b0d 8578                                sta syntmp
 11219  5b0f 20a922                              jsr indfmo
 11220  5b12 18                                  clc
 11221  5b13 6578                                adc syntmp
 11222  5b15 b3591b                              +lbcs errlen                             ; result >255, error "long string"
 11223                          
 11224  5b18 20735a                              jsr strini                               ; sizeok.  initialize string
 11225  5b1b 20355b                              jsr movins                               ; move it
 11226  5b1e a552                                lda dscpnt                               ; get pointer to second
 11227  5b20 a453                                ldy dscpnt+1
 11228  5b22 20715b                              jsr fretmp                               ; free it
 11229  5b25 204a5b                              jsr movdo                                ; move second string
 11230  5b28 a570                                lda strng1
 11231  5b2a a471                                ldy strng1+1
 11232  5b2c 20715b                              jsr fretmp
 11233  5b2f 20d05a                              jsr putnew
 11234  5b32 83cef1                              +lbra tstop                              ; "cat" reenters frmevl from tstop
 11235                          
 11236                          ; .page
 11237  5b35 a000               movins           ldy #0                                   ; get address of string
 11238  5b37 20b522                              jsr indst1_ram1
 11239  5b3a 48                                  pha
 11240  5b3b c8                                  iny
 11241  5b3c 20b522                              jsr indst1_ram1
 11242  5b3f aa                                  tax
 11243  5b40 c8                                  iny
 11244  5b41 20b522                              jsr indst1_ram1
 11245  5b44 a8                                  tay
 11246  5b45 68                                  pla
 11247                          
 11248  5b46 8624               movstr           stx index                                ; adr in (x,y), len in a
 11249  5b48 8425                                sty index+1
 11250                          
 11251  5b4a a8                 movdo            tay
 11252  5b4b f010                                beq mvdone
 11253                          
 11254  5b4d 48                                  pha
 11255  5b4e da                                  phx
 11256  5b4f a237                                ldx #frespc
 11257  5b51 88                 l158_1           dey
 11258  5b52 20d522                              jsr indin1_ram1
 11259  5b55 20f022                              jsr sta_far_ram1                         ; sta (frespc),y
 11260  5b58 98                                  tya
 11261  5b59 d0f6                                bne l158_1
 11262  5b5b fa                                  plx
 11263  5b5c 68                                  pla
 11264                          
 11265  5b5d 18                 mvdone           clc                                      ; update frespc pointer
 11266  5b5e 6537                                adc frespc
 11267  5b60 8537                                sta frespc
 11268  5b62 9002                                bcc l159_1
 11269  5b64 e638                                inc frespc+1
 11270  5b66 60                 l159_1           rts
 11271                          
 11272                          ; .page
 11273                          ; FRETMP is passed a string descriptor pntr in (a,y).  A check is made to see
 11274                          ; if the string descriptor points to the last temporary descriptor allocated by
 11275                          ; putnew.  If so, the temporary is freed up by the updating of (temppt).  If a
 11276                          ; string is freed up, a further check sees if it was the last one created and if
 11277                          ; so, (fretop) is updated to reflect the fact that the space is no longer in use.
 11278                          ; The address of the actual string is returned in (x,y) and its length in (a).
 11279                          
 11280  5b67 20ef4c             frmstr           jsr frmevl
 11281                          
 11282  5b6a 20dd4c             frestr           jsr chkstr                               ; make sure it's a string
 11283  5b6d a566               frefac           lda facmo                                ; free up string pointed to by FAC
 11284  5b6f a467                                ldy facmo+1
 11285  5b71 8524               fretmp           sta index                                ; get length for later
 11286  5b73 8425                                sty index+1
 11287  5b75 20cc5b                              jsr fretms                               ; check desc. if last
 11288  5b78 d03c                                bne l160_3                               ; one then scratch it
 11289  5b7a 206737                              jsr stradj                               ; index points to link
 11290  5b7d 9037                                bcc l160_3                               ; literal no fix
 11291                          
 11292  5b7f da                                  phx                                      ; .x=length
 11293  5b80 88                                  dey                                      ; .y=1
 11294  5b81 a224                                ldx #index
 11295  5b83 a9ff                                lda #$ff                                 ; flag string as garbage
 11296  5b85 20f022                              jsr sta_far_ram1                         ; sta (index),y
 11297  5b88 68                                  pla
 11298  5b89 48                                  pha                                      ; get length, but leave copy on stack
 11299  5b8a 88                                  dey
 11300  5b8b a224                                ldx #index
 11301  5b8d 20f022                              jsr sta_far_ram1 ;sta (index),y          ; put in length
 11302                          
 11303  5b90 49ff                                eor #$ff                                 ; put index back
 11304  5b92 38                                  sec                                      ; to first byte
 11305  5b93 6524                                adc index
 11306  5b95 a425                                ldy index+1
 11307  5b97 b001                                bcs l160_1
 11308  5b99 88                                  dey
 11309  5b9a 8524               l160_1           sta index
 11310  5b9c 8425                                sty index+1
 11311                          
 11312  5b9e aa                                  tax                                      ; lo into x
 11313  5b9f 68                                  pla                                      ; pull length from stack
 11314  5ba0 c436                                cpy fretop+1                             ; = to fretop?
 11315  5ba2 d038                                bne frerts
 11316  5ba4 e435                                cpx fretop
 11317  5ba6 d034                                bne frerts
 11318                          
 11319                          ; .page
 11320                          ; The string was the last one put into string space.  Save garbage
 11321                          ; collection some time by freeing up. (length + 2)
 11322                          
 11323  5ba8 48                                  pha                                      ; save length on stack
 11324  5ba9 38                                  sec                                      ; plus one
 11325  5baa 6535                                adc fretop
 11326  5bac 8535                                sta fretop
 11327  5bae 9002                                bcc l160_2
 11328  5bb0 e636                                inc fretop+1
 11329  5bb2 e335               l160_2           inw fretop                               ; + one more
 11330  5bb4 68                                  pla                                      ; pull length off stack
 11331  5bb5 60                                  rts
 11332                          
 11333                          
 11334  5bb6 a000               l160_3           ldy #0                                   ; set up x,y,a and index
 11335  5bb8 20d522                              jsr indin1_ram1                          ; length
 11336  5bbb 48                                  pha                                      ; on stack
 11337  5bbc c8                                  iny
 11338  5bbd 20d522                              jsr indin1_ram1                          ; pointer lo
 11339  5bc0 aa                                  tax
 11340  5bc1 c8                                  iny
 11341  5bc2 20d522                              jsr indin1_ram1                          ; pointer hi
 11342  5bc5 a8                                  tay
 11343  5bc6 8624                                stx index
 11344  5bc8 8425                                sty index+1
 11345  5bca 68                                  pla                                      ; get back length
 11346  5bcb 60                                  rts
 11347                          
 11348                          
 11349                          
 11350  5bcc c41a               fretms           cpy lastpt+1                             ; last entry to temp?
 11351  5bce d00c                                bne frerts
 11352  5bd0 c519                                cmp lastpt
 11353  5bd2 d008                                bne frerts
 11354  5bd4 8518                                sta temppt
 11355  5bd6 e903                                sbc #strsiz                              ; point to lst one
 11356  5bd8 8519                                sta lastpt                               ; update temp pointer
 11357  5bda a000                                ldy #0                                   ; also clears zflg so we do rest of fretmp
 11358  5bdc 60                 frerts           rts                                      ; all done
 11359                          
 11360                          ;.end
 11361                          ; .page
 11362                          ; .subttl Garbage Collection
 11363                          
 11364                          ;  Get space for a string, perhaps forcing garbage collection.
 11365                          ;
 11366                          ;  Entry:  a = # of chars
 11367                          ;  Exit:   (x,y) pointer to space, otherwise
 11368                          ;          blows off to 'out of string space' error
 11369                          ;          (also preserves .a and sets frespc= y,x = -> at space.)
 11370                          
 11371                          
 11372  5bdd 4611               getspa           lsr garbfl                               ; signal no garbage collection yet
 11373                          
 11374  5bdf aa                 tryag2           tax                                      ; save in x also
 11375  5be0 f042                                beq getrts                               ; length of 0 no go...
 11376  5be2 48                                  pha                                      ; save a (length) on stack
 11377  5be3 a535                                lda fretop                               ; lo byte
 11378  5be5 38                                  sec                                      ; for subtract
 11379  5be6 e902                                sbc #2                                   ; minus 2 (link bytes)
 11380  5be8 a436                                ldy fretop+1
 11381  5bea b001                                bcs l161_1
 11382  5bec 88                                  dey
 11383  5bed 8524               l161_1           sta index1                               ; save for later
 11384  5bef 8425                                sty index1+1
 11385  5bf1 8a                                  txa
 11386  5bf2 49ff                                eor #$ff
 11387  5bf4 38                                  sec
 11388  5bf5 6524                                adc index1
 11389  5bf7 b001                                bcs l161_2
 11390  5bf9 88                                  dey
 11391  5bfa c434               l161_2           cpy strend+1
 11392  5bfc 9027                                bcc garbag
 11393  5bfe d004                                bne strfre
 11394  5c00 c533                                cmp strend
 11395  5c02 9021                                bcc garbag                               ; clean up
 11396                          
 11397                          ; .page
 11398  5c04 8537               strfre           sta frespc
 11399  5c06 8438                                sty frespc+1
 11400  5c08 a001                                ldy #1                                   ; flag string as garbage
 11401  5c0a a9ff                                lda #$ff
 11402  5c0c da                                  phx                                      ; set up string bank
 11403  5c0d a224                                ldx #index1
 11404  5c0f 20f022                              jsr sta_far_ram1 ;sta (index1),y         ; flag
 11405  5c12 fa                                  plx
 11406  5c13 88                                  dey
 11407  5c14 68                                  pla                                      ; length
 11408  5c15 da                                  phx                                      ; set up string bank
 11409  5c16 a224                                ldx #index1
 11410  5c18 20f022                              jsr sta_far_ram1 ;sta (index1),y         ; length
 11411  5c1b fa                                  plx
 11412  5c1c a637                                ldx frespc
 11413  5c1e a438                                ldy frespc+1
 11414  5c20 8635                                stx fretop
 11415  5c22 8436                                sty fretop+1                             ; save new (fretop)
 11416  5c24 60                 getrts           rts
 11417                          
 11418                          
 11419  5c25 a511               garbag           lda garbfl
 11420  5c27 3318d2                              +lbmi omerr                              ; if out of memory
 11421  5c2a 20335c                              jsr garba2
 11422  5c2d 38                                  sec
 11423  5c2e 6611                                ror garbfl
 11424  5c30 68                                  pla                                      ; get back string length
 11425  5c31 80ac                                bra tryag2                               ; always branches
 11426                          
 11427                          
 11428                          ; .page
 11429                          ; Routine looks for and squashes out any unused string space it finds, thus
 11430                          ; returning the space for future use by the string routines.  GARBA2 is called
 11431                          ; only when BASIC needs space or the FRE() function is used.
 11432                          
 11433                          
 11434  5c33 a618               garba2           ldx temppt                               ; ptr to temp. strings
 11435  5c35 e01b               l162_1           cpx #tempst                              ; any out there?
 11436  5c37 f016                                beq l162_2                               ; none
 11437  5c39 20505d                              jsr slr1                                 ; setup ptr (tempf2) to temp. string's bkptr
 11438  5c3c f0f7                                beq l162_1                               ; (skip if null string!)
 11439  5c3e 8a                                  txa                                      ; .x = lsb of ptr to descriptor
 11440  5c3f da                                  phx                                      ; set up string bank
 11441  5c40 a25e                                ldx #tempf2
 11442  5c42 a000                                ldy #0
 11443  5c44 20f022                              jsr sta_far_ram1 ;(tempf2),y             ; place backpointer on string to temp. descr
 11444  5c47 98                                  tya                                      ; .a = msb of ptr (0)
 11445  5c48 c8                                  iny
 11446  5c49 20f022                              jsr sta_far_ram1                         ; (tempf2),y
 11447  5c4c fa                                  plx
 11448  5c4d 80e6                                bra l162_1                               ; always
 11449                          
 11450                          
 11451  5c4f a000               l162_2           ldy #0                                   ; set up flag
 11452  5c51 845a                                sty highds
 11453  5c53 a639                                ldx max_mem_1
 11454  5c55 a43a                                ldy max_mem_1+1
 11455  5c57 8661                                stx grbtop                               ; set both pointers
 11456  5c59 8650                                stx grbpnt
 11457  5c5b 8637                                stx frespc
 11458  5c5d 8462                                sty grbtop+1
 11459  5c5f 8451                                sty grbpnt+1
 11460  5c61 8438                                sty frespc+1
 11461  5c63 8a                                  txa
 11462                          
 11463                          ; .page
 11464                          ; do while (grbpnt <= fretop)
 11465                          
 11466  5c64 20de5c             gloop            jsr chkgrb                               ; check garbage string
 11467  5c67 d00c                                bne l163_2                               ; if not garbage
 11468                          
 11469  5c69 88                 l163_1           dey                                      ; back up to length
 11470  5c6a 20b922                              jsr indgrb
 11471  5c6d 20325d                              jsr movpnt                               ; move grbpnt to next
 11472  5c70 38                                  sec
 11473  5c71 665a                                ror highds                               ; indicate garbage string found
 11474  5c73 80ef                                bra gloop                                ; always
 11475                          
 11476  5c75 245a               l163_2           bit highds
 11477  5c77 1052                                bpl l163_6                               ; if garbage string not found
 11478  5c79 a200                                ldx #0
 11479  5c7b 865a                                stx highds                               ; clear indicator
 11480                          
 11481  5c7d a902                                lda #2                                   ; skip pointers past
 11482                          
 11483                          ; Move a string over garbage
 11484                          
 11485  5c7f da                 l163_3           phx
 11486  5c80 a261                                ldx #grbtop
 11487  5c82 a001                                ldy #1                                   ; move the link bytes
 11488  5c84 20b922                              jsr indgrb
 11489  5c87 20f022                              jsr sta_far_ram1                         ; sta (grbtop),y
 11490  5c8a 88                                  dey
 11491  5c8b 20b922                              jsr indgrb
 11492  5c8e 20f022                              jsr sta_far_ram1                         ; sta (grbtop),y
 11493  5c91 fa                                  plx
 11494                          
 11495  5c92 20d522                              jsr indin1_ram1
 11496  5c95 aa                                  tax
 11497  5c96 20415d                              jsr movtop                               ; move top pointer
 11498  5c99 8537                                sta frespc                               ; save in frespc
 11499  5c9b 8438                                sty frespc+1
 11500  5c9d 8a                                  txa
 11501  5c9e 20325d                              jsr movpnt                               ; move grbpnt
 11502  5ca1 8a                                  txa                                      ; put length-1 in .y
 11503  5ca2 a8                                  tay
 11504                          
 11505  5ca3 88                 l163_4           dey
 11506  5ca4 20b922                              jsr indgrb
 11507  5ca7 da                                  phx
 11508  5ca8 a261                                ldx #grbtop
 11509  5caa 20f022                              jsr sta_far_ram1                         ; sta (grbtop),y
 11510  5cad fa                                  plx
 11511  5cae ca                                  dex
 11512  5caf d0f2                                bne l163_4
 11513                          
 11514  5cb1 a002                                ldy #2                                   ; fix the descriptor
 11515  5cb3 da                                  phx
 11516  5cb4 a224                                ldx #index1
 11517  5cb6 b96000             l163_5           lda grbtop-1,y
 11518  5cb9 20f022                              jsr sta_far_ram1                         ; sta (index1),y
 11519  5cbc 88                                  dey
 11520  5cbd d0f7                                bne l163_5
 11521  5cbf fa                                  plx
 11522                          
 11523  5cc0 a550                                lda grbpnt                               ; check pointer
 11524  5cc2 a451                                ldy grbpnt+1
 11525  5cc4 20de5c                              jsr chkgrb                               ; check garbage string
 11526  5cc7 f0a0                                beq l163_1                               ; if garbage found
 11527  5cc9 d0b4                                bne l163_3                               ; always
 11528                          
 11529  5ccb a000               l163_6           ldy #0                                   ; skip over good strings
 11530  5ccd 20d522                              jsr indin1_ram1
 11531  5cd0 aa                                  tax
 11532  5cd1 20415d                              jsr movtop
 11533  5cd4 8537                                sta frespc
 11534  5cd6 8438                                sty frespc+1
 11535  5cd8 8a                                  txa
 11536  5cd9 20325d                              jsr movpnt
 11537  5cdc 8086                                bra gloop
 11538                          
 11539                          ; .page
 11540                          ; Subroutines used for garbage collection.
 11541                          ;
 11542                          ;  Compare for (y,a) = fretop.
 11543                          ; Entry  (y,a) = address of current string descriptor.
 11544                          ; Exits to caller if (y,a) = fretop, else z flag set if garbage string.
 11545                          ;      z flag clear if not garbage string.
 11546                          ; In either case pointers are setup for next loop and string movement.
 11547                          ; If carry clear (y,a) <= fretop
 11548                          
 11549                          
 11550  5cde c436               chkgrb           cpy fretop+1                             ; end of strings?
 11551  5ce0 9029                                bcc l164_5
 11552  5ce2 d006                                bne l164_1                               ; if not equal
 11553  5ce4 c535                                cmp fretop
 11554  5ce6 f023                                beq l164_5
 11555  5ce8 9021                                bcc l164_5
 11556                          
 11557  5cea 245a               l164_1           bit highds                               ; check flag
 11558  5cec 3005                                bmi l164_2                               ; if empty string found
 11559  5cee a902                                lda #2                                   ; skip pointers past
 11560  5cf0 20415d                              jsr movtop                               ; move top pointer
 11561                          
 11562  5cf3 a902               l164_2           lda #2                                   ; skip pointers past
 11563  5cf5 20325d                              jsr movpnt                               ; move pointers
 11564  5cf8 a001                                ldy #1
 11565  5cfa 20b922                              jsr indgrb                               ; garbage?
 11566  5cfd c9ff                                cmp #$ff
 11567  5cff f009                                beq l164_4                               ; yes
 11568                          
 11569  5d01 20b922             l164_3           jsr indgrb                               ; to link bytes
 11570  5d04 992400                              sta index1,y
 11571  5d07 88                                  dey
 11572  5d08 10f7                                bpl l164_3                               ; if two bytes not moved
 11573  5d0a 60                 l164_4           rts
 11574                          
 11575                          
 11576  5d0b a618               l164_5           ldx temppt                               ; ptr to temp. strings
 11577                          
 11578  5d0d e01b               l164_6           cpx #tempst                              ; any out there?
 11579  5d0f f016                                beq l164_7                               ; no
 11580  5d11 20505d                              jsr slr1                                 ; setup ptr (tempf2) to temp. string's bkptr.
 11581  5d14 f0f7                                beq l164_6                               ; (skip if null string!)
 11582  5d16 da                                  phx
 11583  5d17 a25e                                ldx #tempf2
 11584  5d19 a000                                ldy #0                                   ; .a = string length
 11585  5d1b 20f022                              jsr sta_far_ram1 ;sta (tempf2),y         ; remove backpointer built at garba2
 11586  5d1e c8                                  iny
 11587  5d1f a9ff                                lda #$ff
 11588  5d21 20f022                              jsr sta_far_ram1 ;sta (tempf2),y         ; and mark as garbage
 11589  5d24 fa                                  plx
 11590  5d25 80e6                                bra l164_6                               ; always
 11591                          
 11592  5d27 68                 l164_7           pla                                      ; throw away return address
 11593  5d28 68                                  pla
 11594  5d29 a537                                lda frespc                               ; fix fretop and frespc
 11595  5d2b a438                                ldy frespc+1
 11596  5d2d 8535                                sta fretop
 11597  5d2f 8436                                sty fretop+1
 11598  5d31 60                                  rts
 11599                          
 11600                          ; .page
 11601  5d32 49ff               movpnt           eor #$ff                                 ; comp and add
 11602  5d34 38                                  sec
 11603  5d35 6550                                adc grbpnt
 11604  5d37 a451                                ldy grbpnt+1
 11605  5d39 b001                                bcs l165_1
 11606  5d3b 88                                  dey
 11607  5d3c 8550               l165_1           sta grbpnt
 11608  5d3e 8451                                sty grbpnt+1
 11609  5d40 60                                  rts
 11610                          
 11611                          
 11612                          
 11613  5d41 49ff               movtop           eor #$ff                                 ; comp and add
 11614  5d43 38                                  sec
 11615  5d44 6561                                adc grbtop
 11616  5d46 a462                                ldy grbtop+1
 11617  5d48 b001                                bcs l166_1
 11618  5d4a 88                                  dey
 11619  5d4b 8561               l166_1           sta grbtop
 11620  5d4d 8462                                sty grbtop+1
 11621  5d4f 60                                  rts
 11622                          
 11623                          
 11624                          
 11625  5d50 ca                 slr1             dex                                      ; .x = ptr to temp. string descriptor
 11626  5d51 b500                                lda 0,x                                  ; msb of ptr to string
 11627  5d53 855f                                sta tempf2+1
 11628  5d55 ca                                  dex
 11629  5d56 b500                                lda 0,x                                  ; lsb of ptr to string
 11630  5d58 855e                                sta tempf2
 11631  5d5a ca                                  dex
 11632  5d5b b500                                lda 0,x                                  ; string length
 11633  5d5d 48                                  pha                                      ; save for later test
 11634  5d5e 18                                  clc
 11635  5d5f 655e                                adc tempf2                               ; want ptr to string's backpointer
 11636  5d61 855e                                sta tempf2
 11637  5d63 9002                                bcc l167_1
 11638  5d65 e65f                                inc tempf2+1
 11639  5d67 68                 l167_1           pla   ;.a=len & set z flag               ; .x=next desc. ptr
 11640  5d68 60                                  rts
 11641                          
 11642                          ;.end
 11643                          ; .page
 11644                          ; .subttl  Floating Point Math Package (CODE17)
 11645                          
 11646  5d69 208322             gtbytc           jsr chrget
 11647                          
 11648  5d6c 20d84c             getbyt           jsr frmnum                               ; read formula into FAC
 11649                          
 11650  5d6f 20ad58             conint           jsr posint                               ; convert the FAC to a single byte int
 11651  5d72 a666                                ldx facmo
 11652  5d74 d388f4                              +lbne fcerr                              ; result must be <= 255
 11653  5d77 a667                                ldx faclo
 11654  5d79 4c8522                              jmp chrgot                               ; set condition codes on terminator
 11655                          
 11656                          
 11657                          getnum                                                    ; get 2-byte value in y,a: check for a comma, get 1 byte val in x
 11658  5d7c 20d84c                              jsr frmnum                               ; get address
 11659  5d7f 208d5d                              jsr getadr                               ; get that location
 11660                          
 11661                          combyt                                                    ; check for a comma, get a 1 byte value in x
 11662  5d82 205b4e                              jsr chkcom                               ; check for comma
 11663  5d85 80e5                                bra getbyt                               ; get something to store and return
 11664                          
 11665                          
 11666  5d87 205b4e             comwrd           jsr chkcom
 11667                          
 11668  5d8a 20d84c             getwrd           jsr frmnum                               ; get an unsigned 2-byte value in y,a
 11669                          
 11670  5d8d a568               getadr           lda facsgn                               ; for this entry, value can't be < 0
 11671  5d8f 336df4                              +lbmi fcerr                              ; function call error
 11672                          
 11673                          getsad                                                    ; get a signed 2-byte value in (y,a), ///entry from sprcor
 11674  5d92 a563                                lda facexp                               ; examine exponent
 11675  5d94 c991                                cmp #145
 11676  5d96 b366f4                              +lbcs fcerr                              ; function call error
 11677  5d99 203063                              jsr qint                                 ; integerize it
 11678  5d9c a566                                lda facmo
 11679  5d9e a467                                ldy facmo+1
 11680  5da0 8416                                sty poker
 11681  5da2 8517                                sta poker+1
 11682  5da4 60                                  rts                                      ; it's all done
 11683                          
 11684                          ;.end
 11685                          ; .page
 11686                          ; .subttl Floating Point Math Package (CODE18)
 11687                          
 11688                          ; Floating Point Math Package configuration:
 11689                          ;
 11690                          ; Throughout the math package the floating point format is as follows:
 11691                          ;
 11692                          ; the sign of the first bit of the mantissa.
 11693                          ; the mantissa is 24 bits long.
 11694                          ; the binary point is to the left of the msb.
 11695                          ; number = mantissa * 2 ~ exponent.
 11696                          ; the mantissa is positive with a 1 assumed to be where the sign bit is.
 11697                          ; the sign of the exponent is the first bit of the exponent.
 11698                          ; the exponent is stored in excess $80, i.e., with a bias of +$80.
 11699                          ; so, the exponent is a signed 8 bit number with $80 added to it.
 11700                          ; an exponent of zero means the number is zero.
 11701                          ; the other bytes may not be assumed to be zero.
 11702                          ; to keep the same number in the fac while shifting,
 11703                          ; to shift right, exp:=exp+1.
 11704                          ; to shift left,  exp:=exp-1.
 11705                          ;
 11706                          ; In memory the number looks like this:
 11707                          ; the exponent as a signed number +$80.
 11708                          ; the sign bit in 7, bits 2-8 of mantissa are bits 6-0.
 11709                          ;  remember bit 1 of mantissa is always a one.
 11710                          ; bits 9-16 of the mantissa.
 11711                          ; bits 17-24 of the mantisa.
 11712                          ;
 11713                          ; Arithmetic routine calling conventions:
 11714                          ;
 11715                          ;   For one-argument functions:
 11716                          ; the argument is in the fac.
 11717                          ; the result is left in the fac.
 11718                          ;   For two-argument operations:
 11719                          ; the first argument is in arg (argexp,ho,mo,lo and argsgn).
 11720                          ;       the second argument is in the fac.
 11721                          ; the result is left in the fac.
 11722                          ;
 11723                          ; The "t" entry points to the two argument operations have both arguments setup
 11724                          ; in the respective registers. Before calling arg may have been popped off the
 11725                          ; stack and into arg, for example. The other entry point assumes (xreg) points
 11726                          ; to the argument somewhere in memory. it is unpacked into arg by "conupk".
 11727                          ;
 11728                          ; On the stack, the sgn is pushed on first, the lo,mo,ho, and finally exp.
 11729                          ; Note all things are kept unpacked in arg, fac and on the stack.
 11730                          ;
 11731                          ; It is only when something is stored away that it is packed to four bytes,
 11732                          ; the unpacked format has a sn byte reflecting the sign of the ho turned on.
 11733                          ; The exp is the same as stored format. This is done for speed of operation.
 11734                          ; .page
 11735                          
 11736  5da5 20f760             fsub             jsr conupk
 11737                          
 11738  5da8 a568               fsubt            lda facsgn
 11739  5daa 49ff                                eor #$ff                                 ; complement it
 11740  5dac 8568                                sta facsgn
 11741  5dae 456f                                eor argsgn                               ; complement arisgn
 11742  5db0 8570                                sta arisgn
 11743  5db2 a563                                lda facexp                               ; set codes on facexp
 11744  5db4 8008                                bra faddt                                ; (y)=argexp
 11745                          
 11746  5db6 20e75e             fadd5            jsr shiftr                               ; do a long shift
 11747  5db9 903b                                bcc fadd4                                ; continue with addition
 11748                          
 11749  5dbb 20f760             fadd             jsr conupk
 11750  5dbe f3d304             faddt            +lbeq movfa                              ; if fac=0, result is in arg
 11751  5dc1 a671                                ldx facov
 11752  5dc3 8658                                stx oldov
 11753  5dc5 a26a                                ldx #argexp                              ; default is shift argument
 11754  5dc7 a56a                                lda argexp                               ; if arg=0, fac is result
 11755                          
 11756  5dc9 a8                 faddc            tay                                      ; also copy (a) into (y)
 11757  5dca f38300                              +lbeq zerrts                             ; return
 11758  5dcd 38                                  sec
 11759  5dce e563                                sbc facexp
 11760  5dd0 f024                                beq fadd4                                ; no shifting
 11761  5dd2 9012                                bcc fadda                                ; branch if argexp < facexp
 11762  5dd4 8463                                sty facexp                               ; resulting exponent
 11763  5dd6 a46f                                ldy argsgn                               ; since arg is bigger, its
 11764  5dd8 8468                                sty facsgn                               ; sign is sign of result
 11765  5dda 49ff                                eor #$ff                                 ; shift a negative number of palces
 11766  5ddc 6900                                adc #0                                   ; complete negation, w/ c=1
 11767  5dde a000                                ldy #0                                   ; zero oldov
 11768  5de0 8458                                sty oldov
 11769  5de2 a263                                ldx #fac                                 ; shift the FAC instead
 11770  5de4 8004                                bra fadd1
 11771                          
 11772  5de6 a000               fadda            ldy #0
 11773  5de8 8471                                sty facov
 11774                          
 11775  5dea c9f9               fadd1            cmp #$f9                                 ; for speed and necessity.  gets most likely case to
 11776                          ;SHIFTR fastest and allows shifting of neg nums by QUINT
 11777  5dec 30c8                                bmi fadd5                                ; shift big
 11778  5dee a8                                  tay
 11779  5def a571                                lda facov                                ; set facov
 11780  5df1 5601                                lsr 1,x                                  ; gets 0 in the MSB
 11781  5df3 20fe5e                              jsr rolshf                               ; do the rolling
 11782                          
 11783  5df6 7f7057             fadd4            bbr7 arisgn,fadd2                        ; get resulting sign and if positive, add. carry is clear
 11784  5df9 a063                                ldy #facexp
 11785  5dfb e06a                                cpx #argexp                              ; fac is bigger
 11786  5dfd f002                                beq l168_1
 11787  5dff a06a                                ldy #argexp                              ; arg is bigger
 11788                          
 11789  5e01 38                 l168_1           sec                                      ; subit.
 11790  5e02 49ff                                eor #$ff
 11791  5e04 6558                                adc oldov
 11792  5e06 8571                                sta facov
 11793  5e08 b90400                              lda 4,y
 11794  5e0b f504                                sbc 4,x
 11795  5e0d 8567                                sta faclo
 11796  5e0f b90300                              lda 3,y
 11797  5e12 f503                                sbc 3,x
 11798  5e14 8566                                sta facmo
 11799  5e16 b90200                              lda 2,y
 11800  5e19 f502                                sbc 2,x
 11801  5e1b 8565                                sta facmoh
 11802  5e1d b90100                              lda 1,y
 11803  5e20 f501                                sbc 1,x
 11804  5e22 8564                                sta facho
 11805                          
 11806  5e24 b003               fadflt           bcs normal                               ; here if signs differ. if carry, FAC is set ok
 11807  5e26 20995e                              jsr negfac                               ; negate (FAC)
 11808                          
 11809  5e29 a000               normal           ldy #0
 11810  5e2b 98                                  tya
 11811  5e2c 18                                  clc
 11812                          
 11813  5e2d a664               l169_1           ldx facho
 11814  5e2f d049                                bne norm1
 11815  5e31 a665                                ldx facho+1                              ; shift 8 bits at a time for speed
 11816  5e33 8664                                stx facho
 11817  5e35 a666                                ldx facmoh+1
 11818  5e37 8665                                stx facmoh
 11819  5e39 a667                                ldx facmo+1
 11820  5e3b 8666                                stx facmo
 11821  5e3d a671                                ldx facov
 11822  5e3f 8667                                stx faclo
 11823  5e41 8471                                sty facov
 11824  5e43 6908                                adc #8
 11825  5e45 c920                                cmp #32
 11826  5e47 d0e4                                bne l169_1
 11827                          
 11828  5e49 a900               zerofc           lda #0                                   ; not needed by NORMAL, but by others
 11829  5e4b 8563               zerof1           sta facexp                               ; number must be zero
 11830  5e4d 8568               zeroml           sta facsgn                               ; make sign positive
 11831  5e4f 60                 zerrts           rts                                      ; all done
 11832                          
 11833                          
 11834  5e50 6558               fadd2            adc oldov
 11835  5e52 8571                                sta facov
 11836  5e54 a567                                lda faclo
 11837  5e56 656e                                adc arglo
 11838  5e58 8567                                sta faclo
 11839  5e5a a566                                lda facmo
 11840  5e5c 656d                                adc argmo
 11841  5e5e 8566                                sta facmo
 11842  5e60 a565                                lda facmoh
 11843  5e62 656c                                adc argmoh
 11844  5e64 8565                                sta facmoh
 11845  5e66 a564                                lda facho
 11846  5e68 656b                                adc argho
 11847  5e6a 8564                                sta facho
 11848  5e6c 8019                                bra squeez                               ; go round if signs same
 11849                          
 11850                          
 11851  5e6e 6901               norm2            adc #1                                   ; decrement shift counter
 11852  5e70 0671                                asl facov                                ; shift all left one bit
 11853  5e72 2667                                rol faclo
 11854  5e74 2666                                rol facmo
 11855  5e76 2665                                rol facmoh
 11856  5e78 2664                                rol facho
 11857                          
 11858  5e7a 10f2               norm1            bpl norm2                                ; if msb=0 shift again
 11859  5e7c 38                                  sec
 11860  5e7d e563                                sbc facexp
 11861  5e7f b0c8                                bcs zerofc
 11862  5e81 49ff                                eor #$ff
 11863  5e83 6901                                adc #1                                   ; complement
 11864  5e85 8563                                sta facexp
 11865                          
 11866  5e87 900f               squeez           bcc rndrts                               ; bits to shift?
 11867  5e89 e663               rndshf           inc facexp
 11868  5e8b f3bacf                              +lbeq overr
 11869  5e8e 6664                                ror facho
 11870  5e90 6665                                ror facmoh
 11871  5e92 6666                                ror facmo
 11872  5e94 6667                                ror faclo
 11873  5e96 6671                                ror facov
 11874  5e98 60                 rndrts           rts                                      ; all done adding
 11875                          
 11876                          
 11877  5e99 a568               negfac           lda facsgn
 11878  5e9b 49ff                                eor #$ff                                 ; complement FAC entirely
 11879  5e9d 8568                                sta facsgn
 11880                          
 11881  5e9f a564               negfch           lda facho
 11882  5ea1 49ff                                eor #$ff                                 ; complement just the number
 11883  5ea3 8564                                sta facho
 11884  5ea5 a565                                lda facmoh
 11885  5ea7 49ff                                eor #$ff
 11886  5ea9 8565                                sta facmoh
 11887  5eab a566                                lda facmo
 11888  5ead 49ff                                eor #$ff
 11889  5eaf 8566                                sta facmo
 11890  5eb1 a567                                lda faclo
 11891  5eb3 49ff                                eor #$ff
 11892  5eb5 8567                                sta faclo
 11893  5eb7 a571                                lda facov
 11894  5eb9 49ff                                eor #$ff
 11895  5ebb 8571                                sta facov
 11896  5ebd e671                                inc facov
 11897  5ebf d00e                                bne incfrt
 11898                          
 11899  5ec1 e667               incfac           inc faclo
 11900  5ec3 d00a                                bne incfrt
 11901  5ec5 e666                                inc facmo
 11902  5ec7 d006                                bne incfrt                               ; if no carry, return
 11903  5ec9 e665                                inc facmoh
 11904  5ecb d002                                bne incfrt
 11905  5ecd e664                                inc facho                                ; carry complement
 11906  5ecf 60                 incfrt           rts
 11907                          
 11908                          
 11909                          ; SHIFTR shifts (x+1:x+3) (-a) bits right.  Shifts bits to start with
 11910                          ; if possible.
 11911                          
 11912  5ed0 a227               mulshf           ldx #resho-1                             ; entry point for multiplier
 11913  5ed2 b404               shftr2           ldy 4,x                                  ; shift bits first
 11914  5ed4 8471                                sty facov
 11915  5ed6 b403                                ldy 3,x
 11916  5ed8 9404                                sty 4,x
 11917  5eda b402                                ldy 2,x                                  ; get mo
 11918  5edc 9403                                sty 3,x                                  ; store lo
 11919  5ede b401                                ldy 1,x                                  ; get ho
 11920  5ee0 9402                                sty 2,x                                  ; store mo
 11921  5ee2 acd702                              ldy bits
 11922  5ee5 9401                                sty 1,x                                  ; store ho
 11923                          
 11924  5ee7 6908               shiftr           adc #8
 11925  5ee9 30e7                                bmi shftr2
 11926  5eeb f0e5                                beq shftr2
 11927  5eed e908                                sbc #8                                   ; c can be either 1,0 and it works!
 11928  5eef a8                                  tay
 11929  5ef0 a571                                lda facov
 11930  5ef2 b014                                bcs shftrt                               ; equiv to beq here
 11931                          
 11932  5ef4 1601               shftr3           asl 1,x
 11933  5ef6 9002                                bcc l170_1
 11934  5ef8 f601                                inc 1,x
 11935  5efa 7601               l170_1           ror 1,x
 11936  5efc 7601                                ror 1,x                                  ; yes, two of them
 11937                          
 11938  5efe 7602               rolshf           ror 2,x
 11939  5f00 7603                                ror 3,x
 11940  5f02 7604                                ror 4,x                                  ; one more time
 11941  5f04 6a                                  ror
 11942  5f05 c8                                  iny
 11943  5f06 d0ec                                bne shftr3                               ; $$$ (most expensive!!!)
 11944                          
 11945  5f08 18                 shftrt           clc                                      ; clear output of FACOV
 11946  5f09 60                                  rts
 11947                          
 11948                          ;.end
 11949                          ; .page
 11950                          ; .subttl Floating Point Math Package (CODE19)
 11951                          
 11952                          ; Constants used by LOG, EXP, TRIG, and others.
 11953                          
 11954  5f0a 7f00000000         fr4              !text 127,0,0,0,0                        ; 1/4
 11955  5f0f 8080000000         neghlf           !text 128,128,0,0,0                      ; -0.5
 11956  5f14 8000000000         fhalf            !text 128,0,0,0,0                        ; 0.5
 11957  5f19 8420000000         tenc             !text 132,32,0,0,0                       ; 10.0
 11958  5f1e 82490fdaa1         pival            !text 130,73,15,218,161                  ; pi
 11959  5f23 81490fdaa2         pi2              !text 129,73,15,218,162                  ; pi/2
 11960  5f28 83490fdaa2         twopi            !text 131,73,15,218,162                  ; pi*2
 11961                          
 11962  5f2d 9b3ebc1ffd         n0999            !text $9b,$3e,$bc,$1f,$fd
 11963  5f32 9e6e6b27fd         n9999            !text $9e,$6e,$6b,$27,$fd
 11964  5f37 9e6e6b2800         nmil             !text $9e,$6e,$6b,$28,$00
 11965                          
 11966                          foutbl                                                    ; powers of 10
 11967  5f3c fa0a1f00                            !text 250,10,31,0                        ; -100,000,000
 11968  5f40 00989680                            !text 0,152,150,128                      ; 10,000,000
 11969  5f44 fff0bdc0                            !text 255,240,189,192                    ; -1,000,000
 11970  5f48 000186a0                            !text 0,1,134,160                        ; 100,000
 11971  5f4c ffffd8f0                            !text 255,255,216,240                    ; -10,000
 11972  5f50 000003e8                            !text 0,0,3,232                          ; 1,000
 11973  5f54 ffffff9c                            !text 255,255,255,156                    ; -100
 11974  5f58 0000000a                            !text 0,0,0,10                           ; 10
 11975  5f5c ffffffff                            !text 255,255,255,255                    ; -1
 11976                          fdcend
 11977                          
 11978                          ; .byte @377,@337,@012,@200 ;-2,160,000 for time converter removed [901014]
 11979                          ; .byte @000,@003,@113,@300 ;   216,000
 11980                          ; .byte @377,@377,@163,@140 ;   -36,000
 11981                          ; .byte @000,@000,@016,@020 ;     3,600
 11982                          ; .byte @377,@377,@375,@250 ;      -600
 11983                          ; .byte @000,@000,@000,@074 ;        60
 11984                          ;timend
 11985                          
 11986  5f60 03                 logcn2           !text 3                                  ; degree-1
 11987  5f61 7f5e56cb79                          !text 127,94,86,203,121                  ; 0.43425594188
 11988  5f66 80139b0b64                          !text 128,19,155,11,100                  ; 0.57658454134
 11989  5f6b 8076389316                          !text 128,118,56,147,22                  ; 0.96180075921
 11990  5f70 8238aa3b20                          !text 130,56,170,59,32                   ; 2.8853900728
 11991                          
 11992  5f75 07                 expcon           !text 7                                  ; degree-1
 11993  5f76 7134583e56                          !text 113,52,88,62,86                    ; 0.000021498763697
 11994  5f7b 74167eb31b                          !text 116,22,126,179,27                  ; 0.00014352314036
 11995  5f80 772feee385                          !text 119,47,238,227,133                 ; 0.0013422634824
 11996  5f85 7a1d841c2a                          !text 122,29,132,28,42                   ; 0.0096140170199
 11997  5f8a 7c6359580a                          !text 124,99,89,88,10                    ; 0.055505126860
 11998  5f8f 7e75fde7c6                          !text 126,117,253,231,198                ; 0.24022638462
 11999  5f94 8031721810                          !text 128,49,114,24,16                   ; 0.69314718600
 12000  5f99 8100000000         fone             !text 129,0,0,0,0                        ; 1.0
 12001                          
 12002  5f9e 8138aa3b29         logeb2           !text 129,56,170,59,41                   ; log(e) base 2
 12003  5fa3 803504f334         sqr05            !text 128,53,4,243,52                    ; 0.707106781 sqr(0.5)
 12004  5fa8 813504f334         sqr20            !text 129,53,4,243,52                    ; 1.41421356 sqr(2.0)
 12005  5fad 80317217f8         log2             !text 128,49,114,23,248                  ; 0.693147181 ln(2)
 12006                          
 12007                          
 12008  5fb2 05                 sincon           !text 5                                  ; degree-1 trig
 12009  5fb3 84e61a2d1b                          !text 132,230,26,45,27
 12010  5fb8 862807fbf8                          !text 134,40,7,251,248
 12011  5fbd 8799688901                          !text 135,153,104,137,1
 12012  5fc2 872335dfe1                          !text 135,35,53,223,225
 12013  5fc7 86a55de728                          !text 134,165,93,231,40
 12014  5fcc 83490fdaa2                          !text 131,73,15,218,162
 12015                          
 12016  5fd1 0b                 atncon           !text 11                                 ; degree-1
 12017  5fd2 76b383bdd3                          !text 118,179,131,189,211
 12018  5fd7 791ef4a6f5                          !text 121,30,244,166,245
 12019  5fdc 7b83fcb010                          !text 123,131,252,176,16
 12020  5fe1 7c0c1f67ca                          !text 124,12,31,103,202
 12021  5fe6 7cde53cbc1                          !text 124,222,83,203,193
 12022  5feb 7d1464704c                          !text 125,20,100,112,76
 12023  5ff0 7db7ea517a                          !text 125,183,234,81,122
 12024  5ff5 7d6330887e                          !text 125,99,48,136,126
 12025  5ffa 7e9244993a                          !text 126,146,68,153,58
 12026  5fff 7e4ccc91c7                          !text 126,76,204,145,199
 12027  6004 7faaaaaa13                          !text 127,170,170,170,19
 12028  6009 8100000000                          !text 129,0,0,0,0
 12029                          
 12030                          ; .page
 12031                          ; Natural Log Function
 12032                          ;
 12033                          ; Calculation is by   LN(f*2^n) = (n+LOG2(f))*LN(2)
 12034                          ; An approximation polynomial is used to calculate LOG2(f).
 12035                          
 12036                          
 12037  600e 20c162             log              jsr sign                                 ; is it positive?
 12038  6011 f3ebf1                              +lbeq fcerr                              ; can't tolerate neg or zero
 12039                          
 12040  6014 a563                                lda facexp                               ; get exponent into (a)
 12041  6016 e97f                                sbc #$7f                                 ; remove bias (carry is off)
 12042  6018 48                                  pha                                      ; save exponent a while
 12043  6019 a980                                lda #$80
 12044  601b 8563                                sta facexp                               ; result is FAC in range (0.5,1)
 12045  601d a9a3                                lda #<sqr05                              ; get pointer to sqr(0.5)
 12046  601f a05f                                ldy #>sqr05
 12047  6021 205160                              jsr romadd
 12048  6024 a9a8                                lda #<sqr20
 12049  6026 a05f                                ldy #>sqr20
 12050  6028 205d60                              jsr romdiv
 12051  602b a999                                lda #<fone
 12052  602d a05f                                ldy #>fone
 12053  602f 205760                              jsr romsub
 12054  6032 a960                                lda #<logcn2
 12055  6034 a05f                                ldy #>logcn2
 12056  6036 205a66                              jsr polyx                                ; evaluate approximation polynomial
 12057  6039 a90f                                lda #<neghlf                             ; add in last constant
 12058  603b a05f                                ldy #>neghlf
 12059  603d 205160                              jsr romadd
 12060  6040 68                                  pla                                      ; get exponent back
 12061  6041 201464                              jsr finlog
 12062  6044 a9ad                                lda #<log2                               ; multiply result by ln(2)
 12063  6046 a05f                                ldy #>log2
 12064                          
 12065                          
 12066  6048 20cc60             rommlt           jsr romupk
 12067  604b 8023                                bra fmultt                               ; multiply together
 12068                          
 12069                          
 12070  604d a914               faddh            lda #<fhalf
 12071  604f a05f                                ldy #>fhalf
 12072                          
 12073  6051 20cc60             romadd           jsr romupk
 12074  6054 8368fd                              +lbra faddt
 12075                          
 12076                          
 12077  6057 20cc60             romsub           jsr romupk
 12078  605a 834cfd                              +lbra fsubt
 12079                          
 12080                          
 12081  605d 20cc60             romdiv           jsr romupk
 12082  6060 832301                              +lbra fdivt
 12083                          
 12084                          ; .page
 12085                          ; Multiplication        FAC = ARG*FAC
 12086                          
 12087                          fmultt_c65                                                ; [910402]
 12088  6063 a56f                                lda argsgn
 12089  6065 4568                                eor facsgn
 12090  6067 8570                                sta arisgn                               ; resultant sign
 12091  6069 a663                                ldx facexp                               ; set signs on thing to multiply
 12092  606b 8003                                bra fmultt                               ; go multiply
 12093                          
 12094  606d 20f760             fmult            jsr conupk                               ; unpack the constant into arg for use
 12095                          
 12096  6070 f059               fmultt           beq multrt                               ; if FAC=0, return.  FAC is set
 12097  6072 202761                              jsr muldiv                               ; fix up the exponents
 12098  6075 a900                                lda #0                                   ; to clear result
 12099  6077 8528                                sta resho
 12100  6079 8529                                sta resmoh
 12101  607b 852a                                sta resmo
 12102  607d 852b                                sta reslo
 12103  607f a571                                lda facov
 12104  6081 209e60                              jsr mltpl1                               ; *** THIS fixes the DBL-0 bug without causing other grief!  C128-04 FAB
 12105  6084 a567                                lda faclo                                ; multiply arg by faclo
 12106  6086 209b60                              jsr mltply
 12107  6089 a566                                lda facmo                                ; multiply arg by facmo
 12108  608b 209b60                              jsr mltply
 12109  608e a565                                lda facmoh
 12110  6090 209e60                              jsr mltpl1                               ; *** THIS fixes the DBL-0 bug without causing other grief!  C128-04 FAB
 12111  6093 a564                                lda facho                                ; multiply arg by facho
 12112  6095 209e60                              jsr mltpl1
 12113  6098 836101                              +lbra movfr                              ; move result into FAC
 12114                          
 12115                          ; .page
 12116  609b f333fe             mltply           +lbeq mulshf                             ; normalize result and return. shift result right 1 byte.  exits with .c=0
 12117  609e 4a                 mltpl1           lsr
 12118  609f 0980                                ora #$80                                 ; will flag end of shifting
 12119                          
 12120  60a1 a8                 l171_1           tay
 12121  60a2 9019                                bcc l171_2                               ; if mult bit=0, just shift
 12122  60a4 18                                  clc
 12123  60a5 a52b                                lda reslo
 12124  60a7 656e                                adc arglo
 12125  60a9 852b                                sta reslo
 12126  60ab a52a                                lda resmo
 12127  60ad 656d                                adc argmo
 12128  60af 852a                                sta resmo
 12129  60b1 a529                                lda resmoh
 12130  60b3 656c                                adc argmoh
 12131  60b5 8529                                sta resmoh
 12132  60b7 a528                                lda resho
 12133  60b9 656b                                adc argho
 12134  60bb 8528                                sta resho
 12135                          
 12136  60bd 6628               l171_2           ror resho
 12137  60bf 6629                                ror resmoh
 12138  60c1 662a                                ror resmo
 12139  60c3 662b                                ror reslo
 12140  60c5 6671                                ror facov                                ; save for rounding
 12141  60c7 98                                  tya
 12142  60c8 4a                                  lsr                                      ; clear msb so we get a closer to 0
 12143  60c9 d0d6                                bne l171_1                               ; slow as a turtle
 12144                          
 12145  60cb 60                 multrt           rts
 12146                          
 12147                          ; .page
 12148                          ; Unpack a ROM constant into the FAC
 12149                          
 12150  60cc 8524               romupk           sta index1
 12151  60ce 8425                                sty index1+1
 12152  60d0 a004                                ldy #4
 12153  60d2 b124                                lda (index1),y                           ; it's in ROM, so ok to use ind
 12154  60d4 856e                                sta arglo
 12155  60d6 88                                  dey
 12156  60d7 b124                                lda (index1),y
 12157  60d9 856d                                sta argmo
 12158  60db 88                                  dey
 12159  60dc b124                                lda (index1),y
 12160  60de 856c                                sta argmoh
 12161  60e0 88                                  dey
 12162  60e1 b124                                lda (index1),y
 12163  60e3 856f                                sta argsgn
 12164  60e5 4568                                eor facsgn
 12165  60e7 8570                                sta arisgn
 12166  60e9 a56f                                lda argsgn
 12167  60eb 0980                                ora #$80
 12168  60ed 856b                                sta argho
 12169  60ef 88                                  dey
 12170  60f0 b124                                lda (index1),y
 12171  60f2 856a                                sta argexp
 12172  60f4 a563                                lda facexp                               ; sets code of facexp
 12173  60f6 60                                  rts
 12174                          
 12175                          ; .page
 12176                          ; Unpack a RAM constant into the FAC
 12177                          
 12178  60f7 8524               conupk           sta index1
 12179  60f9 8425                                sty index1+1
 12180                          
 12181                          ; lda mmu_config_reg
 12182                          ; pha   ;preserve caller's memory config????
 12183                          
 12184  60fb a004                                ldy #4
 12185  60fd 20d522                              jsr indin1_ram1
 12186  6100 856e                                sta arglo
 12187  6102 88                                  dey
 12188  6103 20d522                              jsr indin1_ram1
 12189  6106 856d                                sta argmo
 12190  6108 88                                  dey
 12191  6109 20d522                              jsr indin1_ram1
 12192  610c 856c                                sta argmoh
 12193  610e 88                                  dey
 12194  610f 20d522                              jsr indin1_ram1
 12195  6112 856f                                sta argsgn
 12196  6114 4568                                eor facsgn
 12197  6116 8570                                sta arisgn
 12198  6118 a56f                                lda argsgn
 12199  611a 0980                                ora #$80
 12200  611c 856b                                sta argho
 12201  611e 88                                  dey
 12202  611f 20d522                              jsr indin1_ram1
 12203  6122 856a                                sta argexp
 12204                          
 12205                          ; pla
 12206                          ; sta mmu_config_reg ;restore caller's memory config????
 12207                          
 12208  6124 a563                                lda facexp                               ; set codes of facexp
 12209  6126 60                                  rts
 12210                          
 12211                          ; .page
 12212                          ; Check special cases and add exponents for FMULT, FDIV
 12213                          
 12214                          muldiv
 12215  6127 a56a                                lda argexp                               ; exp of arg=0?
 12216  6129 f01f               mldexp           beq zeremv                               ; so we get zero exponent
 12217  612b 18                                  clc
 12218  612c 6563                                adc facexp                               ; result is in (a)
 12219  612e 9005                                bcc l172_1                               ; find (c) xor (n)
 12220  6130 3315cd                              +lbmi overr                              ; overflow if bits match
 12221  6133 18                                  clc
 12222  6134 2c                                  !text $2c
 12223                          
 12224  6135 1013               l172_1           bpl zeremv                               ; underflow
 12225  6137 6980                                adc #$80                                 ; add bias
 12226  6139 8563                                sta facexp
 12227  613b f310fd                              +lbeq zeroml                             ; zero the rest of it
 12228  613e a570                                lda arisgn
 12229  6140 8568                                sta facsgn                               ; arisgn is result's sign
 12230  6142 60                                  rts                                      ; done
 12231                          
 12232                          
 12233  6143 a568               mldvex           lda facsgn                               ; get sign
 12234  6145 49ff                                eor #$ff                                 ; complement it
 12235  6147 33fecc                              +lbmi overr
 12236                          
 12237  614a 68                 zeremv           pla                                      ; get addr off stack
 12238  614b 68                                  pla
 12239  614c 83fbfc                              +lbra zerofc                             ; underflow
 12240                          
 12241                          ; .page
 12242                          ; Multiply FAC by 10
 12243                          
 12244  614f 20a362             mul10            jsr movaf                                ; copy FAC into ARG
 12245  6152 aa                                  tax
 12246  6153 f012                                beq mul10r                               ; if (FAC)=0, got answer
 12247  6155 18                                  clc
 12248  6156 6902                                adc #2                                   ; augment exp by 2
 12249  6158 b3edcc                              +lbcs overr                              ; overflow
 12250                          
 12251  615b a200               finml6           ldx #0
 12252  615d 8670                                stx arisgn                               ; signs are same
 12253  615f 20c95d                              jsr faddc                                ; add together
 12254  6162 e663                                inc facexp                               ; multiply by two
 12255  6164 f3e1cc                              +lbeq overr                              ; overflow
 12256                          
 12257  6167 60                 mul10r           rts
 12258                          
 12259                          ; .page
 12260  6168 20a362             div10            jsr movaf                                ; move FAC to ARG
 12261  616b a919                                lda #<tenc
 12262  616d a05f                                ldy #>tenc                               ; point to constant of 10.0
 12263  616f a200                                ldx #0                                   ; signs are both positive
 12264                          
 12265  6171 8670               fdivf            stx arisgn
 12266  6173 200e62                              jsr movfm                                ; put it into FAC
 12267  6176 800d                                bra fdivt
 12268                          
 12269                          fdivt_c65                                                 ; [910402]
 12270  6178 a56f                                lda argsgn
 12271  617a 4568                                eor facsgn
 12272  617c 8570                                sta arisgn                               ; resultant sign
 12273  617e a663                                ldx facexp                               ; set signs on thing to divide
 12274  6180 8003                                bra fdivt                                ; go divide
 12275                          
 12276  6182 20f760             fdiv             jsr conupk                               ; unpack constant
 12277  6185 f3bdcc             fdivt            +lbeq doverr                             ; can't divide by zero
 12278  6188 20b262                              jsr round                                ; take FACOV into account in FAC
 12279  618b a900                                lda #0                                   ; negate facexp
 12280  618d 38                                  sec
 12281  618e e563                                sbc facexp
 12282  6190 8563                                sta facexp
 12283  6192 202761                              jsr muldiv                               ; fix up exponents
 12284  6195 e663                                inc facexp                               ; scale it right
 12285  6197 f3aecc                              +lbeq overr                              ; overflow
 12286  619a a2fc                                ldx #$fc                                 ; set up procedure
 12287  619c a901                                lda #1
 12288                          
 12289                          ; .page
 12290                          divide                                                    ; this is the best code in the whole pile
 12291  619e a46b                                ldy argho                                ; see what relation holds
 12292  61a0 c464                                cpy facho
 12293  61a2 d010                                bne savquo                               ; (c)=0,1. n(c=0)=0.
 12294  61a4 a46c                                ldy argmoh
 12295  61a6 c465                                cpy facmoh
 12296  61a8 d00a                                bne savquo
 12297  61aa a46d                                ldy argmo
 12298  61ac c466                                cpy facmo
 12299  61ae d004                                bne savquo
 12300  61b0 a46e                                ldy arglo
 12301  61b2 c467                                cpy faclo
 12302                          
 12303  61b4 08                 savquo           php
 12304  61b5 2a                                  rol                                      ; save result
 12305  61b6 9009                                bcc qshft                                ; if not done, continue
 12306  61b8 e8                                  inx
 12307  61b9 952b                                sta reslo,x
 12308  61bb f031                                beq ld100
 12309  61bd 1033                                bpl divnrm                               ; note this req 1 no ram then access
 12310  61bf a901                                lda #1
 12311                          
 12312  61c1 28                 qshft            plp                                      ; return condition codes
 12313  61c2 b00e                                bcs divsub                               ; FAC <= ARG
 12314                          
 12315  61c4 066e               shfarg           asl arglo                                ; shift ARG one place left
 12316  61c6 266d                                rol argmo
 12317  61c8 266c                                rol argmoh
 12318  61ca 266b                                rol argho
 12319  61cc b0e6                                bcs savquo                               ; save a result of one for this position and divide
 12320  61ce 30ce                                bmi divide                               ; if msb on, go decide whether to sub
 12321  61d0 10e2                                bpl savquo
 12322                          
 12323                          ; .page
 12324  61d2 a8                 divsub           tay                                      ; notice c must be on here
 12325  61d3 a56e                                lda arglo
 12326  61d5 e567                                sbc faclo
 12327  61d7 856e                                sta arglo
 12328  61d9 a56d                                lda argmo
 12329  61db e566                                sbc facmo
 12330  61dd 856d                                sta argmo
 12331  61df a56c                                lda argmoh
 12332  61e1 e565                                sbc facmoh
 12333  61e3 856c                                sta argmoh
 12334  61e5 a56b                                lda argho
 12335  61e7 e564                                sbc facho
 12336  61e9 856b                                sta argho
 12337  61eb 98                                  tya
 12338  61ec 80d6                                bra shfarg
 12339                          
 12340                          
 12341                          
 12342  61ee a940               ld100            lda #$40                                 ; only want two more bits
 12343  61f0 80cf                                bra qshft                                ; always branches
 12344                          
 12345                          
 12346                          
 12347  61f2 0a                 divnrm           asl                                      ; get last two bits into MSB and B6
 12348  61f3 0a                                  asl
 12349  61f4 0a                                  asl
 12350  61f5 0a                                  asl
 12351  61f6 0a                                  asl
 12352  61f7 0a                                  asl
 12353  61f8 8571                                sta facov
 12354  61fa 28                                  plp
 12355                          
 12356                          
 12357                          ; .page
 12358  61fb a528               movfr            lda resho                                ; move result to FAC
 12359  61fd 8564                                sta facho
 12360  61ff a529                                lda resmoh
 12361  6201 8565                                sta facmoh
 12362  6203 a52a                                lda resmo
 12363  6205 8566                                sta facmo
 12364  6207 a52b                                lda reslo                                ; move lo and sign
 12365  6209 8567                                sta faclo
 12366  620b 831cfc                              +lbra normal                             ; all done
 12367                          
 12368                          
 12369                          
 12370  620e 8524               movfm            sta index1                               ; move memory into FAC from ROM (unpacked)
 12371  6210 8425                                sty index1+1
 12372  6212 a004                                ldy #4
 12373  6214 b124                                lda (index1),y
 12374  6216 8567                                sta faclo
 12375  6218 88                                  dey
 12376  6219 b124                                lda (index1),y
 12377  621b 8566                                sta facmo
 12378  621d 88                                  dey
 12379  621e b124                                lda (index1),y
 12380  6220 8565                                sta facmoh
 12381  6222 88                                  dey
 12382  6223 b124                                lda (index1),y
 12383  6225 8568                                sta facsgn
 12384  6227 0980                                ora #$80
 12385  6229 8564                                sta facho
 12386  622b 88                                  dey
 12387  622c b124                                lda (index1),y
 12388  622e 8563                                sta facexp
 12389  6230 8471                                sty facov
 12390  6232 60                                  rts
 12391                          
 12392                          ; .page
 12393                          ; Move number from FAC to memory
 12394                          
 12395  6233 a25e               mov2f            ldx #tempf2                              ; move from FAC to temp FAC2
 12396  6235 2c                                  !text $2c
 12397                          
 12398  6236 a259               mov1f            ldx #tempf1                              ; move from FAC to temp FAC1
 12399                          
 12400  6238 a000                                ldy #0
 12401  623a 20b262             movmf            jsr round
 12402  623d 8624                                stx index1
 12403  623f 8425                                sty index1+1
 12404  6241 a004                                ldy #4
 12405  6243 a567                                lda faclo
 12406  6245 9124                                sta (index),y                            ; BasePage
 12407  6247 88                                  dey
 12408  6248 a566                                lda facmo
 12409  624a 9124                                sta (index),y                            ; BasePage
 12410  624c 88                                  dey
 12411  624d a565                                lda facmoh
 12412  624f 9124                                sta (index),y                            ; BasePage
 12413  6251 88                                  dey
 12414  6252 a568                                lda facsgn                               ; include sign in ho
 12415  6254 097f                                ora #$7f
 12416  6256 2564                                and facho
 12417  6258 9124                                sta (index),y                            ; BasePage
 12418  625a 88                                  dey
 12419  625b a563                                lda facexp
 12420  625d 9124                                sta (index),y                            ; BasePage
 12421  625f 8471                                sty facov                                ; zero it since rounded
 12422  6261 60                                  rts                                      ; (y)=0
 12423                          
 12424                          ; .page
 12425                          movmf_ram1
 12426  6262 20b262                              jsr round
 12427  6265 8624                                stx index1
 12428  6267 8425                                sty index1+1
 12429  6269 da                                  phx
 12430  626a a224                                ldx #index
 12431  626c a004                                ldy #4
 12432  626e a567                                lda faclo
 12433  6270 20f022                              jsr sta_far_ram1                         ; sta (index),y
 12434  6273 88                                  dey
 12435  6274 a566                                lda facmo
 12436  6276 20f022                              jsr sta_far_ram1                         ; sta (index),y
 12437  6279 88                                  dey
 12438  627a a565                                lda facmoh
 12439  627c 20f022                              jsr sta_far_ram1                         ; sta (index),y
 12440  627f 88                                  dey
 12441  6280 a568                                lda facsgn                               ; include sign in ho
 12442  6282 097f                                ora #$7f
 12443  6284 2564                                and facho
 12444  6286 20f022                              jsr sta_far_ram1                         ; sta (index),y
 12445  6289 88                                  dey
 12446  628a a563                                lda facexp
 12447  628c 20f022                              jsr sta_far_ram1                         ; sta (index),y
 12448  628f 8471                                sty facov                                ; zero it since rounded
 12449  6291 fa                                  plx
 12450  6292 60                                  rts                                      ; (y)=0
 12451                          
 12452                          ; .page
 12453  6293 a56f               movfa            lda argsgn
 12454                          
 12455  6295 8568               movfa1           sta facsgn
 12456                          
 12457  6297 a205                                ldx #5
 12458  6299 b569               l173_1           lda argexp-1,x
 12459  629b 9562                                sta facexp-1,x
 12460  629d ca                                  dex
 12461  629e d0f9                                bne l173_1
 12462  62a0 8671                                stx facov
 12463  62a2 60                                  rts
 12464                          
 12465                          
 12466  62a3 20b262             movaf            jsr round
 12467                          
 12468  62a6 a206               movef            ldx #6
 12469  62a8 b562               l174_1           lda facexp-1,x
 12470  62aa 9569                                sta argexp-1,x
 12471  62ac ca                                  dex
 12472  62ad d0f9                                bne l174_1
 12473  62af 8671                                stx facov                                ; zero it since rounded
 12474  62b1 60                 movrts           rts
 12475                          
 12476                          
 12477                          ; .page
 12478  62b2 a563               round            lda facexp                               ; zero?
 12479  62b4 f0fb                                beq movrts                               ; yes, done rounding
 12480  62b6 0671                                asl facov                                ; round?
 12481  62b8 90f7                                bcc movrts                               ; no, msb off
 12482                          
 12483  62ba 20c15e             incrnd           jsr incfac                               ; yes, add one to lsb(FAC) /// entry from EXP
 12484                          ;note .c=1 since incfac doesn't touch .c
 12485  62bd f3cafb                              +lbeq rndshf                             ; carry:   squeeze msb in and rts
 12486  62c0 60                                  rts                                      ; no carry: rts now
 12487                          
 12488                          
 12489                          
 12490                          ; Put sign in FAC into (a).
 12491                          
 12492  62c1 a563               sign             lda facexp
 12493  62c3 f009                                beq signrt                               ; if number is zero, so is result
 12494                          
 12495  62c5 a568               fcsign           lda facsgn
 12496  62c7 2a                 fcomps           rol
 12497  62c8 a9ff                                lda #$ff                                 ; assume negative
 12498  62ca b002                                bcs signrt
 12499  62cc a901                                lda #1                                   ; get +1
 12500  62ce 60                 signrt           rts
 12501                          
 12502                          
 12503                          ; .page
 12504                          ; SGN function
 12505                          
 12506  62cf 20c162             sgn              jsr sign
 12507                          
 12508                          ;float the signed integer in accb
 12509  62d2 8564               float            sta facho                                ; put (accb) in high order
 12510  62d4 a900                                lda #0
 12511  62d6 8565                                sta facho+1
 12512  62d8 a288                                ldx #$88                                 ; get the exponent
 12513                          ;float the signed number in FAC
 12514                          
 12515                          
 12516  62da a564               floats           lda facho
 12517  62dc 49ff                                eor #$ff
 12518  62de 2a                                  rol                                      ; get comp of sign in carry
 12519  62df a900               floatc           lda #0                                   ; zero (a) but not carry
 12520  62e1 8567                                sta faclo
 12521  62e3 8566                                sta facmo
 12522                          
 12523  62e5 8663               floatb           stx facexp
 12524  62e7 8571                                sta facov
 12525  62e9 8568                                sta facsgn
 12526  62eb 8337fb                              +lbra fadflt
 12527                          
 12528                          
 12529                          
 12530                          
 12531                          ; Absolute value of FAC
 12532                          
 12533  62ee 4668               abs              lsr facsgn
 12534  62f0 60                                  rts
 12535                          
 12536                          
 12537                          ; .page
 12538                          ; Compare two numbers:
 12539                          ;
 12540                          ; a=1  if  ARG < FAC
 12541                          ; a=0  if  ARG = FAC
 12542                          ; a=-1 if  ARG > FAC
 12543                          
 12544  62f1 8526               fcomp            sta index2
 12545  62f3 8427                                sty index2+1
 12546  62f5 a000                                ldy #0
 12547  62f7 b126                                lda (index2),y                           ; has argexp
 12548  62f9 c8                                  iny                                      ; bump pointer up
 12549  62fa aa                                  tax                                      ; save a in x and reset codes
 12550  62fb f0c4                                beq sign
 12551  62fd b126                                lda (index2),y
 12552  62ff 4568                                eor facsgn                               ; signs the same
 12553  6301 30c2                                bmi fcsign                               ; signs differ so result is
 12554  6303 e463                                cpx facexp                               ; sign of FAC again
 12555  6305 d021                                bne l175_1
 12556                          
 12557  6307 b126                                lda (index2),y
 12558  6309 0980                                ora #$80
 12559  630b c564                                cmp facho
 12560  630d d019                                bne l175_1
 12561  630f c8                                  iny
 12562  6310 b126                                lda (index2),y
 12563  6312 c565                                cmp facmoh
 12564  6314 d012                                bne l175_1
 12565  6316 c8                                  iny
 12566  6317 b126                                lda (index2),y
 12567  6319 c566                                cmp facmo
 12568  631b d00b                                bne l175_1
 12569  631d c8                                  iny
 12570  631e a97f                                lda #$7f
 12571  6320 c571                                cmp facov
 12572  6322 b126                                lda (index2),y
 12573  6324 e567                                sbc faclo                                ; get zero if equal
 12574  6326 f028                                beq qintrt                               ; rts
 12575                          
 12576  6328 a568               l175_1           lda facsgn
 12577  632a 9002                                bcc l175_2
 12578  632c 49ff                                eor #$ff
 12579  632e 8097               l175_2           bra fcomps                               ; a part of sign sets up (a)
 12580                          
 12581                          ;.end
 12582                          ; .page
 12583                          ; .subttl Floating Point Math Package (CODE21)
 12584                          
 12585                          ; Quick Greatest Integer Function
 12586                          ;
 12587                          ; Leaves INT(FAC) in FACHO&MO&LO signed
 12588                          ; Assumes FAC < 2~23 =8388608
 12589                          
 12590  6330 a563               qint             lda facexp
 12591  6332 f04f                                beq clrfac                               ; if zero, got it
 12592  6334 38                                  sec
 12593  6335 e9a0                                sbc #$a0                                 ; get number of places to shift
 12594                          
 12595  6337 7f680a                              bbr7 facsgn,l176_1
 12596                          
 12597  633a aa                                  tax
 12598  633b a9ff                                lda #$ff
 12599  633d 8dd702                              sta bits                                 ; put $ff in when shftr shifts bytes
 12600  6340 209f5e                              jsr negfch                               ; truly negate quantity in FAC
 12601  6343 8a                                  txa
 12602                          
 12603  6344 a263               l176_1           ldx #fac
 12604  6346 c9f9                                cmp #$f9
 12605  6348 1007                                bpl qint1                                ; if number of places > 7 shift 1 place at a time
 12606  634a 20e75e                              jsr shiftr                               ; start shifting bytes, then bits
 12607  634d 8cd702                              sty bits                                 ; zero bits since adder wants zero
 12608  6350 60                 qintrt           rts
 12609                          
 12610                          
 12611  6351 a8                 qint1            tay                                      ; put count in counter
 12612  6352 a568                                lda facsgn
 12613  6354 2980                                and #$80                                 ; get sign bit
 12614  6356 4664                                lsr facho                                ; save first shifted byte
 12615  6358 0564                                ora facho
 12616  635a 8564                                sta facho
 12617  635c 20fe5e                              jsr rolshf                               ; shift the rest
 12618  635f 8cd702                              sty bits                                 ; zero (bits)
 12619  6362 60                                  rts
 12620                          
 12621                          
 12622                          ; .page
 12623                          ; Greatest Integer Function
 12624                          
 12625  6363 a563               int              lda facexp
 12626  6365 c9a0                                cmp #$a0
 12627  6367 b023                                bcs intrts                               ; forget it
 12628  6369 20b262                              jsr round                                ; round FAC per FACOV (fixes the  INT(.9+.1) -> 0  Microsoft bug.  FAB)
 12629  636c 203063                              jsr qint                                 ; INT(FAC)
 12630  636f 8471                                sty facov                                ; clr overflow byte
 12631  6371 a568                                lda facsgn
 12632  6373 8468                                sty facsgn                               ; make FAC look positive
 12633  6375 4980                                eor #$80                                 ; get complement of sign in carry
 12634  6377 2a                                  rol
 12635  6378 a9a0                                lda #$a0                                 ; @230+8
 12636  637a 8563                                sta facexp
 12637  637c a567                                lda faclo
 12638  637e 850a                                sta integr
 12639  6380 83a2fa                              +lbra fadflt
 12640                          
 12641                          
 12642  6383 8564               clrfac           sta facho                                ; make it really zero
 12643  6385 8565                                sta facmoh
 12644  6387 8566                                sta facmo
 12645  6389 8567                                sta faclo
 12646  638b a8                                  tay
 12647  638c 60                 intrts           rts
 12648                          
 12649                          ; .page
 12650                          ; Floating Point Input Routine.
 12651                          ;
 12652                          ; Number input is left in FAC.  At entry (TXTPTR) points to the first character
 12653                          ; in a text buffer.  The first character is also in (a).  FIN packs the digits
 12654                          ; into the FAC as an integer and keeps track of where the decimal point is.
 12655                          ; (DPTFLG) tells whether a dp has been seen.  (DECCNT) is the number of digits
 12656                          ; after the dp.  At the end (DECCNT) and the exponent are used to determine how
 12657                          ; many times to multiply or divide by ten to get the correct number.
 12658                          
 12659                          
 12660  638d 8ed202             fin              stx fin_bank                             ; save bank number where string is stored
 12661                          
 12662  6390 a000                                ldy #0                                   ; zero facsgn, sgnflg
 12663  6392 a20a                                ldx #$0a                                 ; zero exp and ho (and moh)
 12664  6394 945f               l177_1           sty deccnt,x                             ; zero mo and lo
 12665  6396 ca                                  dex                                      ; zero tenexp and expsgn
 12666  6397 10fb                                bpl l177_1                               ; zero deccnt, dptflg
 12667                          
 12668  6399 900f                                bcc findgq                               ; flags still set from chrget
 12669  639b c92d                                cmp #'-'                                 ; a negative sign?
 12670  639d d004                                bne qplus                                ; no, try plus sign
 12671  639f 8669                                stx sgnflg                               ; it's negative. (x=@377)
 12672  63a1 8004                                bra finc                                 ; always branches
 12673                          
 12674                          ; .page
 12675  63a3 c92b               qplus            cmp #'+'                                 ; plus sign?
 12676  63a5 d005                                bne fin1                                 ; yes, skip it
 12677                          
 12678  63a7 205764             finc             jsr fin_chrget
 12679                          
 12680  63aa 9056               findgq           bcc findig
 12681                          
 12682  63ac c92e               fin1             cmp #'.'                                 ; the dp?
 12683  63ae f02c                                beq findp                                ; no kidding
 12684  63b0 c945                                cmp #'E'                                 ; exponent follows
 12685  63b2 d02d                                bne fine                                 ; no
 12686                          
 12687  63b4 205764                              jsr fin_chrget                           ; yes, get another, to check sign of exponent
 12688  63b7 9017                                bcc fnedg1                               ; is it a digit. (easier than backing up pointer)
 12689  63b9 c9ab                                cmp #minus_token                         ; minus?
 12690  63bb f00e                                beq finec1                               ; negate
 12691  63bd c92d                                cmp #'-'                                 ; minus sign?
 12692  63bf f00a                                beq finec1
 12693  63c1 c9aa                                cmp #plus_token                          ; plus?
 12694  63c3 f008                                beq finec
 12695  63c5 c92b                                cmp #'+'                                 ; plus sign?
 12696  63c7 f004                                beq finec
 12697  63c9 8007                                bra finec2
 12698                          
 12699  63cb 6662               finec1           ror expsgn                               ; turn it on
 12700                          
 12701  63cd 205764             finec            jsr fin_chrget                           ; get another
 12702                          
 12703  63d0 9055               fnedg1           bcc finedg                               ; it is a digit
 12704  63d2 7f620c             finec2           bbr7 expsgn,fine
 12705  63d5 a900                                lda #0
 12706  63d7 38                                  sec
 12707  63d8 e560                                sbc tenexp
 12708  63da 8007                                bra fine1
 12709                          
 12710  63dc 6661               findp            ror dptflg
 12711  63de 6f61c6                              bbr6 dptflg,finc
 12712                          
 12713  63e1 a560               fine             lda tenexp
 12714  63e3 38                 fine1            sec
 12715  63e4 e55f                                sbc deccnt                               ; get number of places to shift
 12716  63e6 8560                                sta tenexp
 12717  63e8 f012                                beq finqng                               ; negate?
 12718  63ea 1009                                bpl finmul                               ; positive, so multiply
 12719                          
 12720  63ec 206861             findiv           jsr div10
 12721  63ef e660                                inc tenexp                               ; done?
 12722  63f1 d0f9                                bne findiv                               ; no
 12723  63f3 8007                                bra finqng                               ; yes
 12724                          
 12725                          
 12726  63f5 204f61             finmul           jsr mul10
 12727  63f8 c660                                dec tenexp                               ; done?
 12728  63fa d0f9                                bne finmul                               ; no
 12729  63fc a569               finqng           lda sgnflg
 12730  63fe 33fc01                              +lbmi negop                              ; if negative, negate and return
 12731  6401 60                                  rts                                      ; if positive, return
 12732                          
 12733                          
 12734                          
 12735  6402 48                 findig           pha
 12736  6403 7f6102                              bbr7 dptflg,l178_1
 12737  6406 e65f                                inc deccnt
 12738  6408 204f61             l178_1           jsr mul10
 12739  640b 68                                  pla                                      ; get it back
 12740  640c 38                                  sec
 12741  640d e930                                sbc #'0'
 12742  640f 201464                              jsr finlog                               ; add it in
 12743  6412 8093                                bra finc
 12744                          
 12745                          
 12746                          
 12747  6414 48                 finlog           pha
 12748  6415 20a362                              jsr movaf                                ; save it for later
 12749  6418 68                                  pla
 12750  6419 20d262                              jsr float                                ; float the value in (a)
 12751                          
 12752                          faddt_c65                                                 ; [910402]
 12753  641c a56f                                lda argsgn
 12754  641e 4568                                eor facsgn
 12755  6420 8570                                sta arisgn                               ; resultant sign
 12756  6422 a663                                ldx facexp                               ; set signs on thing to add
 12757  6424 8398f9                              +lbra faddt                              ; add together and return
 12758                          
 12759                          ; .page
 12760                          ; Pack in the next digit of the exponent.
 12761                          ; Multiply the old exp by 10 and add in the next digit.
 12762                          ; (note: does not check for exp overflow)
 12763                          
 12764  6427 a560               finedg           lda tenexp                               ; get exp so far
 12765  6429 c90a                                cmp #10                                  ; will result be >= 100?
 12766  642b 9008                                bcc l179_1
 12767  642d a964                                lda #100
 12768  642f ff6220                              bbs7 expsgn,l179_4                       ; if neg exp, no chk for overr
 12769  6432 8313ca                              +lbra overr
 12770                          
 12771  6435 0a                 l179_1           asl                                      ; max is 120
 12772  6436 0a                                  asl                                      ; mult by 2 twice
 12773  6437 18                                  clc                                      ; possible shift out of high
 12774  6438 6560                                adc tenexp                               ; like multiplying by five
 12775  643a 0a                                  asl                                      ; and now by ten
 12776  643b 18                                  clc
 12777  643c a000                                ldy #0
 12778  643e 8578                                sta syntmp
 12779                          
 12780  6440 add202                              lda fin_bank                             ; text or string bank?
 12781  6443 d005                                bne l179_2
 12782  6445 20c522                              jsr indtxt                               ; text
 12783  6448 8003                                bra l179_3
 12784  644a 20d522             l179_2           jsr indin1_ram1                          ; string
 12785                          
 12786  644d 6578               l179_3           adc syntmp
 12787  644f 38                                  sec
 12788  6450 e930                                sbc #'0'
 12789  6452 8560               l179_4           sta tenexp                               ; save result
 12790  6454 8377ff                              +lbra finec
 12791                          
 12792                          ; .page
 12793                          ; Get a character from either text or string area, and set the flags
 12794                          ; in the manner performed by CHRGET.
 12795                          
 12796                          fin_chrget
 12797  6457 add202                              lda fin_bank                             ; text or string bank?
 12798  645a f327be                              +lbeq chrget                             ; get byte from text bank via normal CHRGET mechanism
 12799                          
 12800                          fin_chrget_1                                              ; get byte from string bank via modified CHRGET mechanism
 12801  645d e324                                inw index1
 12802                          fin_chrget_2
 12803  645f a000                                ldy #0
 12804  6461 20d522                              jsr indin1_ram1
 12805  6464 c93a                                cmp #':'
 12806  6466 b00a                                bcs l180_1
 12807  6468 c920                                cmp #' '
 12808  646a f0f1                                beq fin_chrget_1                         ; skip over spaces
 12809  646c 38                                  sec
 12810  646d e930                                sbc #'0'                                 ; set up .c as CHRGET would
 12811  646f 38                                  sec
 12812  6470 e9d0                                sbc #$d0
 12813  6472 60                 l180_1           rts
 12814                          
 12815                          ;.end
 12816                          ; .page
 12817                          ; .subttl Floating Point Math Package (CODE22,23)
 12818                          
 12819  6473 207dff             inprt            jsr _primm
 12820  6476 20494e2000                          !text " IN ",0
 12821                          
 12822  647b a53c               curprt           lda curlin+1
 12823  647d a63b                                ldx curlin
 12824                          
 12825  647f 8564               linprt           sta facho
 12826  6481 8665                                stx facho+1
 12827  6483 a290                                ldx #$90                                 ; exponent of 16
 12828  6485 38                                  sec                                      ; number is positive
 12829  6486 20df62                              jsr floatc
 12830  6489 209164                              jsr foutc
 12831  648c 83add3                              +lbra strout                             ; print and return
 12832                          
 12833                          
 12834  648f a001               fout             ldy #1
 12835  6491 a920               foutc            lda #' '                                 ; if positive, print space
 12836  6493 7f6802                              bbr7 facsgn,l181_1
 12837  6496 a92d                                lda #'-'                                 ; if neg
 12838  6498 99ff00             l181_1           sta fbuffr-1,y                           ; store the character
 12839  649b 8568                                sta facsgn                               ; make FAC pos for QINT
 12840  649d 8472                                sty fbufpt                               ; save for later
 12841  649f c8                                  iny
 12842  64a0 a930                                lda #'0'                                 ; get zero to type if FAC=0
 12843  64a2 a663                                ldx facexp
 12844  64a4 f30901                              +lbeq fout19
 12845                          
 12846  64a7 a900                                lda #0
 12847  64a9 e080                                cpx #$80                                 ; is number < 1?
 12848  64ab f002                                beq l181_2                               ; no
 12849  64ad b009                                bcs l181_3
 12850                          
 12851  64af a937               l181_2           lda #<nmil                               ; mult by 10~6
 12852  64b1 a05f                                ldy #>nmil
 12853  64b3 204860                              jsr rommlt
 12854  64b6 a9f7                                lda #$f7
 12855  64b8 855f               l181_3           sta deccnt                               ; save count or zero it
 12856                          
 12857  64ba a932               l181_4           lda #<n9999
 12858  64bc a05f                                ldy #>n9999
 12859  64be 20f162                              jsr fcomp                                ; is number > 999999.499 or 999999999.5?
 12860  64c1 f01e                                beq l181_9                               ; go to biggies
 12861  64c3 1012                                bpl l181_7                               ; yes, make it smaller
 12862                          
 12863  64c5 a92d               l181_5           lda #<n0999
 12864  64c7 a05f                                ldy #>n0999
 12865  64c9 20f162                              jsr fcomp                                ; is number > 99999.9499 or 99999999.90625?
 12866  64cc f002                                beq l181_6
 12867  64ce 100e                                bpl l181_8                               ; yes. done multiplying
 12868                          
 12869  64d0 204f61             l181_6           jsr mul10                                ; make it bigger
 12870  64d3 c65f                                dec deccnt
 12871  64d5 d0ee                                bne l181_5                               ; see if that does it (this always goes)
 12872                          
 12873  64d7 206861             l181_7           jsr div10                                ; make it smaller
 12874  64da e65f                                inc deccnt
 12875  64dc d0dc                                bne l181_4                               ; see if that does it (this always goes)
 12876                          
 12877  64de 204d60             l181_8           jsr faddh                                ; add a half to round up
 12878                          
 12879                          
 12880  64e1 203063             l181_9           jsr qint                                 ; biggies.
 12881  64e4 a201                                ldx #1                                   ; decimal point count
 12882  64e6 a55f                                lda deccnt
 12883  64e8 18                                  clc
 12884  64e9 690a                                adc #$0a                                 ; should number be printed in E notation?  (ie, is number .lt. .01?)
 12885  64eb 3009                                bmi l181_10                              ; yes
 12886  64ed c90b                                cmp #$0b                                 ; is it > 999999 or 9999999999?
 12887  64ef b006                                bcs l181_11                              ; yes, use E notation
 12888  64f1 69ff                                adc #$ff                                 ; number of places before decimal point
 12889  64f3 aa                                  tax                                      ; put into accx
 12890  64f4 a902                                lda #2                                   ; no E notation
 12891  64f6 38                 l181_10          sec
 12892                          
 12893  64f7 e902               l181_11          sbc #2                                   ; effectively add 5 to orig exp
 12894  64f9 8560                                sta tenexp                               ; that is the exponent to print
 12895  64fb 865f                                stx deccnt                               ; number of decimal places
 12896  64fd 8a                                  txa
 12897  64fe f002                                beq l181_12
 12898  6500 1013                                bpl l181_14                              ; some places before dec pnt
 12899                          
 12900  6502 a472               l181_12          ldy fbufpt                               ; get pointer to output
 12901  6504 a92e                                lda #'.'                                 ; put in "."
 12902  6506 c8                                  iny
 12903  6507 99ff00                              sta fbuffr-1,y
 12904  650a 8a                                  txa
 12905  650b f006                                beq l181_13
 12906  650d a930                                lda #'0'                                 ; get the ensuing zero
 12907  650f c8                                  iny
 12908  6510 99ff00                              sta fbuffr-1,y
 12909                          
 12910  6513 8472               l181_13          sty fbufpt                               ; save it for later
 12911                          
 12912  6515 a000               l181_14          ldy #0
 12913                          
 12914  6517 a280               foutim           ldx #$80                                 ; first pass through, accb has msb set
 12915  6519 a567               fout2            lda faclo
 12916  651b 18                                  clc
 12917  651c 793f5f                              adc foutbl+3,y
 12918  651f 8567                                sta faclo
 12919  6521 a566                                lda facmo
 12920  6523 793e5f                              adc foutbl+2,y
 12921  6526 8566                                sta facmo
 12922  6528 a565                                lda facmoh
 12923  652a 793d5f                              adc foutbl+1,y
 12924  652d 8565                                sta facmoh
 12925  652f a564                                lda facho
 12926  6531 793c5f                              adc foutbl,y
 12927  6534 8564                                sta facho
 12928  6536 e8                                  inx                                      ; it was done yet another time
 12929  6537 b004                                bcs l182_1
 12930  6539 10de                                bpl fout2
 12931  653b 3002                                bmi l182_2
 12932                          
 12933  653d 30da               l182_1           bmi fout2
 12934  653f 8a                 l182_2           txa
 12935  6540 9004                                bcc l182_3                               ; can use (a) as is
 12936  6542 49ff                                eor #$ff                                 ; find 11.(a)
 12937  6544 690a                                adc #10                                  ; c is still on to complete negation, and will always be on after
 12938                          
 12939  6546 692f               l182_3           adc #'0'-1                               ; get a character to print
 12940  6548 c8                                  iny
 12941  6549 c8                                  iny
 12942  654a c8                                  iny
 12943  654b c8                                  iny
 12944  654c 8449                                sty fdecpt
 12945  654e a472                                ldy fbufpt
 12946  6550 c8                                  iny                                      ; point to place to store output
 12947  6551 aa                                  tax
 12948  6552 297f                                and #$7f                                 ; get rid of msb
 12949  6554 99ff00                              sta fbuffr-1,y
 12950  6557 c65f                                dec deccnt
 12951  6559 d006                                bne l182_4                               ; not time for dp yet
 12952  655b a92e                                lda #'.'
 12953  655d c8                                  iny
 12954  655e 99ff00                              sta fbuffr-1,y                           ; store dp
 12955                          
 12956  6561 8472               l182_4           sty fbufpt                               ; store pointer for later
 12957  6563 a449                                ldy fdecpt
 12958  6565 8a                                  txa                                      ; complement accb
 12959  6566 49ff                                eor #$ff                                 ; complement acca
 12960  6568 2980                                and #$80                                 ; save only msb
 12961  656a aa                                  tax
 12962  656b c024                                cpy #fdcend-foutbl
 12963                          ; beq l182_5  ;for time converter ????   removed [901014]
 12964                          ; cpy #timend-foutbl
 12965  656d d0aa                                bne fout2                                ; continue with output
 12966                          
 12967  656f a472               l182_5           ldy fbufpt                               ; get back output pointer
 12968  6571 b9ff00             l182_6           lda fbuffr-1,y                           ; remove trailing blanks
 12969  6574 88                                  dey
 12970  6575 c930                                cmp #'0'
 12971  6577 f0f8                                beq l182_6
 12972  6579 c92e                                cmp #'.'
 12973  657b f001                                beq l182_7                               ; ran into dp,  stop
 12974  657d c8                                  iny                                      ; something else, save it
 12975                          
 12976  657e a92b               l182_7           lda #'+'
 12977  6580 a660                                ldx tenexp
 12978  6582 f02e                                beq fout17                               ; no exponent to output
 12979  6584 1008                                bpl l182_8
 12980  6586 a900                                lda #0
 12981  6588 38                                  sec
 12982  6589 e560                                sbc tenexp
 12983  658b aa                                  tax
 12984  658c a92d                                lda #'-'                                 ; exponent is negative
 12985                          
 12986  658e 990101             l182_8           sta fbuffr+1,y                           ; store sign of exponent
 12987  6591 a945                                lda #'E'
 12988  6593 990001                              sta fbuffr,y                             ; store the 'E' character
 12989  6596 8a                                  txa
 12990                          
 12991  6597 a22f                                ldx #'0'-1
 12992  6599 38                                  sec
 12993  659a e8                 l182_9           inx                                      ; move closer to output value
 12994  659b e90a                                sbc #10                                  ; subtract 10
 12995  659d b0fb                                bcs l182_9                               ; not negative yet
 12996                          
 12997  659f 693a                                adc #'9'+1                               ; get second output character
 12998  65a1 990301                              sta fbuffr+3,y                           ; store high digit
 12999  65a4 8a                                  txa
 13000  65a5 990201                              sta fbuffr+2,y                           ; store low digit
 13001  65a8 a900                                lda #0                                   ; put in terminator
 13002  65aa 990401                              sta fbuffr+4,y
 13003  65ad 8008                                bra fout20                               ; return
 13004                          
 13005                          
 13006  65af 99ff00             fout19           sta fbuffr-1,y                           ; store the character
 13007  65b2 a900               fout17           lda #0                                   ; store the terminator
 13008  65b4 990001                              sta fbuffr,y
 13009                          
 13010  65b7 a900               fout20           lda #<fbuffr
 13011  65b9 a001                                ldy #>fbuffr
 13012  65bb 60                                  rts                                      ; all done
 13013                          
 13014                          ; .page
 13015                          ; Exponentiation and Square Root Functions.
 13016                          ;
 13017                          ; square root function - sqr(a)
 13018                          ; use sqr(x) = x^.5
 13019                          
 13020  65bc 20a362             sqr              jsr movaf                                ; move FAC into ARG
 13021  65bf a914                                lda #<fhalf
 13022  65c1 a05f                                ldy #>fhalf
 13023                          
 13024  65c3 200e62             fpwr             jsr movfm                                ; put memory into FAC    ARG^MEM
 13025                          
 13026                          
 13027                          ; Last thing fetched is facexp into accx.
 13028                          ;
 13029                          ; Exponentiation --- x^y.
 13030                          ; n.b. 0^0=1
 13031                          ; First check if y=0, and if so the result is one.
 13032                          ; Next  check if x=0, and if so the result is zero.
 13033                          ; Then  check if x>0:
 13034                          ; if not check that y is an integer.
 13035                          ; if so negate x, so that lg doesn't give fcerr.
 13036                          ; If x is negative and y is odd, negate the result returned by exp.
 13037                          ; To compute the result use x^y = EXP((y*LOG(x))
 13038                          
 13039                          
 13040  65c6 f03f               fpwrt            beq exp                                  ; if FAC=0, just exponentiate that  ARG^FAC
 13041  65c8 a56a                                lda argexp                               ; is x=0?
 13042  65ca f37ff8                              +lbeq zerof1                             ; zero FAC
 13043                          
 13044  65cd a250                                ldx #<tempf3                             ; save it for later in a temp
 13045  65cf a000                                ldy #>tempf3
 13046  65d1 203a62                              jsr movmf                                ; FAC->MEM
 13047                          
 13048  65d4 a56f                                lda argsgn                               ; note y=0 already. that's good, in case no one calls int.
 13049  65d6 100f                                bpl l183_1                               ; no problems if x>0
 13050  65d8 206363                              jsr int                                  ; integerize the FAC
 13051  65db a950                                lda #<tempf3                             ; get addr of comperand
 13052  65dd a000                                ldy #>tempf3
 13053  65df 20f162                              jsr fcomp                                ; equal?
 13054  65e2 d003                                bne l183_1                               ; leave x neg. log will blow him out
 13055                          ;a=-1 and y is irrelavant
 13056  65e4 98                                  tya                                      ; negative x. make positive
 13057  65e5 a40a                                ldy integr                               ; get evenness
 13058                          
 13059  65e7 209562             l183_1           jsr movfa1                               ; alternate entry point.    ARG->FAC
 13060  65ea 5a                                  phy                                      ; save evenness for later
 13061  65eb 200e60                              jsr log                                  ; find log
 13062  65ee a950                                lda #<tempf3                             ; multiply FAC times LOG(x)
 13063  65f0 a000                                ldy #>tempf3
 13064  65f2 206d60                              jsr fmult
 13065  65f5 200766                              jsr exp                                  ; exponentiate the FAC
 13066  65f8 68                                  pla
 13067  65f9 4a                                  lsr                                      ; is it even?
 13068  65fa 900a                                bcc negrts                               ; yes. or x>0
 13069                          ;negate the number in FAC
 13070                          
 13071                          
 13072                          negop                                                     ; /// entry point
 13073  65fc a563                                lda facexp
 13074  65fe f006                                beq negrts
 13075  6600 a568                                lda facsgn
 13076  6602 49ff                                eor #$ff
 13077  6604 8568                                sta facsgn
 13078  6606 60                 negrts           rts
 13079                          
 13080                          ;.end
 13081                          ; .page
 13082                          ; .subttl Floating Point Math Package (CODE24)
 13083                          
 13084                          ; Exponentation Function
 13085                          ;
 13086                          ; First save the original argument and multiply the FAC by LOG2(e).  The
 13087                          ; result is used to determine if overflow will occur since
 13088                          ;
 13089                          ;  EXP(x) = 2^(x*LOG2(e))
 13090                          ;
 13091                          ; where
 13092                          ;  LOG2(e) = LOG(e), base 2
 13093                          ;
 13094                          ; Then save the integer part of this to scale the answer at the end, since
 13095                          ; 2^y=2^INT(y)*2^(y-INT(y)) and 2^INT(y) are easy to compute.  Now compute
 13096                          ;
 13097                          ;  2^(x*LOG2(e)-INT(x*LOG2(e))
 13098                          ; by
 13099                          ;  p(LOG(2)*(INT(x*LOG2(e))+1)-x
 13100                          ;
 13101                          ; where p is an approximation polynomial. The result is then scaled by the
 13102                          ; power of two previously saved.  Re: Taylor expansion.
 13103                          
 13104                          
 13105  6607 a99e               exp              lda #<logeb2                             ; multiply by LOG(e) base 2
 13106  6609 a05f                                ldy #>logeb2
 13107  660b 204860                              jsr rommlt                               ; LOGEB2->ARG, FAC=FAC*ARG
 13108  660e a571                                lda facov
 13109  6610 6950                                adc #$50                                 ; ????
 13110  6612 9003                                bcc l184_1
 13111  6614 20ba62                              jsr incrnd
 13112                          
 13113  6617 8558               l184_1           sta oldov
 13114  6619 20a662                              jsr movef                                ; to save in ARG without round.  ARG=FAC, facov=0)
 13115  661c a563                                lda facexp
 13116  661e c988                                cmp #$88                                 ; if ABS(FAC) >= 128, too big
 13117  6620 9003                                bcc l184_3
 13118                          
 13119  6622 204361             l184_2           jsr mldvex                               ; overflow or overflow
 13120  6625 206363             l184_3           jsr int                                  ; FAC=INT(FAC), uses facov
 13121  6628 a50a                                lda integr                               ; get low part
 13122  662a 18                                  clc
 13123  662b 6981                                adc #$81
 13124  662d f0f3                                beq l184_2                               ; overflow or overflow!!
 13125                          
 13126  662f 38                                  sec
 13127  6630 e901                                sbc #1                                   ; subtract it
 13128  6632 48                                  pha                                      ; save a while
 13129                          
 13130  6633 a205                                ldx #5                                   ; swap FAC and ARG
 13131  6635 b56a               l184_4           lda argexp,x
 13132  6637 b463                                ldy facexp,x
 13133  6639 9563                                sta facexp,x
 13134  663b 946a                                sty argexp,x
 13135  663d ca                                  dex
 13136  663e 10f5                                bpl l184_4
 13137                          
 13138  6640 a558                                lda oldov
 13139  6642 8571                                sta facov
 13140  6644 20a85d                              jsr fsubt                                ; FAC=ARG-FAC
 13141  6647 20fc65                              jsr negop                                ; negate FAC
 13142  664a a975                                lda #<expcon
 13143  664c a05f                                ldy #>expcon
 13144  664e 207066                              jsr poly
 13145  6651 a900                                lda #0
 13146  6653 8570                                sta arisgn                               ; multiply by positive 1.0
 13147                          
 13148  6655 68                                  pla                                      ; recall scale factor
 13149  6656 202961                              jsr mldexp                               ; modify facexp and check for overflow
 13150  6659 60                                  rts                                      ; (has to do jsr due to pla's in muldiv)
 13151                          
 13152                          ; .page
 13153                          ; Polynomial Evaluator and the Random Number Generator.
 13154                          ;
 13155                          ; Evaluate  p(x^2)*x
 13156                          ; The pointer to degree is in (a,y) and the constants follow the degree.
 13157                          ; For x=FAC, compute  c0*x + c1*x^3 + c2*x^5 + c3*x^7 +...+ c(n)*x^(2*n+1)
 13158                          
 13159                          
 13160  665a 8572               polyx            sta polypt                               ; retain polynomial pointer for later
 13161  665c 8473                                sty polypt+1
 13162  665e 203662                              jsr mov1f                                ; save FAC in factmp (y=0 upon return)
 13163  6661 a959                                lda #tempf1
 13164  6663 206d60                              jsr fmult                                ; compute x^2.
 13165  6666 207466                              jsr poly1                                ; compute p(x^2).
 13166  6669 a959                                lda #<tempf1
 13167  666b a000                                ldy #>tempf1
 13168  666d 83fef9                              +lbra fmult                              ; multiply by FAC again
 13169                          
 13170                          
 13171                          ; Polynomial Evaluator
 13172                          ;
 13173                          ; Pointer to degree is in (a,y).
 13174                          ; Compute:  c0+c1*x+c2*x^2+c3*x^3+c4*x^4...+c(n-1)*x^(n-1)+c(n)*x^n
 13175                          ;  which is roughly (LOG(2)^n)/LOG(EXP(1))/n!
 13176                          
 13177                          
 13178  6670 8572               poly             sta polypt
 13179  6672 8473                                sty polypt+1
 13180                          
 13181  6674 203362             poly1            jsr mov2f                                ; save FAC (rounds, .y=0)
 13182  6677 b172                                lda (polypt),y
 13183  6679 8569                                sta degree
 13184  667b e372                                inw polypt
 13185  667d a572                                lda polypt
 13186  667f a473                                ldy polypt+1
 13187                          
 13188  6681 204860             l185_1           jsr rommlt
 13189  6684 a572                                lda polypt                               ; get current pointer
 13190  6686 a473                                ldy polypt+1
 13191  6688 18                                  clc
 13192  6689 6905                                adc #5
 13193  668b 9001                                bcc l185_2
 13194  668d c8                                  iny
 13195  668e 8572               l185_2           sta polypt
 13196  6690 8473                                sty polypt+1
 13197  6692 205160                              jsr romadd                               ; add in constant
 13198  6695 a95e                                lda #<tempf2                             ; multiply the original FAC
 13199  6697 a000                                ldy #>tempf2
 13200  6699 c669                                dec degree                               ; done?
 13201  669b d0e4                                bne l185_1
 13202  669d 60                                  rts                                      ; yes
 13203                          
 13204                          ;.end
 13205                          ; .page
 13206                          ; .subttl Floating Point Math Package (TRIG)
 13207                          
 13208                          ; Sine, Cosine, and Tangent Functions.
 13209                          
 13210                          
 13211                          
 13212                          ; Cosine function cos(x)=sin(x+pi/2)
 13213                          
 13214                          
 13215  669e a923               cos              lda #<pi2                                ; pointer to pi/2
 13216  66a0 a05f                                ldy #>pi2
 13217  66a2 205160                              jsr romadd                               ; add it in.  fall into sine
 13218                          
 13219                          
 13220                          
 13221                          ; Sine function
 13222                          ;
 13223                          ; Use identities to get FAC in quadrants I or IV.  The FAC is divided by 2*pi
 13224                          ; and the integer part is ignored because sin(x+2*pi)=sin(x).  Then the
 13225                          ; argument can be compared with pi/2 by comparing the result of the division
 13226                          ; with pi/2(2*pi)=1/4.  Identities are then used to get the result in quadrants
 13227                          ; I or IV.  An approximation polynomial is then used to compute sin(x).
 13228                          
 13229                          
 13230  66a5 20a362             sin              jsr movaf
 13231  66a8 a928                                lda #<twopi                              ; get pointer to divisor
 13232  66aa a05f                                ldy #>twopi
 13233  66ac a66f                                ldx argsgn                               ; get sign of result
 13234  66ae 207161                              jsr fdivf
 13235  66b1 20a362                              jsr movaf                                ; get result into ARG
 13236  66b4 206363                              jsr int                                  ; integerize FAC
 13237  66b7 a900                                lda #0
 13238  66b9 8570                                sta arisgn                               ; always have the same sign
 13239  66bb 20a85d                              jsr fsubt                                ; keep only the fractional part
 13240  66be a90a                                lda #<fr4                                ; get pointer to 1/4
 13241  66c0 a05f                                ldy #>fr4
 13242  66c2 205760                              jsr romsub
 13243  66c5 a568                                lda facsgn                               ; save sign for later
 13244  66c7 48                                  pha
 13245  66c8 100d                                bpl sin1                                 ; first quadrant
 13246  66ca 204d60                              jsr faddh                                ; add 1/2 to FAC
 13247  66cd a568                                lda facsgn                               ; sign is negative?
 13248  66cf 3009                                bmi sin2
 13249  66d1 a514                                lda tansgn                               ; quads II and III come here
 13250  66d3 49ff                                eor #$ff
 13251  66d5 8514                                sta tansgn
 13252                          
 13253  66d7 20fc65             sin1             jsr negop                                ; if positive, negate it
 13254                          
 13255  66da a90a               sin2             lda #<fr4                                ; pointer to 1/4
 13256  66dc a05f                                ldy #>fr4
 13257  66de 205160                              jsr romadd                               ; add it in
 13258  66e1 68                                  pla                                      ; get original quadrant
 13259  66e2 1003                                bpl l186_1
 13260  66e4 20fc65                              jsr negop                                ; if negative, negate result
 13261                          
 13262  66e7 a9b2               l186_1           lda #<sincon
 13263  66e9 a05f                                ldy #>sincon
 13264  66eb 836dff                              +lbra polyx                              ; do approximation polyomial
 13265                          
 13266                          
 13267                          
 13268                          ; Tangent function
 13269                          
 13270                          
 13271  66ee 203662             tan              jsr mov1f                                ; move FAC into temporary
 13272  66f1 a900                                lda #0
 13273  66f3 8514                                sta tansgn                               ; remember whether to negate
 13274  66f5 20a566                              jsr sin                                  ; compute the sin
 13275  66f8 a250                                ldx #<tempf3
 13276  66fa a000                                ldy #>tempf3
 13277  66fc 203a62                              jsr movmf                                ; put sign into other temp
 13278  66ff a959                                lda #<tempf1
 13279  6701 a000                                ldy #>tempf1
 13280  6703 200e62                              jsr movfm                                ; put this memory location into FAC
 13281  6706 a900                                lda #0
 13282  6708 8568                                sta facsgn                               ; start off positive
 13283  670a a514                                lda tansgn
 13284  670c 201c67                              jsr l187_1                               ; compute cosine
 13285  670f a950                                lda #<tempf3
 13286  6711 a000                                ldy #>tempf3                             ; address of sine value
 13287                          ; bra fdiv ;divide sine by cosine and return
 13288  6713 20f760                              jsr conupk                               ; unpack constant    [910226] FAB
 13289  6716 f32fc7                              +lbeq overr                              ; overflow error     "
 13290  6719 836afa                              +lbra fdivt                              ; "
 13291                          
 13292  671c 48                 l187_1           pha                                      ; cosc.
 13293  671d 80b8                                bra sin1
 13294                          
 13295                          
 13296                          ; Arctangent function
 13297                          ;
 13298                          ; Use identities to get arg between 0 and 1 and then use an approximation
 13299                          ; polynomial to compute arctan(x).
 13300                          
 13301                          
 13302  671f a568               atn              lda facsgn                               ; what is sign?
 13303  6721 48                                  pha                                      ; save for later
 13304  6722 1003                                bpl l188_1
 13305  6724 20fc65                              jsr negop                                ; if negative, negate FAC
 13306                          ;use arctan(x)=-arctan(-x)
 13307  6727 a563               l188_1           lda facexp
 13308  6729 48                                  pha                                      ; save this too for later
 13309  672a c981                                cmp #$81                                 ; see if FAC >= 1.0
 13310  672c 9007                                bcc l188_2                               ; it is less than 1
 13311  672e a999                                lda #<fone                               ; get pntr to 1.0
 13312  6730 a05f                                ldy #>fone
 13313  6732 205d60                              jsr romdiv                               ; compute reciprocal
 13314                          ;use aectan(x)=pi/2-arctan(1/x)
 13315  6735 a9d1               l188_2           lda #<atncon                             ; pointer to arctan constants
 13316  6737 a05f                                ldy #>atncon
 13317  6739 205a66                              jsr polyx
 13318  673c 68                                  pla
 13319  673d c981                                cmp #$81                                 ; was original argument < 1?
 13320  673f 9007                                bcc l188_3                               ; yes
 13321  6741 a923                                lda #<pi2
 13322  6743 a05f                                ldy #>pi2
 13323  6745 205760                              jsr romsub                               ; subtract arctan from pi/2
 13324                          
 13325  6748 68                 l188_3           pla                                      ; was original aurgument positive?
 13326  6749 1003                                bpl l188_4                               ; yes
 13327  674b 83affe                              +lbra negop                              ; if negative, negate result
 13328                          
 13329  674e 60                 l188_4           rts                                      ; all done
 13330                          
 13331                          ;.end
 13332                          ; .page
 13333                          ; .subttl  BOOT
 13334                          
 13335                          ;****************************************************************************
 13336                          ; BOOT  Boot has three modes of operation...
 13337                          ;
 13338                          ;   1. *B*LOAD a given binary file and SYS to its load address.
 13339                          ;   2. *D*LOAD a BASIC file named AUTOBOOT.C65* and RUN it.
 13340                          ;   3. BOOT SYS loads the home sector to $0400 and JMPs to it.
 13341                          ;
 13342                          ; For modes 1 & 2, syntax is the same as BLOAD.  Differentiate
 13343                          ; between the two modes via the presence of a filename.  All other
 13344                          ; parameters, such as drive and device numbers, are utilized in the
 13345                          ; normal manner.  For mode 3 there are no options.  It's intended
 13346                          ; to boot a new OS.  BASIC is turned off if it's successful.  If it
 13347                          ; fails, the run time stack & sprites might be corrupted.
 13348                          ;****************************************************************************
 13349                          
 13350  674f c99e               boot             cmp #sys_token                           ; BOOTSYS?      [910111]
 13351  6751 d00d                                bne l189_1                               ; no
 13352  6753 208322                              jsr chrget                               ; yes- eat token
 13353  6756 2059ff                              jsr _bootsys                             ; attempt to boot a new OS
 13354  6759 902f                                bcc l189_4                               ; returned to us after successful install
 13355  675b a224                                ldx #errbdk                              ; bootsys failed, report 'bad disk'????
 13356  675d 83f0c6                              +lbra error
 13357                          
 13358  6760 4f7e03             l189_1           bbr4 runmod,l189_2                       ; Error if in Edit mode     [910620]
 13359  6763 83f4d5                              +lbra edit_err
 13360                          
 13361  6766 a900               l189_2           lda #0                                   ; BOOT "filename"     [910417]
 13362  6768 850c                                sta verck                                ; want 'load', not 'verify'
 13363  676a a9e6                                lda #$e6                                 ; set up parameters for DOS parser like BLOAD
 13364  676c a2fc                                ldx #$fc
 13365  676e 202274                              jsr dosprx                               ; parse the command
 13366  6771 0f7f17                              bbr0 parsts,l189_5                       ; was there a filename?  branch if not
 13367  6774 20ed71                              jsr bload_boot                           ; yes- bload it
 13368  6777 b3bd00                              +lbcs erexit                             ; load error
 13369                          
 13370                          ; ldx current_bank ;assume no B(ank) arg was given    [910114]
 13371                          ; bbr0 parstx,l189_3  ; correct, use current setup
 13372  677a ae8c11                              ldx dosbnk                               ; else use given bank number
 13373  677d 8602               l189_3           stx _bank
 13374  677f a5ac                                lda _starting_addr                       ; set up address BLOAD loaded to
 13375  6781 8504                                sta _pclo
 13376  6783 a5ad                                lda _starting_addr+1
 13377  6785 8503                                sta _pchi
 13378  6787 206eff                              jsr _jsr_far                             ; call it
 13379  678a 60                 l189_4           rts
 13380                          
 13381  678b a0ff               l189_5           ldy #$ff
 13382  678d c8                 l189_6           iny                                      ; Copy default filename from ROM into buffer
 13383  678e b92868                              lda autoboot_filename,y
 13384  6791 999111                              sta savram,y
 13385  6794 d0f7                                bne l189_6                               ; null terminated
 13386                          
 13387  6796 8c8511                              sty dosf1l                               ; length not counting terminator
 13388  6799 e77e                                smb6 runmod                              ; set flag for load not to go to ready
 13389  679b 207b71                              jsr dload_boot                           ; Load it
 13390  679e b39600                              +lbcs erexit                             ; error if problems
 13391  67a1 8320d6                              +lbra run_a_program                      ; else go run it
 13392                          
 13393                          ; .page
 13394                          ; AUTOBOOT_CSG Runs a system diagnostic if PB0 is low after initialization.
 13395                          ;  Diagnostic is copied to RAM-0 from ROM-2 and jumped to.
 13396                          
 13397                          autobootCSG                                               ; Run ROMed diagnostic if PB0 low   [911105]
 13398  67a4 ad01dd                              lda $dd01
 13399  67a7 4a                                  lsr
 13400  67a8 b032                                bcs autoboot                             ; no, try to boot from disk
 13401                          
 13402  67aa 78                                  sei                                      ; prevent IRQ from wacking code DL'd to $1xxx  [911106]
 13403  67ab a20b                                ldx #12-1
 13404  67ad bdd067             l190_1           lda l190_2,x                             ; prep DMA list
 13405  67b0 9d4401                              sta dma1_cmd,x
 13406  67b3 ca                                  dex
 13407  67b4 10f7                                bpl l190_1
 13408                          
 13409  67b6 a900                                lda #0
 13410  67b8 a201                                ldx #>dma1_cmd                           ; copy program from ROM to RAM
 13411  67ba a044                                ldy #<dma1_cmd
 13412  67bc 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
 13413  67bf 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
 13414  67c2 8c00d7                              sty dma_ctlr                             ; dma_list lo & trigger
 13415                          
 13416                          ; jmp run_a_program ;if 'program' was BASIC
 13417                          ; lda #0   ;else set up arg's for call to 'long jmp'  [911105]
 13418  67c5 8502                                sta _bank
 13419  67c7 8504                                sta _pclo
 13420  67c9 a910                                lda #$10
 13421  67cb 8503                                sta _pchi
 13422  67cd 4c71ff                              jmp _jmp_far                             ; jump to code, no return.  NOTE: this *MAPs* RAM-0 into context!
 13423                          
 13424                          ; move from $024001 to $002001, $3FFF bytes  BASIC program
 13425                          ;l190_2 .byte $00,$ff,$3f,$01,$40,$02,$01,$20,$00,$00,$00,$00
 13426                          
 13427                          ; move from $024000 to $1000, $4000 bytes   Diagnostic  [911105]
 13428  67d0 0000400040020010...l190_2           !text $00,$00,$40,$00,$40,$02,$00,$10,$00,0,0,0
 13429                          
 13430                          ; .page
 13431                          ; AUTOBOOT Attempts to RUN a disk program after cold startup.  The
 13432                          ;  program must be a BASIC program called "AUTOBOOT.C65*"
 13433                          
 13434                          autoboot
 13435  67dc a900                                lda #0                                   ; Select internal drive
 13436  67de 8d80d0                              sta fdc
 13437  67e1 2c82d0             l191_1           bit fdc+2                                ; busywait
 13438  67e4 30fb                                bmi l191_1
 13439  67e6 ad83d0                              lda fdc+3                                ; See if a diskette is present
 13440  67e9 2908                                and #$08
 13441  67eb f03a                                beq l191_3                               ; exit with no action taken if not
 13442                          
 13443  67ed a9e6                                lda #$e6                                 ; set up parameters for DOS parser like BLOAD
 13444  67ef a2fc                                ldx #$fc
 13445  67f1 202274                              jsr dosprx                               ; let the parser init DOS stuff
 13446                          
 13447  67f4 a0ff                                ldy #$ff
 13448  67f6 c8                 l191_2           iny                                      ; Copy filename from ROM into buffer
 13449  67f7 b92868                              lda autoboot_filename,y
 13450  67fa 999111                              sta savram,y
 13451  67fd d0f7                                bne l191_2                               ; null terminated
 13452  67ff 8c8511                              sty dosf1l                               ; length not counting terminator
 13453                          
 13454  6802 a941                                lda #%01000001                           ; set flag for load indicating autoboot
 13455  6804 857e                                sta runmod                               ; set flag for load not to go to ready
 13456  6806 207b71                              jsr dload_boot                           ; skip parser & load it
 13457                          
 13458  6809 a900                                lda #0                                   ; clear autoboot flags
 13459  680b 857e                                sta runmod
 13460  680d da                                  phx                                      ; save end address
 13461  680e 5a                                  phy
 13462  680f 20b7ff                              jsr _readst                              ; get status report, but check it later
 13463  6812 48                                  pha
 13464  6813 209a78                              jsr Suck_DS                              ; clear any DOS errors (to kill error LED)
 13465  6816 68                                  pla                                      ; now check I/O status
 13466  6817 7a                                  ply
 13467  6818 fa                                  plx
 13468  6819 29bf                                and #$bf                                 ; EOI is okay
 13469  681b d00a                                bne l191_3                               ; outside problems
 13470  681d b008                                bcs l191_3                               ; inside problems
 13471                          
 13472  681f 8682                                stx text_top                             ; success- set end address & run it
 13473  6821 8483                                sty text_top+1
 13474  6823 58                                  cli
 13475  6824 839dd5                              +lbra run_a_program
 13476                          
 13477  6827 60                 l191_3           rts                                      ; failure- go_ready
 13478                          
 13479                          
 13480                          autoboot_filename
 13481  6828 4155544f424f4f54...                 !text "AUTOBOOT.C65*",0
 13482                          
 13483                          ; .page
 13484                          ; .subttl  SAVE  LOAD  VERIFY  OPEN  CLOSE
 13485                          
 13486  6836 aa                 erexit           tax                                      ; set termination flags
 13487  6837 d316c6                              +lbne error                              ; normal error
 13488  683a 8395c4                              +lbra break_exit                         ; user break
 13489                          
 13490                          
 13491                          
 13492  683d 20d2ff             outch            jsr _bsout
 13493  6840 b0f4                                bcs erexit
 13494  6842 60                                  rts
 13495                          
 13496                          
 13497                          
 13498  6843 20cfff             inchr            jsr _basin
 13499  6846 b0ee                                bcs erexit
 13500  6848 60                                  rts
 13501                          
 13502                          
 13503                          coout
 13504                          ; jsr put_io_in_map
 13505  6849 20c9ff                              jsr _chkout
 13506  684c 20c169                              jsr dschk                                ; see if device # >=4, and clear DS if so
 13507  684f b0e5                                bcs erexit                               ; take error exit of there was one
 13508  6851 60                                  rts
 13509                          
 13510                          
 13511                          coin
 13512                          ; jsr put_io_in_map
 13513  6852 20c6ff                              jsr _chkin
 13514  6855 20c169                              jsr dschk                                ; see if device # >=4, and clear DS if so
 13515  6858 b0dc                                bcs erexit
 13516  685a 60                                  rts
 13517                          
 13518                          cgetl
 13519                          ; jsr put_io_in_map
 13520  685b 20e4ff                              jsr _getin
 13521  685e b371c4                              +lbcs break_exit                         ; 'stop' key was pressed
 13522  6861 60                                  rts
 13523                          
 13524                          ; .page
 13525  6862 202569             save             jsr plsv                                 ; parse parameters, dschk
 13526                          
 13527                          
 13528                          savenp                                                    ; Save Program (from DSave)
 13529  6865 a682                                ldx text_top                             ; ending address
 13530  6867 a483                                ldy text_top+1
 13531  6869 a92d                                lda #<txttab                             ; pointer to start address
 13532                          
 13533                          
 13534                          savenb                                                    ; Save Binary (from BSave & KEY SAVE)
 13535                          ; jsr put_io_in_map
 13536  686b 20d8ff                              jsr _savesp                              ; save it
 13537                          
 13538                          ; Any changes to the following code must be duplicated at:
 13539                          ;  bload
 13540                          ;  load (load_file)
 13541                          
 13542                          exit_disk_op
 13543                          exit_disk_operation
 13544  686e 08                                  php                                      ; preserve kernel error status (.c)
 13545  686f 48                                  pha                                      ; preserve kernel error # (.a)
 13546  6870 206e72                              jsr print_dos_error                      ; print DOS error msg if any only in direct mode
 13547  6873 68                                  pla
 13548  6874 28                                  plp
 13549  6875 900f                                bcc l192_3                               ; branch if no error (rts)
 13550  6877 ff7e0a                              bbs7 runmod,l192_2                       ; branch if run mode (erexit)
 13551  687a c904                                cmp #errfnf                              ; is it 'file not found' catch-all?
 13552  687c d005                                bne l192_1                               ; no  (erexit)
 13553  687e 8dc702                              sta errnum                               ; yes- save error # for 'er'
 13554  6881 0980                                ora #$80                                 ; but no errdis
 13555  6883 38                 l192_1           sec
 13556  6884 b0b0               l192_2           bcs erexit                               ; exit if kernel problem (rts)
 13557  6886 60                 l192_3           rts
 13558                          
 13559                          ; .page
 13560  6887 a901               verify           lda #1                                   ; verify flag
 13561  6889 2c                                  !text $2c                                ; skip two bytes
 13562                          
 13563  688a a900               load             lda #0                                   ; load flag
 13564  688c 850c                                sta verck
 13565  688e 4f7e03             l193_1           bbr4 runmod,l193_2                       ; Error if in Edit mode     [910620]
 13566  6891 83c6d4                              +lbra edit_err
 13567  6894 202569             l193_2           jsr plsv                                 ; parse parameters, dschk
 13568                          
 13569                          cld10                                                     ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< entry from dload
 13570                          ; jsr put_io_in_map
 13571  6897 a50c                                lda verck
 13572  6899 a62d                                ldx txttab                               ; .x and .y have alt...
 13573  689b a42e                                ldy txttab+1                             ; ...load address
 13574                          
 13575                          ; Any changes to the following code must be duplicated at:
 13576                          ;  bload
 13577                          ;  save (exit_disk_op)
 13578                          
 13579                          load_file
 13580  689d 20d5ff                              jsr _loadsp                              ; load it
 13581  68a0 8f7e36                              bbs0 runmod,cld20                        ; skip error checks if autoboot (rts)
 13582  68a3 da                                  phx                                      ; save end address
 13583  68a4 5a                                  phy
 13584  68a5 08                                  php                                      ; save kernel load status (.c)
 13585  68a6 48                                  pha                                      ; save kernel error # (.a)
 13586  68a7 20b7ff                              jsr _readst                              ; save I/O status byte
 13587  68aa 857f                                sta parsts
 13588  68ac 206e72                              jsr print_dos_error                      ; report error msg if any only in direct mode
 13589  68af 68                                  pla                                      ; restore error stuff
 13590  68b0 28                                  plp
 13591  68b1 9010                                bcc l194_3                               ; branch if no error (rts)
 13592  68b3 ff7e0a                              bbs7 runmod,l194_2                       ; branch if run mode (erexit)
 13593  68b6 c904                                cmp #errfnf                              ; is it 'file not found' catch-all?
 13594  68b8 d005                                bne l194_1                               ; no  (erexit)
 13595  68ba 8dc702                              sta errnum                               ; yes- save error # for 'er'
 13596  68bd 0980                                ora #$80                                 ; but no errdis
 13597  68bf 38                 l194_1           sec
 13598  68c0 b374ff             l194_2           +lbcs erexit                             ; exit if kernel problem
 13599  68c3 7a                 l194_3           ply                                      ; restore end address
 13600  68c4 fa                                  plx
 13601  68c5 a50c                                lda verck
 13602  68c7 f011                                beq cld50                                ; was load
 13603                          
 13604                          ; Finish verify
 13605                          
 13606                          verify_check
 13607  68c9 a21c                                ldx #ervfy                               ; assume error
 13608                          ; jsr _readst  ;read status
 13609  68cb cf7f14                              bbs4 parsts,cld55                        ; branch if 'verify' error
 13610  68ce ff7e08                              bbs7 runmod,cld20                        ; branch if not direct mode
 13611                          verify_ok
 13612  68d1 207dff                              jsr _primm
 13613  68d4 0d4f4b0d00                          !text cr,"OK", cr,0
 13614  68d9 60                 cld20            rts
 13615                          
 13616                          
 13617                          
 13618                          ; Finish load
 13619                          
 13620                          cld50
 13621                          ; jsr _readst  ;check I/O status
 13622  68da a57f                                lda parsts
 13623  68dc 29bf                                and #%10111111                           ; EOI is okay, so mask it
 13624  68de f005                                beq cld60                                ; good- finish load operation
 13625                          
 13626                          load_error
 13627  68e0 a21d                                ldx #erload
 13628  68e2 836bc5             cld55            +lbra error
 13629                          
 13630                          
 13631  68e5 8682               cld60            stx text_top
 13632  68e7 8483                                sty text_top+1                           ; end load address
 13633                          
 13634  68e9 ff7e0c                              bbs7 runmod,cld70                        ; branch if not direct mode
 13635  68ec ef7eea                              bbs6 runmod,cld20                        ; special "RUN file_name" flag...get out here (rts)
 13636                          
 13637  68ef 20b930                              jsr link_program                         ; relink
 13638  68f2 20a134                              jsr runc                                 ; clear vars
 13639  68f5 83f6c5                              +lbra ready_2                            ; print 'ready' & return to main
 13640                          
 13641                          
 13642                          ; Program load
 13643                          
 13644  68f8 201f35             cld70            jsr reset_txtptr
 13645  68fb 20b930                              jsr link_program
 13646  68fe 8306cc                              +lbra fload
 13647                          
 13648                          ; .page
 13649  6901 207469             open             jsr paoc                                 ; parse statement
 13650  6904 20c0ff                              jsr _open                                ; open it
 13651  6907 8009                                bra close_out_1
 13652                          
 13653                          
 13654                          
 13655  6909 207469             close            jsr paoc                                 ; parse statement
 13656                          ; jsr put_io_in_map
 13657  690c a54b                                lda andmsk                               ; get la
 13658                          
 13659                          
 13660                          close_out                                                 ; enter with .a=LA   [900725]
 13661  690e 18                                  clc                                      ; flag a real close
 13662  690f 20c3ff                              jsr _close                               ; close it
 13663                          
 13664                          close_out_1
 13665  6912 08                                  php
 13666  6913 48                                  pha
 13667  6914 a5ba                                lda _fa                                  ; special error checking if disk op
 13668  6916 c908                                cmp #8
 13669  6918 9005                                bcc l195_1
 13670  691a 68                                  pla
 13671  691b 28                                  plp
 13672  691c 8350ff                              +lbra exit_disk_operation                ; disk
 13673                          
 13674  691f 68                 l195_1           pla                                      ; something else
 13675  6920 28                                  plp
 13676  6921 b313ff                              +lbcs erexit
 13677  6924 60                                  rts
 13678                          
 13679                          ; .page
 13680                          ; Parse LOAD, SAVE, & VERIFY commands
 13681                          
 13682                          plsv
 13683  6925 a900                                lda #0                                   ; set default filename (none)
 13684  6927 20bdff                              jsr _setnam
 13685  692a ae0611                              ldx _default_drive                       ; set default device # (dosffn)
 13686  692d a000                                ldy #0                                   ; command 0
 13687  692f 20baff                              jsr _setlfs
 13688  6932 a584                                lda text_bank                            ; all loads to   bank 0 ???? set default memory banks
 13689  6934 a685                                ldx var_bank                             ; all names from bank 1 ????   [910620]
 13690  6936 206bff                              jsr _setbank
 13691                          
 13692  6939 206169                              jsr paoc20                               ; by-pass junk
 13693  693c 20b869                              jsr paoc15                               ; get/set file name
 13694  693f 206169                              jsr paoc20                               ; by-pass junk
 13695  6942 205b69                              jsr plsv7                                ; get ',fa'
 13696  6945 a000                                ldy #0                                   ; command 0
 13697  6947 864b                                stx andmsk
 13698  6949 20baff                              jsr _setlfs
 13699  694c 206169                              jsr paoc20                               ; by-pass junk
 13700  694f 205b69                              jsr plsv7                                ; get ',sa'
 13701  6952 8a                                  txa                                      ; new command
 13702  6953 a8                                  tay
 13703  6954 a64b                                ldx andmsk                               ; device #
 13704  6956 20baff                              jsr _setlfs
 13705  6959 8066                                bra dschk                                ; make dosfa current   [900801]
 13706                          
 13707                          
 13708                          
 13709                          ; Look for comma followed by byte
 13710                          
 13711  695b 206969             plsv7            jsr paoc30
 13712  695e 830cf4                              +lbra getbyt
 13713                          
 13714                          
 13715                          
 13716                          ; Skip return if next char is end
 13717                          
 13718  6961 208522             paoc20           jsr chrgot
 13719  6964 d002                                bne paocx
 13720  6966 68                                  pla
 13721  6967 68                                  pla
 13722  6968 60                 paocx            rts
 13723                          
 13724                          
 13725                          
 13726                          ; Check for comma and good stuff
 13727                          
 13728  6969 205b4e             paoc30           jsr chkcom                               ; check comma
 13729                          
 13730  696c 208522             paoc32           jsr chrgot                               ; get current character
 13731  696f d0f7                                bne paocx                                ; is okay
 13732  6971 83d7c4                              +lbra snerr                              ; bad...end of line
 13733                          
 13734                          
 13735                          ; Parse OPEN/CLOSE
 13736                          
 13737  6974 a900               paoc             lda #sys_bank                            ; ????      [910620]
 13738  6976 a685                                ldx var_bank                             ;
 13739  6978 206bff                              jsr _setbank                             ; filename bank     (string bank)????
 13740  697b 20bdff                              jsr _setnam                              ; default file name (null)
 13741  697e 206c69                              jsr paoc32                               ; must get something
 13742  6981 206c5d                              jsr getbyt                               ; get la
 13743  6984 864b                                stx andmsk
 13744  6986 8a                                  txa
 13745  6987 ae0611                              ldx _default_drive                       ; default device
 13746  698a a000                                ldy #0                                   ; default command
 13747  698c 20baff                              jsr _setlfs                              ; store it
 13748  698f 206169                              jsr paoc20                               ; skip junk
 13749  6992 205b69                              jsr plsv7
 13750  6995 864c                                stx eormsk
 13751  6997 a000                                ldy #0                                   ; default sa (command)
 13752  6999 a54b                                lda andmsk                               ; get la
 13753  699b e003                                cpx #3
 13754  699d 9001                                bcc l196_1
 13755  699f 88                                  dey                                      ; if sa not given and fa=serial bus, default to $ff
 13756  69a0 20baff             l196_1           jsr _setlfs                              ; store them
 13757  69a3 206169                              jsr paoc20                               ; skip junk
 13758  69a6 205b69                              jsr plsv7                                ; get sa
 13759  69a9 8a                                  txa
 13760  69aa a8                                  tay
 13761  69ab a64c                                ldx eormsk
 13762  69ad a54b                                lda andmsk
 13763  69af 20baff                              jsr _setlfs                              ; set up real everything
 13764  69b2 206169                              jsr paoc20
 13765  69b5 206969                              jsr paoc30
 13766                          
 13767  69b8 20675b             paoc15           jsr frmstr                               ; do frmevl, frestr. return with len in a, index =~string
 13768  69bb 20dd5b                              jsr getspa                               ; ????fixes old PET bug- load"string",val(chr$(56)) [910917]
 13769                          ; ldx index1
 13770                          ; ldy index1+1
 13771  69be 20bdff                              jsr _setnam                              ; bank always set at plsv
 13772                          ;fall into dschk     [900801]
 13773                          
 13774                          
 13775                          
 13776  69c1 08                 dschk            php                                      ; check if current device >=8, and clear DS if so
 13777  69c2 48                                  pha
 13778  69c3 a5ba                                lda _fa
 13779  69c5 c901                                cmp #1
 13780  69c7 d005                                bne l197_1
 13781  69c9 ad0611                              lda _default_drive
 13782  69cc 85ba                                sta _fa
 13783  69ce c908               l197_1           cmp #8                                   ; ????     [900807]
 13784  69d0 9006                                bcc l197_2
 13785  69d2 8d8211                              sta dosfa                                ; also make last DOS device = current device
 13786  69d5 208278                              jsr Clear_DS
 13787  69d8 68                 l197_2           pla
 13788  69d9 28                                  plp
 13789  69da 60                                  rts
 13790                          
 13791                          ; .page
 13792                          ;k_readst
 13793                          ; jsr put_io_in_map
 13794                          ; jmp _readst
 13795                          
 13796                          
 13797                          
 13798                          ;k_setlfs
 13799                          ; jsr put_io_in_map
 13800                          ; jmp _setlfs
 13801                          
 13802                          
 13803                          
 13804                          ;k_setnam
 13805                          ; jsr put_io_in_map
 13806                          ; jmp _setnam
 13807                          
 13808                          
 13809                          
 13810                          ;k_basin
 13811                          ; jsr put_io_in_map
 13812                          ; jmp _basin
 13813                          
 13814                          
 13815                          ;k_bsout
 13816                          ; jsr put_io_in_map
 13817                          ; jmp _bsout
 13818                          
 13819                          
 13820                          ;k_clrch
 13821                          ; jsr put_io_in_map
 13822                          ; jmp _clrch
 13823                          
 13824                          
 13825                          
 13826                          ;k_close
 13827                          ; jsr put_io_in_map
 13828                          ; jmp _close
 13829                          
 13830                          
 13831                          
 13832                          ;k_clall
 13833                          ; jsr put_io_in_map
 13834                          ; jmp _clall
 13835                          
 13836                          
 13837                          
 13838                          ;k_primm
 13839                          ; jsr put_io_in_map
 13840                          ; jmp _primm
 13841                          
 13842                          
 13843                          ;k_setbank
 13844                          ; jsr put_io_in_map
 13845                          ; jmp _setbank
 13846                          ; rts
 13847                          
 13848                          
 13849                          ;k_plot
 13850                          ; sta sw_rom_ram0  ;????
 13851                          ; jmp _plot
 13852                          
 13853                          
 13854                          ;k_stop
 13855                          ; jsr put_io_in_map
 13856                          ; jmp _stop
 13857                          
 13858                          ;.end
 13859                          ; .page
 13860                          ; .subttl  PRINT USING
 13861                          ; Print Using - Formatted print routine
 13862                          ;
 13863                          ; Entered by cmd, print, or print#
 13864                          ; Syntax:  PRINT USING"****";a;b;c
 13865                          
 13866  69db 202c2e24           pudefs           !text " ,.$"                             ; default:  fill, comma, dec pnt, money symbol
 13867                          
 13868  69df a2ff               using            ldx #$ff
 13869  69e1 8eeb11                              stx endfd
 13870  69e4 208322                              jsr chrget
 13871  69e7 20ef4c                              jsr frmevl                               ; evaluate format string
 13872  69ea 20dd4c                              jsr chkstr                               ; must be string type...
 13873                          
 13874  69ed a566                                lda facmo                                ; save temp descriptor
 13875  69ef 48                                  pha
 13876  69f0 a567                                lda facmo+1
 13877  69f2 48                                  pha
 13878                          
 13879  69f3 a002                                ldy #2                                   ; move (facmo),1&2 to form,form+1
 13880  69f5 20a922             l198_1           jsr indfmo
 13881  69f8 88                                  dey
 13882  69f9 993f00                              sta form,y
 13883  69fc d0f7                                bne l198_1
 13884                          
 13885  69fe 20a922                              jsr indfmo                               ; get length
 13886  6a01 8dea11                              sta lfor
 13887  6a04 a8                                  tay
 13888  6a05 f00b                                beq l198_3                               ; syntax error if length is zero
 13889                          
 13890  6a07 88                 l198_2           dey
 13891  6a08 209d22                              jsr indfrm
 13892  6a0b c923                                cmp #'#'                                 ; at least one # in format?
 13893  6a0d f006                                beq l198_4                               ; yes...
 13894  6a0f 98                                  tya                                      ; no...end of format
 13895  6a10 d0f5                                bne l198_2                               ; no...
 13896  6a12 8336c4             l198_3           +lbra snerr                              ; yes...syntax error
 13897                          
 13898                          
 13899  6a15 a93b               l198_4           lda #';'                                 ; '
 13900  6a17 205d4e             eex2             jsr synchr                               ; check character
 13901  6a1a 8476                                sty z_p_temp_1                           ; clear flag for anaf
 13902  6a1c 8cd811                              sty bnr                                  ; set pointer to begin of no
 13903  6a1f 20ef4c                              jsr frmevl                               ; evaluate expression
 13904  6a22 7f0f39                              bbr7 valtyp,conv                         ; branch if numeric
 13905                          
 13906  6a25 20536c                              jsr ini                                  ; init counters and flags
 13907  6a28 20a16d                              jsr anaf                                 ; analyze format
 13908  6a2b aee011                              ldx chsn                                 ; > or = in format field
 13909  6a2e f015                                beq prcha                                ; branch if not
 13910  6a30 a200                                ldx #0
 13911  6a32 38                                  sec
 13912  6a33 ade611                              lda cform
 13913  6a36 e577                                sbc hulp                                 ; .a=room left in field
 13914  6a38 900b                                bcc prcha                                ; branch if no room left
 13915  6a3a a23d                                ldx #'='
 13916  6a3c ece011                              cpx chsn                                 ; = in field
 13917  6a3f d003                                bne l199_1                               ; branch if not
 13918  6a41 4a                                  lsr                                      ; .a=.a/2
 13919  6a42 6900                                adc #0                                   ; add 1 if odd
 13920                          
 13921  6a44 aa                 l199_1           tax                                      ; store no of blanks in x
 13922  6a45 a000               prcha            ldy #0
 13923  6a47 8a                 chx              txa
 13924  6a48 f005                                beq cpef                                 ; branch if no blanks
 13925  6a4a ca                                  dex
 13926                          
 13927  6a4b a920               oblk             lda #' '                                 ; output a blank
 13928  6a4d 8008                                bra outc                                 ; always
 13929                          
 13930                          
 13931  6a4f c477               cpef             cpy hulp                                 ; end of string reached?
 13932  6a51 b0f8                                bcs oblk                                 ; output blank if yes
 13933  6a53 20d522                              jsr indin1_ram1                          ; lda (index),y
 13934  6a56 c8                                  iny
 13935                          
 13936  6a57 209a6d             outc             jsr cdout                                ; output character
 13937  6a5a d0eb                                bne chx                                  ; branch if not ready
 13938  6a5c 8029                                bra reay
 13939                          
 13940                          
 13941                          
 13942  6a5e 208f64             conv             jsr fout                                 ; convert mfp to decimal
 13943                          
 13944  6a61 a0ff                                ldy #$ff                                 ; build descriptor for fout string
 13945  6a63 c8                 l200_1           iny                                      ; how big IS it?
 13946  6a64 b90001                              lda fbuffr,y
 13947  6a67 d0fa                                bne l200_1
 13948  6a69 98                                  tya
 13949  6a6a 207b5a                              jsr strspa                               ; jsr getspa,stx dsctmp+1,sty dsctmp+2,sta dsctmp,rts
 13950                          
 13951  6a6d da                                  phx
 13952  6a6e a000                                ldy #0
 13953  6a70 a264                                ldx #dsctmp+1
 13954  6a72 b90001             l200_2           lda fbuffr,y
 13955  6a75 f006                                beq l200_3
 13956  6a77 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
 13957  6a7a c8                                  iny
 13958  6a7b d0f5                                bne l200_2
 13959                          
 13960  6a7d fa                 l200_3           plx
 13961  6a7e 20d05a                              jsr putnew
 13962  6a81 20536c                              jsr ini                                  ; init counters and flags
 13963  6a84 20a46a                              jsr fform                                ; output one formatted number
 13964                          
 13965  6a87 208522             reay             jsr chrgot                               ; get old character
 13966  6a8a c92c                                cmp #','                                 ; comma?
 13967  6a8c f089                                beq eex2                                 ; continue print use if yes
 13968  6a8e 38                                  sec
 13969  6a8f 6676                                ror z_p_temp_1                           ; set flag for anaf
 13970  6a91 20a16d                              jsr anaf                                 ; print rest of format
 13971  6a94 7a                                  ply                                      ; restore descriptor
 13972  6a95 68                                  pla
 13973  6a96 20715b                              jsr fretmp
 13974  6a99 208522                              jsr chrgot
 13975  6a9c c93b                                cmp #';'                                 ; semi-colon?
 13976  6a9e d357cd                              +lbne crdo                               ; end of print using
 13977  6aa1 4c8322                              jmp chrget                               ; branch if yes
 13978                          
 13979                          ; .page
 13980                          ;  FFORM - output a number to format
 13981                          ;
 13982                          ;  Number is in fbuffr,  format checked by anaf
 13983                          
 13984                          fform
 13985                          ; sta sw_rom_ram0 ;????
 13986  6aa4 add411                              lda pufill
 13987  6aa7 8de811                              sta blfd                                 ; set working fill char
 13988  6aaa a9ff                                lda #$ff
 13989  6aac 8de711             ana              sta sno                                  ; save blank or '-' in sno
 13990  6aaf 8002                                bra insy
 13991                          
 13992                          
 13993  6ab1 867f               stp              stx point                                ; set point pointer
 13994  6ab3 c477               insy             cpy hulp                                 ; end of no reached?
 13995  6ab5 f032                                beq eoa                                  ; branch if yes
 13996  6ab7 b90001                              lda fbuffr,y                             ; get character of no
 13997  6aba c8                                  iny
 13998  6abb c920                                cmp #' '                                 ; blank?
 13999  6abd f0f4                                beq insy                                 ; yes...span
 14000  6abf c92d                                cmp #'-'                                 ; sign no negative
 14001  6ac1 f0e9                                beq ana                                  ; yes...
 14002  6ac3 c92e                                cmp #'.'                                 ; decimal point?
 14003  6ac5 f0ea                                beq stp                                  ; yes...
 14004  6ac7 c945                                cmp #'E'                                 ; is char 'e'?
 14005  6ac9 f010                                beq lsg                                  ; yes...
 14006  6acb 9d0001                              sta fbuffr,x                             ; move number
 14007  6ace 8ed911                              stx enr                                  ; update end-no pointer
 14008  6ad1 e8                                  inx
 14009  6ad2 247f                                bit point                                ; point pointer set?
 14010  6ad4 10dd                                bpl insy                                 ; yes...
 14011  6ad6 eedf11                              inc vn                                   ; count digits before point
 14012  6ad9 80d8                                bra insy
 14013                          
 14014                          
 14015  6adb b90001             lsg              lda fbuffr,y
 14016  6ade c92d                                cmp #'-'                                 ; sign of exponent negative
 14017  6ae0 d003                                bne l201_1                               ; no...
 14018  6ae2 6edd11                              ror usgn                                 ; make sign negative
 14019  6ae5 c8                 l201_1           iny
 14020  6ae6 8cde11                              sty uexp                                 ; set exponent pointer
 14021                          
 14022  6ae9 a57f               eoa              lda point                                ; decimal found?
 14023  6aeb 1002                                bpl l202_1                               ; yes...
 14024  6aed 867f                                stx point                                ; no...add point
 14025                          
 14026  6aef 20a16d             l202_1           jsr anaf                                 ; analyze format
 14027  6af2 ade111                              lda vf
 14028  6af5 c9ff                                cmp #$ff
 14029  6af7 f029                                beq l202_3                               ; field overflow
 14030  6af9 ade411                              lda fesp                                 ; exponent in field
 14031  6afc f03f                                beq cff                                  ; convert to f format if not
 14032  6afe adde11                              lda uexp                                 ; exponent in number?
 14033  6b01 d012                                bne l202_2                               ; yes...
 14034  6b03 aed911                              ldx enr
 14035  6b06 20286c                              jsr et2                                  ; add exponent to number
 14036  6b09 de0201                              dec fbuffr+2,x
 14037  6b0c e8                                  inx
 14038  6b0d 8ede11                              stx uexp
 14039  6b10 20af6c                              jsr alg                                  ; delete leading zeros
 14040  6b13 f025                                beq hup                                  ; all zero
 14041                          
 14042  6b15 ace311             l202_2           ldy posp                                 ; + or - in format?
 14043  6b18 d017                                bne sswe                                 ; yes...
 14044  6b1a ace711                              ldy sno                                  ; +?
 14045  6b1d 3012                                bmi sswe                                 ; yes...
 14046  6b1f ade111                              lda vf
 14047                          
 14048  6b22 f068               l202_3           beq errf                                 ; no room for sign
 14049  6b24 cee111                              dec vf                                   ; reserve room
 14050  6b27 d005                                bne l202_4
 14051  6b29 ade211                              lda nf                                   ; one #?
 14052  6b2c f05e                                beq errf                                 ; yes...error
 14053                          
 14054  6b2e eedc11             l202_4           inc swe
 14055                          
 14056  6b31 20a36b             sswe             jsr shpn                                 ; shift decimal point
 14057  6b34 206d6c                              jsr uround                               ; round number
 14058  6b37 20a36b                              jsr shpn                                 ; shift again if necessary
 14059                          
 14060  6b3a 839401             hup              +lbra chout                              ; output number
 14061                          
 14062                          
 14063                          
 14064  6b3d acde11             cff              ldy uexp                                 ; exponent in no?
 14065  6b40 f015                                beq l203_2                               ; no...
 14066  6b42 8577                                sta hulp                                 ; delete exponent
 14067  6b44 38                                  sec                                      ; adjust decimal point
 14068  6b45 6ee511                              ror etof                                 ; set e-to-f flag
 14069  6b48 a47f                                ldy point
 14070  6b4a addd11                              lda usgn                                 ; exec nos3 or nos4
 14071  6b4d 1005                                bpl l203_1                               ; depends on sign of exp
 14072  6b4f 20db6b                              jsr nos3
 14073  6b52 800c                                bra l203_3
 14074                          
 14075  6b54 20bd6b             l203_1           jsr nos4
 14076                          
 14077  6b57 a47f               l203_2           ldy point                                ; at start of no?
 14078  6b59 f005                                beq l203_3                               ; yes...
 14079  6b5b 20b36c                              jsr cho                                  ; no = 0 ?
 14080  6b5e f005                                beq l203_4                               ; yes...no round
 14081                          
 14082  6b60 206d6c             l203_3           jsr uround
 14083  6b63 8003                                bra l203_5
 14084                          
 14085  6b65 cedf11             l203_4           dec vn                                   ; adjust...no was 0
 14086  6b68 38                 l203_5           sec
 14087  6b69 ade111                              lda vf
 14088  6b6c eddf11                              sbc vn
 14089  6b6f 901b                                bcc errf                                 ; no fit...error
 14090  6b71 8ddc11                              sta swe                                  ; save difference
 14091  6b74 ace311                              ldy posp                                 ; + or -?
 14092  6b77 d01b                                bne ahp                                  ; yes...
 14093  6b79 ace711                              ldy sno                                  ; get sign
 14094  6b7c 3016                                bmi ahp                                  ; positive...
 14095  6b7e a8                                  tay
 14096  6b7f f00b                                beq errf                                 ; no room for sign
 14097  6b81 88                                  dey
 14098  6b82 d013                                bne ldvn                                 ; swe<>1
 14099  6b84 ade211                              lda nf
 14100  6b87 0ddf11                              ora vn                                   ; both zero?
 14101  6b8a d0ae                                bne hup                                  ; no...
 14102                          
 14103                          
 14104  6b8c a92a               errf             lda #'*'                                 ; format error
 14105  6b8e 209a6d             stout            jsr cdout                                ; fill field with stars
 14106  6b91 d0fb                                bne stout
 14107  6b93 60                                  rts
 14108                          
 14109                          
 14110  6b94 a8                 ahp              tay                                      ; output no if swe=0
 14111  6b95 f0a3                                beq hup
 14112  6b97 addf11             ldvn             lda vn
 14113  6b9a d09e                                bne hup                                  ; vn<>0
 14114  6b9c cedc11                              dec swe                                  ; add extra 0
 14115  6b9f e676                                inc z_p_temp_1                           ; before decimal point
 14116  6ba1 8097                                bra hup
 14117                          
 14118                          ; .page
 14119                          ; Using- shift decimal point
 14120                          
 14121  6ba3 38                 shpn             sec
 14122  6ba4 ade111                              lda vf
 14123  6ba7 eddf11                              sbc vn
 14124  6baa f038                                beq rdy                                  ; format o.k
 14125  6bac a47f                                ldy point
 14126  6bae 9016                                bcc pntl                                 ; vf<vn
 14127  6bb0 8577                                sta hulp
 14128                          
 14129  6bb2 ccd911             incy             cpy enr                                  ; end of no reached?
 14130  6bb5 f002                                beq ity
 14131  6bb7 b001                                bcs nos1                                 ; yes...
 14132                          
 14133  6bb9 c8                 ity              iny
 14134  6bba eedf11             nos1             inc vn
 14135  6bbd 20f16b             nos4             jsr eado                                 ; adjust exponent
 14136  6bc0 c677                                dec hulp                                 ; ready?
 14137  6bc2 d0ee                                bne incy                                 ; no...
 14138  6bc4 f01c                                beq poit
 14139                          
 14140  6bc6 49ff               pntl             eor #$ff
 14141  6bc8 6901                                adc #1
 14142  6bca 8577                                sta hulp                                 ; =vn-vf
 14143                          
 14144  6bcc ccd811             decy             cpy bnr                                  ; begin of no?
 14145  6bcf f006                                beq inz1                                 ; yes...
 14146  6bd1 88                                  dey
 14147  6bd2 cedf11                              dec vn
 14148  6bd5 8002                                bra inz2
 14149                          
 14150                          
 14151  6bd7 e676               inz1             inc z_p_temp_1                           ; add leading zeros
 14152  6bd9 a980               inz2             lda #$80
 14153  6bdb 20f36b             nos3             jsr eadj                                 ; adjust exponent
 14154  6bde c677                                dec hulp                                 ; ready?
 14155  6be0 d0ea                                bne decy                                 ; no...
 14156                          
 14157  6be2 847f               poit             sty point                                ; decimal point pointer
 14158  6be4 60                 rdy              rts
 14159                          
 14160                          ; .page
 14161                          ; Using- adjust exponent
 14162                          
 14163  6be5 d039               sexp             bne retrn                                ; no over/underflow
 14164  6be7 4909                                eor #$09                                 ; .a is 0 or 9
 14165  6be9 9d0001                              sta fbuffr,x                             ; digit back in exp
 14166  6bec ca                                  dex                                      ; = 0 or 9
 14167  6bed ecde11                              cpx uexp
 14168  6bf0 60                                  rts
 14169                          
 14170                          
 14171  6bf1 a900               eado             lda #0
 14172  6bf3 aede11             eadj             ldx uexp
 14173  6bf6 e8                                  inx
 14174  6bf7 2ce511                              bit etof                                 ; e-to-f flag on?
 14175  6bfa 3010                                bmi l204_2                               ; yes...
 14176  6bfc 4ddd11                              eor usgn
 14177  6bff f00b                                beq l204_2                               ; ++ or --
 14178                          
 14179  6c01 20366c             l204_1           jsr tag3                                 ; inc exp, overflow?
 14180  6c04 20e56b                              jsr sexp                                 ; digit 0 if yes
 14181  6c07 b0f8                                bcs l204_1                               ; try second digit
 14182  6c09 833cc2                              +lbra overr                              ; exp>99
 14183                          
 14184  6c0c bd0001             l204_2           lda fbuffr,x
 14185  6c0f de0001                              dec fbuffr,x                             ; decrement exp
 14186  6c12 c930                                cmp #'0'                                 ; underflow on digit?
 14187  6c14 20e56b                              jsr sexp                                 ; set digit=9 if yes...
 14188  6c17 b0f3                                bcs l204_2                               ; try 2nd digit
 14189  6c19 2ce511                              bit etof                                 ; flag off?
 14190  6c1c 1005                                bpl et3                                  ; yes...
 14191  6c1e 847f                                sty point                                ; decimal point pointer
 14192                          
 14193  6c20 68                 retrn            pla
 14194  6c21 68                                  pla
 14195  6c22 60                                  rts                                      ; return to fform/main
 14196                          
 14197                          
 14198  6c23 addd11             et3              lda usgn
 14199  6c26 4980                                eor #$80                                 ; reverse sign exp
 14200  6c28 8ddd11             et2              sta usgn
 14201  6c2b a930                                lda #'0'
 14202  6c2d 9d0101                              sta fbuffr+1,x                           ; exp<0 here
 14203  6c30 a931                                lda #'1'
 14204  6c32 9d0201                              sta fbuffr+2,x
 14205  6c35 60                                  rts
 14206                          
 14207                          
 14208  6c36 bd0001             tag3             lda fbuffr,x                             ; get digit of exp
 14209  6c39 fe0001                              inc fbuffr,x                             ; increment digit
 14210  6c3c c939                                cmp #'9'                                 ; overflow
 14211  6c3e 60                                  rts                                      ; return .z set
 14212                          
 14213                          ; .page
 14214                          ; Using- ansub: load format field char in .a
 14215                          
 14216  6c3f 18                 ansub            clc
 14217  6c40 c8                                  iny                                      ; begin format?
 14218  6c41 f005                                beq l205_1                               ; yes...
 14219  6c43 ccea11                              cpy lfor                                 ; end?
 14220  6c46 9004                                bcc l205_2                               ; no...
 14221                          
 14222  6c48 a476               l205_1           ldy z_p_temp_1                           ; <>0?
 14223  6c4a d0d4                                bne retrn                                ; yes...
 14224                          
 14225  6c4c 209d22             l205_2           jsr indfrm
 14226  6c4f eee611                              inc cform                                ; pointer to field
 14227  6c52 60                                  rts
 14228                          
 14229                          
 14230                          ;  Using- ini: init counters and flags
 14231                          
 14232  6c53 206d5b             ini              jsr frefac                               ; free temp descriptor
 14233  6c56 8577                                sta hulp                                 ; length string
 14234  6c58 a20a                                ldx #$0a                                 ; printed in hulp
 14235  6c5a a900                                lda #0
 14236                          
 14237  6c5c 9ddc11             l206_1           sta swe,x                                ; init working registers
 14238  6c5f ca                                  dex
 14239  6c60 10fa                                bpl l206_1
 14240  6c62 8edb11                              stx flag                                 ; comma flag =ff
 14241  6c65 867f                                stx point                                ; point pointer=ff
 14242  6c67 8eda11                              stx dolr                                 ; dollar flag=ff
 14243  6c6a aa                                  tax                                      ; x=y=0
 14244  6c6b a8                                  tay
 14245  6c6c 60                                  rts
 14246                          
 14247                          ; .page
 14248                          ; Using- round number
 14249                          
 14250  6c6d 18                 uround           clc
 14251  6c6e a57f                                lda point
 14252  6c70 6de211                              adc nf                                   ; overflow?
 14253  6c73 b039                                bcs rrts                                 ; yes...
 14254  6c75 38                                  sec
 14255  6c76 e576                                sbc z_p_temp_1                           ; underflow?
 14256  6c78 9034                                bcc rrts                                 ; yes...
 14257  6c7a cdd911                              cmp enr                                  ; anything to round?
 14258  6c7d f002                                beq l207_1                               ; yes...
 14259  6c7f b02d                                bcs rrts                                 ; no...
 14260                          
 14261  6c81 cdd811             l207_1           cmp bnr                                  ; again...
 14262  6c84 9028                                bcc rrts                                 ; no...
 14263  6c86 aa                                  tax
 14264  6c87 bd0001                              lda fbuffr,x                             ; get digit
 14265  6c8a c935                                cmp #'5'                                 ; <5 ?
 14266  6c8c 9020                                bcc rrts                                 ; yes...no round
 14267                          
 14268  6c8e ecd811             l207_2           cpx bnr                                  ; begin of no reached?
 14269  6c91 f00a                                beq l207_3                               ; yes..add 1
 14270  6c93 ca                                  dex
 14271  6c94 20366c                              jsr tag3                                 ; increment digit
 14272  6c97 8ed911                              stx enr                                  ; new end of no pointer
 14273  6c9a f0f2                                beq l207_2                               ; branch on overflow
 14274  6c9c 60                                  rts
 14275                          
 14276  6c9d a931               l207_3           lda #'1'
 14277  6c9f 9d0001                              sta fbuffr,x
 14278  6ca2 e8                                  inx
 14279  6ca3 867f                                stx point
 14280  6ca5 c676                                dec z_p_temp_1                           ; # of 0's before '.'
 14281  6ca7 1005                                bpl rrts                                 ; no underflow
 14282  6ca9 e676                                inc z_p_temp_1                           ; underflow...back to 0
 14283  6cab eedf11                              inc vn
 14284  6cae 60                 rrts             rts
 14285                          
 14286                          ; .page
 14287                          ; Using- alg: delete leading zeros of no
 14288                          
 14289  6caf a47f               alg              ldy point                                ; start with a .?
 14290  6cb1 f017                                beq szer                                 ; yes...
 14291                          
 14292  6cb3 acd811             cho              ldy bnr
 14293  6cb6 b90001             cmo              lda fbuffr,y                             ; start with a 0?
 14294  6cb9 c930                                cmp #'0'
 14295  6cbb 60                                  rts
 14296                          
 14297                          
 14298  6cbc e67f               nbr              inc point                                ; adjust point
 14299  6cbe 20f16b                              jsr eado                                 ; and exponent
 14300  6cc1 eed811                              inc bnr                                  ; and pointer to begin of no
 14301  6cc4 ccd911                              cpy enr                                  ; end of number?
 14302  6cc7 f0e5                                beq rrts                                 ; yes...
 14303  6cc9 c8                                  iny
 14304                          
 14305  6cca 20b66c             szer             jsr cmo                                  ; zero in no?
 14306  6ccd f0ed                                beq nbr                                  ; yes...
 14307  6ccf 60                                  rts                                      ; no...
 14308                          
 14309                          
 14310                          ; Using- chout: print number
 14311                          
 14312  6cd0 adda11             chout            lda dolr                                 ; dollar flag set?
 14313  6cd3 3002                                bmi l208_1                               ; no...
 14314  6cd5 e676                                inc z_p_temp_1                           ; make room for $
 14315                          
 14316  6cd7 aed811             l208_1           ldx bnr                                  ; start of #
 14317  6cda ca                                  dex
 14318  6cdb ace911                              ldy begfd                                ; begin of field
 14319                          
 14320  6cde 209d22             afrm             jsr indfrm
 14321  6ce1 c8                                  iny
 14322  6ce2 c92c                                cmp #','                                 ; comma?
 14323  6ce4 d00f                                bne punt                                 ; no...
 14324  6ce6 2cdb11                              bit flag                                 ; comma flag on?
 14325  6ce9 3005                                bmi bout                                 ; yes, do a fill char
 14326                          ; sta sw_rom_ram0 ;????
 14327  6ceb add511                              lda pucoma
 14328  6cee 8064                                bra out                                  ; no,...output a comma char
 14329                          
 14330                          
 14331  6cf0 ade811             bout             lda blfd
 14332  6cf3 805f                                bra out
 14333                          
 14334                          
 14335  6cf5 c92e               punt             cmp #'.'                                 ; decimal point?
 14336  6cf7 d005                                bne afplus
 14337                          ; sta sw_rom_ram0 ;????
 14338  6cf9 add611                              lda pudot                                ; yes...
 14339  6cfc 8056                                bra out
 14340                          
 14341                          
 14342  6cfe c92b               afplus           cmp #'+'                                 ; plus?
 14343  6d00 f03a                                beq ispl                                 ; yes...
 14344  6d02 c92d                                cmp #'-'                                 ; minus?
 14345  6d04 f031                                beq ispl1                                ; yes...
 14346  6d06 c95e                                cmp #'^'                                 ; up arrow?
 14347  6d08 d070                                bne pndd                                 ; no...
 14348  6d0a a945                                lda #'E'
 14349  6d0c 209a6d                              jsr cdout
 14350  6d0f acde11                              ldy uexp
 14351  6d12 20b66c                              jsr cmo                                  ; first dig of exp zero?
 14352  6d15 d006                                bne l209_1                               ; no...
 14353  6d17 c8                                  iny
 14354  6d18 20b66c                              jsr cmo                                  ; second digit?
 14355  6d1b f007                                beq l209_2                               ; yes
 14356                          
 14357  6d1d a92d               l209_1           lda #'-'
 14358  6d1f 2cdd11                              bit usgn
 14359  6d22 3002                                bmi l209_3
 14360                          
 14361  6d24 a92b               l209_2           lda #'+'
 14362  6d26 209a6d             l209_3           jsr cdout                                ; output sign exp
 14363  6d29 aede11                              ldx uexp
 14364  6d2c bd0001                              lda fbuffr,x
 14365  6d2f 209a6d                              jsr cdout                                ; output first dig exp
 14366  6d32 aceb11                              ldy endfd
 14367  6d35 8013                                bra telx
 14368                          
 14369  6d37 ade711             ispl1            lda sno                                  ; positive?
 14370  6d3a 30b4                                bmi bout                                 ; yes...out blank or *
 14371  6d3c ade711             ispl             lda sno                                  ; output sgn
 14372  6d3f 8013                                bra out
 14373                          
 14374                          
 14375  6d41 a576               zerot            lda z_p_temp_1                           ; # of zeros
 14376  6d43 d017                                bne zerot1
 14377  6d45 ecd911                              cpx enr                                  ; end of # reached?
 14378  6d48 f005                                beq zout                                 ; yes...output zero
 14379                          
 14380  6d4a e8                 telx             inx
 14381  6d4b bd0001                              lda fbuffr,x                             ; get digit
 14382  6d4e 2c                                  !text $2c                                ; skip
 14383                          
 14384  6d4f a930               zout             lda #'0'                                 ; output zero
 14385                          
 14386  6d51 4edb11             outs             lsr flag                                 ; clear comma flag
 14387                          
 14388  6d54 209a6d             out              jsr cdout                                ; output character
 14389  6d57 f355ff                              +lbeq rrts
 14390  6d5a 8082                                bra afrm                                 ; not ready...
 14391                          
 14392                          
 14393  6d5c c676               zerot1           dec z_p_temp_1                           ; count leading zeros
 14394  6d5e adda11                              lda dolr                                 ; $ flag set?
 14395  6d61 30ec                                bmi zout                                 ; no...output zero
 14396                          
 14397  6d63 209d22                              jsr indfrm                               ; take a peek at the next character in the format string
 14398  6d66 c92c                                cmp #','                                 ; if it's a comma, we got problems
 14399  6d68 d007                                bne l210_1                               ; ...branch if no comma & resume normal processing
 14400                          
 14401  6d6a ade811                              lda blfd                                 ; here's the "$,999.99" bug fix:
 14402  6d6d 209a6d                              jsr cdout                                ; print a 'fill' character instead of the '$'
 14403  6d70 c8                                  iny                                      ; and increment format string pointer past comma
 14404                          
 14405  6d71 38                 l210_1           sec                                      ; resume normal processing
 14406  6d72 6eda11                              ror dolr                                 ; clear the dollar flag & go on to print '$'
 14407                          ; sta sw_rom_ram0 ;????
 14408  6d75 add711                              lda pumony
 14409  6d78 80d7                                bra outs                                 ; output money symbol
 14410                          
 14411                          
 14412  6d7a addc11             pndd             lda swe                                  ; # of blanks
 14413  6d7d f0c2                                beq zerot
 14414  6d7f cedc11                              dec swe                                  ; count !
 14415                          
 14416  6d82 d36cff             l211_1           +lbne bout                               ; out blank or *
 14417  6d85 ade311                              lda posp                                 ; + or - in field?
 14418  6d88 30f8                                bmi l211_1                               ; yes...out blank or *
 14419                          
 14420  6d8a 209d22             l211_2           jsr indfrm
 14421  6d8d c92c                                cmp #','                                 ; comma?
 14422  6d8f d0a6                                bne ispl1                                ; no...out sign
 14423  6d91 ade811                              lda blfd                                 ; yes...
 14424  6d94 209a6d                              jsr cdout                                ; out blank or *
 14425  6d97 c8                                  iny
 14426  6d98 80f0                                bra l211_2
 14427                          
 14428                          
 14429                          
 14430  6d9a 203d68             cdout            jsr outch ;outdo                         ; char out
 14431  6d9d cee611                              dec cform                                ; count it
 14432  6da0 60                                  rts
 14433                          
 14434                          ; .page
 14435                          ; Using- anaf: analyze format
 14436                          
 14437  6da1 aceb11             anaf             ldy endfd                                ; format pointer
 14438  6da4 203f6c             gfor             jsr ansub
 14439  6da7 20536e                              jsr comp                                 ; check special chars
 14440  6daa d014                                bne pchar                                ; no match...
 14441  6dac 8ce911                              sty begfd                                ; save beginning of field
 14442  6daf 9019                                bcc ffoun                                ; # was found
 14443  6db1 aa                                  tax                                      ; save char
 14444                          
 14445  6db2 203f6c             sfur             jsr ansub                                ; get next format char
 14446  6db5 b005                                bcs l212_1                               ; stop on wrap-around
 14447  6db7 205b6e                              jsr com1                                 ; compare specials
 14448  6dba f009                                beq foun1                                ; found some...
 14449                          
 14450  6dbc ace911             l212_1           ldy begfd
 14451  6dbf 8a                                  txa
 14452  6dc0 203d68             pchar            jsr outch ;outdo                         ; out character
 14453  6dc3 80df                                bra gfor
 14454                          
 14455                          
 14456  6dc5 b0eb               foun1            bcs sfur                                 ; no #...keep looking
 14457  6dc7 ace911                              ldy begfd
 14458  6dca a676               ffoun            ldx z_p_temp_1
 14459  6dcc d078                                bne trts
 14460  6dce 8ee611                              stx cform
 14461  6dd1 88                                  dey
 14462                          
 14463  6dd2 cee611             hyo2             dec cform                                ; correct counter
 14464  6dd5 203f6c             hyo              jsr ansub                                ; get next format char
 14465  6dd8 b072                                bcs efo                                  ; end of format
 14466  6dda c92c                                cmp #','                                 ; comma?
 14467  6ddc f0f7                                beq hyo                                  ; yes...ignore it
 14468  6dde 202a6e                              jsr isp                                  ; + or - in format?
 14469  6de1 90ef                                bcc hyo2                                 ; yes...
 14470  6de3 c92e                                cmp #'.'                                 ; decimal point?
 14471  6de5 d008                                bne avf1                                 ; no...
 14472  6de7 e8                                  inx
 14473  6de8 e002                                cpx #2                                   ; more than 1 decimal?
 14474  6dea 90e9                                bcc hyo                                  ; no...
 14475  6dec 835cc0             ero              +lbra snerr                              ; yes...syntax error
 14476                          
 14477                          
 14478  6def 205f6e             avf1             jsr com2                                 ; =, >, or # in field
 14479  6df2 d00a                                bne llar                                 ; no...
 14480  6df4 9003                                bcc hyo1                                 ; was #
 14481  6df6 8de011                              sta chsn                                 ; was > or =
 14482                          
 14483  6df9 fee111             hyo1             inc vf,x
 14484  6dfc 80d7                                bra hyo
 14485                          
 14486  6dfe c924               llar             cmp #'$'                                 ; dollar?
 14487  6e00 d00e                                bne expo                                 ; no...
 14488  6e02 2cda11                              bit dolr                                 ; test flag
 14489  6e05 10f2                                bpl hyo1                                 ; no...
 14490  6e07 18                                  clc
 14491  6e08 6eda11                              ror dolr                                 ; set flag
 14492  6e0b cee111                              dec vf
 14493  6e0e 80e9                                bra hyo1
 14494                          
 14495  6e10 c95e               expo             cmp #'^'                                 ; up arrow?
 14496  6e12 d016                                bne isp                                  ; no...
 14497  6e14 a202                                ldx #$02
 14498  6e16 203f6c             l213_1           jsr ansub                                ; must be 4 up arrows
 14499  6e19 b0d1                                bcs ero
 14500  6e1b c95e                                cmp #'^'                                 ; up arrow?
 14501  6e1d d0cd                                bne ero
 14502  6e1f ca                                  dex
 14503  6e20 10f4                                bpl l213_1
 14504  6e22 eee411                              inc fesp                                 ; set exp flag
 14505  6e25 203f6c                              jsr ansub                                ; next format char
 14506  6e28 b022                                bcs efo                                  ; end of format
 14507                          
 14508  6e2a c92b               isp              cmp #'+'                                 ; plus?
 14509  6e2c d019                                bne chom                                 ; no...
 14510  6e2e ade711                              lda sno                                  ; sign neg?
 14511  6e31 1005                                bpl spos                                 ; yes...
 14512  6e33 a92b                                lda #'+'
 14513  6e35 8de711                              sta sno
 14514                          
 14515  6e38 ade311             spos             lda posp                                 ; + or - already?
 14516  6e3b d0af                                bne ero
 14517  6e3d 6ee311                              ror posp                                 ; make posp neg/clc
 14518  6e40 8ceb11                              sty endfd                                ; end field pointer
 14519  6e43 eee611                              inc cform                                ; correct counter
 14520  6e46 60                 trts             rts
 14521                          
 14522                          
 14523  6e47 c92d               chom             cmp #'-'                                 ; minus?
 14524  6e49 f0ed                                beq spos                                 ; yes...
 14525  6e4b 38                                  sec
 14526  6e4c 8ceb11             efo              sty endfd                                ; end field pointer
 14527  6e4f ceeb11                              dec endfd
 14528  6e52 60                                  rts
 14529                          
 14530                          
 14531                          ; Using- comp: compare .a with symbols
 14532                          
 14533  6e53 c92b               comp             cmp #'+'
 14534  6e55 f015                                beq rt
 14535  6e57 c92d                                cmp #'-'
 14536  6e59 f011                                beq rt
 14537                          
 14538  6e5b c92e               com1             cmp #'.'
 14539  6e5d f00d                                beq rt
 14540                          
 14541  6e5f c93d               com2             cmp #'='
 14542  6e61 f009                                beq rt
 14543  6e63 c93e                                cmp #'>'
 14544  6e65 f005                                beq rt
 14545  6e67 c923                                cmp #'#'
 14546  6e69 d001                                bne rt
 14547  6e6b 18                                  clc
 14548  6e6c 60                 rt               rts
 14549                          
 14550                          ;.end
 14551                          ; .page
 14552                          ; .subttl  INSTR()
 14553                          
 14554                          ;  INSTRing - Find position of str1 in str2 at or after position n
 14555                          ;
 14556                          ; Usage: INSTR(a$,b${,n})
 14557                          
 14558  6e6d a566               instr            lda facmo                                ; save pointer to temporary descriptors
 14559  6e6f 8dd302                              sta tmpdes
 14560  6e72 a567                                lda facmo+1
 14561  6e74 8dd402                              sta tmpdes+1
 14562                          
 14563  6e77 20ef4c                              jsr frmevl                               ; get next arg
 14564  6e7a 20dd4c                              jsr chkstr                               ; must be string
 14565  6e7d a566                                lda facmo
 14566  6e7f 8dd502                              sta tmpdes+2
 14567  6e82 a567                                lda facmo+1
 14568  6e84 8dd602                              sta tmpdes+3
 14569                          
 14570  6e87 a201                                ldx #1                                   ; default starting position
 14571  6e89 8667                                stx faclo
 14572  6e8b 208522                              jsr chrgot
 14573  6e8e c929                                cmp #')'                                 ; any length argument?
 14574  6e90 f003                                beq l214_1                               ; branch if not
 14575  6e92 20825d                              jsr combyt                               ; else go get a one byte argument
 14576                          
 14577  6e95 20554e             l214_1           jsr chkcls                               ; look for )
 14578  6e98 a667                                ldx faclo
 14579  6e9a f362e3                              +lbeq fcerr                              ; starting position can't be 0
 14580  6e9d ca                                  dex
 14581  6e9e 8663                                stx positn
 14582                          
 14583  6ea0 a203                                ldx #3                                   ; copy 'pointers to temp descriptors' to zero page
 14584  6ea2 bdd302             l214_2           lda tmpdes,x
 14585  6ea5 9559                                sta ptarg1,x
 14586  6ea7 ca                                  dex
 14587  6ea8 10f8                                bpl l214_2
 14588                          
 14589  6eaa a002                                ldy #2                                   ; now get the descriptors
 14590  6eac a959               l214_3           lda #ptarg1
 14591  6eae 20d722                              jsr lda_far_ram1                         ; lda (ptarg1),y
 14592  6eb1 995d00                              sta str1,y
 14593  6eb4 a95b                                lda #ptarg2
 14594  6eb6 20d722                              jsr lda_far_ram1                         ; lda (ptarg2),y
 14595  6eb9 996000                              sta str2,y
 14596  6ebc 88                                  dey
 14597  6ebd 10ed                                bpl l214_3
 14598                          
 14599  6ebf a560                                lda str2                                 ; check if string 2 is null
 14600  6ec1 f03b                                beq l214_8                               ; if so, return 0
 14601                          
 14602  6ec3 a900               l214_4           lda #0
 14603  6ec5 8564                                sta match
 14604  6ec7 18                                  clc
 14605  6ec8 a560                                lda str2                                 ; length of string 2
 14606  6eca 6563                                adc positn
 14607  6ecc b030                                bcs l214_8                               ; too long, not found
 14608  6ece c55d                                cmp str1                                 ; see if > length of string 1
 14609  6ed0 9002                                bcc l214_5                               ; < len string 1
 14610  6ed2 d02a                                bne l214_8                               ; must be >, not found
 14611                          
 14612  6ed4 a464               l214_5           ldy match
 14613  6ed6 c460                                cpy str2                                 ; if match len = str len, then found
 14614  6ed8 f01f                                beq l214_7
 14615  6eda 98                                  tya
 14616  6edb 18                                  clc
 14617  6edc 6563                                adc positn                               ; compare str1(s+p+m) with str2(m)
 14618  6ede a8                                  tay
 14619  6edf a95e                                lda #str1+1
 14620  6ee1 20d722                              jsr lda_far_ram1                         ; lda (str1+1),y
 14621  6ee4 8578                                sta syntmp
 14622  6ee6 a464                                ldy match
 14623  6ee8 a961                                lda #str2+1
 14624  6eea 20d722                              jsr lda_far_ram1                         ; lda (str2+1),y
 14625  6eed c578                                cmp syntmp
 14626  6eef f004                                beq l214_6
 14627  6ef1 e663                                inc positn                               ; not the same, start over from next positn
 14628  6ef3 80ce                                bra l214_4                               ; always
 14629                          
 14630  6ef5 e664               l214_6           inc match                                ; count characters that match
 14631  6ef7 80db                                bra l214_5                               ; always
 14632                          
 14633                          
 14634  6ef9 e663               l214_7           inc positn                               ; found
 14635  6efb a563                                lda positn
 14636  6efd 2c                                  !text $2c
 14637                          
 14638  6efe a900               l214_8           lda #0                                   ; not found
 14639                          ; sta sw_rom_ram0 ;????
 14640  6f00 48                                  pha
 14641  6f01 add502                              lda tmpdes+2                             ; free temp descriptors
 14642  6f04 acd602                              ldy tmpdes+3
 14643  6f07 20715b                              jsr fretmp
 14644                          ; sta sw_rom_ram0 ;????
 14645  6f0a add302                              lda tmpdes
 14646  6f0d acd402                              ldy tmpdes+1
 14647  6f10 20715b                              jsr fretmp
 14648  6f13 7a                                  ply
 14649  6f14 83bce9                              +lbra sngflt                             ; float 1 byte in .y
 14650                          
 14651                          ;.end
 14652                          ; .page
 14653                          ; .subttl  TYPE
 14654                          
 14655                          ; TYPE  types a given disk (SEQ) file to output channel
 14656                          ;
 14657                          
 14658  6f17 a300               type             ldz #0
 14659                          
 14660                          open_SEQ_file
 14661  6f19 db                                  phz                                      ; save EDIT load flag    [910620]
 14662  6f1a a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
 14663  6f1c 202074                              jsr dosprs                               ; (like dopen:      0 0 0 *  * 0 0 1 )
 14664  6f1f 20dc77                              jsr chk1                                 ; check parameters
 14665  6f22 201d71                              jsr find_la                              ; find an available LA
 14666  6f25 200d71                              jsr find_sa                              ; find an available SA
 14667  6f28 a011                                ldy #fopnseq
 14668  6f2a a206                                ldx #6
 14669  6f2c 20fd70                              jsr open_file                            ; open the file
 14670  6f2f b3f6c3                              +lbcs list_err                           ; exit if error
 14671  6f32 fb                                  plz                                      ; [910620]
 14672  6f33 f001                                beq l215_1
 14673  6f35 60                                  rts                                      ; or exit if called by EDIT load routine
 14674                          
 14675  6f36 20e1ff             l215_1           jsr _stop                                ; check stop key
 14676  6f39 f03c                                beq l215_6                               ; exit if down
 14677  6f3b ae8111                              ldx dosla
 14678  6f3e 20c6ff                              jsr _chkin                               ; get input channel
 14679  6f41 b034                                bcs l215_6                               ; exit if bad??
 14680  6f43 a200                                ldx #0
 14681  6f45 e0ff               l215_2           cpx #255                                 ; check buffer (buflen????)
 14682                          ; bcs 99$   ; 'too long' error
 14683  6f47 f011                                beq l215_3                               ; allow long lines   [910620]
 14684  6f49 20cfff                              jsr _basin                               ; read file data
 14685  6f4c 9d0013                              sta dosstr,x                             ; buffer it
 14686  6f4f e8                                  inx                                      ; bump buffer pointer
 14687  6f50 a8                                  tay                                      ; save char
 14688  6f51 20b7ff                              jsr _readst                              ; check channel status
 14689  6f54 d004                                bne l215_3                               ; exit if eof or error
 14690  6f56 c00d                                cpy #cr
 14691  6f58 d0eb                                bne l215_2                               ; loop until eol
 14692                          
 14693  6f5a 08                 l215_3           php                                      ; save input channel status (beq=eol, bne=eof/err)
 14694  6f5b 8e7b11                              stx t4                                   ; save character count
 14695  6f5e 20c770                              jsr dcato                                ; get output channel
 14696  6f61 a200                                ldx #0
 14697  6f63 ec7b11             l215_4           cpx t4                                   ; check buffer
 14698  6f66 b009                                bcs l215_5                               ; end of buffered data
 14699  6f68 bd0013                              lda dosstr,x                             ; output data
 14700  6f6b 20d2ff                              jsr _bsout
 14701  6f6e e8                                  inx                                      ; bump buffer pointer
 14702  6f6f d0f2                                bne l215_4                               ; loop until end of buffer
 14703                          
 14704  6f71 20ccff             l215_5           jsr _clrch
 14705  6f74 28                                  plp                                      ; check input status
 14706  6f75 f0bf                                beq l215_1                               ; loop until eof or bad status
 14707                          
 14708  6f77 83a7c3             l215_6           +lbra list_exit                          ; release channel, close file, return to main
 14709                          
 14710                          ;99$ jsr _clrch  ;non-I/O trouble   removed [910620]
 14711                          ; lda dosla  ; shut down disk & report BASIC error
 14712                          ; clc
 14713                          ; jsr _close
 14714                          ; bra errlen  ;buffer overflow: report 'string too long'
 14715                          
 14716                          ; .page
 14717                          ; .subttl  DISK command
 14718                          
 14719                          ; DISK "command_string" [,U#] [,D#]     new [910123]
 14720                          
 14721                          disk
 14722  6f7a a9f6                                lda #$f6                                 ; parse:  command_string [,U#]
 14723  6f7c 202074                              jsr dosprs
 14724  6f7f 20dc77                              jsr chk1                                 ; check parameters
 14725  6f82 a900                                lda #doslfn                              ; la (reserved la)
 14726  6f84 8d8111                              sta dosla
 14727  6f87 a96f                                lda #$6f
 14728  6f89 8d8311                              sta dossa                                ; sa (command channel)
 14729  6f8c a053                                ldy #fdisk
 14730  6f8e a202                                ldx #2                                   ; add "/" [911108]
 14731  6f90 20fd70                              jsr open_file                            ; open command channel & send command string
 14732  6f93 08                                  php                                      ; save error status    [910404]
 14733  6f94 48                                  pha
 14734  6f95 a900                                lda #doslfn                              ; close it
 14735  6f97 38                                  sec                                      ; not a real close
 14736  6f98 20c3ff                              jsr _close                               ; close it
 14737  6f9b 68                                  pla                                      ; [910404]
 14738  6f9c 28                                  plp
 14739  6f9d 83cff8                              +lbra exit_disk_op                       ; common error check & exit path ????
 14740                          
 14741                          
 14742                          ;.end
 14743                          ; .page
 14744                          ; .subttl  DOS 1
 14745                          
 14746                          ; These routines take tokens and values after the following BASIC keywords:
 14747                          ;
 14748                          ;  DOPEN,   DCLOSE,  APPEND,  CONCAT, RECORD
 14749                          ;  DLOAD,   DSAVE,   DVERIFY, BLOAD,  BSAVE
 14750                          ;  FORMAT,  COLLECT, BACKUP,  COPY
 14751                          ;  CATALOG, RENAME,  SCRATCH, DCLEAR
 14752                          ;
 14753                          ; It then parses the following line and finds syntax errors, checks for values
 14754                          ; out of range, and sets variables in the zero-page to be passed to the disk
 14755                          ; message generator.
 14756                          
 14757                          
 14758                          directory                                                 ; display disk directory (catalog)
 14759  6fa0 208522                              jsr chrgot                               ; get current chr
 14760  6fa3 c9fe                                cmp #esc_command_token                   ; eat dirECTORY kludge if it's there
 14761  6fa5 d00b                                bne l216_1
 14762  6fa7 208322                              jsr chrget                               ; (esc token + another)
 14763  6faa c929                                cmp #ectory_token
 14764  6fac d39cbe                              +lbne snerr
 14765  6faf 208322                              jsr chrget                               ; yes- get next good char
 14766                          
 14767  6fb2 201e74             l216_1           jsr dospar                               ; parse the line
 14768  6fb5 a57f                                lda parsts                               ; check options
 14769  6fb7 29e6                                and #$e6
 14770  6fb9 d38fbe                              +lbne snerr
 14771                          
 14772  6fbc a001                                ldy #fdir                                ; table offset for directory
 14773  6fbe 2c8f11                              bit dosflags                             ; want recoverable files? [901024]
 14774  6fc1 5002                                bvc l216_2                               ; no
 14775  6fc3 a005                                ldy #fdirr                               ; yes
 14776  6fc5 a201               l216_2           ldx #1                                   ; just $
 14777  6fc7 a57f                                lda parsts                               ; check for default
 14778  6fc9 2911                                and #$11                                 ; no drive?
 14779  6fcb f006                                beq l216_4
 14780  6fcd 4a                                  lsr
 14781  6fce 9002                                bcc l216_3                               ; just drive
 14782  6fd0 e8                                  inx                                      ; drive and filename
 14783  6fd1 e8                                  inx
 14784  6fd2 e8                 l216_3           inx
 14785  6fd3 8a                 l216_4           txa                                      ; a now has length
 14786  6fd4 20f276                              jsr sendp                                ; build
 14787                          
 14788  6fd7 a200                                ldx #sys_bank                            ; set banks????  fname in system space, bank0 [910620]
 14789  6fd9 8a                                  txa                                      ; (load bank is don't care- we're not actually loading)
 14790  6fda 206bff                              jsr _setbank
 14791                          
 14792  6fdd a060                                ldy #$60                                 ; sa, load floppy
 14793  6fdf ae8211                              ldx dosfa
 14794  6fe2 a900                                lda #doslfn                              ; lfn
 14795  6fe4 20baff                              jsr _setlfs                              ; set file parameters
 14796  6fe7 20c0ff                              jsr _open                                ; open it...
 14797  6fea 9009                                bcc l216_5                               ; ...ok
 14798  6fec 48                                  pha
 14799  6fed 204f70                              jsr dcat11                               ; ...error, shut down and report
 14800  6ff0 fa                                  plx
 14801  6ff1 38                                  sec
 14802  6ff2 835bbe                              +lbra error
 14803                          
 14804  6ff5 a515               l216_5           lda channl                               ; determine DIR vs LDIR
 14805  6ff7 d05e                                bne ldir                                 ; if output channel not default (screen)
 14806                          ; use LDIR
 14807                          
 14808                          ; Get length in blocks
 14809                          
 14810  6ff9 a200               dir              ldx #doslfn
 14811  6ffb 20c6ff                              jsr _chkin
 14812  6ffe b04f                                bcs dcat11                               ; if problem??
 14813  7000 20b7ff                              jsr _readst                              ; check status
 14814  7003 d04a                                bne dcat11                               ; exit if bad status
 14815  7005 20f737                              jsr crdo                                 ; output new line
 14816  7008 a003                                ldy #3                                   ; loop counter
 14817                          
 14818  700a 8c7911             dcat3            sty t3                                   ; save counter
 14819                          
 14820  700d 20cfff             l217_1           jsr _basin                               ; get char
 14821  7010 8d7b11                              sta t4
 14822  7013 20cfff                              jsr _basin                               ; get char
 14823  7016 8d7c11                              sta t4+1
 14824  7019 20b7ff                              jsr _readst                              ; check status
 14825  701c d031                                bne dcat11                               ; exit if eof or bad status
 14826  701e ce7911                              dec t3
 14827  7021 d0ea                                bne l217_1                               ; if not done
 14828                          
 14829                          ; Output blocks number
 14830                          
 14831  7023 ae7b11                              ldx t4
 14832  7026 ad7c11                              lda t4+1
 14833  7029 207f64                              jsr linprt                               ; output number
 14834  702c a920                                lda #' '
 14835  702e 20d2ff                              jsr _bsout                               ; output a space
 14836                          
 14837                          ; Get name & output it
 14838                          
 14839  7031 20b7ff             dcat4            jsr _readst                              ; get status
 14840  7034 d016                                bne dcat10                               ; if bad status
 14841  7036 20cfff                              jsr _basin                               ; get char
 14842  7039 f005                                beq dcat5                                ; if eol
 14843  703b 20d2ff                              jsr _bsout                               ; echo char
 14844  703e 80f1                                bra dcat4                                ; continue to process name until eol or err
 14845                          
 14846                          ; Here on end of name
 14847                          
 14848  7040 20f737             dcat5            jsr crdo                                 ; output new line
 14849  7043 20e1ff                              jsr _stop                                ; check stop key
 14850  7046 f007                                beq dcat11                               ; exit if stop request
 14851                          
 14852                          ; Process next
 14853                          
 14854  7048 a002                                ldy #2                                   ; perform 2 times
 14855  704a 80be                                bra dcat3
 14856                          
 14857                          
 14858                          ; Exit directory
 14859                          
 14860  704c 20f737             dcat10           jsr crdo                                 ; flush current line
 14861  704f 20b438             dcat11           jsr release_channels                     ; release cmd channel, restore terminal
 14862  7052 a900                                lda #doslfn
 14863  7054 83b8f8                              +lbra close_out                          ; [900725]
 14864                          
 14865                          ; .page
 14866                          ; LDIR  same as DIR, except it buffers each line to reduce
 14867                          ;       talker/listener turnaround time.  Even so, it is still
 14868                          ; unacceptably slow for normal screen output, which is
 14869                          ; why it was split out from the original DIRECTORY routine.
 14870                          ;
 14871                          
 14872                          ; Read block count
 14873                          
 14874                          ldir
 14875  7057 a9c0                                lda #$c0                                 ; serial bus kludge for open4,4:cmd4:dir ????
 14876  7059 2d09d6                              and $d609
 14877  705c 1c09d6                              trb $d609                                ; disable fast serial bus
 14878  705f 8586                                sta sid_speed_flag                       ; but save enables so we can restore them
 14879                          
 14880  7061 a003                                ldy #3                                   ; loop counter (3=skip fake load adr & link bytes)
 14881  7063 8c7911             l218_1           sty t3                                   ; save counter
 14882  7066 a200                                ldx #doslfn
 14883  7068 20c6ff                              jsr _chkin
 14884  706b b053                                bcs ldir_end                             ; problem??
 14885                          
 14886  706d 20b7ff             l218_2           jsr _readst                              ; check status
 14887  7070 d04e                                bne ldir_end                             ; exit if bad status
 14888  7072 20cfff                              jsr _basin                               ; get block count
 14889  7075 8d0013                              sta dosstr                               ; buffer it
 14890  7078 20cfff                              jsr _basin
 14891  707b 8d0113                              sta dosstr+1
 14892  707e ce7911                              dec t3
 14893  7081 d0ea                                bne l218_2                               ; continue eating bytes until we have block count
 14894                          
 14895                          ; Read filename
 14896                          
 14897  7083 a201                                ldx #1                                   ; buffer index-1
 14898  7085 e8                 l218_3           inx
 14899  7086 20b7ff                              jsr _readst                              ; check status
 14900  7089 d035                                bne ldir_end                             ; exit if eof or bad status
 14901  708b 20cfff                              jsr _basin                               ; buffer next character
 14902  708e 9d0013                              sta dosstr,x
 14903  7091 d0f2                                bne l218_3                               ; loop until eol (null terminator)
 14904                          
 14905                          ; Print one line of directory
 14906                          
 14907  7093 20c770                              jsr dcato                                ; get output channel
 14908  7096 ae0013                              ldx dosstr
 14909  7099 ad0113                              lda dosstr+1
 14910  709c 207f64                              jsr linprt                               ; print blocks
 14911                          
 14912  709f a920                                lda #' '
 14913  70a1 20d2ff                              jsr _bsout                               ; print space
 14914                          
 14915  70a4 a202                                ldx #2
 14916  70a6 bd0013             l218_4           lda dosstr,x
 14917  70a9 f006                                beq l218_5
 14918  70ab 20d2ff                              jsr _bsout                               ; print filename (null terminated)
 14919  70ae e8                                  inx
 14920  70af d0f5                                bne l218_4
 14921                          
 14922  70b1 20f737             l218_5           jsr crdo                                 ; print return
 14923  70b4 20ccff                              jsr _clrch
 14924  70b7 20e1ff                              jsr _stop                                ; check stop key
 14925  70ba f004                                beq ldir_end                             ; exit if stop request
 14926                          
 14927                          ; Continue with next line
 14928                          
 14929  70bc a002                                ldy #2                                   ; set to skip fake link bytes
 14930  70be 80a3                                bra l218_1                               ; loop
 14931                          
 14932                          
 14933                          ldir_end
 14934  70c0 a586                                lda sid_speed_flag                       ; serial bus kludge for open4,4:cmd4:dir ????
 14935  70c2 0c09d6                              tsb $d609                                ; restore fast serial bus enables
 14936  70c5 8088                                bra dcat11
 14937                          
 14938                          
 14939                          
 14940  70c7 20ccff             dcato            jsr _clrch
 14941  70ca a615                                ldx channl                               ; restore output channel
 14942  70cc f003                                beq l219_1                               ; branch if screen (default output)
 14943  70ce 4cc9ff                              jmp _chkout                              ; else get output channel
 14944                          
 14945  70d1 60                 l219_1           rts
 14946                          
 14947                          ; .page
 14948                          ; DOPEN dfn(,t(,r))
 14949                          
 14950  70d2 a922               dopen            lda #$22                                 ; set error flag
 14951  70d4 202074                              jsr dosprs                               ; parse the line
 14952  70d7 200478                              jsr chk6                                 ; check required parameters
 14953  70da 200d71                              jsr find_sa                              ; find unused secondary address
 14954  70dd a009                                ldy #fopn                                ; fcb format pointer
 14955  70df a204                                ldx #4                                   ; normal length
 14956  70e1 6f7f13                              bbr6 parsts,open_it                      ; relative record? branch if not relative
 14957  70e4 a208                                ldx #8                                   ; random access length
 14958  70e6 800f                                bra open_it                              ; [910925]
 14959                          
 14960                          ;l220_1 jsr open_file  ;open it
 14961                          ; bra exit_disk_op ;report any DOS errors, & return to main [910404]
 14962                          
 14963                          
 14964                          
 14965                          ; APPEND
 14966                          
 14967  70e8 a9e2               append           lda #$e2                                 ; set error flags
 14968  70ea 202074                              jsr dosprs                               ; parse the line
 14969  70ed 200478                              jsr chk6                                 ; check required parameters
 14970  70f0 200d71                              jsr find_sa                              ; find secondary address
 14971  70f3 a028                                ldy #fapn                                ; tabld index
 14972  70f5 a205                                ldx #5                                   ; length
 14973                          open_it
 14974  70f7 20fd70                              jsr open_file                            ; open it
 14975  70fa 8372f7                              +lbra exit_disk_op                       ; report any DOS errors, & return to main [910404]
 14976                          
 14977                          
 14978                          
 14979                          open_file                                                 ; dop2.
 14980  70fd 8a                                  txa                                      ; set length into a
 14981  70fe 20f276                              jsr sendp
 14982  7101 20ccff                              jsr _clrch
 14983  7104 a200                                ldx #sys_bank                            ; fname is in system space, bank0  [910620]
 14984  7106 8a                                  txa                                      ; (load bank not req'd)????
 14985  7107 206bff                              jsr _setbank
 14986  710a 4cc0ff                              jmp _open
 14987                          
 14988                          ; .page
 14989                          ; Find an available secondary address
 14990                          
 14991                          find_sa
 14992  710d a061                                ldy #$61                                 ; 2-14 possible
 14993                          
 14994  710f c8                 l220_1           iny
 14995  7110 c06f                                cpy #$6f
 14996  7112 f017                                beq too_many_files                       ; if none available error
 14997  7114 2062ff                              jsr _lkupsa                              ; kernel will lookup this sa in its tables
 14998  7117 90f6                                bcc l220_1                               ; if used keep looking
 14999  7119 8c8311                              sty dossa                                ; save secondary address
 15000  711c 60                                  rts                                      ; return .y = sa
 15001                          
 15002                          
 15003                          
 15004                          ; Find an available logical address
 15005                          
 15006                          find_la
 15007  711d a900                                lda #0                                   ; 1-127 possible
 15008                          
 15009  711f 1a                 l221_1           inc
 15010  7120 3009                                bmi too_many_files                       ; if none available error
 15011  7122 205fff                              jsr _lkupla                              ; kernel will lookup this la in its tables
 15012  7125 90f8                                bcc l221_1                               ; if used keep looking
 15013  7127 8d8111                              sta dosla                                ; save logical address
 15014  712a 60                                  rts                                      ; return .a = la
 15015                          
 15016                          
 15017                          
 15018                          
 15019                          too_many_files
 15020  712b a201                                ldx #errtmf                              ; too many files open
 15021  712d 8320bd                              +lbra error
 15022                          
 15023                          ; .page
 15024                          ; Close disk file
 15025                          
 15026  7130 a9f3               dclose           lda #$f3                                 ; set error flags
 15027  7132 202074                              jsr dosprs                               ; parse the line
 15028  7135 208278                              jsr Clear_DS
 15029  7138 2f7f06                              bbr2 parsts,dclall                       ; any la given?  branch if not
 15030  713b ad8111                              lda dosla
 15031  713e 83cef7                              +lbra close_out
 15032                          
 15033  7141 ad8211             dclall           lda dosfa                                ; get disk #
 15034                          ; jsr put_io_in_map
 15035  7144 4c50ff                              jmp _close_all                           ; close all channels
 15036                          
 15037                          
 15038                          
 15039                          ; DSAVE dfn
 15040                          
 15041  7147 4f7e03             dsave            bbr4 runmod,l222_1                       ; PROGRAM or EDIT mode?    [910620]
 15042  714a 83ab4c                              +lbra edit_save                          ; edit
 15043                          
 15044  714d a966               l222_1           lda #$66                                 ; set error flags
 15045  714f 202074                              jsr dosprs                               ; parse the line
 15046  7152 20e177                              jsr chk2                                 ; check required parameters
 15047  7155 a009                                ldy #fopn                                ; table offset
 15048  7157 a904                                lda #4                                   ; ..length,
 15049  7159 20f276                              jsr sendp
 15050                          
 15051  715c a584                                lda text_bank                            ; default to text bank set up banks???? [910620]
 15052  715e a200                                ldx #sys_bank                            ; fname is in system space, bank0
 15053  7160 206bff                              jsr _setbank
 15054  7163 8300f7                              +lbra savenp
 15055                          
 15056                          ; .page
 15057                          ; DVERIFY
 15058                          
 15059  7166 a901               dverify          lda #1                                   ; flag 'verify'
 15060  7168 2c                                  !text $2c
 15061                          
 15062                          
 15063                          
 15064                          ; DLOAD dfn
 15065                          
 15066  7169 a900               dload            lda #0
 15067  716b 850c                                sta verck                                ; set load flag (for verify check later)
 15068                          
 15069  716d 4f7e03                              bbr4 runmod,l223_1                       ; PROGRAM or EDIT mode?    [910620]
 15070  7170 839b4b                              +lbra edit_load                          ; edit
 15071                          
 15072  7173 a9e6               l223_1           lda #$e6                                 ; set error flags
 15073  7175 202074                              jsr dosprs                               ; parse the line
 15074  7178 20e177                              jsr chk2                                 ; check required parameters
 15075                          
 15076                          
 15077                          dload_boot                                                ; <<<<<<<<<<<<<<<<<< entry for BOOT'AUTOBOOT.C65'
 15078  717b a900                                lda #0
 15079  717d 8d8311                              sta dossa                                ; set relocate flag
 15080  7180 a009                                ldy #fopn                                ; table offset
 15081  7182 a904                                lda #4                                   ; ..length
 15082  7184 20f276                              jsr sendp
 15083                          
 15084  7187 a584                                lda text_bank                            ; set up banks ???? want text_bank ????  [910620]
 15085  7189 a200                                ldx #sys_bank                            ; fname is in system space, bank0
 15086  718b 206bff                              jsr _setbank
 15087                          
 15088  718e 8307f7                              +lbra cld10                              ; finish load, using 'LOAD' code.
 15089                          
 15090                          ; .page
 15091                          ; BSAVE
 15092                          
 15093  7191 a966               bsave            lda #$66                                 ; std error flag
 15094  7193 a2f8                                ldx #$f8                                 ; auxiliary error flag (allow bank, start & end address)
 15095  7195 202274                              jsr dosprx                               ; parse options
 15096  7198 20e177                              jsr chk2                                 ; check required parameters
 15097                          
 15098  719b a580                                lda parstx                               ; check for starting & ending addresses
 15099  719d 2906                                and #6
 15100  719f c906                                cmp #6
 15101  71a1 d3a7bc                              +lbne snerr                              ; ..if not present, syntax error
 15102                          
 15103  71a4 ad8011                              lda dosofh+1                             ; check that ea>sa
 15104  71a7 cd7e11                              cmp dosofl+1
 15105  71aa 9352e0                              +lbcc fcerr                              ; ...error
 15106  71ad d00c                                bne l224_1
 15107  71af ad7f11                              lda dosofh
 15108  71b2 cd7d11                              cmp dosofl
 15109  71b5 9347e0                              +lbcc fcerr                              ; ...error
 15110  71b8 f344e0                              +lbeq fcerr
 15111                          
 15112  71bb a009               l224_1           ldy #fopn                                ; table offset
 15113  71bd a904                                lda #4                                   ; ..length
 15114  71bf 20f276                              jsr sendp
 15115                          
 15116  71c2 ad8c11                              lda dosbnk                               ; get requested bank
 15117  71c5 a200                                ldx #sys_bank                            ; ..and name will be in system bank
 15118  71c7 206bff                              jsr _setbank                             ; ..and go set up bank
 15119                          
 15120  71ca ae7d11                              ldx dosofl                               ; start addr
 15121  71cd ac7e11                              ldy dosofl+1
 15122  71d0 a95a                                lda #highds                              ; ..and a pointer to start address
 15123  71d2 865a                                stx highds
 15124  71d4 845b                                sty highds+1
 15125  71d6 ae7f11                              ldx dosofh                               ; end addr
 15126  71d9 ac8011                              ldy dosofh+1
 15127  71dc 838df6                              +lbra savenb
 15128                          
 15129                          
 15130                          ; .page
 15131                          ; DVERIFY
 15132                          
 15133  71df a901               bverify          lda #1                                   ; flag 'verify'
 15134  71e1 2c                                  !text $2c
 15135                          
 15136                          
 15137                          ; BLOAD dfn
 15138                          
 15139  71e2 a900               bload            lda #0                                   ; flag 'load'
 15140  71e4 850c                                sta verck                                ; eventually the 'load' routine will look here
 15141                          
 15142  71e6 a9e6                                lda #$e6                                 ; std error flag
 15143  71e8 a2fc                                ldx #$fc                                 ; aux error flag (allow bank & load address)
 15144  71ea 202274                              jsr dosprx                               ; parse options
 15145                          
 15146                          bload_boot                                                ; <<<<<<<<<<<<<<<<<<<<<< entry for BOOT'filename'
 15147  71ed 20e177                              jsr chk2                                 ; check required parameters
 15148  71f0 ae7d11                              ldx dosofl                               ; get starting address high
 15149  71f3 ac7e11                              ldy dosofl+1                             ; ..and lo
 15150  71f6 a900                                lda #0                                   ; assume x & y not both=ff (means real add., not def)
 15151  71f8 e0ff                                cpx #$ff
 15152  71fa d006                                bne l225_1
 15153  71fc c0ff                                cpy #$ff
 15154  71fe d002                                bne l225_1
 15155  7200 a9ff                                lda #$ff                                 ; use defaults
 15156  7202 8d8311             l225_1           sta dossa
 15157                          
 15158  7205 a009                                ldy #fopn                                ; table offset
 15159  7207 a904                                lda #4                                   ; ..length,
 15160  7209 20f276                              jsr sendp                                ; ...and go send parameters
 15161                          
 15162  720c ad8c11                              lda dosbnk
 15163  720f a200                                ldx #sys_bank
 15164  7211 206bff                              jsr _setbank
 15165                          
 15166  7214 a50c                                lda verck                                ; flag LOAD or VERIFY
 15167  7216 ae7d11                              ldx dosofl                               ; get starting address high
 15168  7219 ac7e11                              ldy dosofl+1                             ; ..and lo (in case this isn't a 'default' load)
 15169  721c 20d5ff                              jsr _loadsp                              ; load it
 15170                          
 15171                          ; Any changes to the following code must be duplicated at:
 15172                          ;  load (load_file)
 15173                          ;  save (exit_disk_op)
 15174                          
 15175  721f 08                                  php                                      ; save kernel load status (.c)
 15176  7220 48                                  pha                                      ; save kernel error # (.a)
 15177  7221 20b7ff                              jsr _readst                              ; save I/O status byte
 15178  7224 857f                                sta parsts
 15179  7226 206e72                              jsr print_dos_error                      ; report DOS problems
 15180  7229 68                                  pla                                      ; restore error stuff
 15181  722a 28                                  plp
 15182  722b 9010                                bcc l225_4                               ; branch if no error (rts)
 15183  722d ff7e0a                              bbs7 runmod,l225_3                       ; branch if run mode (erexit)
 15184  7230 c904                                cmp #errfnf                              ; is it 'file not found' catch-all?
 15185  7232 d005                                bne l225_2                               ; no  (erexit)
 15186  7234 8dc702                              sta errnum                               ; yes- save error # for 'er'
 15187  7237 0980                                ora #$80                                 ; but no errdis
 15188  7239 38                 l225_2           sec
 15189  723a b3faf5             l225_3           +lbcs erexit                             ; exit if kernel problem (rts)
 15190                          
 15191  723d a50c               l225_4           lda verck                                ; load or verify operation?
 15192  723f d388f6                              +lbne verify_check                       ; verify
 15193                          
 15194                          ; jsr _readst  ;  read status
 15195  7242 a57f                                lda parsts                               ; load
 15196  7244 29bf                                and #%10111111                           ; EOI is okay, so mask it
 15197  7246 d398f6                              +lbne load_error                         ; load error
 15198  7249 18                                  clc
 15199  724a 60                                  rts
 15200                          
 15201                          ; .page
 15202                          ; HEADER nddn [,id]  (alias: FORMAT)
 15203                          
 15204  724b 201e74             header           jsr dospar                               ; parse the line
 15205  724e 20dc77                              jsr chk1                                 ; check parameter errors
 15206  7251 2901                                and #$01
 15207  7253 c901                                cmp #$01
 15208  7255 d3f3bb                              +lbne snerr                              ; if required parameters not present
 15209                          
 15210  7258 20e7ff                              jsr _clall                               ; close all files
 15211  725b 20c378                              jsr are_you_sure                         ; confirm if in direct mode
 15212  725e d072                                bne header_rts                           ; exit if 'no' response
 15213  7260 a02d                                ldy #fhed                                ; tabld index
 15214  7262 a904                                lda #4                                   ; length
 15215  7264 ae8d11                              ldx dosdid                               ; check for diskid
 15216  7267 f002                                beq l226_1
 15217  7269 a906                                lda #6                                   ; length with id
 15218                          
 15219  726b 20f973             l226_1           jsr trans                                ; build and send command
 15220                          ;fall into 'print_dos_error'
 15221                          
 15222                          ; .page
 15223                          print_dos_error                                           ; [900725]
 15224  726e ff7e61                              bbs7 runmod,header_rts                   ; branch if not direct mode
 15225  7271 200e78                              jsr Check_DS                             ; get current disk error message
 15226  7274 a000                                ldy #0
 15227  7276 a97a                                lda #dsdesc+1
 15228  7278 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y peek at first character
 15229  727b c932                                cmp #'2'
 15230  727d 9053                                bcc header_rts                           ; branch if no error occured ('00' or '01')
 15231  727f c937                                cmp #'7'
 15232  7281 d00a                                bne l227_1                               ; [900730]
 15233  7283 c8                                  iny
 15234  7284 a97a                                lda #dsdesc+1
 15235  7286 20d722                              jsr lda_far_ram1                         ; might be '73' powerup message
 15236  7289 c933                                cmp #'3'
 15237  728b f045                                beq header_rts                           ; yup
 15238                          
 15239                          ; ldx #errbdk  ; bad disk error (carry is set)
 15240                          ; bra error
 15241                          
 15242                          ; Print DOS error message as if it were a BASIC error message   [900910]
 15243                          
 15244  728d a9ff               l227_1           lda #$ff                                 ; reset error line
 15245  728f 8dc802                              sta errlin                               ;
 15246  7292 8dc902                              sta errlin+1
 15247  7295 20ccff                              jsr _clrch
 15248                          ; inc a   ;a=0 restore output to screen   [910909]
 15249  7298 8515                                sta channl
 15250  729a 2027af                              jsr RestoreTextScreen                    ; make sure we're in text mode????  [910404]
 15251  729d 200935                              jsr init_stack                           ; clean up system, string temps, etc.  [910121]
 15252                          
 15253  72a0 20dc3c                              jsr highlight_text                       ; [910624]
 15254  72a3 207dff                              jsr _primm                               ; start a new line with '?DOS: '
 15255  72a6 0d3f444f533a2000                    !text cr,"?DOS: ",0                      ; (to distinguish ?DOS: SYNTAX ERROR from ?SYNTAX ERROR)
 15256                          
 15257  72ae a003                                ldy #3                                   ; print text part of message only
 15258  72b0 a97a                                lda #dsdesc+1
 15259  72b2 20d722                              jsr lda_far_ram1                         ; skip err#, comma, & leading space if any
 15260  72b5 c920                                cmp #' '
 15261  72b7 d00a                                bne l227_3
 15262  72b9 c8                                  iny
 15263  72ba a97a               l227_2           lda #dsdesc+1
 15264  72bc 20d722                              jsr lda_far_ram1
 15265  72bf c92c                                cmp #','                                 ; finished at comma preceding trk, sector
 15266  72c1 f006                                beq l227_4
 15267  72c3 203d68             l227_3           jsr outch
 15268  72c6 c8                                  iny
 15269  72c7 10f1                                bpl l227_2                               ; loop always (bpl=failsafe)
 15270                          
 15271  72c9 20cb3c             l227_4           jsr highlight_done                       ; [910624]
 15272  72cc 20f737                              jsr crdo
 15273  72cf 837cbb                              +lbra ready                              ; we're in direct mode, error msg has been printed, abort
 15274                          
 15275                          header_rts
 15276  72d2 18                                  clc
 15277  72d3 60                                  rts
 15278                          
 15279                          ; .page
 15280                          ; SCRATCH sdfn  aliases: DELETE, ERASE
 15281                          
 15282  72d4 201e74             scratch          jsr dospar                               ; parse the line
 15283  72d7 20dc77                              jsr chk1
 15284  72da 20c378                              jsr are_you_sure                         ; confirm if in direct mode
 15285  72dd d02b                                bne l228_4                               ; branch if 'no' response given
 15286                          
 15287  72df a049                                ldy #fscr                                ; offset
 15288  72e1 a904                                lda #4                                   ; length
 15289  72e3 2c8f11                              bit dosflags                             ; scratch or recover?
 15290  72e6 5004                                bvc l228_1                               ; scratch
 15291  72e8 a04d                                ldy #frscr                               ; recover
 15292  72ea a906                                lda #6
 15293  72ec 20f973             l228_1           jsr trans                                ; transmit scratch command
 15294  72ef 201378                              jsr Read_DS                              ; read error channel & update DS$
 15295                          
 15296  72f2 ff7e15                              bbs7 runmod,l228_4                       ; branch if not direct mode
 15297  72f5 20f737                              jsr crdo                                 ; output cr
 15298                          
 15299  72f8 a000                                ldy #0                                   ; display 'files scratched' DOS message
 15300  72fa a97a               l228_2           lda #dsdesc+1
 15301  72fc 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
 15302  72ff f006                                beq l228_3                               ; if end of error message
 15303  7301 203d68                              jsr outch                                ; print it
 15304  7304 c8                                  iny
 15305  7305 10f3                                bpl l228_2                               ; always (bpl=failsafe)
 15306                          
 15307  7307 20f737             l228_3           jsr crdo                                 ; done
 15308                          
 15309  730a 60                 l228_4           rts
 15310                          
 15311                          ; .page
 15312                          ; RECORD- relative record access
 15313                          
 15314  730b a923               record           lda #'#'
 15315  730d 205d4e                              jsr synchr                               ; syntax error if not 'record#'
 15316                          
 15317  7310 206c5d                              jsr getbyt                               ; get lfn in x
 15318  7313 e000                                cpx #0
 15319  7315 f3e7de                              +lbeq fcerr                              ; cannot be zero
 15320  7318 8e8111                              stx dosla                                ; save logical address
 15321                          
 15322  731b 20875d                              jsr comwrd                               ; check for comma, get record number in 'poker'
 15323                          
 15324  731e a201                                ldx #1                                   ; set up to get starting byte # - default is 1
 15325  7320 202679                              jsr optbyt
 15326  7323 8e8b11                              stx dosrcl                               ; save byte position (pos)    [911024]
 15327  7326 8a                                  txa                                      ; cpx #0
 15328  7327 f3d5de                              +lbeq fcerr                              ; if out of range
 15329  732a e8                                  inx                                      ; cpx #$ff
 15330  732b f3d1de                              +lbeq fcerr                              ; if out of range
 15331                          
 15332  732e ad8111                              lda dosla                                ; get logical address
 15333                          ; jsr put_io_in_map
 15334  7331 205fff                              jsr _lkupla                              ; logical to physical map
 15335  7334 b01a                                bcs l229_1                               ; if file not found (not open)    [910404]
 15336  7336 8c9011                              sty dossa_temp                           ; save secondary address
 15337                          
 15338  7339 8e8211                              stx dosfa                                ; set up device number for trans routine
 15339  733c a900                                lda #0
 15340  733e 8d8111                              sta dosla                                ; set up logical address for trans routine
 15341  7341 a96f                                lda #$6f
 15342  7343 8d8311                              sta dossa                                ; and secondary address, too!
 15343                          
 15344  7346 a055                                ldy #frec                                ; set pointer
 15345  7348 a904                                lda #4                                   ; process five bytes
 15346  734a 20f973                              jsr trans                                ; send command
 15347  734d 831fff                              +lbra print_dos_error                    ; if any
 15348                          
 15349  7350 a203               l229_1           ldx #errfno                              ; file not found err (file not open)   [910404]
 15350  7352 83fbba                              +lbra error
 15351                          
 15352                          ; .page
 15353                          ; DCLEAR - reinitilaize the drive
 15354                          
 15355  7355 201e74             dclear           jsr dospar                               ; parse the line
 15356  7358 a0ff                                ldy #finit                               ; set code
 15357  735a a902                                lda #2
 15358  735c 20f973                              jsr trans                                ; send command
 15359  735f 206e72                              jsr print_dos_error                      ; if any
 15360  7362 83ddfd                              +lbra dclall
 15361                          
 15362                          
 15363                          
 15364                          
 15365                          ; COLLECT v<drive#>
 15366                          
 15367  7365 201e74             collect          jsr dospar                               ; parse the line
 15368  7368 20ed77                              jsr chk3                                 ; check optional parameters
 15369  736b 20e7ff                              jsr _clall                               ; close all files
 15370  736e a033                                ldy #fcoll                               ; tabld offset
 15371  7370 a901                                lda #1                                   ; length
 15372  7372 4f7f01                              bbr4 parsts,l230_1
 15373  7375 1a                                  inc                                      ; include drive
 15374  7376 20f973             l230_1           jsr trans                                ; send command
 15375  7379 83f3fe                              +lbra print_dos_error                    ; if any
 15376                          
 15377                          
 15378                          ; .page
 15379                          ; COPY cdddfn=sdsfn
 15380                          
 15381  737c 201e74             dcopy            jsr dospar                               ; parse the line
 15382  737f 2930                                and #$30
 15383  7381 c930                                cmp #$30                                 ; check required parameters
 15384  7383 d024                                bne l231_1                               ; branch if single drive copy
 15385  7385 a57f                                lda parsts                               ; else check for dual drive params
 15386  7387 29c7                                and #$c7
 15387  7389 f023                                beq l231_2
 15388  738b 2903                                and #3                                   ; special check for 2nd filename   [910717]
 15389  738d c903                                cmp #3
 15390  738f f018                                beq l231_1                               ; branch if given
 15391  7391 a92a                                lda #'*'
 15392  7393 8d8d11                              sta dosdid                               ; else supply "*" for him, just like 'name2'
 15393  7396 a901                                lda #1
 15394  7398 a28d                                ldx #<dosdid
 15395  739a a011                                ldy #>dosdid
 15396  739c 8d8711                              sta dosf2l
 15397  739f 8e8911                              stx dosf2a
 15398  73a2 8c8a11                              sty dosf2a+1
 15399  73a5 a902                                lda #2                                   ; and set filename2 flag
 15400  73a7 047f                                tsb parsts                               ; set flag in status
 15401  73a9 a57f               l231_1           lda parsts
 15402  73ab 20f377                              jsr chk4
 15403                          ; lda parsts
 15404  73ae a039               l231_2           ldy #fcopy                               ; tabld offset
 15405  73b0 a908                                lda #8                                   ; length
 15406  73b2 20f973                              jsr trans                                ; send command
 15407  73b5 83b7fe                              +lbra print_dos_error                    ; if any
 15408                          
 15409                          
 15410                          
 15411                          ; CONCAT
 15412                          
 15413  73b8 201e74             concat           jsr dospar                               ; parse the line
 15414  73bb 20f377                              jsr chk4
 15415  73be a01f                                ldy #fconc                               ; offset
 15416  73c0 a90c                                lda #12                                  ; length
 15417  73c2 20f973                              jsr trans                                ; send command
 15418  73c5 83a7fe                              +lbra print_dos_error                    ; if any
 15419                          
 15420                          
 15421                          
 15422                          
 15423                          ; RENAME rdddfn=sdsfn
 15424                          
 15425  73c8 a9e4               rename           lda #$e4                                 ; set error flags
 15426  73ca 202074                              jsr dosprs                               ; parse the line
 15427  73cd 20fa77                              jsr chk5
 15428  73d0 a041                                ldy #fren                                ; offset
 15429  73d2 a908                                lda #8                                   ; length
 15430  73d4 20f973                              jsr trans                                ; send command
 15431  73d7 8395fe                              +lbra print_dos_error                    ; if any
 15432                          
 15433                          
 15434                          ; .page
 15435                          ; BACKUP D<destination_drive>=D<source_drive>
 15436                          ;
 15437                          ; where destination|source_drive is [0...9]
 15438                          
 15439  73da a9c7               backup           lda #$c7                                 ; set error flags
 15440  73dc 202074                              jsr dosprs                               ; parse the line
 15441  73df 2930                                and #$30                                 ; required parameters
 15442  73e1 c930                                cmp #$30
 15443  73e3 d365ba                              +lbne snerr
 15444  73e6 20c378                              jsr are_you_sure
 15445  73e9 f001                                beq l232_1                               ; if run mode or not 'yes'
 15446  73eb 60                                  rts
 15447                          
 15448  73ec 204171             l232_1           jsr dclall                               ; close disk
 15449  73ef a035                                ldy #fbak
 15450  73f1 a904                                lda #4                                   ; length
 15451  73f3 20f973                              jsr trans                                ; send command
 15452  73f6 8376fe                              +lbra print_dos_error                    ; if any
 15453                          
 15454                          
 15455                          ; .page
 15456                          ; Trans subroutine
 15457                          
 15458  73f9 20f276             trans            jsr sendp                                ; build string to output
 15459  73fc 20ccff                              jsr _clrch
 15460  73ff a200                                ldx #sys_bank                            ; name is in system space, bank0 ????  [910620]
 15461  7401 8a                                  txa
 15462  7402 206bff                              jsr _setbank
 15463  7405 20c0ff                              jsr _open                                ; send it...
 15464  7408 08                                  php                                      ; save error status (.c)
 15465  7409 48                                  pha                                      ; save error code (if any)
 15466  740a ad8111                              lda dosla
 15467  740d 38                                  sec
 15468  740e 20c3ff                              jsr _close                               ; special close...
 15469  7411 68                                  pla                                      ; pop error
 15470  7412 28                                  plp                                      ; pop error status
 15471  7413 b321f4                              +lbcs erexit                             ; ...branch if there was an error opening
 15472  7416 60                                  rts
 15473                          
 15474                          ;.end
 15475                          ; .page
 15476                          ; .subttl  DOS 2
 15477                          
 15478                          ; This is the DOS parser routine which looks at lines passed to it and
 15479                          ; verifies that the syntax is proper.  -mgm 7/23/79-
 15480                          ;
 15481                          ; Entry  (dosprs)
 15482                          ; a = parsts bit which must be zero.
 15483                          ;
 15484                          ; Exit  a = parsts as follows
 15485                          ;
 15486                          ;    ---------------------------------
 15487                          ;    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 15488                          ;    ---------------------------------
 15489                          ;      ^   ^   ^   ^   ^   ^   ^   ^
 15490                          ;      |   |   |   |   |   |   |   |_____ fn1 set for the first filename
 15491                          ;      |   |   |   |   |   |   |_______ fn2 set for second filename
 15492                          ;      |   |   |   |   |   |_________ la set when #lfn parsed
 15493                          ;      |   |   |   |   |___________ fa set for device number
 15494                          ;      |   |   |   |_____________ d1 set for first disk unit
 15495                          ;      |   |   |_______________ d2 set for second disk unit
 15496                          ;      |   |_________________ dosrcl set for record size
 15497                          ;      |___________________ @ set when @ encountered
 15498                          ;
 15499                          ; The following are the vaild bit patterns for parsts after parsing for the
 15500                          ; various keywords:
 15501                          ;
 15502                          ;       7 6 5 4  3 2 1 0
 15503                          ;
 15504                          ;     header  0 0 0 *  * 0 0 1
 15505                          ;     collect 0 0 0 *  * 0 0 0
 15506                          ;     dclear  0 0 0 *  * 0 0 0
 15507                          ;     backup  0 0 1 1  * 0 0 0
 15508                          ;     copy    0 0 1 1  * 0 0 0
 15509                          ;      or..   0 0 * *  * 0 1 1
 15510                          ;     concat  0 0 * *  * 0 1 1
 15511                          ;     bsave   * 0 0 *  * 0 0 1
 15512                          ;     dsave   * 0 0 *  * 0 0 1
 15513                          ;     bload   0 0 0 *  * 0 0 1
 15514                          ;     dload   0 0 0 *  * 0 0 1
 15515                          ;     dverify 0 0 0 *  * 0 0 1
 15516                          ;     catalog 0 0 0 *  * 0 0 *
 15517                          ;     rename  0 0 0 *  * 0 1 1
 15518                          ;     append  0 0 0 *  * 1 0 1
 15519                          ;     scratch 0 0 0 *  * 0 0 1
 15520                          ;     dopen   * * 0 *  * 1 0 1
 15521                          ;     dclose  0 0 0 0  * * 0 0
 15522                          ;             ^ ^ ^ ^  ^ ^ ^ ^
 15523                          ;             @ l d d  f l f f
 15524                          ;             r r 2 1  a a n n
 15525                          ;             p e          2 1
 15526                          ;             l l
 15527                          ;
 15528                          ;      "0" bits are required to be clear
 15529                          ;      "1" bits are required to be set
 15530                          ;      "*" bits are optional parameters
 15531                          ; .page
 15532                          ; Entry (dosprs):
 15533                          ;  parstx shall be set to prevent any auxiliary options to be specified.
 15534                          ;
 15535                          ; Entry (dosprx):
 15536                          ;  .x = parstx bits which must be zero.
 15537                          ;
 15538                          ; Exit:  .x = parstx as follows:
 15539                          ;
 15540                          ;     ---------------------------------
 15541                          ;     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 15542                          ;     ---------------------------------
 15543                          ;       ^   ^   ^   ^   ^   ^   ^   ^____ bnk is set for bank option
 15544                          ;       |   |   |   |   |   |   | ______ offl set for 1st address
 15545                          ;       |   |   |   |   |   |_________ offh set for 2nd address
 15546                          ;       |   |   |   |   |___________ unused
 15547                          ;       |   |   |   |_____________ unused
 15548                          ;       |   |   |_______________ unused
 15549                          ;       |   |_________________ unused
 15550                          ;       |___________________ unused
 15551                          ;
 15552                          ; The following are the valid bit patterns for parstx after parsing for the
 15553                          ; various keywords.  These options are allowed for load/save commands only.
 15554                          ;
 15555                          ;    7 6 5 4  3 2 1 0
 15556                          ;
 15557                          ;   bsave   0 0 0 0  0 1 1 *
 15558                          ;   bload   0 0 0 0  0 0 * *
 15559                          ;   bverify 0 0 0 0  0 0 * *
 15560                          ;   [auto]boot 0 0 0 0  0 0 * *
 15561                          ;    ^ ^ ^ ^  ^ ^ ^ ^
 15562                          ;    ? ? ? ?  ? o o b
 15563                          ;        f f n
 15564                          ;        h l k
 15565                          ;
 15566                          ;      "0" bits are required to be clear
 15567                          ;      "1" bits are required to be set
 15568                          ;      "*" bits are optional parameters
 15569                          
 15570  7417 ffffffff           dostbl           !word $ffff,$ffff                        ; default start/end address
 15571  741b 00086f                              !text doslfn,dosffn,$6f                  ; default la/fa/sa
 15572                          
 15573                          ; .page
 15574  741e a900               dospar           lda #0                                   ; DOS Parser
 15575                          
 15576                          dosprs                                                    ; special error flag entry
 15577  7420 a2ff                                ldx #$ff                                 ; no aux options!
 15578                          
 15579                          dosprx                                                    ; spec aux error flag entry
 15580  7422 48                                  pha                                      ; save error flags
 15581  7423 da                                  phx
 15582  7424 a900                                lda #0
 15583  7426 857f                                sta parsts                               ; reset parser status/option words
 15584  7428 8580                                sta parstx
 15585                          
 15586  742a a20d                                ldx #dosspc                              ; clear DOS scratch area   [900522]
 15587  742c 9d8311             l233_1           sta xcnt-1,x
 15588  742f ca                                  dex                                      ; no filenames, null lengths
 15589  7430 d0fa                                bne l233_1
 15590                          
 15591  7432 a206                                ldx #dossa-dosofl                        ; set some defaults from table
 15592  7434 bd1774             l233_2           lda dostbl,x
 15593  7437 9d7d11                              sta dosofl,x                             ; start/end adr = $FFFF, la/fa/sa
 15594  743a ca                                  dex
 15595  743b 10f7                                bpl l233_2
 15596                          
 15597  743d ae0611                              ldx _default_drive                       ; set default device   [900522]
 15598  7440 8e8211                              stx dosfa
 15599  7443 aed102                              ldx current_bank                         ; set current bank
 15600  7446 8e8c11                              stx dosbnk
 15601                          
 15602  7449 208522                              jsr chrgot                               ; get next character from command string
 15603  744c d00f                                bne parse1                               ; if eol stick with defaults, else begin parsing
 15604                          
 15605                          
 15606                          ; Done parsing, check for errors, return if everything okay
 15607                          
 15608  744e 68                 done             pla                                      ; get aux error flag
 15609  744f 2580                                and parstx                               ; repeated or illegal params?
 15610  7451 d3f7b9                              +lbne snerr                              ; yes- report syntax error
 15611  7454 68                                  pla                                      ; get error flags
 15612  7455 208c76                              jsr prmrpt
 15613  7458 a57f                                lda parsts
 15614  745a a680                                ldx parstx
 15615  745c 60                                  rts
 15616                          
 15617                          ; .page
 15618                          ; Parse given parameters.  what it is  example
 15619                          ;     -------------------- ---------
 15620  745d c922               parse1           cmp #'"'
 15621  745f f30201                              +lbeq name1                              ; explicit filename "file"
 15622  7462 c928                                cmp #'('
 15623  7464 f3fd00                              +lbeq name1                              ; evaluate filename (f$)
 15624  7467 c923                                cmp #'#'
 15625  7469 f039                                beq logadr                               ; logical file number #1
 15626  746b c955                                cmp #'U'
 15627  746d f029                                beq unit1                                ; unit number  U8
 15628  746f c944                                cmp #'D'
 15629  7471 f06d                                beq drv1                                 ; drive number  D0
 15630  7473 c950                                cmp #'P'
 15631  7475 f3b700                              +lbeq doffl                              ; load/save address P1234
 15632  7478 c942                                cmp #'B'
 15633  747a f022                                beq dbank1                               ; load/save bank   B0
 15634  747c c957                                cmp #'W'
 15635  747e f038                                beq reclen                               ; write mode  W
 15636  7480 c94c                                cmp #'L'
 15637  7482 f034                                beq reclen                               ; record length  L80
 15638  7484 c952                                cmp #'R'
 15639  7486 f3ce00                              +lbeq recover                            ; recover mode  R
 15640  7489 c949                                cmp #'I'
 15641  748b f06b                                beq ident                                ; ID   Ixx
 15642  748d c991                                cmp #on_token
 15643                          ; beq on1   ; ON token  ON
 15644                          
 15645  748f d3b9b9                              +lbne snerr                              ; none of these, syntax error
 15646                          
 15647                          ; .page
 15648  7492 20fe75             on1              jsr on
 15649  7495 83e400                              +lbra del1
 15650                          
 15651                          
 15652  7498 200a76             unit1            jsr unit                                 ; do unit# parsing
 15653  749b 83de00                              +lbra del1                               ; always
 15654                          
 15655                          
 15656  749e 202476             dbank1           jsr dbank
 15657  74a1 83d800                              +lbra del1                               ; always
 15658                          
 15659                          
 15660  74a4 a904               logadr           lda #4
 15661  74a6 208c76                              jsr prmrpt                               ; check for repeated parameter
 15662  74a9 20695d                              jsr gtbytc                               ; getval
 15663  74ac 8a                                  txa                                      ; cpx #0
 15664  74ad f34fdd                              +lbeq fcerr                              ; if illegal value
 15665  74b0 8e8111                              stx dosla
 15666  74b3 a904                                lda #4                                   ; set logical address flag
 15667  74b5 83c400                              +lbra del1                               ; get next parameter
 15668                          
 15669                          
 15670  74b8 aa                 reclen           tax                                      ; save char
 15671  74b9 a940                                lda #$40
 15672  74bb 208c76                              jsr prmrpt                               ; check for repeated parameter
 15673  74be e057                                cpx #'W'
 15674  74c0 d005                                bne l234_1
 15675  74c2 208322                              jsr chrget
 15676  74c5 8014                                bra l234_4                               ; set parsts
 15677                          
 15678  74c7 a201               l234_1           ldx #1                                   ; a kludge to allow  DOPEN#lf,"relfile",L  [911024]
 15679  74c9 208322                              jsr chrget
 15680  74cc f003                                beq l234_2                               ; eol? open existing rel file
 15681  74ce 206c5d                              jsr getbyt                               ; get reclen (was getval)
 15682  74d1 8e8b11             l234_2           stx dosrcl                               ; store parcel
 15683  74d4 8a                                  txa                                      ; cpx #0
 15684  74d5 f001                                beq l234_3                               ; zero illegal dosrcl
 15685  74d7 e8                                  inx                                      ; cpx #255
 15686  74d8 f324dd             l234_3           +lbeq fcerr                              ; illegal dosrcl
 15687                          
 15688  74db a940               l234_4           lda #$40                                 ; set dosrcl flag &
 15689  74dd 839c00                              +lbra del1
 15690                          
 15691                          
 15692  74e0 a910               drv1             lda #$10
 15693  74e2 208c76                              jsr prmrpt                               ; check for repeated parameter
 15694  74e5 20695d                              jsr gtbytc                               ; getval
 15695  74e8 e00a                                cpx #10
 15696  74ea b312dd                              +lbcs fcerr                              ; illegal drv# if >9 [allow 0: to 9: ?????]
 15697  74ed 8e8611                              stx dosds1
 15698  74f0 8e8811                              stx dosds2
 15699  74f3 a910                                lda #$10
 15700  74f5 838400                              +lbra del1
 15701                          
 15702                          
 15703  74f8 a980               ident            lda #$80                                 ; set ID flag
 15704  74fa 0c8f11                              tsb dosflags
 15705  74fd d34bb9                              +lbne snerr                              ; repeated parameter
 15706  7500 208322                              jsr chrget                               ; get next character
 15707  7503 c928                                cmp #'('                                 ; c65: allow I(ID$) syntax  [900710]
 15708  7505 d019                                bne l235_1
 15709  7507 20675b                              jsr frmstr                               ; get ID from var
 15710  750a c902                                cmp #2
 15711  750c 935c01                              +lbcc err_mfn                            ; if length < 2, error
 15712  750f a000                                ldy #0
 15713  7511 20d522                              jsr indin1_ram1                          ; else grab first two characters
 15714  7514 8d8d11                              sta dosdid
 15715  7517 c8                                  iny
 15716  7518 20d522                              jsr indin1_ram1
 15717  751b 8d8e11                              sta dosdid+1
 15718  751e 805d                                bra delim1                               ; continue
 15719                          
 15720  7520 8d8d11             l235_1           sta dosdid                               ; m(txtptr => dosdid
 15721  7523 208322                              jsr chrget
 15722  7526 8d8e11                              sta dosdid+1
 15723  7529 208322                              jsr chrget                               ; continue
 15724  752c 8052                                bra delim2
 15725                          
 15726                          
 15727  752e a902               doffl            lda #$02                                 ; check aux status
 15728  7530 209276                              jsr prxrpt
 15729  7533 207576                              jsr getoff                               ; get offset value
 15730  7536 8c7d11                              sty dosofl
 15731  7539 8d7e11                              sta dosofl+1
 15732  753c a902                                lda #$02
 15733  753e 0580               dlimx1           ora parstx                               ; set aux status bits
 15734  7540 8580                                sta parstx
 15735  7542 d039                                bne delim1                               ; try for next param
 15736                          
 15737                          
 15738  7544 a904               doffh            lda #$04
 15739  7546 209276                              jsr prxrpt
 15740  7549 207576                              jsr getoff
 15741  754c 8c7f11                              sty dosofh
 15742  754f 8d8011                              sta dosofh+1
 15743  7552 a904                                lda #$04
 15744  7554 80e8                                bra dlimx1                               ; set aux status
 15745                          
 15746                          
 15747  7556 a940               recover          lda #$40
 15748  7558 0c8f11                              tsb dosflags                             ; set 'recover' bit
 15749  755b d3edb8                              +lbne snerr                              ; if repeated parameter
 15750  755e 208322                              jsr chrget                               ; continue
 15751  7561 801d                                bra delim2
 15752                          
 15753                          
 15754  7563 a901               name1            lda #1                                   ; name1 allowed only once
 15755  7565 203676                              jsr newnam                               ; do name parsing
 15756  7568 8d8511                              sta dosf1l
 15757                          
 15758  756b a000                                ldy #0
 15759  756d 20d522             l236_1           jsr indin1_ram1
 15760  7570 999111                              sta savram,y                             ; copy name into buffer
 15761  7573 c8                                  iny
 15762  7574 cc8511                              cpy dosf1l
 15763  7577 90f4                                bcc l236_1                               ; ...copy all of it
 15764  7579 a901                                lda #1                                   ; set name1 flag
 15765                          
 15766                          
 15767  757b 047f               del1             tsb parsts
 15768                          
 15769  757d 208522             delim1           jsr chrgot
 15770  7580 d016               delim2           bne nxxx
 15771  7582 83cafe                              +lbra done                               ; <cr>/<> => done
 15772                          
 15773                          
 15774  7585 c991               next6            cmp #on_token
 15775  7587 f309ff                              +lbeq on1
 15776  758a c9a4                                cmp #to_token                            ; "to" token
 15777  758c d3bcb8                              +lbne snerr                              ; syntax error
 15778                          
 15779                          ;  If "to" is not followed by an offset param, then do file2 params.
 15780                          ;  Otherwise, do high offset and continue with file0 options.
 15781                          
 15782  758f 208322                              jsr chrget
 15783  7592 c950                                cmp #'P'
 15784  7594 d00f                                bne pars22
 15785  7596 f0ac                                beq doffh
 15786                          
 15787                          
 15788  7598 c92c               nxxx             cmp #','
 15789  759a d0e9                                bne next6
 15790  759c 208322                              jsr chrget
 15791  759f 83bcfe                              +lbra parse1
 15792                          
 15793                          
 15794  75a2 208322             parse2           jsr chrget
 15795  75a5 c944               pars22           cmp #'D'
 15796  75a7 f010                                beq l237_1
 15797  75a9 c991                                cmp #on_token                            ; "on" token
 15798  75ab f020                                beq on2
 15799  75ad c955                                cmp #'U'
 15800  75af f021                                beq unit2
 15801  75b1 c922                                cmp #'"'
 15802  75b3 f022                                beq name2
 15803  75b5 c928                                cmp #'('
 15804  75b7 f01e                                beq name2
 15805                          
 15806  75b9 a920               l237_1           lda #$20
 15807  75bb 208c76                              jsr prmrpt                               ; check for repeated parameter
 15808  75be 20695d                              jsr gtbytc                               ; getval
 15809  75c1 e00a                                cpx #10
 15810  75c3 b339dc                              +lbcs fcerr                              ; illegal drive #  [allow 0: to 9: ????]
 15811  75c6 8e8811                              stx dosds2
 15812  75c9 a920                                lda #$20
 15813  75cb 801a                                bra del2
 15814                          
 15815  75cd 20fe75             on2              jsr on
 15816  75d0 8015                                bra del2
 15817                          
 15818                          
 15819  75d2 200a76             unit2            jsr unit                                 ; do unit# parsing
 15820  75d5 8010                                bra del2                                 ; always
 15821                          
 15822  75d7 a902               name2            lda #2                                   ; name2 allowed only once
 15823  75d9 203676                              jsr newnam
 15824  75dc 8d8711                              sta dosf2l
 15825  75df 8e8911                              stx dosf2a
 15826  75e2 8c8a11                              sty dosf2a+1
 15827                          
 15828  75e5 a902                                lda #2                                   ; set filename2 flag &
 15829  75e7 047f               del2             tsb parsts                               ; set flag in status
 15830  75e9 208522                              jsr chrgot
 15831  75ec f360fe                              +lbeq done                               ; done on <cr>/<>
 15832  75ef c92c                                cmp #','
 15833  75f1 f0af                                beq parse2
 15834  75f3 c991                                cmp #on_token                            ; "on" token
 15835  75f5 f0d6                                beq on2
 15836  75f7 c955                                cmp #'U'
 15837  75f9 f0d7                                beq unit2
 15838  75fb 834db8                              +lbra snerr
 15839                          
 15840                          
 15841  75fe 208322             on               jsr chrget
 15842  7601 c942                                cmp #'B'
 15843  7603 f01f                                beq dbank
 15844  7605 c955                                cmp #'U'
 15845  7607 d341b8                              +lbne snerr
 15846                          
 15847                          
 15848  760a 20695d             unit             jsr gtbytc                               ; getval
 15849  760d e01f                                cpx #31
 15850  760f b05c                                bcs err_ild                              ; error if >30
 15851  7611 e001                                cpx #1                                   ; drive 1 = use system default drive  [910221]
 15852  7613 d005                                bne l238_1
 15853  7615 ae0611                              ldx _default_drive
 15854  7618 8004                                bra l238_2
 15855  761a e004               l238_1           cpx #4
 15856  761c 904f                                bcc err_ild                              ; error if <4
 15857  761e 8e8211             l238_2           stx dosfa
 15858  7621 a908                                lda #$08                                 ; set parser's unit flag
 15859  7623 60                                  rts
 15860                          
 15861                          
 15862  7624 a901               dbank            lda #$01                                 ; repeated param?
 15863  7626 209276                              jsr prxrpt
 15864  7629 20695d                              jsr gtbytc                               ; getval
 15865                          ; cpx #16  ;bank too large?
 15866                          ; bcs fcerr ;illegal qty
 15867  762c 8e8c11                              stx dosbnk
 15868  762f a901                                lda #$01
 15869  7631 0480                                tsb parstx                               ; set bnk bit in aux status
 15870  7633 a900                                lda #0                                   ; .a=std status wrd, no bits to set
 15871  7635 60                                  rts
 15872                          
 15873                          
 15874                          newnam
 15875  7636 48                                  pha                                      ; save nam1,2 for subdir check later  [901115]
 15876  7637 208c76                              jsr prmrpt                               ; check for repeated parameter
 15877  763a 20675b                              jsr frmstr
 15878  763d aa                                  tax                                      ; save length of string
 15879  763e f02a                                beq err_mfn                              ; if length = 0
 15880  7640 a000                                ldy #0
 15881  7642 20d522                              jsr indin1_ram1
 15882  7645 c940                                cmp #'@'                                 ; Replace file convention?
 15883  7647 d00c                                bne l239_1                               ; no
 15884  7649 a980                                lda #$80                                 ; yes- check for repeated param
 15885  764b 208c76                              jsr prmrpt
 15886  764e f77f                                smb7 parsts                              ; set "@" flag
 15887  7650 ca                                  dex                                      ; decrement length
 15888  7651 e324                                inw index1                               ; increment past "@"
 15889  7653 800c                                bra lenchk
 15890                          
 15891  7655 c92f               l239_1           cmp #'/'                                 ; Subdirectory (partition)?   [901115]
 15892  7657 d008                                bne lenchk                               ; no
 15893  7659 68                                  pla                                      ; yes- recall nam1 or nam2
 15894  765a 0c8f11                              tsb dosflags                             ; set appropriate '/' flag (.a=1 or 2)
 15895  765d ca                                  dex                                      ; decrement length
 15896  765e e324                                inw index1                               ; increment past "@"
 15897  7660 89                                  !text $89
 15898                          
 15899                          
 15900  7661 68                 lenchk           pla                                      ; [901115]
 15901  7662 8a                                  txa                                      ; Check filename length
 15902  7663 f005                                beq err_mfn                              ; too small, missing filename  [901115]
 15903                          ; cmp #17  ;  ???? (problem if name has ',P')
 15904                          ; bcs errlen ; too long
 15905  7665 a624                                ldx index1
 15906  7667 a425                                ldy index1+1                             ; ok- return pointer to filename
 15907  7669 60                                  rts
 15908                          
 15909                          
 15910  766a a208               err_mfn          ldx #err_missing_fname
 15911  766c 2c                                  !text $2c
 15912                          
 15913  766d a209               err_ild          ldx #err_illegal_device
 15914  766f 2c                                  !text $2c
 15915                          
 15916  7670 a217               errlen           ldx #errls                               ; string or filename too long
 15917  7672 83dbb7                              +lbra error
 15918                          
 15919                          
 15920                          
 15921                          ; Get next value routine (use gtbytc instead!)
 15922                          
 15923                          ;getval jsr chrget ;get nxt chr
 15924                          ; beq snerr ;if end of statement
 15925                          ; bra getbyt ;       [911024]
 15926                          
 15927                          ; bcc getbyt ;can be numeric, go evaluate it  why this crap ????
 15928                          ; jsr chkopn ;or a "("
 15929                          ; jsr getbyt ;anything else is an error
 15930                          ; bra chkcls ;need closing ")"
 15931                          
 15932                          
 15933                          
 15934                          ; Get next 2-byte expression.  Exit: .a,.y (high,low) value
 15935                          
 15936  7675 208322             getoff           jsr chrget                               ; get nxt chr
 15937  7678 f3d0b7                              +lbeq snerr                              ; if end of statement
 15938  767b 930de7                              +lbcc getwrd                             ; can be num. const, go evaluate it
 15939  767e 20584e                              jsr chkopn                               ; or a "("
 15940  7681 208a5d                              jsr getwrd                               ; expr
 15941  7684 20554e                              jsr chkcls                               ; need closing ")"
 15942  7687 a416                                ldy poker
 15943  7689 a517                                lda poker+1
 15944  768b 60                                  rts
 15945                          
 15946                          
 15947                          
 15948                          ; Prmrpt checks for a repeated parameter.
 15949                          ;
 15950                          ; Entry: .a contains parsts flag to check
 15951                          
 15952                          
 15953  768c 257f               prmrpt           and parsts                               ; compare mask with status
 15954  768e d3bab7                              +lbne snerr                              ; error if bit previously set
 15955  7691 60                                  rts
 15956                          
 15957                          
 15958                          
 15959                          ; Prxrpt checks for a repeated parameter.
 15960                          ;
 15961                          ; Entry: .a contains parstx flag to check
 15962                          
 15963                          
 15964  7692 2580               prxrpt           and parstx                               ; and with parstx
 15965  7694 d3b4b7                              +lbne snerr                              ; if bit previously set
 15966  7697 60                                  rts
 15967                          
 15968                          ;.end
 15969                          ; .page
 15970                          ; .subttl  DOS 3
 15971                          
 15972                          ; CBM-2001 BASIC-4 disk verb processors.  -- rsr 7-24-79 --
 15973                          ;
 15974                          ; Token Table Definitions
 15975                          
 15976                          xsca             =$c2                                     ; send dossca
 15977                          xid              =$d0                                     ; sends disk id
 15978                          xd1              =$d1                                     ; sends dosds1
 15979                          xd2              =$d2                                     ; sends dosds2
 15980                          xrec             =$e0                                     ; sends S for SEQ, or dosrcl
 15981                          xwrt             =$e1                                     ; sends W or L
 15982                          xrcl             =$e2                                     ; send low ((poker))
 15983                          xfat             =$f0                                     ; sends "@" or "/" if specified
 15984                          xfn1             =$f1                                     ; sends filename1
 15985                          xfn2             =$f2                                     ; sends filename2
 15986                          
 15987                          
 15988                          ; Tabld - used to build disk command strings
 15989                          
 15990                          tabld
 15991                          finit            = $ff                                    ; Dclear
 15992  7698 49d1                                !text "I",xd1
 15993                          
 15994                          fdir             = *-tabld-1                              ; Dir
 15995  769a 24d13af1                            !text "$",xd1,":",xfn1
 15996                          
 15997                          fdirr            = *-tabld-1                              ; Recover Dir  [901024]
 15998  769e 5fd13af1                            !text "_",xd1,":",xfn1                   ; ('_'=CBM backarrow, $5F)
 15999                          
 16000                          fopn             = *-tabld-1                              ; Dopen
 16001  76a2 f0d13af12ce12ce0                    !text xfat,xd1,":",xfn1,",",xwrt,",",xrec
 16002                          
 16003                          fopnseq          = *-tabld-1                              ; Type   [900801]
 16004  76aa f0d13af12c53                        !text xfat,xd1,":",xfn1,",S"
 16005                          
 16006                          fsavseq          = *-tabld-1                              ; EDIT_SAVE  [910620]
 16007  76b0 f0d13af12c532c57                    !text xfat,xd1,":",xfn1,",S,W"
 16008                          
 16009                          fconc            = *-tabld-1                              ; Concat
 16010  76b8 43d23af23dd23af2...                 !text "C",xd2,":",xfn2,"=",xd2,":",xfn2,","
 16011                          
 16012                          fapn             = *-tabld-1                              ; Append
 16013  76c1 d13af12c41                          !text xd1,":",xfn1,",A"
 16014                          
 16015                          fhed             = *-tabld-1                              ; Header
 16016  76c6 4ed13af12cd0                        !text "N",xd1,":",xfn1,",",xid
 16017                          
 16018                          fcoll            = *-tabld-1                              ; Collect
 16019  76cc 56d1                                !text "V",xd1
 16020                          
 16021                          fbak             = *-tabld-1                              ; Backup
 16022  76ce 44d23dd1                            !text "D",xd2,"=",xd1
 16023                          
 16024                          fcopy            = *-tabld-1                              ; Copy
 16025  76d2 43d23af23dd13af1                    !text "C",xd2,":",xfn2,"=",xd1,":",xfn1
 16026                          
 16027                          fren             = *-tabld-1                              ; Rename
 16028  76da 52d13af23dd13af1                    !text "R",xd1,":",xfn2,"=",xd1,":",xfn1
 16029                          
 16030                          fscr             = *-tabld-1                              ; Scratch
 16031  76e2 53d13af1                            !text "S",xd1,":",xfn1
 16032                          
 16033                          frscr            = *-tabld-1                              ; Recover Del  [901024]
 16034  76e6 462d52d13af1                        !text "F-R",xd1,":",xfn1
 16035                          
 16036                          fdisk            = *-tabld-1                              ; Disk command  [910123]
 16037  76ec f0f1                                !text xfat,xfn1                          ; pass '/' [911030]
 16038                          
 16039                          frec             = *-tabld-1                              ; Record
 16040  76ee 50c2e2e0                            !text "P",xsca,xrcl,xrec
 16041                          
 16042                          ; .page
 16043                          ; Send parameters to device
 16044                          ;
 16045                          ; Entry: .a = number of bytes in format
 16046                          ;  .y = pointer to TABLD entry
 16047                          
 16048  76f2 8d8411             sendp            sta xcnt                                 ; save number of string bytes
 16049  76f5 5a                                  phy
 16050  76f6 208278                              jsr Clear_DS                             ; clear old status
 16051                          
 16052  76f9 a200                                ldx #0
 16053  76fb 68                 sdp1             pla
 16054  76fc ce8411                              dec xcnt
 16055  76ff 304d                                bmi tranr
 16056  7701 a8                                  tay
 16057  7702 c8                                  iny                                      ; move down table
 16058  7703 5a                                  phy
 16059  7704 b99876                              lda tabld,y                              ; get next entry
 16060  7707 103f                                bpl sdp5                                 ; if not escape code
 16061  7709 c9c2                                cmp #xsca                                ; if not secondary address
 16062  770b f058                                beq rsca
 16063  770d c9d0                                cmp #xid
 16064  770f f06a                                beq rid                                  ; if disk id
 16065  7711 c9e2                                cmp #xrcl
 16066  7713 f38400                              +lbeq rdcn                               ; if record number
 16067  7716 c9e1                                cmp #xwrt
 16068  7718 f06d                                beq rwrt                                 ; if W or L
 16069  771a c9f0                                cmp #xfat
 16070  771c f04c                                beq rfat                                 ; if "@" symbol request
 16071  771e c9f1                                cmp #xfn1
 16072  7720 f38100                              +lbeq rsfn                               ; if filename 1
 16073  7723 c9f2                                cmp #xfn2
 16074  7725 f39200                              +lbeq rdfn                               ; if filename 2
 16075  7728 c9e0                                cmp #xrec
 16076  772a d00a                                bne sdp2                                 ; if not record type
 16077  772c ad8b11                              lda dosrcl                               ; get rec #
 16078  772f c901                                cmp #1                                   ; kludge to allow DOPEN#lf,"relfile",L  [911024]
 16079  7731 d015                                bne sdp5                                 ; (note RECORD byte 0 = byte 1 anyhow)
 16080  7733 3a                                  dec
 16081  7734 8012                                bra sdp5                                 ; always branch
 16082                          
 16083  7736 c9d1               sdp2             cmp #xd1
 16084  7738 d005                                bne sdp3                                 ; if not drive 1
 16085  773a ad8611                              lda dosds1
 16086  773d 8007                                bra sdp4                                 ; always branch
 16087                          
 16088  773f c9d2               sdp3             cmp #xd2
 16089  7741 d0b8                                bne sdp1                                 ; if not drive 2, continue
 16090  7743 ad8811                              lda dosds2
 16091  7746 0930               sdp4             ora #'0'                                 ; change # to PETSCII
 16092                          
 16093  7748 9d0013             sdp5             sta dosstr,x                             ; else into buffer
 16094  774b e8                                  inx
 16095  774c 80ad                                bra sdp1                                 ; always
 16096                          
 16097                          
 16098  774e 8a                 tranr            txa                                      ; length to a
 16099  774f 48                                  pha
 16100  7750 a200                                ldx #<dosstr                             ; set filename
 16101  7752 a013                                ldy #>dosstr
 16102  7754 20bdff                              jsr _setnam
 16103                          
 16104  7757 ad8111                              lda dosla                                ; set channel
 16105  775a ae8211                              ldx dosfa
 16106  775d ac8311                              ldy dossa
 16107  7760 20baff                              jsr _setlfs
 16108                          
 16109  7763 68                                  pla
 16110  7764 60                                  rts
 16111                          
 16112                          
 16113                          
 16114                          
 16115  7765 ad9011             rsca             lda dossa_temp                           ; secondary address (record)
 16116  7768 80de                                bra sdp5                                 ; always
 16117                          
 16118                          
 16119  776a 7f7f04             rfat             bbr7 parsts,l240_1                       ; if "@" not encountered
 16120  776d a940                                lda #'@'
 16121  776f 80d7                                bra sdp5                                 ; always
 16122                          
 16123  7771 ad8f11             l240_1           lda dosflags
 16124  7774 4a                                  lsr
 16125  7775 9084                                bcc sdp1                                 ; if "/" not encountered
 16126  7777 a92f                                lda #'/'
 16127  7779 80cd                                bra sdp5
 16128                          
 16129                          
 16130                          ; ID subroutine
 16131                          
 16132  777b ad8d11             rid              lda dosdid                               ; include id
 16133  777e 9d0013                              sta dosstr,x
 16134  7781 e8                                  inx
 16135  7782 ad8e11                              lda dosdid+1
 16136  7785 80c1                                bra sdp5                                 ; always
 16137                          
 16138                          
 16139  7787 ad8b11             rwrt             lda dosrcl                               ; check for L or W
 16140  778a f004                                beq l241_1                               ; zero then write
 16141  778c a94c                                lda #'L'
 16142  778e 80b8                                bra sdp5                                 ; always
 16143                          
 16144  7790 a953               l241_1           lda #'S'                                 ; send W,S
 16145  7792 8d8b11                              sta dosrcl
 16146  7795 a957                                lda #'W'
 16147  7797 80af                                bra sdp5                                 ; always
 16148                          
 16149                          
 16150                          
 16151                          ; Move record number
 16152                          
 16153  7799 a516               rdcn             lda poker
 16154  779b 9d0013                              sta dosstr,x
 16155  779e a517                                lda poker+1
 16156  77a0 e8                                  inx
 16157  77a1 80a5                                bra sdp5                                 ; always
 16158                          
 16159                          
 16160                          ; Move file names
 16161                          
 16162  77a3 ac8511             rsfn             ldy dosf1l                               ; file name 1: get length
 16163  77a6 f030                                beq rdrt0                                ; if null string
 16164                          
 16165  77a8 a000                                ldy #0                                   ; move name to dosstr
 16166  77aa b99111             l242_1           lda savram,y
 16167  77ad 9d0013                              sta dosstr,x
 16168  77b0 e8                                  inx
 16169  77b1 c8                                  iny
 16170  77b2 cc8511                              cpy dosf1l
 16171  77b5 d0f3                                bne l242_1                               ; if move not complete
 16172  77b7 8020                                bra rdrt1                                ; always
 16173                          
 16174                          
 16175  77b9 ad8911             rdfn             lda dosf2a
 16176  77bc 8524                                sta index1
 16177  77be ad8a11                              lda dosf2a+1
 16178  77c1 8525                                sta index1+1
 16179  77c3 ac8711                              ldy dosf2l
 16180  77c6 f010                                beq rdrt0                                ; if null string
 16181                          
 16182  77c8 a000                                ldy #0                                   ; move name to dosstr
 16183  77ca 20d522             l243_1           jsr indin1_ram1
 16184  77cd 9d0013                              sta dosstr,x
 16185  77d0 e8                                  inx
 16186  77d1 c8                                  iny
 16187  77d2 cc8711                              cpy dosf2l
 16188  77d5 d0f3                                bne l243_1                               ; if move not complete
 16189  77d7 89                                  !text $89                                ; hop
 16190                          
 16191  77d8 ca                 rdrt0            dex                                      ; case cdd=sd
 16192  77d9 8320ff             rdrt1            +lbra sdp1                               ; get next symbol
 16193                          
 16194                          ; .page
 16195                          ; Syntax checker DOS write
 16196                          
 16197  77dc 29e6               chk1             and #$e6                                 ; for HEADER, DLOAD, SCRATCH, TYPE, LIST
 16198  77de d36ab6                              +lbne snerr
 16199                          
 16200  77e1 a57f               chk2             lda parsts                               ; for DSAVE
 16201  77e3 2901                                and #1
 16202  77e5 c901                                cmp #1                                   ; check required parameters
 16203  77e7 d361b6                              +lbne snerr                              ; error if 1 missing
 16204  77ea a57f                                lda parsts                               ; reload for return
 16205  77ec 60                                  rts
 16206                          
 16207                          
 16208  77ed 29e7               chk3             and #$e7                                 ; for COLLECT
 16209  77ef d359b6                              +lbne snerr                              ; check optional parameters
 16210  77f2 60                                  rts
 16211                          
 16212                          
 16213  77f3 29c4               chk4             and #$c4                                 ; for COPY, CONCAT
 16214  77f5 d353b6                              +lbne snerr                              ; check optional parameters
 16215  77f8 a57f                                lda parsts
 16216  77fa 2903               chk5             and #3                                   ; for RENAME
 16217  77fc c903                                cmp #3                                   ; check required parameters
 16218  77fe d34ab6                              +lbne snerr
 16219  7801 a57f                                lda parsts                               ; reload for return
 16220  7803 60                                  rts
 16221                          
 16222                          
 16223  7804 2905               chk6             and #5                                   ; for APPEND, DOPEN
 16224  7806 c905                                cmp #5                                   ; check required parameters
 16225  7808 d340b6                              +lbne snerr
 16226  780b a57f                                lda parsts                               ; reload for rts
 16227  780d 60                                  rts
 16228                          
 16229                          ;.end
 16230                          ; .page
 16231                          ; .subttl  DOS 4
 16232                          
 16233                          ; Allocate DS$ if nesessary, but use old DS$ string otherwise
 16234                          ; Called by DS$ and DS
 16235                          
 16236                          Check_DS                                                  ; chkds.
 16237  780e a579                                lda dsdesc
 16238  7810 f005                                beq Read_DS_1                            ; branch if DS$ is not in memory
 16239  7812 60                                  rts                                      ; else return & use old one
 16240                          
 16241                          
 16242                          ; Allocate DS$ if necessary & Read DOS error channel
 16243                          
 16244                          Read_DS                                                   ; errchl.
 16245  7813 a579                                lda dsdesc                               ; has DS$ space been allocated?
 16246  7815 d01a                                bne Read_DS_2                            ; yes
 16247                          
 16248                          Read_DS_1
 16249  7817 a928                                lda #40                                  ; no- get 40 char string
 16250  7819 8579                                sta dsdesc
 16251  781b 20dd5b                              jsr getspa                               ; allocate space for DS$
 16252  781e 867a                                stx dsdesc+1                             ; low address of string
 16253  7820 847b                                sty dsdesc+2                             ; high   "    "    "
 16254  7822 a27a                                ldx #dsdesc+1                            ; set up string back pointer to dsdesc
 16255  7824 a028                                ldy #40
 16256  7826 a979                                lda #<dsdesc
 16257  7828 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y
 16258  782b c8                                  iny
 16259  782c a900                                lda #>dsdesc
 16260  782e 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y
 16261                          
 16262                          Read_DS_2
 16263  7831 ae8211                              ldx dosfa                                ; fa
 16264  7834 e002                                cpx #2
 16265  7836 b006                                bcs l244_1                               ; if =0 or 1 use default  [910429]
 16266  7838 ae0611                              ldx _default_drive                       ; (was dosffn)   [900710]
 16267  783b 8e8211                              stx dosfa
 16268  783e a900               l244_1           lda #doslfn                              ; la (reserved la)
 16269  7840 a06f                                ldy #$6f                                 ; sa (command channel)
 16270  7842 20baff                              jsr _setlfs
 16271  7845 a900                                lda #0                                   ; no name (so no setbank)
 16272  7847 20bdff                              jsr _setnam
 16273  784a 20c0ff                              jsr _open                                ; get command channel
 16274  784d a200                                ldx #doslfn
 16275  784f 20c6ff                              jsr _chkin
 16276  7852 b023                                bcs l244_4                               ; a problem (file already open??)
 16277                          
 16278  7854 a0ff                                ldy #$ff
 16279  7856 c8                 l244_2           iny                                      ; read disk error message
 16280  7857 20cfff                              jsr _basin
 16281  785a c90d                                cmp #cr
 16282  785c f009                                beq l244_3                               ; if eol
 16283  785e a27a                                ldx #dsdesc+1
 16284  7860 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y copy to DS$
 16285  7863 c028                                cpy #40
 16286  7865 90ef                                bcc l244_2                               ; loop unless too long
 16287                          
 16288  7867 a900               l244_3           lda #0                                   ; errend.
 16289  7869 a27a                                ldx #dsdesc+1                            ; terminate DS$ with a null
 16290  786b 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y
 16291                          
 16292  786e 20ccff                              jsr _clrch                               ; shut down command channel
 16293  7871 a900                                lda #doslfn
 16294  7873 38                                  sec                                      ; not a real close
 16295  7874 4cc3ff                              jmp _close                               ; close it and rts
 16296                          
 16297  7877 48                 l244_4           pha                                      ; errbad.
 16298  7878 206778                              jsr l244_3
 16299  787b 208278                              jsr Clear_DS                             ; flag 'no DS available'
 16300  787e fa                                  plx                                      ; get error
 16301  787f 83ceb5                              +lbra error
 16302                          
 16303                          ; .page
 16304                          ; Clear_DS subroutine - forget current DS$ message, if any
 16305                          ;
 16306                          
 16307                          Clear_DS                                                  ; oldclr.
 16308  7882 a579                                lda dsdesc                               ; check for allocation
 16309  7884 f013                                beq l245_1                               ; branch if not allocated
 16310                          
 16311  7886 5a                                  phy                                      ; mark current DS$ string as garbage
 16312  7887 da                                  phx
 16313                          ; lda #40   ;   standard DS$ allocation
 16314  7888 a8                                  tay
 16315  7889 a27a                                ldx #dsdesc+1
 16316  788b 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y length of garbage
 16317  788e c8                                  iny
 16318  788f a9ff                                lda #$ff
 16319  7891 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y garbage flagged
 16320  7894 1a                                  inc
 16321  7895 8579                                sta dsdesc                               ; (0)    kill DS$
 16322  7897 fa                                  plx
 16323  7898 7a                                  ply
 16324                          
 16325  7899 60                 l245_1           rts
 16326                          
 16327                          ; .page
 16328                          ; Read DOS error message, but don't care what it is.  Want to stop disk LED blink.
 16329                          ;
 16330                          
 16331                          Suck_DS
 16332  789a ae8211                              ldx dosfa                                ; fa
 16333  789d a900                                lda #doslfn                              ; la (reserved la)
 16334  789f a06f                                ldy #$6f                                 ; sa (command channel)
 16335  78a1 20baff                              jsr _setlfs
 16336  78a4 a900                                lda #0                                   ; no name (so no setbank)
 16337  78a6 20bdff                              jsr _setnam
 16338  78a9 20c0ff                              jsr _open                                ; get command channel
 16339  78ac a200                                ldx #doslfn
 16340  78ae 20c6ff                              jsr _chkin
 16341  78b1 b007                                bcs l246_2                               ; skip input if problem
 16342                          
 16343  78b3 20cfff             l246_1           jsr _basin                               ; read disk error message
 16344  78b6 c90d                                cmp #cr
 16345  78b8 d0f9                                bne l246_1                               ; loop until eol
 16346                          
 16347  78ba 20ccff             l246_2           jsr _clrch                               ; shut down command channel
 16348  78bd a900                                lda #doslfn
 16349  78bf 38                                  sec                                      ; not a real close
 16350  78c0 4cc3ff                              jmp _close                               ; close it
 16351                          
 16352                          ; .page
 16353                          ; R-U-sure subroutine
 16354                          
 16355                          are_you_sure
 16356                          
 16357  78c3 ff7e29                              bbs7 runmod,response_fake                ; branch if not direct mode
 16358                          
 16359  78c6 207dff                              jsr _primm                               ; else prompt user for y/n answer
 16360  78c9 41524520594f5520...                 !text "ARE YOU SURE? ", 0
 16361                          
 16362                          
 16363                          response_get
 16364  78d8 20ccff                              jsr _clrch                               ; clear channel for basin
 16365  78db 20cfff                              jsr _basin                               ; next char
 16366  78de 48                                  pha                                      ; save first char of reply
 16367                          
 16368  78df c90d               l247_1           cmp #cr                                  ; eat chars until end of line
 16369  78e1 f005                                beq l247_2                               ; if cr received, exit
 16370  78e3 20cfff                              jsr _basin
 16371  78e6 d0f7                                bne l247_1                               ; continue to ignore
 16372                          
 16373  78e8 20d2ff             l247_2           jsr _bsout                               ; new line     [910212] FAB
 16374  78eb 68                                  pla
 16375  78ec c959                                cmp #'Y'                                 ; z set means ans=y.....
 16376  78ee 60                                  rts
 16377                          
 16378                          
 16379                          response_fake
 16380  78ef a900                                lda #0                                   ; ...or not in direct mode
 16381  78f1 60                                  rts
 16382                          
 16383                          ;.end
 16384                          ; .page
 16385                          ; .subttl  General Purpose Subroutines
 16386                          
 16387                          ;*****************************************************************
 16388                          ;  OPTWRD - get an optional, unsigned 2-byte value in y,a.
 16389                          ;
 16390                          ;      case 1 : pointer at end of line:
 16391                          ;   return a=y=0, clear c to flag 'default'
 16392                          ;      case 2 : pointer is at comma, next non-blank is also a comma:
 16393                          ;   return a=y=0, clear c to flag 'default'
 16394                          ;      case 3 : pointer is at comma, next non-blank is not a comma:
 16395                          ;   get word in y,a, set c to flag 'non-default'
 16396                          ;*****************************************************************
 16397                          
 16398  78f2 208522             optwrd           jsr chrgot
 16399  78f5 f00c                                beq l248_1
 16400  78f7 205b4e                              jsr chkcom
 16401  78fa c92c                                cmp #','
 16402  78fc f005                                beq l248_1
 16403  78fe 208a5d                              jsr getwrd
 16404  7901 38                                  sec
 16405  7902 60                                  rts
 16406                          
 16407  7903 a900               l248_1           lda #0
 16408  7905 a8                                  tay
 16409                          
 16410  7906 18                 optw99           clc
 16411  7907 60                                  rts
 16412                          
 16413                          ; .page
 16414  7908 205b4e             comsad           jsr chkcom                               ; get a comma & signed 2-byte arg in y,a   [910307]
 16415  790b 83d83e                              +lbra sadwrd
 16416                          
 16417                          
 16418                          
 16419  790e 208522             optsad           jsr chrgot                               ; get a comma & optional, signed 2-byte arg in y,a [910307]
 16420  7911 f00c                                beq l249_1                               ; eol, therefore this arg is not specified
 16421  7913 205b4e                              jsr chkcom                               ; eat comma
 16422  7916 c92c                                cmp #','                                 ; is next a comma too?
 16423  7918 f005                                beq l249_1                               ; yes, therefore this arg is not specified
 16424  791a 20e5b7                              jsr sadwrd                               ; get signed word
 16425  791d 38                                  sec
 16426  791e 60                                  rts
 16427                          
 16428  791f a900               l249_1           lda #0                                   ; default optional arg to zero
 16429  7921 a8                                  tay
 16430  7922 18                                  clc
 16431  7923 60                                  rts
 16432                          
 16433                          ; .page
 16434                          ;*****************************************************************
 16435                          ;  OPTBYT - get an optional 1 byte value in x.
 16436                          ;
 16437                          ;  Enter with default value in x.
 16438                          ;
 16439                          ;      case 1 : pointer at end of line:
 16440                          ;   return default x.
 16441                          ;      case 2 : pointer is at comma, next non-blank is also a comma:
 16442                          ;   return default x.
 16443                          ;      case 3 : pointer is at comma, next non-blank is not a comma:
 16444                          ;   get byte in x.
 16445                          ;*****************************************************************
 16446                          
 16447  7924 a200               optzer           ldx #0                                   ; optional byte, with default=0
 16448                          
 16449  7926 208522             optbyt           jsr chrgot
 16450  7929 f0db                                beq optw99                               ; EOL: clc/rts
 16451  792b 205b4e                              jsr chkcom
 16452  792e c92c                                cmp #','
 16453  7930 f0d4                                beq optw99                               ; Comma: clc/rts
 16454  7932 206c5d                              jsr getbyt
 16455  7935 38                                  sec
 16456  7936 60                                  rts
 16457                          
 16458                          ; .page
 16459                          prtdec
 16460  7937 5a                                  phy
 16461  7938 da                                  phx
 16462  7939 aa                                  tax                                      ; prints decimal value of chr in .a
 16463  793a a900                                lda #0
 16464  793c 207f64                              jsr linprt
 16465  793f fa                                  plx
 16466  7940 7a                                  ply
 16467  7941 60                                  rts
 16468                          
 16469                          
 16470                          
 16471                          retpat                                                    ; f.bowen
 16472  7942 88                                  dey                                      ; [910828]
 16473  7943 b13f                                lda (fndpnt),y                           ; restore pointers
 16474  7945 853e                                sta txtptr+1
 16475  7947 88                                  dey
 16476  7948 b13f                                lda (fndpnt),y
 16477  794a 853d                                sta txtptr
 16478  794c 88                                  dey
 16479  794d b13f                                lda (fndpnt),y
 16480                          
 16481  794f 853c                                sta curlin+1                             ; fixes a problem when RETURNing to a GOSUB in direct mode
 16482  7951 88                                  dey                                      ; or LOOPing to a DO in direct mode. 'curlin+1' must not be
 16483  7952 aa                                  tax                                      ; restored to $ff without also resetting 'runmod'
 16484  7953 e8                                  inx
 16485  7954 d004                                bne l250_1                               ; branch if GOSUB or DO was from a program
 16486  7956 a9c0                                lda #%11000000
 16487  7958 147e                                trb runmod                               ; else force return to direct mode
 16488                          
 16489  795a b13f               l250_1           lda (fndpnt),y
 16490  795c 853b                                sta curlin
 16491  795e 60                                  rts
 16492                          
 16493                          
 16494  795f 010204010204       vbits            !text $01,$02,$04,$01,$02,$04            ; for stereo filter, volume bit setting
 16495  7965 0102040810204080   sbits            !text $01,$02,$04,$08,$10,$20,$40,$80
 16496  796d 8040201008040201   rbits            !text $80,$40,$20,$10,$08,$04,$02,$01
 16497                          
 16498                          ;.end
 16499                          ; .page
 16500                          ; .subttl BASIC IRQ Handler
 16501                          
 16502                          basic_irq
 16503                          ; lda _vicIRQ  ;a VIC raster interrupt?
 16504                          ; and #%10000001  ; (used to update moving sprites & sound stuff)
 16505                          ; cmp #%10000001
 16506                          ; bne collision_irq ; no, go check other VIC interrupts
 16507                          
 16508  7975 addb02                              lda irq_wrap_flag                        ; filter out wrapped IRQ calls (allows interruptable code)
 16509  7978 f001                                beq l251_1                               ; it's ok
 16510  797a 60                                  rts                                      ; exit- we're already handling one interrupt
 16511                          
 16512  797b eedb02             l251_1           inc irq_wrap_flag                        ; shut the door
 16513  797e 58                                  cli                                      ; but leave the window open
 16514                          
 16515                          ; .page
 16516                          ; Test if there was a VIC collision/light pen interrupt
 16517                          
 16518                          collision_irq
 16519                          ; sei
 16520  797f a5a0                                lda _vicIRQ                              ; check VIC IRQ flags
 16521  7981 290e                                and #%00001110                           ; mask all but lp, s/s, and s/bgnd flags
 16522  7983 f04c                                beq l252_5                               ; exit if none set
 16523  7985 14a0                                trb _vicIRQ                              ; else reset flags we're going to handle
 16524  7987 4a                                  lsr                                      ; shift out raster interrupt bit (not used)
 16525                          
 16526                          ; Test for 3 types of collision interrupts : sprite/sprite, sprite/bgnd, & light pen
 16527                          
 16528  7988 a001                                ldy #1                                   ; loop for sprite/bgnd and sprite/sprite collision check
 16529  798a 4a                 l252_1           lsr
 16530  798b 901b                                bcc l252_4                               ; bit not set ==> not source of interrupt
 16531                          
 16532  798d 48                                  pha
 16533  798e b91ed0                              lda vic+30,y                             ; accumulate collision data (resets register)
 16534  7991 19e602                              ora collisions,y
 16535  7994 99e602                              sta collisions,y
 16536                          
 16537  7997 addc02                              lda intval                               ; allowable interrupts
 16538  799a c000                                cpy #0                                   ; examine selected bit
 16539  799c f001                                beq l252_2
 16540  799e 4a                                  lsr
 16541  799f 4a                 l252_2           lsr
 16542  79a0 9005                                bcc l252_3                               ; BASIC doesn't want this interrupt
 16543  79a2 a9ff                                lda #$ff
 16544  79a4 99dd02                              sta int_trip_flag,y                      ; turn on trip flag
 16545                          
 16546  79a7 68                 l252_3           pla
 16547                          
 16548  79a8 88                 l252_4           dey
 16549  79a9 10df                                bpl l252_1
 16550                          
 16551                          ; .page
 16552                          ; Check light pen latch
 16553                          
 16554  79ab 4a                                  lsr
 16555  79ac 9023                                bcc l252_5                               ; LightPen latch not valid
 16556                          
 16557  79ae ae31d0                              ldx vic+49                               ; 4567R7 bug- must read LP_latches in Slow mode????
 16558  79b1 a940                                lda #%01000000                           ; [910618]
 16559  79b3 1c31d0                              trb vic+49
 16560  79b6 ac13d0                              ldy vic+19                               ; save latched x position
 16561  79b9 8ce802                              sty lightpen_xpos
 16562  79bc ac14d0                              ldy vic+20                               ; save latched y position
 16563  79bf 8ce902                              sty lightpen_ypos
 16564  79c2 8e31d0                              stx vic+49                               ; restore speed     [910618]
 16565                          
 16566  79c5 addc02                              lda intval                               ; is BASIC interested in our little find?
 16567  79c8 2904                                and #4
 16568  79ca f005                                beq l252_5                               ; no, move on to next IRQ task
 16569  79cc a9ff                                lda #$ff
 16570  79ce 8ddf02                              sta int_trip_flag+2                      ; yes- let BASIC know we caught one
 16571                          
 16572                          l252_5
 16573                          ; .page
 16574                          ; Update moving sprites
 16575                          
 16576                          movspr_irq
 16577  79d1 ad15d0                              lda vic+21                               ; any sprites active?    [910212]
 16578  79d4 f3f100                              +lbeq music_irq                          ; no- skip ahead
 16579                          
 16580  79d7 a007                                ldy #7                                   ; check each of 8 sprites
 16581  79d9 ad15d0             l253_1           lda vic+21                               ; is this sprite is enabled?
 16582  79dc 396579                              and sbits,y
 16583  79df f03d                                beq l253_5                               ; sprite not enabled
 16584                          
 16585  79e1 befeb7                              ldx sproff,y                             ; get offset to sprite info from a table
 16586  79e4 bd0512                              lda sprite_data,x                        ; is this sprite moving (speed >0 )?
 16587  79e7 f035                                beq l253_5                               ; sprite not moving
 16588  79e9 1005                                bpl l253_2                               ; sprite moving, no destination
 16589  79eb 633700                              bsr movspr_to_irq                        ; sprite moving to a destination [910809]
 16590  79ee 802e                                bra l253_5
 16591                          
 16592  79f0 9d0612             l253_2           sta sprite_data+1,x                      ; set counter
 16593  79f3 98                 l253_3           tya                                      ; convert sprite# to a VIC register pointer
 16594  79f4 0a                                  asl
 16595  79f5 a8                                  tay
 16596  79f6 bd0712                              lda sprite_data+2,x                      ; get angle sign
 16597  79f9 3a                                  dec                                      ; subtract 1 for cosine
 16598  79fa e8                                  inx
 16599  79fb e8                                  inx
 16600  79fc c8                                  iny
 16601  79fd 20c67b                              jsr sprsub                               ; update y position
 16602  7a00 ca                                  dex
 16603  7a01 ca                                  dex
 16604  7a02 88                                  dey
 16605  7a03 bd0712                              lda sprite_data+2,x
 16606  7a06 20c67b                              jsr sprsub                               ; update x position
 16607  7a09 08                                  php
 16608  7a0a 98                                  tya
 16609  7a0b 4a                                  lsr                                      ; restore index (.Y=sprite pointer)
 16610  7a0c a8                                  tay
 16611  7a0d 28                                  plp
 16612  7a0e 9009                                bcc l253_4                               ; skip if no overflow
 16613  7a10 ad10d0                              lda vic+16                               ; get x position msb bits ???vic_save
 16614  7a13 596579                              eor sbits,y                              ; invert bit
 16615  7a16 8d10d0                              sta vic+16                               ; ???vic_save
 16616  7a19 de0612             l253_4           dec sprite_data+1,x
 16617  7a1c d0d5                                bne l253_3                               ; loop until counter done
 16618                          
 16619  7a1e 88                 l253_5           dey                                      ; check next sprite
 16620  7a1f 10b8                                bpl l253_1                               ; loop until done moving all sprites
 16621  7a21 83a400                              +lbra music_irq                          ; then continue with next IRQ task
 16622                          ; .page
 16623                          movspr_to_irq                                             ; [910809]
 16624  7a24 5a                                  phy                                      ; sprite #
 16625  7a25 293f                                and #$3f                                 ; speed factor
 16626  7a27 4b                                  taz
 16627  7a28 98                                  tya                                      ; vic sprite index
 16628  7a29 0a                                  asl
 16629  7a2a a8                                  tay
 16630                          
 16631  7a2b 38                 l254_1           sec                                      ; for i = 1 to abs(greatr)
 16632  7a2c bd0612                              lda sprite_data+1,x
 16633  7a2f e901                                sbc #1
 16634  7a31 9d0612                              sta sprite_data+1,x
 16635  7a34 b011                                bcs l254_2
 16636  7a36 bd0712                              lda sprite_data+2,x
 16637  7a39 e900                                sbc #0
 16638  7a3b 9d0712                              sta sprite_data+2,x
 16639  7a3e b007                                bcs l254_2
 16640  7a40 a900                                lda #0
 16641  7a42 9d0512                              sta sprite_data,x                        ; done!  sprite is at its destination
 16642  7a45 7a                                  ply                                      ; remember sprite #
 16643  7a46 60                                  rts
 16644                          
 16645  7a47 bd0812             l254_2           lda sprite_data+3,x                      ; ptr(lesser)
 16646  7a4a 3c0f12                              bit sprite_data+10,x
 16647  7a4d 3009                                bmi l254_3                               ; if e > 0
 16648  7a4f 3c0812                              bit sprite_data+3,x                      ; sgn(lesser) (b7=1=neg, b6=1=pos, else 0)
 16649  7a52 20907a                              jsr drwinc                               ; pos(lesser) = pos(lesser) + sgn(lesser)
 16650                          
 16651  7a55 bd0912                              lda sprite_data+4,x                      ; ptr(greater)
 16652  7a58 4a                 l254_3           lsr                                      ; which f?
 16653  7a59 b014                                bcs l254_4
 16654  7a5b bd0e12                              lda sprite_data+9,x                      ; e = e + f1
 16655  7a5e 7d0a12                              adc sprite_data+5,x
 16656  7a61 9d0e12                              sta sprite_data+9,x
 16657  7a64 bd0f12                              lda sprite_data+10,x
 16658  7a67 7d0b12                              adc sprite_data+6,x
 16659  7a6a 9d0f12                              sta sprite_data+10,x
 16660  7a6d 8013                                bra l254_5
 16661                          
 16662  7a6f 18                 l254_4           clc
 16663  7a70 bd0e12                              lda sprite_data+9,x                      ; e = e + f2
 16664  7a73 7d0c12                              adc sprite_data+7,x
 16665  7a76 9d0e12                              sta sprite_data+9,x
 16666  7a79 bd0f12                              lda sprite_data+10,x
 16667  7a7c 7d0d12                              adc sprite_data+8,x
 16668  7a7f 9d0f12                              sta sprite_data+10,x
 16669                          
 16670  7a82 bd0912             l254_5           lda sprite_data+4,x                      ; ptr(greater)
 16671  7a85 3c0912                              bit sprite_data+4,x                      ; sgn(greater) (b7=1=neg, b6=1=pos, else 0)
 16672  7a88 20907a                              jsr drwinc                               ; pos(greater) = pos(greater) + sgn(greater)
 16673                          
 16674  7a8b 3b                                  dez                                      ; count
 16675  7a8c d09d                                bne l254_1
 16676  7a8e 7a                                  ply                                      ; remember sprite #
 16677  7a8f 60                                  rts                                      ; done this frame
 16678                          
 16679                          
 16680  7a90 08                 drwinc           php
 16681  7a91 2901                                and #1                                   ; adjust .y for x or y position
 16682  7a93 f001                                beq l255_1                               ; 0=x
 16683  7a95 c8                                  iny                                      ; 1=y
 16684  7a96 28                 l255_1           plp
 16685  7a97 300b                                bmi l255_2                               ; enter with b7=negative, b6=positive, else zero
 16686  7a99 5027                                bvc l255_4
 16687                          
 16688  7a9b b900d0                              lda vic,y                                ; positive direction
 16689  7a9e 1a                                  inc
 16690  7a9f 9900d0                              sta vic,y
 16691  7aa2 8009                                bra l255_3
 16692                          
 16693  7aa4 b900d0             l255_2           lda vic,y                                ; negative direction
 16694  7aa7 3a                                  dec
 16695  7aa8 9900d0                              sta vic,y
 16696  7aab c9ff                                cmp #$ff
 16697                          
 16698  7aad d013               l255_3           bne l255_4                               ; no wrap
 16699  7aaf 98                                  tya
 16700  7ab0 8901                                bit #1
 16701  7ab2 d00e                                bne l255_4                               ; wrap in y okay
 16702  7ab4 4a                                  lsr
 16703  7ab5 a8                                  tay
 16704  7ab6 b96579                              lda sbits,y                              ; wrap in x- toggle msb
 16705  7ab9 4d10d0                              eor vic+16
 16706  7abc 8d10d0                              sta vic+16
 16707  7abf 98                                  tya
 16708  7ac0 0a                                  asl
 16709  7ac1 a8                                  tay
 16710                          
 16711  7ac2 98                 l255_4           tya                                      ; restore y to sprite offset
 16712  7ac3 29fe                                and #$fe
 16713  7ac5 a8                                  tay
 16714  7ac6 60                                  rts
 16715                          
 16716                          ; .page
 16717                          ; Play music, if in progress
 16718                          
 16719                          music_irq
 16720  7ac7 a200                                ldx #0
 16721  7ac9 bc5e12             l256_1           ldy voices+1,x
 16722  7acc 3025                                bmi l256_2                               ; skip if not active
 16723                          
 16724  7ace bd5d12                              lda voices,x
 16725  7ad1 38                                  sec
 16726  7ad2 ed7312                              sbc tempo_rate                           ; decrement current value by current tempo
 16727  7ad5 9d5d12                              sta voices,x
 16728  7ad8 b019                                bcs l256_2
 16729  7ada 98                                  tya                                      ; lda voices+1,x
 16730  7adb e900                                sbc #0
 16731  7add 9d5e12                              sta voices+1,x
 16732  7ae0 b011                                bcs l256_2                               ; ok, no underflow
 16733                          
 16734  7ae2 8a                                  txa
 16735  7ae3 4a                                  lsr                                      ; get offset to waveform
 16736  7ae4 a8                                  tay
 16737  7ae5 b96912                              lda waveform,y                           ; get waveform
 16738  7ae8 29fe                                and #$fe                                 ; mask out gate bit
 16739  7aea 48                                  pha
 16740  7aeb b9004a                              lda SID_offset,y                         ; get offset to correct oscillator
 16741  7aee a8                                  tay
 16742  7aef 68                                  pla
 16743                          ; jsr go_slow  ;      [910716] 4567R7A
 16744  7af0 9904d4                              sta sid1+4,y                             ; turn off sound
 16745                          ; jsr go_fast  ;      [910716] 4567R7A
 16746                          
 16747  7af3 e8                 l256_2           inx
 16748  7af4 e8                                  inx
 16749  7af5 e00c                                cpx #6+6                                 ; [910612]
 16750  7af7 90d0                                bcc l256_1                               ; loop for 6 voices
 16751                          ;then continue with next IRQ task
 16752                          ; .page
 16753                          ; Test if SOUND command wants anything
 16754                          
 16755                          sound_irq
 16756  7af9 a005                                ldy #6-1                                 ; test six voices    [910612]
 16757  7afb b9c412             l257_1           lda sound_time_hi,y                      ; active if msb clear
 16758  7afe 1006                                bpl l257_3
 16759  7b00 88                 l257_2           dey
 16760  7b01 10f8                                bpl l257_1
 16761  7b03 83bc00                              +lbra basic_irq_end
 16762                          
 16763  7b06 18                 l257_3           clc                                      ; add step to frequency
 16764  7b07 b9f412                              lda sound_freq_lo,y
 16765  7b0a 79e812                              adc sound_step_lo,y
 16766  7b0d 99f412                              sta sound_freq_lo,y
 16767  7b10 b9fa12                              lda sound_freq_hi,y
 16768  7b13 79ee12                              adc sound_step_hi,y
 16769  7b16 99fa12                              sta sound_freq_hi,y
 16770                          
 16771  7b19 b9e212                              lda sound_direction,y                    ; test if this is up or down
 16772  7b1c aa                                  tax
 16773  7b1d 2901                                and #1
 16774  7b1f f02d                                beq l257_6                               ; branch if up
 16775                          
 16776                          ; If step direction is down, .C==0 OR freq < min  ==> reset value
 16777                          
 16778  7b21 900f                                bcc l257_4                               ; underflow, reset
 16779  7b23 38                                  sec
 16780  7b24 b9f412                              lda sound_freq_lo,y
 16781  7b27 f9d612                              sbc sound_min_lo,y
 16782  7b2a b9fa12                              lda sound_freq_hi,y
 16783  7b2d f9dc12                              sbc sound_min_hi,y
 16784  7b30 b04c                                bcs l257_9                               ; no borrow, don't reset
 16785                          
 16786  7b32 e002               l257_4           cpx #2                                   ; is 'cycle' bit set?
 16787  7b34 900a                                bcc l257_5                               ; no, keep direction 'down'
 16788                          
 16789  7b36 20ab7b                              jsr negate_step                          ; make step 2's comp
 16790  7b39 a902                                lda #2                                   ; change direction to 'up'
 16791  7b3b 99e212                              sta sound_direction,y
 16792  7b3e d032                                bne l257_8                               ; go reset for 'up'
 16793                          
 16794  7b40 b9ca12             l257_5           lda sound_max_lo,y                       ; reset to max
 16795  7b43 99f412                              sta sound_freq_lo,y
 16796  7b46 b9d012                              lda sound_max_hi,y
 16797  7b49 99fa12                              sta sound_freq_hi,y
 16798  7b4c 8030                                bra l257_9                               ; go update SID frequency
 16799                          
 16800                          ; If step direction is up, overflow (.C==1) OR freq > max ==> reset frequency
 16801                          
 16802  7b4e b014               l257_6           bcs l257_7                               ; overflow, must reset
 16803  7b50 b9fa12                              lda sound_freq_hi,y                      ; 16 bit compare (yech!)
 16804  7b53 d9d012                              cmp sound_max_hi,y
 16805  7b56 9026                                bcc l257_9                               ; freq < max, no reset
 16806  7b58 d00a                                bne l257_7                               ; freq > max, reset
 16807  7b5a b9f412                              lda sound_freq_lo,y                      ; msb's the same, test lsb's
 16808  7b5d d9ca12                              cmp sound_max_lo,y
 16809  7b60 901c                                bcc l257_9                               ; freq < max, no reset
 16810  7b62 f01a                                beq l257_9                               ; freq = max, no reset
 16811                          
 16812  7b64 e002               l257_7           cpx #2                                   ; is this 'cycle'?
 16813  7b66 900a                                bcc l257_8                               ; no, go reset for next 'up'
 16814                          
 16815  7b68 20ab7b                              jsr negate_step                          ; make step 2's comp
 16816  7b6b a903                                lda #3                                   ; change direction to 'down'
 16817  7b6d 99e212                              sta sound_direction,y
 16818  7b70 d0ce                                bne l257_5                               ; go reset for next 'down'
 16819                          
 16820  7b72 b9d612             l257_8           lda sound_min_lo,y                       ; set freq to minimum value
 16821  7b75 99f412                              sta sound_freq_lo,y
 16822  7b78 b9dc12                              lda sound_min_hi,y
 16823  7b7b 99fa12                              sta sound_freq_hi,y
 16824                          
 16825                          ; Update SID frequency registers
 16826                          
 16827                          l257_9
 16828                          ; jsr go_slow  ;      [910716] 4567R7A
 16829  7b7e be004a                              ldx SID_offset,y                         ; get index to SID voices
 16830  7b81 b9f412                              lda sound_freq_lo,y
 16831  7b84 9d00d4                              sta sid1,x
 16832  7b87 b9fa12                              lda sound_freq_hi,y
 16833  7b8a 9d01d4                              sta sid1+1,x
 16834                          ; jsr go_fast  ;      [910716] 4567R7A
 16835                          
 16836                          ; Decrement total time - see if it's time to bring down the curtain
 16837                          
 16838  7b8d 98                                  tya
 16839  7b8e aa                                  tax
 16840  7b8f bdbe12                              lda sound_time_lo,x                      ; 16 bit decrement - not very pretty
 16841  7b92 d003                                bne l257_10
 16842  7b94 dec412                              dec sound_time_hi,x
 16843  7b97 debe12             l257_10          dec sound_time_lo,x
 16844                          
 16845  7b9a bdc412                              lda sound_time_hi,x                      ; underflow?
 16846  7b9d 1361ff                              +lbpl l257_2                             ; nope
 16847                          
 16848                          ; Time to turn off this voice
 16849                          
 16850                          ; jsr go_slow  ;      [910716] 4567R7A
 16851  7ba0 a908                                lda #$08
 16852  7ba2 be004a                              ldx SID_offset,y
 16853  7ba5 9d04d4                              sta sid1+4,x
 16854                          ; jsr go_fast  ;      [910716] 4567R7A
 16855  7ba8 8356ff                              +lbra l257_2
 16856                          
 16857                          
 16858                          negate_step
 16859  7bab b9e812                              lda sound_step_lo,y
 16860  7bae 49ff                                eor #$ff
 16861  7bb0 18                                  clc
 16862  7bb1 6901                                adc #1
 16863  7bb3 99e812                              sta sound_step_lo,y
 16864  7bb6 b9ee12                              lda sound_step_hi,y
 16865  7bb9 49ff                                eor #$ff
 16866  7bbb 6900                                adc #0
 16867  7bbd 99ee12                              sta sound_step_hi,y
 16868  7bc0 60                                  rts
 16869                          
 16870                          
 16871                          ; .page
 16872                          ; Here is where BASIC_IRQ exits
 16873                          
 16874                          basic_irq_end
 16875  7bc1 cedb02                              dec irq_wrap_flag                        ; open the door to IRQ
 16876  7bc4 58                                  cli
 16877  7bc5 60                                  rts
 16878                          
 16879                          ; .page
 16880                          ; Update sprite position subroutine
 16881                          
 16882  7bc6 48                 sprsub           pha                                      ; save angle phase
 16883  7bc7 18                                  clc
 16884  7bc8 bd0812                              lda sprite_data+3,x                      ; add low bytes
 16885  7bcb 7d0c12                              adc sprite_data+7,x
 16886  7bce 9d0c12                              sta sprite_data+7,x
 16887  7bd1 bd0912                              lda sprite_data+4,x                      ; add high bytes
 16888  7bd4 7d0d12                              adc sprite_data+8,x
 16889  7bd7 9d0d12                              sta sprite_data+8,x
 16890  7bda 68                                  pla                                      ; get angle sign
 16891  7bdb 9012                                bcc l258_3                               ; skip if no carry - do not update position
 16892  7bdd 4a                                  lsr
 16893  7bde 4a                                  lsr                                      ; test if positive or negative
 16894  7bdf b900d0                              lda vic,y                                ; ???vic_save
 16895  7be2 b004                                bcs l258_1                               ; skip if negative
 16896  7be4 6901                                adc #1                                   ; increment position
 16897  7be6 8004                                bra l258_2
 16898                          
 16899  7be8 e901               l258_1           sbc #1                                   ; decrement position
 16900  7bea c9ff                                cmp #$ff                                 ; set carry if underflow
 16901  7bec 9900d0             l258_2           sta vic,y                                ; decrement position  ???vic_save
 16902  7bef 60                 l258_3           rts
 16903                          
 16904                          ;.end
 16905                          ; .page
 16906                          ; .subttl  MOUSE
 16907                          
 16908                          ;***********************************************************************
 16909                          ;*   MOUSE  ON  [,[port] [,[sprite] [,[hotspot] [,X/Yposition] ]]]
 16910                          ;*   MOUSE  OFF
 16911                          ;*    where: port     = (1...3) for joyport 1, 2, or either (both)
 16912                          ;*  sprite   = (0...7) sprite pointer
 16913                          ;*  hotspot  = x,y offset in sprite, default 0,0
 16914                          ;*  position = normal, relative, or angluar coordinates
 16915                          ;*
 16916                          ;*      (defaults to sprite 0, port 2, last hotspot & position)
 16917                          ;***********************************************************************
 16918                          
 16919  7bf0 c991               mouse            cmp #on_token                            ; new [910122]
 16920  7bf2 f010                                beq l259_1
 16921  7bf4 2016b5                              jsr chkesc
 16922  7bf7 c924                                cmp #off_token
 16923  7bf9 d34fb2                              +lbne snerr
 16924                          
 16925                          ;    The Kernel MOUSE_CMD is called to install or remove mouse driver.
 16926                          ; .a= B7,6 set to install mouse in game port 2 ($80), 1 ($40), or both ($C0)
 16927                          ; .a= 0 to disable mouse driver
 16928                          ; .x= 0-7 physical sprite pointer
 16929                          
 16930  7bfc a900                                lda #0                                   ; TURN MOUSE OFF
 16931  7bfe 201be0                              jsr _mouse                               ; do it
 16932  7c01 831f39                              +lbra chkeos                             ; eat token & exit after checking for eos
 16933                          
 16934                          ;TURN MOUSE ON
 16935  7c04 208322             l259_1           jsr chrget                               ; eat token
 16936  7c07 a202                                ldx #2                                   ; get (optional) port# in .X
 16937  7c09 202679                              jsr optbyt                               ; if not present default to port 2
 16938  7c0c e004                                cpx #4                                   ;
 16939  7c0e b3eed5                              +lbcs fcerr                              ; illegal value
 16940  7c11 da                                  phx
 16941                          
 16942  7c12 a200                                ldx #0                                   ; get (optional) sprite# in .X
 16943  7c14 202679                              jsr optbyt                               ; if not present default to sprite 0
 16944  7c17 e008                                cpx #8
 16945  7c19 b3e3d5                              +lbcs fcerr                              ; illegal value
 16946  7c1c 8676                                stx z_p_temp_1
 16947  7c1e bcfeb7                              ldy sproff,x                             ; kill moving sprite
 16948  7c21 a900                                lda #0                                   ; get offset to speed data
 16949  7c23 990512                              sta sprite_data,y                        ; reset sprite's speed value
 16950                          
 16951  7c26 68                                  pla                                      ; setup for Kernel call- get port# into b7,6
 16952  7c27 6a                                  ror                                      ; .a= port(s), .x=sprite
 16953  7c28 6a                                  ror
 16954  7c29 6a                                  ror
 16955  7c2a 201be0                              jsr _mouse                               ; do it (???? do after coord error check)
 16956                          
 16957                          ; .page
 16958  7c2d 202679                              jsr optbyt                               ; get (optional) hotspot, x  new [910307]
 16959  7c30 9014                                bcc l259_2                               ; not given
 16960  7c32 e018                                cpx #24
 16961  7c34 b3c8d5                              +lbcs fcerr                              ; out of range (0-23)
 16962  7c37 8a                                  txa
 16963  7c38 42                                  neg
 16964  7c39 aa                                  tax
 16965  7c3a 6918                                adc #24
 16966  7c3c 8d3d11                              sta _mouse_left
 16967  7c3f 8a                                  txa
 16968  7c40 18                                  clc
 16969  7c41 6957                                adc #87
 16970  7c43 8d3e11                              sta _mouse_right
 16971                          
 16972  7c46 202679             l259_2           jsr optbyt                               ; get (optional) hotspot, y
 16973  7c49 9014                                bcc l259_3                               ; not given
 16974  7c4b e015                                cpx #21
 16975  7c4d b3afd5                              +lbcs fcerr                              ; out of range (0-20)
 16976  7c50 8a                                  txa
 16977  7c51 42                                  neg
 16978  7c52 aa                                  tax
 16979  7c53 6932                                adc #50
 16980  7c55 8d3b11                              sta _mouse_top
 16981  7c58 8a                                  txa
 16982  7c59 18                                  clc
 16983  7c5a 69fa                                adc #250
 16984  7c5c 8d3c11                              sta _mouse_bottom
 16985                          
 16986  7c5f 208522             l259_3           jsr chrgot                               ; get (optional) position coordinate  [910123]
 16987  7c62 f028                                beq l259_4                               ; eol, use this sprite's last position
 16988  7c64 20c3b7                              jsr sprcor                               ; else get first coordinate
 16989  7c67 2cf411                              bit numcnt                               ; test coordinate type
 16990  7c6a 73deb1                              +lbvs snerr                              ; syntax error
 16991  7c6d 8cf011                              sty xdest                                ; save coordinate value
 16992  7c70 8cf211                              sty xdest+2
 16993  7c73 8df111                              sta xdest+1
 16994  7c76 8df311                              sta xdest+3
 16995                          
 16996  7c79 a97f                                lda #$7f                                 ; flag 'mouse' for movspr call  [910808]
 16997  7c7b 8587                                sta op
 16998  7c7d 20c3b7                              jsr sprcor                               ; get second coordinate
 16999  7c80 2cf411                              bit numcnt                               ; test type of coordinate
 17000  7c83 53bf39                              +lbvc movspr_normal                      ; position sprite, normal coordinates
 17001  7c86 339e39                              +lbmi movspr_angle                       ; angular coordinates
 17002  7c89 83bfb1                              +lbra snerr                              ; else error
 17003                          
 17004  7c8c 60                 l259_4           rts
 17005                          
 17006                          ;.end
 17007                          ; .page
 17008                          ;************************************************************************
 17009                          ;*   RMOUSE Returns in variable list current status of mouse *
 17010                          ;*         *
 17011                          ;*   Syntax: RMOUSE [Xposition [,Yposition [, Buttons] ]]  *
 17012                          ;*         *
 17013                          ;*   Where: X,Yposition = current position of mouse pointer sprite *
 17014                          ;*  Button      = current status of mouse buttons  *
 17015                          ;*         *
 17016                          ;*   0   = no button     *
 17017                          ;*   1   = right button    *
 17018                          ;*   128 = left button    *
 17019                          ;*   129 = both buttons    *
 17020                          ;*         *
 17021                          ;* If a mouse is not installed, "-1" is returned for all vars. *
 17022                          ;* If both ports are enabled, buttons from each port are merged. *
 17023                          ;************************************************************************
 17024                          
 17025  7c8d a900               rmouse           lda #0                                   ; Init
 17026  7c8f 850d                                sta count                                ; variable count = 0
 17027  7c91 3a                                  dec
 17028  7c92 a205                                ldx #6-1
 17029  7c94 9587               l260_1           sta grapnt,x                             ; positions/buttons = -1
 17030  7c96 ca                                  dex
 17031  7c97 10fb                                bpl l260_1
 17032                          
 17033  7c99 ad3511                              lda _mouse_enable                        ; Is there a mouse in the house?
 17034  7c9c 29c0                                and #%11000000
 17035  7c9e f050                                beq l260_5                               ; no, exit
 17036  7ca0 48                                  pha                                      ; yes, save port assigns for later
 17037  7ca1 78                                  sei
 17038  7ca2 ac3611                              ldy _mouse_pointer                       ; Where is it?  Get pointer to sprite
 17039  7ca5 b900d0                              lda vic,y                                ; Get X position    ???vic_save
 17040  7ca8 8587                                sta grapnt                               ; lsb
 17041  7caa b96579                              lda sbits,y
 17042  7cad 2d10d0                              and vic+16                               ; msb    ???vic_save
 17043  7cb0 f002                                beq l260_2
 17044  7cb2 a901                                lda #1                                   ; convert to 0 or 1
 17045  7cb4 8588               l260_2           sta grapnt+1
 17046  7cb6 c8                                  iny                                      ; Get Y position
 17047  7cb7 b900d0                              lda vic,y                                ; lsb    ???vic_save
 17048  7cba 8589                                sta grapnt+2
 17049  7cbc a900                                lda #0                                   ; msb (fake it)
 17050  7cbe 858a                                sta grapnt+3
 17051                          
 17052  7cc0 858b                                sta grapnt+4                             ; Init button status
 17053  7cc2 858c                                sta grapnt+5
 17054  7cc4 ab00dc                              ldz d1pra                                ; Set up port & read buttons
 17055  7cc7 a9ff                                lda #$ff                                 ; save kybd output lines (IRQ already disabled)
 17056  7cc9 8d00dc                              sta d1pra                                ; set to not read any kybd inputs
 17057                          
 17058  7ccc a000                                ldy #0                                   ; which port?
 17059  7cce fa                                  plx                                      ; recall port assignments
 17060  7ccf 8a                 l260_3           txa
 17061  7cd0 0a                                  asl                                      ; .c=1 if this one
 17062  7cd1 aa                                  tax
 17063  7cd2 900f                                bcc l260_4                               ; not this one
 17064  7cd4 b900dc                              lda d1pra,y                              ; read it (logical port is opposite physical port)
 17065  7cd7 2911                                and #%00010001                           ; want left, right buttons only
 17066  7cd9 4911                                eor #%00010001                           ; (invert, since low means button down)
 17067  7cdb 048b                                tsb grapnt+4
 17068  7cdd 2910                                and #%00010000                           ; shift left button to msb
 17069  7cdf f002                                beq l260_4
 17070  7ce1 f78b                                smb7 grapnt+4
 17071  7ce3 c8                 l260_4           iny                                      ; next port
 17072  7ce4 c002                                cpy #2
 17073  7ce6 90e7                                bcc l260_3
 17074                          
 17075  7ce8 a97e                                lda #%01111110                           ; clean up
 17076  7cea 148b                                trb grapnt+4                             ; fix button register
 17077  7cec 9c00dc                              stz d1pra                                ; restore port for Kernel
 17078  7cef 58                                  cli
 17079                          
 17080                          ; At this point, we have snapshot the current mouse status.
 17081                          ; Now pass requested info along in a manner very similar to RREG...
 17082                          
 17083  7cf0 208522             l260_5           jsr chrgot                               ; Get a variable name from variable list
 17084  7cf3 f032                                beq l260_8                               ; eol- exit
 17085  7cf5 c92c                                cmp #','                                 ;
 17086  7cf7 f01a                                beq l260_7                               ; null- skip this arg
 17087  7cf9 207c4f                              jsr ptrget                               ; Get pointer to target variable
 17088  7cfc 854b                                sta forpnt                               ; set up so we can share LET code
 17089  7cfe 844c                                sty forpnt+1
 17090  7d00 a50f                                lda valtyp                               ; what kind of variable name did ptrget find?
 17091  7d02 d3e3cf                              +lbne chkerr                             ; string- type mismatch error
 17092                          
 17093  7d05 a60d               l260_6           ldx count                                ; Make assignment
 17094  7d07 b487                                ldy grapnt,x                             ; low byte
 17095  7d09 b588                                lda grapnt+1,x                           ; high byte
 17096  7d0b 203f4e                              jsr givayf                               ; float it
 17097  7d0e a510                                lda intflg                               ; set flags for type of var (int/float)
 17098  7d10 209336                              jsr qintgr                               ; use part of LET to do the work
 17099                          
 17100  7d13 e60d               l260_7           inc count                                ; Next assignment
 17101  7d15 e60d                                inc count
 17102  7d17 a60d                                ldx count
 17103  7d19 e006                                cpx #6                                   ; there are 3 possible
 17104  7d1b b00a                                bcs l260_8                               ; done all 3, exit
 17105  7d1d 208522                              jsr chrgot                               ; check terminator
 17106  7d20 f005                                beq l260_8                               ; eol- exit
 17107  7d22 205b4e                              jsr chkcom                               ; check delimiter
 17108  7d25 80c9                                bra l260_5                               ; loop until done
 17109                          
 17110  7d27 60                 l260_8           rts
 17111                          
 17112                          ;.end
 17113                          ; .page
 17114                          ; .subttl   CURSOR
 17115                          
 17116                          ;*****************************************************************
 17117                          ;*   CURSOR [ON|OFF,] [column] [,row [,style] ]
 17118                          ;*
 17119                          ;*   where: column,row = x,y logical screen position
 17120                          ;*  style      = flashing (0) or solid (1)
 17121                          ;*  ON,OFF     = to turn the cursor on or off
 17122                          ;*****************************************************************
 17123                          
 17124  7d28 c991               cursor           cmp #on_token                            ; Check for ON | OFF
 17125  7d2a 18                                  clc
 17126  7d2b f046                                beq l261_3                               ; turn cursor on (.c=0)
 17127  7d2d c9fe                                cmp #esc_command_token
 17128  7d2f d00a                                bne l261_1                               ; (might be a function)
 17129  7d31 2016b5                              jsr chkesc
 17130  7d34 c924                                cmp #off_token                           ; turn cursor off (.c=1)
 17131  7d36 f03b                                beq l261_3
 17132  7d38 8310b1                              +lbra snerr
 17133                          
 17134  7d3b 48                 l261_1           pha                                      ; Evaluate cursor position parameters
 17135  7d3c 38                                  sec
 17136  7d3d 20f0ff                              jsr _plot                                ; get current cursor position & save it
 17137  7d40 8688                                stx srow
 17138  7d42 8487                                sty column
 17139                          
 17140  7d44 a687                                ldx column                               ; get new column, default=current column
 17141  7d46 68                                  pla
 17142  7d47 c92c                                cmp #','
 17143  7d49 f003                                beq l261_2                               ; not given, use default
 17144  7d4b 206c5d                              jsr getbyt
 17145  7d4e 8687               l261_2           stx column
 17146  7d50 a688                                ldx srow                                 ; get new row, default=current row
 17147  7d52 202679                              jsr optbyt
 17148                          ; stx srow
 17149  7d55 a487                                ldy column
 17150  7d57 18                                  clc
 17151  7d58 20f0ff                              jsr _plot                                ; set new cursor position
 17152  7d5b b3a1d4                              +lbcs fcerr                              ; error if bad position
 17153                          
 17154  7d5e 202479                              jsr optzer                               ; Get new cursor type   ???? assumes screen output
 17155  7d61 901d                                bcc l261_4                               ; not given, exit
 17156  7d63 a91b                                lda #esc
 17157  7d65 20d2ff                              jsr _bsout                               ; use escape sequence to set
 17158  7d68 8a                                  txa
 17159  7d69 2901                                and #1
 17160  7d6b 4901                                eor #1                                   ; [910808]
 17161  7d6d 18                                  clc
 17162  7d6e 6945                                adc #'E'                                 ; 0=F=flash, 1=E=solid
 17163  7d70 4cd2ff                              jmp _bsout                               ; set it and exit
 17164                          
 17165  7d73 2030e0             l261_3           jsr _cursor                              ; Turn cursor ON or OFF per .c
 17166                          
 17167  7d76 208322                              jsr chrget                               ; eat token, get next character
 17168  7d79 f005                                beq l261_4                               ; eol- exit
 17169  7d7b 205b4e                              jsr chkcom                               ; else, must be comma
 17170  7d7e 80bb                                bra l261_1                               ; it is- go evaluate position
 17171                          
 17172  7d80 60                 l261_4           rts                                      ; eol
 17173                          
 17174                          ; .page
 17175                          ;************************************************************************
 17176                          ;*   RCURSOR Returns in variable list current cursor position *
 17177                          ;*         *
 17178                          ;*   Syntax: RCURSOR [column [,row] ]    *
 17179                          ;************************************************************************
 17180                          
 17181  7d81 38                 rcursor          sec                                      ; new [910228]
 17182  7d82 20f0ff                              jsr _plot                                ; get current cursor position & save it
 17183  7d85 8688                                stx srow
 17184  7d87 8487                                sty column
 17185                          
 17186  7d89 a200                                ldx #0                                   ; just like RREG and RMOUSE...
 17187  7d8b 860d                                stx count
 17188  7d8d 208522             l262_1           jsr chrgot                               ; Get a variable name from variable list
 17189  7d90 f030                                beq l262_4                               ; eol- exit
 17190  7d92 c92c                                cmp #','                                 ;
 17191  7d94 f01a                                beq l262_3                               ; null- skip this arg
 17192  7d96 207c4f                              jsr ptrget                               ; Get pointer to target variable
 17193  7d99 854b                                sta forpnt                               ; set up so we can share LET code
 17194  7d9b 844c                                sty forpnt+1
 17195  7d9d a50f                                lda valtyp                               ; what kind of variable name did ptrget find?
 17196  7d9f d346cf                              +lbne chkerr                             ; string- type mismatch error
 17197                          
 17198  7da2 a60d               l262_2           ldx count                                ; Make assignment
 17199  7da4 b487                                ldy column,x                             ; low byte
 17200  7da6 a900                                lda #0                                   ; high byte
 17201  7da8 203f4e                              jsr givayf                               ; float it
 17202  7dab a510                                lda intflg                               ; set flags for type of var (int/float)
 17203  7dad 209336                              jsr qintgr                               ; use part of LET to do the work
 17204                          
 17205  7db0 e60d               l262_3           inc count                                ; Next assignment
 17206  7db2 a60d                                ldx count
 17207  7db4 e002                                cpx #2                                   ; there are 2 possible
 17208  7db6 b00a                                bcs l262_4                               ; done 2, exit
 17209  7db8 208522                              jsr chrgot                               ; check terminator
 17210  7dbb f005                                beq l262_4                               ; eol- exit
 17211  7dbd 205b4e                              jsr chkcom                               ; check delimiter
 17212  7dc0 80cb                                bra l262_1                               ; loop until done
 17213                          
 17214  7dc2 60                 l262_4           rts
 17215                          
 17216                          ;.end
 17217                          ; .page
 17218                          ; .subttl  AutoScroll
 17219                          
 17220                          AutoScroll
 17221  7dc3 48                                  pha                                      ; save character for Editor
 17222  7dc4 ff7e1e                              bbs7 runmod,AutoScrollno                 ; branch if not direct mode
 17223  7dc7 a415                                ldy channl                               ; is output redirected?
 17224  7dc9 d01a                                bne AutoScrollno                         ; yes- can't do scroll (need to read screen)
 17225  7dcb a52d                                lda txttab
 17226  7dcd a62e                                ldx txttab+1                             ; is there a program in memory to scroll?
 17227  7dcf 853d                                sta txtptr
 17228  7dd1 863e                                stx txtptr+1
 17229  7dd3 c8                                  iny                                      ; (1)
 17230  7dd4 20c522                              jsr indtxt
 17231  7dd7 d011                                bne AutoScrollyes                        ; yes- continue
 17232  7dd9 800a                                bra AutoScrollno                         ; no-  exit
 17233                          
 17234                          AutoScrollpop
 17235  7ddb 68                                  pla
 17236  7ddc 68                                  pla
 17237                          AutoScrollng
 17238  7ddd a67f                                ldx point                                ; restore cursor position
 17239  7ddf a480                                ldy point+1
 17240  7de1 18                                  clc
 17241  7de2 20f0ff                              jsr _plot
 17242                          AutoScrollno
 17243  7de5 1755                                rmb1 helper                              ; remove LINGET flag
 17244  7de7 68                                  pla                                      ; restore character
 17245  7de8 38                                  sec                                      ; return to Editor with no action taken
 17246  7de9 60                                  rts
 17247                          
 17248                          AutoScrollyes
 17249  7dea 663f                                ror form                                 ; save .c=direction (character already on stack)
 17250  7dec 38                                  sec
 17251  7ded 20f0ff                              jsr _plot                                ; get current cursor position & save it
 17252  7df0 867f                                stx point
 17253  7df2 8480                                sty point+1
 17254  7df4 9755                                smb1 helper                              ; set flag for LINGET not to go to error if it has problems
 17255  7df6 ff3f3d                              bbs7 form,AutoScrolldn                   ; branch according to direction of scroll...
 17256                          
 17257                          ; .page
 17258                          AutoScrollup                                              ; wanting to scroll up
 17259  7df9 38                                  sec
 17260  7dfa a5e4                                lda _screen_bottom                       ; put cursor at bottom of screen
 17261  7dfc e5e5                                sbc _screen_top
 17262  7dfe 8540                                sta form+1                               ; save where it is- we'll be printing line there
 17263  7e00 aa                                  tax
 17264  7e01 20a87e                              jsr AutoSearch                           ; search for a line number on screen, put it in linnum
 17265  7e04 20fa31                              jsr FindLine                             ; find the line in program
 17266  7e07 900e                                bcc l263_1   ;  line not found           ; we have a pointer to the next line
 17267  7e09 a000                                ldy #0
 17268  7e0b 20ad22                              jsr indlow                               ; find the next line, the one we want to print, via link bytes
 17269  7e0e aa                                  tax
 17270  7e0f c8                                  iny
 17271  7e10 20ad22                              jsr indlow
 17272  7e13 8661                                stx lowtr                                ; advance pointer to it
 17273  7e15 8562                                sta lowtr+1
 17274  7e17 a640               l263_1           ldx form+1                               ; put cursor back at bottom of screen
 17275  7e19 a000                                ldy #0
 17276  7e1b 18                                  clc
 17277  7e1c 20f0ff                              jsr _plot
 17278  7e1f 20f737             l263_2           jsr crdo                                 ; get a blank line to print on- scroll screen up
 17279  7e22 a001                                ldy #1
 17280  7e24 20ad22                              jsr indlow                               ; end of program marker?
 17281  7e27 d05f                                bne AutoScrollprint                      ; no-  print this line & exit
 17282  7e29 a52d                                lda txttab                               ; yes- loop to start of program,
 17283  7e2b a62e                                ldx txttab+1
 17284  7e2d 8561                                sta lowtr
 17285  7e2f 8662                                stx lowtr+1
 17286  7e31 20f737                              jsr crdo                                 ; and add an extra newline
 17287  7e34 80e9                                bra l263_2
 17288                          
 17289                          ; .page
 17290                          AutoScrolldn                                              ; wanting to scroll down
 17291  7e36 a200                                ldx #0                                   ; put cursor at top of screen
 17292  7e38 20a87e                              jsr AutoSearch                           ; search for a line number on screen, put it in linnum
 17293  7e3b a200                                ldx #0                                   ; get a blank line to print on
 17294  7e3d a000                                ldy #0                                   ; put cursor at top of screen
 17295  7e3f 18                                  clc
 17296  7e40 20f0ff                              jsr _plot
 17297  7e43 207dff             l264_1           jsr _primm                               ; and scroll screen (kill any pending Editor modes, too)
 17298  7e46 1b1b1b5700                          !text esc,esc,esc,"W",0
 17299  7e4b 20fa31                              jsr FindLine                             ; find the line in program whose number we found on screen
 17300  7e4e a561                                lda lowtr                                ; (does not matter if it or next higher line is found)
 17301  7e50 c52d                                cmp txttab
 17302  7e52 d012                                bne l264_2
 17303  7e54 a562                                lda lowtr+1
 17304  7e56 c52e                                cmp txttab+1
 17305  7e58 d00c                                bne l264_2
 17306  7e5a a9ff                                lda #$ff                                 ; special case- it's the very first line, want to wrap to last line
 17307  7e5c 8517                                sta linnum+1                             ; fake pointer to the last line,
 17308  7e5e 207dff                              jsr _primm                               ; scroll screen to insert extra space,
 17309  7e61 1b5700                              !text esc,"W",0
 17310  7e64 80dd                                bra l264_1                               ; and go around again
 17311                          
 17312  7e66 a52d               l264_2           lda txttab                               ; start at beginning of program (txttab) and find the line which points at (lowtr)
 17313  7e68 a62e                                ldx txttab+1
 17314  7e6a 8524               l264_3           sta index                                ; pointer to link bytes
 17315  7e6c 8625                                stx index+1
 17316  7e6e a001                                ldy #1
 17317  7e70 20c122                              jsr indin1                               ; get link bytes
 17318  7e73 aa                                  tax
 17319  7e74 88                                  dey
 17320  7e75 20c122                              jsr indin1
 17321  7e78 e462                                cpx lowtr+1                              ; do link bytes point at target line?
 17322  7e7a d0ee                                bne l264_3
 17323  7e7c c561                                cmp lowtr
 17324  7e7e d0ea                                bne l264_3                               ; no- use these link bytes to find next line
 17325                          
 17326  7e80 a524                                lda index                                ; yes- copy pointer
 17327  7e82 a625                                ldx index+1
 17328  7e84 8561                                sta lowtr
 17329  7e86 8662                                stx lowtr+1
 17330                          ; bra AutoScrollprint ; print the line & exit
 17331                          
 17332                          ; .page
 17333                          AutoScrollprint
 17334  7e88 a002                                ldy #2                                   ; get line number to print
 17335  7e8a 20ad22                              jsr indlow
 17336  7e8d aa                                  tax
 17337  7e8e c8                                  iny
 17338  7e8f 20ad22                              jsr indlow
 17339  7e92 207733                              jsr p1line                               ; print the number & the line
 17340                          ; bra AutoScrolldone ;Normal exit
 17341                          
 17342                          AutoScrolldone
 17343  7e95 207dff                              jsr _primm                               ; kill special Editor modes
 17344  7e98 1b1b00                              !text esc,esc,0
 17345  7e9b a67f                                ldx point                                ; restore cursor position
 17346  7e9d a480                                ldy point+1
 17347  7e9f 18                                  clc
 17348  7ea0 20f0ff                              jsr _plot
 17349  7ea3 1755                                rmb1 helper                              ; remove LINGET flag
 17350  7ea5 68                                  pla                                      ; restore character
 17351  7ea6 18                                  clc                                      ; return to Editor, with flag we handled character
 17352  7ea7 60                                  rts
 17353                          
 17354                          AutoSearch
 17355  7ea8 a000                                ldy #0                                   ; search for any line number on screen in leftmost column
 17356  7eaa 18                                  clc
 17357  7eab 20f0ff                              jsr _plot                                ; move to beginning of next line
 17358                          ; bcs AutoScrollpop ;  exit if no more lines
 17359  7eae b02a                                bcs l265_4                               ; no more lines- fake one   [910716]
 17360  7eb0 38                                  sec
 17361  7eb1 20f0ff                              jsr _plot                                ; else check if wrapped line
 17362  7eb4 b018                                bcs l265_1                               ; it's wrapped- move up one line
 17363  7eb6 a5e0                                lda _pnt
 17364  7eb8 65e6                                adc _screen_left                         ; (.c=0)
 17365  7eba 853d                                sta txtptr                               ; copy screen address of logical line to txtptr
 17366  7ebc a5e1                                lda _pnt+1
 17367  7ebe 6900                                adc #0
 17368  7ec0 853e                                sta txtptr+1
 17369  7ec2 a000                                ldy #0                                   ; get first character on this line in window
 17370  7ec4 b13d                                lda (txtptr),y
 17371                          ; jsr indtxt  ;    (I did not want to limit search to the first column,
 17372  7ec6 c93a                                cmp #'9'+1                               ; but it was way too slow searching the entire screen)
 17373  7ec8 b004                                bcs l265_1                               ; it's not a number
 17374  7eca c930                                cmp #'0'
 17375  7ecc b008                                bcs l265_3                               ; it's a digit 0-9, continue
 17376                          
 17377  7ece ff3f02             l265_1           bbs7 form,l265_2                         ; not on this line- move to next line
 17378  7ed1 ca                                  dex                                      ; move up one line
 17379  7ed2 89                                  !text $89
 17380  7ed3 e8                 l265_2           inx                                      ; move down one line
 17381  7ed4 80d2                                bra AutoSearch                           ; loop until we find a numeric digit or run out of lines
 17382                          
 17383  7ed6 18                 l265_3           clc                                      ; found a digit, get entire number into linnum & rts
 17384  7ed7 8355b3                              +lbra linget
 17385                          
 17386  7eda a9ff               l265_4           lda #$ff                                 ; no line found, fake end of program   [910716]
 17387  7edc 8517                                sta linnum+1
 17388  7ede 60                                  rts
 17389                          
 17390                          ; .ifgt *-$7f00
 17391                          ; .messg ***ROM OVERFLOW: $7F00
 17392                          ; .endif
 17393                          ;.end
 17394                          ; .page
 17395                          ; .subttl  GRAPHIC Interface
 17396                          
 17397                                           * = $af00                                ; [911001]
 17398                          
 17399                          ;*****************************************************************
 17400                          ; SCREEN DEF      define a screen
 17401                          ; SCREEN SET  set draw, view screen
 17402                          ; SCREEN CLR  clear a screen
 17403                          ; SCREEN OPEN  open a screen
 17404                          ; SCREEN CLOSE  close a screen
 17405                          ;*****************************************************************
 17406                          
 17407                          Screen
 17408  af00 c99f                                cmp #open_token                          ; else dispatch per secondary token...
 17409  af02 f39200                              +lbeq ScreenOpen
 17410  af05 c9a0                                cmp #close_token
 17411  af07 f39e00                              +lbeq ScreenClose
 17412  af0a c996                                cmp #def_token
 17413  af0c f058                                beq ScreenDef
 17414  af0e c99c                                cmp #clr_token
 17415  af10 f020                                beq ScreenClr
 17416                          
 17417  af12 2016b5                              jsr chkesc                               ; [910930]
 17418                          ; cmp #esc_command_token
 17419                          ; bne l266_1
 17420                          ; jsr chrget  ; get past escape token
 17421  af15 c92d                                cmp #set_token
 17422  af17 f02f                                beq ScreenSet
 17423  af19 832f7f             l266_1           +lbra snerr                              ; report syntax error
 17424                          
 17425                          ; .page
 17426                          CheckGraphicMode
 17427  af1c 2c4b1f                              bit $1f4b                                ; Check draw screen allocation   [910711]
 17428  af1f 3001                                bmi NoGraphicArea
 17429  af21 60                                  rts                                      ; ok
 17430                          
 17431                          
 17432                          NoGraphicArea
 17433  af22 a223                                ldx #errng                               ; bad- no graphic area????
 17434  af24 83297f                              +lbra error
 17435                          
 17436                          
 17437                          RestoreTextScreen                                          ; [910404]
 17438  af27 a9ff                                lda #$ff                                 ; [910930]
 17439  af29 8d001f                              sta GKI__parm1                           ; leave drawscreen as is
 17440  af2c 8d011f                              sta GKI__parm2                           ; set viewscreen to text
 17441  af2f 6c0e80                              jmp ($800e)                              ; kg65.screen
 17442                          
 17443                          ; lda vic+49  ;Check graphic screen allocation
 17444                          ; and #%00010000
 17445                          ; beq 99$   ; we're in text mode
 17446                          ;; bit $1f43
 17447                          ;; bmi NoGraphicArea
 17448                          ;
 17449                          ; sei
 17450                          ; lda #$80
 17451                          ; bit _mode  ;40/80 mode, 0=80 128=40
 17452                          ; bmi l267_1
 17453                          ;
 17454                          ; tsb vic+49  ; 80
 17455                          ; lda #1
 17456                          ; trb vic+22  ;  fix x-scroll register
 17457                          ; bra 99$
 17458                          ;
 17459                          ;l267_1 trb vic+49  ; 40
 17460                          ; lda #1
 17461                          ; tsb vic+22  ;  fix x-scroll register
 17462                          ;
 17463                          ;99$ cli
 17464                          ;; lda #0
 17465                          ;; sta _graphm  ;text mode????
 17466                          ; rts
 17467                          
 17468                          ; .page
 17469                          ;*****************************************************************
 17470                          ; SCNCLR  clear a text or graphic screen
 17471                          ;
 17472                          ;  Syntax : SCNCLR  [ColorReg]
 17473                          ;
 17474                          ; if [ColorReg] not specified, clears text screen
 17475                          ; else clears the graphic screen with given value.
 17476                          ;*****************************************************************
 17477                          
 17478                          ScreenClr
 17479  af32 208322                              jsr chrget                               ; eat token & fall into SCNCLR
 17480                          
 17481                          scnclr
 17482  af35 d005                                bne C65__screenclear                     ; have a parameter, go clear graphic screen
 17483                          
 17484  af37 a993                                lda #$93
 17485  af39 4cd2ff                              jmp _bsout                               ; no parameter, clear text screen
 17486                          ; rts
 17487                          
 17488                          
 17489                          
 17490                          ;*****************************************************************
 17491                          ;* SCREEN CLR  clear a graphic screen
 17492                          ;*
 17493                          ;*  Syntax : SCREEN CLR  color_reg#
 17494                          ;*
 17495                          ;*           parm1 = color reg#  0-255
 17496                          ;*****************************************************************
 17497                          
 17498                          C65__screenclear
 17499  af3c 206c5d                              jsr getbyt                               ; get color register # (range 0-255)?????
 17500                          ;limit to range allowed by current screen def?
 17501  af3f 8e001f                              stx GKI__parm1
 17502  af42 201caf                              jsr CheckGraphicMode
 17503  af45 6c0c80                              jmp ($800c)                              ; bra screenclear
 17504                          
 17505                          ; .page
 17506                          ;*****************************************************************
 17507                          ;* SCREEN SET  specify draw & view screens
 17508                          ;*
 17509                          ;*  Syntax : SCREEN SET  [DrawScreen] [,ViewScreen]
 17510                          ;*
 17511                          ;*           parm1 = draw screen # 0-3, 255=don't change    [910711]
 17512                          ;*           parm2 = view screen # 0-3, 255=text
 17513                          ;*****************************************************************
 17514                          
 17515                          ScreenSet
 17516  af48 208322                              jsr chrget                               ; advance past token
 17517                          
 17518                          C65__screen
 17519                          ; beq snerr  ;missing args??      [911017]
 17520  af4b a2ff                                ldx #255                                 ; [911028]
 17521  af4d c92c                                cmp #','
 17522  af4f f003                                beq l267_1                               ; options byte only
 17523                          
 17524  af51 206c5d                              jsr getbyt                               ; get draw screen# in .x
 17525                          ; cpx #4   ;       [910711]
 17526                          ; bcs 20$   ;  out of range error???? (255=leave alone)  [910930]
 17527  af54 8e001f             l267_1           stx GKI__parm1
 17528                          
 17529  af57 ae691f                              ldx $1f69                                ; current viewscreen     [911017]
 17530  af5a 202679                              jsr optbyt                               ; eat a comma, get view screen# in .x
 17531                          ; cpx #4   ;
 17532                          ;20$ bcs fcerr  ;  out of range error???? (255=text)   [910930]
 17533  af5d 8e011f                              stx GKI__parm2
 17534                          
 17535  af60 220e80                              jsr ($800e)                              ; kg65.screen
 17536  af63 b0bd                                bcs NoGraphicArea
 17537  af65 60                                  rts
 17538                          
 17539                          ; .page
 17540                          ;*****************************************************************
 17541                          ;* SCREEN DEF  define a graphic screen
 17542                          ;*
 17543                          ;*  Syntax : SCREEN DEF  screen#, width, height, depth
 17544                          ;*
 17545                          ;*           parm1 = screen#           0-3    [910711]
 17546                          ;*           parm2 = width             0=320, 1=640, 2=1280
 17547                          ;*           parm3 = height            0=200, 1=400
 17548                          ;*           parm4 = depth             1-8 bitplanes (2-256 colors)
 17549                          ;*****************************************************************
 17550                          
 17551                          ScreenDef
 17552  af66 208322                              jsr chrget                               ; advance past token
 17553                          
 17554                          C65__screendef
 17555  af69 206c5d                              jsr getbyt                               ; get screen number
 17556  af6c e004                                cpx #4                                   ; range 0-3   [910711]
 17557  af6e b01d                                bcs l268_1
 17558  af70 8e001f                              stx GKI__parm1                           ; screen#
 17559                          
 17560  af73 20825d                              jsr combyt                               ; get width
 17561  af76 e003                                cpx #3                                   ; range 0-2 ???? 1280 mode ????
 17562  af78 b013                                bcs l268_1
 17563  af7a 8e011f                              stx GKI__parm2                           ; width
 17564                          
 17565  af7d 20825d                              jsr combyt                               ; get height
 17566  af80 e002                                cpx #2                                   ; range 0-1
 17567  af82 b009                                bcs l268_1
 17568  af84 8e021f                              stx GKI__parm3                           ; height
 17569                          
 17570  af87 20825d                              jsr combyt                               ; get depth (# bitplanes)
 17571  af8a ca                                  dex                                      ; convert 1-8 to 0-7
 17572  af8b e008                                cpx #8                                   ; range 0-7
 17573  af8d b36fa2             l268_1           +lbcs fcerr                              ; illegal quantity error
 17574  af90 8e031f                              stx GKI__parm4                           ; depth
 17575                          
 17576  af93 6c0680                              jmp ($8006)                              ; bra screendef
 17577                          
 17578                          ; .page
 17579                          ;*****************************************************************
 17580                          ;* SCREEN OPEN  open a graphic screen for viewing or drawing
 17581                          ;*
 17582                          ;*  Syntax : SCREEN OPEN screen#
 17583                          ;*
 17584                          ;*           parm1 = screen#      0-3    [910711]
 17585                          ;*****************************************************************
 17586                          
 17587                          
 17588                          ScreenOpen
 17589  af96 208322                              jsr chrget                               ; advance past Open token
 17590                          
 17591                          C65__screenopen
 17592  af99 206c5d                              jsr getbyt                               ; get screen# in .x
 17593  af9c e004                                cpx #4                                   ; range 0-3   [910711]
 17594  af9e b35ea2                              +lbcs fcerr                              ; branch if out of range
 17595                          
 17596  afa1 8e001f                              stx GKI__parm1
 17597  afa4 6c0880                              jmp ($8008)                              ; screenopen    [910826]
 17598                          
 17599                          ; bcs NoGraphicArea ; bad ???? let user catch via RGRAPHIC
 17600                          ; rts
 17601                          
 17602                          ; .page
 17603                          ;*****************************************************************
 17604                          ;* SCREEN CLOSE  close a graphic screen
 17605                          ;*
 17606                          ;*  Syntax : SCREEN CLOSE screen#
 17607                          ;*
 17608                          ;*           parm1 = screen#  0-3    [910711]
 17609                          ;*****************************************************************
 17610                          
 17611                          
 17612                          ScreenClose
 17613  afa7 208322                              jsr chrget                               ; advance past Close token
 17614                          
 17615                          C65__screenclose
 17616  afaa 206c5d                              jsr getbyt                               ; get screen#
 17617  afad e004                                cpx #4                                   ; range 0-3   [910711]
 17618  afaf b34da2                              +lbcs fcerr                              ; branch if out of range
 17619  afb2 8e001f                              stx GKI__parm1
 17620                          
 17621  afb5 6c0a80                              jmp ($800a)                              ; bra screenclose
 17622                          
 17623                          ; .page
 17624                          ;*****************************************************************
 17625                          ;* PEN
 17626                          ;*
 17627                          ;*  Syntax : PEN  Pen#, ColorReg
 17628                          ;*
 17629                          ;*           parm1 = pen#  0-2
 17630                          ;*           parm2 = color reg#  0-255
 17631                          ;*****************************************************************
 17632                          
 17633                          C65__setpen
 17634  afb8 206c5d                              jsr getbyt                               ; get pen#
 17635  afbb e003                                cpx #3                                   ; range 0-2
 17636  afbd b33fa2                              +lbcs fcerr                              ; branch if out of range
 17637  afc0 8e001f                              stx GKI__parm1
 17638                          
 17639  afc3 20825d                              jsr combyt                               ; get color reg#
 17640                          ;???? error check for max color allowed
 17641                          ; for the current screen.
 17642  afc6 8e011f                              stx GKI__parm2
 17643                          
 17644  afc9 6c1080                              jmp ($8010)                              ; bra setpen
 17645                          
 17646                          ; .page
 17647                          ;*****************************************************************
 17648                          ;* DMODE   Set Draw Mode
 17649                          ;*
 17650                          ;*  Syntax : DMODE  jam, complement, stencil, style, thickness
 17651                          ;*
 17652                          ;*         parm1 = jam           0-1
 17653                          ;*         parm2 = complement (XOR) 0-1
 17654                          ;*         parm3 = stencil       0-1  <<< not implemented  [911003]
 17655                          ;*         parm4 = style         0-3  <<< only 0-1 implemented [911003]
 17656                          ;*         parm5 = thickness     1-8  <<< not implemented  [911003]
 17657                          ;*******************************************************************
 17658                          
 17659                          C65__setdmode
 17660  afcc 206c5d                              jsr getbyt                               ; jam mode
 17661  afcf e002                                cpx #2
 17662  afd1 b026                                bcs l269_1
 17663  afd3 8e001f                              stx GKI__parm1
 17664                          
 17665  afd6 20825d                              jsr combyt                               ; complement (xor) mode
 17666  afd9 e002                                cpx #2                                   ; (ignores jam mode if set)
 17667  afdb b01c                                bcs l269_1
 17668  afdd 8e011f                              stx GKI__parm2
 17669                          
 17670  afe0 20825d                              jsr combyt                               ; stencil mode (not implemented)
 17671  afe3 e002                                cpx #2
 17672  afe5 b012                                bcs l269_1
 17673  afe7 8e021f                              stx GKI__parm3
 17674                          
 17675  afea 20825d                              jsr combyt                               ; style mode
 17676  afed e004                                cpx #4                                   ; 0=solid, 1=pattern, 2=tile (not implemented), 3=reserved
 17677  afef b008                                bcs l269_1
 17678  aff1 8e031f                              stx GKI__parm4
 17679                          
 17680  aff4 20825d                              jsr combyt                               ; thickness mode (not implemented)
 17681                          ; dex   ; adjust to 0-7     [911003]
 17682  aff7 e009                                cpx #8+1
 17683  aff9 b303a2             l269_1           +lbcs fcerr                              ; illegal quantity error
 17684  affc 8e041f                              stx GKI__parm5
 17685                          
 17686  afff 6c1480                              jmp ($8014)                              ; bra setdmode
 17687                          
 17688                          ; .page
 17689                          ;*****************************************************************
 17690                          ;* DPAT   set draw pattern
 17691                          ;*
 17692                          ;*  Syntax : DPAT  type [, # bytes, byte1, byte2, byte3, byte4]
 17693                          ;*
 17694                          ;*           parm1 = type        0-63  <<< only 0-4 implemented [911003]
 17695                          ;*           parm2 = # bytes     1-4
 17696                          ;*           parm3 = byte1       0-255
 17697                          ;*           parm4 = byte2       0-255
 17698                          ;*           parm5 = byte3       0-255
 17699                          ;*           parm6 = byte4       0-255
 17700                          ;*****************************************************************
 17701                          
 17702                          C65__setdpat
 17703  b002 206c5d                              jsr getbyt                               ; get pattern type
 17704  b005 e005                                cpx #4+1                                 ; 63+1       [911028]
 17705  b007 b3f5a1             l270_1           +lbcs fcerr                              ; if out of range
 17706  b00a 8e001f                              stx GKI__parm1
 17707  b00d 8a                                  txa
 17708  b00e d033                                bne l270_2                               ; if parm1 is 0 then get extra stuff
 17709                          
 17710  b010 20825d                              jsr combyt                               ; get number of bytes
 17711  b013 e005                                cpx #5
 17712  b015 b0f0                                bcs l270_1                               ; too many bytes
 17713  b017 8e011f                              stx GKI__parm2
 17714  b01a 8676                                stx z_p_temp_1                           ; save for count
 17715                          
 17716  b01c 20825d                              jsr combyt                               ; get byte 1
 17717  b01f 8e021f                              stx GKI__parm3
 17718  b022 c676                                dec z_p_temp_1
 17719  b024 f01d                                beq l270_2
 17720  b026 33d6a1                              +lbmi fcerr                              ; too few bytes
 17721                          
 17722  b029 20825d                              jsr combyt                               ; get byte 2
 17723  b02c 8e031f                              stx GKI__parm4
 17724  b02f c676                                dec z_p_temp_1
 17725  b031 f010                                beq l270_2
 17726                          
 17727  b033 20825d                              jsr combyt                               ; get byte 3
 17728  b036 8e041f                              stx GKI__parm5
 17729  b039 c676                                dec z_p_temp_1
 17730  b03b f006                                beq l270_2
 17731                          
 17732  b03d 20825d                              jsr combyt                               ; get byte 4
 17733  b040 8e051f                              stx GKI__parm6
 17734                          
 17735  b043 6c1680             l270_2           jmp ($8016)                              ; bra setdpat
 17736                          
 17737                          ; .page
 17738                          ;*****************************************************************
 17739                          ;* PALETTE   set palette colors
 17740                          ;*
 17741                          ;*  Syntax : PALETTE {screen|COLOR}, color_index, red, green, blue
 17742                          ;*           PALETTE RESTORE
 17743                          ;*
 17744                          ;*           parm1 = screen  0-3     [910711]
 17745                          ;*           parm2 = color_index 0-255
 17746                          ;*           parm3 = red           0-31 (b0-3 red, b4=fgbg)  [910520]
 17747                          ;*           parm4 = green         0-15
 17748                          ;*           parm5 = blue          0-15
 17749                          ;*****************************************************************
 17750                          
 17751                          C65__setpalette
 17752  b046 c98c                                cmp #restore_token                       ; restore palette?
 17753  b048 d006                                bne l271_1                               ; no
 17754  b04a 208322                              jsr chrget                               ; yes- advance past Restore token
 17755  b04d 4c27e0                              jmp _palette_init
 17756                          
 17757  b050 c9e7               l271_1           cmp #color_token                         ; set physical color register?
 17758  b052 d00b                                bne l271_2                               ; no- set logical color register
 17759  b054 8d001f                              sta GKI__parm1
 17760  b057 208322                              jsr chrget                               ; yes- advance past Color token
 17761  b05a 206c5d                              jsr getbyt
 17762  b05d 800e                                bra l271_3
 17763                          
 17764  b05f 206c5d             l271_2           jsr getbyt                               ; get screen#
 17765  b062 e004                                cpx #4                                   ; [910711]
 17766  b064 b398a1                              +lbcs fcerr
 17767  b067 8e001f                              stx GKI__parm1
 17768                          
 17769  b06a 20825d                              jsr combyt                               ; get color reg #
 17770  b06d 8e011f             l271_3           stx GKI__parm2                           ; (GKI will check for out of range????)
 17771                          
 17772                          set_palette
 17773  b070 20825d                              jsr combyt                               ; get red & fgbg
 17774  b073 e020                                cpx #32                                  ; [910520]
 17775  b075 b387a1                              +lbcs fcerr
 17776  b078 8e021f                              stx GKI__parm3
 17777                          
 17778  b07b 200ab5                              jsr getcomnyb                            ; get green
 17779                          ; cpx #16
 17780                          ; bcs 10$
 17781  b07e 8e031f                              stx GKI__parm4
 17782                          
 17783  b081 200ab5                              jsr getcomnyb                            ; get blue
 17784                          ; cpx #16
 17785                          ; bcs fcerr  ; illegal quantity error
 17786  b084 8e041f                              stx GKI__parm5
 17787                          
 17788  b087 ad001f                              lda GKI__parm1                           ; logical or physical color register?
 17789  b08a 1017                                bpl l272_1                               ; logical
 17790  b08c ae011f                              ldx GKI__parm2
 17791  b08f ad021f                              lda GKI__parm3                           ; physical
 17792  b092 9d00d1                              sta _red,x
 17793  b095 ad031f                              lda GKI__parm4
 17794  b098 9d00d2                              sta _green,x
 17795  b09b ad041f                              lda GKI__parm5
 17796  b09e 9d00d3                              sta _blue,x
 17797  b0a1 8006                                bra l272_2
 17798                          
 17799  b0a3 221280             l272_1           jsr ($8012)                              ; go set screen palette
 17800  b0a6 b37afe                              +lbcs NoGraphicArea                      ; illegal screen# or color#  [910917]
 17801                          
 17802  b0a9 202679             l272_2           jsr optbyt                               ; get another color reg # ?
 17803  b0ac 8e011f                              stx GKI__parm2
 17804  b0af b0bf                                bcs set_palette                          ; yes- loop
 17805  b0b1 60                                  rts
 17806                          
 17807                          ; .page
 17808                          ;*****************************************************************
 17809                          ;* LINE  draw a dot, a line or a stick shape
 17810                          ;*
 17811                          ;*  Syntax : LINE  x0, y0 [,[x1] [,y1]]...
 17812                          ;*
 17813                          ;* parm1,2 = x0 (lo/hi)
 17814                          ;* parm3,4 = y0
 17815                          ;* parm5,6 = x1 (x1,y1)=(x0,y0) if not specified
 17816                          ;* parm7,8 = y1
 17817                          ;*****************************************************************
 17818                          
 17819                          C65__line
 17820  b0b2 c984                                cmp #input_token                         ; special check for 'line input#'  [910103]
 17821  b0b4 f3e687                              +lbeq linputn                            ; yes
 17822  b0b7 c985                                cmp #input_token+1                       ; special check for 'line input'
 17823  b0b9 f3ff87                              +lbeq linput                             ; yes
 17824                          
 17825  b0bc 201caf                              jsr CheckGraphicMode
 17826  b0bf 20e5b7                              jsr sadwrd                               ; get x0
 17827  b0c2 8c001f                              sty GKI__parm1
 17828  b0c5 8d011f                              sta GKI__parm2
 17829  b0c8 8c041f                              sty GKI__parm5                           ; [910228]
 17830  b0cb 8d051f                              sta GKI__parm6
 17831                          
 17832  b0ce 200879                              jsr comsad                               ; get y0
 17833  b0d1 8c021f                              sty GKI__parm3
 17834  b0d4 8d031f                              sta GKI__parm4
 17835  b0d7 8c061f                              sty GKI__parm7                           ; [910228]
 17836  b0da 8d071f                              sta GKI__parm8
 17837                          
 17838  b0dd 200e79                              jsr optsad                               ; get x1     [910228]
 17839  b0e0 9006                                bcc l273_2                               ; use x0
 17840  b0e2 8c041f             l273_1           sty GKI__parm5
 17841  b0e5 8d051f                              sta GKI__parm6
 17842                          
 17843  b0e8 200e79             l273_2           jsr optsad                               ; get y1     [910228]
 17844  b0eb 9006                                bcc l273_3                               ; use y0
 17845  b0ed 8c061f                              sty GKI__parm7
 17846  b0f0 8d071f                              sta GKI__parm8
 17847                          
 17848  b0f3 221880             l273_3           jsr ($8018)                              ; draw a line from x0,y0 to x1,y1
 17849                          
 17850  b0f6 a203                                ldx #3
 17851  b0f8 bd041f             l273_4           lda GKI__parm5,x                         ; copy x1,y1 to x0,y0
 17852  b0fb 9d001f                              sta GKI__parm1,x
 17853  b0fe ca                                  dex
 17854  b0ff 10f7                                bpl l273_4
 17855                          
 17856  b101 200e79                              jsr optsad                               ; more?
 17857  b104 b0dc                                bcs l273_1                               ; yes, continue
 17858  b106 60                                  rts
 17859                          
 17860                          ; .page
 17861                          ;*****************************************************************
 17862                          ;* BOX   draw a 4-sided figure
 17863                          ;*
 17864                          ;*  Syntax :  BOX x0,y0, x1,y1, x2,y2, x3,y3 [,solid flag]
 17865                          ;*
 17866                          ;* parm1,2   = x0  (lo/hi)
 17867                          ;* parm3,4   = y0
 17868                          ;* parm5,6   = x1
 17869                          ;* parm7,8   = y1
 17870                          ;* parm9,10  = x2
 17871                          ;* parm11,12 = y2
 17872                          ;* parm13,14 = x3
 17873                          ;* parm15,16 = y3
 17874                          ;* parm17    = solid flag
 17875                          ;*****************************************************************
 17876                          
 17877                          C65__box
 17878  b107 201caf                              jsr CheckGraphicMode
 17879  b10a 20e5b7                              jsr sadwrd                               ; get x0
 17880  b10d 8c001f                              sty GKI__parm1
 17881  b110 8d011f                              sta GKI__parm2
 17882                          
 17883  b113 200879                              jsr comsad                               ; get y0
 17884  b116 8c021f                              sty GKI__parm3
 17885  b119 8d031f                              sta GKI__parm4
 17886                          
 17887  b11c 200879                              jsr comsad                               ; get x1
 17888  b11f 8c041f                              sty GKI__parm5
 17889  b122 8d051f                              sta GKI__parm6
 17890                          
 17891  b125 200879                              jsr comsad                               ; get y1
 17892  b128 8c061f                              sty GKI__parm7
 17893  b12b 8d071f                              sta GKI__parm8
 17894                          
 17895  b12e 200879                              jsr comsad                               ; get x2
 17896  b131 8c081f                              sty GKI__parm9
 17897  b134 8d091f                              sta GKI__parm10
 17898                          
 17899  b137 200879                              jsr comsad                               ; get y2
 17900  b13a 8c0a1f                              sty GKI__parm11
 17901  b13d 8d0b1f                              sta GKI__parm12
 17902                          
 17903  b140 200879                              jsr comsad                               ; get x3
 17904  b143 8c0c1f                              sty GKI__parm13
 17905  b146 8d0d1f                              sta GKI__parm14
 17906                          
 17907  b149 200879                              jsr comsad                               ; get y3
 17908  b14c 8c0e1f                              sty GKI__parm15
 17909  b14f 8d0f1f                              sta GKI__parm16
 17910                          
 17911  b152 202479                              jsr optzer                               ; get solid flag
 17912  b155 8e101f                              stx GKI__parm17
 17913                          
 17914  b158 6c1a80                              jmp ($801a)                              ; bra box
 17915                          
 17916                          ; .page
 17917                          ;*****************************************************************
 17918                          ;* CIRCLE   draw a Circle
 17919                          ;*
 17920                          ;*  Syntax : CIRCLE  CenterX, CenterY, radius [,solid flag]
 17921                          ;*
 17922                          ;*         parm1 = center x lo
 17923                          ;*         parm2 = center x hi
 17924                          ;*         parm3 = center y lo
 17925                          ;*         parm4 = center y hi
 17926                          ;*         parm5 = radius lo
 17927                          ;*         parm6 = radius hi
 17928                          ;*         parm7 = solid flag 0=no, 1=yes
 17929                          ;*****************************************************************
 17930                          
 17931                          C65__circle
 17932  b15b 201caf                              jsr CheckGraphicMode
 17933  b15e 20e5b7                              jsr sadwrd                               ; get center x
 17934  b161 8c001f                              sty GKI__parm1
 17935  b164 8d011f                              sta GKI__parm2
 17936                          
 17937  b167 200879                              jsr comsad                               ; get center y
 17938  b16a 8c021f                              sty GKI__parm3
 17939  b16d 8d031f                              sta GKI__parm4
 17940                          
 17941  b170 200879                              jsr comsad                               ; get radius
 17942  b173 8c041f                              sty GKI__parm5
 17943  b176 8d051f                              sta GKI__parm6
 17944                          
 17945  b179 202479                              jsr optzer                               ; get solid flag
 17946  b17c e002                                cpx #2
 17947  b17e b37ea0                              +lbcs fcerr
 17948  b181 8e061f                              stx GKI__parm7
 17949                          
 17950  b184 6c1c80                              jmp ($801c)                              ; bra circle
 17951                          
 17952                          ; .page
 17953                          ; .subttl  ELLIPSE
 17954                          
 17955                          ;*****************************************************************
 17956                          ;* ELLIPSE   draw an Ellipse
 17957                          ;*
 17958                          ;*  Syntax : ELLIPSE  CenterX, CenterY, RadiusX,  RadiusY  [,solid flag]
 17959                          ;*
 17960                          ;*         parm1 = center x lo
 17961                          ;*         parm2 = center x hi
 17962                          ;*         parm3 = center y lo
 17963                          ;*         parm4 = center y hi
 17964                          ;*         parm5 = x radius lo
 17965                          ;*         parm6 = x radius hi
 17966                          ;*         parm7 = y radius lo
 17967                          ;*         parm8 = y radius hi
 17968                          ;*         parm9 = solid flag 0-1
 17969                          ;*****************************************************************
 17970                          
 17971                          C65__ellipse
 17972  b187 201caf                              jsr CheckGraphicMode
 17973  b18a 20e5b7                              jsr sadwrd                               ; get center x
 17974  b18d 8c001f                              sty GKI__parm1
 17975  b190 8d011f                              sta GKI__parm2
 17976                          
 17977  b193 200879                              jsr comsad                               ; get center y
 17978  b196 8c021f                              sty GKI__parm3
 17979  b199 8d031f                              sta GKI__parm4
 17980                          
 17981  b19c 200879                              jsr comsad                               ; get xradius
 17982  b19f 8c041f                              sty GKI__parm5
 17983  b1a2 8d051f                              sta GKI__parm6
 17984                          
 17985  b1a5 200879                              jsr comsad                               ; get yradius
 17986  b1a8 8c061f                              sty GKI__parm7
 17987  b1ab 8d071f                              sta GKI__parm8
 17988                          
 17989  b1ae 202479                              jsr optzer                               ; get solid flag
 17990  b1b1 e002                                cpx #2
 17991  b1b3 b349a0                              +lbcs fcerr
 17992  b1b6 8e081f                              stx GKI__parm9
 17993                          
 17994  b1b9 6c2080                              jmp ($8020)                              ; bra ellipse
 17995                          
 17996                          ; .page
 17997                          ; .subttl  POLYGON
 17998                          
 17999                          ;*****************************************************************
 18000                          ;* POLYGON   draw a regular n-sided Polygon
 18001                          ;*
 18002                          ;*  POLYGON  X,Y, Xradius, Yradius, sides [,drawsides [,subtend [,angle [,solid] ]]]
 18003                          ;*
 18004                          ;*         parm1 = center x lo
 18005                          ;*         parm2 = center x hi
 18006                          ;*         parm3 = center y lo
 18007                          ;*         parm4 = center y hi
 18008                          ;*         parm5 = xradius lo
 18009                          ;*         parm6 = xradius hi
 18010                          ;*         parm7 = yradius lo
 18011                          ;*         parm8 = yradius hi
 18012                          ;*         parm9 = solid flag 0-1
 18013                          ;*         parm10 = sa lo (starting angle 0-360)
 18014                          ;*         parm11 = sa hi
 18015                          ;*         parm12 = # of sides to draw (1 to 127)
 18016                          ;*         parm13 = # of sides (3 to parm12)
 18017                          ;*         parm14 = subtend flag 0-1
 18018                          ;****************************************************************
 18019                          
 18020                          C65__polygon                                              ; changed BASIC syntax to something more reasonable [910923] FAB
 18021  b1bc 201caf                              jsr CheckGraphicMode
 18022  b1bf 20e5b7                              jsr sadwrd                               ; get center x
 18023  b1c2 8c001f                              sty GKI__parm1
 18024  b1c5 8d011f                              sta GKI__parm2
 18025                          
 18026  b1c8 200879                              jsr comsad                               ; get center y
 18027  b1cb 8c021f                              sty GKI__parm3
 18028  b1ce 8d031f                              sta GKI__parm4
 18029                          
 18030  b1d1 20875d                              jsr comwrd                               ; get x radius
 18031  b1d4 8c041f                              sty GKI__parm5
 18032  b1d7 8d051f                              sta GKI__parm6
 18033                          
 18034  b1da 20875d                              jsr comwrd                               ; get y radius
 18035  b1dd 8c061f                              sty GKI__parm7
 18036  b1e0 8d071f                              sta GKI__parm8
 18037                          
 18038  b1e3 20825d                              jsr combyt                               ; get number of sides
 18039  b1e6 e003                                cpx #3
 18040  b1e8 900d                                bcc l274_2                               ; too few
 18041  b1ea e080                                cpx #128
 18042  b1ec b310a0             l274_1           +lbcs fcerr                              ; too many
 18043  b1ef 8e0c1f                              stx GKI__parm13
 18044                          
 18045                          ; ldx GKI__parm13  ;get number of sides to draw (default=#sides)
 18046  b1f2 202679                              jsr optbyt
 18047  b1f5 e001                                cpx #1                                   ; must be at least 1 side
 18048  b1f7 9305a0             l274_2           +lbcc fcerr
 18049  b1fa 8e0b1f                              stx GKI__parm12
 18050  b1fd ca                                  dex
 18051  b1fe ec0c1f                              cpx GKI__parm13                          ; draw sides must be <= #sides
 18052  b201 b0e9                                bcs l274_1
 18053                          
 18054  b203 202479                              jsr optzer                               ; get subtend flag
 18055                          ; cpx #2
 18056                          ; bcs l274_1
 18057  b206 8e0d1f                              stx GKI__parm14
 18058                          
 18059  b209 20f278                              jsr optwrd                               ; get starting angle (default=0 degrees)
 18060  b20c 8c091f                              sty GKI__parm10                          ; lo
 18061  b20f 8d0a1f                              sta GKI__parm11                          ; hi
 18062                          
 18063  b212 202479                              jsr optzer                               ; get solid flag
 18064                          ; cpx #2
 18065                          ; bcs l274_1
 18066  b215 8e081f                              stx GKI__parm9
 18067                          
 18068  b218 6c1e80                              jmp ($801e)                              ; bra polygon
 18069                          
 18070                          ; .page
 18071                          ; .subttl  SET multipurpose command
 18072                          
 18073                          ;  SET  A multipurpose command initiator
 18074                          
 18075                          
 18076                          C65__set
 18077  b21b c995                                cmp #verify_token                        ; SET VERIFY <ON | OFF>  new [910429]
 18078  b21d f39c00                              +lbeq verify_mode
 18079  b220 c996                                cmp #def_token                           ; SET DEF unit
 18080  b222 d00c                                bne l275_1
 18081  b224 2085b2                              jsr getdisknum_1
 18082  b227 8e0611                              stx _default_drive
 18083  b22a 8e8211                              stx dosfa                                ; Make last DOS device = current device
 18084  b22d 8353c6                              +lbra Clear_DS
 18085                          
 18086                          
 18087                          
 18088  b230 2016b5             l275_1           jsr chkesc                               ; Must be ESCape token
 18089  b233 c940                                cmp #disk_token                          ; ok so far
 18090  b235 d3047c                              +lbne bad_command                        ; unknown command
 18091                          
 18092                          
 18093                          
 18094                          
 18095  b238 2085b2                              jsr getdisknum_1                         ; SET DISK # [<,|TO> #]
 18096  b23b 8e8211                              stx dosfa                                ; got current disk unit #
 18097                          
 18098  b23e 208522                              jsr chrgot                               ; check delimiter (comma, 'TO', or eos)
 18099  b241 f33fc6                              +lbeq Clear_DS                           ; eos- just change DOS' current drive [910417]
 18100  b244 c92c                                cmp #','                                 ; not eos, must be comma or 'TO'
 18101  b246 f005                                beq l275_2
 18102  b248 c9a4                                cmp #to_token
 18103  b24a d3fe7b                              +lbne snerr
 18104                          
 18105  b24d 2085b2             l275_2           jsr getdisknum_1                         ; skip delimiter
 18106  b250 8e8811                              stx dosds2                               ; got new disk unit #
 18107                          
 18108                          
 18109                          ; .page
 18110                          ;  Open disk command channel & pass it 'renumber' command
 18111                          
 18112  b253 204171                              jsr dclall                               ; Close any open files????
 18113                          
 18114  b256 a205                                ldx #6-1
 18115  b258 bd7fb2             l275_3           lda disk_renum_cmd,x                     ; move command to RAM, setup for open
 18116  b25b 9d9111                              sta savram,x
 18117  b25e ca                                  dex
 18118  b25f 10f7                                bpl l275_3
 18119  b261 ad8811                              lda dosds2
 18120  b264 0920                                ora #32                                  ; make new # a talk/listen address
 18121  b266 8d9711                              sta savram+6
 18122  b269 ad8811                              lda dosds2
 18123  b26c 0940                                ora #64
 18124  b26e 8d9811                              sta savram+7
 18125                          
 18126  b271 a908                                lda #8                                   ; command string length
 18127  b273 2096b2                              jsr SendDiskCmd                          ; Send command
 18128  b276 ad8811                              lda dosds2
 18129  b279 8d8211                              sta dosfa                                ; Make last DOS device = current device
 18130  b27c 8394b6                              +lbra close_out_1                        ; common error check & exit path ????
 18131                          
 18132                          
 18133  b27f 4d2d57770002       disk_renum_cmd   !text "M-W",119,0,2                      ; Renumber Drive command
 18134                          
 18135                          ; .page
 18136                          
 18137                          ;  GetDiskNum - Get a (required) disk number and check it
 18138                          
 18139                          getdisknum_1
 18140  b285 208322                              jsr chrget                               ; skip current character
 18141                          getdisknum
 18142  b288 206c5d                              jsr getbyt                               ; get number in .x
 18143  b28b e008                                cpx #8                                   ; check range (8-30)
 18144  b28d 936f9f                              +lbcc fcerr
 18145  b290 e01f                                cpx #31
 18146  b292 b36a9f                              +lbcs fcerr
 18147  b295 60                                  rts                                      ; returns only if okay
 18148                          
 18149                          
 18150                          
 18151                          ;  SendDiskCmd - Send command in SAVRAM to disk, length in .A
 18152                          
 18153                          SendDiskCmd
 18154                          ; lda #   ; command string length
 18155  b296 a291                                ldx #<savram                             ; address
 18156  b298 a011                                ldy #>savram
 18157  b29a 20bdff                              jsr _setnam
 18158  b29d a200                                ldx #sys_bank                            ; ???? sysbank ????
 18159  b29f 206bff                              jsr _setbank
 18160  b2a2 20ccff                              jsr _clrch                               ; Restore normal channels, establish our's
 18161  b2a5 ae8211                              ldx dosfa                                ; fa
 18162  b2a8 a900                                lda #doslfn                              ; la (reserved la)
 18163  b2aa a06f                                ldy #$6f                                 ; sa (command channel)
 18164  b2ac 20baff                              jsr _setlfs
 18165  b2af 20c0ff                              jsr _open                                ; open channel & send command
 18166  b2b2 a900                                lda #doslfn                              ; close it already
 18167  b2b4 38                                  sec                                      ; not a real close
 18168  b2b5 20c3ff                              jsr _close
 18169  b2b8 83c8c5                              +lbra Clear_DS                           ; Exit
 18170                          
 18171                          ; .page
 18172                          ;  SET VERIFY <ON | OFF> Set DOS verify-after-write mode for 3.5" drives
 18173                          
 18174                          verify_mode
 18175  b2bb 208322                              jsr chrget                               ; eat 'verify' token, get next  new [910429]
 18176  b2be c991                                cmp #on_token
 18177  b2c0 38                                  sec
 18178  b2c1 f009                                beq l276_1                               ; turn verify on (.c=1)
 18179  b2c3 2016b5                              jsr chkesc
 18180  b2c6 c924                                cmp #off_token                           ; turn cursor off (.c=0)
 18181  b2c8 d3807b                              +lbne snerr
 18182  b2cb 18                                  clc
 18183                          
 18184                          ;  Open disk command channel & pass it 'verify' command
 18185                          
 18186  b2cc 08                 l276_1           php                                      ; Save mode
 18187  b2cd 2022b5                              jsr chkeos                               ; eat 'on/off' token, error if not eos
 18188                          
 18189  b2d0 a203                                ldx #4-1
 18190  b2d2 bdecb2             l276_2           lda verify_cmd,x                         ; move command to RAM, setup for open
 18191  b2d5 9d9111                              sta savram,x
 18192  b2d8 ca                                  dex
 18193  b2d9 10f7                                bpl l276_2
 18194                          
 18195  b2db a900                                lda #0                                   ; form on/off flag
 18196  b2dd 28                                  plp
 18197  b2de 2a                                  rol
 18198  b2df 0930                                ora #$30
 18199  b2e1 8d9511                              sta savram+4
 18200                          
 18201  b2e4 a905                                lda #5                                   ; command string length
 18202  b2e6 2096b2                              jsr SendDiskCmd                          ; Send command
 18203  b2e9 8327b6                              +lbra close_out_1                        ; common error check & exit path ????
 18204                          
 18205                          
 18206  b2ec 55303e56           verify_cmd       !text "U0>V"                             ; Verify on/off command
 18207                          
 18208                          ;.end
 18209                          ; .page
 18210                          ; .subttl  CHAR
 18211                          
 18212                          ;*****************************************************************
 18213                          ;* CHAR   draw a character string
 18214                          ;*
 18215                          ;*  Syntax : CHAR column, row, height, width, direction, "string" [,charsetadr [,bank]]
 18216                          ;*
 18217                          ;* parm1  = column#
 18218                          ;* parm2  = row lo
 18219                          ;* parm3  = row hi
 18220                          ;* parm4  = height
 18221                          ;* parm5  = width
 18222                          ;* parm6  = direction
 18223                          ;* parm7  = len of string
 18224                          ;* parm8  = lo addr of string
 18225                          ;* parm9  = hi addr of string
 18226                          ;* parm10 = lo addr of character set $29800 default
 18227                          ;* parm11 = hi addr of character set
 18228                          ;* parm12 = bank of character set   [910912]
 18229                          ;****************************************************************
 18230                          
 18231                          C65__char
 18232  b2f0 201caf                              jsr CheckGraphicMode
 18233  b2f3 206c5d                              jsr getbyt                               ; get column
 18234  b2f6 8e001f                              stx GKI__parm1
 18235                          
 18236  b2f9 200879                              jsr comsad                               ; get row
 18237  b2fc 8c011f                              sty GKI__parm2
 18238  b2ff 8d021f                              sta GKI__parm3
 18239                          
 18240  b302 20825d                              jsr combyt                               ; get height
 18241  b305 8e031f                              stx GKI__parm4
 18242                          
 18243  b308 20825d                              jsr combyt                               ; get width
 18244  b30b 8e041f                              stx GKI__parm5
 18245                          
 18246  b30e 20825d                              jsr combyt                               ; get direction
 18247  b311 8e051f                              stx GKI__parm6
 18248                          
 18249  b314 205b4e                              jsr chkcom
 18250  b317 20ef4c                              jsr frmevl                               ; evaluate the string
 18251  b31a 20dd4c                              jsr chkstr                               ; type mismatch error if not string
 18252  b31d a000                                ldy #0
 18253  b31f 20a922                              jsr indfmo                               ; pointer to string descriptor is left in the fac by frmevl
 18254  b322 8d061f                              sta GKI__parm7                           ; length  ???? check for null string ????
 18255  b325 48                                  pha
 18256  b326 c8                                  iny
 18257  b327 20a922                              jsr indfmo
 18258  b32a 8d071f                              sta GKI__parm8                           ; adrlo
 18259  b32d c8                                  iny
 18260  b32e 20a922                              jsr indfmo
 18261  b331 8d081f                              sta GKI__parm9                           ; adrhi
 18262  b334 206d5b                              jsr frefac                               ; [910917]
 18263  b337 68                                  pla
 18264  b338 20dd5b                              jsr getspa
 18265                          
 18266  b33b 20f278                              jsr optwrd                               ; get charset address (????bank)
 18267  b33e b004                                bcs l277_1                               ; given
 18268  b340 a000                                ldy #<$9800                              ; not given- use ROM as default   [910207] FAB
 18269  b342 a998                                lda #>$9800                              ; ???? uc/lc or graphic set ????
 18270  b344 8c091f             l277_1           sty GKI__parm10                          ; lo
 18271  b347 8d0a1f                              sta GKI__parm11                          ; hi
 18272  b34a a202                                ldx #2                                   ; default to ROM bank 2    [910912] FAB
 18273  b34c 202679                              jsr optbyt
 18274  b34f 8e0b1f                              stx GKI__parm12
 18275                          
 18276  b352 ad061f                              lda GKI__parm7                           ; ???? check for null string ????
 18277  b355 f003                                beq l277_2
 18278  b357 6c2c80                              jmp ($802c)                              ; bra kg65.char
 18279                          
 18280  b35a 60                 l277_2           rts
 18281                          
 18282                          ; .page
 18283                          ; .subttl  PAINT
 18284                          
 18285                          ;*****************************************************************
 18286                          ;* PAINT   fill a graphic area with color
 18287                          ;*
 18288                          ;*  Syntax : PAINT x, y [,mode [,color]]
 18289                          ;*
 18290                          ;* parm1  = x lo
 18291                          ;* parm2  = x lo
 18292                          ;* parm3  = y lo
 18293                          ;* parm4  = y hi
 18294                          ;* parm5  = mode
 18295                          ;* parm6  = color
 18296                          ;*
 18297                          ;* fill color is pen-A
 18298                          ; mode 0: fill region defined by color at x,y (default) new modes [910916] FAB
 18299                          ; mode 1: fill region using given color as boundary
 18300                          ; mode 2: fill connected region
 18301                          ;****************************************************************
 18302                          
 18303                          C65__paint                                                ; new [910228] FAB
 18304  b35b 201caf                              jsr CheckGraphicMode
 18305  b35e 20e5b7                              jsr sadwrd                               ; get x
 18306  b361 8c001f                              sty GKI__parm1
 18307  b364 8d011f                              sta GKI__parm2
 18308                          
 18309  b367 200879                              jsr comsad                               ; get y
 18310  b36a 8c021f                              sty GKI__parm3
 18311  b36d 8d031f                              sta GKI__parm4
 18312                          
 18313  b370 a200                                ldx #0                                   ; [910916]
 18314  b372 202679                              jsr optbyt                               ; mode, default = 0 (fill region pointed to)
 18315  b375 e003                                cpx #3
 18316  b377 b3859e                              +lbcs fcerr                              ; (range 0-2)
 18317  b37a 8e041f                              stx GKI__parm5
 18318  b37d a200                                ldx #0
 18319  b37f 202679                              jsr optbyt                               ; boundary color, default = 0
 18320  b382 8e051f                              stx GKI__parm6
 18321                          
 18322  b385 20335c             l278_1           jsr garba2                               ; create space in var bank for paint stack [910716]
 18323  b388 a533                                lda strend
 18324  b38a 8d061f                              sta GKI__parm7                           ; pass pointer to bottom of bank-1 free space
 18325  b38d a534                                lda strend+1                             ; (top of stack)
 18326  b38f 8d071f                              sta GKI__parm8
 18327  b392 38                                  sec
 18328  b393 a535                                lda fretop                               ; pass pointer to top of free space
 18329  b395 e903                                sbc #3                                   ; (bottom of stack)
 18330  b397 8d081f                              sta GKI__parm9
 18331  b39a a536                                lda fretop+1
 18332  b39c e900                                sbc #0
 18333  b39e 8d091f                              sta GKI__parm10
 18334                          
 18335  b3a1 222e80                              jsr ($802e)                              ; bra paint
 18336  b3a4 b001                                bcs l278_2                               ; error- stack overflow or stop key
 18337  b3a6 60                                  rts
 18338                          
 18339  b3a7 e010               l278_2           cpx #errom
 18340  b3a9 f3a47a                              +lbeq error                              ; stack overflow, say 'out of memory'
 18341  b3ac 832379                              +lbra break_exit                         ; user hit stop key
 18342                          
 18343                          ; .page
 18344                          ; .subttl   LOAD/SAVE IFF
 18345                          
 18346                          ;*****************************************************************
 18347                          ;*   LOADIFF "filename" [,U#] [,D#]
 18348                          ;*
 18349                          ;* ???? requires SCREEN already opened   910402 FAB
 18350                          ;*****************************************************************
 18351                          
 18352                          loadiff
 18353  b3af 201caf                              jsr CheckGraphicMode
 18354  b3b2 a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
 18355  b3b4 202074                              jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 )
 18356  b3b7 20dc77                              jsr chk1                                 ; check parameters
 18357  b3ba a900                                lda #0
 18358  b3bc 8d8311                              sta dossa                                ; setup as dload would (0 = load channel)
 18359  b3bf 201d71                              jsr find_la                              ; find an available la to use (cannot use reserved one)
 18360  b3c2 a009                                ldy #fopn
 18361  b3c4 a204                                ldx #4
 18362  b3c6 20fd70                              jsr open_file                            ; open the file
 18363  b3c9 b006                                bcs l279_1                               ; exit if error
 18364                          
 18365  b3cb ae8111                              ldx dosla
 18366                          ; stx GKI__parm1
 18367  b3ce 20c6ff                              jsr _chkin                               ; get input channel
 18368  b3d1 b3547f             l279_1           +lbcs list_err                           ; exit if error
 18369                          
 18370  b3d4 222a80                              jsr ($802a)                              ; Load it
 18371                          
 18372                          exit_GKI_disk_op
 18373  b3d7 08                                  php                                      ; preserve completion status
 18374  b3d8 48                                  pha
 18375  b3d9 20ccff                              jsr _clrch
 18376  b3dc ad8111                              lda dosla
 18377  b3df 200e69                              jsr close_out                            ; close channel
 18378                          
 18379  b3e2 20cc2c                              jsr is_stop_key_down                     ; weed out BREAK error
 18380  b3e5 fa                                  plx
 18381  b3e6 28                                  plp
 18382  b3e7 b3667a                              +lbcs error                              ; must be I/O or file data error
 18383  b3ea 60                                  rts                                      ; load was successful
 18384                          
 18385                          ; .page
 18386                          ;*****************************************************************
 18387                          ;*
 18388                          ;*   SAVEIFF "[@]filename" [,U#] [,D#]      [910930] FAB
 18389                          ;*
 18390                          ;*****************************************************************
 18391                          
 18392                          saveiff
 18393  b3eb 201caf                              jsr CheckGraphicMode
 18394  b3ee a966                                lda #$66                                 ; set error flags
 18395  b3f0 202074                              jsr dosprs                               ; parse the line
 18396  b3f3 20e177                              jsr chk2                                 ; check required parameters
 18397  b3f6 a901                                lda #1
 18398  b3f8 8d8311                              sta dossa                                ; setup as dsave would (1 = save channel)
 18399  b3fb 201d71                              jsr find_la                              ; find an available la to use (cannot use reserved one)
 18400  b3fe a009                                ldy #fopn
 18401  b400 a204                                ldx #4
 18402  b402 20fd70                              jsr open_file                            ; open the file
 18403  b405 b006                                bcs l280_1                               ; exit if error
 18404                          
 18405  b407 ae8111                              ldx dosla
 18406                          ; stx GKI__parm1
 18407  b40a 20c9ff                              jsr _chkout                              ; get output channel
 18408  b40d b3187f             l280_1           +lbcs list_err                           ; exit if error
 18409                          
 18410  b410 223a80                              jsr ($803a)                              ; Save it
 18411  b413 80c2                                bra exit_GKI_disk_op
 18412                          
 18413                          ; php   ;preserve completion status
 18414                          ; pha
 18415                          ; jsr _clrch
 18416                          ; lda dosla
 18417                          ; jsr close_out  ;close channel
 18418                          ;
 18419                          ; jsr is_stop_key_down ; weed out BREAK error
 18420                          ; plx
 18421                          ; plp
 18422                          ; bcs error  ; must be I/O or file data error
 18423                          ; rts   ; load was successful
 18424                          
 18425                          ;.end
 18426                          ; .page
 18427                          ; .subttl   VIEWPORT Commands
 18428                          
 18429                          ;*****************************************************************
 18430                          ;*   VIEWPORT <CLR | DEF>  x, y, viewport_width, viewport_height
 18431                          ;*
 18432                          ;* assumes SCREEN already opened   910626 FAB
 18433                          ;*****************************************************************
 18434                          
 18435                          C65__Viewport
 18436  b415 48                                  pha                                      ; save secondary command
 18437  b416 208322                              jsr chrget                               ; advance past it
 18438  b419 201caf                              jsr CheckGraphicMode                     ; make sure a screen is open
 18439                          
 18440  b41c 20e5b7                              jsr sadwrd                               ; get x0
 18441  b41f 8c001f                              sty GKI__parm1
 18442  b422 8d011f                              sta GKI__parm2
 18443                          
 18444  b425 200879                              jsr comsad                               ; get y0
 18445  b428 8c021f                              sty GKI__parm3
 18446  b42b 8d031f                              sta GKI__parm4
 18447                          
 18448  b42e 200879                              jsr comsad                               ; get width (delta-x)
 18449  b431 8c041f                              sty GKI__parm5
 18450  b434 8d051f                              sta GKI__parm6
 18451                          
 18452  b437 200879                              jsr comsad                               ; get height (delta-y)
 18453  b43a 8c061f                              sty GKI__parm7
 18454  b43d 8d071f                              sta GKI__parm8
 18455                          
 18456  b440 68                                  pla                                      ; dispatch per secondary token...
 18457  b441 c99c                                cmp #clr_token
 18458  b443 f008                                beq l281_1
 18459  b445 c996                                cmp #def_token
 18460  b447 d3017a                              +lbne snerr                              ; error
 18461                          
 18462  b44a 6c3080                              jmp ($8030)                              ; define viewport & return
 18463                          
 18464  b44d 6c2280             l281_1           jmp ($8022)                              ; clear viewport (???? make this a box command)
 18465                          
 18466                          ; .page
 18467                          C65__copy
 18468                          C65__cut
 18469                          C65__paste
 18470  b450 4c3b2e                              jmp bad_command
 18471                          
 18472                          ; .page
 18473                          ; .subttl  GENLOCK
 18474                          
 18475                          ;*****************************************************************
 18476                          ;* GENLOCK  set/reset genlock mode & color registers
 18477                          ;*
 18478                          ;*  Syntax: GENLOCK <ON[,color#[,...]] | OFF[,color#,R,G,B]>
 18479                          ;*****************************************************************
 18480                          
 18481  b453 8d001f             genlock          sta GKI__parm1                           ; save token as flag for set palette   [910107]
 18482  b456 c991                                cmp #on_token
 18483  b458 f028                                beq l282_4
 18484  b45a 2016b5                              jsr chkesc
 18485  b45d c924                                cmp #off_token
 18486  b45f d3e979                              +lbne snerr
 18487                          ;TURN GENLOCK OFF
 18488  b462 ad31d0                              lda vic+49                               ; any interlaced bitplanes on?
 18489  b465 2919                                and #%00011001
 18490  b467 c919                                cmp #%00011001
 18491  b469 f005                                beq l282_1                               ; yes, leave interlace mode on
 18492                          
 18493  b46b a901                                lda #%00000001
 18494  b46d 1c31d0                              trb vic+49                               ; no, turn interlace off
 18495  b470 a902               l282_1           lda #%00000010
 18496  b472 1c30d0                              trb vic+48                               ; reset external sync mode
 18497                          ; beq l282_2   ;       [910114]
 18498                          ; lda vic+63  ;       [910111]
 18499                          ; inc a   ;  adjust vert. position (chip bug ????)
 18500                          ; inc a   ;  (to be handled by a custom C65 genlock board)
 18501                          ; inc a
 18502                          ; sta vic+63
 18503                          
 18504  b475 208322             l282_2           jsr chrget                               ; eat token
 18505  b478 202679                              jsr optbyt                               ; get (optional) color reg# in .X
 18506  b47b 8e011f                              stx GKI__parm2                           ; save it
 18507  b47e b3f0fb                              +lbcs set_palette                        ; if present, go do it & exit
 18508  b481 60                 l282_3           rts                                      ; if not present (eol), exit
 18509                          
 18510                          
 18511  b482 a901               l282_4           lda #%00000001                           ; TURN GENLOCK ON
 18512  b484 0c31d0                              tsb vic+49                               ; set interlace mode
 18513  b487 0a                                  asl
 18514  b488 0c30d0                              tsb vic+48                               ; set external sync mode
 18515                          ; bne l282_5   ;       [910114]
 18516                          ; lda vic+63  ;       [910111]
 18517                          ; dec a   ;  adjust vert. position (chip bug ????)
 18518                          ; dec a   ;  (to be handled by a custom C65 genlock board)
 18519                          ; dec a
 18520                          ; sta vic+63
 18521                          
 18522  b48b 208322             l282_5           jsr chrget                               ; eat token
 18523  b48e 202679             l282_6           jsr optbyt                               ; get (optional) color reg# in .X
 18524  b491 90ee                                bcc l282_3                               ; if not present (eol), exit
 18525  b493 a910                                lda #%00010000                           ; if present, set FGBG bit in red palette
 18526  b495 9d00d1                              sta _red,x
 18527  b498 80f4                                bra l282_6                               ; loop
 18528                          
 18529                          ; .page
 18530                          ; .subttl  COLOR Control
 18531                          
 18532                          ;*****************************************************************
 18533                          ;* COLOR       <ON | OFF> Enable|Disable SW & HW color
 18534                          ;* FOREGROUND  color# Set Foreground color (text)
 18535                          ;* HIGHLIGHT   color# Set Highlight color (text)
 18536                          ;* BACKGROUND  color# Set VIC Background color
 18537                          ;* BORDER      color# Set VIC Border color
 18538                          ;*****************************************************************
 18539                          
 18540  b49a c92c               color            cmp #','                                 ; optional first arg
 18541  b49c f01f                                beq l283_3
 18542  b49e c991                                cmp #on_token                            ; SOFTWARE (Editor) color mode
 18543  b4a0 f00b                                beq l283_2
 18544  b4a2 2016b5                              jsr chkesc
 18545  b4a5 c924                                cmp #off_token
 18546  b4a7 d3a179             l283_1           +lbne snerr
 18547                          
 18548  b4aa a05b                                ldy #'['                                 ; OFF (color & attributes)
 18549  b4ac 2c                                  !text $2c
 18550  b4ad a05d               l283_2           ldy #']'                                 ; ON
 18551  b4af a91b                                lda #esc
 18552  b4b1 20d2ff                              jsr _bsout                               ; do it
 18553  b4b4 98                                  tya
 18554  b4b5 20d2ff                              jsr _bsout
 18555  b4b8 208322                              jsr chrget                               ; eat token
 18556  b4bb f01d                                beq l283_6                               ; eol- exit
 18557                          
 18558  b4bd 205b4e             l283_3           jsr chkcom                               ; else must be comma, eat & get next
 18559                          ; jsr chrgot  ;      [910930]
 18560  b4c0 c991                                cmp #on_token                            ; HARDWARE (Vic) color mode
 18561  b4c2 f00e                                beq l283_4
 18562  b4c4 2016b5                              jsr chkesc
 18563  b4c7 c924                                cmp #off_token
 18564  b4c9 d0dc                                bne l283_1
 18565                          
 18566  b4cb a902                                lda #%00000010                           ; OFF (monochrome)
 18567  b4cd 0c31d0                              tsb vic+49
 18568  b4d0 8005                                bra l283_5
 18569                          
 18570  b4d2 a902               l283_4           lda #%00000010                           ; ON
 18571  b4d4 1c31d0                              trb vic+49
 18572  b4d7 83aa6d             l283_5           +lbra chrget                             ; exit after eating last token
 18573                          
 18574  b4da 60                 l283_6           rts                                      ; exit after encountering eol
 18575                          
 18576                          ; .page
 18577                          foreground
 18578  b4db 200db5                              jsr getnyb                               ; Set text foreground color
 18579  b4de 86f1                                stx _color
 18580  b4e0 60                                  rts
 18581                          
 18582                          
 18583                          
 18584                          highlight
 18585  b4e1 f36779                              +lbeq snerr                              ; missing args??     [911017]
 18586  b4e4 c92c                                cmp #','
 18587  b4e6 f006                                beq l284_1                               ; options byte only
 18588                          
 18589  b4e8 206c5d                              jsr getbyt                               ; Set text highlight color
 18590  b4eb 8ed802                              stx highlight_color
 18591                          
 18592  b4ee 202479             l284_1           jsr optzer                               ; set options:     [911001]
 18593  b4f1 9008                                bcc l284_2                               ; comma but no value not given??
 18594  b4f3 8a                                  txa
 18595  b4f4 2903                                and #3                                   ; 0= error msgs only
 18596  b4f6 0a                                  asl                                      ; 1= REMs
 18597  b4f7 0a                                  asl                                      ; 2= tokens
 18598  b4f8 0a                                  asl
 18599  b4f9 8555                                sta helper
 18600  b4fb 60                 l284_2           rts
 18601                          
 18602                          
 18603                          
 18604                          background
 18605  b4fc 200db5                              jsr getnyb                               ; Set Vic background color
 18606  b4ff 8e21d0                              stx vic+33
 18607  b502 60                                  rts
 18608                          
 18609                          
 18610                          
 18611                          border
 18612  b503 200db5                              jsr getnyb                               ; Set Vic border color
 18613  b506 8e20d0                              stx vic+32
 18614  b509 60                                  rts
 18615                          
 18616                          ; .page
 18617                          getcomnyb
 18618  b50a 205b4e                              jsr chkcom                               ; check for comma
 18619                          getnyb
 18620  b50d 206c5d                              jsr getbyt                               ; Get a nybble, check range (0-15)
 18621                          chknyb
 18622  b510 e010                                cpx #16
 18623  b512 b3ea9c                              +lbcs fcerr
 18624  b515 60                                  rts
 18625                          
 18626                          
 18627                          
 18628                          chkesc                                                    ; Check for escape token, error if not, else get next token
 18629  b516 c9fe                                cmp #esc_command_token
 18630  b518 d33079                              +lbne snerr
 18631  b51b 208322                              jsr chrget
 18632  b51e f32a79                              +lbeq snerr                              ; eos? report error if so
 18633  b521 60                                  rts
 18634                          
 18635                          
 18636                          
 18637                          chkeos                                                    ; Check for next byte = end of statement, error if not
 18638  b522 208322                              jsr chrget
 18639  b525 d32379                              +lbne snerr                              ; eos? report error if not
 18640  b528 60                                  rts
 18641                          
 18642                          
 18643                          ;.end
 18644                          ; .page
 18645                          ; .subttl SPRITE Commands and Functions
 18646                          
 18647                          ;************************************************************************************
 18648                          ; SPRITE CLR
 18649                          ; SPRITE {LOAD|SAVE} "filename" [,Ddrive] [,Udevice]
 18650                          ; SPRITE sprite [,enable [,color [,priority [,xexp [,yexp [,resolution] ]]]]]
 18651                          ;
 18652                          ; where: sprite  :== sprite number (1-8)
 18653                          ;  enable  :== enable  (0=off, 1=on)
 18654                          ;  color  :== color  (0-15)
 18655                          ;  priority :== sprite/bgnd  (0=sprite, 1=bgnd)
 18656                          ;  xexp  :== expand x direction (0=no, 1=yes)
 18657                          ;  yexp  :== expand y direction (0=no, 1=yes)
 18658                          ;  resolution :== resolution  (0=hires, 1=multicolor)
 18659                          ;************************************************************************************
 18660                          
 18661  b529 c99c               sprite           cmp #clr_token                           ; SPRITE CLR: init environment   [910717]
 18662  b52b f3a709                              +lbeq Sprite_CLR                         ; yes
 18663  b52e c994                                cmp #save_token                          ; SPRITE SAVE: save sprite data   [911001]
 18664  b530 f048                                beq Sprite_Save                          ; yes
 18665  b532 c993                                cmp #load_token                          ; SPRITE LOAD: load sprite data   [911001]
 18666  b534 f057                                beq Sprite_Load                          ; yes
 18667                          
 18668  b536 20b5b5                              jsr get_sprite_number                    ; get sprite number in z_p_temp_1
 18669  b539 202679                              jsr optbyt                               ; look for (optional) enable
 18670  b53c 9005                                bcc l285_1                               ; none here, don't change
 18671  b53e a015                                ldy #21
 18672  b540 209fb5                              jsr sprbit                               ; set/clear sprite bit
 18673                          
 18674  b543 202679             l285_1           jsr optbyt                               ; get (optional) color
 18675  b546 9009                                bcc l285_2                               ; branch if no arg
 18676  b548 2010b5                              jsr chknyb                               ; [910109]
 18677  b54b 8a                                  txa
 18678  b54c a676                                ldx z_p_temp_1                           ; get back sprite number
 18679                          ; jsr put_io_in_map
 18680  b54e 9d27d0                              sta vic+39,x
 18681                          
 18682  b551 202679             l285_2           jsr optbyt                               ; look for (optional) priority
 18683  b554 9005                                bcc l285_3
 18684  b556 a01b                                ldy #27
 18685  b558 209fb5                              jsr sprbit
 18686                          
 18687  b55b 202679             l285_3           jsr optbyt                               ; look for (optional) x expansion
 18688  b55e 9005                                bcc l285_4
 18689  b560 a01d                                ldy #29
 18690  b562 209fb5                              jsr sprbit
 18691                          
 18692  b565 202679             l285_4           jsr optbyt                               ; look for (optional) y expansion
 18693  b568 9005                                bcc l285_5
 18694  b56a a017                                ldy #23
 18695  b56c 209fb5                              jsr sprbit
 18696                          
 18697  b56f 202679             l285_5           jsr optbyt                               ; look for (optional) resolution
 18698  b572 9005                                bcc l285_6
 18699  b574 a01c                                ldy #28
 18700  b576 209fb5                              jsr sprbit
 18701                          
 18702  b579 60                 l285_6           rts
 18703                          
 18704                          ; .page
 18705                          Sprite_Save                                               ; Just like Key_Save     [911001]
 18706  b57a 202e47                              jsr GetSaveChannel
 18707  b57d a95a                                lda #highds                              ; set starting & ending addresses
 18708  b57f a006                                ldy #>sprite_base                        ; start address & pointer to it
 18709  b581 a200                                ldx #<sprite_base
 18710  b583 845b                                sty highds+1
 18711  b585 865a                                stx highds
 18712  b587 c8                                  iny                                      ; end address = start address + 512 + 1
 18713  b588 c8                                  iny
 18714  b589 e8                                  inx
 18715  b58a 83dfb2                              +lbra savenb                             ; [910925]
 18716                          
 18717                          
 18718                          
 18719                          Sprite_Load
 18720  b58d 20c946                              jsr GetLoadChannel                       ; get a channel      [911001]
 18721  b590 a006                                ldy #>sprite_base
 18722  b592 a900                                lda #<sprite_base
 18723  b594 20fa46                              jsr LoadBlock                            ; load first block
 18724  b597 e65b                                inc highds+1
 18725  b599 20fe46                              jsr LoadBlockNext                        ; load second block
 18726  b59c 83897d                              +lbra list_err                           ; release channel, close file, return to main
 18727                          
 18728                          ; .page
 18729                          ;  Set or clear a bit in a VIC register
 18730                          ;
 18731                          ; .X = 1 to set, 0 to clear
 18732                          ; .Y = register in VIC to operate opon
 18733                          
 18734  b59f 8a                 sprbit           txa
 18735  b5a0 4a                                  lsr                                      ; put lsb in .C (0 clear, 1 set sprite bit)
 18736  b5a1 d35b9c                              +lbne fcerr                              ; only 0 or 1, please.
 18737                          ; jsr put_io_in_map
 18738  b5a4 a676                                ldx z_p_temp_1                           ; get sprite number
 18739  b5a6 bd6579                              lda sbits,x
 18740  b5a9 1900d0                              ora vic,y
 18741  b5ac b003                                bcs l286_1
 18742  b5ae 5d6579                              eor sbits,x
 18743  b5b1 9900d0             l286_1           sta vic,y
 18744  b5b4 60                                  rts
 18745                          
 18746                          
 18747                          get_sprite_number
 18748  b5b5 206c5d                              jsr getbyt
 18749                          ; dex        [910221]
 18750  b5b8 e008                                cpx #8
 18751  b5ba b3429c                              +lbcs fcerr
 18752  b5bd 8676                                stx z_p_temp_1
 18753  b5bf 60                                  rts
 18754                          
 18755                          ;.end
 18756                          ; .page
 18757                          ; .subttl MOVSPR Command
 18758                          
 18759                          ;****************************************************************
 18760                          ; Move Sprite.  Position sprite and optionally animate it.
 18761                          ;
 18762                          ;   MOVSPR n, [ p | x#y ]   or   MOVSPR n, p1 TO p2, speed
 18763                          ;
 18764                          ;  n = Sprite number (0-7)
 18765                          ; p = (x,y) coordinate.
 18766                          ;  Relative and angular distances  are relative to
 18767                          ;  current sprite position and scaled if scaling is on.
 18768                          ; x#y = Constant movement at an angle-x with speed-y.
 18769                          ;****************************************************************
 18770                          
 18771  b5c0 a900               movspr           lda #0                                   ; flag 'movspr' initial coord   [910808]
 18772  b5c2 8587                                sta op                                   ; (0=movspr, $80=movspr_to, $7f=mouse)
 18773  b5c4 20b5b5                              jsr get_sprite_number                    ; get sprite #
 18774  b5c7 20c3b7                              jsr sprcor                               ; get first coordinate (y,a)
 18775                          movspr_1                                                  ; entry to eval destination coordinate  [910808]
 18776  b5ca 2cf411                              bit numcnt                               ; test coordinate type
 18777  b5cd 737b78                              +lbvs snerr                              ; syntax error
 18778  b5d0 8cf011                              sty xdest                                ; save coordinate value
 18779  b5d3 8cf211                              sty xdest+2
 18780  b5d6 8df111                              sta xdest+1
 18781  b5d9 8df311                              sta xdest+3
 18782                          
 18783  b5dc 20c3b7                              jsr sprcor                               ; get second coordinate (y,a)
 18784  b5df 2cf411                              bit numcnt                               ; test coordinate type & dispatch accordingly
 18785  b5e2 5060                                bvc movspr_normal                        ; normal coordinates
 18786  b5e4 3040                                bmi movspr_angle                         ; angular coordinates
 18787                          
 18788  b5e6 2487                                bit op                                   ; angle#speed, test if allowed
 18789  b5e8 336078                              +lbmi snerr                              ; ng- movspr_to call
 18790  b5eb 5a                                  phy                                      ; ok- save speed value
 18791  b5ec a004                                ldy #xdest-vwork
 18792  b5ee 20b5ba                              jsr getang                               ; get angle of movement
 18793  b5f1 a676                                ldx z_p_temp_1                           ; get sprite number
 18794  b5f3 bcfeb7                              ldy sproff,x                             ; get offset to speed data
 18795  b5f6 a900                                lda #0
 18796  b5f8 990512                              sta sprite_data,y                        ; turn off sprite speed
 18797  b5fb c8                                  iny
 18798                          
 18799  b5fc a203                                ldx #3
 18800  b5fe 5efb11             l287_1           lsr sinval,x
 18801  b601 ca                                  dex
 18802  b602 7efb11                              ror sinval,x
 18803  b605 ca                                  dex
 18804  b606 10f6                                bpl l287_1
 18805                          
 18806  b608 78                 l287_2           sei
 18807  b609 e8                                  inx                                      ; x=0
 18808  b60a bdfa11                              lda angsgn,x                             ; move angle data to speed data
 18809  b60d c8                                  iny
 18810  b60e 990512                              sta sprite_data,y
 18811  b611 e004                                cpx #4
 18812  b613 d0f3                                bne l287_2
 18813                          
 18814  b615 a900                                lda #0                                   ; clear speed angle counts
 18815  b617 c8                 l287_3           iny
 18816  b618 990512                              sta sprite_data,y
 18817  b61b ca                                  dex
 18818  b61c d0f9                                bne l287_3
 18819                          
 18820  b61e 68                                  pla                                      ; restore speed value
 18821  b61f 293f                                and #$3f                                 ; limit range (0-63) ????  [910806]
 18822  b621 99fb11                              sta sprite_data-10,y                     ; start sprite movement
 18823  b624 58                                  cli
 18824  b625 60                                  rts
 18825                          
 18826                          movspr_angle
 18827                          ; jsr swapxy  ;swap y and a (eventually) : y ==> x
 18828                          ; tay   ;        a ==> y
 18829                          ; txa   ;        x ==> a
 18830  b626 48                                  pha
 18831  b627 98                                  tya
 18832  b628 7a                                  ply
 18833                          
 18834  b629 20b8ba                              jsr gtang1                               ; get angle values
 18835                          ; ldx #xdest-vwork
 18836                          ; jsr scalxy  ;scale lengths
 18837  b62c a204                                ldx #xdest-vwork
 18838  b62e 18                                  clc
 18839                          
 18840  b62f 2011bb             l288_1           jsr angmlt                               ; multiply lengths*angles for x and y
 18841  b632 9dec11                              sta vwork,x
 18842  b635 98                                  tya
 18843  b636 9ded11                              sta vwork+1,x
 18844  b639 e8                                  inx
 18845  b63a e8                                  inx
 18846  b63b e006                                cpx #ydest-vwork
 18847  b63d f0f0                                beq l288_1                               ; loop to do y-position
 18848                          
 18849  b63f 6ef411                              ror numcnt                               ; shift in carry to set msb
 18850  b642 8006                                bra movspr_position                      ; go place sprite
 18851                          
 18852                          
 18853                          movspr_normal                                             ; [910122]
 18854  b644 8cf211                              sty xdest+2                              ; save second coordinate (y,a)
 18855  b647 8df311                              sta xdest+3
 18856                          ; ldx #xdest-vwork
 18857                          ; jsr scalxy  ;scale the coordinates
 18858                          
 18859                          
 18860                          movspr_position
 18861  b64a 78                                  sei                                      ; [910123]
 18862  b64b a576                                lda z_p_temp_1                           ; get sprite number
 18863  b64d aa                                  tax                                      ; use as an index
 18864  b64e 0a                                  asl
 18865  b64f a8                                  tay                                      ; get sprite-number * 2 as another index
 18866                          
 18867  b650 7f8701                              bbr7 op,l289_1
 18868  b653 60                                  rts                                      ; >>>exit here if movspr_to call   [910808]
 18869                          
 18870  b654 adf211             l289_1           lda xdest+2                              ; get y-coordinate
 18871  b657 0ef411                              asl numcnt                               ; test if relative
 18872  b65a 9009                                bcc l289_3                               ; skip if absolute
 18873  b65c 18                                  clc
 18874  b65d 1003                                bpl l289_2                               ; skip if normal coordinates
 18875  b65f 49ff                                eor #$ff
 18876  b661 38                                  sec                                      ; invert to subtract if angular
 18877  b662 7901d0             l289_2           adc vic+1,y                              ; add to current sprite y-value  ???vic_save
 18878                          
 18879  b665 9901d0             l289_3           sta vic+1,y                              ; save new sprite y-position  ???vic_save
 18880  b668 adf011                              lda xdest                                ; get low byte of x-coordinate
 18881  b66b 0ef411                              asl numcnt                               ; test if relative
 18882  b66e 1011                                bpl l289_5                               ; skip if absolute
 18883  b670 18                                  clc
 18884  b671 7900d0                              adc vic,y                                ; add current sprite x-position  ???vic_save
 18885  b674 9900d0                              sta vic,y                                ; save sprite x-position   ???vic_save
 18886  b677 b003                                bcs l289_4                               ; skip if carry
 18887  b679 eef111                              inc xdest+1                              ; invert lsb
 18888                          
 18889  b67c ad10d0             l289_4           lda vic+16                               ; get x-position msb bits  ???vic_save
 18890  b67f 8009                                bra l289_6                               ; test if need to invert msb bit
 18891                          
 18892  b681 9900d0             l289_5           sta vic,y                                ; save new sprite x-position  ???vic_save
 18893  b684 ad10d0                              lda vic+16                               ; ???vic_save
 18894  b687 1d6579                              ora sbits,x                              ; set x-position msb bit
 18895                          
 18896  b68a 4ef111             l289_6           lsr xdest+1                              ; match to lsb of x-coordinate high byte
 18897  b68d b003                                bcs l289_7                               ; skip if should be set
 18898  b68f 5d6579                              eor sbits,x                              ; reset bit
 18899                          
 18900  b692 8d10d0             l289_7           sta vic+16                               ; save position msb bits   ???vic_save
 18901                          ; cli
 18902                          ;1l289_1 rts   ; mouse or movspr_to
 18903                          
 18904                          ; .page
 18905                          movspr_to                                                 ; setup for moving sprite to a particular position
 18906                          ;we have already positioned the sprite onscreen
 18907  b695 208522                              jsr chrgot                               ; reget terminating character
 18908  b698 c9a4                                cmp #to_token
 18909  b69a f002                                beq l290_1                               ; not our call
 18910  b69c 58                                  cli
 18911  b69d 60                                  rts
 18912                          
 18913  b69e f787               l290_1           smb7 op                                  ; it's for us- let everybody else know we're in charge
 18914  b6a0 208322                              jsr chrget                               ; move to next non-space character
 18915  b6a3 18                                  clc
 18916  b6a4 20c6b7                              jsr sprcor_1                             ; go get & evaluate destination coordinate
 18917  b6a7 20cab5                              jsr movspr_1                             ; returns with sprite# in .x, VIC sprite index in .y,
 18918                          ;P1 in VIC sprite regs, and P2 in x,ydest
 18919  b6aa 0ef411                              asl numcnt                               ; Y: handle specific coordinate types
 18920  b6ad 900f                                bcc l290_3                               ; skip if absolute
 18921  b6af 18                                  clc
 18922  b6b0 adf211                              lda xdest+2                              ; get y-coordinate
 18923  b6b3 1003                                bpl l290_2                               ; skip if normal coordinates
 18924  b6b5 49ff                                eor #$ff
 18925  b6b7 38                                  sec                                      ; invert to subtract if angular
 18926  b6b8 7901d0             l290_2           adc vic+1,y                              ; add to current sprite y-value ???vic_save
 18927  b6bb 8df211                              sta xdest+2                              ; save sprite destination y-position
 18928                          
 18929  b6be 0ef411             l290_3           asl numcnt                               ; X: handle specific coordinate types
 18930  b6c1 100f                                bpl l290_4                               ; skip if absolute
 18931  b6c3 18                                  clc
 18932  b6c4 adf011                              lda xdest                                ; get low byte of x-coordinate
 18933  b6c7 7900d0                              adc vic,y                                ; add current sprite x-position  ???vic_save
 18934  b6ca 8df011                              sta xdest                                ; save sprite destination x-position
 18935  b6cd 9003                                bcc l290_4
 18936  b6cf eef111                              inc xdest+1
 18937                          
 18938  b6d2 5a                 l290_4           phy
 18939  b6d3 20825d                              jsr combyt                               ; get speed parameter
 18940  b6d6 8a                                  txa
 18941  b6d7 293f                                and #$3f                                 ; limit range (0-63) ????
 18942  b6d9 0980                                ora #$80
 18943  b6db 8d8411                              sta xcnt                                 ; save in temp.
 18944  b6de 7a                                  ply
 18945                          
 18946  b6df b900d0                              lda vic,y                                ; copy current sprite pos'n to line vars
 18947  b6e2 8dec11                              sta xpos                                 ; in preparation for line calculations
 18948  b6e5 b901d0                              lda vic+1,y
 18949  b6e8 8dee11                              sta ypos
 18950  b6eb a900                                lda #0
 18951  b6ed 8ded11                              sta xpos+1
 18952  b6f0 8def11                              sta ypos+1
 18953  b6f3 98                                  tya
 18954  b6f4 4a                                  lsr
 18955  b6f5 a8                                  tay
 18956  b6f6 b96579                              lda sbits,y
 18957  b6f9 2d10d0                              and vic+16
 18958  b6fc f003                                beq l290_5
 18959  b6fe eeed11                              inc xpos+1
 18960                          l290_5
 18961                          ; .page
 18962                          ;******************************************************************
 18963                          ;  MOVSPR n, p1 TO p2 - move a sprite along line from p1 to p2
 18964                          ;
 18965                          ; The following is performed now:
 18966                          ;
 18967                          ;           absx    = abs(destx-posx) : absy = abs(desty-posy)
 18968                          ;           sgnx    = sgn(destx-posx) : sgny = sgn(desty-posy)
 18969                          ;                     ( sgn=(1,0,-1) if (+,0,-) )
 18970                          ;           greatr  = index to the greatr of absx,absy
 18971                          ;           lesser  = index to the smaller of absx,absy
 18972                          ;
 18973                          ;           fct1    = 2*min(absx,absy)
 18974                          ;           fct2    = fct1 - 2*max(absx,absy)
 18975                          ;           error   = fct1 - max(absx,absy)
 18976                          ;
 18977                          ; The following is performed during IRQ:
 18978                          ;
 18979                          ;           for i:= 1 to max(absx,absy) do begin
 18980                          ;                 movspr n, posx, posy
 18981                          ;                 if error > 0 then begin
 18982                          ;                      pos(lesser):= pos(lesser) + sgn(lesser)
 18983                          ;                      error:= error + fct2
 18984                          ;                      end
 18985                          ;                      else error:= error + fct1
 18986                          ;                 pos(greatr):= pos(greatr) + sgn(greatr)
 18987                          ;           end;
 18988                          ;
 18989                          ; (modification of C128 Bresenham DrawLn algorithm 910808 F.Bowen)
 18990                          ;******************************************************************
 18991                          
 18992                          movspr_line
 18993  b701 a202                                ldx #ypos-vwork
 18994  b703 a006                                ldy #ydest-vwork
 18995  b705 a900               l291_1           lda #0
 18996  b707 9d9511                              sta xsgn,x                               ; init direction pointers
 18997  b70a 9d9611                              sta xsgn+1,x
 18998  b70d 207fbb                              jsr abstwo                               ; get absolute value of coordinate differences
 18999  b710 1008                                bpl l291_2                               ; and determine direction
 19000  b712 de9511                              dec xsgn,x                               ; negative direction
 19001  b715 de9611                              dec xsgn+1,x
 19002  b718 800b                                bra l291_4
 19003                          
 19004  b71a c900               l291_2           cmp #0
 19005  b71c d004                                bne l291_3
 19006  b71e c000                                cpy #0
 19007  b720 f003                                beq l291_4                               ; zero direction
 19008  b722 fe9511             l291_3           inc xsgn,x                               ; positive direction
 19009  b725 9d9111             l291_4           sta xabs,x
 19010  b728 0a                                  asl
 19011  b729 9d9911                              sta fct,x                                ; fct(x,y) = 2*abs(x,y)
 19012  b72c 98                                  tya
 19013  b72d 9d9211                              sta xabs+1,x
 19014  b730 2a                                  rol
 19015  b731 9d9a11                              sta fct+1,x
 19016  b734 ca                                  dex
 19017  b735 ca                                  dex
 19018  b736 a004                                ldy #xdest-vwork                         ; loop to do in x-direction
 19019  b738 e000                                cpx #xpos-vwork
 19020  b73a f0c9                                beq l291_1
 19021                          
 19022  b73c a202                                ldx #yabs-savram                         ; determine max(xabs,yabs)
 19023  b73e a000                                ldy #xabs-savram
 19024  b740 205cbb                              jsr subtwo_savram
 19025  b743 a900                                lda #0
 19026  b745 2a                                  rol
 19027  b746 2a                                  rol                                      ; a = c * 2
 19028  b747 8d0312                              sta lesser                               ; index to smaller delta
 19029  b74a 4902                                eor #2
 19030  b74c 8d0412                              sta greatr                               ; index to greater delta
 19031                          
 19032  b74f 18                                  clc
 19033  b750 a908                                lda #fct-savram
 19034  b752 6d0312                              adc lesser
 19035  b755 48                                  pha
 19036  b756 a8                                  tay
 19037  b757 4902                                eor #2
 19038  b759 aa                                  tax
 19039  b75a 205cbb                              jsr subtwo_savram                        ; fct(greatr) = fct(lesser)-fct(greatr)
 19040  b75d 9d9111                              sta savram,x
 19041  b760 8b9211                              sty savram+1,x
 19042                          
 19043  b763 7a                                  ply                                      ; fct(lesser)
 19044  b764 18                                  clc
 19045  b765 a900                                lda #xabs-savram
 19046  b767 6d0412                              adc greatr
 19047  b76a aa                                  tax
 19048  b76b 205cbb                              jsr subtwo_savram                        ; error = fct(lesser) - abs(greatr)
 19049  b76e 8d9d11                              sta errval
 19050  b771 8c9e11                              sty errval+1
 19051                          
 19052                          ; At this point, we've positioned the sprite at the start position, and have
 19053                          ; calculated everything we need to move it along a line towards the destination
 19054                          ; position.  All that's left is to copy the working vars into the sprite_data
 19055                          ; tables where the IRQ routine can find & diddle with our data.
 19056                          ;
 19057                          ;    move ang/dist move line
 19058                          ;  offset= 0 b7=0+speed b7=1+speed
 19059                          ;   1 counter  counter lo
 19060                          ;   2 angle sign         hi
 19061                          ;   3,4 delta-X  dir+min/max
 19062                          ;   5,6 delta-Y  fct1
 19063                          ;   7,8 total-X  fct2
 19064                          ;   9,10 total-Y  error
 19065                          
 19066  b774 a476                                ldy z_p_temp_1                           ; sprite #
 19067  b776 befeb7                              ldx sproff,y                             ; sprite IRQ table offset
 19068                          
 19069  b779 ad8411                              lda xcnt                                 ; set speed factor
 19070  b77c 9d0512                              sta sprite_data,x
 19071  b77f ac0412                              ldy greatr
 19072  b782 b99111                              lda xabs,y                               ; set counter = max(xyabs)
 19073  b785 9d0612                              sta sprite_data+1,x
 19074  b788 b99211                              lda xabs+1,y
 19075  b78b 9d0712                              sta sprite_data+2,x
 19076  b78e b99511                              lda xsgn,y                               ; set dir(max) and max
 19077  b791 199611                              ora xsgn+1,y
 19078  b794 2903                                and #3
 19079  b796 4a                                  lsr
 19080  b797 6a                                  ror
 19081  b798 0d0412                              ora greatr
 19082  b79b 6a                                  ror
 19083  b79c 9d0912                              sta sprite_data+4,x
 19084  b79f ac0312                              ldy lesser
 19085  b7a2 b99511                              lda xsgn,y                               ; set dir(min) and min
 19086  b7a5 199611                              ora xsgn+1,y
 19087  b7a8 2903                                and #3
 19088  b7aa 4a                                  lsr
 19089  b7ab 6a                                  ror
 19090  b7ac 0d0312                              ora lesser
 19091  b7af 6a                                  ror
 19092  b7b0 9d0812                              sta sprite_data+3,x
 19093  b7b3 a000                                ldy #0                                   ; set f1, f2, and e
 19094  b7b5 b99911             l291_5           lda fct,y
 19095  b7b8 9d0a12                              sta sprite_data+5,x
 19096  b7bb e8                                  inx
 19097  b7bc c8                                  iny
 19098  b7bd c006                                cpy #6
 19099  b7bf 90f4                                bcc l291_5
 19100                          
 19101  b7c1 58                                  cli
 19102  b7c2 60                                  rts                                      ; done!
 19103                          
 19104                          ; .page
 19105                          ;  SPRCOR  -- Get sprite position coordinate
 19106                          ;
 19107                          
 19108  b7c3 20ebb7             sprcor           jsr chkcom_1                             ; check for a comma
 19109                          sprcor_1
 19110  b7c6 6ef411                              ror numcnt                               ; reset msb if comma else set msb
 19111  b7c9 100b                                bpl l292_1                               ; skip if got a comma
 19112  b7cb c93b                                cmp #';'                                 ; test if angular data
 19113  b7cd f013                                beq l292_3                               ; skip if yes - 2 msb's = 1 1
 19114  b7cf c923                                cmp #'#'                                 ; test if speed type
 19115  b7d1 f00e                                beq l292_2                               ; skip if yes - 2 msb's = 0 1
 19116  b7d3 837576                              +lbra snerr                              ; syntax error if none of above
 19117                          
 19118  b7d6 208522             l292_1           jsr chrgot                               ; test for relative coordinate
 19119  b7d9 c9aa                                cmp #plus_token                          ; test if plus sign
 19120  b7db f005                                beq l292_3                               ; skip if yes - show relative
 19121  b7dd c9ab                                cmp #minus_token                         ; test if minus sign
 19122  b7df f001                                beq l292_3                               ; skip if yes - show relative
 19123  b7e1 18                 l292_2           clc                                      ; reset to show absolute
 19124  b7e2 6ef411             l292_3           ror numcnt                               ; shift in second flag bit
 19125                          
 19126  b7e5 20d84c             sadwrd           jsr frmnum                               ; get number     label [910307]
 19127  b7e8 83a8a5                              +lbra getsad                             ; get signed 2 byte coordinate,do rts
 19128                          
 19129                          ; .page
 19130                          ;*************************************************************
 19131                          ; CHKCOM_1  --  Check for a comma
 19132                          ;
 19133                          ;  carry set & eq = end of string
 19134                          ;  carry set & neq = not a comma
 19135                          ;  carry clear = a comma
 19136                          ;*************************************************************
 19137                          
 19138                          chkcom_1
 19139  b7eb 208522                              jsr chrgot                               ; get character in input stream
 19140  b7ee f00d                                beq l293_2                               ; skip if end of string
 19141  b7f0 c92c                                cmp #','                                 ; check if a comma
 19142  b7f2 18                                  clc
 19143  b7f3 f001                                beq l293_1                               ; skip if yes
 19144  b7f5 38                                  sec                                      ; set carry if not
 19145  b7f6 08                 l293_1           php
 19146  b7f7 48                                  pha
 19147  b7f8 208322                              jsr chrget                               ; move to next non-space character
 19148  b7fb 68                                  pla
 19149  b7fc 28                                  plp
 19150  b7fd 60                 l293_2           rts
 19151                          
 19152                          
 19153  b7fe 000b16212c37424d   sproff           !text 0,11,22,33,44,55,66,77             ; sprite offsets into speed table
 19154                          
 19155                          ;.end
 19156                          ; .page
 19157                          ; .subttl SPRCOLOR Command
 19158                          
 19159                          ;**************************************************************
 19160                          ;*
 19161                          ;*   SPRCOLOR - Set sprite multicolor registers
 19162                          ;*
 19163                          ;* syntax : SPRCOLOR [multicolor_1] [,multicolor_2]
 19164                          ;*
 19165                          ;**************************************************************
 19166                          
 19167                          sprcolor
 19168  b806 c92c                                cmp #','                                 ; is there a first arg?
 19169  b808 f006                                beq l294_1                               ; nope, skip to second
 19170                          
 19171  b80a 200db5                              jsr getnyb                               ; get 1 byte arg in .X, range 0-15
 19172                          ; jsr put_io_in_map
 19173  b80d 8e25d0                              stx vic+37
 19174                          
 19175  b810 202679             l294_1           jsr optbyt                               ; get (optional) 1 byte arg in .X
 19176  b813 9006                                bcc l294_2
 19177  b815 2010b5                              jsr chknyb                               ; range 0-15
 19178                          ; jsr put_io_in_map
 19179  b818 8e26d0                              stx vic+38
 19180                          
 19181  b81b 60                 l294_2           rts
 19182                          
 19183                          ;.end
 19184                          ; .page
 19185                          ; .subttl SPRSAV Command
 19186                          
 19187                          ;***************************************************************
 19188                          ;  SPRSAV ( n1 / s1$ ) , ( n2 / s2$ )
 19189                          ;   - move string(s1) or sprite(n1) to string(s2) or sprite(n2)
 19190                          ;               n1 & n2 = a sprite number (1-8)
 19191                          ;                   s1$ = a string variable or expression
 19192                          ;                   s2$ = a string variable
 19193                          ;***************************************************************
 19194                          
 19195  b81c 20a9b8             sprsav           jsr savinp                               ; evaluate 1st expression
 19196  b81f b02f                                bcs l295_2                               ; skip if source is a string
 19197  b821 854b                                sta forpnt
 19198  b823 844c                                sty forpnt+1                             ; save sprite address
 19199  b825 a03e                                ldy #62
 19200                          
 19201  b827 b14b               l295_1           lda (forpnt),y                           ; move sprite def to save area
 19202  b829 999111                              sta savram,y
 19203  b82c 88                                  dey
 19204  b82d 10f8                                bpl l295_1
 19205                          
 19206  b82f c8                                  iny                                      ; (0)
 19207  b830 8cd111                              sty savram+64                            ; save sprite column length
 19208  b833 8cd311                              sty savram+66                            ; save sprite row length
 19209  b836 a917                                lda #23
 19210  b838 8dd011                              sta savram+63
 19211  b83b a914                                lda #20
 19212  b83d 8dd211                              sta savram+65
 19213  b840 a291                                ldx #<savram                             ; set ptr to start of sprite def
 19214  b842 a011                                ldy #>savram
 19215  b844 8670                                stx strng1                               ; **
 19216  b846 8471                                sty strng1+1                             ; **
 19217                          
 19218  b848 a943                                lda #67                                  ; set sprite length including lengths
 19219  b84a 20b75a                              jsr strlit_1                             ; **get string space, copy savram to it
 19220  b84d 20c2b8                              jsr desc_free                            ; **free up temp descriptor
 19221                          
 19222  b850 8eff11             l295_2           stx savsiz                               ; save source length
 19223  b853 8d0012                              sta savsiz+1
 19224  b856 8c0112                              sty savsiz+2                             ; save source start address
 19225                          
 19226  b859 205b4e                              jsr chkcom                               ; check for a comma
 19227  b85c a53d                                lda txtptr                               ; save basic text pointer
 19228  b85e 8d0312                              sta sprtmp_1
 19229  b861 a53e                                lda txtptr+1
 19230  b863 8d0412                              sta sprtmp_2
 19231  b866 20a9b8                              jsr savinp                               ; get next destination parameter
 19232  b869 b022                                bcs savs50                               ; skip if string
 19233                          
 19234  b86b 8587                                sta grapnt
 19235  b86d 8488                                sty grapnt+1                             ; save sprite address
 19236  b86f ad0012                              lda savsiz+1
 19237  b872 854b                                sta forpnt                               ; get source address
 19238  b874 ad0112                              lda savsiz+2
 19239  b877 854c                                sta forpnt+1
 19240  b879 a000                                ldy #0
 19241  b87b ccff11             l295_3           cpy savsiz                               ; test index vs source length
 19242  b87e f00c                                beq l295_4                               ; exit if source depleted
 19243  b880 a94b                                lda #forpnt                              ; move source byte to sprite
 19244  b882 20d722                              jsr lda_far_ram1                         ; (from ram bank 1)
 19245                          ; sta sw_rom_ram0
 19246  b885 9187                                sta (grapnt),y                           ; (to sprite area in bank 0)????
 19247  b887 c8                                  iny
 19248  b888 c03f                                cpy #63
 19249  b88a d0ef                                bne l295_3
 19250  b88c 60                 l295_4           rts
 19251                          
 19252                          
 19253  b88d ad0312             savs50           lda sprtmp_1                             ; restore basic text pointer
 19254  b890 853d                                sta txtptr
 19255  b892 ad0412                              lda sprtmp_2
 19256  b895 853e                                sta txtptr+1
 19257  b897 207c4f                              jsr ptrget                               ; get symbol table descriptor for string dest.
 19258  b89a 854b                                sta forpnt
 19259  b89c 844c                                sty forpnt+1                             ; save symbol table address
 19260  b89e a9ff                                lda #<savsiz
 19261  b8a0 8566                                sta facmo                                ; save descriptor address of source
 19262  b8a2 a911                                lda #>savsiz
 19263  b8a4 8567                                sta facmo+1
 19264  b8a6 830d7e                              +lbra inpcom                             ; move source to dest, do rts (snerr if not eol)
 19265                          
 19266                          ; .page
 19267  b8a9 20ef4c             savinp           jsr frmevl                               ; evaluate expression
 19268  b8ac ff0f13                              bbs7 valtyp,desc_free                    ; exit if a string
 19269  b8af 206f5d                              jsr conint                               ; get one byte integer in .X
 19270                          ; dex    ;adjust sprite 1..8 to 0..7  [910220]
 19271  b8b2 e008                                cpx #8
 19272  b8b4 b34899                              +lbcs fcerr                              ; bad value
 19273  b8b7 8a                                  txa                                      ; move sprite number to .A
 19274  b8b8 4a                                  lsr
 19275  b8b9 6a                                  ror
 19276  b8ba 6a                                  ror                                      ; get sprite address
 19277  b8bb a006                                ldy #>sprite_base
 19278  b8bd 9001                                bcc l296_1
 19279  b8bf c8                                  iny
 19280  b8c0 18                 l296_1           clc                                      ; flag 'sprite' (as opposed to 'string')
 19281  b8c1 60                                  rts
 19282                          
 19283                          
 19284                          desc_free                                                 ; free temporary descriptor, set up pointers to string.
 19285  b8c2 a566                                lda facmo                                ; get address of temp descriptor
 19286  b8c4 a467                                ldy facmo+1
 19287  b8c6 20cc5b                              jsr fretms
 19288  b8c9 a000                                ldy #0                                   ; get len, addr of string
 19289  b8cb 20a922                              jsr indfmo
 19290  b8ce aa                                  tax
 19291  b8cf c8                                  iny
 19292  b8d0 20a922                              jsr indfmo
 19293  b8d3 48                                  pha
 19294  b8d4 c8                                  iny
 19295  b8d5 20a922                              jsr indfmo
 19296  b8d8 a8                                  tay
 19297  b8d9 68                                  pla
 19298  b8da 38                                  sec                                      ; flag 'string found'
 19299  b8db 60                                  rts                                      ; return w/ x=len, (a,y)==> string
 19300                          
 19301                          ;.end
 19302                          ; .page
 19303                          ; .subttl COLLISION Command
 19304                          
 19305                          ;*****************************************************************
 19306                          ; COLLISION Command
 19307                          ;
 19308                          ; Syntax:  COLLISION n [,address]
 19309                          ;
 19310                          ; Where:   n= 1 ==> sprite / sprite
 19311                          ;   2 ==> sprite / background
 19312                          ;   3 ==> light pen
 19313                          ;
 19314                          ; Address ==> BASIC line number to trap to on interrupt
 19315                          ;      (no address ==> disable trapping)
 19316                          ;*****************************************************************
 19317                          
 19318                          collision
 19319  b8dc 206c5d                              jsr getbyt                               ; get type in .X
 19320  b8df ca                                  dex                                      ; adjust 1..3 to 0..2
 19321  b8e0 e003                                cpx #3
 19322  b8e2 b31a99                              +lbcs fcerr                              ; value error
 19323                          
 19324  b8e5 da                                  phx                                      ; save collision type
 19325  b8e6 20f278                              jsr optwrd                               ; get address (line number) in .Y,.A (optional)
 19326  b8e9 fa                                  plx
 19327                          ; php   ;save .C (.C == 1 ==> real value)
 19328  b8ea 9de302                              sta int_adr_hi,x                         ; save address given
 19329  b8ed 8be002                              sty int_adr_lo,x
 19330                          
 19331  b8f0 addc02                              lda intval                               ; this records valid interrupts
 19332  b8f3 1d6579                              ora sbits,x                              ; set correct bit
 19333                          ; plp
 19334  b8f6 b003                                bcs l297_1                               ; ..unless this is a 'clear',
 19335  b8f8 5d6579                              eor sbits,x                              ; ..in which case we'll reset bit
 19336  b8fb 8ddc02             l297_1           sta intval
 19337  b8fe 60                                  rts
 19338                          
 19339                          ;.end
 19340                          ; .page
 19341                          ; .subttl  RCOLOR Function
 19342                          
 19343                          ;************************************************************************
 19344                          ;  RCOLOR (source)  --  return current color assigned to source
 19345                          ;   0  :  Background color
 19346                          ;   1  :  Foreground color
 19347                          ;   2  :  Highlight color
 19348                          ;   3  :  Border color
 19349                          ;************************************************************************
 19350                          
 19351  b8ff 206f5d             rcolor           jsr conint                               ; evaluate integer argument, put in .X
 19352                          ; jsr put_io_in_map
 19353                          
 19354  b902 e004                                cpx #4
 19355  b904 b3f898                              +lbcs fcerr                              ; illegal qty
 19356  b907 8a                                  txa
 19357  b908 0a                                  asl                                      ; make into word pointer
 19358  b909 aa                                  tax
 19359  b90a bd1eb9                              lda color_source,x                       ; get address of source
 19360  b90d 8587                                sta grapnt
 19361  b90f bd1fb9                              lda color_source+1,x
 19362  b912 8588                                sta grapnt+1
 19363  b914 a000                                ldy #0
 19364  b916 b187                                lda (grapnt),y                           ; read source (aways system space or I/O????)
 19365  b918 290f                                and #$0f                                 ; mask unused bits
 19366  b91a a8                                  tay
 19367                          ; iny   ; make color match keytops
 19368  b91b 83b59f                              +lbra sngflt                             ; float 1 byte in .Y
 19369                          
 19370                          color_source
 19371  b91e 21d0f100d80220d0                    !word vic+33,_color,highlight_color,vic+32
 19372                          
 19373                          ; .page
 19374                          ; .subttl Graphic Functions
 19375                          
 19376                          ; Return graphic screen status & parameters      [910826]
 19377                          ; RGRAPHIC (screen, param) where param = 0 open (1), closed (0), or invalid (>1)
 19378                          ;            1 width  (0=320, 1=640, 2=1280)
 19379                          ;            2 height (0=200, 1=400)
 19380                          ;            3 depth (1-8 bitplanes)
 19381                          ;            4 bitplanes used  (bitmask)
 19382                          ;            5 bank A blocks used (bitmask)
 19383                          ;            6 bank B blocks used (bitmask)
 19384                          ;            7 drawscreen # (0-3)
 19385                          ;            8 viewscreen # (0-3)
 19386                          ;            9 drawmodes  (bitmask)
 19387                          ;           10 pattern type  (bitmask)
 19388                          ;
 19389                          ; Requires a kludge, because RGR used to be a normal 1-arg function in the C128
 19390                          ; but now it takes two args.
 19391                          
 19392                          rgraphic
 19393                          ; jsr CheckGraphicMode ;verify screen open
 19394  b926 68                                  pla                                      ; remove token from stack
 19395  b927 20e8b9                              jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820]
 19396                          
 19397  b92a 20584e                              jsr chkopn                               ; check for open paren
 19398  b92d 206c5d                              jsr getbyt                               ; get screen # in .X
 19399  b930 8e001f                              stx GKI__parm1
 19400  b933 20825d                              jsr combyt                               ; get param # in .X
 19401  b936 e00b                                cpx #10+1                                ; [911028]
 19402  b938 b007                                bcs l298_1                               ; illegal param #
 19403  b93a da                                  phx
 19404  b93b 20554e                              jsr chkcls                               ; check for closing parens
 19405                          
 19406  b93e 223880                              jsr ($8038)                              ; read screen params
 19407  b941 b3bb98             l298_1           +lbcs fcerr                              ; bad input????
 19408                          
 19409  b944 ad011f                              lda GKI__parm2
 19410  b947 fa                                  plx                                      ; get back desired param #
 19411  b948 ca                                  dex
 19412  b949 1006                                bpl l298_2
 19413  b94b 4980                                eor #$80                                 ; make 0=closed, 1=open, >1=invalid
 19414  b94d 4a                                  lsr
 19415  b94e 4a                                  lsr
 19416  b94f 8003                                bra l298_3                               ; return screen open status
 19417                          
 19418  b951 ca                 l298_2           dex
 19419  b952 1008                                bpl l298_5
 19420  b954 4a                 l298_3           lsr
 19421  b955 4a                 l298_4           lsr
 19422  b956 4a                                  lsr
 19423  b957 4a                                  lsr
 19424  b958 2903                                and #3
 19425  b95a 8012                                bra l298_8                               ; return width, height
 19426                          
 19427  b95c ca                 l298_5           dex
 19428  b95d 1004                                bpl l298_6
 19429  b95f 2908                                and #8
 19430  b961 80f2                                bra l298_4
 19431  b963 ca                 l298_6           dex
 19432  b964 1005                                bpl l298_7
 19433  b966 2907                                and #7                                   ; return depth
 19434  b968 1a                                  inc                                      ; make depth 1-8
 19435  b969 8003                                bra l298_8
 19436                          
 19437  b96b bd021f             l298_7           lda GKI__parm3,x                         ; return bp bask, banks, etc.
 19438  b96e a8                 l298_8           tay
 19439  b96f 20d258                              jsr sngflt                               ; float 1 byte arg in .y
 19440                          
 19441  b972 20f9b9                              jsr PopParms                             ; restore Graphics parameters & LINNUM
 19442  b975 60                                  rts
 19443                          
 19444                          ; .page
 19445                          ; Return the color of a given X,Y pixel location on the drawscreen  [910801]
 19446                          ;  PIXEL (x,y)
 19447                          
 19448  b976 201caf             pixel            jsr CheckGraphicMode                     ; verify screen open
 19449  b979 20e8b9                              jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820]
 19450                          
 19451  b97c 20925d                              jsr getsad                               ; get x
 19452  b97f 8c001f                              sty GKI__parm1
 19453  b982 8d011f                              sta GKI__parm2
 19454  b985 200879                              jsr comsad                               ; get y
 19455  b988 8c021f                              sty GKI__parm3
 19456  b98b 8d031f                              sta GKI__parm4
 19457  b98e 20554e                              jsr chkcls                               ; check for closing parens
 19458                          
 19459  b991 223280                              jsr ($8032)                              ; get Bitplane data at pixel (x,y), returned in .y
 19460  b994 20d258                              jsr sngflt                               ; go float 1 byte arg in .Y
 19461                          
 19462  b997 20f9b9                              jsr PopParms                             ; restore graphics parameters
 19463  b99a 60                                  rts
 19464                          
 19465                          ; .page
 19466                          ; Return the color of a drawscreen's PEN      [910820]
 19467                          ;  RPEN (pen#) where pen# = 0,1,2
 19468                          
 19469  b99b 201caf             rpen             jsr CheckGraphicMode                     ; verify screen open
 19470  b99e 20e8b9                              jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820]
 19471                          
 19472  b9a1 206f5d                              jsr conint                               ; get 1 byte arg in .x (old style single arg function)
 19473  b9a4 e003                                cpx #3
 19474  b9a6 b006                                bcs l299_1                               ; illegal pen #?
 19475  b9a8 8e001f                              stx GKI__parm1
 19476                          
 19477  b9ab 223680                              jsr ($8036)                              ; convert to logical color# (palette index#)
 19478  b9ae b34e98             l299_1           +lbcs fcerr                              ; drawscreen not set or illegal quantity somewhere
 19479                          
 19480  b9b1 20d258                              jsr sngflt                               ; go float 1 byte arg in .Y
 19481                          
 19482  b9b4 20f9b9                              jsr PopParms                             ; restore graphics parameters
 19483  b9b7 60                                  rts
 19484                          
 19485                          ; .page
 19486                          ; Return the R,G, or B component of a color     [910820]
 19487                          ; RPALETTE (screen#, color#, rgb)
 19488                          
 19489                          rpalette
 19490  b9b8 201caf                              jsr CheckGraphicMode                     ; verify screen open
 19491  b9bb 20e8b9                              jsr PushParms                            ; Save graphics parameters
 19492                          
 19493  b9be 206f5d                              jsr conint                               ; get screen# in .x
 19494  b9c1 e004                                cpx #4
 19495  b9c3 b013                                bcs l300_1                               ; illegal screen#
 19496  b9c5 8e001f                              stx GKI__parm1
 19497                          
 19498  b9c8 20825d                              jsr combyt                               ; get color# in .x ????check for legal color#
 19499  b9cb 8e011f                              stx GKI__parm2
 19500                          
 19501  b9ce 223480                              jsr ($8034)                              ; get RGB components of color# in PARM3,4,5
 19502  b9d1 b005                                bcs l300_1                               ; something is wrong????
 19503                          
 19504  b9d3 20825d                              jsr combyt                               ; get r,g,b component#
 19505  b9d6 e003                                cpx #3
 19506  b9d8 b32498             l300_1           +lbcs fcerr                              ; illegal value
 19507                          
 19508  b9db bc021f                              ldy GKI__parm3,x                         ; get r,g,b value
 19509  b9de 20d258                              jsr sngflt                               ; float 1 byte arg in .y
 19510                          
 19511  b9e1 20554e                              jsr chkcls                               ; check for closing paren
 19512  b9e4 20f9b9                              jsr PopParms                             ; restore graphics parameters
 19513  b9e7 60                                  rts
 19514                          
 19515                          ; .page
 19516                          PushParms                                                 ; [910820]
 19517  b9e8 7a                                  ply                                      ; Grab return address
 19518  b9e9 fb                                  plz
 19519                          
 19520  b9ea fc1600                              phw linnum                               ; Save 'poker' value
 19521                          
 19522  b9ed a210                                ldx #17-1
 19523  b9ef bd001f             l301_1           lda GKI__parm1,x                         ; Save Graphics parameters
 19524  b9f2 48                                  pha                                      ; [eg: CHAR x,y,1,1,2,str$(PIXEL(x,y))]
 19525  b9f3 ca                                  dex
 19526  b9f4 10f9                                bpl l301_1
 19527                          
 19528  b9f6 db                                  phz                                      ; Restore return address
 19529  b9f7 5a                                  phy
 19530  b9f8 60                                  rts
 19531                          
 19532                          
 19533                          PopParms                                                  ; [910820]
 19534  b9f9 7a                                  ply                                      ; Grab return address
 19535  b9fa fb                                  plz
 19536                          
 19537  b9fb a200                                ldx #0
 19538  b9fd 68                 l302_1           pla                                      ; Restore Graphics parameters
 19539  b9fe 9d001f                              sta GKI__parm1,x
 19540  ba01 e8                                  inx
 19541  ba02 e011                                cpx #17
 19542  ba04 90f7                                bcc l302_1
 19543                          
 19544  ba06 68                                  pla                                      ; Restore 'poker' value
 19545  ba07 8517                                sta linnum+1
 19546  ba09 68                                  pla
 19547  ba0a 8516                                sta linnum
 19548                          
 19549  ba0c db                                  phz                                      ; Restore return address
 19550  ba0d 5a                                  phy
 19551  ba0e 60                                  rts
 19552                          
 19553                          ;.end
 19554                          ; .page
 19555                          ; .subttl RSPRITE Function
 19556                          
 19557                          ;******************************************************************
 19558                          ;* RSPRITE - Return sprite information
 19559                          ;*
 19560                          ;* Syntax : RSPRITE (sprite_number, argument)
 19561                          ;*
 19562                          ;* Where  : sprite_number = [0..7]
 19563                          ;*   argument = [0..5]
 19564                          ;*   0 : enabled?   (y(1)/n(0))
 19565                          ;*   1 : color?     (0-15)
 19566                          ;*   2 : priority over background? (y(1)/n(0))
 19567                          ;*   3 : expand in x direction? (y(1)/n(0))
 19568                          ;*   4 : expand in Y direction? (y(1)/n(0))
 19569                          ;*   5 : multicolor sprite?  (y(1)/n(0))
 19570                          ;******************************************************************
 19571                          
 19572  ba0f 206f5d             rsprite          jsr conint                               ; get first arg, sprite #, in .X
 19573                          ; dex  ;adjust [1..8] to [0..7]   [910220]
 19574  ba12 e008                                cpx #8  ; (318018-03 mod                 ; fab)
 19575  ba14 b00a                                bcs l303_1                               ; value error
 19576  ba16 8a                                  txa
 19577  ba17 48                                  pha                                      ; save sprite number
 19578                          
 19579                          ; jsr chkcom ;check for proper delimiter
 19580                          ; jsr getbyt ;do frmevl, get 1 byte arg (arg) in .X
 19581  ba18 20825d                              jsr combyt                               ; [910820]
 19582  ba1b 20554e                              jsr chkcls                               ; look for closing paren
 19583  ba1e e006                                cpx #6
 19584  ba20 b3dc97             l303_1           +lbcs fcerr                              ; value error
 19585                          
 19586  ba23 7a                                  ply                                      ; sprite number
 19587                          ; jsr put_io_in_map
 19588  ba24 b927d0                              lda vic+39,y                             ; assume 'color'
 19589  ba27 290f                                and #$0f                                 ; range 0-15
 19590                          ; inc a  ;adjust to 'keyboard' colors   [910724]
 19591  ba29 e001                                cpx #1
 19592  ba2b f00e                                beq l303_2                               ; it was color. set up for float
 19593                          
 19594  ba2d bd3fba                              lda rspmod,x                             ; get index for this function
 19595  ba30 aa                                  tax
 19596  ba31 b96579                              lda sbits,y                              ; get mask for this sprite number
 19597  ba34 3d00d0                              and vic,x
 19598  ba37 f002                                beq l303_2
 19599  ba39 a901                                lda #1                                   ; return all non-zeros as '1'
 19600                          
 19601  ba3b a8                 l303_2           tay
 19602  ba3c 83949e                              +lbra sngflt                             ; go float 1 byte arg in .Y
 19603                          
 19604                          
 19605  ba3f 15271b1d171c       rspmod           !text 21,39,27,29,23,28                  ; VIC registers associated with arg#
 19606                          
 19607                          ;.end
 19608                          ; .page
 19609                          ; .subttl RSPCOLOR Function
 19610                          
 19611                          ;******************************************************************
 19612                          ;* RSPCOLOR - return sprite multicolor reg's
 19613                          ;*
 19614                          ;* Syntax : RSPCOLOR (argument)
 19615                          ;*
 19616                          ;* Where  : argument = [1..2]
 19617                          ;*   1 : return multicolor #1
 19618                          ;*   2 : return multicolor #2
 19619                          ;******************************************************************
 19620                          
 19621                          rspcolor
 19622  ba45 20554e                              jsr chkcls                               ; check for closing paren
 19623  ba48 206f5d                              jsr conint                               ; get arg in .X
 19624  ba4b ca                                  dex                                      ; adjust [1..2] to [0..1
 19625  ba4c e002                                cpx #2
 19626  ba4e b3ae97                              +lbcs fcerr                              ; value error
 19627                          
 19628                          ; jsr put_io_in_map
 19629  ba51 bd25d0                              lda vic+37,x
 19630  ba54 290f                                and #$0f
 19631  ba56 a8                                  tay
 19632                          ; iny  ;range 0-15     [910724]
 19633  ba57 83799e                              +lbra sngflt                             ; float 1 byte arg in .Y
 19634                          
 19635                          ;.end
 19636                          ; .page
 19637                          ; .subttl RSPPOS Function
 19638                          
 19639                          ;******************************************************************
 19640                          ;* RSPPOS - Return sprite location / speed data
 19641                          ;*
 19642                          ;* Syntax:  RSPPOS (sprite_number, argument)
 19643                          ;*
 19644                          ;* Where:   sprite_number = [0..7]
 19645                          ;*    argument = [0..2]
 19646                          ;*   0 : return X position
 19647                          ;*   1 : return Y position
 19648                          ;*   2 : return current speed
 19649                          ;******************************************************************
 19650                          
 19651  ba5a 206f5d             rsppos           jsr conint                               ; get first arg, sprite #, in .X
 19652                          ; dex  ;adjust [1..8] to [0..7]   [910220]
 19653  ba5d e008                                cpx #8  ; (318018-03 mod                 ; fab)
 19654  ba5f b009                                bcs l304_1                               ; value error
 19655                          
 19656  ba61 da                                  phx                                      ; save sprite number
 19657                          ; jsr chkcom ;check for proper delimiter
 19658                          ; jsr getbyt ;do frmevl, get 1 byte arg (arg) in .X
 19659  ba62 20825d                              jsr combyt                               ; [910820]
 19660  ba65 20554e                              jsr chkcls                               ; look for closing paren
 19661  ba68 e003                                cpx #3
 19662  ba6a b39297             l304_1           +lbcs fcerr                              ; value error
 19663                          
 19664  ba6d 7a                                  ply                                      ; sprite number
 19665  ba6e e002                                cpx #2
 19666  ba70 d009                                bne l304_2                               ; branch if x or y position
 19667                          
 19668  ba72 befeb7                              ldx sproff,y                             ; get offset into speed data
 19669  ba75 bc0512                              ldy sprite_data,x                        ; get speed data
 19670  ba78 83589e                              +lbra sngflt                             ; go float 1 byte arg in .Y
 19671                          
 19672                          ; Get msb of sprite position (in case this is for x position)
 19673                          
 19674  ba7b 78                 l304_2           sei
 19675  ba7c b96579                              lda sbits,y                              ; get bit mask for this sprite
 19676  ba7f 2d10d0                              and vic+16                               ; ???vic_save
 19677  ba82 f002                                beq l304_3
 19678  ba84 a901                                lda #1                                   ; change any non-zero to a '1'
 19679  ba86 48                 l304_3           pha                                      ; save msb
 19680                          
 19681  ba87 98                                  tya                                      ; y = sprite# * 2
 19682  ba88 0a                                  asl
 19683  ba89 a8                                  tay
 19684  ba8a 8a                                  txa                                      ; see if this is y position
 19685  ba8b 4a                                  lsr                                      ; .C = 0 for x pos'n, 1 for y pos'n
 19686  ba8c 9005                                bcc l304_4                               ; branch if x pos'n
 19687                          
 19688  ba8e c8                                  iny                                      ; adjust pointer to point to y pos'n in register data
 19689  ba8f 68                                  pla
 19690  ba90 a900                                lda #0                                   ; ..and force 'msb' to be zero
 19691  ba92 48                                  pha
 19692                          
 19693  ba93 b900d0             l304_4           lda vic,y                                ; get correct location lsb   ???vic_save
 19694  ba96 58                                  cli
 19695  ba97 a8                                  tay
 19696  ba98 68                                  pla                                      ; ..and get msb,
 19697  ba99 832c9e                              +lbra nosflt                             ; ..and go float 2 byte value in y,a
 19698                          
 19699                          ;.end
 19700                          ; .page
 19701                          ; .subttl BUMP Function
 19702                          
 19703                          ;******************************************************************
 19704                          ;* BUMP - read sprite collision
 19705                          ;*
 19706                          ;* Syntax : BUMP (argument)
 19707                          ;*
 19708                          ;* Where  : argument = [1..2]
 19709                          ;*   1 : sprite/sprite collision
 19710                          ;*   2 : sprite/background collision
 19711                          ;******************************************************************
 19712                          
 19713  ba9c 20554e             bump             jsr chkcls
 19714  ba9f 206f5d                              jsr conint                               ; get arg in .X
 19715  baa2 ca                                  dex                                      ; adjust [1..2] to [0..1]
 19716  baa3 e002                                cpx #2
 19717  baa5 b35797                              +lbcs fcerr                              ; value error
 19718                          
 19719  baa8 78                                  sei
 19720  baa9 bce602                              ldy collisions,x                         ; get recorded collisions
 19721  baac a900                                lda #0                                   ; reset them
 19722  baae 9de602                              sta collisions,x
 19723  bab1 58                                  cli
 19724  bab2 831e9e                              +lbra sngflt                             ; float 1 byte arg in .Y
 19725                          
 19726                          ;.end
 19727                          ; .page
 19728                          ; .subttl Sprite Support Routines
 19729                          
 19730                          ; GRAPHIC3.SRC
 19731                          ;****************************************************************
 19732                          ;  getang  -  set cosine & sine values
 19733                          ;             results in sinval & cosval based as a fraction
 19734                          ;             - over 65536
 19735                          ;             angsgn = angle phase (0-3)
 19736                          ;    on input vwork+y = 2 byte angle
 19737                          ;***************************************************************
 19738                          
 19739                          getang
 19740  bab5 2075bb                              jsr settwo                               ; move angle value into y/a
 19741                          
 19742  bab8 a200               gtang1           ldx #0                                   ; init count of phase
 19743                          
 19744  baba e8                 l305_1           inx
 19745  babb 38                                  sec
 19746  babc e95a                                sbc #90                                  ; subtract 90 until less than 0
 19747  babe b0fa                                bcs l305_1
 19748  bac0 88                                  dey
 19749  bac1 10f7                                bpl l305_1
 19750  bac3 8efa11                              stx angsgn                               ; save phase (here it is 1-4)
 19751  bac6 48                                  pha
 19752  bac7 695a                                adc #90                                  ; make positive
 19753  bac9 20d5ba                              jsr l305_2                               ; do division by 10
 19754  bacc 68                                  pla                                      ; get 2's comp of angle
 19755  bacd 18                                  clc
 19756  bace 49ff                                eor #$ff
 19757  bad0 6901                                adc #1                                   ; make positive
 19758  bad2 cefa11                              dec angsgn                               ; correct phase
 19759                          
 19760  bad5 a2ff               l305_2           ldx #$ff
 19761  bad7 e8                 l305_3           inx                                      ; do division by 10
 19762  bad8 38                                  sec
 19763  bad9 e90a                                sbc #10
 19764  badb b0fa                                bcs l305_3
 19765  badd 690a                                adc #10                                  ; make positive
 19766  badf 8df511                              sta vtemp1                               ; save remainder
 19767  bae2 8a                                  txa
 19768  bae3 0a                                  asl                                      ; get quotient*2 as index
 19769  bae4 aa                                  tax
 19770  bae5 bda2bc                              lda angval+1,x                           ; get low byte base
 19771  bae8 bca1bc                              ldy angval,x                             ; get high byte value
 19772                          
 19773  baeb 18                 l305_4           clc
 19774  baec cef511                              dec vtemp1
 19775  baef 300c                                bmi l305_5                               ; done - remainder = 0
 19776  baf1 7db6bc                              adc incval+1,x                           ; add low byte increment
 19777  baf4 48                                  pha
 19778  baf5 98                                  tya
 19779  baf6 7db5bc                              adc incval,x                             ; add high byte increment
 19780  baf9 a8                                  tay
 19781  bafa 68                                  pla
 19782  bafb 90ee                                bcc l305_4                               ; ...always
 19783                          
 19784  bafd 48                 l305_5           pha                                      ; save low byte of result
 19785  bafe a200                                ldx #0                                   ; point to sinval
 19786  bb00 adfa11                              lda angsgn
 19787  bb03 4a                                  lsr
 19788  bb04 b002                                bcs l305_6                               ; skip if sine value
 19789  bb06 a202                                ldx #2                                   ; point to cosval
 19790                          
 19791  bb08 68                 l305_6           pla
 19792  bb09 9dfb11                              sta sinval,x                             ; save low byte result
 19793  bb0c 98                                  tya
 19794  bb0d 9dfc11                              sta sinval+1,x                           ; save high byte result
 19795  bb10 60                                  rts
 19796                          
 19797                          ; .page
 19798                          ;*************************************************************
 19799                          ;  angmlt  -  multiple 2-byte integer times angle
 19800                          ;       carry set/reset = cosine/sine
 19801                          ;
 19802                          ;       vwork+x = 2-byte integer
 19803                          ;       result left in y/a
 19804                          ;*************************************************************
 19805                          
 19806                          angmlt
 19807  bb11 a00f                                ldy #sinval-vwork                        ; get offset to angle value
 19808  bb13 9002                                bcc l306_1                               ; get cosine/sine offset
 19809  bb15 a011                                ldy #cosval-vwork
 19810                          
 19811  bb17 adfa11             l306_1           lda angsgn
 19812  bb1a 6902                                adc #2                                   ; correct phase for cosine to look as sine
 19813  bb1c 4a                                  lsr
 19814  bb1d 4a                                  lsr
 19815  bb1e 08                                  php                                      ; save if carry - means negative angle value
 19816  bb1f 2075bb                              jsr settwo                               ; get angle fraction in y/a
 19817  bb22 c0ff                                cpy #$ff                                 ; test if value should be 1
 19818  bb24 9007                                bcc l306_2                               ; skip if not
 19819  bb26 8a                                  txa
 19820  bb27 a8                                  tay                                      ; get offset to integer
 19821  bb28 2075bb                              jsr settwo                               ; just get integer - multiplied by 1
 19822  bb2b b003                                bcs l306_3
 19823                          
 19824  bb2d 2094bb             l306_2           jsr twobyt                               ; multiply integer times angle value
 19825  bb30 28                 l306_3           plp                                      ; get sign of angle
 19826  bb31 9051                                bcc invert                               ; invert result if negative,do rts
 19827  bb33 60                                  rts
 19828                          
 19829                          ; .page
 19830                          ;*************************************************************
 19831                          ;  angdst  -  set up values for distance * angles
 19832                          ;       vwork+x = x & y distances
 19833                          ;       a = angles : ang1,ang2,ang3,ang4,0,0,0,0
 19834                          ;       get  xdist1 = xdist1 * angle-1
 19835                          ;     ydist1 = ydist1 * angle-2
 19836                          ;     xdist2 = xdist2 * angle-3
 19837                          ;     ydist2 = ydist2 * angle-4
 19838                          ;*************************************************************
 19839                          ;
 19840                          ;angdst
 19841                          ; sta angcnt      ;save angles
 19842                          ; ldx #xdist1-vwork
 19843                          ;angd10
 19844                          ; asl angcnt
 19845                          ; jsr angmlt      ;multiply angle * distance
 19846                          ; sta vwork,x
 19847                          ; tya  ;save results
 19848                          ; sta vwork+1,x
 19849                          ; inx  ;point to next distance
 19850                          ; inx
 19851                          ; cpx #disend-vwork
 19852                          ; bcc angd10 ;loop 4 times
 19853                          ;angd20 rts
 19854                          
 19855                          ;.end
 19856                          ; .page
 19857                          ; GRAPHIC8.SRC
 19858                          ;****************************************************************
 19859                          ;  docolr  --  set up color for 8x8 charcater cell
 19860                          ;   x = row number  --  y = column number
 19861                          ;****************************************************************
 19862                          ;
 19863                          ;docolr lda _ldtb2,x      ;put address of video ram into grapnt
 19864                          ; sta grapnt
 19865                          ; lda graphic_ldtb1,x ;point to bit mapped color area
 19866                          ; sta grapnt+1
 19867                          ;
 19868                          ; lda colsel  ;get current color source selected
 19869                          ;
 19870                          ; bne l306_1   ;branch if NOT background
 19871                          ; lda fg_bg
 19872                          ; bit _graphm  ;test if mode = hires
 19873                          ; bpl 25$   ;if so, go set up byte
 19874                          ; rts   ;else exit
 19875                          ;
 19876                          ;l306_1 cmp #2
 19877                          ; bne l306_3   ;branch if NOT multi-color 1
 19878                          ;
 19879                          ;l306_2 lda fg_mc1  ;get correct packed colors for multicolor mode.
 19880                          ;25$ and #$0f
 19881                          ; sta z_p_temp_1
 19882                          ; lda (grapnt),y
 19883                          ; and #$f0
 19884                          ; ora z_p_temp_1
 19885                          ; sta (grapnt),y
 19886                          ; rts
 19887                          ;
 19888                          ;l306_3 bcs 40$   ;branch if multicolor 2
 19889                          ;
 19890                          ; lda fg_bg  ;here for foreground. get packed colors.
 19891                          ; and #$f0
 19892                          ; sta z_p_temp_1
 19893                          ; lda (grapnt),y  ;do foreground
 19894                          ; and #$0f
 19895                          ; ora z_p_temp_1
 19896                          ; sta (grapnt),y
 19897                          ; rts
 19898                          ;
 19899                          ;40$ lda grapnt+1  ;do multicolor 2
 19900                          ; and #3
 19901                          ; ora #>color_ram_hi ;set up to point to high color area
 19902                          ; sta grapnt+1
 19903                          ;
 19904                          ; lda #0   ;put i/o in map
 19905                          ; sta mmu_config_reg
 19906                          ;
 19907                          ; sei
 19908                          ; lda _6510_data_reg
 19909                          ; pha
 19910                          ; and #%11111110  ;point cpu at correct nybble bank
 19911                          ; sta _6510_data_reg
 19912                          ; lda multicolor_2
 19913                          ; sta (grapnt),y
 19914                          ; pla
 19915                          ; sta _6510_data_reg
 19916                          ; cli
 19917                          ; rts
 19918                          ;
 19919                          ;
 19920                          ;
 19921                          ;graphic_ldtb1   ;_ldtb1 adjusted for an org at color_ram_lo
 19922                          ;99$=color_ram_lo
 19923                          ;1$=color_ram_lo+40*1
 19924                          ;2$=color_ram_lo+40*2
 19925                          ;3$=color_ram_lo+40*3
 19926                          ;4$=color_ram_lo+40*4
 19927                          ;5$=color_ram_lo+40*5
 19928                          ;6$=color_ram_lo+40*6
 19929                          ;7$=color_ram_lo+40*7
 19930                          ;8$=color_ram_lo+40*8
 19931                          ;9$=color_ram_lo+40*9
 19932                          ;l306_1=color_ram_lo+40*10
 19933                          ;11$=color_ram_lo+40*11
 19934                          ;12$=color_ram_lo+40*12
 19935                          ;13$=color_ram_lo+40*13
 19936                          ;14$=color_ram_lo+40*14
 19937                          ;15$=color_ram_lo+40*15
 19938                          ;16$=color_ram_lo+40*16
 19939                          ;17$=color_ram_lo+40*17
 19940                          ;18$=color_ram_lo+40*18
 19941                          ;19$=color_ram_lo+40*19
 19942                          ;l306_2=color_ram_lo+40*20
 19943                          ;21$=color_ram_lo+40*21
 19944                          ;22$=color_ram_lo+40*22
 19945                          ;23$=color_ram_lo+40*23
 19946                          ;24$=color_ram_lo+40*24
 19947                          ;
 19948                          ; .byte >99$,>1$,>2$,>3$,>4$,>5$,>6$,>7$,>8$,>9$,>l306_1
 19949                          ; .byte >11$,>12$,>13$,>14$,>15$,>16$,>17$,>18$,>19$
 19950                          ; .byte >l306_2,>21$,>22$,>23$,>24$
 19951                          
 19952                          ; .page
 19953                          ;******************************************************************
 19954                          ;  getpos - get address in graphic bit map into grapnt
 19955                          ;      x = bit offset into byte specified (0-7)
 19956                          ;      y = offset to byte within 8x8 character cell
 19957                          ;      a = bit mask to the bit (or bits if multicolor mode)
 19958                          ;******************************************************************
 19959                          ;
 19960                          ;getpos jsr divpos      ;get xpos/ypos to column/row position
 19961                          ; bcs grprts      ;abort if position too large
 19962                          ;
 19963                          ;getps1 tya  ;get addr for row (X) and col (Y) in grapnt
 19964                          ; clc
 19965                          ; adc _ldtb2,x ;add column position to low byte offset
 19966                          ; sta grapnt
 19967                          ; lda _ldtb1,x ;get high byte screen address
 19968                          ; adc #0  ;add any carry
 19969                          ; asl grapnt
 19970                          ; rol a
 19971                          ; asl grapnt ;mult by 8 to get offset into 8k area
 19972                          ; rol a
 19973                          ; asl grapnt
 19974                          ; rol a
 19975                          ; sta grapnt+1
 19976                          ;
 19977                          ; lda ypos
 19978                          ; and #07
 19979                          ; tay  ;get byte offset into 8x8 char cell
 19980                          ; lda xpos
 19981                          ; bit _graphm
 19982                          ; php
 19983                          ; bpl grpos3 ;skip if not multicolor mode
 19984                          ; asl a  ;shift x-pos for multicolor mode
 19985                          ;
 19986                          ;grpos3 and #07
 19987                          ; tax
 19988                          ; lda rbits,x ;get bit mask
 19989                          ; plp
 19990                          ; bpl grprts ;done if not multicolor mode
 19991                          ; inx
 19992                          ; ora rbits,x ;mask for 2 bits if multicolor mode
 19993                          ;grprts rts
 19994                          ;
 19995                          ;rbits .byte   $80,$40,$20,$10,$08,$04,$02,$01
 19996                          
 19997                          ; .page
 19998                          ;**************************************************************
 19999                          ;  divpos  --  convert xpos to column number
 20000                          ;  convert ypos to row number
 20001                          ;  return carry set if either above limits
 20002                          ;**************************************************************
 20003                          ;
 20004                          ;divpos lda xpos+1
 20005                          ; lsr a
 20006                          ; bne l306_2       ;out of bounds if greater than 1
 20007                          ; lda xpos
 20008                          ; ror a
 20009                          ; lsr a  ;get column position = xpos/8
 20010                          ; bit _graphm
 20011                          ; bmi l306_1  ;skip if multicolor mode
 20012                          ; lsr a  ;divide by 8 if a hires or text mode
 20013                          ;l306_1 tay
 20014                          ; cpy #llen
 20015                          ; bcs l306_2  ;error exit if out of bounds
 20016                          ; lda ypos+1
 20017                          ; bne l306_2  ;out of bounds error if not = 0
 20018                          ; lda ypos
 20019                          ; lsr a
 20020                          ; lsr a  ;get row number = ypos/8
 20021                          ; lsr a
 20022                          ; tax
 20023                          ; cmp #nlines ;compare to max number of rows
 20024                          ; rts  ;carry clr if okay
 20025                          ;l306_2 sec
 20026                          ; rts
 20027                          
 20028                          ; .page
 20029                          ;***************************************************************
 20030                          ;   SCALXY  - Scale the x & y coordinates found in vwork+x
 20031                          ;***************************************************************
 20032                          ;
 20033                          ;scalxy lda scalem
 20034                          ; beq sclrts      ;do nothing if scaling off
 20035                          ;
 20036                          ; lda scale_x
 20037                          ; ldy scale_x+1
 20038                          ; jsr doscal      ;scale in the x-direction
 20039                          ;
 20040                          ; lda scale_y
 20041                          ; ldy scale_y+1 ;scale in the y direction
 20042                          ;
 20043                          ;doscal jsr twobyt ;multiply * coordinate
 20044                          ; sta vwork,x
 20045                          ; tya
 20046                          ; inx  ;store back into original position
 20047                          ; sta vwork,x
 20048                          ; inx
 20049                          ;sclrts
 20050                          ; rts
 20051                          
 20052                          ;.end
 20053                          ; .page
 20054                          ;GRAPHICS9.SRC
 20055                          ;***************************************************************
 20056                          ;   DOTWO  - Add      two 2-byte values if carry clear
 20057                          ;  Subtract two 2-byte values if carry set
 20058                          ;***************************************************************
 20059                          
 20060                          dotwo2
 20061  bb34 9007                                bcc addtw2                               ; go do addition
 20062  bb36 b014                                bcs subtw2                               ; go do subtraction
 20063                          dotwo
 20064  bb38 b00f                                bcs subtwo                               ; go do subtraction
 20065                          
 20066                          ;***************************************************************
 20067                          ;  ADDTWO  - Add vwork+y and vwork+x  Result in y/a
 20068                          ;***************************************************************
 20069                          
 20070                          addtwo
 20071  bb3a 2075bb                              jsr settwo                               ; put vwrok+y into y/a
 20072                          
 20073                          addtw2                                                    ; enter here to add y/a to vwork+x
 20074  bb3d 18                                  clc
 20075  bb3e 7dec11                              adc vwork,x
 20076  bb41 48                                  pha
 20077  bb42 98                                  tya
 20078  bb43 7ded11                              adc vwork+1,x
 20079  bb46 a8                                  tay
 20080  bb47 68                                  pla
 20081  bb48 60                                  rts
 20082                          
 20083                          ; .page
 20084                          ;****************************************************************
 20085                          ;  SUBTWO  - Subtract vwork+y - vwork+x Result in y/a
 20086                          ;****************************************************************
 20087                          
 20088                          subtwo
 20089  bb49 2075bb                              jsr settwo                               ; move vwork+y into y/a
 20090                          
 20091                          subtw2                                                    ; enter here with 1st value in y/a
 20092  bb4c 38                                  sec
 20093  bb4d fdec11                              sbc vwork,x
 20094  bb50 8559                                sta tempf1
 20095  bb52 98                                  tya
 20096  bb53 fded11                              sbc vwork+1,x
 20097  bb56 a8                                  tay
 20098  bb57 08                                  php
 20099  bb58 a559                                lda tempf1
 20100  bb5a 28                                  plp
 20101  bb5b 60                                  rts
 20102                          
 20103                          
 20104                          subtwo_savram
 20105  bb5c b99111                              lda savram,y                             ; load value into y,a
 20106  bb5f 48                                  pha
 20107  bb60 b99211                              lda savram+1,y
 20108  bb63 a8                                  tay
 20109  bb64 68                                  pla
 20110  bb65 38                                  sec
 20111  bb66 fd9111                              sbc savram,x
 20112  bb69 8559                                sta tempf1
 20113  bb6b 98                                  tya
 20114  bb6c fd9211                              sbc savram+1,x
 20115  bb6f a8                                  tay
 20116  bb70 08                                  php
 20117  bb71 a559                                lda tempf1
 20118  bb73 28                                  plp
 20119  bb74 60                                  rts
 20120                          
 20121                          ; .page
 20122                          ;************************************************************
 20123                          ;  SETTWO  - Move value in vwork+y into y/a
 20124                          ;************************************************************
 20125                          
 20126                          settwo
 20127  bb75 b9ec11                              lda vwork,y
 20128  bb78 48                                  pha
 20129  bb79 b9ed11                              lda vwork+1,y
 20130  bb7c a8                                  tay
 20131  bb7d 68                                  pla
 20132  bb7e 60                                  rts
 20133                          
 20134                          ;******************************************************************
 20135                          ;  ABSTWO  - Get absolute value of vwork+y - vwork+x
 20136                          ;  Result in y/a  -  carry === vwork+y >= vwork+x
 20137                          ;******************************************************************
 20138                          
 20139                          abstwo                                                    ; movspr_to [910809]
 20140  bb7f 2049bb                              jsr subtwo                               ; subtract vwork+y - vwork+x
 20141                          abstw2                                                    ; entrance with vwork+y in y/a
 20142  bb82 100f                                bpl absrts                               ; done if result is positive
 20143  bb84 08                 invert           php
 20144  bb85 18                                  clc
 20145  bb86 49ff                                eor #$ff                                 ; invert low byte result and add 1
 20146  bb88 6901                                adc #1
 20147  bb8a 48                                  pha
 20148  bb8b 98                                  tya
 20149  bb8c 49ff                                eor #$ff                                 ; invert high byte result
 20150  bb8e 6900                                adc #0                                   ; add back any carry
 20151  bb90 a8                                  tay
 20152  bb91 68                                  pla
 20153  bb92 28                                  plp
 20154  bb93 60                 absrts           rts
 20155                          
 20156                          ; .page
 20157                          ;****************************************************************
 20158                          ;  TWOBYT  - Multiply 2 byte fraction in y/a times 2 bytes
 20159                          ;  Integer found in vwork+x-reg.  Result = y/a
 20160                          ;****************************************************************
 20161                          
 20162                          twobyt
 20163  bb94 8cf511                              sty vtemp1                               ; save fraction
 20164  bb97 8df611                              sta vtemp2
 20165  bb9a bdec11                              lda vwork,x
 20166  bb9d bced11                              ldy vwork+1,x
 20167  bba0 08                                  php                                      ; save sign of integer
 20168  bba1 2082bb                              jsr abstw2                               ; absolute value
 20169  bba4 9dec11                              sta vwork,x
 20170  bba7 98                                  tya
 20171  bba8 9ded11                              sta vwork+1,x
 20172  bbab a900                                lda #0
 20173  bbad 8df711                              sta vtemp3                               ; initialize result to zero
 20174                          
 20175  bbb0 a010                                ldy #16                                  ; initialize count
 20176  bbb2 4ef511             l307_1           lsr vtemp1
 20177  bbb5 6ef611                              ror vtemp2
 20178  bbb8 900f                                bcc l307_2                               ; skip if no bit set
 20179  bbba 18                                  clc
 20180  bbbb 7dec11                              adc vwork,x                              ; add integer low byte
 20181  bbbe 48                                  pha
 20182  bbbf adf711                              lda vtemp3
 20183  bbc2 7ded11                              adc vwork+1,x                            ; add integer high byte to total
 20184  bbc5 8df711                              sta vtemp3
 20185  bbc8 68                                  pla
 20186                          
 20187  bbc9 4ef711             l307_2           lsr vtemp3                               ; divide by 2
 20188  bbcc 6a                                  ror
 20189  bbcd 88                                  dey
 20190  bbce d0e2                                bne l307_1                               ; loop 16 times - test all bits in 2 bytes
 20191                          
 20192  bbd0 6900                                adc #0                                   ; add back round factor
 20193  bbd2 acf711                              ldy vtemp3
 20194  bbd5 9001                                bcc l307_3
 20195  bbd7 c8                                  iny
 20196  bbd8 28                 l307_3           plp                                      ; pop sign
 20197  bbd9 80a7                                bra abstw2                               ; return with signed product in y/a
 20198                          
 20199                          ; .page
 20200                          ;******************************************************************
 20201                          ;  dstpos  -  move xdest/ydest to xpos/ypos
 20202                          ;******************************************************************
 20203                          ;
 20204                          ;dstpos
 20205                          ; ldy #0
 20206                          ; jsr dstmov
 20207                          ; ldy #2
 20208                          ;dstmov
 20209                          ; lda xdest,y
 20210                          ; sta xpos,y
 20211                          ; lda xdest+1,y
 20212                          ; sta xpos+1,y
 20213                          ; rts
 20214                          
 20215                          ;.end
 20216                          ; .page
 20217                          ;GRAPHICS10.SRC
 20218                          ;************************************************************
 20219                          ;   incolr  --  get color selection parameter into colsel
 20220                          ;************************************************************
 20221                          ;
 20222                          ;incolr
 20223                          ; ldx #1   ;get an optional 1 byte val, def=fg(1)
 20224                          ; jsr chrgot
 20225                          ;incol1
 20226                          ; beq incol2       ;eol, use default
 20227                          ; cmp #','
 20228                          ; beq incol2       ;just ',', use default
 20229                          ; jsr getbyt
 20230                          ; cpx #4   ;must be 0-3
 20231                          ; bcs illval       ;..else illegal value
 20232                          ; cpx #2
 20233                          ; bit _graphm       ;if hires, must be 0 or 1
 20234                          ; bmi incol2
 20235                          ; bcs illval
 20236                          ;incol2
 20237                          ; stx colsel
 20238                          ; rts
 20239                          ;
 20240                          ;illval
 20241                          ; jmp fcerr  ;illegal value
 20242                          
 20243                          ; .page
 20244                          ;******************************************************************
 20245                          ;  INCORD  ---  Get X,Y coordinate from input stream into vwork+x
 20246                          ;
 20247                          ;  Coordinate may have any of the forms:
 20248                          ;    x,y  = absolute xpos & absolute ypos
 20249                          ; +/-x,y  = relative xpos & absolute ypos
 20250                          ;    x,+/-y = absolute xpos & relative ypos
 20251                          ; +/-x,+/-y = relative xpos & relative ypos
 20252                          ;    x;y  = x-distance at an angle y
 20253                          ;
 20254                          ;  Relative and angle distances are relative to current x,ypos.
 20255                          ;  Values are scaled to current mode parameters if required.
 20256                          ;******************************************************************
 20257                          
 20258                          
 20259                          incor2                                                    ; enter here for optional argument
 20260  bbdb 208522                              jsr chrgot                               ; end of line?
 20261  bbde f007                                beq l308_1                               ; yes, use defaults
 20262  bbe0 205b4e                              jsr chkcom
 20263  bbe3 c92c                                cmp #','                                 ; is there really an arg?
 20264  bbe5 d00f                                bne incord                               ; yes, let'er rip
 20265                          
 20266  bbe7 a000               l308_1           ldy #0                                   ; set default pos = current pos
 20267  bbe9 b9ec11             l308_2           lda xpos,y
 20268  bbec 9dec11                              sta vwork,x
 20269  bbef e8                                  inx
 20270  bbf0 c8                                  iny
 20271  bbf1 c004                                cpy #4
 20272  bbf3 90f4                                bcc l308_2
 20273  bbf5 60                                  rts
 20274                          
 20275                          ; .page
 20276                          ;incor3    ;enter here for non-optional arg preceded by a comma
 20277                          ; jsr chkcom
 20278                          incord
 20279  bbf6 8ef811                              stx vtemp4                               ; save offset to destination
 20280  bbf9 2081bc                              jsr cordsb                               ; get 2-byte x-parameter
 20281  bbfc 208522                              jsr chrgot
 20282  bbff c92c                                cmp #','
 20283  bc01 f051                                beq docord                               ; skip ahead if have comma
 20284                          
 20285  bc03 c93b                                cmp #';'                                 ; check for semi-colon
 20286  bc05 d34372                              +lbne snerr                              ; missing angle param- show syntax message
 20287  bc08 208322                              jsr chrget       ;skip over '            ; '
 20288  bc0b 208a5d                              jsr getwrd                               ; get 2-byte angle in a,y
 20289  bc0e 8576                                sta z_p_temp_1                           ; swap a,y
 20290  bc10 98                                  tya
 20291  bc11 a476                                ldy z_p_temp_1
 20292  bc13 20b8ba                              jsr gtang1                               ; get sine & cosine values for the angle
 20293  bc16 aef811                              ldx vtemp4
 20294  bc19 bdec11                              lda vwork,x
 20295  bc1c 9dee11                              sta vwork+2,x                            ; move length to y-parameter
 20296  bc1f bded11                              lda vwork+1,x
 20297  bc22 9def11                              sta vwork+3,x
 20298                          ; jsr scalxy       ;scale the values
 20299  bc25 a90e                                lda #$0e
 20300  bc27 8df911                              sta vtemp5
 20301  bc2a 18                                  clc
 20302  bc2b aef811                              ldx vtemp4
 20303                          
 20304  bc2e 2011bb             l309_1           jsr angmlt                               ; multiply length * angle
 20305  bc31 9dec11                              sta vwork,x                              ; save angle result
 20306  bc34 98                                  tya
 20307  bc35 9ded11                              sta vwork+1,x
 20308  bc38 a000                                ldy #xpos-vwork
 20309  bc3a 4ef911                              lsr vtemp5
 20310  bc3d 9002                                bcc l309_2
 20311  bc3f a002                                ldy #ypos-vwork
 20312                          
 20313  bc41 2038bb             l309_2           jsr dotwo                                ; add/subtract value to current position
 20314  bc44 9dec11                              sta vwork,x
 20315  bc47 98                                  tya                                      ; save result in destination
 20316  bc48 9ded11                              sta vwork+1,x
 20317  bc4b e8                                  inx
 20318  bc4c e8                                  inx
 20319  bc4d 4ef911                              lsr vtemp5
 20320  bc50 d0dc                                bne l309_1                               ; do y-coordinate
 20321  bc52 18                                  clc
 20322  bc53 60                                  rts
 20323                          
 20324                          ; .page
 20325  bc54 208322             docord           jsr chrget                               ; skip over comma
 20326  bc57 eef811                              inc vtemp4                               ; point to y-destination
 20327  bc5a eef811                              inc vtemp4
 20328  bc5d 2081bc                              jsr cordsb                               ; get y-paramter
 20329                          ; ldx vtemp4
 20330                          ; dex
 20331                          ; dex
 20332                          ; jsr scalxy       ;scale the values
 20333  bc60 a002                                ldy #ypos-vwork
 20334  bc62 aef811                              ldx vtemp4
 20335  bc65 e8                                  inx
 20336  bc66 e8                                  inx
 20337                          
 20338  bc67 ca                 docor1           dex
 20339  bc68 ca                                  dex
 20340  bc69 4ef911                              lsr vtemp5
 20341  bc6c 900a                                bcc docor2                               ; skip if not relative
 20342  bc6e 203abb                              jsr addtwo                               ; add to current position
 20343  bc71 9dec11                              sta vwork,x
 20344  bc74 98                                  tya
 20345  bc75 9ded11                              sta vwork+1,x
 20346                          
 20347  bc78 a000               docor2           ldy #xpos-vwork
 20348  bc7a ecf811                              cpx vtemp4
 20349  bc7d f0e8                                beq docor1                               ; loop to do x-coordinate
 20350  bc7f 18                                  clc
 20351  bc80 60                                  rts
 20352                          
 20353                          ;
 20354                          ; CORDSB -- Get the next 2-byte parameter
 20355                          ;
 20356                          
 20357  bc81 208522             cordsb           jsr chrgot                               ; read character
 20358  bc84 c9aa                                cmp #plus_token                          ; check if relative - plus sign
 20359  bc86 f005                                beq l310_1                               ; skip if yes
 20360  bc88 c9ab                                cmp #minus_token
 20361  bc8a f001                                beq l310_1                               ; skip if relative - minus sign
 20362  bc8c 18                                  clc                                      ; .c=1 if relative coord, .c=0 if absolute
 20363  bc8d 2ef911             l310_1           rol vtemp5                               ; save coord type for later
 20364  bc90 20d84c                              jsr frmnum
 20365  bc93 20925d                              jsr getsad                               ; get signed 2 byte coordinate (y,a), do rts
 20366  bc96 aef811                              ldx vtemp4
 20367  bc99 9ded11                              sta vwork+1,x                            ; save 2-byte parameter
 20368  bc9c 98                                  tya
 20369  bc9d 9dec11                              sta vwork,x
 20370  bca0 60                                  rts
 20371                          
 20372                          ;.end
 20373                          ; .page
 20374                          ;GRAPHICS11.SRC
 20375                          
 20376                          ;  ANGVAL  -- Table of angle values on 10 degree boundaries
 20377                          ;  Values based as fraction of 65536
 20378                          
 20379                          angval
 20380  bca1 0000                                !text $00,$00                            ; sine 00 degrees -  .0000
 20381  bca3 2c71                                !text $2c,$71                            ; sine 10 degrees -  .1736
 20382  bca5 578d                                !text $57,$8d                            ; sine 20 degrees -  .3420
 20383  bca7 8000                                !text $80,$00                            ; sine 30 degrees -  .5000
 20384  bca9 a48f                                !text $a4,$8f                            ; sine 40 degrees -  .6428
 20385  bcab c419                                !text $c4,$19                            ; sine 50 degrees -  .7660
 20386  bcad ddb2                                !text $dd,$b2                            ; sine 60 degrees -  .8660
 20387  bcaf f090                                !text $f0,$90                            ; sine 70 degrees -  .9397
 20388  bcb1 fc1c                                !text $fc,$1c                            ; sine 80 degrees -  .9848
 20389  bcb3 ffff                                !text $ff,$ff                            ; sine 90 degrees - 1.0000
 20390                          
 20391                          ;  INCVAL  -- Table of incremental values between 10 degrees
 20392                          ;  Values based on fraction of 65536
 20393                          
 20394                          incval
 20395  bcb5 0472                                !text $04,$72                            ; 01 - 09 degrees -  .01739
 20396  bcb7 0450                                !text $04,$50                            ; 11 - 19 degrees -  .01692
 20397  bcb9 040b                                !text $04,$0b                            ; 21 - 29 degrees -  .01592
 20398  bcbb 03a8                                !text $03,$a8                            ; 31 - 39 degrees -  .01443
 20399  bcbd 0328                                !text $03,$28                            ; 41 - 49 degrees -  .01252
 20400  bcbf 0290                                !text $02,$90                            ; 51 - 59 degrees -  .01023
 20401  bcc1 01e3                                !text $01,$e3                            ; 61 - 69 degrees -  .00762
 20402  bcc3 0128                                !text $01,$28                            ; 71 - 79 degrees -  .00477
 20403  bcc5 0063                                !text $00,$63                            ; 81 - 89 degrees -  .00179
 20404                          
 20405                          ;.end
 20406                          ; .page
 20407                          ; .subttl  EDIT Mode
 20408                          
 20409                          ; Edit mode is simply a poor man's word processor.  Text is entered normally
 20410                          ; as if the user were typing in a program, but tokenization is turned off.
 20411                          ; This affects only that text which follows a line number.  CRUNCH and QPLOP
 20412                          ; test for this mode, and deal with the text accordingly.  RUN, GOTO, etc.
 20413                          ; test for this mode and error-out if it's enabled.  LOADing a text file
 20414                          ; will automatically add line numbers, SAVEing a text file will remove them.
 20415                          ;
 20416                          ; Syntax:  EDIT < ON | OFF >
 20417                          ;
 20418                          ; F. Bowen        [910620]
 20419                          
 20420  bcc7 20ed58             edit             jsr errind                               ; direct mode only command
 20421  bcca c991                                cmp #on_token
 20422  bccc d004                                bne l311_1
 20423  bcce a910                                lda #%00010000                           ; EDIT ON
 20424  bcd0 800a                                bra l311_3                               ; (this kills trace mode, too)
 20425                          
 20426  bcd2 2016b5             l311_1           jsr chkesc                               ; [910930]
 20427                          ; cmp #esc_command_token
 20428                          ; bne l311_2
 20429                          ; jsr chrget
 20430  bcd5 c924                                cmp #off_token
 20431  bcd7 d37171             l311_2           +lbne snerr
 20432  bcda a900                                lda #0                                   ; EDIT OFF
 20433  bcdc 857e               l311_3           sta runmod
 20434  bcde 4c8322                              jmp chrget                               ; exit
 20435                          
 20436                          
 20437                          edit_crunch                                               ; Edit mode only, find end of plain text in input buffer
 20438  bce1 fc3d00                              phw txtptr                               ; save current position in input buffer
 20439  bce4 205635                              jsr rem                                  ; find the end of the line
 20440  bce7 a63d                                ldx txtptr
 20441  bce9 68                                  pla                                      ; restore buffer pointer
 20442  bcea 853e                                sta txtptr+1
 20443  bcec 68                                  pla
 20444  bced 853d                                sta txtptr
 20445  bcef 38                                  sec                                      ; compute length of line
 20446  bcf0 8a                                  txa
 20447  bcf1 e53d                                sbc txtptr
 20448  bcf3 a8                                  tay
 20449  bcf4 c8                                  iny
 20450  bcf5 60                                  rts                                      ; done
 20451                          
 20452                          
 20453                          edit_p1line                                               ; Edit mode only, list a line of plain text
 20454  bcf6 207f64                              jsr linprt                               ; print line number in (a,x)
 20455  bcf9 a920                                lda #' '                                 ; print a space
 20456                          
 20457  bcfb a003                                ldy #3                                   ; start printing at text following line number
 20458  bcfd 203d68             l312_1           jsr outch                                ; print character
 20459  bd00 c8                                  iny
 20460  bd01 5f5503                              bbr5 helper,l312_2                       ; if called from FIND/CHANGE check for highlighting
 20461  bd04 20963c                              jsr helpsb
 20462  bd07 20ad22             l312_2           jsr indlow                               ; get next character
 20463  bd0a d0f1                                bne l312_1                               ; loop until eol
 20464  bd0c 60                                  rts                                      ; done
 20465                          
 20466                          
 20467                          ;.end
 20468                          ; .page
 20469                          ; EDIT LOAD/SAVE  Load or Save a plain text SEQ file in memory
 20470                          
 20471                          edit_load                                                 ; Called by DLOAD/DVERIFY when in EDIT mode
 20472  bd0d a301                                ldz #1
 20473  bd0f 20196f                              jsr open_SEQ_file                        ; Open the file just like TYPE: filename [,U#] [,D#]
 20474  bd12 200e78                              jsr Check_DS                             ; check current disk error message
 20475  bd15 a000                                ldy #0
 20476  bd17 a97a                                lda #dsdesc+1
 20477  bd19 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y peek at first character
 20478  bd1c c932                                cmp #'2'
 20479  bd1e b3bb00                              +lbcs l313_12                            ; exit if error
 20480  bd21 208278                              jsr Clear_DS                             ; else zap 'ok' message so user gets fresh one
 20481  bd24 ae8111                              ldx dosla
 20482  bd27 20c6ff                              jsr _chkin                               ; get input channel
 20483  bd2a b3af00                              +lbcs l313_12                            ; error
 20484                          
 20485  bd2d 8f0c0e                              bbs0 verck,l313_1
 20486  bd30 207dff                              jsr _primm
 20487  bd33 0d4c4f4144494e47...                 !text cr,"LOADING",0
 20488  bd3c 800e                                bra l313_2
 20489  bd3e 207dff             l313_1           jsr _primm
 20490  bd41 0d56455249465949...                 !text cr,"VERIFYING",0
 20491                          
 20492  bd4c a9e8               l313_2           lda #<1000                               ; default starting line #
 20493  bd4e a203                                ldx #>1000
 20494  bd50 8516                                sta linnum
 20495  bd52 8617                                stx linnum+1
 20496                          
 20497  bd54 a52d                                lda txttab                               ; load address
 20498  bd56 a62e                                ldx txttab+1
 20499  bd58 8524                                sta index
 20500  bd5a 8625                                stx index+1
 20501                          
 20502  bd5c a000               l313_3           ldy #0                                   ; Input one line of text
 20503  bd5e 20e1ff                              jsr _stop                                ; check stop key
 20504  bd61 f072                                beq l313_11                              ; exit if down
 20505  bd63 20b7ff                              jsr _readst                              ; check channel status
 20506  bd66 d06d                                bne l313_11                              ; exit if eof or error
 20507                          
 20508  bd68 0f0c04                              bbr0 verck,l313_4
 20509  bd6b a003                                ldy #3
 20510  bd6d 8020                                bra l313_5                               ; skip ahead if verify op
 20511                          
 20512  bd6f a901               l313_4           lda #1                                   ; install fake line links for this line
 20513  bd71 200623                              jsr sta_far_in1
 20514  bd74 c8                                  iny                                      ; 1
 20515  bd75 200623                              jsr sta_far_in1
 20516  bd78 c8                                  iny                                      ; 2
 20517  bd79 a516                                lda linnum                               ; install line number for this line
 20518  bd7b 200623                              jsr sta_far_in1
 20519  bd7e c8                                  iny                                      ; 3
 20520  bd7f a517                                lda linnum+1
 20521  bd81 200623                              jsr sta_far_in1
 20522  bd84 18                                  clc
 20523  bd85 a516                                lda linnum                               ; generate next line number
 20524  bd87 690a                                adc #10
 20525  bd89 8516                                sta linnum
 20526  bd8b 9002                                bcc l313_5
 20527  bd8d e617                                inc linnum+1
 20528                          
 20529                          ; .page
 20530  bd8f c8                 l313_5           iny                                      ; bump buffer pointer
 20531  bd90 c0a1                                cpy #buflen                              ; check buffer (160 max. input buffer size to edit)
 20532  bd92 f01e                                beq l313_8                               ; split long lines into two????
 20533  bd94 20cfff                              jsr _basin                               ; read file data
 20534  bd97 f019                                beq l313_8                               ; CR or null terminates line
 20535  bd99 c90d                                cmp #cr
 20536  bd9b f015                                beq l313_8
 20537                          ; cmp #$20  ;adjust invisible characters less than space
 20538                          ; bcc l313_6   ; ????make them appear in reverse field, but note
 20539                          ; ora #$80  ; that these lines can't be edited without losing them.
 20540                          
 20541  bd9d 0f0c0d             l313_6           bbr0 verck,l313_7
 20542  bda0 201723                              jsr indcmp_in1                           ; Compare to memory
 20543  bda3 f0ea                                beq l313_5                               ; ok
 20544  bda5 202033                              jsr list_exit
 20545  bda8 a21c                                ldx #ervfy                               ; verify error
 20546  bdaa 83a370                              +lbra error
 20547                          
 20548  bdad 200623             l313_7           jsr sta_far_in1                          ; Load into memory
 20549  bdb0 80dd                                bra l313_5                               ; loop until eol or error (kernel returns CR in case of error)
 20550                          
 20551  bdb2 8f0c05             l313_8           bbs0 verck,l313_9
 20552  bdb5 a900                                lda #0
 20553  bdb7 200623                              jsr sta_far_in1                          ; terminate line with null (replaces CR)
 20554  bdba c8                 l313_9           iny
 20555  bdbb 98                                  tya
 20556  bdbc 18                                  clc
 20557  bdbd 6524                                adc index
 20558  bdbf 8524                                sta index
 20559  bdc1 9002                                bcc l313_10
 20560  bdc3 e625                                inc index+1
 20561  bdc5 a525               l313_10          lda index+1
 20562  bdc7 cdd002                              cmp max_mem_0+1                          ; out of memory????
 20563  bdca 9090                                bcc l313_3                               ; no, continue until eof
 20564  bdcc 631000                              bsr edit_load_done                       ; yes, patch things up best we can
 20565  bdcf 202033                              jsr list_exit                            ; close disk
 20566  bdd2 836d70                              +lbra omerr                              ; report error & exit
 20567                          
 20568  bdd5 8f0c03             l313_11          bbs0 verck,l313_12
 20569  bdd8 20debd                              jsr edit_load_done                       ; EOF: terminate memory with a pair of nulls
 20570  bddb 834375             l313_12          +lbra list_exit                          ; release channel, close file, etc.
 20571                          
 20572                          ; bbr0 verck,40$
 20573                          ; jsr verify_ok  ;if Verify, report 'ok'
 20574                          ;40$ lda #0   ;exit directly to main????
 20575                          ; bra end
 20576                          ; .page
 20577                          edit_load_done
 20578  bdde a900                                lda #0                                   ; EOF: terminate memory with a pair of nulls
 20579  bde0 a8                                  tay
 20580  bde1 200623                              jsr sta_far_in1
 20581  bde4 c8                                  iny
 20582  bde5 200623                              jsr sta_far_in1
 20583  bde8 e324                                inw index
 20584  bdea e324                                inw index
 20585  bdec a624                                ldx index                                ; set top
 20586  bdee a425                                ldy index+1
 20587  bdf0 8682                                stx text_top
 20588  bdf2 8483                                sty text_top+1
 20589  bdf4 83c372                              +lbra link_program                       ; relink & RTS
 20590                          
 20591                          ; .page
 20592                          edit_save
 20593  bdf7 a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
 20594  bdf9 202074                              jsr dosprs                               ; (like dopen:      0 0 0 *  * 0 0 1 )
 20595  bdfc 20dc77                              jsr chk1                                 ; check parameters
 20596  bdff 201d71                              jsr find_la                              ; find an available LA
 20597  be02 200d71                              jsr find_sa                              ; find an available SA
 20598  be05 a017                                ldy #fsavseq
 20599  be07 a208                                ldx #8
 20600  be09 20fd70                              jsr open_file                            ; open the file
 20601  be0c b31975                              +lbcs list_err                           ; exit if error
 20602  be0f ae8111                              ldx dosla
 20603  be12 20c9ff                              jsr _chkout                              ; get output channel
 20604  be15 b03b                                bcs l314_5                               ; error
 20605                          
 20606  be17 a52d                                lda txttab                               ; save address
 20607  be19 a62e                                ldx txttab+1
 20608  be1b 8524                                sta index
 20609  be1d 8625                                stx index+1
 20610                          
 20611  be1f 20e1ff             l314_1           jsr _stop                                ; check stop key
 20612  be22 f02e                                beq l314_5                               ; exit if down
 20613  be24 20b7ff                              jsr _readst                              ; check channel status
 20614  be27 d029                                bne l314_5                               ; exit if eof or error????
 20615                          
 20616  be29 a003                                ldy #3                                   ; save a line, starting past links & line#
 20617  be2b c8                 l314_2           iny                                      ; bump buffer pointer
 20618                          ; cpy #buflen  ;check buffer (160 max. input buffer size to edit)
 20619                          ; beq ??$   ; split long lines into two????
 20620  be2c 20c122                              jsr indin1
 20621  be2f aa                                  tax                                      ; save character for eol check
 20622  be30 d002                                bne l314_3
 20623  be32 a90d                                lda #cr                                  ; eol: substitute CR ???? allow some other terminator
 20624  be34 20d2ff             l314_3           jsr _bsout                               ; write file data
 20625  be37 8a                                  txa
 20626  be38 d0f1                                bne l314_2                               ; loop until eol
 20627                          
 20628  be3a c8                                  iny                                      ; advance text index to start of next line
 20629  be3b 98                                  tya
 20630  be3c 18                                  clc
 20631  be3d 6524                                adc index
 20632  be3f 8524                                sta index
 20633  be41 9002                                bcc l314_4
 20634  be43 e625                                inc index+1
 20635                          
 20636  be45 a000               l314_4           ldy #0                                   ; check for EOF: a pair of null links
 20637  be47 20c122                              jsr indin1
 20638  be4a d0d3                                bne l314_1
 20639  be4c c8                                  iny
 20640  be4d 20c122                              jsr indin1
 20641  be50 d0cd                                bne l314_1                               ; loop until end of text
 20642                          
 20643  be52 83cc74             l314_5           +lbra list_exit                          ; release channel, close file, exit
 20644                          
 20645                          ;.end
 20646                          ; .page
 20647                          ; .subttl  ETC.
 20648                          Sound_CLR
 20649  be55 2022b5                              jsr chkeos                               ; eat CLR token, check eos   [910717] new
 20650                          Sound_CLR_1
 20651  be58 08                                  php
 20652  be59 78                                  sei
 20653                          ; jsr go_slow  ;      [910716] 4567R7A
 20654  be5a a900                                lda #0
 20655  be5c a217                                ldx #24-1
 20656  be5e 9d00d4             l315_1           sta sid1,x                               ; initialize SID chips
 20657  be61 9d20d4                              sta sid2,x
 20658  be64 ca                                  dex
 20659  be65 10f7                                bpl l315_1
 20660                          
 20661  be67 8d7a12                              sta filters1+2                           ; set filters off
 20662  be6a 8d7e12                              sta filters2+2
 20663                          
 20664  be6d a908                                lda #8                                   ; set default volume
 20665  be6f 8d7b12                              sta filters1+3
 20666  be72 8d7f12                              sta filters2+3                           ; [910612]
 20667                          ; sta filters+4  ;why?      [910612]
 20668  be75 8d18d4                              sta sid1+24
 20669  be78 8d38d4                              sta sid2+24
 20670                          
 20671                          ; jsr go_fast  ;      [910716] 4567R7A
 20672                          
 20673  be7b 2c0311                              bit _pal_ntsc                            ; determine if PAL or NTSC system  [910724]
 20674  be7e 3006                                bmi l315_2                               ; ...branch if PAL
 20675  be80 a928                                lda #(<beats_ntsc)/4                     ; set beat to quarter note (4/4 time = .5 sec)
 20676  be82 a001                                ldy #>beats_ntsc/4
 20677  be84 8004                                bra l315_3
 20678  be86 a92c               l315_2           lda #<beats_pal/4
 20679  be88 a001                                ldy #>beats_pal/4
 20680  be8a 8d7612             l315_3           sta ntime
 20681  be8d 8c7712                              sty ntime+1
 20682                          
 20683  be90 a904                                lda #4                                   ; set default octave
 20684  be92 8d7012                              sta octave
 20685  be95 a90c                                lda #12                                  ; set default tempo    [910220]
 20686  be97 8d7312                              sta tempo_rate                           ; 12 makes whole note in 4/4 time last 2 seconds
 20687                          
 20688  be9a a01d                                ldy #30-1                                ; initialize music tables
 20689  be9c b9d849             l315_4           lda atkmus,y
 20690  be9f 998912                              sta atktab,y
 20691  bea2 88                                  dey
 20692  bea3 10f7                                bpl l315_4
 20693                          
 20694  bea5 a209                                ldx #10-1                                ; initialize pulse widths
 20695  bea7 bdf649             l315_5           lda pwhmus,x
 20696  beaa 9db112                              sta pulshi,x
 20697  bead ca                                  dex
 20698  beae 10f7                                bpl l315_5
 20699                          
 20700  beb0 8a                                  txa                                      ; $ff
 20701  beb1 a205                                ldx #6-1                                 ; stereo SIDs   (save space) [911119]
 20702  beb3 a001                                ldy #1
 20703  beb5 9dc412             l315_6           sta sound_time_hi,x                      ; turn all SOUND counters off
 20704  beb8 995d12                              sta voices,y                             ; turn all PLAY counters off
 20705  bebb c8                                  iny
 20706  bebc c8                                  iny
 20707  bebd ca                                  dex
 20708  bebe 10f5                                bpl l315_6
 20709                          
 20710  bec0 a005                                ldy #6-1                                 ; set default envelope (piano) for all voices (6)
 20711  bec2 8c6f12                              sty voice
 20712  bec5 a200               l315_7           ldx #0
 20713  bec7 200748                              jsr set_envelope_1
 20714  beca ce6f12                              dec voice
 20715  becd 10f6                                bpl l315_7
 20716  becf ee6f12                              inc voice                                ; set default voice (0)
 20717                          
 20718  bed2 28                                  plp
 20719  bed3 60                                  rts
 20720                          
 20721                          ; .page
 20722                          Sprite_CLR
 20723  bed4 2022b5                              jsr chkeos                               ; eat CLR token, check eos   [910717] new
 20724                          Sprite_CLR_1
 20725  bed7 08                                  php
 20726  bed8 78                                  sei
 20727  bed9 a900                                lda #0
 20728  bedb 8d15d0                              sta vic+21                               ; Turn off all sprites
 20729  bede 8d17d0                              sta vic+23                               ; Unexpand them     [910828]
 20730  bee1 8d1bd0                              sta vic+27                               ; Sprite priority
 20731  bee4 8d1cd0                              sta vic+28                               ; Hires sprites
 20732  bee7 8d1dd0                              sta vic+29
 20733                          
 20734  beea a257                                ldx #init_as_0                           ; Init sprite tables
 20735  beec 9d0512             l316_1           sta sprite_data,x
 20736  beef ca                                  dex
 20737  bef0 10fa                                bpl l316_1
 20738                          
 20739  bef2 a91f                                lda #sprite_base/64+7                    ; Set up sprite pointers
 20740  bef4 a007                                ldy #7
 20741  bef6 7fd705             l316_2           bbr7 _mode,l316_3
 20742  bef9 99f80b                              sta sprite_ptrs_40,y                     ; 40 col screen
 20743  befc 8003                                bra l316_4
 20744  befe 99f80f             l316_3           sta sprite_ptrs_80,y                     ; 80 col screen
 20745  bf01 3a                 l316_4           dec
 20746  bf02 88                                  dey
 20747  bf03 10f1                                bpl l316_2
 20748                          
 20749  bf05 28                                  plp
 20750                          ; rts
 20751                          
 20752                          ;.end
 20753                          ; .page
 20754                          ; .subttl BASIC NMI Handler
 20755                          
 20756                          basic_nmi                                                 ; removed [910826]
 20757                          ; lda nmi_wrap_flag ;filter out wrapped NMI calls   [910523] audio
 20758                          ; beq 1$   ; it's ok
 20759                          ; rts   ; exit- we're already handling one interrupt
 20760                          ;
 20761                          ;1$ inc nmi_wrap_flag ;shut the door to NMI
 20762                          ;
 20763                          ;basic_nmi_end
 20764                          ; dec nmi_wrap_flag ;open the door to NMI
 20765  bf06 60                                  rts
 20766                          
 20767                          ; .ifgt *-$c000
 20768                          ; .messg ***ROM OVERFLOW: $C000
 20769                          ; .endif
 20770                          ;.end
 20771                          ; .page
 20772                          ; .subttl C65 BASIC Jump Table
 20773                          
 20774                                           * = $7f00
 20775                          
 20776                          
 20777                          ; Format Conversions     [6]
 20778                          
 20779  7f00 83b2d9                              +lbra ayint                              ; convert floating point to integer
 20780  7f03 833acf                              +lbra givayf                             ; convert integer to floating point
 20781  7f06 8387e5                              +lbra fout                               ; convert floating point to PETSCII string
 20782  7f09 8341d6                              +lbra val_1                              ; convert PETSCII string to floating point
 20783  7f0c 837fde                              +lbra getadr                             ; convert floating point to an address
 20784  7f0f 83cee3                              +lbra floatc                             ; convert address to floating point
 20785                          
 20786                          ; Math Functions     [24]
 20787                          
 20788  7f12 8391de                              +lbra fsub                               ; MEM - FACC
 20789  7f15 8391de                              +lbra fsubt                              ; ARG - FACC
 20790  7f18 83a1de                              +lbra fadd                               ; MEM + FACC
 20791  7f1b 83ffe4                              +lbra faddt_c65                          ; ARG - FACC      [910402]
 20792  7f1e 834de1                              +lbra fmult                              ; MEM * FACC
 20793  7f21 8340e1                              +lbra fmultt_c65                         ; ARG * FACC      [910402]
 20794  7f24 835ce2                              +lbra fdiv                               ; MEM / FACC
 20795  7f27 834fe2                              +lbra fdivt_c65                          ; ARG / FACC      [910402]
 20796  7f2a 83e2e0                              +lbra log                                ; compute natural log of FACC
 20797  7f2d 8334e4                              +lbra int                                ; perform BASIC INT() on FACC
 20798  7f30 838ae6                              +lbra sqr                                ; compute square root of FACC
 20799  7f33 83c7e6                              +lbra negop                              ; negate FACC
 20800  7f36 838be6                              +lbra fpwr                               ; raise ARG to the MEM power
 20801  7f39 838be6                              +lbra fpwrt                              ; raise ARG to the FACC power
 20802  7f3c 83c9e6                              +lbra exp                                ; compute EXP of FACC
 20803  7f3f 835de7                              +lbra cos                                ; compute COS of FACC
 20804  7f42 8361e7                              +lbra sin                                ; compute SIN of FACC
 20805  7f45 83a7e7                              +lbra tan                                ; compute TAN of FACC
 20806  7f48 83d5e7                              +lbra atn                                ; compute ATN of FACC
 20807  7f4b 8365e3                              +lbra round                              ; round FACC
 20808  7f4e 839ee3                              +lbra abs                                ; absolute value of FACC
 20809  7f51 836ee3                              +lbra sign                               ; test sign of FACC
 20810  7f54 839be3                              +lbra fcomp                              ; compare FACC with MEM
 20811  7f57 83cdd8                              +lbra rnd_0                              ; generate random floating point number
 20812                          
 20813                          ; Movement      [22]
 20814                          
 20815  7f5a 839be1                              +lbra conupk                             ; move RAM MEM to ARG
 20816  7f5d 836de1                              +lbra romupk                             ; move ROM MEM to ARG
 20817  7f60 83f0cf                              +lbra movfrm                             ; move RAM MEM to FACC
 20818  7f63 83a9e2                              +lbra movfm                              ; move ROM MEM to FACC
 20819  7f66 83d2e2                              +lbra movmf                              ; move FACC to MEM
 20820  7f69 8328e3                              +lbra movfa                              ; move ARG to FACC
 20821  7f6c 8335e3                              +lbra movaf                              ; move FACC to ARG
 20822                          
 20823                          ; bra optab ;????not executable
 20824                          ; bra drawln
 20825                          ; bra gplot
 20826                          ; bra cirsub
 20827  7f6f 8343be                              +lbra run
 20828  7f72 832db5                              +lbra runc
 20829  7f75 8354b5                              +lbra clearc                             ; [910410]
 20830  7f78 83dbb4                              +lbra new
 20831  7f7b 833cb1                              +lbra link_program
 20832  7f7e 839fa3                              +lbra crunch
 20833  7f81 8377b2                              +lbra FindLine
 20834  7f84 8387ac                              +lbra newstt
 20835  7f87 8359ce                              +lbra eval
 20836  7f8a 8363cd                              +lbra frmevl
 20837  7f8d 8334be                              +lbra run_a_program
 20838  7f90 8309be                              +lbra setexc
 20839  7f93 8399b2                              +lbra linget
 20840  7f96 839bdc                              +lbra garba2
 20841  7f99 8376af                              +lbra execute_a_line
 20842                          
 20843                          ; Temporaries for C65 development (???? used by graphics) [12]
 20844                          
 20845  7f9c 83e5a2                              +lbra chrget
 20846  7f9f 83e4a2                              +lbra chrgot
 20847  7fa2 83b7ce                              +lbra chkcom
 20848  7fa5 8331cd                              +lbra frmnum
 20849  7fa8 83e3dd                              +lbra getadr
 20850  7fab 83cfdd                              +lbra getnum
 20851  7fae 83bcdd                              +lbra getbyt
 20852  7fb1 8372e9                              +lbra plsv
 20853                          
 20854  7fb4 8311a3                              +lbra lda_far_ram0                       ; lda (.x),y from BASIC text bank [910716]
 20855  7fb7 831ea3                              +lbra lda_far_ram1                       ; lda (.x),y from BASIC variable bank [910716]
 20856  7fba 8350a3                              +lbra sta_far_ram0                       ; sta (.x),y to   BASIC text bank [910716]
 20857  7fbd 8331a3                              +lbra sta_far_ram1                       ; sta (.x),y to   BASIC variable bank [910716]
 20858                          
 20859                          ; .page
 20860                          ; Graphic Kernel Call. (Temporary for C65 development ????)
 20861                          ;
 20862                          ;  syntax:  GRAPHIC command# [,args]
 20863                          ;
 20864                          ; Basically this is a modified C64-type SYS command, minus the address.
 20865                          ; In the final C65 system, this will represent the ML interface, not the
 20866                          ; BASIC 10.0 interface which is implemented here in the development system.
 20867                          
 20868                          
 20869                          graphic
 20870  7fc0 c99c                                cmp #clr_token                           ; GRAPHIC CLR (graphic system initialize)
 20871  7fc2 d006                                bne l317_1                               ; no
 20872  7fc4 208322                              jsr chrget                               ; yes advance past token
 20873  7fc7 6c0080                              jmp ($8000)                              ; go initialize graphic kernel
 20874                          
 20875                          l317_1
 20876                          ; tax
 20877                          ; bmi snerr  ;Syntax error if any other secondary token
 20878                          ;
 20879                          ;
 20880  7fca 6cfe02                              jmp (graphic_vector)                     ; Else, call the Graphics Kernel's Parser...
 20881                          ;
 20882                          ;
 20883                          graphic_kernel                                            ; ...via indirect
 20884  7fcd 6c0280                              jmp ($8002)
 20885                          
 20886                          ; .page
 20887                          ; C65 Graphic Kernel Jump Table      [910826]
 20888                          ;
 20889                          ; 8000 init   ;sets up graphic vars
 20890                          ; 8002 parser   ;GRAPHIC ML Parser????
 20891                          ;
 20892                          ; 8004 kg65.start-1  ;0 commands
 20893                          ; 8006 kg65.screendef-1 ;1
 20894                          ; 8008 kg65.screenopen-1 ;2
 20895                          ; 800a kg65.screenclose-1 ;3
 20896                          ; 800c kg65.screenclear-1 ;4
 20897                          ; 800e kg65.screen-1  ;5
 20898                          ; 8010 kg65.setpen-1  ;6
 20899                          ; 8012 kg65.setpalette-1 ;7
 20900                          ; 8014 kg65.setdmode-1  ;8
 20901                          ; 8016 kg65.setdpat-1  ;9
 20902                          ; 8018 kg65.line-1  ;10
 20903                          ; 801a kg65.box-1  ;11
 20904                          ; 801c kg65.circle-1  ;12
 20905                          ; 801e kg65.polygon-1  ;13
 20906                          ; 8020 kg65.ellipse-1  ;14
 20907                          ; 8022 kg65.viewpclr-1  ;15
 20908                          ; 8024 kg65.copy-1  ;16
 20909                          ; 8026 kg65.cut-1  ;17
 20910                          ; 8028 kg65.paste-1  ;18
 20911                          ; 802a kg65.load-1  ;19
 20912                          ; 802c kg65.char-1  ;20
 20913                          ; 802e kg65.paint-1  ;21
 20914                          ; 8030 kg65.viewpdef-1  ;22
 20915                          ; 8032 kg65.f.pixel-1  ;23
 20916                          ; 8034 kg65.f.rpalette-1 ;24
 20917                          ; 8036 kg65.f.index2color-1 ;25
 20918                          ; 8038 kg65.f.rgraphic  ;26
 20919                          
 20920                          ; .ifgt *-$8000
 20921                          ; .messg ***ROM OVERFLOW: $8000
 20922                          ; .endif
 20923                          ; .end
