
; ******** Source: tmp/basic.asm
     1                          ;[[header]]
     2                          
     3                          
     4                          
     5                          ;  ***************************************************************************
     6                          ;  *                               //                                        *
     7                          ;  *              CCCCCCC         //    6666666     555555555                *
     8                          ;  *             CCC   CCC       //    666   666    555                      *
     9                          ;  *            CCC             //    666           555                      *
    10                          ;  *            CCC            //     666 6666      55555555                 *
    11                          ;  *            CCC           //      6666   666          555                *
    12                          ;  *            CCC          //       666     666          555               *
    13                          ;  *             CCC   CCC  //         666   666    555   555                *
    14                          ;  *              CCCCCCC  //           6666666      5555555                 *
    15                          ;  *                      //                                                 *
    16                          ;  *                                                                         *
    17                          ;  *          BBBBBBBBB      AAAA      SSSSSSSS   III    CCCCCCC             *
    18                          ;  *          BBB    BBB   AAA  AAA   SSS    SSS  III   CCC   CCC            *
    19                          ;  *          BBB    BBB  AAA    AAA  SSS         III  CCC                   *
    20                          ;  *          BBBBBBBBB   AAAAAAAAAA   SSSSSSSS   III  CCC                   *
    21                          ;  *          BBB    BBB  AAA    AAA         SSS  III  CCC                   *
    22                          ;  *          BBB    BBB  AAA    AAA  SSS    SSS  III   CCC   CCC            *
    23                          ;  *          BBBBBBBBB   AAA    AAA   SSSSSSSS   III    CCCCCCC             *
    24                          ;  *                                                                         *
    25                          ;  *                       V E R S I O N   1 0 . 0                           *
    26                          ;  *              *
    27                          ;  *        Copyright (C)1991  by   Commodore Business Machines, Inc.        *
    28                          ;  *              *
    29                          ;  *       All  Rights  Reserved        *
    30                          ;  *              *
    31                          ;  ***************************************************************************
    32                          
    33                          ;   ROM VERSION  911115  (ver 0.9B)
    34                          
    35                          ; ******************************************************************
    36                          ; *                                                                *
    37                          ; * This listing contains confidential and proprietary information *
    38                          ; * of CBM, Inc.  The reproduction, dissemination or disclosure to *
    39                          ; * others without express written permission is prohibited.  This *
    40                          ; * software is for use in prototype Commodore C/65 systems only.  *
    41                          ; *                                                                *
    42                          ; *  The information in this document will change without notice.  *
    43                          ; *                                                                *
    44                          ; *  No  responsibility  is  assumed  for the reliability of this  *
    45                          ; *                          software.                             *
    46                          ; *                                                                *
    47                          ; ******************************************************************
    48                          
    49                          
    50                          
    51                          ; This version written and assembled by Fred Bowen using BSO format.
    52                          
    53                          ; Adapted from the following C128 files, ROM part numbers 318018-04, 3180194-04:
    54                          ;
    55                          ; disclaim  resume   hexfunc
    56                          ; declare   doloop   rgr
    57                          ; entries   key   rclr
    58                          ; header   paint   joy
    59                          ; init   box   penpot
    60                          ; indjumps  sshape   pointer
    61                          ; crunch   gshape   rsprite
    62                          ; tokens1   circle   rspcolor
    63                          ; tokens2   draw   bump
    64                          ; disptable  char   rsppos
    65                          ; errmsgs   locate   xor
    66                          ; errprint  scale   rwindow
    67                          ; execute   color   rnd
    68                          ; functions  scnclr   code12
    69                          ; code0   graphic   stringfns
    70                          ; rtstack   bank   code17
    71                          ; findline  sleep   code18
    72                          ; lineget   wait   code19
    73                          ; list   sprite   code21
    74                          ; newclr   movspr   code22
    75                          ; return   play   code23
    76                          ; remdata   filter   code24
    77                          ; if   envelope  code26
    78                          ; ongoto   collision  grbcol
    79                          ; let   sprcolor  trig
    80                          ; print   width   using
    81                          ; input   volume   instring
    82                          ; next   sound   graphic3
    83                          ; dim   window   rdot
    84                          ; sys   boot   graphic7
    85                          ; trontroff  sprdef   graphic8
    86                          ; rreg   sprsav   graphic9
    87                          ; midequal  fast   graphic10
    88                          ; auto   slow   graphic11
    89                          ; help   checkval  sethires
    90                          ; gosubgoto  formeval  clrhires
    91                          ; go   variables  dos1
    92                          ; continue  getpointr  dos2
    93                          ; run   array   dos3
    94                          ; restore   patcheslo  dos4
    95                          ; renumber  fre   overflow
    96                          ; for   val   irq
    97                          ; delete   dec   stash
    98                          ; pudef   peekpoke  fetch
    99                          ; trap   errfunc   swap
   100                          ; patcheshi  jumptable  def
   101                          ; strings
   102                          
   103                          
   104                          
   105                          
   106                          
   107                          
   108                          
   109                          
   110                          ;[[constants]]
   111                          ; General assignments and equates
   112                          
   113                          doslfn           = 0                                      ; DOS' private logical file number
   114                          dosffn           = 8                                      ; DOS' default drive number
   115                          
   116                          strsiz           = 3                                      ; string descriptor size in temps. and arrays
   117                          lengos           = 5                                      ; length of a GOSUB entry on the runtime stack
   118                          lenfor           = 18                                     ; length of a FOR entry in the runtime stack
   119                          
   120                          ; maxchr = 80  ;misc. command equates
   121                          ; llen  = 40
   122                          ; nlines = 25
   123                          column_width     = 10                                     ; print comma spacing
   124                          
   125                          beats_pal        = 1200                                   ; whole note (4/4 time = 2sec.)    [910724]
   126                          beats_ntsc       = 1440                                   ;
   127                          
   128                          lf               = $0a                                    ; line feed
   129                          cr               = $0d                                    ; carriage return
   130                          esc              = $1b                                    ; escape
   131                          pi               = $ff
   132                          
   133                          basbgn           = $2000                                  ; bottom of BASIC text bank
   134                          baswrk           = basbgn+1                               ; where BASIC text starts
   135                          varbgn           = $2000                                  ; bottom of BASIC data bank (C65: DOS RAM below $12000)
   136                          bank_0_top       = $8000                                  ; top of BASIC text bank ($FF00)    [910528]
   137                          bank_1_top       = $8000                                  ; top of BASIC data bank ($f800, VIC attributes)  [910528]
   138                          
   139                          ; graphic_base = $2000
   140                          ; color_ram_lo = $1c00
   141                          ; color_ram_hi = $d800
   142                          
   143                          vic              = $d000                                  ; Video controller
   144                          
   145                          fdc              = $d080                                  ; Built-in floppy disk controller
   146                          
   147                          sid1             = $d400                                  ; Audio processors (right)
   148                          sid2             = $d420                                  ; (left)
   149                          
   150                          d1_6526          = $dc00                                  ; Ports, peripheral control
   151                          d1pra            = d1_6526
   152                          d2_6526          = $dd00
   153                          d2pra            = d2_6526
   154                          
   155                          dma_ctlr         = $d700                                  ; DMA Controller
   156                          
   157                          
   158                          ;  BASIC base page storage
   159                          ;[[data.zeropage]]
   160                          
   161                                           * = $0000
   162                          
   163  0000 0000                                !fill 2                                  ; '4510' registers (not used in C65 mode)
   164  0002 00                 srchtk           !fill 1                                  ; token 'search' looks for (run-time stack) / SYS 'bank#'
   165                          
   166                                           * = $000a                                ; skip over SYS address, status, a/x/y/z registers
   167                          
   168                          integr                                                    ; used by math routines (this & following location)
   169  000a 00                 charac           !fill 1
   170  000b 00                 endchr           !fill 1
   171  000c 00                 verck            !fill 1                                  ; LOAD/VERIFY flag
   172  000d 00                 count            !fill 1                                  ; temp used all over
   173  000e 00                 dimflg           !fill 1                                  ; DIM flag used by variable search
   174  000f 00                 valtyp           !fill 1                                  ; 0=numeric, $FF=string
   175  0010 00                 intflg           !fill 1                                  ; b7: (0=float,1=integer), b6: (1=get flag)
   176                          garbfl                                                    ; garbage collection temporary
   177  0011 00                 dores            !fill 1                                  ; b7: P1LINE quote flag
   178  0012 00                 subflg           !fill 1                                  ; b7: subscript flag (set to disallow subscripts() & integers%)
   179  0013 00                 input_flag       !fill 1                                  ; READ($98), GET($40), or INPUT($00)
   180                          domask
   181  0014 00                 tansgn           !fill 1
   182  0015 00                 channl           !fill 1                                  ; active I/O channel
   183                          poker                                                     ; temp used all over
   184  0016 0000               linnum           !fill 2                                  ; line number
   185                          
   186  0018 00                 temppt           !fill 1                                  ; pointer to next temporary descriptor in tempst
   187  0019 0000               lastpt           !fill 2                                  ; pointer to last used temporary string
   188  001b 0000000000000000...tempst           !fill 9                                  ; temporary descriptor pointers (3 at 3 bytes each)
   189                          
   190                          index
   191  0024 0000               index1           !fill 2
   192  0026 0000               index2           !fill 2
   193                          
   194                          multiplicand                                              ; 2 bytes wide, for unsigned integer multiply
   195  0028 00                 resho            !fill 1
   196  0029 00                 resmoh           !fill 1
   197                          product                                                   ; 3 bytes wide, for unsigned integer multiply
   198                          addend
   199  002a 00                 resmo            !fill 1
   200  002b 00                 reslo            !fill 1
   201  002c 00                                  !fill 1
   202  002d 0000               txttab           !fill 2                                  ; where BASIC program begins   (text_bank)
   203  002f 0000               vartab           !fill 2                                  ; where variable descriptors begin  (var_bank)
   204  0031 0000               arytab           !fill 2                                  ; where array table begins   (var_bank)
   205  0033 0000               strend           !fill 2                                  ; where arrays table ends   (var_bank)
   206  0035 0000               fretop           !fill 2                                  ; bottom of string storage   (var_bank)
   207  0037 0000               frespc           !fill 2                                  ; where temporary strings begin   (var_bank)
   208  0039 0000               max_mem_1        !fill 2                                  ; highest address available to BASIC in RAM 1 (var_bank)
   209  003b 0000               curlin           !fill 2
   210  003d 0000               txtptr           !fill 2                                  ; pointer to BASIC text used by CHRGET, etc.
   211                          form                                                      ; used by print using
   212  003f 0000               fndpnt           !fill 2                                  ; pointer to item found by search
   213  0041 0000               datlin           !fill 2
   214  0043 0000               datptr           !fill 2
   215  0045 0000               inpptr           !fill 2
   216  0047 0000               varnam           !fill 2
   217                          fdecpt
   218  0049 0000               varpnt           !fill 2
   219                          lstpnt
   220                          andmsk
   221  004b 0000               forpnt           !fill 2
   222                          eormsk           =forpnt+1
   223                          vartxt
   224  004d 0000               opptr            !fill 2
   225  004f 00                 opmask           !fill 1
   226                          grbpnt
   227                          tempf3
   228  0050 0000               defpnt           !fill 2
   229  0052 0000               dscpnt           !fill 2
   230                          token_saver                                               ; temp used by P1LINE/HELPSB (was spare????) [910628]
   231  0054 00                 trmpos           !fill 1                                  ; temp used by SPC(), TAB()   [910628]
   232                          
   233  0055 00                 helper           !fill 1                                  ; P1LINE flag b7: HELP vs. LIST
   234                          ;  b6: memory vs. file
   235                          ;  b5: FIND/CHANGE
   236                          ;  b4: highlight tokens
   237                          ;  b3: highlight REM
   238                          ;  b1: LINGET flag for AUTOSCROLL
   239                          ;  b0: token in progress
   240                          
   241  0056 00                 jmper            !fill 1                                  ; 3 locations used by Function handler
   242  0057 00                                  !fill 1                                  ;
   243  0058 00                 oldov            !fill 1                                  ;
   244                          
   245  0059 00                 tempf1           !fill 1                                  ; used by math routines
   246                          ptarg1           =tempf1                                  ; multiply defined for INSTR thru FACexp
   247                          ptarg2           =tempf1+2                                ; (also used by Monitor Utility, thru lowtr)
   248                          str1             =tempf1+4
   249                          str2             =tempf1+7
   250                          positn           =tempf1+10
   251                          match            =tempf1+11
   252                          
   253                          arypnt
   254  005a 0000               highds           !fill 2
   255  005c 0000               hightr           !fill 2
   256                          
   257  005e 00                 tempf2           !fill 1                                  ; used by math routines
   258  005f 0000               deccnt           !fill 2
   259                          tenexp           = deccnt+1
   260                          grbtop
   261                          dptflg
   262  0061 00                 lowtr            !fill 1
   263  0062 00                 expsgn           !fill 1
   264                          
   265                          fac                                                       ; Floating point accumulator (primary) FAC1
   266                          dsctmp
   267  0063 00                 facexp           !fill 1
   268  0064 00                 facho            !fill 1
   269  0065 00                 facmoh           !fill 1
   270                          indice
   271  0066 00                 facmo            !fill 1
   272  0067 00                 faclo            !fill 1
   273  0068 00                 facsgn           !fill 1
   274                          degree
   275  0069 00                 sgnflg           !fill 1
   276                          
   277  006a 00                 argexp           !fill 1                                  ; Floating point accumulator (secondary) FAC2
   278  006b 00                 argho            !fill 1
   279  006c 00                 argmoh           !fill 1
   280  006d 00                 argmo            !fill 1
   281  006e 00                 arglo            !fill 1
   282  006f 00                 argsgn           !fill 1
   283                          
   284                          strng1
   285  0070 00                 arisgn           !fill 1
   286  0071 00                 facov            !fill 1
   287                          
   288                          strng2
   289                          polypt
   290                          curtol
   291  0072 0000               fbufpt           !fill 2
   292                          
   293  0074 0000               autinc           !fill 2                                  ; incremental value for AUTO (0=off)
   294                          
   295  0076 00                 z_p_temp_1       !fill 1                                  ; USING's leading zero counter
   296                          ;GET, RENUMBER, KEY temporary
   297                          ;MOVSPR, SPRITE, PLAY, VOL temporary
   298                          ;MID$= temporary
   299                          
   300                          hulp                                                      ; counter
   301  0077 00                 keysiz           !fill 1
   302                          
   303  0078 00                 syntmp           !fill 1                                  ; used as temp all over the place
   304  0079 000000             dsdesc           !fill 3                                  ; descriptor for DS$
   305  007c 0000               tos              !fill 2                                  ; top of run time stack
   306  007e 00                 runmod           !fill 1                                  ; flags run/direct(b7), load(b6), trace(b5), edit(b4) modes
   307                          ; autoboot wedge (b0)
   308                          point                                                     ; USING's pointer to decimal point, 2 bytes used by AutoScroll
   309  007f 00                 parsts           !fill 1                                  ; DOS parser status word
   310  0080 00                 parstx           !fill 1                                  ; DOS parser status extensions
   311                          
   312  0081 00                 oldstk           !fill 1                                  ; BASIC saves uP stack pointer here
   313                          
   314  0082 0000               text_top         !fill 2                                  ; top of BASIC text pointer  (in text_bank)
   315  0084 00                 text_bank        !fill 1                                  ; where BASIC text lives   (RAM0 default)
   316  0085 00                 var_bank         !fill 1                                  ; where BASIC vars live   (RAM1 default)
   317                          sys_bank         = 0                                      ; where system space is  ???? (RAM0, make this a var?)
   318                          
   319  0086 00                 sid_speed_flag   !fill 1                                  ; saves system speed during SID ops (used during IRQ)
   320                          
   321                          time                                                      ; temporaries for TI, TI$, SLEEP (4 bytes)
   322                          grapnt                                                    ; used by SPRSAV, RMOUSE, RCOLOR
   323                          op
   324  0087 00                 column           !fill 1                                  ; temporaries for FIND/CHANGE, [L]INPUT, [L]READ, CURSOR
   325                          srow
   326  0088 000000             fstr1            !fill 3                                  ;
   327  008b 000000             fstr2            !fill 3                                  ;
   328                          
   329                          
   330                          ;[[stackdata]]
   331                          
   332                                           * = $00ff
   333                          
   334  00ff 00                 lofbuf           !fill 1
   335  0100 0000000000000000...fbuffr           !fill 16                                 ; MathPack builds numbers here, USING, RENUMBER
   336                          
   337                          ;  Kernel MAP configurations & DMA lists
   338                          
   339  0110 0000000000000000...                 !fill 16+36                              ; (4 configs + 3 DMA lists)
   340                          
   341                          ;  BASIC DMA lists  (2 @ 12bytes each = 24 bytes)
   342                          
   343  0144 00                 dma1_cmd         !fill 1                                  ; This list is used by BASIC OS
   344  0145 00                 dma1_cnt_lo      !fill 1
   345  0146 00                 dma1_cnt_hi      !fill 1
   346  0147 00                 dma1_src_lo      !fill 1
   347  0148 00                 dma1_src_hi      !fill 1
   348  0149 00                 dma1_src_bank    !fill 1
   349  014a 00                 dma1_dest_lo     !fill 1
   350  014b 00                 dma1_dest_hi     !fill 1
   351  014c 00                 dma1_dest_bank   !fill 1
   352  014d 00                 dma1_subcmd      !fill 1                                  ; (from here on not supported until F018A) [910520] F018A
   353  014e 00                 dma1_mod_lo      !fill 1
   354  014f 00                 dma1_mod_hi      !fill 1
   355                          
   356  0150 00                 dma2_cmd         !fill 1                                  ; This list is used by DMA command & Graphics
   357  0151 00                 dma2_cnt_lo      !fill 1
   358  0152 00                 dma2_cnt_hi      !fill 1
   359  0153 00                 dma2_src_lo      !fill 1
   360  0154 00                 dma2_src_hi      !fill 1
   361  0155 00                 dma2_src_bank    !fill 1
   362  0156 00                 dma2_dest_lo     !fill 1
   363  0157 00                 dma2_dest_hi     !fill 1
   364  0158 00                 dma2_dest_bank   !fill 1
   365  0159 00                 dma2_subcmd      !fill 1                                  ; (from here on not supported until F018A) [910520] F018A
   366  015a 00                 dma2_mod_lo      !fill 1
   367  015b 00                 dma2_mod_hi      !fill 1
   368                          
   369  015c 00                                  !fill 1                                  ; Kernel's dma_byte
   370                          
   371                          sysstk                                                    ; bottom of system stack
   372                          stkend           = $1fb                                   ; top of system stack
   373                          
   374                          ;[[data]]
   375                          
   376                          
   377                                           * = $0200
   378                          
   379                          buflen           = 161                                    ; input buffer size (2 80-column lines + 1)
   380  0200 0000000000000000...buf              !fill buflen                             ; BASIC/Monitor line input buffer
   381                          buf_txtptr       = buf-1
   382                          
   383                          
   384                                           * = $02c0
   385                          ; BASIC RAM code  (RAM code not needed- following moved to ROM)
   386                          ;
   387                          ; chrget *=*+42  ;get byte from text bank after incrementing TXTPTR
   388                          ; chrgot = chrget+2 ;get byte from text bank at TXTPTR
   389                          ; qnum  = chrget+27 ;evaluate byte as a number & set flags accordingly
   390                          
   391  02c0 0000               adray1           !fill 2                                  ; ptr to routine:  convert float -> integer ???? why keep
   392  02c2 0000               adray2           !fill 2                                  ; ptr to routine:  convert integer -> float ???? why keep
   393  02c4 000000             zero             !fill 3                                  ; numeric constant for BASIC, downloaded from ROM
   394                          
   395  02c7 00                 errnum           !fill 1                                  ; used by error trapping routine-last error number
   396  02c8 0000               errlin           !fill 2                                  ; line # of last error ($FFFF if no error)
   397  02ca 0000               trapno           !fill 2                                  ; line to go to on error ($FFxx if none set)
   398  02cc 00                 tmptrp           !fill 1                                  ; hold trap # temporary
   399  02cd 0000               errtxt           !fill 2                                  ; pointer to statement causing last error
   400  02cf 0000               max_mem_0        !fill 2                                  ; highest address available to BASIC in RAM 0 (text bank)
   401                          
   402  02d1 00                 current_bank     !fill 1                                  ; context for PEEK,POKE,BOOT,SYS,WAIT,BLOAD/SAVE set by BANK.
   403  02d2 00                 fin_bank         !fill 1                                  ; bank pointer for string->number conversion routine FIN
   404  02d3 00000000           tmpdes           !fill 4                                  ; pointers to temporary descriptors for INSTR
   405  02d7 00                 bits             !fill 1                                  ; flag for math bit/byte shifter
   406  02d8 00                 highlight_color  !fill 1                                  ; color for highlighting text
   407  02d9 00                 highlight_save   !fill 1                                  ; saves normal color during highlighting, msb=flag
   408  02da 00                 find_count       !fill 1                                  ; count for LIST to highlight FIND text
   409                          
   410                          ; Interrupt stuff
   411                          
   412  02db 00                 irq_wrap_flag    !fill 1                                  ; used by BASIC_IRQ to block all but one IRQ call
   413  02dc 00                 intval           !fill 1                                  ; BASIC interrupts enabled (via collision command)
   414  02dd 000000             int_trip_flag    !fill 3                                  ; flags which interrupts occurred
   415  02e0 000000             int_adr_lo       !fill 3                                  ; where to go for each type of collision (line number)
   416  02e3 000000             int_adr_hi       !fill 3                                  ;
   417  02e6 0000               collisions       !fill 2                                  ; sprite collisions, s/s and s/bgnd, recorded during IRQ
   418  02e8 00                 lightpen_xpos    !fill 1                                  ; lightpen position recorded during IRQ
   419  02e9 00                 lightpen_ypos    !fill 1
   420                          
   421                          ; dejavu *=*+1  ;'cold' or 'warm' reset status (must be in page 5!)????
   422                          
   423                          ; nmi_wrap_flag *=*+1  ;used by BASIC_NMI to block all but one NMI call [910523]
   424                          ;    ; (removed)      [910826]
   425                          ;(leaving 12 bytes)
   426                          
   427                          ; BASIC indirect vectors
   428                          
   429                                           * = $02f7
   430                          
   431  02f7 000000             usrpok           !fill 3                                  ; USR vector (must be set by application)
   432                          
   433                          vectors_begin
   434  02fa 0000               iAutoScroll      !fill 2                                  ; AutoScroll vector
   435  02fc 0000               esc_fn_vec       !fill 2                                  ; Escape Function vector
   436  02fe 0000               graphic_vector   !fill 2                                  ; Graphic Kernel vector (was 'bnkvec')
   437  0300 0000               ierror           !fill 2                                  ; indirect error (output error in .x)
   438  0302 0000               imain            !fill 2                                  ; indirect main (system direct loop)
   439  0304 0000               icrnch           !fill 2                                  ; indirect crunch (tokenization routine)
   440  0306 0000               iqplop           !fill 2                                  ; indirect list (char list)
   441  0308 0000               igone            !fill 2                                  ; indirect gone (char dispatch)
   442  030a 0000               ieval            !fill 2                                  ; indirect eval (symbol evaluation)
   443  030c 0000               iesclk           !fill 2                                  ; escape token crunch
   444  030e 0000               iescpr           !fill 2                                  ; escape token list
   445  0310 0000               iescex           !fill 2                                  ; escape token execute
   446  0312 0000               itime            !fill 2                                  ; 60Hz interrupt vector (before jiffy)
   447  0314 0000               cinv             !fill 2                                  ; IRQ RAM vector
   448  0316 0000               cbinv            !fill 2                                  ; BRK RAM vector
   449                          
   450                          ; Remainder of this area reserved for Kernel indirects & Kernel RAM code
   451                          
   452                          
   453                                           * = $0400                                ; BASIC's run-time stack (2 pages)
   454                          stktop                                                    ; (also used by BOOT SYS and Monitor)
   455                          stkbot           = $05ff
   456                          
   457                          
   458                                           * = $0600                                ; Sprite definitions (2 pages, must be below $1000)
   459                          sprite_base
   460                          
   461                          
   462                                           * = $0800
   463                          screen_start                                              ; Text display screen
   464                                           * = *+2000
   465                          
   466                          sprite_ptrs_40   = screen_start+$3f8
   467                          sprite_ptrs_80   = screen_start+$7f8
   468                          
   469                          
   470                                           * = $1170                                ; previous to this used by Kernel
   471                          
   472  1170 0000               oldlin           !fill 2                                  ; BASIC storage
   473  1172 0000               oldtxt           !fill 2                                  ; BASIC storage
   474  1174 0000000000         rndx             !fill 5                                  ; Floating Point representation of last random #
   475                          
   476                          
   477                          ; Yet more temporaries shared by various routines
   478                          
   479                          window_temp                                               ; window  (4 bytes)
   480                          t3                                                        ; dcat  (1 byte)
   481                          renum_tmp_1                                               ; renumber (2 bytes)
   482  1179 0000               tmptxt           !fill 2                                  ; do/loop (2 bytes)
   483                          
   484                          t4                                                        ; dcat  (2 bytes)
   485                          renum_tmp_2                                               ; renumber (2 bytes)
   486  117b 0000               tmplin           !fill 2                                  ; do/loop (2 bytes)
   487                          
   488                          
   489                          ;  BASIC/DOS interface vars  (20 bytes)
   490                          
   491  117d 0000               dosofl           !fill 2                                  ; BLOAD/BSAVE starting addr
   492  117f 0000               dosofh           !fill 2                                  ; BSAVE ending addr
   493  1181 00                 dosla            !fill 1                                  ; DOS logical addr
   494  1182 00                 dosfa            !fill 1                                  ; DOS physical addr
   495  1183 00                 dossa            !fill 1                                  ; DOS secondary addr
   496                          
   497  1184 00                 xcnt             !fill 1                                  ; DOS loop counter------ this area zeroed-out each DOS call -----
   498  1185 00                 dosf1l           !fill 1                                  ; DOS filename 1 len
   499  1186 00                 dosds1           !fill 1                                  ; DOS disk drive 1
   500  1187 00                 dosf2l           !fill 1                                  ; DOS filename 2 len
   501  1188 00                 dosds2           !fill 1                                  ; DOS disk drive 2
   502  1189 0000               dosf2a           !fill 2                                  ; DOS filename 2 addr
   503  118b 00                 dosrcl           !fill 1                                  ; DOS record length
   504  118c 00                 dosbnk           !fill 1                                  ; DOS load/save bank
   505  118d 0000               dosdid           !fill 2                                  ; DOS ID identifier
   506  118f 00                 dosflags         !fill 1                                  ; DOS flags  7:ID,  6:recover
   507  1190 00                 dossa_temp       !fill 1                                  ; temp storage for file's sa during RECORD command
   508                          dosspc           = *-xcnt                                 ; space used by DOS routines-------------------------------------
   509                          
   510  1191 0000000000000000...savram           !fill 67                                 ; buffer used by MOVSPR, SPRDEF, SAVSPR, and DOS parser
   511                          
   512                          xabs             = savram                                 ; movspr_line calculations   [910809]
   513                          yabs             = savram+2
   514                          xsgn             = savram+4
   515                          ysgn             = savram+6
   516                          fct              = savram+8
   517                          errval           = savram+12
   518                          
   519                          
   520                          ; PRINT USING definitions & storage  (24 bytes)
   521                          
   522                          puchrs                                                    ; Declarations for PRINT USING...
   523  11d4 00                 pufill           !fill 1                                  ; print using fill symbol
   524  11d5 00                 pucoma           !fill 1                                  ; print using comma symbol
   525  11d6 00                 pudot            !fill 1                                  ; print using decimal point symbol
   526  11d7 00                 pumony           !fill 1                                  ; print using monetary symbol
   527                          
   528  11d8 00                 bnr              !fill 1                                  ; pointer to begin #
   529  11d9 00                 enr              !fill 1                                  ; pointer to end #
   530  11da 00                 dolr             !fill 1                                  ; dollar flag
   531  11db 00                 flag             !fill 1                                  ; comma flag (also used by PLAY)????
   532  11dc 00                 swe              !fill 1                                  ; counter
   533  11dd 00                 usgn             !fill 1                                  ; sign exponent
   534  11de 00                 uexp             !fill 1                                  ; pointer to exponent
   535  11df 00                 vn               !fill 1                                  ; # of digits before decimal point
   536  11e0 00                 chsn             !fill 1                                  ; justify flag
   537  11e1 00                 vf               !fill 1                                  ; # of positions before decimal point (field)
   538  11e2 00                 nf               !fill 1                                  ; # of positions after decimal point (field)
   539  11e3 00                 posp             !fill 1                                  ; +/- flag (field)
   540  11e4 00                 fesp             !fill 1                                  ; exponent flag (field)
   541  11e5 00                 etof             !fill 1                                  ; switch
   542  11e6 00                 cform            !fill 1                                  ; char counter (field)
   543  11e7 00                 sno              !fill 1                                  ; sign no
   544  11e8 00                 blfd             !fill 1                                  ; blank/star flag
   545  11e9 00                 begfd            !fill 1                                  ; pointer to begin of field
   546  11ea 00                 lfor             !fill 1                                  ; length of format
   547  11eb 00                 endfd            !fill 1                                  ; pointer to end of field
   548                          
   549                          
   550                          ;  * = $1200 ;BASIC Graphic, Sprite, Music, & Sound storage
   551                          
   552                          ;  The following 24 bytes are multiply defined...
   553                          ;
   554                          ; params = *
   555                          
   556                          ;  Circle drawing variables  (multiply defined).
   557                          ;
   558                          ; xcircl *=*+2  ;circle center, x coordinate
   559                          ; ycircl *=*+2  ;circle center, y coordinate
   560                          ; xradus *=*+2  ;x radius
   561                          ; yradus *=*+2  ;y radius
   562                          ; rotang *=*+4  ;rotation angle
   563                          ; angbeg *=*+2  ;arc angle start
   564                          ; angend *=*+2  ;arc angle end
   565                          ; xrcos  *=*+2  ;x radius * cos(rotation angle)
   566                          ; yrsin  *=*+2  ;y radius * sin(rotation angle)
   567                          ; xrsin  *=*+2  ;x radius * sin(rotation angle)
   568                          ; yrcos  *=*+2  ;y radius * cos(rotation angle)
   569                          
   570                          ; parend = *
   571                          
   572                          ;  Box drawing variables  (multiply defined).
   573                          ;
   574                          ;  *=params
   575                          ; xcord1 *=*+2  ;point 1 x-coord.
   576                          ; ycord1 *=*+2  ;point 1 y-coord.
   577                          ; boxang *=*+2  ;rotation angle
   578                          ; xcount *=*+2
   579                          ; ycount *=*+2
   580                          ; bxleng *=*+2  ;length of a side
   581                          ; xcord2 *=*+2
   582                          ; ycord2 *=*+2
   583                          
   584                          
   585                          ;  Shape variables  (multiply defined).
   586                          ;
   587                          ;  *=params
   588                          ;  *=*+1  ;placeholder
   589                          ; keylen *=*+1
   590                          ; keynxt *=*+1
   591                          ; strsz  *=*+1  ;string len
   592                          ; gettyp *=*+1  ;replace shape mode
   593                          ; strptr *=*+1  ;string pos'n counter
   594                          ; oldbyt *=*+1  ;old bit map byte
   595                          ; newbyt *=*+1  ;new string or bit map byte
   596                          ;  *=*+1  ;placeholder
   597                          ; xsize  *=*+2  ;shape column length
   598                          ; ysize  *=*+2  ;shape row length
   599                          ; xsave  *=*+2  ;temp for column length
   600                          ; stradr *=*+2  ;save shape string descriptor
   601                          ; bitidx *=*+1  ;bit index into byte
   602                          
   603                          ;  General use parameters  (multiply defined).
   604                          ;
   605                          ;  *=params
   606                          ; xcentr *=*+2
   607                          ; ycentr *=*+2
   608                          ; xdist1 *=*+2
   609                          ; ydist1 *=*+2
   610                          ; xdist2 *=*+2
   611                          ; ydist2 *=*+2
   612                          ; disend
   613                          ;  *=*+2  ;placeholder
   614                          ; colcnt *=*+1  ;char's col. counter
   615                          ; rowcnt *=*+1
   616                          ; strcnt *=*+1
   617                          
   618                          
   619                          ;  General  graphic & sound  buffers & assignments
   620                          ;
   621                          ;  * = parend
   622                          
   623                          ;  General graphic storage (used by C128-type sprite routines in C65)
   624                          
   625                          vwork                                                     ; graphics & sprite vars
   626  11ec 0000               xpos             !fill 2                                  ; current x position
   627  11ee 0000               ypos             !fill 2                                  ; current y position
   628  11f0 0000               xdest            !fill 2                                  ; x-coordinate destination
   629  11f2 0000               ydest            !fill 2                                  ; y-coordinate destination
   630                          
   631  11f4 00                 numcnt           !fill 1                                  ; temp, usually coordinate type
   632  11f5 00                 vtemp1           !fill 1                                  ; used by sprite math stuff ????was base page
   633  11f6 00                 vtemp2           !fill 1                                  ; ????was base page
   634  11f7 00                 vtemp3           !fill 1                                  ; misc. graphic temp storage
   635  11f8 00                 vtemp4           !fill 1
   636  11f9 00                 vtemp5           !fill 1
   637                          
   638                          ; mvdflg *=*+1  ;flag if 10k hires allocated ???? this stuff was base page
   639                          ; colsel *=*+1  ;current color selected
   640                          ; multicolor_1 *=*+1
   641                          ; multicolor_2 *=*+1
   642                          ; foreground *=*+1
   643                          ; scalem *=*+1  ;scale mode flag
   644                          ; scale_x *=*+2  ;scale factor in x
   645                          ; scale_y *=*+2  ;scale factor in y
   646                          ; stopnb *=*+1  ;stop paint if not background/not same color
   647                          ; fg_bg  *=*+1  ;packed foreground/background color nybbles
   648                          ; fg_mc1 *=*+1  ;packed foreground/multicolor 1 color nybbles
   649                          
   650                          ; bitcnt *=*+1  ;temp for gshape
   651                          ; width  *=*+1  ;double width flag
   652                          ; filflg *=*+1  ;box fill flag
   653                          ; circle_segment *=*+1  ;degrees per circle segment
   654                          ; bitmsk *=*+1  ;temp for bit mask
   655                          
   656                          ; character_rom *=*+1  ;high byte of address of char rom for 'char' command
   657                          ; upper_lower *=*+1  ;pointer to upper/lower case for char command
   658                          ; upper_graphic *=*+1  ;   "       upper/graphic
   659                          
   660                          ;  DrawLine stuff
   661                          ;
   662                          ; xabs  *=*+2  ;16 bytes
   663                          ; yabs  *=*+2
   664                          ; xsgn  *=*+2
   665                          ; ysgn  *=*+2
   666                          ; fct  *=*+4
   667                          ; errval *=*+2
   668                          ; lesser *=*+1
   669                          ; greatr *=*+1
   670                          
   671                          ;  Angle stuff (used by sprites)
   672                          
   673  11fa 00                 angsgn           !fill 1                                  ; sign of angle
   674  11fb 0000               sinval           !fill 2                                  ; sine of value of angle
   675  11fd 0000               cosval           !fill 2                                  ; cosine of value of angle
   676                          ; angcnt *=*+2  ;temps for angle distance routines
   677                          
   678                          
   679                          ; Sprite stuff
   680                          
   681  11ff 00000000           savsiz           !fill 4                                  ; temp work locations for SSHAPE, SPRSAV, MOVSPR_TO
   682                          lesser
   683  1203 00                 sprtmp_1         !fill 1                                  ; temp for SPRSAV
   684                          greatr
   685  1204 00                 sprtmp_2         !fill 1
   686                          
   687  1205 0000000000000000...sprite_data      !fill 88                                 ; speed/direction tables for 8 sprites, 11 bytes each
   688                          ;   move ang/dist move line
   689                          ; offset= 0 b7=0+speed b7=1+speed
   690                          ;  1 counter  counter lo
   691                          ;  2 angle sign         hi
   692                          ;  3,4 delta-X  dir+min/max
   693                          ;  5,6 delta-Y  fct1
   694                          ;  7,8 total-X  fct2
   695                          ;  9,10 total-Y  error
   696                          
   697                          init_as_0        = *-sprite_data-1
   698                          
   699                          ; vic_save *=*+21  ;copy of VIC reg's, used to update chip during retrace
   700                          
   701                          ; defmod *=*+1  ;for SPRDEF
   702                          ; lincnt *=*+1  ; "
   703                          ; sprite_number *=*+1  ; "
   704                          
   705                          
   706                          ; Music stuff driving stereo SIDs, 3 voices each
   707                          
   708  125d 0000000000000000...voices           !fill 12                                 ; Voice counters (activity flags)  [910612] stereo
   709  1269 000000000000       waveform         !fill 6                                  ; Waveforms for each voice   [910612] stereo
   710                          
   711  126f 00                 voice            !fill 1                                  ; Play note parameters
   712  1270 00                 octave           !fill 1
   713  1271 00                 sharp            !fill 1
   714  1272 00                 dnote            !fill 1
   715  1273 00                 tempo_rate       !fill 1                                  ; duration of whole note 4/4 time = 24/rate
   716  1274 0000               pitch            !fill 2
   717  1276 0000               ntime            !fill 2
   718                          
   719  1278 00000000           filters1         !fill 4                                  ; Volume & Filter parameters   [910612] was 5
   720  127c 00000000           filters2         !fill 4                                  ; [910612] stereo
   721  1280 00000000           fltsav           !fill 4                                  ; temps
   722  1284 00                 fltflg           !fill 1                                  ; temp
   723                          
   724  1285 00                 tonnum           !fill 1                                  ; Tune Envelope stuff
   725  1286 000000             tonval           !fill 3
   726                          
   727  1289 0000000000000000...atktab           !fill 10                                 ; Tune Envelopes
   728  1293 0000000000000000...sustab           !fill 10
   729  129d 0000000000000000...wavtab           !fill 10
   730  12a7 0000000000000000...pulslw           !fill 10
   731  12b1 0000000000000000...pulshi           !fill 10
   732                          
   733  12bb 00                 parcnt           !fill 1                                  ; temp: envelope
   734  12bc 00                 nibble           !fill 1                                  ; temp: envelope, filter
   735                          
   736                          
   737                          ; SOUND command stuff
   738                          
   739  12bd 00                 sound_voice      !fill 1
   740  12be 000000000000       sound_time_lo    !fill 3+3                                ; [910612] stereo
   741  12c4 000000000000       sound_time_hi    !fill 3+3                                ; [910612] stereo
   742  12ca 000000000000       sound_max_lo     !fill 3+3                                ; [910612] stereo
   743  12d0 000000000000       sound_max_hi     !fill 3+3                                ; [910612] stereo
   744  12d6 000000000000       sound_min_lo     !fill 3+3                                ; [910612] stereo
   745  12dc 000000000000       sound_min_hi     !fill 3+3                                ; [910612] stereo
   746  12e2 000000000000       sound_direction  !fill 3+3                                ; [910612] stereo
   747  12e8 000000000000       sound_step_lo    !fill 3+3                                ; [910612] stereo
   748  12ee 000000000000       sound_step_hi    !fill 3+3                                ; [910612] stereo
   749  12f4 000000000000       sound_freq_lo    !fill 3+3                                ; [910612] stereo
   750  12fa 000000000000       sound_freq_hi    !fill 3+3                                ; [910612] stereo
   751                          
   752                          ;above must end before $1300
   753                                           * = $1160
   754                          ;below must end before $1170
   755                          
   756  1160 00                 temp_time_lo     !fill 1
   757  1161 00                 temp_time_hi     !fill 1
   758  1162 00                 temp_max_lo      !fill 1
   759  1163 00                 temp_max_hi      !fill 1
   760  1164 00                 temp_min_lo      !fill 1
   761  1165 00                 temp_min_hi      !fill 1
   762  1166 00                 temp_direction   !fill 1
   763  1167 00                 temp_step_lo     !fill 1
   764  1168 00                 temp_step_hi     !fill 1
   765  1169 00                 temp_freq_lo     !fill 1
   766  116a 00                 temp_freq_hi     !fill 1
   767  116b 00                 temp_pulse_lo    !fill 1
   768  116c 00                 temp_pulse_hi    !fill 1
   769  116d 00                 temp_waveform    !fill 1
   770                          
   771  116e 00                 pot_temp_1       !fill 1                                  ; temporaries for 'POT' function
   772  116f 00                 pot_temp_2       !fill 1
   773                          
   774                          
   775                                           * = $1300
   776                          
   777  1300 0000000000000000...dosstr           !fill 256                                ; DOS input/output string buffer
   778                          
   779                          
   780                                           * = $1f00                                ; Graphics Kernel Interface
   781                          
   782  1f00 00                 GKI__parm1       !fill 1                                  ; ml interface parm values
   783  1f01 00                 GKI__parm2       !fill 1
   784  1f02 00                 GKI__parm3       !fill 1
   785  1f03 00                 GKI__parm4       !fill 1
   786  1f04 00                 GKI__parm5       !fill 1
   787  1f05 00                 GKI__parm6       !fill 1
   788  1f06 00                 GKI__parm7       !fill 1
   789  1f07 00                 GKI__parm8       !fill 1
   790  1f08 00                 GKI__parm9       !fill 1
   791  1f09 00                 GKI__parm10      !fill 1
   792  1f0a 00                 GKI__parm11      !fill 1
   793  1f0b 00                 GKI__parm12      !fill 1
   794  1f0c 00                 GKI__parm13      !fill 1
   795  1f0d 00                 GKI__parm14      !fill 1
   796  1f0e 00                 GKI__parm15      !fill 1
   797  1f0f 00                 GKI__parm16      !fill 1
   798  1f10 00                 GKI__parm17      !fill 1
   799                          
   800  1f11 00                 GKI__subparm1    !fill 1                                  ; subroutine parm values
   801  1f12 00                 GKI__subparm2    !fill 1
   802  1f13 00                 GKI__subparm3    !fill 1
   803  1f14 00                 GKI__subparm4    !fill 1
   804  1f15 00                 GKI__subparm5    !fill 1
   805                          
   806  1f16 00                 GKI__temp1       !fill 1                                  ; local variables within subroutines
   807  1f17 00                 GKI__temp2       !fill 1
   808  1f18 00                 GKI__temp3       !fill 1
   809  1f19 00                 GKI__temp4       !fill 1
   810  1f1a 00                 GKI__temp5       !fill 1
   811  1f1b 00                 GKI__temp6       !fill 1
   812  1f1c 00                 GKI__temp7       !fill 1
   813  1f1d 00                 GKI__temp8       !fill 1
   814  1f1e 00                 GKI__temp9       !fill 1
   815  1f1f 00                 GKI__temp10      !fill 1
   816  1f20 00                 GKI__temp11      !fill 1
   817  1f21 00                 GKI__temp12      !fill 1
   818  1f22 00                 GKI__temp13      !fill 1
   819  1f23 00                 GKI__temp14      !fill 1
   820  1f24 00                 GKI__temp15      !fill 1
   821  1f25 00                 GKI__temp16      !fill 1
   822  1f26 00                 GKI__temp17      !fill 1
   823                          
   824                          ;.end
   825                          
   826                          
   827                          ;[[kernal]]
   828                          ; Addresses of OS parameters referenced by BASIC:
   829                          
   830                          _6510_data_reg   = $01
   831                          _bank            = $02                                    ; reg's for Kernel xxx_FAR routines (used by SYS)
   832                          _pchi            = $03
   833                          _pclo            = $04
   834                          _s_reg           = $05
   835                          _a_reg           = $06
   836                          _x_reg           = $07
   837                          _y_reg           = $08
   838                          _z_reg           = $09
   839                          
   840                          _vicIRQ          = $a0                                    ; VIC IRQ flag register at time of IRQ
   841                          _starting_addr   = $ac                                    ; address BLOAD loaded to
   842                          _sa              = $b9                                    ; I/O channel secondary address
   843                          _fa              = $ba                                    ; I/O channel device number
   844                          _ndx             = $d0                                    ; number of characters in keyboard buffer
   845                          _kyndx           = $d1                                    ; fkey active flag
   846                          _mode            = $d7                                    ; 40/80 mode
   847                          _graphm          = $d8                                    ; graphic mode switch (multi/hires/split)
   848                          _pnt             = $e0                                    ; Editor screen address at cursor
   849                          
   850                          _screen_bottom   = $e4                                    ; these describe the current window
   851                          _screen_top      = $e5
   852                          _screen_left     = $e6
   853                          _screen_right    = $e7
   854                          
   855                          _color           = $f1                                    ; text color      [910722]
   856                          _autoinsert      = $f6                                    ; enable/disable auto insert mode
   857                          _locks           = $f7                                    ; Editor keyboard locks     [910722]
   858                          
   859                          _keyd            = $02b0                                  ; keyboard buffer     [910710]
   860                          ;_split = $0a34  ;line to start split at
   861                          
   862                          number_fkeys     = 16                                     ; max of 14 prog. fn. keys
   863                          _pky_lengths     = $1000                                  ; table of prog. fn. key sizes
   864                          _pky_buffer      = _pky_lengths+number_fkeys              ; actual buffer
   865                          
   866                          _restart_vector  = $1100                                  ; Kernel restart vector
   867                          _pal_ntsc        = $1103                                  ; PAL=$ff, NTSC=$00 indicator    [910107]
   868                          _init_status     = $1104                                  ; msb set tells Kernel to let BASIC have IRQs
   869                          _default_drive   = $1106                                  ; system default disk drive
   870                          _expansion       = $1107                                  ; expansion RAM (# banks????)    [910107]
   871                          _sleep_counter   = $110c                                  ; binary frame counter maintained by Kernel  [910730]
   872                          _mouse_enable    = $1135                                  ; port# used by mouse (b7=port2, b6=port1, or both) [910107]
   873                          _mouse_pointer   = $1136                                  ; sprite pointer (sprite*2) by Kernel mouse driver "
   874                          _mouse_top       = $113b                                  ; margins for mouse pointer    "
   875                          _mouse_bottom    = $113c                                  ; "
   876                          _mouse_left      = $113d                                  ; "
   877                          _mouse_right     = $113e                                  ; "
   878                          
   879                          ; Addresses of I/O areas referenced by BASIC:
   880                          
   881                          _red             = $d100                                  ; VIC palette (I/O block)
   882                          _green           = $d200
   883                          _blue            = $d300
   884                          
   885                          ; Addresses of Kernel entry points referenced by BASIC:
   886                          
   887                          _print           = $e00c
   888                          _mouse           = $e01b                                  ; [910122]
   889                          _set_window      = $e02d
   890                          _palette_init    = $e027
   891                          _cursor          = $e030                                  ; [910228]
   892                          ;_ldtb2 = $e033
   893                          ;_ldtb1 = $e04c
   894                          
   895                          _close_all       = $ff50                                  ; close all channels assigned to device .a
   896                          _go_64           = $ff53                                  ; C64 mode
   897                          _monitor         = $ff56                                  ; ML Monitor
   898                          _bootsys         = $ff59                                  ; Boot alternate OS     [910110]
   899                          _phoenix         = $ff5c                                  ; jump to 'post-BASIC initialize' routine
   900                          _lkupla          = $ff5f                                  ; find an available Logical Address
   901                          _lkupsa          = $ff62                                  ; find an available Secondary Address
   902                          _swapper         = $ff65                                  ; switch 80/40 column
   903                          _doakey          = $ff68                                  ; add/remove a definition from the p.f. key table
   904                          _setbank         = $ff6b                                  ; set bank for load/save/verify/open
   905                          _jsr_far         = $ff6e                                  ; call a subroutine in any bank
   906                          _jmp_far         = $ff71                                  ; jump to code in any bank
   907                          _lda_far         = $ff74                                  ; write a byte to any bank
   908                          _sta_far         = $ff77                                  ; read a byte from any bank
   909                          _cmp_far         = $ff7a                                  ; compare a byte to any bank
   910                          _primm           = $ff7d                                  ; print immediate
   911                          
   912                          _setmsg          = $ff90
   913                          _readst          = $ffb7
   914                          _setlfs          = $ffba
   915                          _setnam          = $ffbd
   916                          _open            = $ffc0
   917                          _close           = $ffc3
   918                          _chkin           = $ffc6
   919                          _chkout          = $ffc9
   920                          _clrch           = $ffcc
   921                          _basin           = $ffcf
   922                          _bsout           = $ffd2
   923                          _loadsp          = $ffd5
   924                          _savesp          = $ffd8
   925                          _SetTime         = $ffdb
   926                          _ReadTime        = $ffde
   927                          _stop            = $ffe1
   928                          _getin           = $ffe4
   929                          _clall           = $ffe7
   930                          _screen_org      = $ffed
   931                          _plot            = $fff0
   932                          
   933                          ;.end
   934                          
   935                          
   936                          
   937                          ;[[initialise]]
   938                          ; ***************************************************************************************************************
   939                          ; ***************************************************************************************************************
   940                          ;
   941                          ;      Name:       patch.asm
   942                          ;      Purpose:    Fixes
   943                          ;      Created:    4th January 2020
   944                          ;      Author:     Paul Robson (paul@robsons.org.uk)
   945                          ;
   946                          ; ***************************************************************************************************************
   947                          ; ***************************************************************************************************************
   948                          
   949                          ; ***************************************************************************************************************
   950                          ;
   951                          ;				At present ACME does not support BRA opcode $83. BRL replaces this.
   952                          ;
   953                          ; ***************************************************************************************************************
   954                          
   955                          !macro lbra addr {
   956                          	!byte $83
   957                          	!word (addr-*-1) & $FFFF
   958                          }
   959                          
   960                          !macro lbcc addr {
   961                          	!byte $93
   962                          	!word (addr-*-1) & $FFFF
   963                          }
   964                          
   965                          !macro lbcs addr {
   966                          	!byte $B3
   967                          	!word (addr-*-1) & $FFFF
   968                          }
   969                          
   970                          !macro lbne addr {
   971                          	!byte $D3
   972                          	!word (addr-*-1) & $FFFF
   973                          }
   974                          
   975                          !macro lbeq addr {
   976                          	!byte $F3
   977                          	!word (addr-*-1) & $FFFF
   978                          }
   979                          
   980                          !macro lbpl addr {
   981                          	!byte $13
   982                          	!word (addr-*-1) & $FFFF
   983                          }
   984                          
   985                          !macro lbmi addr {
   986                          	!byte $33
   987                          	!word (addr-*-1) & $FFFF
   988                          }
   989                          
   990                          !macro lbvs addr {
   991                          	!byte $73
   992                          	!word (addr-*-1) & $FFFF
   993                          }
   994                          
   995                          !macro lbvc addr {
   996                          	!byte $53
   997                          	!word (addr-*-1) & $FFFF
   998                          }
   999                                           * = $2000
  1000                          
  1001                          basic
  1002  2000 4c2520                              jmp hard_reset
  1003  2003 4c0c20                              jmp soft_reset
  1004  2006 4c7579                              jmp basic_irq
  1005  2009 4c06bf                              jmp basic_nmi                            ; (removed)    [910523] audio
  1006                          
  1007                          soft_reset                                                ; warm start BASIC...
  1008  200c 20b438                              jsr release_channels                     ; restore default terminal I/O channels
  1009  200f a900                                lda #doslfn                              ; restore reserved disk channel
  1010  2011 38                                  sec                                      ; not a real close
  1011  2012 20c3ff                              jsr _close
  1012  2015 208278                              jsr Clear_DS                             ; zap DS$ just in case
  1013                          ; (might have been in Monitor or building DS$)
  1014  2018 200d21                              jsr init_sound_sprites                   ; init interrupt & dma stuff   [910523]
  1015  201b 200935                              jsr init_stack                           ; restore stack
  1016  201e a901                                lda #1
  1017  2020 0c0411                              tsb _init_status                         ; tell Kernel to give BASIC a call at IRQ time
  1018  2023 802e                                bra go_ready                             ; enable IRQ, print READY, and go MAIN
  1019                          
  1020                          
  1021                          hard_reset
  1022  2025 205f22                              jsr init_vectors                         ; init vectors
  1023  2028 205720                              jsr init_storage                         ; init variables, voices,  & download RAM code
  1024  202b 203321                              jsr signon_message                       ; print initialization message
  1025                          
  1026  202e a900                                lda #0                                   ; init bank pointers   [900509]
  1027  2030 8584                                sta text_bank
  1028  2032 8555                                sta helper                               ; reset all LIST flags
  1029  2034 a901                                lda #1
  1030  2036 8585                                sta var_bank
  1031  2038 a902                                lda #2
  1032  203a 8dd802                              sta highlight_color                      ; set highlight color (2=red)
  1033  203d a203                                ldx #<basic+3
  1034  203f 8e0011                              stx _restart_vector                      ; point system restart vector at warm start entry
  1035  2042 200935                              jsr init_stack                           ; initialize system stack pointer
  1036  2045 a901                                lda #1
  1037  2047 0c0411                              tsb _init_status                         ; tell Kernel to give BASIC a call at IRQ time
  1038  204a 220080                              jsr ($8000)                              ; initialize graphics
  1039  204d 205cff                              jsr _phoenix                             ; call cartridges, check out expansion card
  1040  2050 20a467                              jsr autobootCSG                          ; attempt to boot program from disk
  1041                          
  1042                          go_ready
  1043  2053 58                                  cli                                      ; enable IRQ
  1044  2054 83f70d                              +lbra ready
  1045                          
  1046                          
  1047                          init_storage
  1048  2057 a94c                                lda #76                                  ; 'jmp' opcode
  1049  2059 8556                                sta jmper
  1050  205b 8df702                              sta usrpok
  1051                          
  1052  205e a9e8                                lda #<errguf                             ; init USR vector to 'undef'd function'  [910226] FAB
  1053  2060 a058                                ldy #>errguf
  1054  2062 8df802                              sta usrpok+1
  1055  2065 8cf902                              sty usrpok+2
  1056                          
  1057  2068 a99f                                lda #<flpint                             ; ???? why keep
  1058  206a a058                                ldy #>flpint
  1059  206c 8dc002                              sta adray1
  1060  206f 8cc102                              sty adray1+1
  1061                          
  1062  2072 a93f                                lda #<givayf                             ; ???? why keep
  1063  2074 a04e                                ldy #>givayf
  1064  2076 8dc202                              sta adray2
  1065  2079 8cc302                              sty adray2+1
  1066                          
  1067                          ; Download CHRGET (and INDSUB code????) to RAM
  1068                          ;
  1069                          ; ldx #endmov-chrget_pattern
  1070                          ;1$ lda chrget_pattern-1,x
  1071                          ; sta chrget-1,x
  1072                          ; dex
  1073                          ; bne 1$
  1074                          
  1075  207c a200                                ldx #0
  1076  207e 8ec402                              stx zero                                 ; zero constant
  1077  2081 8ec502                              stx zero+1
  1078  2084 8ec602                              stx zero+2
  1079  2087 8ed702                              stx bits                                 ; reset bit/byte shifter
  1080  208a 8615                                stx channl                               ; default channels
  1081  208c 867e                                stx runmod                               ; direct mode
  1082  208e 861a                                stx lastpt+1
  1083  2090 8674                                stx autinc                               ; turn off auto increment
  1084  2092 8675                                stx autinc+1
  1085  2094 8e7411                              stx rndx                                 ; zero-ing MSB will guarantee a legal value
  1086                          ; stx dosfa  ;zero device number     [910429]
  1087                          
  1088  2097 8edc02                              stx intval                               ; reset all BASIC IRQ stuff
  1089  209a 8edd02                              stx int_trip_flag                        ; (BASIC IRQ enabled in init_voices)
  1090  209d 8ede02                              stx int_trip_flag+1
  1091  20a0 8edf02                              stx int_trip_flag+2
  1092  20a3 8ee802                              stx lightpen_xpos
  1093  20a6 8ee902                              stx lightpen_ypos
  1094                          
  1095                          ; stx mvdflg  ;flag '8k graphics screen not allocated'
  1096                          ; stx width  ;init to single-width lines
  1097                          ; stx scalem  ;turn off scaleing
  1098                          ; stx filflg
  1099                          
  1100                          ; inx   ;.x=1 ???? why init stack with $0101 ????
  1101                          ; stx buf-3
  1102                          ; stx buf-4
  1103                          
  1104                          ; ldy #88   ;zero out sprite information area
  1105                          ;2$ sta sprite_data,y ;???? this is done later at init_as_0
  1106                          ; dey
  1107                          ; bpl 2$
  1108                          
  1109                          ; ldx #13
  1110                          ; stx foreground  ;init bit map's fg color to light green
  1111                          ; ldx #1
  1112                          ; stx multicolor_1 ;init mc1 to white
  1113                          ; ldx #2
  1114                          ; stx multicolor_2 ;init mc2 to red
  1115                          ; jsr set_packed_color ;set up packed fg/bg and fg/mc1 bytes
  1116                          
  1117  20a9 ae0611                              ldx _default_drive
  1118  20ac 8e8211                              stx dosfa                                ; init device number to system default   [910429]
  1119                          
  1120  20af a280                                ldx #$80                                 ; bank 0 with I/O????
  1121  20b1 8ed102                              stx current_bank                         ; set default bank for PEEK,POKE,BOOT,SYS,WAIT,BLOAD/SAVE
  1122                          
  1123  20b4 a21b                                ldx #tempst
  1124  20b6 8618                                stx temppt                               ; init temp descriptor pointer
  1125                          
  1126  20b8 a201                                ldx #<baswrk                             ; set up bottom of bank 0 (text area)
  1127  20ba a020                                ldy #>baswrk
  1128  20bc 862d                                stx txttab
  1129  20be 842e                                sty txttab+1
  1130                          
  1131  20c0 a900                                lda #<varbgn                             ; set up bottom of bank 1 (storage area)
  1132  20c2 a020                                ldy #>varbgn
  1133  20c4 852f                                sta vartab
  1134  20c6 8430                                sty vartab+1
  1135                          
  1136  20c8 a900                                lda #<bank_0_top                         ; set up top of bank 0
  1137  20ca a080                                ldy #>bank_0_top
  1138  20cc 8dcf02                              sta max_mem_0
  1139  20cf 8cd002                              sty max_mem_0+1
  1140                          
  1141  20d2 a900                                lda #<bank_1_top                         ; set up  top of bank 1
  1142  20d4 a080                                ldy #>bank_1_top
  1143  20d6 8539                                sta max_mem_1
  1144  20d8 843a                                sty max_mem_1+1
  1145                          
  1146  20da a900                                lda #0                                   ; init text input buffer  (these are for autoboot)
  1147  20dc 8d0002                              sta buf
  1148  20df 3a                                  dec
  1149  20e0 853c                                sta curlin+1                             ; init line pointer
  1150  20e2 a2ff                                ldx #<buf_txtptr                         ; init txtptr
  1151  20e4 a001                                ldy #>buf_txtptr
  1152  20e6 863d                                stx txtptr
  1153  20e8 843e                                sty txtptr+1
  1154                          
  1155                          ; Set up sprite pointers
  1156                          
  1157  20ea a91f                                lda #sprite_base/64+7
  1158  20ec a007                                ldy #7
  1159  20ee 7fd705             l1_1             bbr7 _mode,l1_2
  1160  20f1 99f80b                              sta sprite_ptrs_40,y                     ; 40 col screen
  1161  20f4 8003                                bra l1_3
  1162  20f6 99f80f             l1_2             sta sprite_ptrs_80,y                     ; 80 col screen
  1163  20f9 3a                 l1_3             dec
  1164  20fa 88                                  dey
  1165  20fb 10f1                                bpl l1_1
  1166                          
  1167                          ; Zero out sprite movement stuff and some VIC stuff too
  1168                          
  1169  20fd a900                                lda #0
  1170  20ff a257                                ldx #init_as_0
  1171  2101 9d0512             l1_4             sta sprite_data,x
  1172  2104 ca                                  dex
  1173  2105 10fa                                bpl l1_4
  1174                          
  1175  2107 200d21                              jsr init_sound_sprites                   ; init misc. interrupt & dma stuff
  1176                          
  1177                          ; lda #$d0  ;initialize pointers to character ROM
  1178                          ; sta upper_graphic
  1179                          ; lda #$d8
  1180                          ; sta upper_lower
  1181                          
  1182  210a 836c13                              +lbra init_text                          ; go to 'new'
  1183                          
  1184                          
  1185                          init_sound_sprites                                          ; [910523]
  1186                          ;; init_voices   ;Initialize music stuff
  1187                          ; bit _pal_ntsc  ;determine if PAL or NTSC system  [910724]
  1188                          ; bmi 1$   ;...branch if PAL
  1189                          ; lda #<beats_ntsc/4 ;set beat to quarter note (4/4 time = .5 sec)
  1190                          ; ldy #>beats_ntsc/4
  1191                          ; bra 2$
  1192                          ;1$ lda #<beats_pal/4
  1193                          ; ldy #>beats_pal/4
  1194                          ;2$ sta ntime
  1195                          ; sty ntime+1
  1196                          ;
  1197                          ; lda #4   ;set default octave
  1198                          ; sta octave
  1199                          ;
  1200                          ; lda #12   ;set default tempo    [910220]
  1201                          ; sta tempo_rate  ; 12 makes whole note in 4/4 time last 2 seconds
  1202                          ;----
  1203                          ;; jsr go_slow  ;      [910716] 4567R7A
  1204                          ; lda #0   ;make sure all gates are off
  1205                          ; sta sid1+4
  1206                          ; sta sid1+11
  1207                          ; sta sid1+18
  1208                          ; sta sid2+4
  1209                          ; sta sid2+11
  1210                          ; sta sid2+18
  1211                          ; sta filters1+2  ;set filters off, volume to max????  [910612]
  1212                          ; sta filters2+2
  1213                          ;
  1214                          ; lda #8
  1215                          ; sta sid1+24
  1216                          ; sta sid2+24
  1217                          ; sta filters1+3
  1218                          ; sta filters2+3  ;      [910612]
  1219                          ;; sta filters+4  ;why?      [910612]
  1220                          ;; jsr go_fast  ;      [910716] 4567R7A
  1221                          ;----
  1222                          ; ldy #29   ;initialize music tables
  1223                          ;10$ lda atkmus,y
  1224                          ; sta atktab,y
  1225                          ; dey
  1226                          ; bpl 10$
  1227                          ;
  1228                          ; ldx #9   ;initialize pulse widths
  1229                          ;20$ lda pwhmus,x
  1230                          ; sta pulshi,x
  1231                          ; dex
  1232                          ; bpl 20$
  1233                          ;
  1234                          ; stx sound_time_hi ;turn all SOUND counters off (.X = $ff)
  1235                          ; stx sound_time_hi+1
  1236                          ; stx sound_time_hi+2
  1237                          ; stx sound_time_hi+3 ;stereo SIDs     [910612]
  1238                          ; stx sound_time_hi+4
  1239                          ; stx sound_time_hi+5
  1240                          ; stx voices+1  ;turn all PLAY counters off
  1241                          ; stx voices+3
  1242                          ; stx voices+5
  1243                          ; stx voices+7  ;stereo SIDs     [910612]
  1244                          ; stx voices+9
  1245                          ; stx voices+11
  1246                          ;
  1247                          ; ldy #6-1  ;set default envelope (piano) for all voices (6)
  1248                          ; sty voice
  1249                          ;30$ ldx #0
  1250                          ; jsr set_envelope_1
  1251                          ; dec voice
  1252                          ; bpl 30$
  1253                          ; inc voice  ;set default voice (0)
  1254                          ;-----
  1255  210d 2058be                              jsr Sound_CLR_1                          ; [910724]
  1256                          
  1257  2110 a9e7                                lda #%11100111                           ; [910626]
  1258  2112 1455                                trb helper                               ; reset LIST/HELP/FIND flags
  1259  2114 0cd902                              tsb highlight_save                       ; mark saved color as invalid
  1260                          
  1261  2117 a900                                lda #0                                   ; [910523] F018A
  1262  2119 a217                                ldx #12+12-1                             ; init DMA lists
  1263  211b 9d4401             l2_1             sta dma1_cmd,x
  1264  211e ca                                  dex
  1265  211f 10fa                                bpl l2_1
  1266                          
  1267                          ; stop_sprites   ;Stop all moving sprites (a=0)   [910523]
  1268  2121 a007                                ldy #7                                   ; for sprites 0...7
  1269  2123 befeb7             l2_2             ldx sproff,y                             ; get table offset
  1270  2126 9d0512                              sta sprite_data,x                        ; reset speed for this sprite
  1271  2129 88                                  dey
  1272  212a 10f7                                bpl l2_2                                 ; loop until done
  1273                          
  1274  212c 8d15d0                              sta vic+21                               ; Turn off all sprites    [910717]
  1275                          
  1276  212f 8ddb02                              sta irq_wrap_flag                        ; enable BASIC IRQ handler
  1277                          ; sta nmi_wrap_flag ;enable BASIC NMI handler   [910523]
  1278  2132 60                                  rts                                      ; (removed)    [910826]
  1279                          
  1280                          
  1281                          signon_message
  1282  2133 207dff             l3_1             jsr _primm
  1283  2136 93121c2020202020...                 !text 147,18,028,"                     ",146,169
  1284  2150 0509202020202020...                 !text 5,9,"       THE COMMODORE C65 DEVELOPMENT SYSTEM",cr
  1285  217e 1296202020202020...                 !text 18,150,"                  ",146,169,cr
  1286  2195 129e202020202020...                 !text 18,158,"               ",146,169
  1287  21a8 0509202020434f50...                 !text 5,9,"   COPYRIGHT  1991  COMMODORE ELECTRONICS, LTD.",cr
  1288  21da 121e202020202020...                 !text 18,030,"            ",146,169
  1289  21ea 0509090920202020...                 !text 5,9,9,9,"    COPYRIGHT  1977  MICROSOFT",cr
  1290  220d 129a202020202020...                 !text 18,154,"          ",146,169,cr
  1291  221c 129c202020202020...                 !text 18,156,"        ",146,169
  1292  2228 0509092042415349...                 !text 5,9,9," BASIC 10.0   V0.9B.911119    ALL RIGHTS RESERVED",cr,0
  1293                          
  1294  225e 60                                  rts
  1295                          
  1296                          
  1297                          init_vectors
  1298  225f a217                                ldx #l4_3-l4_2-1
  1299  2261 bd6b22             l4_1             lda l4_2,x
  1300  2264 9dfa02                              sta vectors_begin,x
  1301  2267 ca                                  dex
  1302  2268 10f7                                bpl l4_1
  1303                          
  1304  226a 60                                  rts
  1305                          
  1306                          
  1307  226b c37d               l4_2             !word AutoScroll                         ; autoscroll vector
  1308  226d 8f2d                                !word n_esc_fn_vec                       ; escape function vector
  1309  226f cd7f                                !word graphic_kernel                     ; graphic extension vector
  1310  2271 522e0a2f2223be33...                 !word nerror,nmain,ncrnch,nqplop,ngone,neval ; traditional vectors
  1311  227d 32234e34c02c                        !word nesclk,nescpr,nescex               ; escape command vectors
  1312                          l4_3
  1313                          
  1314                          
  1315                          ;; CHRGET/CHRGOT code.  It is downloaded to RAM.
  1316                          ;;
  1317                          ;chrget_pattern
  1318                          ; inw txtptr ;CHRGET entry
  1319                          ; phz  ;CHRGOT entry (chrget+2)
  1320                          ; phx
  1321                          ; lda #0
  1322                          ; ldx #$f0
  1323                          ; ldy #0
  1324                          ; ldz #$f0
  1325                          ; map
  1326                          ; ldy #0
  1327                          ; lda (txtptr),y
  1328                          ; phy
  1329                          ; pha
  1330                          ; jsr _restore_sys
  1331                          ; nop  ;unmap
  1332                          ; pla
  1333                          ; ply
  1334                          ; plx
  1335                          ; plz
  1336                          ;
  1337                          ; cmp #':' ;QNUM entry (chrget+27)
  1338                          ; bcs l4_2
  1339                          ; cmp #' '
  1340                          ; beq chrget_pattern
  1341                          ; sec
  1342                          ; sbc #'0'
  1343                          ; sec
  1344                          ; sbc #$d0
  1345                          ;l4_2 rts  ;(42 bytes to here)
  1346                          ;
  1347                          ;
  1348                          ;
  1349                          ;; Constants which must be moved to RAM
  1350                          ;
  1351                          ; .byte   0,0,0 ;zero, of course!
  1352                          ;
  1353                          ;endmov   ;(45 bytes to here)
  1354                          
  1355                          
  1356                          ; CHRGET/CHRGOT code.
  1357                          ;
  1358                          
  1359  2283 e33d               chrget           inw txtptr                               ; get next character from text
  1360  2285 a000               chrgot           ldy #0                                   ; re-get current character from text
  1361  2287 20c522                              jsr indtxt                               ; lda (txtptr),y from RAM0
  1362  228a c920               qnum             cmp #' '
  1363  228c f0f5                                beq chrget                               ; skip spaces
  1364  228e c93a               chrtst           cmp #':'                                 ; [910513]
  1365  2290 b006                                bcs l5_1                                 ; eol
  1366  2292 38                                  sec
  1367  2293 e930                                sbc #'0'                                 ; alpha or numeric?
  1368  2295 38                                  sec
  1369  2296 e9d0                                sbc #$d0
  1370  2298 60                 l5_1             rts
  1371                          
  1372                          
  1373                          ;.end
  1374                          ;[[indirection]]
  1375                          
  1376                          ; C65 BASIC Indirect Load Subroutines
  1377                          
  1378                          
  1379                          inddef
  1380  2299 a950                                lda #defpnt
  1381  229b 803a                                bra lda_far_ram1
  1382                          
  1383                          indfrm
  1384  229d a93f                                lda #form
  1385  229f 8036                                bra lda_far_ram1
  1386                          
  1387                          inddpt
  1388  22a1 a952                                lda #dscpnt
  1389  22a3 8032                                bra lda_far_ram1
  1390                          
  1391                          ;indhtr
  1392                          ; lda #hightr
  1393                          ; bra lda_far_ram0
  1394                          
  1395                          indhtr_ram1
  1396  22a5 a95c                                lda #hightr
  1397  22a7 802e                                bra lda_far_ram1
  1398                          
  1399                          indfmo
  1400  22a9 a966                                lda #facmo
  1401  22ab 802a                                bra lda_far_ram1
  1402                          
  1403                          indlow
  1404  22ad a961                                lda #lowtr
  1405  22af 8016                                bra lda_far_ram0
  1406                          
  1407                          indst1
  1408  22b1 a970                                lda #strng1
  1409  22b3 8012                                bra lda_far_ram0
  1410                          
  1411                          indst1_ram1
  1412  22b5 a970                                lda #strng1
  1413  22b7 801e                                bra lda_far_ram1
  1414                          
  1415                          indgrb
  1416  22b9 a950                                lda #grbpnt
  1417  22bb 801a                                bra lda_far_ram1
  1418                          
  1419                          indlow_ram1
  1420  22bd a961                                lda #lowtr
  1421  22bf 8016                                bra lda_far_ram1
  1422                          
  1423                          indin1
  1424  22c1 a924                                lda #index1
  1425  22c3 8002                                bra lda_far_ram0
  1426                          
  1427                          ;indin2
  1428                          ; lda #index2
  1429                          ; bra lda_far_ram0
  1430                          
  1431                          indtxt
  1432  22c5 a93d                                lda #txtptr
  1433                          ; bra lda_far_ram0
  1434                          
  1435                          
  1436                          ; C65 BASIC Indirect Load Subroutines
  1437                          
  1438                          lda_far_ram0
  1439  22c7 db                                  phz                                      ; save registers
  1440  22c8 da                                  phx
  1441  22c9 aa                                  tax                                      ; pointer
  1442  22ca ab8400                              ldz text_bank                            ; RAM0
  1443  22cd 2074ff                              jsr _lda_far                             ; LDA (.x),Y from bank .z
  1444  22d0 fa                                  plx
  1445  22d1 fb                                  plz
  1446  22d2 29ff                                and #$ff                                 ; set processor status per byte fetched
  1447  22d4 60                                  rts
  1448                          
  1449                          
  1450                          
  1451                          indin1_ram1
  1452  22d5 a924                                lda #index1
  1453                          ; bra lda_far_ram1
  1454                          
  1455                          lda_far_ram1
  1456  22d7 08                                  php                                      ; save .c
  1457  22d8 db                                  phz                                      ; save registers
  1458  22d9 da                                  phx
  1459  22da aa                                  tax                                      ; pointer
  1460  22db ab8500                              ldz var_bank                             ; RAM1
  1461  22de b501                                lda 1,x                                  ; check to see if pointer points to "common"
  1462  22e0 c920                                cmp #$20
  1463  22e2 b003                                bcs l6_1                                 ; branch if not
  1464  22e4 ab8400                              ldz text_bank                            ; else select RAM0
  1465                          
  1466  22e7 2074ff             l6_1             jsr _lda_far                             ; LDA (.x),Y from bank .z
  1467  22ea fa                                  plx
  1468  22eb fb                                  plz
  1469  22ec 28                                  plp                                      ; restore .c
  1470  22ed 29ff                                and #$ff                                 ; set processor status per byte fetched
  1471  22ef 60                                  rts
  1472                          
  1473                          
  1474                          ; C65 BASIC Indirect Save Subroutines
  1475                          
  1476                          sta_far_ram1
  1477  22f0 08                                  php                                      ; save registers
  1478  22f1 db                                  phz
  1479  22f2 48                                  pha
  1480  22f3 ab8500                              ldz var_bank                             ; RAM1
  1481  22f6 b501                                lda 1,x                                  ; check to see if pointer points to "common"
  1482  22f8 c920                                cmp #$20
  1483  22fa b003                                bcs l7_1                                 ; branch if not
  1484  22fc ab8400                              ldz text_bank                            ; else select RAM0
  1485                          
  1486  22ff 68                 l7_1             pla
  1487  2300 2077ff                              jsr _sta_far                             ; STA (.x),Y to bank .z
  1488  2303 fb                                  plz
  1489  2304 28                                  plp
  1490  2305 60                                  rts
  1491                          
  1492                          
  1493                          sta_far_in1                                               ; [910624]
  1494  2306 a224                                ldx #index1
  1495  2308 8002                                bra sta_far_ram0
  1496                          
  1497                          sta_far_txt
  1498  230a a23d                                ldx #txtptr
  1499                          
  1500                          sta_far_ram0
  1501  230c 08                                  php                                      ; save registers
  1502  230d db                                  phz
  1503  230e ab8400                              ldz text_bank                            ; RAM0
  1504  2311 2077ff                              jsr _sta_far                             ; STA (.x),Y to bank .z
  1505  2314 fb                                  plz
  1506  2315 28                                  plp
  1507  2316 60                                  rts
  1508                          
  1509                          
  1510                          indcmp_in1                                                ; [910620]
  1511  2317 a224                                ldx #index1
  1512  2319 ab8400                              ldz text_bank                            ; RAM0
  1513  231c 4c7aff                              jmp _cmp_far                             ; STA (.x),Y to bank .z
  1514                          
  1515                          ;.end
  1516                          
  1517                          
  1518                          
  1519                          ;[[tokeniser]]
  1520                          ;        CRUNCH
  1521                          ;
  1522                          ;  Entry:  TXTPTR points to start of text to crunch
  1523                          ;  Exit:   TXTPTR points to start of crunched text
  1524                          ;
  1525                          ;  Calls:  CHRGET
  1526                          ;          CHRGOT
  1527                          ;          RESER
  1528                          ;          KLOOP
  1529                          ;          REM
  1530                          ;          DATA
  1531                          ;
  1532                          ;  CRUNCH collapses all reserved words into tokens.  It removes all graphic
  1533                          ;  characters (characters with msb set) not in quoted strings, DATA or REM
  1534                          ;  statements.
  1535                          ;
  1536                          ;  An escape token is implemented as follows:
  1537                          ;
  1538                          ; As each character on a line of text to be crunched is scanned, an
  1539                          ; indirect jump is performed.  Anyone wishing to scan for their own
  1540                          ; commands should grab off this vector, saving the return vector.
  1541                          ; On entry, if the carry flag is set, it is still up for grabs.
  1542                          ; The current text pointer is at TXTPTR.  If the escape routine
  1543                          ; recognizes the command, it should:
  1544                          ;
  1545                          ;  ) put the length of the reserved word in .y
  1546                          ;  ) put the desired 'second' token in .a
  1547                          ;  ) clear the carry flag
  1548                          ;  ) put type of token in x: 0==>command, ff==>function
  1549                          ;
  1550                          ; If it is not your command, leave .a and the carry flag intact.
  1551                          ; NOTE:  The reserved word must be >= 2 characters long.  Exit through
  1552                          ; the old vector (for daisy chaining).  If the carry flag is clear on
  1553                          ; entry it means someone else before you recognized this command.  In
  1554                          ; this case, just pass control through the old vector.
  1555                          
  1556                          
  1557  231f 6c0403             crunch           jmp (icrnch)
  1558                          
  1559                          
  1560  2322 fc3d00             ncrnch           phw txtptr                               ; save old text pointer
  1561                          
  1562  2325 208522             crun05           jsr chrgot
  1563  2328 8003                                bra crun20
  1564                          
  1565  232a 208322             crun10           jsr chrget
  1566                          
  1567                          
  1568  232d 90fb               crun20           bcc crun10                               ; don't crunch numbers
  1569  232f 6c0c03                              jmp (iesclk)                             ; give others a chance at this.  (carry is set)
  1570                          
  1571                          nesclk
  1572  2332 938e00                              +lbcc l8_12                              ; carry clear if someone wanted it
  1573  2335 c900                                cmp #0                                   ; end of line?
  1574  2337 f078                                beq l8_10                                ; yes
  1575  2339 c93a                                cmp #':'                                 ; multi-stmt char?
  1576  233b f0ed                                beq crun10                               ; yes
  1577  233d c93f                                cmp #'?'                                 ; print ('?') abreviation?
  1578  233f d004                                bne l8_1                                 ; no
  1579  2341 a999                                lda #print_token                         ; yes- substitute print token
  1580  2343 8050                                bra l8_8
  1581                          
  1582  2345 c980               l8_1             cmp #$80                                 ; graphics?
  1583  2347 900b                                bcc l8_2                                 ; no
  1584  2349 c9ff                                cmp #pi                                  ; pi? (special case)
  1585  234b f0dd                                beq crun10                               ; yes, leave alone
  1586  234d a001                                ldy #1
  1587  234f 20de23                              jsr kloop                                ; crunch out graphics
  1588  2352 80d1                                bra crun05
  1589                          
  1590                          
  1591  2354 c922               l8_2             cmp #'"'                                 ; quote string?
  1592  2356 d00d                                bne l8_4                                 ; no- try escape token
  1593                          
  1594  2358 208322             l8_3             jsr chrget
  1595  235b c900                                cmp #0                                   ; end of line?
  1596  235d f052                                beq l8_10                                ; yes
  1597  235f c922                                cmp #'"'                                 ; close quote?
  1598  2361 f0c7                                beq crun10                               ; yes
  1599  2363 80f3                                bra l8_3                                 ; no, continue skipping characters
  1600                          
  1601                          
  1602                          ; Crunch escape token
  1603                          
  1604  2365 a926               l8_4             lda #>esc_command_list                   ; look for token in escape-command list
  1605  2367 a029                                ldy #<esc_command_list
  1606  2369 20f423                              jsr reser
  1607  236c 9006                                bcc l8_5                                 ; not found
  1608  236e a981                                lda #first_esc_command_token+$80-1       ; set up for common escape routine
  1609  2370 a200                                ldx #0                                   ; ..flag 'cmd' type escape
  1610  2372 804c                                bra l8_11                                ; ..and go to it.
  1611                          
  1612  2374 a927               l8_5             lda #>esc_function_list                  ; look for token in escape-function list
  1613  2376 a09a                                ldy #<esc_function_list
  1614  2378 20f423                              jsr reser
  1615  237b 9006                                bcc l8_6                                 ; not found
  1616  237d a981                                lda #first_esc_function_token+$80-1      ; set up for common escape routine
  1617  237f a2ff                                ldx #$ff                                 ; ..flag 'function' type escape
  1618  2381 803d                                bra l8_11                                ; ..and go to it
  1619                          
  1620  2383 a924               l8_6             lda #>keyword_list                       ; look for token in normal list
  1621  2385 a03a                                ldy #<keyword_list
  1622  2387 20f423                              jsr reser
  1623  238a 909e                                bcc crun10                               ; not found
  1624  238c c000                                cpy #0                                   ; anything to move?
  1625  238e f003                                beq l8_7                                 ; no
  1626  2390 20de23                              jsr kloop                                ; crunch it out
  1627  2393 a50d               l8_7             lda count
  1628                          
  1629  2395 a000               l8_8             ldy #0
  1630  2397 200a23                              jsr sta_far_txt                          ; put token into text  (bleed-thru)
  1631  239a c98f                                cmp #rem_token
  1632  239c f00d                                beq l8_9
  1633  239e c983                                cmp #data_token
  1634  23a0 d088                                bne crun10
  1635  23a2 208322                              jsr chrget
  1636  23a5 204835                              jsr data
  1637  23a8 837bff                              +lbra crun05
  1638                          
  1639  23ab 208322             l8_9             jsr chrget
  1640  23ae 205635                              jsr rem
  1641                          
  1642                          
  1643                          ;  No other statements can follow a REM
  1644                          
  1645  23b1 a63d               l8_10            ldx txtptr
  1646  23b3 68                                  pla
  1647  23b4 853e                                sta txtptr+1
  1648  23b6 68                                  pla
  1649  23b7 853d                                sta txtptr
  1650  23b9 38                                  sec                                      ; compute length of line
  1651  23ba 8a                                  txa
  1652  23bb e53d                                sbc txtptr
  1653  23bd a8                                  tay
  1654  23be c8                                  iny
  1655  23bf 60                                  rts
  1656                          
  1657                          
  1658                          ; Crunch out old text, install an escape token
  1659                          
  1660  23c0 650d               l8_11            adc count                                ; make pointer into a token
  1661  23c2 48                 l8_12            pha                                      ; save second token
  1662  23c3 88                                  dey                                      ; waste (# of chars) - 1
  1663  23c4 20de23                              jsr kloop
  1664                          
  1665                          ; See if this is function (x=ff) or command (x=0)
  1666                          
  1667  23c7 a9fe                                lda #esc_command_token                   ; assume command
  1668  23c9 e8                                  inx
  1669  23ca d002                                bne l8_13                                ; branch if command
  1670  23cc a9ce                                lda #esc_function_token                  ; ..else get correct token
  1671                          
  1672  23ce a000               l8_13            ldy #0
  1673  23d0 200a23                              jsr sta_far_txt                          ; install escape token... (bleed-thru)
  1674  23d3 c8                                  iny
  1675  23d4 68                                  pla
  1676  23d5 200a23                              jsr sta_far_txt                          ; ..and second token  (bleed-thru)
  1677  23d8 208322                              jsr chrget                               ; skip over token,
  1678  23db 834dff                              +lbra crun10                             ; ..and continue with line.
  1679                          
  1680                          
  1681                          ;      KLOOP
  1682                          ;
  1683                          ;  Crunch loop.  Moves offset .y characters from txtptr to end of line.
  1684                          ;  .x is preserved
  1685                          
  1686  23de 18                 kloop            clc                                      ; compute source address
  1687  23df 98                                  tya
  1688  23e0 653d                                adc txtptr
  1689  23e2 8524                                sta index1
  1690  23e4 a53e                                lda txtptr+1
  1691  23e6 6900                                adc #0
  1692  23e8 8525                                sta index1+1
  1693  23ea a0ff                                ldy #$ff
  1694                          
  1695  23ec c8                 l9_1             iny
  1696  23ed b124                                lda (index1),y                           ; move source..  ????assumes text in common area
  1697  23ef 913d                                sta (txtptr),y                           ; to destination offset ????assumes text in common area
  1698  23f1 d0f9                                bne l9_1                                 ; not end of line
  1699  23f3 60                                  rts
  1700                          
  1701                          
  1702                          ;      RESER
  1703                          ;
  1704                          ;  Search reserved word list for a match
  1705                          ;
  1706                          ;  Entry:  (txtptr) is first char of word to match
  1707                          ;    (y,a) is start of table to check
  1708                          ;
  1709                          ;  Exit:   .y  length of word matched
  1710                          ;    .c  success/fail (set/clear) flag
  1711                          ;    count token value
  1712                          
  1713  23f4 8525               reser            sta index1+1
  1714  23f6 8424                                sty index1
  1715  23f8 a000                                ldy #0
  1716  23fa 840d                                sty count
  1717  23fc 88                                  dey
  1718  23fd c8                 l10_1            iny
  1719  23fe b13d               l10_2            lda (txtptr),y                           ; assumes common memory
  1720  2400 3029                                bmi l10_7                                ; abrieviation    [900510]
  1721  2402 38                                  sec
  1722  2403 f124                                sbc (index1),y                           ; does letter match? (ind.ok)
  1723  2405 f0f6                                beq l10_1                                ; yes...continue
  1724  2407 c980                                cmp #$80                                 ; end of word?
  1725  2409 f01b                                beq l10_6                                ; yes...c set...done
  1726                          
  1727                          
  1728                          ;  find next word
  1729                          
  1730  240b b124               l10_3            lda (index1),y                           ; ind.ok
  1731  240d 3003                                bmi l10_4                                ; found end of current
  1732  240f c8                                  iny
  1733  2410 d0f9                                bne l10_3
  1734  2412 c8                 l10_4            iny                                      ; start of next
  1735  2413 e60d                                inc count                                ; value of token
  1736  2415 18                                  clc
  1737  2416 98                                  tya
  1738  2417 6524                                adc index1
  1739  2419 8524                                sta index1
  1740  241b 9002                                bcc l10_5
  1741  241d e625                                inc index1+1
  1742  241f 18                 l10_5            clc
  1743  2420 a000                                ldy #0
  1744  2422 b124                                lda (index1),y                           ; end of list? ind.ok
  1745  2424 d0d8                                bne l10_2                                ; no
  1746                          
  1747                          
  1748                          ;  yes...carry clear...fail
  1749                          
  1750  2426 050d               l10_6            ora count                                ; .a=$80 if match
  1751  2428 850d                                sta count                                ; token is formed
  1752  242a 60                                  rts
  1753                          
  1754                          
  1755                          ; special case- last character is shifted (necessary for 'diR' compatibility)
  1756                          
  1757  242b 38                 l10_7            sec                                      ; allow last chr to be shifted   [900510]
  1758  242c f124                                sbc (index1),y                           ; does letter match? (ind.ok)
  1759  242e f006                                beq l10_8                                ; yes- end of word
  1760  2430 c980                                cmp #$80                                 ; end of word?
  1761  2432 f0f2                                beq l10_6                                ; yes
  1762  2434 d0d5                                bne l10_3                                ; no- next word
  1763                          
  1764  2436 a980               l10_8            lda #$80                                 ; last chr is shifted & so is end of current word
  1765  2438 80ec                                bra l10_6
  1766                          
  1767                          ;.end
  1768                          
  1769                          
  1770                          
  1771                          ;[[tokeniser.keywords]]
  1772                          
  1773                          keyword_list
  1774  243a 454ec4                              !text "EN",'D'+$80                       ; $80
  1775  243d 464fd2                              !text "FO",'R'+$80                       ; $81
  1776  2440 4e4558d4                            !text "NEX",'T'+$80                      ; $82
  1777  2444 444154c1                            !text "DAT",'A'+$80                      ; $83
  1778  2448 494e505554a3                        !text "INPUT",'#'+$80                    ; $84
  1779  244e 494e5055d4                          !text "INPU",'T'+$80                     ; $85
  1780  2453 4449cd                              !text "DI",'M'+$80                       ; $86
  1781  2456 524541c4                            !text "REA",'D'+$80                      ; $87
  1782  245a 4c45d4                              !text "LE",'T'+$80                       ; $88
  1783  245d 474f54cf                            !text "GOT",'O'+$80                      ; $89
  1784  2461 5255ce                              !text "RU",'N'+$80                       ; $8A
  1785  2464 49c6                                !text "I",'F'+$80                        ; $8B
  1786  2466 524553544f52c5                      !text "RESTOR",'E'+$80                   ; $8C
  1787  246d 474f5355c2                          !text "GOSU",'B'+$80                     ; $8D
  1788  2472 5245545552ce                        !text "RETUR",'N'+$80                    ; $8E
  1789  2478 5245cd                              !text "RE",'M'+$80                       ; $8F
  1790  247b 53544fd0                            !text "STO",'P'+$80                      ; $90
  1791  247f 4fce                                !text "O",'N'+$80                        ; $91
  1792  2481 574149d4                            !text "WAI",'T'+$80                      ; $92
  1793  2485 4c4f41c4                            !text "LOA",'D'+$80                      ; $93
  1794  2489 534156c5                            !text "SAV",'E'+$80                      ; $94
  1795  248d 5645524946d9                        !text "VERIF",'Y'+$80                    ; $95
  1796  2493 4445c6                              !text "DE",'F'+$80                       ; $96
  1797  2496 504f4bc5                            !text "POK",'E'+$80                      ; $97
  1798  249a 5052494e54a3                        !text "PRINT",'#'+$80                    ; $98
  1799  24a0 5052494ed4                          !text "PRIN",'T'+$80                     ; $99
  1800  24a5 434f4ed4                            !text "CON",'T'+$80                      ; $9A
  1801  24a9 4c4953d4                            !text "LIS",'T'+$80                      ; $9B
  1802  24ad 434cd2                              !text "CL",'R'+$80                       ; $9C
  1803  24b0 434dc4                              !text "CM",'D'+$80                       ; $9D
  1804  24b3 5359d3                              !text "SY",'S'+$80                       ; $9E
  1805  24b6 4f5045ce                            !text "OPE",'N'+$80                      ; $9F
  1806  24ba 434c4f53c5                          !text "CLOS",'E'+$80                     ; $A0
  1807  24bf 4745d4                              !text "GE",'T'+$80                       ; $A1
  1808  24c2 4e45d7                              !text "NE",'W'+$80                       ; $A2
  1809  24c5 544142a8                            !text "TAB",'('+$80                      ; $A3
  1810  24c9 54cf                                !text "T",'O'+$80                        ; $A4
  1811  24cb 46ce                                !text "F",'N'+$80                        ; $A5
  1812  24cd 535043a8                            !text "SPC",'('+$80                      ; $A6
  1813  24d1 544845ce                            !text "THE",'N'+$80                      ; $A7
  1814  24d5 4e4fd4                              !text "NO",'T'+$80                       ; $A8
  1815  24d8 535445d0                            !text "STE",'P'+$80                      ; $A9
  1816  24dc ab                                  !text '+'+$80                            ; $AA operators
  1817  24dd ad                                  !text '-'+$80                            ; $AB
  1818  24de aa                                  !text '*'+$80                            ; $AC
  1819  24df af                                  !text '/'+$80                            ; $AD
  1820  24e0 de                                  !text '^'+$80                            ; $AE
  1821  24e1 414ec4                              !text "AN",'D'+$80                       ; $AF
  1822  24e4 4fd2                                !text "O",'R'+$80                        ; $B0
  1823  24e6 be                                  !text '>'+$80                            ; $B1
  1824  24e7 bd                                  !text '='+$80                            ; $B2
  1825  24e8 bc                                  !text '<'+$80                            ; $B3
  1826  24e9 5347ce                              !text "SG",'N'+$80                       ; $B4 first numeric function
  1827  24ec 494ed4                              !text "IN",'T'+$80                       ; $B5
  1828  24ef 4142d3                              !text "AB",'S'+$80                       ; $B6
  1829  24f2 5553d2                              !text "US",'R'+$80                       ; $B7
  1830  24f5 4652c5                              !text "FR",'E'+$80                       ; $B8
  1831  24f8 504fd3                              !text "PO",'S'+$80                       ; $B9
  1832  24fb 5351d2                              !text "SQ",'R'+$80                       ; $BA
  1833  24fe 524ec4                              !text "RN",'D'+$80                       ; $BB
  1834  2501 4c4fc7                              !text "LO",'G'+$80                       ; $BC
  1835  2504 4558d0                              !text "EX",'P'+$80                       ; $BD
  1836  2507 434fd3                              !text "CO",'S'+$80                       ; $BE
  1837  250a 5349ce                              !text "SI",'N'+$80                       ; $BF
  1838  250d 5441ce                              !text "TA",'N'+$80                       ; $C0
  1839  2510 4154ce                              !text "AT",'N'+$80                       ; $C1
  1840  2513 504545cb                            !text "PEE",'K'+$80                      ; $C2
  1841  2517 4c45ce                              !text "LE",'N'+$80                       ; $C3
  1842  251a 535452a4                            !text "STR",'$'+$80                      ; $C4
  1843  251e 5641cc                              !text "VA",'L'+$80                       ; $C5
  1844  2521 4153c3                              !text "AS",'C'+$80                       ; $C6 last numeric function
  1845  2524 434852a4                            !text "CHR",'$'+$80                      ; $C7 last single-arg function
  1846  2528 4c454654a4                          !text "LEFT",'$'+$80                     ; $C8
  1847  252d 5249474854a4                        !text "RIGHT",'$'+$80                    ; $C9
  1848  2533 4d4944a4                            !text "MID",'$'+$80                      ; $CA
  1849  2537 47cf                                !text "G",'O'+$80                        ; $CB
  1850                          ; beginning of new C128 keywords------------
  1851  2539 52475241504849c3                    !text "RGRAPHI",'C'+$80                  ; $CC was 'rgr'   [910701]
  1852  2541 52434f4c4fd2                        !text "RCOLO",'R'+$80                    ; $CD was 'rclr'   [910701]
  1853  2547 80                                  !text $80                                ; $CE null to skip over escape_function token
  1854  2548 4a4fd9                              !text "JO",'Y'+$80                       ; $CF
  1855  254b 525045ce                            !text "RPE",'N'+$80                      ; $D0 (was rdot in c128)
  1856  254f 4445c3                              !text "DE",'C'+$80                       ; $D1
  1857  2552 484558a4                            !text "HEX",'$'+$80                      ; $D2
  1858  2556 455252a4                            !text "ERR",'$'+$80                      ; $D3
  1859  255a 494e5354d2                          !text "INST",'R'+$80                     ; $D4 last function
  1860                          
  1861  255f 454c53c5                            !text "ELS",'E'+$80                      ; $D5
  1862  2563 524553554dc5                        !text "RESUM",'E'+$80                    ; $D6
  1863  2569 545241d0                            !text "TRA",'P'+$80                      ; $D7
  1864  256d 54524fce                            !text "TRO",'N'+$80                      ; $D8
  1865  2571 54524f46c6                          !text "TROF",'F'+$80                     ; $D9
  1866  2576 534f554ec4                          !text "SOUN",'D'+$80                     ; $DA
  1867  257b 564fcc                              !text "VO",'L'+$80                       ; $DB
  1868  257e 415554cf                            !text "AUT",'O'+$80                      ; $DC
  1869  2582 50554445c6                          !text "PUDE",'F'+$80                     ; $DD
  1870  2587 475241504849c3                      !text "GRAPHI",'C'+$80                   ; $DE
  1871  258e 5041494ed4                          !text "PAIN",'T'+$80                     ; $DF
  1872  2593 434841d2                            !text "CHA",'R'+$80                      ; $E0
  1873  2597 424fd8                              !text "BO",'X'+$80                       ; $E1
  1874  259a 434952434cc5                        !text "CIRCL",'E'+$80                    ; $E2
  1875  25a0 50415354c5                          !text "PAST",'E'+$80                     ; $E3 (was gshape in C128)
  1876  25a5 4355d4                              !text "CU",'T'+$80                       ; $E4 (was sshape in C128)
  1877  25a8 4c494ec5                            !text "LIN",'E'+$80                      ; $E5 (was draw in C128)
  1878  25ac 4c4f434154c5                        !text "LOCAT",'E'+$80                    ; $E6
  1879  25b2 434f4c4fd2                          !text "COLO",'R'+$80                     ; $E7
  1880  25b7 53434e434cd2                        !text "SCNCL",'R'+$80                    ; $E8
  1881  25bd 5343414cc5                          !text "SCAL",'E'+$80                     ; $E9
  1882  25c2 48454cd0                            !text "HEL",'P'+$80                      ; $EA
  1883  25c6 44cf                                !text "D",'O'+$80                        ; $EB
  1884  25c8 4c4f4fd0                            !text "LOO",'P'+$80                      ; $EC
  1885  25cc 455849d4                            !text "EXI",'T'+$80                      ; $ED
  1886  25d0 4449d2                              !text "DI",'R'+$80                       ; $EE
  1887  25d3 44534156c5                          !text "DSAV",'E'+$80                     ; $EF
  1888  25d8 444c4f41c4                          !text "DLOA",'D'+$80                     ; $F0
  1889  25dd 4845414445d2                        !text "HEADE",'R'+$80                    ; $F1
  1890  25e3 534352415443c8                      !text "SCRATC",'H'+$80                   ; $F2
  1891  25ea 434f4c4c4543d4                      !text "COLLEC",'T'+$80                   ; $F3
  1892  25f1 434f50d9                            !text "COP",'Y'+$80                      ; $F4
  1893  25f5 52454e414dc5                        !text "RENAM",'E'+$80                    ; $F5
  1894  25fb 4241434b55d0                        !text "BACKU",'P'+$80                    ; $F6
  1895  2601 44454c4554c5                        !text "DELET",'E'+$80                    ; $F7
  1896  2607 52454e554d4245d2                    !text "RENUMBE",'R'+$80                  ; $F8
  1897  260f 4b45d9                              !text "KE",'Y'+$80                       ; $F9
  1898  2612 4d4f4e49544fd2                      !text "MONITO",'R'+$80                   ; $FA
  1899  2619 5553494ec7                          !text "USIN",'G'+$80                     ; $FB
  1900  261e 554e5449cc                          !text "UNTI",'L'+$80                     ; $FC
  1901  2623 5748494cc5                          !text "WHIL",'E'+$80                     ; $FD
  1902  2628 00                                  !text 0                                  ; $FE skip over the escape_command token
  1903                          
  1904                          ;.end
  1905                          
  1906                          
  1907                          
  1908                          
  1909                          ;[[tokeniser.keyword.esc]]
  1910                          ; Escape Command Tokens
  1911                          
  1912                          esc_command_list
  1913  2629 42414ecb                            !text "BAN",'K'+$80                      ; $02: set bank number
  1914  262d 46494c5445d2                        !text "FILTE",'R'+$80                    ; $03: set up filter
  1915  2633 504c41d9                            !text "PLA",'Y'+$80                      ; $04: play a tune
  1916  2637 54454d50cf                          !text "TEMP",'O'+$80                     ; $05: set rate for playing
  1917  263c 4d4f565350d2                        !text "MOVSP",'R'+$80                    ; $06: sprite position/movement
  1918  2642 5350524954c5                        !text "SPRIT",'E'+$80                    ; $07: turn on/set up sprite
  1919  2648 535052434f4c4fd2                    !text "SPRCOLO",'R'+$80                  ; $08: set sprite multicolor registers
  1920  2650 525245c7                            !text "RRE",'G'+$80                      ; $09: retreive register values after 'SYS'
  1921  2654 454e56454c4f50c5                    !text "ENVELOP",'E'+$80                  ; $0A: set up SID envelopes
  1922  265c 534c4545d0                          !text "SLEE",'P'+$80                     ; $0B: delay
  1923  2661 434154414c4fc7                      !text "CATALO",'G'+$80                   ; $0C: disk directory
  1924  2668 444f5045ce                          !text "DOPE",'N'+$80                     ; $0D: open a disk file
  1925  266d 415050454ec4                        !text "APPEN",'D'+$80                    ; $0E: open a disk file for appending
  1926  2673 44434c4f53c5                        !text "DCLOS",'E'+$80                    ; $0F: close a file opened w/ DOPEN
  1927  2679 42534156c5                          !text "BSAV",'E'+$80                     ; $10: binary (non-program) save
  1928  267e 424c4f41c4                          !text "BLOA",'D'+$80                     ; $11: binary load
  1929  2683 5245434f52c4                        !text "RECOR",'D'+$80                    ; $12:
  1930  2689 434f4e4341d4                        !text "CONCA",'T'+$80                    ; $13: concatenate 2 files
  1931  268f 445645524946d9                      !text "DVERIF",'Y'+$80                   ; $14: verify a saved program
  1932  2696 44434c4541d2                        !text "DCLEA",'R'+$80                    ; $15: re-initialize a drive
  1933  269c 5350525341d6                        !text "SPRSA",'V'+$80                    ; $16: sprite/string to sprite/string
  1934  26a2 434f4c4c4953494f...                 !text "COLLISIO",'N'+$80                 ; $17: set traps for sprite & light pen collisions
  1935  26ab 42454749ce                          !text "BEGI",'N'+$80                     ; $18: mark start of a b-block
  1936  26b0 42454ec4                            !text "BEN",'D'+$80                      ; $19: ..and its end, too!
  1937  26b4 57494e444fd7                        !text "WINDO",'W'+$80                    ; $1A: set screen window
  1938  26ba 424f4fd4                            !text "BOO",'T'+$80                      ; $1B: load&run ML or autoboot a disk
  1939  26be 57494454c8                          !text "WIDT",'H'+$80                     ; $1C: single/double width drawing
  1940  26c3 5350524445c6                        !text "SPRDE",'F'+$80                    ; $1D: define a sprite
  1941  26c9 515549d4                            !text "QUI",'T'+$80                      ; $1E: (UNIMPLEMENTED)
  1942  26cd 444dc1                              !text "DM",'A'+$80                       ; $1F: access memory
  1943  26d0 a0                                  !text ' '+$80                            ; $20: POISON - space character
  1944  26d1 444dc1                              !text "DM",'A'+$80                       ; $21: access memory
  1945  26d4 a0                                  !text ' '+$80                            ; $22: POISON - quote character
  1946  26d5 444dc1                              !text "DM",'A'+$80                       ; $23: access memory
  1947  26d8 4f46c6                              !text "OF",'F'+$80                       ; $24: KEY OFF
  1948  26db 464153d4                            !text "FAS",'T'+$80                      ; $25: go to 2 MHz. mode
  1949  26df 534c4fd7                            !text "SLO",'W'+$80                      ; $26: go to 1 MHz. mode
  1950  26e3 545950c5                            !text "TYP",'E'+$80                      ; $27: type SEQ file
  1951  26e7 425645524946d9                      !text "BVERIF",'Y'+$80                   ; $28: verify a saved program
  1952  26ee 4543544f52d9                        !text "ECTOR",'Y'+$80                    ; $29: dirECTORY
  1953  26f4 45524153c5                          !text "ERAS",'E'+$80                     ; $2A: alias for scratch
  1954  26f9 46494ec4                            !text "FIN",'D'+$80                      ; $2B: find string
  1955  26fd 4348414e47c5                        !text "CHANG",'E'+$80                    ; $2C: change string
  1956  2703 5345d4                              !text "SE",'T'+$80                       ; $2D:
  1957  2706 5343524545ce                        !text "SCREE",'N'+$80                    ; $2E:
  1958  270c 504f4c59474fce                      !text "POLYGO",'N'+$80                   ; $2F:
  1959  2713 454c4c495053c5                      !text "ELLIPS",'E'+$80                   ; $30:
  1960  271a 56494557504f52d4                    !text "VIEWPOR",'T'+$80                  ; $31:
  1961  2722 47434f50d9                          !text "GCOP",'Y'+$80                     ; $32:
  1962  2727 5045ce                              !text "PE",'N'+$80                       ; $33:
  1963  272a 50414c455454c5                      !text "PALETT",'E'+$80                   ; $34:
  1964  2731 444d4f44c5                          !text "DMOD",'E'+$80                     ; $35:
  1965  2736 445041d4                            !text "DPA",'T'+$80                      ; $36:
  1966  273a 464f524d41d4                        !text "FORMA",'T'+$80                    ; $37: alias for HEADER command  [911017]
  1967  2740 47454e4c4f43cb                      !text "GENLOC",'K'+$80                   ; $38:     [910108]
  1968  2747 464f524547524f55...                 !text "FOREGROUN",'D'+$80                ; $39:     [910109]
  1969  2751 a0                                  !text ' '+$80                            ; $3A: POISON - colon character  "
  1970  2752 4241434b47524f55...                 !text "BACKGROUN",'D'+$80                ; $3B:     "
  1971  275c 424f524445d2                        !text "BORDE",'R'+$80                    ; $3C:     "
  1972  2762 484947484c494748...                 !text "HIGHLIGH",'T'+$80                 ; $3D:     "
  1973  276b 4d4f5553c5                          !text "MOUS",'E'+$80                     ; $3E:     [910122]
  1974  2770 524d4f5553c5                        !text "RMOUS",'E'+$80                    ; $3F: return coordinates of mouse [910123]
  1975  2776 444953cb                            !text "DIS",'K'+$80                      ; $40:     [910123]
  1976  277a 435552534fd2                        !text "CURSO",'R'+$80                    ; $41:     [910228]
  1977  2780 52435552534fd2                      !text "RCURSO",'R'+$80                   ; $42: return cursor position  [910228]
  1978  2787 4c4f41444946c6                      !text "LOADIF",'F'+$80                   ; $43: load IFF picture from disk [910402]
  1979  278e 534156454946c6                      !text "SAVEIF",'F'+$80                   ; $44: save IFF picture to   disk [910402]
  1980  2795 454449d4                            !text "EDI",'T'+$80                      ; $45: Edit mode on/off   [910620]
  1981                          
  1982  2799 00                                  !text 0                                  ; End marker
  1983                          ;(don't forget to change last_command_token!)
  1984                          
  1985                          ; Escape Function Tokens
  1986                          
  1987                          esc_function_list
  1988  279a 504fd4                              !text "PO",'T'+$80                       ; $02: return paddle value
  1989  279d 42554dd0                            !text "BUM",'P'+$80                      ; $03: read sprite collision
  1990  27a1 4c5045ce                            !text "LPE",'N'+$80                      ; $04: read light pen value
  1991  27a5 525350504fd3                        !text "RSPPO",'S'+$80                    ; $05: read sprite position
  1992  27ab 525350524954c5                      !text "RSPRIT",'E'+$80                   ; $06: read sprite value
  1993  27b2 525350434f4c4fd2                    !text "RSPCOLO",'R'+$80                  ; $07: read sprite multicolor value
  1994  27ba 584fd2                              !text "XO",'R'+$80                       ; $08: exclusive or
  1995  27bd 5257494e444fd7                      !text "RWINDO",'W'+$80                   ; $09: read window size
  1996  27c4 504f494e5445d2                      !text "POINTE",'R'+$80                   ; $0a: return address of descriptor
  1997  27cb 4d4fc4                              !text "MO",'D'+$80                       ; $0b: modulus    [910402]
  1998  27ce 50495845cc                          !text "PIXE",'L'+$80                     ; $0c: return BP data at pixel  [910820]
  1999  27d3 5250414c455454c5                    !text "RPALETT",'E'+$80                  ; $0d: return RGB component of color [910820]
  2000  27db 00                                  !text 0
  2001                          
  2002                          ;.end
  2003                          ;[[tokeniser.vectors]]
  2004                          
  2005                          
  2006                          stmdsp
  2007  27dc dc2c                                !word end-1
  2008  27de 5c41                                !word for-1
  2009  27e0 743a                                !word next-1
  2010  27e2 4735                                !word data-1
  2011  27e4 a138                                !word inputn-1
  2012  27e6 bf38                                !word input-1
  2013  27e8 f33a                                !word dim-1
  2014  27ea 0f39                                !word read-1
  2015  27ec 7536                                !word let-1
  2016  27ee fa3c                                !word goto-1
  2017  27f0 b33d                                !word run-1
  2018  27f2 7d35                                !word if-1
  2019  27f4 e63d                                !word restor-1
  2020  27f6 eb3c                                !word gosub-1
  2021  27f8 2c35                                !word return-1
  2022  27fa 5535                                !word rem-1
  2023  27fc da2c                                !word stop-1
  2024  27fe 5436                                !word ongoto-1
  2025  2800 e654                                !word wait-1
  2026  2802 8968                                !word load-1
  2027  2804 6168                                !word save-1
  2028  2806 8668                                !word verify-1
  2029  2808 f458                                !word def-1
  2030  280a ed55                                !word poke-1
  2031  280c a737                                !word printn-1
  2032  280e c837                                !word print-1
  2033  2810 793d                                !word cont-1
  2034  2812 8932                                !word list-1
  2035  2814 a534                                !word clear-1
  2036  2816 ad37                                !word cmd-1
  2037  2818 fd3a                                !word sys-1
  2038  281a 0069                                !word open-1
  2039  281c 0869                                !word close-1
  2040  281e 6638                                !word get-1
  2041  2820 5434                                !word new-1
  2042                          
  2043  2822 4236                                !word else-1
  2044  2824 6744                                !word resume-1
  2045  2826 5544                                !word trap-1
  2046  2828 993b                                !word tron-1
  2047  282a 9c3b                                !word troff-1
  2048  282c 7c4b                                !word sound-1
  2049  282e 454b                                !word volume-1
  2050  2830 593c                                !word auto-1
  2051  2832 4144                                !word puctrl-1
  2052  2834 bf7f                                !word graphic-1
  2053                          
  2054  2836 5ab3                                !word C65__paint-1
  2055  2838 efb2                                !word C65__char-1
  2056  283a 06b1                                !word C65__box-1
  2057  283c 5ab1                                !word C65__circle-1
  2058  283e 4fb4                                !word C65__paste-1                       ; gshape
  2059  2840 4fb4                                !word C65__cut-1                         ; sshape
  2060  2842 b1b0                                !word C65__line-1                        ; draw
  2061                          
  2062  2844 3a2e                                !word bad_command-1                      ; escape - SYSTEM - unimplemented command
  2063                          ; .word  locate-1
  2064                          
  2065  2846 99b4                                !word color-1
  2066  2848 34af                                !word scnclr-1
  2067                          
  2068  284a 3a2e                                !word bad_command-1                      ; escape - SYSTEM - unimplemented command
  2069                          ; .word  scale-1
  2070                          
  2071  284c 683c                                !word help-1
  2072  284e ec44                                !word do-1
  2073  2850 8e45                                !word loop-1
  2074  2852 4145                                !word exit-1
  2075  2854 9f6f                                !word directory-1
  2076  2856 4671                                !word dsave-1
  2077  2858 6871                                !word dload-1
  2078  285a 4a72                                !word header-1
  2079  285c d372                                !word scratch-1
  2080  285e 6473                                !word collect-1
  2081  2860 7b73                                !word dcopy-1
  2082  2862 c773                                !word rename-1
  2083  2864 d973                                !word backup-1
  2084  2866 e741                                !word delete-1
  2085  2868 123e                                !word renumber-1
  2086  286a d445                                !word key-1
  2087  286c 55ff                                !word _monitor-1
  2088  286e 4647                                !word bank-1                             ; escape
  2089  2870 154a                                !word filter-1                           ; escape
  2090  2872 4d47                                !word play-1                             ; escape
  2091  2874 8449                                !word tempo-1                            ; escape
  2092                          
  2093  2876 bfb5                                !word movspr-1                           ; escape
  2094  2878 28b5                                !word sprite-1                           ; escape
  2095  287a 05b8                                !word sprcolor-1                         ; escape
  2096                          
  2097  287c 9f3b                                !word rreg-1                             ; escape
  2098  287e a34a                                !word envelope-1                         ; escape
  2099  2880 c054                                !word sleep-1                            ; escape
  2100  2882 9f6f                                !word directory-1                        ; escape
  2101  2884 d170                                !word dopen-1                            ; escape
  2102  2886 e770                                !word append-1                           ; escape
  2103  2888 2f71                                !word dclose-1                           ; escape
  2104  288a 9071                                !word bsave-1                            ; escape
  2105  288c e171                                !word bload-1                            ; escape
  2106  288e 0a73                                !word record-1                           ; escape
  2107  2890 b773                                !word concat-1                           ; escape
  2108  2892 6571                                !word dverify-1                          ; escape
  2109  2894 5473                                !word dclear-1                           ; escape
  2110                          
  2111  2896 1bb8                                !word sprsav-1                           ; escape
  2112  2898 dbb8                                !word collision-1                        ; escape
  2113                          
  2114  289a 4735                                !word data-1                             ; escape - BEGIN
  2115  289c 4735                                !word data-1                             ; escape - BEND
  2116  289e 5f4c                                !word window-1                           ; escape
  2117  28a0 4e67                                !word boot-1                             ; escape
  2118                          
  2119  28a2 3a2e                                !word bad_command-1
  2120                          ; .word  set_width-1 ;escape - WIDTH
  2121                          
  2122  28a4 3a2e                                !word bad_command-1
  2123                          ; .word  sprdef-1  ;escape - Sprite Definition mode
  2124                          
  2125  28a6 3a2e                                !word bad_command-1                      ; escape - QUIT - unimplemented command
  2126  28a8 333b                                !word dma-1                              ; escape
  2127  28aa 0000                                !word 0                                  ; placeholder to skip over the space character
  2128  28ac 333b                                !word dma-1                              ; escape
  2129  28ae 0000                                !word 0                                  ; placeholder to skip over the quote character
  2130  28b0 333b                                !word dma-1                              ; escape
  2131  28b2 3a2e                                !word bad_command-1                      ; escape - OFF - unimplemented command
  2132  28b4 c54c                                !word fast-1                             ; escape
  2133  28b6 ce4c                                !word slow-1                             ; escape
  2134  28b8 166f                                !word type-1                             ; escape (C65: type SEQ file)
  2135  28ba de71                                !word bverify-1                          ; escape (C65: verify BINary file)
  2136  28bc 492e                                !word snerr-1                            ; escape (C65: kludge- dirECTORY)
  2137  28be d372                                !word scratch-1                          ; escape (C65: erase alias for scratch)
  2138  28c0 8842                                !word find-1                             ; escape (C65: find BASIC text)
  2139  28c2 8b42                                !word change-1                           ; escape (C65: change BASIC text)
  2140                          
  2141  28c4 1ab2                                !word C65__set-1                         ; escape (C65: multi-purpose command)
  2142  28c6 ffae                                !word Screen-1                           ; escape (C65: SCREEN)
  2143  28c8 bbb1                                !word C65__polygon-1                     ; escape (C65: POLYGON)
  2144  28ca 86b1                                !word C65__ellipse-1                     ; escape (C65: ELLIPSE)
  2145  28cc 14b4                                !word C65__Viewport-1                    ; escape (C65: VIEWPORT)
  2146  28ce 4fb4                                !word C65__copy-1                        ; escape (C65: GCOPY)
  2147  28d0 b7af                                !word C65__setpen-1                      ; escape (C65: PEN)
  2148  28d2 45b0                                !word C65__setpalette-1                  ; escape (C65: PALETTE)
  2149  28d4 cbaf                                !word C65__setdmode-1                    ; escape (C65: DMODE)
  2150  28d6 01b0                                !word C65__setdpat-1                     ; escape (C65: DPAT)
  2151  28d8 4a72                                !word header-1                           ; format alias for header command [911017]
  2152  28da 52b4                                !word genlock-1                          ; [910108]
  2153                          
  2154                          stmdsp2
  2155  28dc dab4                                !word foreground-1                       ; this is the 128th command!  [910109]
  2156  28de 0000                                !word 0                                  ; placeholder to skip over the colon character
  2157  28e0 fbb4                                !word background-1
  2158  28e2 02b5                                !word border-1
  2159  28e4 e0b4                                !word highlight-1
  2160  28e6 ef7b                                !word mouse-1                            ; [910122]
  2161  28e8 8c7c                                !word rmouse-1                           ; [910123]
  2162  28ea 796f                                !word disk-1                             ; [910123]
  2163  28ec 277d                                !word cursor-1                           ; [910228]
  2164  28ee 807d                                !word rcursor-1                          ; [910228]
  2165  28f0 aeb3                                !word loadiff-1                          ; [910402]
  2166  28f2 eab3                                !word saveiff-1                          ; [910930]
  2167  28f4 c6bc                                !word edit-1                             ; [910620]
  2168                          
  2169                          
  2170                          fundsp
  2171  28f6 cf62                                !word sgn
  2172  28f8 6363                                !word int
  2173  28fa ee62                                !word abs
  2174  28fc f702                                !word usrpok
  2175  28fe 1355                                !word fre
  2176  2900 ce58                                !word pos
  2177  2902 bc65                                !word sqr
  2178  2904 2358                                !word rnd
  2179  2906 0e60                                !word log
  2180  2908 0766                                !word exp
  2181  290a 9e66                                !word cos
  2182  290c a566                                !word sin
  2183  290e ee66                                !word tan
  2184  2910 1f67                                !word atn
  2185  2912 c755                                !word peek
  2186  2914 565a                                !word len
  2187  2916 a559                                !word strd
  2188  2918 4655                                !word val
  2189  291a 655a                                !word asc
  2190  291c b659                                !word chrd
  2191  291e cc59                                !word leftd
  2192  2920 ff59                                !word rightd
  2193  2922 105a                                !word midd
  2194  2924 26b9                                !word rgraphic                           ; [910701]
  2195  2926 ffb8                                !word rcolor                             ; [910701]
  2196  2928 0000                                !word 0                                  ; placeholder for escape function token
  2197  292a ae56                                !word joy
  2198  292c 9bb9                                !word rpen                               ; was rdot     [910820]
  2199  292e 7855                                !word dcml                               ; dec
  2200  2930 6f56                                !word hexd
  2201  2932 1856                                !word errd
  2202  2934 f356                                !word pot                                ; escape
  2203  2936 9cba                                !word bump                               ; escape
  2204  2938 5257                                !word lpen                               ; escape
  2205  293a 5aba                                !word rsppos                             ; escape
  2206  293c 0fba                                !word rsprite                            ; escape
  2207  293e 45ba                                !word rspcolor                           ; escape
  2208  2940 9557                                !word xor                                ; escape
  2209  2942 fa57                                !word rwindow                            ; escape
  2210  2944 7457                                !word pointer                            ; escape
  2211  2946 b757                                !word mod                                ; escape c65     [910402]
  2212  2948 76b9                                !word pixel                              ; escape c65     [910820]
  2213  294a b8b9                                !word rpalette                           ; escape c65     [910820]
  2214                          
  2215                          
  2216  294c 79                 optab            !text 121
  2217  294d bd5d                                !word faddt-1
  2218  294f 79                                  !text 121
  2219  2950 a75d                                !word fsubt-1
  2220  2952 7b                                  !text 123
  2221  2953 6f60                                !word fmultt-1
  2222  2955 7b                                  !text 123
  2223  2956 8461                                !word fdivt-1
  2224  2958 7f                                  !text 127
  2225  2959 c565                                !word fpwrt-1
  2226  295b 50                                  !text 80
  2227  295c 9a2d                                !word andop-1
  2228  295e 46                                  !text 70
  2229  295f 972d                                !word orop-1
  2230  2961 7d                 negtab           !text 125
  2231  2962 fb65                                !word negop-1
  2232  2964 5a                                  !text 90
  2233  2965 324e                                !word notop-1
  2234  2967 64                 ptdorl           !text 100
  2235  2968 c72d                                !word dorel-1
  2236                          
  2237                          ;.end
  2238                          
  2239                          ;[[tokeniser.const]]
  2240                          
  2241                          
  2242                          end_token        = $80                                    ; v2 commands
  2243                          for_token        = $81
  2244                          next_token       = $82
  2245                          data_token       = $83
  2246                          input_token      = $84
  2247                          goto_token       = $89
  2248                          run_token        = $8a
  2249                          restore_token    = $8c
  2250                          gosub_token      = $8d
  2251                          rem_token        = $8f
  2252                          on_token         = $91
  2253                          load_token       = $93
  2254                          save_token       = $94
  2255                          verify_token     = $95
  2256                          def_token        = $96
  2257                          print_token      = $99
  2258                          clr_token        = $9c
  2259                          sys_token        = $9e
  2260                          open_token       = $9f
  2261                          close_token      = $a0
  2262                          new_token        = $a2
  2263                          tab_token        = $a3
  2264                          to_token         = $a4
  2265                          fn_token         = $a5
  2266                          spc_token        = $a6
  2267                          then_token       = $a7
  2268                          not_token        = $a8
  2269                          step_token       = $a9
  2270                          plus_token       = $aa                                    ; operators
  2271                          minus_token      = $ab
  2272                          greater_token    = $b1
  2273                          equal_token      = $b2
  2274                          less_token       = $b3
  2275                          first_function_token = $b4                                    ; v2 functions
  2276                          left_token       = $c8
  2277                          mid_token        = $ca
  2278                          go_token         = $cb                                    ; kludges
  2279                          rgraphic_token   = $cc                                    ; first new v7 token
  2280                          esc_function_token = $ce
  2281                          err_token        = $d3
  2282                          instr_token      = $d4
  2283                          last_function_token = $d4
  2284                          else_token       = $d5
  2285                          resume_token     = $d6
  2286                          trap_token       = $d7
  2287                          color_token      = $e7
  2288                          do_token         = $eb
  2289                          loop_token       = $ec
  2290                          key_token        = $f9
  2291                          monitor_token    = $fa
  2292                          using_token      = $fb
  2293                          until_token      = $fc
  2294                          while_token      = $fd
  2295                          esc_command_token = $fe
  2296                          
  2297                          first_esc_command_token = $02
  2298                          collision_token  = $17
  2299                          begin_token      = $18
  2300                          bend_token       = $19
  2301                          off_token        = $24
  2302                          ectory_token     = $29
  2303                          set_token        = $2d
  2304                          pic_token        = $37
  2305                          disk_token       = $40
  2306                          last_esc_command_token = $45                                    ; <<<< last_command_token
  2307                          
  2308                          first_esc_function_token = $02
  2309                          pointer_token    = $0a
  2310                          last_esc_function_token = $0d                                    ; [910820]
  2311                          
  2312                          
  2313                          ;[[errors]]
  2314                          
  2315                          
  2316                          ok_error_message
  2317  296a 4fcb                                !text "O",'K'+$80                        ; 0 for ERR$ [910911]
  2318                          error_message_list
  2319  296c 544f4f204d414e59...                 !text "TOO MANY FILE",'S'+$80            ; 1
  2320  297a 46494c45204f5045...                 !text "FILE OPE",'N'+$80                 ; 2
  2321  2983 46494c45204e4f54...                 !text "FILE NOT OPE",'N'+$80             ; 3
  2322  2990 46494c45204e4f54...                 !text "FILE NOT FOUN",'D'+$80            ; 4
  2323  299e 444556494345204e...                 !text "DEVICE NOT PRESEN",'T'+$80        ; 5
  2324  29b0 4e4f5420494e5055...                 !text "NOT INPUT FIL",'E'+$80            ; 6
  2325  29be 4e4f54204f555450...                 !text "NOT OUTPUT FIL",'E'+$80           ; 7
  2326  29cd 4d495353494e4720...                 !text "MISSING FILE NAM",'E'+$80         ; 8
  2327  29de 494c4c4547414c20...                 !text "ILLEGAL DEVICE NUMBE",'R'+$80     ; 9
  2328  29f3 4e45585420574954...                 !text "NEXT WITHOUT FO",'R'+$80          ; 10
  2329  2a03 53594e5441d8                        !text "SYNTA",'X'+$80                    ; 11
  2330  2a09 52455455524e2057...                 !text "RETURN WITHOUT GOSU",'B'+$80      ; 12
  2331  2a1d 4f5554204f462044...                 !text "OUT OF DAT",'A'+$80               ; 13
  2332  2a28 494c4c4547414c20...                 !text "ILLEGAL QUANTIT",'Y'+$80          ; 14
  2333  2a38 4f564552464c4fd7                    !text "OVERFLO",'W'+$80                  ; 15
  2334  2a40 4f5554204f46204d...                 !text "OUT OF MEMOR",'Y'+$80             ; 16
  2335  2a4d 554e444546274420...                 !text "UNDEF",$27,"D STATEMEN",'T'+$80   ; 17
  2336  2a5e 4241442053554253...                 !text "BAD SUBSCRIP",'T'+$80             ; 18
  2337  2a6b 524544494d274420...                 !text "REDIM",$27,"D ARRA",'Y'+$80       ; 19
  2338  2a78 4449564953494f4e...                 !text "DIVISION BY ZER",'O'+$80          ; 20
  2339  2a88 494c4c4547414c20...                 !text "ILLEGAL DIREC",'T'+$80            ; 21
  2340  2a96 54595045204d4953...                 !text "TYPE MISMATC",'H'+$80             ; 22
  2341  2aa3 535452494e472054...                 !text "STRING TOO LON",'G'+$80           ; 23
  2342  2ab2 46494c4520444154...                 !text "FILE DAT",'A'+$80                 ; 24
  2343  2abb 464f524d554c4120...                 !text "FORMULA TOO COMPLE",'X'+$80       ; 25
  2344  2ace 43414e275420434f...                 !text "CAN",$27,"T CONTINU",'E'+$80      ; 26
  2345  2adc 554e444546274420...                 !text "UNDEF'D FUNCTIO",'N'+$80          ; 27
  2346  2aec 5645524946d9                        !text "VERIF",'Y'+$80                    ; 28
  2347  2af2 4c4f41c4                            !text "LOA",'D'+$80                      ; 29
  2348  2af6 42524541cb                          !text "BREA",'K'+$80                     ; 30 ???? null & space [910925]
  2349  2afb 43414e2754205245...                 !text "CAN'T RESUM",'E'+$80              ; 31
  2350  2b07 4c4f4f50204e4f54...                 !text "LOOP NOT FOUN",'D'+$80            ; 32
  2351  2b15 4c4f4f5020574954...                 !text "LOOP WITHOUT D",'O'+$80           ; 33
  2352  2b24 444952454354204d...                 !text "DIRECT MODE ONL",'Y'+$80          ; 34
  2353                          ; .byte 'NO GRAPHICS ARE','A'+$80   ;35
  2354  2b34 53435245454e204e...                 !text "SCREEN NOT OPE",'N'+$80           ; 35    [911001]
  2355  2b43 42414420444953cb                    !text "BAD DIS",'K'+$80                  ; 36 ???? used for failed bootsys
  2356  2b4b 42454e44204e4f54...                 !text "BEND NOT FOUN",'D'+$80            ; 37
  2357  2b59 4c494e45204e554d...                 !text "LINE NUMBER TOO LARG",'E'+$80     ; 38
  2358  2b6e 554e5245534f4c56...                 !text "UNRESOLVED REFERENC",'E'+$80      ; 39
  2359  2b82 554e494d504c454d...                 !text "UNIMPLEMENTED COMMAN",'D'+$80     ; 40
  2360  2b97 46494c4520524541...                 !text "FILE REA",'D'+$80                 ; 41
  2361  2ba0 45444954204d4f44...                 !text "EDIT MOD",'E'+$80                 ; 42    [910620]
  2362                          
  2363                          
  2364                          
  2365                          ;[[errors/constants]]
  2366                          
  2367                          errtmf           = 1
  2368                          errfno           = 3
  2369                          errfnf           = 4
  2370                          err_missing_fname = 8
  2371                          err_illegal_device = 9
  2372                          errnf            = 10
  2373                          errsn            = 11
  2374                          errrg            = 12
  2375                          errod            = 13
  2376                          errfc            = 14
  2377                          errov            = 15
  2378                          errom            = 16
  2379                          errus            = 17
  2380                          errbs            = 18
  2381                          errdd            = 19
  2382                          errdvo           = 20
  2383                          errid            = 21
  2384                          errtm            = 22
  2385                          errls            = 23
  2386                          errbd            = 24
  2387                          errst            = 25
  2388                          errcn            = 26
  2389                          erruf            = 27
  2390                          ervfy            = 28
  2391                          erload           = 29
  2392                          erbrk            = 30
  2393                          errcr            = 31
  2394                          errlnf           = 32
  2395                          errlwd           = 33
  2396                          erroid           = 34
  2397                          errng            = 35
  2398                          errbdk           = 36
  2399                          err_no_bend      = 37
  2400                          err_too_large    = 38
  2401                          err_ref          = 39
  2402                          err_bad_command  = 40
  2403                          err_file_read    = 41
  2404                          edit_mode_error  = 42                                     ; [910620]
  2405                          last_error_message = 42                                     ; # of last error msg
  2406                          
  2407                          ;.end
  2408                          
  2409                          ;[[error.handler]]
  2410                          
  2411                          
  2412                          ; Routine to translate error message # in .a
  2413                          ; into address of string containing message in index2
  2414                          
  2415  2ba9 aa                 erstup           tax                                      ; error set up
  2416  2baa a000                                ldy #0                                   ; start with address of first error message
  2417  2bac a96c                                lda #<error_message_list
  2418  2bae 8526                                sta index2
  2419  2bb0 a929                                lda #>error_message_list
  2420  2bb2 8527                                sta index2+1
  2421                          
  2422  2bb4 ca                 l11_1            dex
  2423  2bb5 300a                                bmi l11_3                                ; finished when .x decrements out
  2424                          
  2425  2bb7 b126               l11_2            lda (index2),y                           ; look at msg, and find end (msb set) (ind.ok)
  2426  2bb9 e326                                inw index2
  2427  2bbb 29ff                                and #$ff                                 ; was msb set?
  2428  2bbd 10f8                                bpl l11_2                                ; no, not end of message
  2429  2bbf 80f3                                bra l11_1                                ; yes, tick off another msg
  2430                          
  2431  2bc1 60                 l11_3            rts
  2432                          
  2433                          ;.end
  2434                          ;[[dispatcher]]
  2435                          
  2436                          
  2437                          
  2438                          ; Here for new statement. Character -> by txtptr is ':' or eol. The adr of
  2439                          ; this loc is left on the stack when a statement is executed so that it can
  2440                          ; merely do a rts when it is done.
  2441                          ; Get char, exit via xeqcm3, and return to newstt.
  2442                          
  2443  2bc2 6c0803             xeqcm            jmp (igone)
  2444                          
  2445                          ; Check if there is an interrupt from VIC that needs to be serviced
  2446                          
  2447  2bc5 7f7e3f             ngone            bbr7 runmod,l12_3                        ; get off here if we are in direct mode
  2448  2bc8 addc02                              lda intval                               ; check if there is an interrupt already in progress
  2449  2bcb 303a                                bmi l12_3                                ; yes, don't go any further
  2450                          
  2451  2bcd a202                                ldx #2                                   ; check for 3 types of interrupts: s/s, s/b, & lp
  2452  2bcf bddd02             l12_1            lda int_trip_flag,x
  2453  2bd2 f030                                beq l12_2                                ; this wasn't set, go check next
  2454                          
  2455  2bd4 a900                                lda #0
  2456  2bd6 9ddd02                              sta int_trip_flag,x                      ; reset this flag to show 'serviced'
  2457  2bd9 bde002                              lda int_adr_lo,x                         ; install the trap address as linnum
  2458  2bdc 8516                                sta linnum
  2459  2bde bde302                              lda int_adr_hi,x
  2460  2be1 8517                                sta linnum+1
  2461  2be3 da                                  phx                                      ; save counter & text pointer
  2462  2be4 fc3d00                              phw txtptr
  2463  2be7 a980                                lda #$80                                 ; flag 'no other interrupt traps, please'
  2464  2be9 0cdc02                              tsb intval
  2465                          
  2466  2bec 208322                              jsr chrget                               ; skip over 2nd byte of line number
  2467  2bef 20393d                              jsr gosub_sub                            ; fake a 'gosub' from here, so trap rx can do a RETURN
  2468  2bf2 20063d                              jsr goto_1
  2469  2bf5 200d2c                              jsr newstt
  2470                          
  2471  2bf8 a980                                lda #$80
  2472  2bfa 1cdc02                              trb intval
  2473  2bfd 68                                  pla
  2474  2bfe 853e                                sta txtptr+1
  2475  2c00 68                                  pla
  2476  2c01 853d                                sta txtptr
  2477  2c03 fa                                  plx
  2478                          
  2479  2c04 ca                 l12_2            dex
  2480  2c05 10c8                                bpl l12_1
  2481                          
  2482                          
  2483  2c07 208322             l12_3            jsr chrget                               ; get statement type
  2484  2c0a 20522c             xeqdir           jsr xeqcm3
  2485                          
  2486  2c0d 20cc2c             newstt           jsr is_stop_key_down
  2487  2c10 7f7e06                              bbr7 runmod,l13_1                        ; branch if direct mode
  2488                          
  2489                          ; In run mode...save txtptr for CONTinue command
  2490                          
  2491  2c13 20472c                              jsr tto                                  ; transfer txtptr to oldtxt
  2492  2c16 ba                                  tsx
  2493  2c17 8681                                stx oldstk
  2494                          
  2495  2c19 a000               l13_1            ldy #0
  2496  2c1b 20c522                              jsr indtxt                               ; end of the line?
  2497  2c1e d3a500                              +lbne morsts                             ; no...out of statement
  2498                          
  2499  2c21 247e               l13_2            bit runmod                               ; in direct mode?
  2500  2c23 132802                              +lbpl ready                              ; yes, go to ready
  2501  2c26 a002                                ldy #2
  2502  2c28 20c522                              jsr indtxt                               ; end of text?
  2503  2c2b f32002                              +lbeq ready                              ; yes...finished
  2504  2c2e c8                                  iny                                      ; y=3
  2505  2c2f 20c522                              jsr indtxt                               ; extract line# lo byte
  2506  2c32 853b                                sta curlin
  2507  2c34 c8                                  iny
  2508  2c35 20c522                              jsr indtxt                               ; extract line # hi byte
  2509  2c38 853c                                sta curlin+1
  2510  2c3a 98                                  tya                                      ; y=4
  2511  2c3b 18                                  clc
  2512  2c3c 653d                                adc txtptr                               ; point @ character before line start
  2513  2c3e 853d                                sta txtptr
  2514  2c40 9002                                bcc l13_3
  2515  2c42 e63e                                inc txtptr+1
  2516  2c44 837cff             l13_3            +lbra xeqcm                              ; execute new line
  2517                          
  2518                          
  2519                          
  2520  2c47 a53d               tto              lda txtptr
  2521  2c49 a43e                                ldy txtptr+1
  2522  2c4b 8d7211                              sta oldtxt
  2523  2c4e 8c7311                              sty oldtxt+1
  2524  2c51 60                 xeqrts           rts
  2525                          
  2526                          
  2527                          ; Set up for command processing and set processor address on stack.
  2528                          ; Exit via jmp to CHRGET
  2529                          
  2530  2c52 f0fd               xeqcm3           beq xeqrts                               ; nothing here...null statement
  2531  2c54 5f7e12                              bbr5 runmod,xeqcm2                       ; trcflg. branch if trace not enabled
  2532  2c57 7f7e0f                              bbr7 runmod,xeqcm2                       ; branch if direct mode- can't trace
  2533                          
  2534  2c5a 48                                  pha                                      ; save token
  2535  2c5b a95b                                lda #'['                                 ; print '[line-number]'
  2536  2c5d 203d68                              jsr outch                                ; outdo
  2537  2c60 207b64                              jsr curprt                               ; print curlin
  2538  2c63 a95d                                lda #']'
  2539  2c65 203d68                              jsr outch                                ; outdo
  2540  2c68 68                                  pla                                      ; restore token
  2541                          
  2542                          
  2543  2c69 c9fe               xeqcm2           cmp #esc_command_token                   ; special case: escape token
  2544  2c6b f03e                                beq xeqesc
  2545  2c6d c9cb                                cmp #go_token                            ; special case: go to
  2546  2c6f f3ed10                              +lbeq go_without_to
  2547  2c72 c9ca                                cmp #mid_token                           ; special case: mid$()=
  2548  2c74 f02c                                beq xeqmid
  2549                          
  2550                          ; Command can be in the range END...NEW (old BASIC) & ELSE...MONITOR
  2551                          ; (new extensions).  Although there is a gap between these two blocks,
  2552                          ; it will be quickest & easiest to collapse them into one continuous block.
  2553                          
  2554  2c76 c9fb                                cmp #monitor_token+1
  2555  2c78 b048                                bcs snerr1
  2556  2c7a c9a3                                cmp #new_token+1
  2557  2c7c 9006                                bcc xeqcm4                               ; no need to collapse
  2558  2c7e c9d5                                cmp #else_token
  2559  2c80 9040                                bcc snerr1
  2560  2c82 e932                                sbc #else_token-new_token-1
  2561                          
  2562  2c84 38                 xeqcm4           sec                                      ; convert adjusted token into an index into a jump table.
  2563  2c85 e980                                sbc #end_token
  2564  2c87 93ed09                              +lbcc let                                ; it wasn't a token after all!  assume an assignment
  2565                          
  2566  2c8a 0a                 xeqcm5           asl                                      ; *2 to convert into word pointer
  2567  2c8b a8                                  tay
  2568  2c8c b009                                bcs l14_1                                ; dispatch table 1 or 2?     [901212]
  2569  2c8e b9dd27                              lda stmdsp+1,y                           ; one
  2570  2c91 48                                  pha
  2571  2c92 b9dc27                              lda stmdsp,y
  2572  2c95 8007                                bra l14_2
  2573                          
  2574  2c97 b9dd28             l14_1            lda stmdsp2+1,y                          ; two      [901212]
  2575  2c9a 48                                  pha
  2576  2c9b b9dc28                              lda stmdsp2,y
  2577                          
  2578  2c9e 48                 l14_2            pha
  2579  2c9f 4c8322                              jmp chrget                               ; execution will commence after chrget's RTS
  2580                          
  2581                          
  2582                          
  2583                          xeqmid                                                    ; handle special case of MID$= (what we call a kludge)
  2584  2ca2 a93b                                lda #>midwrk                             ; midd2-1
  2585  2ca4 48                                  pha
  2586  2ca5 a9e1                                lda #<midwrk
  2587  2ca7 48                                  pha
  2588                          xeqchr
  2589  2ca8 4c8322                              jmp chrget
  2590                          
  2591                          
  2592                          
  2593                          
  2594                          xeqesc                                                    ; execute escape token
  2595  2cab 208322                              jsr chrget                               ; let's have us a look at the second char
  2596  2cae f012                                beq snerr1                               ; oops, there wasn't any!
  2597  2cb0 c902                                cmp #first_esc_command_token             ; is it one of our esc tokens?
  2598  2cb2 9008                                bcc l15_1                                ; no, foreign.
  2599  2cb4 c946                                cmp #last_esc_command_token+1
  2600  2cb6 b004                                bcs l15_1                                ; foreign
  2601                          
  2602                          ; It's one of our own.  Convert to index into command dispatch table
  2603                          
  2604  2cb8 6947                                adc #monitor_token-else_token+new_token-end_token-first_esc_command_token+2
  2605  2cba 80ce                                bra xeqcm5                               ; always
  2606                          
  2607  2cbc 38                 l15_1            sec                                      ; set up flag for a trip into the users code
  2608  2cbd 6c1003                              jmp (iescex)
  2609                          
  2610  2cc0 90e6               nescex           bcc xeqchr                               ; jmp chrget
  2611                          
  2612  2cc2 838601             snerr1           +lbra snerr
  2613                          
  2614  2cc5 c93a               morsts           cmp #':'
  2615  2cc7 f3f9fe                              +lbeq xeqcm                              ; if ':', continue statement
  2616  2cca 80f6                                bra snerr1
  2617                          
  2618                          
  2619                          ;[[command.set1]]
  2620                          ; STOP, STOP KEY, and END handlers
  2621                          ;
  2622                          
  2623                          is_stop_key_down
  2624  2ccc 20e1ff                              jsr _stop                                ; test stop key
  2625  2ccf d03b                                bne do_rts                               ; not down, exit
  2626                          
  2627                          ; ldy trapno+1  ;test if trap on????   removed [910925]
  2628                          ; iny
  2629                          ; beq stop_1  ;no, do a normal stop
  2630                          
  2631                          
  2632                          break_exit                                                ; STOP KEY:     [910104]
  2633  2cd1 20e1ff             l16_1            jsr _stop                                ; wait for the user to release the key
  2634  2cd4 f0fb                                beq l16_1
  2635  2cd6 a21e                                ldx #erbrk                               ; take the vector thru error to ready
  2636  2cd8 837501                              +lbra error
  2637                          
  2638                          
  2639                          
  2640  2cdb b001               stop             bcs stopc                                ; STOP: .c=1
  2641                          
  2642  2cdd 18                 end              clc                                      ; END: .c=0
  2643  2cde d36a01             stopc            +lbne snerr                              ; error if args present   [910410]
  2644                          
  2645  2ce1 7f7e0d             stop_1           bbr7 runmod,l17_1                        ; branch if direct mode
  2646  2ce4 20472c                              jsr tto                                  ; transfer txtptr to oldtxt
  2647  2ce7 a53b                                lda curlin
  2648  2ce9 a43c                                ldy curlin+1
  2649  2ceb 8d7011                              sta oldlin
  2650  2cee 8c7111                              sty oldlin+1
  2651  2cf1 68                 l17_1            pla                                      ; .diris
  2652  2cf2 68                                  pla
  2653  2cf3 935801                              +lbcc ready                              ; say 'ready' if END, say 'break' if STOP
  2654                          
  2655                          
  2656  2cf6 20b438             break            jsr release_channels                     ; make sure we're in text mode????  [910909]
  2657  2cf9 2027af                              jsr RestoreTextScreen
  2658  2cfc 20dc3c                              jsr highlight_text                       ; ????      [910624]
  2659  2cff 207dff                              jsr _primm
  2660  2d02 0d425245414b00                      !text cr,"BREAK",0
  2661  2d09 83ce01                              +lbra errfin                             ; exit via 'in line #'
  2662                          
  2663  2d0c 60                 do_rts           rts
  2664                          
  2665                          ;.end
  2666                          ;[[functions]]
  2667                          
  2668                          
  2669                          
  2670                          ; At this point, eval has determined that the token in a has to be a
  2671                          ; function.  It must therefor be in the range SGN...MID$ (old BASIC),
  2672                          ; or RGR...INSTR (new extensions).  We will collapse these two disjoint
  2673                          ; blocks into one continuous range.
  2674                          ;
  2675                          ; On entry, we can assume the token is >= 'sgn'
  2676                          
  2677  2d0d c9ce               isfun            cmp #esc_function_token                  ; is this an escape function?
  2678  2d0f f059                                beq do_esc_fn                            ; yes
  2679  2d11 c9d5                                cmp #last_function_token+1
  2680  2d13 b0ad                                bcs snerr1                               ; no- must be syntax error
  2681  2d15 c9cb                                cmp #mid_token+1
  2682  2d17 9002                                bcc l18_1                                ; no need to adjust
  2683  2d19 e901                                sbc #rgraphic_token-mid_token-1
  2684                          
  2685  2d1b 48                 l18_1            pha                                      ; save token
  2686  2d1c aa                                  tax
  2687  2d1d 208322                              jsr chrget                               ; set up for synchk.
  2688  2d20 e0d3                                cpx #instr_token-1                       ; look for (adjusted) instr token
  2689  2d22 f00d                                beq l18_2                                ; yes
  2690  2d24 e0cb                                cpx #rgraphic_token-1                    ; look for rgraphic which now takes 2 args [910801]
  2691  2d26 f3fe8b                              +lbeq rgraphic                           ; yes
  2692                          
  2693  2d29 e0cb                                cpx #mid_token+1
  2694  2d2b b024                                bcs oknorm                               ; LEFT$,RIGHT$,MID$ require multiple args
  2695  2d2d e0c8                                cpx #left_token                          ; is it past last single-arg function?
  2696  2d2f 9020                                bcc oknorm                               ; no, must be normal function
  2697                          
  2698                          
  2699                          ; Most functions take a single argument.  The return address of these functions
  2700                          ; is CHKNUM, which ascertains that VALTYP=0 (numeric).  Normal functions which
  2701                          ; return string results (eg. CHR$) must pop off that return address and return
  2702                          ; directly to FRMEVL.
  2703                          ;
  2704                          ; The so called "funny" functions can take more than one argument, the first
  2705                          ; of which must be string and the second of which must be a number between 0
  2706                          ; and 255.  The closed parenthesis must be checked and return is directly to
  2707                          ; FRMEVL with the text pointer pointing beyond the ")".  The pointer to the
  2708                          ; description of the string argument is stored on the stack underneath the
  2709                          ; value of the integer argument.
  2710                          
  2711  2d31 20584e             l18_2            jsr chkopn                               ; check for an open parenthesis
  2712  2d34 20ef4c                              jsr frmevl                               ; eat open paren and first argument
  2713  2d37 205b4e                              jsr chkcom                               ; two args so comma must delimit
  2714  2d3a 20dd4c                              jsr chkstr                               ; make sure first was string
  2715                          
  2716  2d3d 68                                  pla                                      ; check token
  2717  2d3e c9d3                                cmp #instr_token-1                       ; special case: INSTR() bails out here
  2718  2d40 f32b41                              +lbeq instr
  2719  2d43 a667                                ldx facmo+1                              ; push address of string arg1
  2720  2d45 da                                  phx
  2721  2d46 a666                                ldx facmo
  2722  2d48 da                                  phx
  2723  2d49 48                                  pha                                      ; push token
  2724  2d4a 206c5d                              jsr getbyt                               ; get arg2
  2725  2d4d 68                                  pla                                      ; retrieve token
  2726  2d4e da                                  phx                                      ; push value of arg2
  2727  2d4f 8004                                bra fingo                                ; go set up to evaluate fn
  2728                          
  2729                          
  2730                          
  2731                          oknorm
  2732  2d51 204f4e                              jsr parchk                               ; check for open parens, evaluate argument
  2733  2d54 68                                  pla                                      ; restore token
  2734                          
  2735                          fingo
  2736  2d55 38                                  sec                                      ; convert token to index into jump table
  2737  2d56 e9b4                                sbc #first_function_token
  2738  2d58 0a                                  asl
  2739  2d59 a8                                  tay
  2740  2d5a b9f728                              lda fundsp+1,y
  2741  2d5d 8558                                sta jmper+2
  2742  2d5f b9f628                              lda fundsp,y
  2743  2d62 8557                                sta jmper+1
  2744  2d64 205600                              jsr jmper                                ; dispatch
  2745                          ;string functions remove this ret addr
  2746  2d67 83721f                              +lbra chknum                             ; check for "numeric-ness" and return
  2747                          
  2748                          
  2749                          ; Escape Function handler
  2750                          
  2751                          do_esc_fn
  2752  2d6a 208322                              jsr chrget                               ; get second token
  2753  2d6d f3db00                              +lbeq snerr                              ; error if no second token
  2754  2d70 c90a                                cmp #pointer_token
  2755  2d72 f00b                                beq l19_1                                ; skip pre-parse if 'POINTER()'
  2756  2d74 48                                  pha
  2757  2d75 208322                              jsr chrget                               ; should be '('
  2758  2d78 20584e                              jsr chkopn
  2759  2d7b 20ef4c                              jsr frmevl                               ; evaluate first argument
  2760  2d7e 68                                  pla
  2761  2d7f c902               l19_1            cmp #first_esc_function_token            ; see if this esc fn is one of ours
  2762  2d81 9008                                bcc foreign_esc_fn                       ; nope.
  2763  2d83 c90e                                cmp #last_esc_function_token+1
  2764  2d85 b004                                bcs foreign_esc_fn                       ; nope
  2765                          
  2766                          ; Convert to index into the function dispatch table
  2767                          
  2768  2d87 69d1                                adc #last_function_token-first_esc_function_token-1
  2769  2d89 80ca                                bra fingo                                ; always
  2770                          
  2771                          
  2772                          foreign_esc_fn
  2773  2d8b 38                                  sec                                      ; flag 'up for grabs'
  2774  2d8c 20952d                              jsr go_foreign_esc_fn
  2775                          n_esc_fn_vec
  2776  2d8f b3b900                              +lbcs snerr                              ; it's unwanted. off to the refuse pile
  2777  2d92 83471f                              +lbra chknum
  2778                          
  2779                          go_foreign_esc_fn
  2780  2d95 6cfc02                              jmp (esc_fn_vec)
  2781                          
  2782                          
  2783  2d98 a0ff               orop             ldy #255                                 ; must always complement
  2784  2d9a 2c                                  !text $2c
  2785                          
  2786  2d9b a000               andop            ldy #0
  2787  2d9d 840d                                sty count                                ; operator
  2788  2d9f 20b458                              jsr ayint                                ; (facmo&lo)=int value and check size
  2789  2da2 a566                                lda facmo                                ; use Demorgan's Law on high
  2790  2da4 450d                                eor count
  2791  2da6 850a                                sta integr
  2792  2da8 a567                                lda faclo                                ; and low
  2793  2daa 450d                                eor count
  2794  2dac 850b                                sta integr+1
  2795  2dae 209362                              jsr movfa
  2796  2db1 20b458                              jsr ayint                                ; (facmo&lo)=int of arg
  2797  2db4 a567                                lda faclo
  2798  2db6 450d                                eor count
  2799  2db8 250b                                and integr+1
  2800  2dba 450d                                eor count                                ; finish out Demorgan
  2801  2dbc a8                                  tay                                      ; save high
  2802  2dbd a566                                lda facmo
  2803  2dbf 450d                                eor count
  2804  2dc1 250a                                and integr
  2805  2dc3 450d                                eor count
  2806  2dc5 837820                              +lbra givayf                             ; float (a,y) and return to user
  2807                          
  2808                          
  2809                          ;[[relational]]
  2810                          
  2811                          ; Time to perform a relational operator.
  2812                          ; (domask) contains the bits as to which relational operator it was.
  2813                          ; Carry bit on = string compare.
  2814                          
  2815                          
  2816  2dc8 20de4c             dorel            jsr chkval                               ; check for match
  2817  2dcb b012                                bcs strcmp                               ; is it a string?
  2818  2dcd a56f                                lda argsgn                               ; pack argument for fcomp
  2819  2dcf 097f                                ora #$7f
  2820  2dd1 256b                                and argho
  2821  2dd3 856b                                sta argho
  2822  2dd5 a96a                                lda #<argexp
  2823  2dd7 a000                                ldy #>argexp
  2824  2dd9 20f162                              jsr fcomp
  2825  2ddc aa                                  tax
  2826  2ddd 8033                                bra qcomp
  2827                          
  2828                          
  2829  2ddf a900               strcmp           lda #0
  2830  2de1 850f                                sta valtyp
  2831  2de3 c64f                                dec opmask
  2832  2de5 206d5b                              jsr frefac                               ; free the faclo string
  2833  2de8 8563                                sta dsctmp                               ; save it for later
  2834  2dea 8664                                stx dsctmp+1
  2835  2dec 8465                                sty dsctmp+2
  2836  2dee a56d                                lda argmo                                ; get pointer to other string
  2837  2df0 a46e                                ldy argmo+1
  2838  2df2 20715b                              jsr fretmp                               ; frees first desc pointer
  2839  2df5 866d                                stx argmo
  2840  2df7 846e                                sty argmo+1
  2841  2df9 aa                                  tax                                      ; copy count into x
  2842  2dfa 38                                  sec
  2843  2dfb e563                                sbc dsctmp                               ; which is greater. if 0, all set up
  2844  2dfd f008                                beq stasgn                               ; just put sign of difference away
  2845  2dff a901                                lda #1
  2846  2e01 9004                                bcc stasgn                               ; sign is positive
  2847  2e03 a663                                ldx dsctmp                               ; length of fac is shorter
  2848  2e05 a9ff                                lda #$ff                                 ; get a minus one for negatives
  2849  2e07 8568               stasgn           sta facsgn                               ; keep for later
  2850  2e09 a0ff                                ldy #255                                 ; set pointer to first string. (arg)
  2851  2e0b e8                                  inx                                      ; to loop properly
  2852  2e0c c8                 nxtcmp           iny
  2853  2e0d ca                                  dex                                      ; any characters left to compare?
  2854  2e0e d007                                bne getcmp                               ; not done yet
  2855  2e10 a668                                ldx facsgn                               ; use sign of length difference
  2856                          ;since all characters are the same
  2857  2e12 301b               qcomp            bmi docmp                                ; c is always set then
  2858  2e14 18                                  clc
  2859  2e15 8018                                bra docmp                                ; always branch
  2860                          
  2861                          
  2862  2e17 a96d               getcmp           lda #argmo
  2863  2e19 20d722                              jsr lda_far_ram1                         ; lda (argmo),y from RAM1
  2864  2e1c 48                                  pha
  2865  2e1d a964                                lda #dsctmp+1
  2866  2e1f 20d722                              jsr lda_far_ram1                         ; lda (dsctmp+1),y from RAM1
  2867  2e22 8578                                sta syntmp
  2868  2e24 68                                  pla
  2869  2e25 c578                                cmp syntmp
  2870  2e27 f0e3                                beq nxtcmp
  2871  2e29 a2ff                                ldx #$ff
  2872  2e2b b002                                bcs docmp
  2873  2e2d a201                                ldx #1
  2874                          
  2875                          
  2876                          
  2877                          docmp
  2878  2e2f e8                                  inx                                      ; -1 to 1, 0 to 2, 1 to 4
  2879  2e30 8a                                  txa
  2880  2e31 2a                                  rol
  2881  2e32 2514                                and domask
  2882  2e34 f002                                beq l20_1
  2883  2e36 a9ff                                lda #$ff                                 ; map 0 to 0, map all others to -1
  2884  2e38 839834             l20_1            +lbra float                              ; float the one-byte result into FAC
  2885                          
  2886                          
  2887                          ;.end
  2888                          
  2889                          ;[[readyerror]]
  2890                          
  2891                          
  2892                          bad_command
  2893  2e3b a228                                ldx #err_bad_command                     ; unimplemented command
  2894  2e3d 2c                                  !text $2c
  2895                          
  2896  2e3e a211               userr            ldx #errus                               ; undefined statement
  2897  2e40 2c                                  !text $2c
  2898                          
  2899  2e41 a210               omerr            ldx #errom                               ; out of memory
  2900  2e43 2c                                  !text $2c
  2901                          
  2902  2e44 a214               doverr           ldx #errdvo                              ; division by zero
  2903  2e46 2c                                  !text $2c
  2904                          
  2905  2e47 a20f               overr            ldx #errov                               ; overflow
  2906  2e49 2c                                  !text $2c
  2907                          
  2908  2e4a a20b               snerr            ldx #errsn                               ; syntax error
  2909  2e4c 2c                                  !text $2c
  2910                          
  2911  2e4d a280               ready            ldx #$80                                 ; no error
  2912                          
  2913  2e4f 6c0003             error            jmp (ierror)
  2914                          
  2915  2e52 8a                 nerror           txa
  2916  2e53 338f00                              +lbmi ready_1                            ; ...branch if no error (from 'ready')
  2917  2e56 8ec702                              stx errnum                               ; save error # for 'er'
  2918  2e59 7f7e3c                              bbr7 runmod,errisd                       ; branch if direct mode- always display error
  2919                          
  2920  2e5c a001                                ldy #1                                   ; copy curlin to errlin, oldtxt to errtxt
  2921  2e5e b93b00             l21_1            lda curlin,y
  2922  2e61 99c802                              sta errlin,y                             ; line# where error occurred
  2923  2e64 b97211                              lda oldtxt,y
  2924  2e67 99cd02                              sta errtxt,y                             ; statement where error occured
  2925  2e6a 88                                  dey
  2926  2e6b 10f1                                bpl l21_1
  2927  2e6d eecd02                              inc errtxt                               ; point to a token, not ':' for HELP
  2928  2e70 d003                                bne l21_2
  2929  2e72 eece02                              inc errtxt+1
  2930                          
  2931  2e75 accb02             l21_2            ldy trapno+1                             ; is trap set?
  2932  2e78 c0ff                                cpy #$ff
  2933  2e7a f01c                                beq errisd                               ; no
  2934  2e7c 8417                                sty linnum+1
  2935  2e7e 8ccc02                              sty tmptrp                               ; save until a resume is executed
  2936  2e81 acca02                              ldy trapno
  2937  2e84 8416                                sty linnum
  2938                          
  2939  2e86 a2ff                                ldx #$ff
  2940  2e88 8ecb02                              stx trapno+1                             ; flag no more traps
  2941  2e8b a21b                                ldx #tempst                              ; clear any accumulated string temps
  2942  2e8d 8618                                stx temppt
  2943  2e8f a681                                ldx oldstk
  2944  2e91 9a                                  txs
  2945  2e92 201f3d                              jsr luk4it
  2946  2e95 8376fd                              +lbra newstt
  2947                          
  2948                          
  2949                          ;[[error.handler]]
  2950  2e98 ca                 errisd           dex
  2951  2e99 8a                                  txa
  2952  2e9a 20a92b                              jsr erstup                               ; set up address of error msg in .a in index2
  2953                          
  2954  2e9d ff7e08                              bbs7 runmod,l22_1                        ; reset error line if direct mode error
  2955  2ea0 a9ff                                lda #$ff
  2956  2ea2 8dc802                              sta errlin                               ;
  2957  2ea5 8dc902                              sta errlin+1
  2958                          
  2959  2ea8 20b438             l22_1            jsr release_channels                     ; restore output to screen    [910909]
  2960  2eab 2027af                              jsr RestoreTextScreen                    ; make sure we're in text mode    [910404]
  2961  2eae 200935                              jsr init_stack
  2962                          
  2963  2eb1 20f737             l22_2            jsr crdo                                 ; Print error message- start a new line with '?'
  2964  2eb4 20dc3c                              jsr highlight_text                       ; use highlight color????    [910624]
  2965  2eb7 206238                              jsr outqst
  2966  2eba a000                                ldy #0
  2967  2ebc b126               l22_3            lda (index2),y                           ; Read error msg from ROM  (ind.ok????)
  2968  2ebe 48                                  pha
  2969  2ebf 297f                                and #$7f
  2970  2ec1 203d68                              jsr outch                                ; Print it
  2971  2ec4 c8                                  iny
  2972  2ec5 68                                  pla
  2973  2ec6 10f4                                bpl l22_3
  2974  2ec8 aec702                              ldx errnum                               ; retrieve error #     [910925]
  2975  2ecb e01e                                cpx #erbrk
  2976  2ecd f00a                                beq errfin                               ; skip 'error' crap if 'break'
  2977  2ecf 207dff                              jsr _primm
  2978  2ed2 204552524f5200                      !text " ERROR",0
  2979                          
  2980  2ed9 a43c               errfin           ldy curlin+1                             ; direct mode?
  2981  2edb c8                                  iny
  2982  2edc f003                                beq l23_1                                ; yes...no line #
  2983  2ede 207364                              jsr inprt
  2984  2ee1 20cb3c             l23_1            jsr highlight_done                       ; restore normal text color????    [910624]
  2985                          
  2986                          ;[[interface]]
  2987                          
  2988                          
  2989                          ready_1
  2990  2ee4 a980                                lda #%10000000
  2991  2ee6 2090ff                              jsr _setmsg                              ; turn Kernel messages on
  2992  2ee9 a9c0                                lda #%11000000
  2993  2eeb 147e                                trb runmod                               ; turn run modes off, leave trace mode on????
  2994                          
  2995                          ready_2
  2996  2eed cf7e0e                              bbs4 runmod,l24_1                        ; print appropriate system prompt
  2997  2ef0 207dff                              jsr _primm                               ; Program mode: print 'ready.'
  2998  2ef3 0d52454144592e0d...                 !text cr,"READY.",cr,0
  2999  2efc 8009                                bra main
  3000                          
  3001  2efe 207dff             l24_1            jsr _primm                               ; Edit mode: print 'ok.'
  3002  2f01 0d4f4b2e0d00                        !text cr,"OK.",cr,0
  3003                          
  3004                          
  3005  2f07 6c0203             main             jmp (imain)                              ; MAIN INPUT LOOP
  3006                          
  3007  2f0a a2ff               nmain            ldx #$ff                                 ; set direct mode flag
  3008  2f0c 863c                                stx curlin+1
  3009  2f0e 201c31                              jsr InputLine                            ; get a line of input & buffer it
  3010                          
  3011                          ;[[execute]]
  3012                          
  3013                          execute_a_line                                            ; EXECUTE PLAIN TEXT IN BUFFER
  3014  2f11 863d                                stx txtptr                               ; init buffer pointer
  3015  2f13 843e                                sty txtptr+1
  3016  2f15 208322                              jsr chrget                               ; get first character of null-terminated string
  3017  2f18 aa                                  tax
  3018  2f19 f0ec                                beq main                                 ; got null input
  3019  2f1b 9009                                bcc l25_1                                ; got line number
  3020  2f1d 201f23                              jsr crunch                               ; got text- tokenize buffer,
  3021  2f20 208522                              jsr chrgot                               ; get first command (token),
  3022  2f23 83e5fc                              +lbra xeqdir                             ; and execute it
  3023                          
  3024                          
  3025                          ;ADD or DELETE NEW LINE
  3026  2f26 202e32             l25_1            jsr linget                               ; evaluate line number, put into into linnum
  3027  2f29 4f7e05                              bbr4 runmod,l25_2
  3028  2f2c 20e1bc                              jsr edit_crunch                          ; if edit mode, find end of input   [910620]
  3029  2f2f 8003                                bra l25_3
  3030                          
  3031  2f31 201f23             l25_2            jsr crunch                               ; tokenize rest of input if not edit mode
  3032  2f34 840d               l25_3            sty count                                ; save length
  3033  2f36 20fa31                              jsr FindLine                             ; locate line in program
  3034  2f39 938300                              +lbcc nodel                              ; not found, go insert line into program
  3035                          ; else delete current line and insert this one
  3036                          ;[[edit.shift]]
  3037                          
  3038                          ; Test: IF new line is longer than the line it replaces,
  3039                          ;  THEN IF there isn't enough room in memory to add this new line,
  3040                          ;   THEN out-of-memory error
  3041                          ;
  3042                          ; Before this fix, the old line was deleted BEFORE testing if the new line fit.
  3043                          ;
  3044                          ; N.B.: I am assuming that lines cannot be greater than 255 chars, as is the
  3045                          ; case where the line was entered "normally", that is, using LINGET.  The only
  3046                          ; consequence of this assumption is that lines > 255 will fall prey to the
  3047                          ; pre-fix problem mentioned above.
  3048                          
  3049  2f3c a000                                ldy #0
  3050  2f3e 20ad22                              jsr indlow                               ; get lsb of the next line's starting address
  3051  2f41 38                                  sec
  3052  2f42 e561                                sbc lowtr                                ; subtract lsb of this line's starting address
  3053  2f44 38                                  sec                                      ; ignore borrow (gives abs. value)
  3054  2f45 e904                                sbc #4                                   ; allow for link & line number
  3055  2f47 e50d                                sbc count                                ; compare with new length
  3056  2f49 b016                                bcs l25_5                                ; new line is shorter, no problem
  3057  2f4b 42                                  neg                                      ; convert to positive delta
  3058                          
  3059  2f4c a483                                ldy text_top+1                           ; get msb of end of text (.c=0)
  3060  2f4e 6582                                adc text_top                             ; add our calculated delta to end of text
  3061  2f50 9001                                bcc l25_4
  3062  2f52 c8                                  iny
  3063  2f53 ccd002             l25_4            cpy max_mem_0+1
  3064  2f56 9009                                bcc l25_5                                ; result is less than top-of-memory: ok
  3065  2f58 d3e7fe                              +lbne omerr                              ; msb >  top, overflow
  3066  2f5b cdcf02                              cmp max_mem_0                            ; msb's the same, test lsb's
  3067  2f5e b3e1fe                              +lbcs omerr                              ; lsb >= top, overflow
  3068                          
  3069                          ; Using DMA device to move text downwards (to delete or replace a line)...
  3070                          ;
  3071                          ; lowtr     = destination
  3072                          ; (lowtr)    = pointer to source (via link bytes of line to be removed)
  3073                          ; text_top-(lowtr) = number of bytes to move (text_top points to old top of text)
  3074                          ; new text_top     = text_top -( (lowtr)-lowtr )
  3075                          
  3076  2f61 a561               l25_5            lda lowtr                                ; set up DMA destination
  3077  2f63 8d4a01                              sta dma1_dest_lo
  3078  2f66 a562                                lda lowtr+1
  3079  2f68 8d4b01                              sta dma1_dest_hi
  3080  2f6b a000                                ldy #0
  3081  2f6d 20ad22                              jsr indlow                               ; set up DMA source (& delta)
  3082  2f70 8d4701                              sta dma1_src_lo
  3083  2f73 38                                  sec
  3084  2f74 e561                                sbc lowtr
  3085  2f76 8524                                sta index1                               ; (delta lo)
  3086  2f78 c8                                  iny
  3087  2f79 20ad22                              jsr indlow
  3088  2f7c 8d4801                              sta dma1_src_hi
  3089  2f7f e562                                sbc lowtr+1
  3090  2f81 8525                                sta index1+1                             ; (delta hi)
  3091  2f83 38                                  sec
  3092  2f84 a582                                lda text_top                             ; set up DMA count
  3093  2f86 ed4701                              sbc dma1_src_lo
  3094  2f89 8d4501                              sta dma1_cnt_lo
  3095  2f8c a583                                lda text_top+1
  3096  2f8e ed4801                              sbc dma1_src_hi
  3097  2f91 8d4601                              sta dma1_cnt_hi
  3098                          
  3099  2f94 a584                                lda text_bank
  3100                          ; and #%00001111  ;      [910102]
  3101                          ; and #%01111111  ;      [910520] F018A
  3102  2f96 8d4901                              sta dma1_src_bank
  3103  2f99 8d4c01                              sta dma1_dest_bank
  3104                          
  3105  2f9c a900                                lda #0
  3106  2f9e 8d4401                              sta dma1_cmd                             ; dma command (copy, source=start)
  3107  2fa1 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
  3108  2fa4 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
  3109                          
  3110  2fa7 a201                                ldx #>dma1_cmd                           ; dma_list
  3111  2fa9 a944                                lda #<dma1_cmd
  3112  2fab 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
  3113  2fae 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
  3114                          
  3115  2fb1 38                                  sec                                      ; calculate & set new text_top
  3116  2fb2 a582                                lda text_top
  3117  2fb4 e524                                sbc index1
  3118  2fb6 8582                                sta text_top                             ; lo
  3119  2fb8 a583                                lda text_top+1
  3120  2fba e525                                sbc index1+1
  3121  2fbc 8583                                sta text_top+1                           ; hi
  3122                          ;fall into routine to insert new line (if any)
  3123                          
  3124                          
  3125  2fbe 200935             nodel            jsr init_stack                           ; 'clearc' removed since text changes don't require trashing variables
  3126  2fc1 20b930                              jsr link_program                         ; fix links
  3127  2fc4 20dc44                              jsr error_clear                          ; clear HELP/error flag, assuming he fixed whatever caused current error, if any
  3128                          
  3129  2fc7 a000                                ldy #0
  3130  2fc9 b13d                                lda (txtptr),y                           ; delete line? ("common")
  3131  2fcb f33aff                              +lbeq main                               ; yes
  3132                          
  3133  2fce 18                 l26_1            clc                                      ; no...something to insert
  3134  2fcf a483                                ldy text_top+1
  3135  2fd1 a582                                lda text_top
  3136  2fd3 845d                                sty hightr+1                             ; top of block to move (old text_top)
  3137  2fd5 855c                                sta hightr
  3138  2fd7 650d                                adc count                                ; number of characters in line to be inserted
  3139  2fd9 9001                                bcc l26_2
  3140  2fdb c8                                  iny
  3141  2fdc 18                 l26_2            clc
  3142  2fdd 6904                                adc #4                                   ; plus link and line #
  3143  2fdf 9001                                bcc l26_3                                ; gives us destination of move (new text_top)
  3144  2fe1 c8                                  iny
  3145                          
  3146  2fe2 855a               l26_3            sta highds                               ; destination of top
  3147  2fe4 845b                                sty highds+1
  3148  2fe6 ccd002                              cpy max_mem_0+1                          ; make sure new top doesn't crash into top of available ram
  3149  2fe9 9009                                bcc l26_4                                ; ok
  3150  2feb d354fe                              +lbne omerr                              ; out of memory, don't insert
  3151  2fee cdcf02                              cmp max_mem_0
  3152  2ff1 b34efe                              +lbcs omerr                              ; out of memory, don't insert
  3153                          
  3154  2ff4 8582               l26_4            sta text_top                             ; set new top of text
  3155  2ff6 8483                                sty text_top+1
  3156  2ff8 38                                  sec                                      ; compute number of things to move up
  3157  2ff9 a55c                                lda hightr
  3158  2ffb e561                                sbc lowtr                                ; (old top) - (adr where new line goes)
  3159  2ffd a8                                  tay                                      ; lowtr was setup previously by FindLine call
  3160  2ffe a55d                                lda hightr+1
  3161  3000 e562                                sbc lowtr+1
  3162  3002 aa                                  tax
  3163                          
  3164                          ; Using DMA device to copy data upwards...
  3165                          ;
  3166                          ; (hightr)   = source  (old top)
  3167                          ; (highds)   = destination (new top)
  3168                          ; .y, .x     = number of bytes to move
  3169                          ; (lowtr)    = where to insert new line (starting with link bytes)
  3170                          
  3171  3003 c35c                                dew hightr                               ; (text_top-1) points to actual last byte
  3172  3005 c35a                                dew highds
  3173                          
  3174                          ; lda dma_ctlr+3  ;dma controller version    [910520] F018A
  3175                          ; and #1
  3176                          ; beq l26_5   ; F018    removed [910808] F018B
  3177  3007 a930                                lda #%00110000                           ; F018A, B
  3178  3009 8d4401             l26_5            sta dma1_cmd                             ; command=copy, source=endpt   [910102]
  3179  300c 8c4501                              sty dma1_cnt_lo                          ; count
  3180  300f 8e4601                              stx dma1_cnt_hi
  3181  3012 98                                  tya
  3182  3013 0d4601                              ora dma1_cnt_hi
  3183  3016 f02e                                beq l26_7                                ; special case= nothing to move???? should not happen
  3184                          
  3185  3018 a55c                                lda hightr
  3186  301a a45d                                ldy hightr+1
  3187  301c 8d4701                              sta dma1_src_lo                          ; source
  3188  301f 8c4801                              sty dma1_src_hi
  3189  3022 a55a                                lda highds
  3190  3024 a45b                                ldy highds+1
  3191  3026 8d4a01                              sta dma1_dest_lo                         ; destination
  3192  3029 8c4b01                              sty dma1_dest_hi
  3193  302c a584                                lda text_bank                            ; [910520] F018A
  3194                          ; ldx dma1_cmd  ;version?    removed [910808] F018B
  3195                          ; bne l26_6   ; F018A
  3196                          ; and #%00001111  ;      [910102]
  3197                          ; ora #%01000000  ;(copy source=endpoint)    [910102]
  3198  302e 8d4901             l26_6            sta dma1_src_bank                        ; banks
  3199  3031 8d4c01                              sta dma1_dest_bank
  3200  3034 a900                                lda #0
  3201  3036 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
  3202  3039 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
  3203  303c a201                                ldx #>dma1_cmd                           ; dma_list
  3204  303e a944                                lda #<dma1_cmd
  3205  3040 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
  3206  3043 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
  3207                          
  3208                          ; Make links non-null to fool 'chead'
  3209                          
  3210  3046 a000               l26_7            ldy #0
  3211  3048 a901                                lda #1
  3212  304a a261                                ldx #lowtr
  3213  304c 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=0 (bleed-thru)
  3214  304f c8                                  iny
  3215  3050 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=1 (bleed-thru)
  3216                          
  3217                          ; Put line number in text
  3218                          
  3219  3053 c8                                  iny
  3220  3054 a516                                lda linnum
  3221  3056 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=2 (bleed-thru)
  3222  3059 c8                                  iny
  3223  305a a517                                lda linnum+1
  3224  305c 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y  y=3 (bleed-thru)
  3225                          
  3226                          ; Advance 'lowtr' to start of line (past link bytes & line #)
  3227                          
  3228  305f 18                                  clc
  3229  3060 a561                                lda lowtr
  3230  3062 6904                                adc #4
  3231  3064 8561                                sta lowtr
  3232  3066 9002                                bcc l26_8
  3233  3068 e662                                inc lowtr+1
  3234                          
  3235                          
  3236                          ; Block move line to text
  3237                          
  3238  306a a40d               l26_8            ldy count                                ; use dma ???? [910925]
  3239  306c 88                                  dey
  3240                          
  3241  306d b13d               l26_9            lda (txtptr),y                           ; (from common area)
  3242  306f 200c23                              jsr sta_far_ram0                         ; sta (lowtr),y   (bleed-thru)
  3243  3072 88                                  dey
  3244  3073 c0ff                                cpy #$ff
  3245  3075 d0f6                                bne l26_9
  3246                          
  3247                          ; beq l26_9   ;special case= nothing to move???? should not happen
  3248                          ; lda #0   ; F018A, B
  3249                          ; sta dma1_cmd  ;command=copy, source=start
  3250                          ; sty dma1_cnt_lo  ;count
  3251                          ; sta dma1_cnt_hi
  3252                          ;
  3253                          ; lda txtptr
  3254                          ; ldy txtptr+1
  3255                          ; sta dma1_src_lo  ;source
  3256                          ; sty dma1_src_hi
  3257                          ; lda lowtr
  3258                          ; ldy lowtr+1
  3259                          ; sta dma1_dest_lo ;destination
  3260                          ; sty dma1_dest_hi
  3261                          ; lda text_bank  ;banks
  3262                          ; sta dma1_dest_bank
  3263                          ; lda #sys_bank  ;????
  3264                          ; sta dma1_src_bank
  3265                          ; sta dma1_subcmd  ;      [910520] F018A
  3266                          ; sta dma_ctlr+2  ;dma_list bank
  3267                          ; ldx #>dma1_cmd  ;dma_list
  3268                          ; lda #<dma1_cmd
  3269                          ; stx dma_ctlr+1  ;dma_list hi
  3270                          ; sta dma_ctlr  ;dma_list lo & trigger
  3271                          ;l26_9
  3272  3077 20b930                              jsr link_program
  3273  307a 201f35                              jsr reset_txtptr                         ; set up txtptr (was jsr runc)
  3274                          
  3275                          ; Test if AUTO in effect
  3276                          
  3277  307d a574                                lda autinc                               ; if in auto mode, increment val <> 0
  3278  307f 0575                                ora autinc+1
  3279  3081 f033                                beq l26_12                               ; not in
  3280                          
  3281  3083 a516                                lda linnum                               ; yes, construct new line number
  3282  3085 18                                  clc
  3283  3086 6574                                adc autinc
  3284  3088 8565                                sta facho+1
  3285  308a a517                                lda linnum+1
  3286  308c 6575                                adc autinc+1
  3287  308e b026                                bcs l26_12                               ; no auto if wrapped
  3288  3090 c9fa                                cmp #$fa                                 ; test if # >= 64000
  3289  3092 b022                                bcs l26_12                               ; no auto if so.
  3290  3094 8564                                sta facho
  3291  3096 a290                                ldx #$90
  3292  3098 38                                  sec
  3293  3099 20df62                              jsr floatc                               ; float it
  3294  309c 208f64                              jsr fout                                 ; make it into a string
  3295                          
  3296  309f 78                                  sei                                      ; [910710]
  3297  30a0 a200                                ldx #0                                   ; move string into kbd buffer
  3298  30a2 bd0101             l26_10           lda fbuffr+1,x                           ; copy number formed into buffer, ignoring leading space
  3299  30a5 f006                                beq l26_11                               ; a null marks end
  3300  30a7 9db002                              sta _keyd,x
  3301  30aa e8                                  inx
  3302  30ab d0f5                                bne l26_10                               ; always
  3303                          
  3304  30ad a91d               l26_11           lda #29                                  ; cursor right
  3305  30af 9db002                              sta _keyd,x
  3306  30b2 e8                                  inx
  3307  30b3 86d0                                stx _ndx
  3308  30b5 58                                  cli                                      ; [910710]
  3309                          
  3310  30b6 834ffe             l26_12           +lbra main
  3311                          
  3312                          ;[[linkprogram]]
  3313                          
  3314                          
  3315                          link_program
  3316  30b9 a52d                                lda txttab
  3317  30bb a42e                                ldy txttab+1
  3318  30bd 8524                                sta index
  3319  30bf 8425                                sty index+1
  3320  30c1 18                                  clc
  3321                          
  3322  30c2 a000               chead            ldy #0
  3323  30c4 20c122                              jsr indin1                               ; lda (index),y .. check for null link
  3324  30c7 d006                                bne l27_1
  3325  30c9 c8                                  iny
  3326  30ca 20c122                              jsr indin1                               ; lda (index),y
  3327  30cd f042                                beq lnkrts
  3328                          
  3329  30cf a003               l27_1            ldy #3                                   ; [900524]
  3330  30d1 c8                 l27_2            iny                                      ; ???? very expensive loop ????
  3331  30d2 c0fe                                cpy #254
  3332  30d4 b01f                                bcs link_error                           ; failsafe- program is mangled  [910103]
  3333  30d6 20c122                              jsr indin1                               ; lda (index),y
  3334  30d9 d0f6                                bne l27_2
  3335  30db c8                                  iny
  3336  30dc 98                                  tya
  3337  30dd 6524                                adc index
  3338  30df 48                                  pha
  3339  30e0 a000                                ldy #0
  3340  30e2 a224                                ldx #index
  3341  30e4 200c23                              jsr sta_far_ram0                         ; sta (index),y   (bleed-thru)
  3342  30e7 98                                  tya
  3343  30e8 6525                                adc index+1
  3344  30ea c8                                  iny
  3345  30eb 200c23                              jsr sta_far_ram0                         ; sta (index),y   (bleed-thru)
  3346  30ee fa                                  plx
  3347  30ef 8624                                stx index
  3348  30f1 8525                                sta index+1
  3349  30f3 80cd                                bra chead                                ; always
  3350                          
  3351                          
  3352                          link_error                                                ; [910103]
  3353  30f5 20dc3c                              jsr highlight_text                       ; [911119]
  3354  30f8 207dff                              jsr _primm
  3355  30fb 0d3f50524f475241...                 !text cr,"?PROGRAM MANGLED",cr,0
  3356  310e 20cb3c                              jsr highlight_done                       ; [911119]
  3357                          
  3358                          
  3359  3111 60                 lnkrts           rts
  3360                          
  3361                          ;[[command.input.handler]]
  3362                          
  3363                          
  3364                          ; Function to get a line one character at a time from the input
  3365                          ; channel and build it in the input buffer.
  3366                          ;
  3367                          
  3368                          PromptedInput                                             ; qinlin.
  3369  3112 a515                                lda channl                               ; entry for things line INPUT, wanting a prompt
  3370  3114 d006                                bne InputLine                            ; prompt only if terminal
  3371  3116 206238                              jsr outqst                               ; yes- print '? '
  3372  3119 205f38                              jsr realsp
  3373                          
  3374                          
  3375                          InputLine                                                 ; inlin.
  3376  311c a200                                ldx #0                                   ; read & buffer data until 'return' or buffer full
  3377  311e 204368             l28_1            jsr inchr                                ; get a character
  3378  3121 c900                                cmp #0
  3379  3123 f00f                                beq l28_2
  3380  3125 c90d                                cmp #cr                                  ; a carriage return?
  3381  3127 f00b                                beq l28_2                                ; yes...done build
  3382                          
  3383  3129 9d0002                              sta buf,x                                ; no...buffer it
  3384  312c e8                                  inx
  3385  312d e0a1                                cpx #buflen                              ; buffer full?
  3386  312f 90ed                                bcc l28_1                                ; no...continue
  3387  3131 833d45                              +lbra errlen                             ; yes...string too long error
  3388                          
  3389                          
  3390  3134 a900               l28_2            lda #0                                   ; fininl.  terminate input with a null
  3391  3136 9d0002                              sta buf,x
  3392  3139 a2ff                                ldx #<buf_txtptr                         ; set up pointer to start of buffer-1 (for chrget)
  3393  313b a001                                ldy #>buf_txtptr
  3394  313d a515                                lda channl                               ; print 'return' only if terminal
  3395  313f f3b606                              +lbeq crdo
  3396  3142 60                                  rts
  3397                          
  3398                          ;.end
  3399                          
  3400                          ;[[stack]]
  3401                          
  3402                          
  3403                          
  3404                          ; Find a specific token in the run-time stack. token to be found is in srchtk.
  3405                          ;
  3406                          ; If called by 'for' or 'next', scan entries in stack, looking for a specific
  3407                          ; 'for-variable' (in (forpnt)).  If found, (fndpnt) will point to it, and z is
  3408                          ; set.  Otherwise, (fndpnt) will point to either:
  3409                          ;  1) the non-for token
  3410                          ;  2) bottom-of-stack
  3411                          ;
  3412                          ; Special case: 'next' with no argument will match first 'for' entry on stack
  3413                          ; found, if any.  This case is signaled by a (forpnt) with a msb of $ff (an
  3414                          ; impossible value).
  3415                          ;
  3416                          ; All other calls to search will result in either:
  3417                          ;  1) (success) z = 1, (fndpnt) = address
  3418                          ;  2) (failure) z = 0
  3419                          
  3420                          
  3421                          ; Set up temporary pointer with current top of stack
  3422                          
  3423  3143 8502               search           sta srchtk                               ; save token to search for
  3424  3145 20dd31                              jsr movtos                               ; tos => fndpnt
  3425                          
  3426                          
  3427                          ; Test if pointer is at bottom of stack.  If so, the item was not found.
  3428                          
  3429  3148 a53f               l29_1            lda fndpnt
  3430  314a c9ff                                cmp #<stkbot
  3431  314c d006                                bne l29_2                                ; (fndpnt) <> bottom, ok
  3432  314e a540                                lda fndpnt+1                             ; lsb's the same, test msb's
  3433  3150 c905                                cmp #>stkbot
  3434  3152 f03d                                beq l29_6                                ; stack empty, rts
  3435                          
  3436  3154 a000               l29_2            ldy #0
  3437  3156 a502                                lda srchtk                               ; what are we looking for?
  3438  3158 c981                                cmp #for_token                           ; 'for' tokens are special cases
  3439  315a d01b                                bne l29_4
  3440                          
  3441                          ; Looking for a 'for' token.  If next token examined is not a 'for' token,
  3442                          ; return with z = 0.  Otherwise, check the pointer to its 'for' variable.
  3443                          ; If the variable pointer = (forpnt) or if (forpnt) = $FFxx, return with z=1.
  3444                          ; Otherwise, set up x with length of a 'for' entry, and use the usual
  3445                          ; mechanisim for examining the next entry.
  3446                          
  3447  315c d13f                                cmp (fndpnt),y                           ; indirect ok- looking at runtime stack????
  3448  315e d033                                bne l29_7                                ; not 'for', do rts with z = 0
  3449  3160 a002                                ldy #2                                   ; point to msb of 'for' variable
  3450  3162 a54c                                lda forpnt+1
  3451  3164 c9ff                                cmp #$ff
  3452  3166 f02b                                beq l29_7                                ; do rts with z = 1
  3453  3168 d13f                                cmp (fndpnt),y
  3454  316a d007                                bne l29_3                                ; not right variable, keep looking.
  3455  316c 88                                  dey
  3456  316d a54b                                lda forpnt                               ; test lsb
  3457  316f d13f                                cmp (fndpnt),y
  3458  3171 f020                                beq l29_7                                ; a hit! rts with z = 1
  3459                          
  3460  3173 a212               l29_3            ldx #lenfor
  3461  3175 800e                                bra l29_5                                ; keep looking
  3462                          
  3463  3177 b13f               l29_4            lda (fndpnt),y
  3464  3179 c502                                cmp srchtk                               ; is this the correct type of entry?
  3465  317b f016                                beq l29_7                                ; rts with z = 1
  3466                          
  3467                          ; The entry on top of the run-time stack is not the entry we are looking for.
  3468                          ; Find out what is there, and advance temp. pointer past it.
  3469                          
  3470  317d a212                                ldx #lenfor                              ; is it a 'for' entry?
  3471  317f c981                                cmp #for_token
  3472  3181 f002                                beq l29_5
  3473  3183 a205                                ldx #5                                   ; must be gosub or do by default
  3474                          
  3475  3185 8a                 l29_5            txa
  3476  3186 18                                  clc
  3477  3187 653f                                adc fndpnt
  3478  3189 853f                                sta fndpnt
  3479  318b 90bb                                bcc l29_1
  3480  318d e640                                inc fndpnt+1
  3481  318f 80b7                                bra l29_1                                ; always
  3482                          
  3483  3191 a001               l29_6            ldy #1                                   ; clear z flag
  3484  3193 60                 l29_7            rts
  3485                          
  3486                          
  3487                          ; GETSTK
  3488                          ;
  3489                          ; Add (.A) elements to top of run-time stack.  Error if result exceeds tos.
  3490                          
  3491  3194 49ff               getstk           eor #$ff                                 ; make value 2's comp.
  3492  3196 38                                  sec
  3493  3197 657c                                adc tos
  3494  3199 857c                                sta tos
  3495  319b a47d                                ldy tos+1
  3496  319d b001                                bcs l30_1
  3497  319f 88                                  dey
  3498  31a0 847d               l30_1            sty tos+1
  3499  31a2 c004                                cpy #>stktop
  3500  31a4 939bfc                              +lbcc omerr
  3501  31a7 d005                                bne l30_2
  3502  31a9 c57c                                cmp tos
  3503  31ab 9394fc                              +lbcc omerr
  3504  31ae 60                 l30_2            rts
  3505                          
  3506                          
  3507                          ; (a,y) is a certain address.  REASON makes sure it is less than (fretop).
  3508                          
  3509  31af c436               reason           cpy fretop+1
  3510  31b1 9029                                bcc l31_4
  3511  31b3 d004                                bne l31_1                                ; go garbage collect
  3512  31b5 c535                                cmp fretop
  3513  31b7 9023                                bcc l31_4
  3514                          
  3515  31b9 48                 l31_1            pha
  3516  31ba a209                                ldx #9                                   ; if tempf2 has zero in between
  3517  31bc 98                                  tya
  3518                          
  3519  31bd 48                 l31_2            pha
  3520  31be b559                                lda highds-1,x                           ; save highds on stack
  3521  31c0 ca                                  dex
  3522  31c1 10fa                                bpl l31_2                                ; put 8 of them on stack
  3523  31c3 20335c                              jsr garba2                               ; go garbage collect
  3524  31c6 a2f7                                ldx #$f7
  3525                          
  3526  31c8 68                 l31_3            pla
  3527  31c9 9563                                sta highds+9,x                           ; restore after garbage collect
  3528  31cb e8                                  inx
  3529  31cc 30fa                                bmi l31_3
  3530  31ce 7a                                  ply
  3531  31cf 68                                  pla                                      ; restore .a and .y
  3532  31d0 c436                                cpy fretop+1                             ; compare highs
  3533  31d2 9008                                bcc l31_4
  3534  31d4 d36bfc                              +lbne omerr                              ; higher is bad
  3535  31d7 c535                                cmp fretop                               ; compare the lows
  3536  31d9 b366fc                              +lbcs omerr
  3537  31dc 60                 l31_4            rts
  3538                          
  3539                          
  3540                          
  3541                          ;  Utilities involved in the operation of the BASIC run-time stack.
  3542                          
  3543                          
  3544                          ; Move top-of-stack pointer to (fndpnt)
  3545                          
  3546  31dd a57c               movtos           lda tos
  3547  31df 853f                                sta fndpnt
  3548  31e1 a57d                                lda tos+1
  3549  31e3 8540                                sta fndpnt+1
  3550  31e5 60                                  rts
  3551                          
  3552                          
  3553                          
  3554                          ; move (fndpnt) to (tos)
  3555                          
  3556  31e6 a53f               movfnd           lda fndpnt
  3557  31e8 857c                                sta tos
  3558  31ea a540                                lda fndpnt+1
  3559  31ec 857d                                sta tos+1
  3560  31ee 60                                  rts
  3561                          
  3562                          ; Reduce size of run-time stack by (y).  No error checking performed!
  3563                          
  3564  31ef 98                 rlsstk           tya
  3565  31f0 18                                  clc
  3566  31f1 657c                                adc tos
  3567  31f3 857c                                sta tos
  3568  31f5 9002                                bcc l32_1
  3569  31f7 e67d                                inc tos+1
  3570  31f9 60                 l32_1            rts
  3571                          
  3572                          ;.end
  3573                          ;[[linesearch]]
  3574                          
  3575                          
  3576                          
  3577                          
  3578                          ; FindLine
  3579                          ; Searches the program text for the line whose number is passed in "linnum".
  3580                          ; There are two possible returns:
  3581                          ;
  3582                          ; 1) carry set.
  3583                          ;  Line found.  (lowtr) points to the link bytes of line sought.
  3584                          ;
  3585                          ; 2) carry clear.
  3586                          ;  Line not found.  (lowtr) points to the link bytes of the next
  3587                          ;  line greater than the one sought.
  3588                          
  3589                          FindLine
  3590  31fa a52d                                lda txttab                               ; init pointer to beginning of program
  3591  31fc a62e                                ldx txttab+1
  3592                          
  3593                          FindLink
  3594  31fe 8561                                sta lowtr                                ; current position in program
  3595  3200 8662                                stx lowtr+1
  3596  3202 a001                                ldy #1
  3597  3204 20ad22                              jsr indlow                               ; end of program (null link)?
  3598  3207 f023                                beq l33_3                                ; yes, exit with .c=0 (not found)
  3599  3209 c8                                  iny
  3600  320a c8                                  iny
  3601  320b 20ad22                              jsr indlow                               ; get line number of this line (high byte first)
  3602                          ; sta syntmp
  3603                          ; lda linnum+1 ;is this the line we're looking for?
  3604                          ; cmp syntmp
  3605                          ; bcc l33_4  ; no- too high, so the line does not exist, exit
  3606                          ; beq l33_1
  3607                          ; dey  ; no- too low, so get link to next line
  3608                          ; bra l33_2
  3609  320e c517                                cmp linnum+1                             ; is this the line we're looking for?   [910925]
  3610  3210 f005                                beq l33_1                                ; maybe
  3611  3212 b018                                bcs l33_3                                ; no- too high, so the line does not exist, exit with .c=0
  3612  3214 88                                  dey                                      ; no- too low, so get link to next line
  3613  3215 800a                                bra l33_2
  3614                          
  3615  3217 88                 l33_1            dey                                      ; maybe- have to check low byte
  3616  3218 20ad22                              jsr indlow
  3617                          ; sta syntmp
  3618                          ; lda linnum
  3619                          ; cmp syntmp
  3620                          ; bcc l33_4  ; no- too high, exit
  3621                          ; beq l33_4  ; yes- got it, exit
  3622  321b c516                                cmp linnum                               ; is this the line we're looking for?   [910925]
  3623  321d f00e                                beq l33_4                                ; yes- got it, exit with .c=1
  3624  321f b00b                                bcs l33_3                                ; no- too high, so the line does not exist, exit with .c=0
  3625                          
  3626  3221 88                 l33_2            dey                                      ; get link to next line
  3627  3222 20ad22                              jsr indlow
  3628  3225 aa                                  tax
  3629  3226 88                                  dey
  3630  3227 20ad22                              jsr indlow
  3631  322a 80d2                                bra FindLink                             ; continue looking
  3632                          
  3633                          
  3634  322c 18                 l33_3            clc                                      ; exit, line not found (.c=0)
  3635  322d 60                 l33_4            rts                                      ; exit, line found (.c=1)
  3636                          
  3637                          ;.end
  3638                          ;[[command.line.get]]
  3639                          
  3640                          
  3641                          
  3642                          
  3643                          ; LINGET  Reads a line # from the current txtptr position
  3644                          ;   and stores it in linnum  (valid range is 0-63999).
  3645                          ;
  3646                          ;   On exit txtptr is pointing to the terminating char
  3647                          ;   which is in .a with condition codes set.
  3648                          ;   Endchr will be =0 if no digit input, else >0.  Use it
  3649                          ;   to distinguish between line # 0 & null input.
  3650                          
  3651  322e a200               linget           ldx #0                                   ; enter with CHRGET flags set
  3652  3230 860b                                stx endchr                               ; flags line # input
  3653  3232 8616                                stx linnum                               ; init line # to 0
  3654  3234 8617                                stx linnum+1
  3655                          
  3656  3236 b04b               l34_1            bcs l34_5                                ; it's not a digit, do rts
  3657  3238 e60b               l34_2            inc endchr                               ; indicate line # input
  3658  323a e92f                                sbc #$2f                                 ; '0'-1 since .c=0
  3659  323c 850a                                sta charac                               ; save for later
  3660  323e a517                                lda linnum+1
  3661  3240 8524                                sta index
  3662  3242 c919                                cmp #25                                  ; line number will be < 64000?
  3663  3244 9006                                bcc l34_3                                ; yes, continue
  3664  3246 9f553a                              bbs1 helper,l34_5                        ; no, if called by AutoScroll it's okay
  3665  3249 83fffb                              +lbra snerr                              ; else syntax error
  3666                          
  3667  324c a516               l34_3            lda linnum
  3668  324e 0a                                  asl                                      ; multiply by 10
  3669  324f 2624                                rol index
  3670  3251 0a                                  asl
  3671  3252 2624                                rol index
  3672  3254 6516                                adc linnum
  3673  3256 8516                                sta linnum
  3674  3258 a524                                lda index
  3675  325a 6517                                adc linnum+1
  3676  325c 8517                                sta linnum+1
  3677  325e 0616                                asl linnum
  3678  3260 2617                                rol linnum+1
  3679  3262 a516                                lda linnum
  3680  3264 650a                                adc charac                               ; add in digit
  3681  3266 8516                                sta linnum
  3682  3268 9002                                bcc l34_4
  3683  326a e617                                inc linnum+1
  3684                          l34_4
  3685                          ; jsr chrget  ;ALLOW SPACES to terminate number  [910620]
  3686                          ; bra l34_1
  3687  326c e33d                                inw txtptr                               ; get next character from text
  3688  326e a000                                ldy #0                                   ; re-get current character from text
  3689  3270 20c522                              jsr indtxt                               ; lda (txtptr),y from RAM0
  3690  3273 c920                                cmp #' '                                 ; space=eol    [910708]
  3691  3275 f00d                                beq l34_6
  3692  3277 c93a                                cmp #':'                                 ;
  3693  3279 b008                                bcs l34_5                                ; eol
  3694  327b 38                                  sec
  3695  327c e930                                sbc #'0'                                 ; alpha or numeric?
  3696  327e 38                                  sec
  3697  327f e9d0                                sbc #$d0
  3698  3281 90b5                                bcc l34_2                                ; numeric
  3699  3283 60                 l34_5            rts                                      ; exit
  3700                          
  3701  3284 20a540             l34_6            jsr chargt                               ; terminating character is a space, eat it just this once
  3702  3287 8305f0                              +lbra chrtst                             ; return with flags set appropriately (esp. for 'range')
  3703                          
  3704                          ;.end
  3705                          
  3706                          ;[[command.list]]
  3707                          
  3708                          
  3709                          
  3710  328a 7755               list             rmb7 helper                              ; clear 'help' flag for p1line
  3711                          
  3712                          ; Determine which form of LIST we have...
  3713                          
  3714  328c f3aa00                              +lbeq list_memory                        ; branch if terminator (no parameter)
  3715  328f 93a700                              +lbcc list_memory                        ; branch if a number (assume range parameter)
  3716  3292 c9ab                                cmp #minus_token
  3717  3294 f3a200                              +lbeq list_memory                        ; branch if a dash (assume range parameter)
  3718                          
  3719                          
  3720                          ; LIST command is of the form  LIST filename [,U#] [,D#]
  3721                          
  3722                          list_file
  3723  3297 a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
  3724  3299 202074                              jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 )
  3725  329c 20dc77                              jsr chk1                                 ; check parameters
  3726  329f a900                                lda #0
  3727  32a1 8d8311                              sta dossa                                ; setup as dload would (0 = load channel)
  3728  32a4 201d71                              jsr find_la                              ; find an available la to use (cannot use reserved one)
  3729  32a7 a009                                ldy #fopn
  3730  32a9 a204                                ldx #4
  3731  32ab 20fd70                              jsr open_file                            ; open the file
  3732  32ae b077                                bcs list_err                             ; exit if error
  3733                          
  3734  32b0 ae8111                              ldx dosla
  3735  32b3 20c6ff                              jsr _chkin                               ; get input channel
  3736  32b6 b06f                                bcs list_err                             ; exit if bad??
  3737  32b8 20cfff                              jsr _basin                               ; waste 'load address'
  3738  32bb 20cfff                              jsr _basin
  3739                          
  3740  32be 20cfff             l35_1            jsr _basin                               ; get link bytes
  3741  32c1 8d0013                              sta dosstr
  3742  32c4 20cfff                              jsr _basin
  3743  32c7 8d0113                              sta dosstr+1
  3744  32ca 0d0013                              ora dosstr
  3745  32cd f051                                beq list_exit                            ; done if null pointer
  3746  32cf 20b7ff                              jsr _readst
  3747  32d2 d04c                                bne list_exit                            ; done if eof or bad status
  3748                          ; ???? assumes serial bus
  3749  32d4 a913                                lda #>dosstr                             ; point p1line's pointer at our line buffer
  3750  32d6 a200                                ldx #<dosstr
  3751  32d8 8562                                sta lowtr+1
  3752  32da 8661                                stx lowtr
  3753                          
  3754  32dc a202                                ldx #2
  3755  32de 20cfff                              jsr _basin                               ; read line into buffer
  3756  32e1 9d0013                              sta dosstr,x
  3757  32e4 e8                                  inx
  3758  32e5 20cfff                              jsr _basin                               ; 2-byte line #
  3759  32e8 9d0013                              sta dosstr,x
  3760  32eb e8                                  inx
  3761  32ec e0ff               l35_2            cpx #255                                 ; check buffer (buflen????)
  3762  32ee b38043                              +lbcs errlen                             ; 'too long' error
  3763  32f1 20cfff                              jsr _basin
  3764  32f4 9d0013                              sta dosstr,x
  3765  32f7 e8                                  inx
  3766  32f8 a8                                  tay                                      ; save char
  3767  32f9 20b7ff                              jsr _readst                              ; check channel status (serial bus????)
  3768  32fc d022                                bne list_exit                            ; exit if eof or error
  3769  32fe 20e1ff                              jsr _stop
  3770  3301 f01d                                beq list_exit                            ; exit if stop key down
  3771  3303 98                                  tya
  3772  3304 d0e6                                bne l35_2                                ; loop until eol
  3773                          
  3774  3306 20c770                              jsr dcato                                ; get output channel
  3775  3309 20f737                              jsr crdo                                 ; start new line
  3776  330c ae0213                              ldx dosstr+2                             ; get line #
  3777  330f ad0313                              lda dosstr+3
  3778  3312 207733                              jsr p1line                               ; print line #, space, and the line of code
  3779  3315 20ccff                              jsr _clrch
  3780  3318 ae8111                              ldx dosla
  3781  331b 20c6ff                              jsr _chkin                               ; get input channel
  3782  331e 909e                                bcc l35_1                                ; [900730]
  3783                          
  3784                          list_exit
  3785  3320 20c770                              jsr dcato                                ; flush last line with a <cr>
  3786  3323 20f737                              jsr crdo                                 ; flush current line
  3787  3326 18                                  clc                                      ; no errors    [910404]
  3788                          list_err
  3789  3327 08                                  php                                      ; save error status   [910404]
  3790  3328 48                                  pha
  3791  3329 20b438                              jsr release_channels                     ; release cmd channel, restore terminal
  3792  332c ad8111                              lda dosla
  3793                          ; bra close_out  ;    removed [900725]
  3794  332f 18                                  clc                                      ; a real close   new [910404]
  3795  3330 20c3ff                              jsr _close
  3796  3333 68                                  pla                                      ; pop error status, if any
  3797  3334 28                                  plp
  3798  3335 833735                              +lbra exit_disk_op
  3799                          
  3800                          
  3801                          ; LIST command is of the form  LIST [range]
  3802                          
  3803                          list_memory
  3804  3338 205042                              jsr range                                ; set up line range
  3805                          
  3806  333b a001               l36_1            ldy #1
  3807  333d 20ad22                              jsr indlow                               ; get ms byte of line to list's pointer
  3808  3340 d007                                bne l36_2                                ; ok if not zero, but..
  3809  3342 88                                  dey
  3810  3343 20ad22                              jsr indlow
  3811  3346 f3af04                              +lbeq crdo                               ; ..if ls byte is also zero, we're done
  3812                          
  3813  3349 20cc2c             l36_2            jsr is_stop_key_down
  3814  334c 20f737                              jsr crdo                                 ; new line
  3815  334f a002                                ldy #2
  3816  3351 20ad22                              jsr indlow                               ; get ms byte of line number
  3817  3354 aa                                  tax
  3818  3355 c8                                  iny
  3819  3356 20ad22                              jsr indlow                               ; get ls byte
  3820                          
  3821  3359 c517                                cmp linnum+1                             ; test if we are past the last line requested
  3822  335b d004                                bne l36_3
  3823  335d e416                                cpx linnum
  3824  335f f003                                beq l36_4
  3825  3361 b39404             l36_3            +lbcs crdo                               ; next line is > last line requested, exit
  3826  3364 207733             l36_4            jsr p1line                               ; print line #, space, and the line of code
  3827  3367 a000                                ldy #0                                   ; move 'pointer to next line' into (lowtr)
  3828  3369 20ad22                              jsr indlow
  3829  336c aa                                  tax
  3830  336d c8                                  iny
  3831  336e 20ad22                              jsr indlow
  3832  3371 8661                                stx lowtr
  3833  3373 8562                                sta lowtr+1
  3834  3375 80c4                                bra l36_1
  3835                          
  3836                          ;[[command.list.basic]]
  3837                          
  3838                          
  3839                          ;******************************************************
  3840                          ; P1LINE Print 1 line of BASIC text
  3841                          ;
  3842                          ; Entry: (a,x) contains line number low,high
  3843                          ;  (lowtr) points to beginning of line
  3844                          ;
  3845                          ; next-line   line-num  BASIC text......  null
  3846                          ; lo    hi    lo    hi  byte byte...byte   00
  3847                          ;        ^           ^     ^
  3848                          ;    (lowtr)        .A    .X
  3849                          ;******************************************************
  3850                          
  3851  3377 4f7e03             p1line           bbr4 runmod,l37_1                        ; [910620]
  3852  337a 837a89                              +lbra edit_p1line                        ; handle things differently for plain text
  3853                          
  3854  337d a003               l37_1            ldy #3
  3855  337f 844b                                sty lstpnt
  3856  3381 8411                                sty dores                                ; reset quote-switch
  3857  3383 207f64                              jsr linprt                               ; print line number
  3858  3386 a920                                lda #' '                                 ; print a space
  3859                          
  3860  3388 a44b               p1l010           ldy lstpnt
  3861  338a 297f                                and #$7f
  3862                          
  3863  338c c93a               p1l015           cmp #':'                                 ; end-of-stmt?     [900516]
  3864  338e d00b                                bne l38_1                                ; no
  3865  3390 7f5508                              bbr7 helper,l38_1                        ; yes, but skip e-o-s check if not HELP...
  3866  3393 ff1105                              bbs7 dores,l38_1                         ; or ':' is inside quotes
  3867  3396 20cb3c                              jsr highlight_done                       ; yes, restore normal text color
  3868  3399 a93a                                lda #':'
  3869                          
  3870  339b 203d68             l38_1            jsr outch                                ; outdo
  3871  339e c922                                cmp #'"'                                 ; if quote character, toggle quote-switch
  3872  33a0 d006                                bne l38_2
  3873  33a2 a511                                lda dores
  3874  33a4 49ff                                eor #$ff
  3875  33a6 8511                                sta dores
  3876                          
  3877  33a8 c8                 l38_2            iny                                      ; point to next character (should never wrap)
  3878  33a9 8f5506                              bbs0 helper,l38_3                        ; branch if highlighting tokens
  3879  33ac df5503                              bbs5 helper,l38_3                        ; branch if called by FIND/CHANGE
  3880  33af 7f5503                              bbr7 helper,l38_4                        ; branch if called by LIST or HELP satisfied
  3881  33b2 20963c             l38_3            jsr helpsb
  3882                          
  3883  33b5 20ad22             l38_4            jsr indlow
  3884  33b8 f31109                              +lbeq highlight_done                     ; finished when trailing null is found
  3885  33bb 6c0603                              jmp (iqplop)                             ; usually points to nqplop
  3886                          
  3887                          
  3888                          nqplop                                                    ; <<<<<<< vector entry
  3889  33be 10cc                                bpl p1l015                               ; not a token, just print character
  3890  33c0 ff11c9                              bbs7 dores,p1l015                        ; branch if inside quotes, print chr as is
  3891                          
  3892                          ;  At this point, we know we're talking token.  Scan the token text
  3893                          ;  list until the correct text is found, and print that text.
  3894                          
  3895  33c3 8554                                sta token_saver                          ; save token for REM check   [910626]
  3896  33c5 c9fe                                cmp #esc_command_token                   ; is this an escape token?
  3897  33c7 f042                                beq print_esc_cmd                        ; yes- escape command
  3898  33c9 c9ce                                cmp #esc_function_token
  3899  33cb f059                                beq print_esc_fn                         ; yes- escape function
  3900  33cd c9ff                                cmp #pi
  3901  33cf f0bb                                beq p1l015                               ; no- pi is >$80, but should be printed 'as is'
  3902  33d1 aa                                  tax
  3903  33d2 844b                                sty lstpnt                               ; no- use the token as index into ROM keyword list
  3904  33d4 a924                                lda #>keyword_list
  3905  33d6 a03a                                ldy #<keyword_list
  3906                          
  3907                          ; Scan list pointed to by (y,a) for token in (x), and print token's text
  3908                          
  3909  33d8 8525               p1l026           sta index1+1                             ; index1 points to token text list in ROM
  3910  33da 8424                                sty index1
  3911  33dc a000                                ldy #0                                   ; begin scanning lists for this token's text
  3912  33de ca                                  dex
  3913  33df 1014                                bpl p1l070                               ; what luck! it's the first one
  3914                          
  3915  33e1 e324               l39_1            inw index1                               ; scan text until next command found
  3916  33e3 b124                                lda (index1),y                           ; ind.ok (ROM)
  3917  33e5 10fa                                bpl l39_1                                ; loop until terminal char (msb=1)
  3918  33e7 ca                                  dex                                      ; is next text the one we want?
  3919  33e8 30f7                                bmi l39_1                                ; no, keep scanning
  3920  33ea e324                                inw index1                               ; yes, point to first character
  3921                          
  3922  33ec 3f5506                              bbr3 helper,p1l070                       ; found text for this token, is it REM?  [910626]
  3923  33ef a554                                lda token_saver                          ; [910628]
  3924  33f1 c98f                                cmp #rem_token
  3925  33f3 f009                                beq p1l071                               ; yes, and REM highlighting is enabled
  3926                          
  3927                          p1l070                                                    ; found text for this token
  3928  33f5 4f5509                              bbr4 helper,p1l072                       ; branch if not highlighting tokens
  3929  33f8 b124                                lda (index1),y                           ; peek at first character
  3930  33fa 308c                                bmi p1l010                               ; branch if operator (1-byte, msb=1)
  3931  33fc 8755                                smb0 helper                              ; else begin highlight
  3932  33fe 20dc3c             p1l071           jsr highlight_text
  3933                          
  3934  3401 b124               p1l072           lda (index1),y                           ; get char from ROM table
  3935  3403 3083                                bmi p1l010                               ; msb=1=last char this token, contine line
  3936  3405 203d68                              jsr outch                                ; else print it
  3937  3408 c8                                  iny
  3938  3409 80f6                                bra p1l072
  3939                          
  3940                          
  3941                          ; Print Escape Command
  3942                          
  3943                          print_esc_cmd
  3944  340b aa                                  tax                                      ; save type (cmd) in case it is a foreign esc token
  3945  340c c8                                  iny
  3946  340d 20ad22                              jsr indlow                               ; look at second token
  3947  3410 f37aff                              +lbeq p1l015                             ; none?  print funny character
  3948  3413 844b                                sty lstpnt
  3949  3415 c902                                cmp #first_esc_command_token             ; is this one of ours?
  3950  3417 9028                                bcc print_foreign_esc                    ; nope
  3951  3419 c946                                cmp #last_esc_command_token+1
  3952  341b b024                                bcs print_foreign_esc                    ; nope
  3953  341d 697e                                adc #$80-first_esc_command_token         ; yes- make a pointer p1l will be proud of
  3954  341f aa                                  tax
  3955  3420 a029                                ldy #<esc_command_list
  3956  3422 a926                                lda #>esc_command_list
  3957  3424 80b2                                bra p1l026                               ; go scan list and print it
  3958                          
  3959                          
  3960                          
  3961                          ; Print Escape Function
  3962                          
  3963                          print_esc_fn
  3964  3426 aa                                  tax                                      ; save type (function) in case it's a foreign esc token
  3965  3427 c8                                  iny
  3966  3428 20ad22                              jsr indlow                               ; look at second token
  3967  342b f35fff                              +lbeq p1l015                             ; none?  print funny character
  3968  342e 844b                                sty lstpnt
  3969  3430 c902                                cmp #first_esc_function_token            ; is this one of ours?
  3970  3432 900d                                bcc print_foreign_esc                    ; nope
  3971  3434 c90e                                cmp #last_esc_function_token+1
  3972  3436 b009                                bcs print_foreign_esc                    ; nope
  3973  3438 697e                                adc #$80-first_esc_function_token        ; yes- make a pointer p1l will be proud of
  3974  343a aa                                  tax
  3975  343b a09a                                ldy #<esc_function_list
  3976  343d a927                                lda #>esc_function_list
  3977  343f 8097                                bra p1l026                               ; go scan list and print it
  3978                          
  3979                          
  3980                          ; The token to be printed is an escape token which is NOT recognized by BASIC.
  3981                          ; We will jump through the indirect chain and see if anyone claims this token.
  3982                          ;
  3983                          ; At this point:
  3984                          ; .C = 1 to signal 'unclaimed'
  3985                          ; .X = type (0==>command, ff==>function)
  3986                          ; .A = second token character
  3987                          ;
  3988                          ; If anyone claims this token, they should:
  3989                          ;
  3990                          ; > Clear .C to flag 'taken'
  3991                          ; > Point (INDEX1) at the string to be printed (with msb of last char set)
  3992                          ; > Note: string to print MUST be in RAM-0!
  3993                          
  3994                          print_foreign_esc
  3995  3441 e0fe                                cpx #esc_command_token
  3996  3443 d003                                bne l40_1
  3997  3445 a200                                ldx #0
  3998  3447 2c                                  !text $2c
  3999                          
  4000  3448 a2ff               l40_1            ldx #$ff
  4001  344a 38                                  sec
  4002  344b 6c0e03                              jmp (iescpr)
  4003                          
  4004  344e b33cff             nescpr           +lbcs p1l015                             ; no takers, print a funny graphic character
  4005  3451 a000                                ldy #0
  4006  3453 80a0                                bra p1l070
  4007                          
  4008                          
  4009                          ;.end
  4010                          ;[[command.newclr]]
  4011                          
  4012                          
  4013                          
  4014                          ;
  4015                          ; The NEW command clears the program text as well as variable space.
  4016                          ;
  4017                          
  4018  3455 f021               new              beq init_text                            ; Erase program in memory
  4019  3457 c98c                                cmp #restore_token                       ; Restore an erased program?    [910103]
  4020  3459 d3eff9                              +lbne snerr                              ; no- syntax error    [910410]
  4021  345c 2022b5                              jsr chkeos                               ; yes- eat token, error if not eos  [910429]
  4022  345f a52d                                lda txttab                               ; "seed" first link to fool 'chead'
  4023  3461 a62e                                ldx txttab+1
  4024  3463 8524                                sta index
  4025  3465 8625                                stx index+1
  4026  3467 a900                                lda #0
  4027  3469 a001                                ldy #1
  4028  346b a224                                ldx #index
  4029  346d 200c23                              jsr sta_far_ram0                         ; clear msb  (bleed-thru)
  4030  3470 88                                  dey
  4031  3471 1a                                  inc
  4032  3472 200c23                              jsr sta_far_ram0                         ; set lsb   (bleed-thru)
  4033  3475 839c09                              +lbra renumber                           ; make renumber check it for us (not 100%) & relink
  4034                          
  4035                          
  4036                          init_text
  4037  3478 a52d                                lda txttab                               ; find the bottom of basic text
  4038  347a a62e                                ldx txttab+1
  4039  347c 8524                                sta index
  4040  347e 8625                                stx index+1
  4041  3480 c324                                dew index                                ; (the absolute bottom)
  4042                          
  4043  3482 a900                                lda #0
  4044  3484 a8                                  tay
  4045  3485 a224                                ldx #index
  4046  3487 200c23                              jsr sta_far_ram0                         ; clear bottom     (bleed-thru)
  4047  348a c8                                  iny
  4048  348b 200c23                              jsr sta_far_ram0                         ; clear first link bytes    (bleed-thru)
  4049  348e c8                                  iny
  4050  348f 200c23                              jsr sta_far_ram0                         ; (bleed-thru)
  4051  3492 18                                  clc
  4052  3493 a52d                                lda txttab
  4053  3495 6902                                adc #2
  4054  3497 8582                                sta text_top                             ; set up (text_top), the end of text
  4055  3499 a52e                                lda txttab+1
  4056  349b 6900                                adc #0
  4057  349d 8583                                sta text_top+1
  4058                          
  4059  349f 577e                                rmb5 runmod                              ; trcflg. reset trace flag
  4060                          
  4061                          
  4062  34a1 201f35             runc             jsr reset_txtptr                         ; load (txtptr) with (txttab)-1
  4063  34a4 8025                                bra clearc                               ; "CLR" to clear vars    [910410]
  4064                          
  4065                          
  4066                          ; CLeaR Routines
  4067                          ;
  4068                          
  4069                          ; Special forms of CLR command:
  4070                          ;
  4071                          ; CLR ERR$ Clears program error status, useful in TRAP handlers which
  4072                          ;   have resolved an error & wish to RESUME with a clean status.
  4073                          ;
  4074                          ; CLR DS$  Clears the currently buffered DS,DS$ messages.  The next
  4075                          ;   use of DS or DS$ will make BASIC re a new message from DOS.
  4076                          
  4077  34a6 f023               clear            beq clearc                               ; branch if no args    [910410]
  4078                          
  4079  34a8 c9d3                                cmp #err_token                           ; CLR ERR$
  4080  34aa d006                                bne l41_1                                ; no
  4081  34ac 2022b5                              jsr chkeos                               ; yes- eat token & error if not eos
  4082  34af 832b10                              +lbra error_clear                        ; and go clear ERR$
  4083                          
  4084  34b2 c944               l41_1            cmp #'D'                                 ; CLR DS$     [910717]
  4085  34b4 d00c                                bne l41_2                                ; no- error
  4086  34b6 208322                              jsr chrget
  4087  34b9 c953                                cmp #'S'
  4088  34bb d005                                bne l41_2
  4089  34bd 208322                              jsr chrget
  4090  34c0 c924                                cmp #'$'
  4091  34c2 d386f9             l41_2            +lbne snerr                              ; no- error
  4092  34c5 2022b5                              jsr chkeos
  4093  34c8 83b843                              +lbra Clear_DS                           ; yes- clear current DS$
  4094                          
  4095                          
  4096                          ; Clearc is a subroutine which initializes the variable and array space by
  4097                          ; resetting STREND (the end of array storage).  It falls into INIT_STACK,
  4098                          ; which resets the stack.
  4099                          
  4100  34cb 20e7ff             clearc           jsr _clall                               ; close all files
  4101  34ce a000                                ldy #0
  4102  34d0 8479                                sty dsdesc                               ; flag 'no DS$ string'
  4103  34d2 88                                  dey                                      ; (y=$ff)
  4104  34d3 8ccb02                              sty trapno+1                             ; flag no current trap line
  4105  34d6 8cc802                              sty errlin                               ; reset last error pointers
  4106  34d9 8cc902                              sty errlin+1
  4107  34dc 8cc702                              sty errnum
  4108                          
  4109  34df a539                                lda max_mem_1                            ; clear string space
  4110  34e1 a43a                                ldy max_mem_1+1
  4111  34e3 8535                                sta fretop
  4112  34e5 8436                                sty fretop+1
  4113                          
  4114  34e7 a9ff                                lda #<stkbot                             ; empty run-time stack
  4115  34e9 a005                                ldy #>stkbot
  4116  34eb 857c                                sta tos
  4117  34ed 847d                                sty tos+1
  4118                          
  4119  34ef a52f                                lda vartab
  4120  34f1 a430                                ldy vartab+1
  4121  34f3 8531                                sta arytab                               ; this will delete all variables,
  4122  34f5 8432                                sty arytab+1
  4123  34f7 8533                                sta strend                               ; ..and arrays
  4124  34f9 8434                                sty strend+1
  4125                          
  4126  34fb a203                                ldx #pumony-puchrs                       ; reset print using chars
  4127  34fd bddb69             l42_1            lda pudefs,x
  4128  3500 9dd411                              sta puchrs,x
  4129  3503 ca                                  dex
  4130  3504 10f7                                bpl l42_1
  4131                          
  4132  3506 20fc3d             fload            jsr restore__1                           ; reset pointer for DATA statements
  4133                          
  4134                          
  4135                          ;[[stack.init]]
  4136                          
  4137                          ; INIT_STACK Routine (formerly STKINI)
  4138                          ;
  4139                          ;   Init_Stack resets the stack pointer.  String temporaries are freed up,
  4140                          ;   SUBFLG is reset, continuing is prohibited.
  4141                          
  4142                          init_stack
  4143  3509 7a                                  ply                                      ; pop return address
  4144  350a 68                                  pla
  4145  350b a2fa                                ldx #stkend-257                          ; reset system stack pointer
  4146  350d 9a                                  txs
  4147  350e 48                                  pha                                      ; push return address
  4148  350f 5a                                  phy
  4149  3510 a21b                                ldx #tempst                              ; reset string temporaries
  4150  3512 8618                                stx temppt
  4151  3514 a900                                lda #0
  4152  3516 8512                                sta subflg                               ; allow subscripted & integer vars
  4153  3518 8d7311                              sta oldtxt+1                             ; disallow continuing
  4154  351b 8dd702                              sta bits                                 ; reset math bit/byte flag
  4155                          
  4156  351e 60                 stkrts           rts
  4157                          
  4158                          
  4159                          
  4160                          reset_txtptr
  4161  351f 18                                  clc                                      ; load (txtptr) with (txttab)-1
  4162  3520 a52d                                lda txttab
  4163  3522 69ff                                adc #$ff
  4164  3524 853d                                sta txtptr
  4165  3526 a52e                                lda txttab+1
  4166  3528 69ff                                adc #$ff
  4167  352a 853e                                sta txtptr+1                             ; set up text pointers
  4168  352c 60                                  rts
  4169                          
  4170                          ;.end
  4171                          ;[[command.return]]
  4172                          
  4173                          
  4174                          
  4175                          ;*********************************************************************
  4176                          ; RETURN Routine
  4177                          ;
  4178                          ; Restores the line number and text pointer from the stack, and
  4179                          ; eliminates all the FOR entries in front of the GOSUB entry.
  4180                          ;
  4181                          ;*********************************************************************
  4182                          
  4183                          return
  4184                          
  4185                          ; Ok, pay attention: we got here by a pseudo-jsr which left a return to NEWSTT
  4186                          ; on the stack for us to return to.  There is also a return to NEWSTT left on
  4187                          ; the stack from the GOSUB we are returning from.  This is true UNLESS we got
  4188                          ; here on a sprite collision, in which case we still have the NEWSUB return
  4189                          ; recently left by our current call, but the second return goes back to the
  4190                          ; trapping mechanism.  The bottom line is: we have an extra return address on
  4191                          ; the stack, which we have to get rid of before leaving.
  4192                          
  4193  352d 68                                  pla                                      ; mea culpa, mea culpa, mea culpa
  4194  352e 68                                  pla
  4195  352f a98d                                lda #gosub_token
  4196  3531 204331                              jsr search                               ; look for GOSUB on runtime stack
  4197  3534 f005                                beq ret010                               ; found
  4198  3536 a20c                                ldx #errrg                               ; else error
  4199  3538 8315f9                              +lbra error
  4200                          
  4201  353b 20e631             ret010           jsr movfnd                               ; (fndpnt) => (tos)
  4202  353e a005                                ldy #lengos
  4203  3540 20ef31                              jsr rlsstk                               ; effectivly pop GOSUB off run-time stack
  4204                          ; dey
  4205                          ; lda (fndpnt),y
  4206                          ; sta txtptr+1
  4207                          ; dey
  4208                          ; lda (fndpnt),y
  4209                          ; sta txtptr
  4210                          ; dey
  4211                          ; lda (fndpnt),y
  4212  3543 204279                              jsr retpat                               ; 01/18/84 patch: correct RETURN to GOSUB from direct mode
  4213                          ; lda (fndpnt),y
  4214                          ; sta curlin ;jump to DATA to waste rest of stmt (in case of ON..GOSUB)
  4215  3546 8000                                bra data
  4216                          
  4217                          ;.end
  4218                          ;[[command.data]]
  4219                          
  4220                          
  4221                          
  4222                          
  4223                          data
  4224  3548 205b35                              jsr datan                                ; skip to end of statement- offset in .y
  4225  354b 98                 addon            tya
  4226  354c 18                                  clc
  4227  354d 653d                                adc txtptr                               ; add offset to end to txtptr
  4228  354f 853d                                sta txtptr
  4229  3551 9002                                bcc remrts
  4230  3553 e63e                                inc txtptr+1
  4231  3555 60                 remrts           rts                                      ; NEWSTT rts addr is still there
  4232                          
  4233                          
  4234                          
  4235  3556 205e35             rem              jsr remn                                 ; skip rest of statement
  4236  3559 80f0                                bra addon                                ; will always branch
  4237                          
  4238                          
  4239  355b a23a               datan            ldx #':'                                 ; DATA terminates on ":" and null
  4240  355d 2c                                  !text $2c
  4241                          
  4242  355e a200               remn             ldx #0                                   ; REM terminates on null only
  4243  3560 860a                                stx charac                               ; preserve terminator
  4244  3562 a000                                ldy #0                                   ; this makes charac=0 after swap
  4245  3564 840b                                sty endchr
  4246                          
  4247  3566 a50b               l43_1            lda endchr
  4248  3568 a60a                                ldx charac
  4249  356a 850a                                sta charac
  4250  356c 860b                                stx endchr
  4251  356e 20c522             l43_2            jsr indtxt
  4252  3571 f0e2                                beq remrts                               ; null always terminates
  4253  3573 c50b                                cmp endchr                               ; is it some another terminator?
  4254  3575 f0de                                beq remrts                               ; yes, it's finished
  4255  3577 c8                                  iny                                      ; progress to next character
  4256  3578 c922                                cmp #'"'                                 ; is it a quote?
  4257  357a d0f2                                bne l43_2                                ; no, just continue
  4258  357c f0e8                                beq l43_1                                ; yes, time to change
  4259                          
  4260                          ;.end
  4261                          ;[[command.ifthenelse]]
  4262                          
  4263                          
  4264                          
  4265                          ;****************************************************************
  4266                          ;*
  4267                          ;* IF Statment
  4268                          ;*
  4269                          ;* IF exp {GOTO line#  | THEN {line# | statements | b-block} }
  4270                          ;*  [:ELSE {line# | statements | b-block} ]
  4271                          ;*
  4272                          ;* B-block
  4273                          ;*
  4274                          ;* BEGIN : [statement(s) on one or more lines] : BEND
  4275                          ;*
  4276                          ;****************************************************************
  4277                          
  4278  357e 20ef4c             if               jsr frmevl                               ; evaluate the conditional expression
  4279  3581 208522                              jsr chrgot                               ; re-get current character
  4280  3584 c989                                cmp #goto_token                          ; is terminating character a GOTO?
  4281  3586 f005                                beq l44_1                                ; yes
  4282  3588 a9a7                                lda #then_token                          ; no, it must be THEN
  4283  358a 205d4e                              jsr synchr
  4284                          
  4285  358d a563               l44_1            lda facexp                               ; test truth value of argument
  4286  358f d026                                bne if_true                              ; branch if true
  4287                          
  4288                          if_false
  4289  3591 208522                              jsr chrgot                               ; is there a b-block?
  4290  3594 c9fe                                cmp #esc_command_token
  4291  3596 d00b                                bne l45_1                                ; no, must be an escape command
  4292  3598 c8                                  iny                                      ; might be, look at escape token
  4293  3599 20c522                              jsr indtxt
  4294  359c c918                                cmp #begin_token
  4295  359e d003                                bne l45_1                                ; branch if not
  4296  35a0 20d935                              jsr find_bend                            ; skip to end of b-block
  4297                          
  4298  35a3 204835             l45_1            jsr data                                 ; may be 'else' clause. first skip over 'then' clause..
  4299  35a6 a000                                ldy #0
  4300  35a8 20c522                              jsr indtxt                               ; ..and see if end of stmt or end of line
  4301  35ab f0a9                                beq rem                                  ; end of line, no 'else'. go to next line
  4302  35ad 208322                              jsr chrget                               ; another statement on this line.. is it 'else'?
  4303  35b0 c9d5                                cmp #else_token
  4304  35b2 d0ef                                bne l45_1                                ; no, keep looking on this line
  4305  35b4 208322                              jsr chrget                               ; yes! skip over token and execute clause (below)
  4306                          
  4307  35b7 208522             if_true          jsr chrgot
  4308  35ba f017                                beq l46_2                                ; branch if end of statement
  4309  35bc b003                                bcs l46_1                                ; branch if not a number
  4310  35be 833b07                              +lbra goto                               ; here if of the form 'THEN line#'
  4311                          
  4312  35c1 c9fe               l46_1            cmp #esc_command_token                   ; is this the beginning of a b-block?
  4313  35c3 d00e                                bne l46_2                                ; no, must be an escape command
  4314  35c5 c8                                  iny                                      ; might be, look at escape token
  4315  35c6 20c522                              jsr indtxt
  4316  35c9 c918                                cmp #begin_token
  4317  35cb d006                                bne l46_2
  4318  35cd 208322                              jsr chrget                               ; skip over 'BEGIN' if so...
  4319  35d0 208322                              jsr chrget                               ; ..and the second token, as well.
  4320                          
  4321  35d3 208522             l46_2            jsr chrgot                               ; get back original character, & set up flags
  4322  35d6 837af6                              +lbra xeqcm3                             ; ..and go execute whatever it is
  4323                          
  4324                          
  4325                          find_bend                                                 ; ... subroutine to find end of current b-block
  4326  35d9 208322                              jsr chrget
  4327  35dc d026                                bne l47_3
  4328                          
  4329                          ; End of statement.. set up next
  4330                          
  4331  35de c93a               l47_1            cmp #':'                                 ; is this EOL?
  4332  35e0 f0f7                                beq find_bend                            ; no, keep looking
  4333                          
  4334  35e2 7f7e48             l47_2            bbr7 runmod,l47_7                        ; EOL: branch if direct mode, 'block terminator not found' error
  4335                          
  4336  35e5 a002                                ldy #2
  4337  35e7 20c522                              jsr indtxt                               ; end of text?
  4338  35ea f041                                beq l47_7                                ; yes, msb of next stmt pointer = 0. error
  4339                          
  4340  35ec c8                                  iny
  4341  35ed 20c522                              jsr indtxt
  4342  35f0 853b                                sta curlin                               ; set up next line of text
  4343  35f2 c8                                  iny
  4344  35f3 20c522                              jsr indtxt
  4345  35f6 853c                                sta curlin+1
  4346  35f8 98                                  tya
  4347  35f9 18                                  clc
  4348  35fa 653d                                adc txtptr
  4349  35fc 853d                                sta txtptr
  4350  35fe 90d9                                bcc find_bend
  4351  3600 e63e                                inc txtptr+1
  4352  3602 80d5                                bra find_bend                            ; always
  4353                          
  4354  3604 c922               l47_3            cmp #'"'
  4355  3606 d007                                bne l47_4
  4356  3608 203236                              jsr un_quote                             ; look for terminating quote, or EOL
  4357  360b f0d1                                beq l47_1                                ; EOL or ':' after closing quote
  4358  360d d0ca                                bne find_bend                            ; ..else normal char, keep looking
  4359                          
  4360  360f c98f               l47_4            cmp #rem_token                           ; REM?
  4361  3611 d005                                bne l47_5                                ; no
  4362  3613 205635                              jsr rem                                  ; yes, trash this line
  4363  3616 80ca                                bra l47_2                                ; and go test for end of text
  4364                          
  4365  3618 c9fe               l47_5            cmp #esc_command_token                   ; is this a BEND?
  4366  361a d0bd                                bne find_bend                            ; can't be, has to be an escape
  4367                          
  4368  361c 208322                              jsr chrget                               ; skip over esc token
  4369  361f c919                                cmp #bend_token
  4370  3621 f009                                beq l47_6                                ; this is what we came for, bye!
  4371                          
  4372  3623 c918                                cmp #begin_token                         ; not a BEND. is it a BEGIN?
  4373  3625 d0b2                                bne find_bend                            ; it's just a normal, stick-in-the-mud char. keep looking.
  4374                          
  4375  3627 20d935                              jsr find_bend                            ; oh-oh, recursion. Dr. Ja-Ja warned me about this.
  4376  362a 80ad                                bra find_bend
  4377                          
  4378  362c 60                 l47_6            rts
  4379                          
  4380  362d a225               l47_7            ldx #err_no_bend
  4381  362f 831ef8                              +lbra error
  4382                          
  4383                          un_quote                                                  ; txtptr points to a '"'. look for closing '"', or EOL
  4384  3632 a000                                ldy #0
  4385  3634 e33d               l48_1            inw txtptr
  4386  3636 20c522                              jsr indtxt
  4387  3639 f007                                beq l48_2                                ; EOL, get out here with .z set and a '00' in .a
  4388  363b c922                                cmp #'"'
  4389  363d d0f5                                bne l48_1                                ; keep looking until quote
  4390  363f 4c8322                              jmp chrget                               ; got closing quote, get byte after quote, set flags
  4391                          
  4392  3642 60                 l48_2            rts
  4393                          
  4394                          
  4395                          
  4396  3643 c9fe               else             cmp #esc_command_token                   ; is this of the form "ELSE b-block"?
  4397  3645 d00b                                bne l49_1                                ; no, must be an escape command
  4398  3647 c8                                  iny                                      ; might be, look at escape token
  4399  3648 20c522                              jsr indtxt
  4400  364b c918                                cmp #begin_token
  4401  364d d003                                bne l49_1                                ; no, justa plain-old "ELSE statement"
  4402  364f 20d935                              jsr find_bend                            ; yes, it is a b-block. skip over the b-block.
  4403  3652 8302ff             l49_1            +lbra rem
  4404                          
  4405                          
  4406                          ;.end
  4407                          ;[[command.on]]
  4408                          
  4409                          
  4410                          
  4411                          ;*********************************************************
  4412                          ;* ON expression {GOTO | GOSUB} line_number
  4413                          ;*********************************************************
  4414                          ongoto
  4415  3655 206c5d                              jsr getbyt                               ; get & save GOTO/GOSUB
  4416  3658 48                                  pha
  4417  3659 c989                                cmp #goto_token                          ; GOTO?
  4418  365b f005                                beq l50_1                                ; yes
  4419  365d c98d                                cmp #gosub_token                         ; GOSUB?
  4420  365f d3e9f7                              +lbne snerr                              ; no, syntax error
  4421                          
  4422  3662 c667               l50_1            dec faclo
  4423  3664 d004                                bne l50_2                                ; skip another line number
  4424  3666 68                                  pla                                      ; get dispatch character
  4425  3667 8300f6                              +lbra xeqcm2
  4426                          
  4427  366a 208322             l50_2            jsr chrget                               ; advance and set codes
  4428  366d 202e32                              jsr linget                               ; read next line
  4429  3670 c92c                                cmp #','                                 ; is it a "comma"?
  4430  3672 f0ee                                beq l50_1
  4431  3674 68                                  pla                                      ; remove stack entry (token)
  4432  3675 60                                  rts                                      ; either end of line or syntax error
  4433                          
  4434                          ;.end
  4435                          ;[[command.let]]
  4436                          
  4437                          
  4438                          
  4439                          ;****************************************************************
  4440                          ;*
  4441                          ;*  [LET] variable = expression
  4442                          ;*
  4443                          ;****************************************************************
  4444                          
  4445  3676 207c4f             let              jsr ptrget                               ; get pntr to variable into "varpnt"
  4446  3679 854b                                sta forpnt                               ; preserve pointer
  4447  367b 844c                                sty forpnt+1
  4448  367d a9b2                                lda #equal_token
  4449  367f 205d4e                              jsr synchr                               ; "=" is necessary
  4450                          
  4451  3682 a510                                lda intflg                               ; save type for later
  4452  3684 48                                  pha
  4453  3685 a50f                                lda valtyp                               ; retain the variable's value type too
  4454  3687 48                                  pha
  4455                          
  4456  3688 20ef4c                              jsr frmevl                               ; get value of formula into FAC
  4457  368b 68                                  pla
  4458  368c 2a                                  rol                                      ; carry set for string, off for numeric
  4459  368d 20de4c                              jsr chkval                               ; make sure VALTYP matches carry
  4460                          ;and set zero flag for numeric
  4461  3690 d022                                bne copstr                               ; if numeric, copy it
  4462  3692 68                                  pla                                      ; get number type
  4463                          
  4464  3693 1018               qintgr           bpl copflt                               ; store a floating point number
  4465  3695 20b262                              jsr round                                ; round integer
  4466  3698 20b458                              jsr ayint                                ; make two-byte number
  4467  369b a000                                ldy #0
  4468  369d a566                                lda facmo                                ; get high
  4469  369f da                                  phx
  4470  36a0 a24b                                ldx #forpnt
  4471  36a2 20f022                              jsr sta_far_ram1 ;sta (forpnt),y         ; store it
  4472  36a5 c8                                  iny
  4473  36a6 a567                                lda faclo                                ; get low
  4474  36a8 20f022                              jsr sta_far_ram1                         ; sta (forpnt),y
  4475  36ab fa                                  plx
  4476  36ac 60                                  rts
  4477                          
  4478                          
  4479                          
  4480  36ad a64b               copflt           ldx forpnt
  4481  36af a44c                                ldy forpnt+1
  4482  36b1 83af2b                              +lbra movmf_ram1                         ; put number @forpnt in var bank
  4483                          
  4484                          
  4485                          
  4486  36b4 68                 copstr           pla                                      ; if string, no INTFLG
  4487                          
  4488  36b5 a44c               inpcom           ldy forpnt+1                             ; TI$?
  4489  36b7 c002                                cpy #>zero                               ; (only TI$ can be this on assign)
  4490  36b9 f3c21c                              +lbeq Set_TI_String                      ; yes
  4491  36bc 8024                                bra getspt                               ; no
  4492                          
  4493                          
  4494  36be 68                 dskx1            pla
  4495  36bf c8                                  iny
  4496                          
  4497  36c0 c536               dskx2            cmp fretop+1
  4498  36c2 9018                                bcc l51_2
  4499  36c4 d008                                bne l51_1
  4500  36c6 88                                  dey
  4501  36c7 20a922                              jsr indfmo
  4502  36ca c535                                cmp fretop
  4503  36cc 900e                                bcc l51_2
  4504                          
  4505  36ce a467               l51_1            ldy faclo                                ; qvaria
  4506  36d0 c430                                cpy vartab+1                             ; if (vartab) > (facmo), don't copy
  4507  36d2 9008                                bcc l51_2
  4508  36d4 d023                                bne copy                                 ; it is less
  4509  36d6 a566                                lda facmo
  4510  36d8 c52f                                cmp vartab                               ; compare low orders
  4511  36da b01d                                bcs copy
  4512                          
  4513  36dc a566               l51_2            lda facmo                                ; dntcpy
  4514  36de a467                                ldy facmo+1
  4515  36e0 8035                                bra copyc
  4516                          
  4517                          
  4518  36e2 a002               getspt           ldy #2                                   ; get pntr to descriptor
  4519  36e4 20a922                              jsr indfmo
  4520  36e7 c57b                                cmp dsdesc+2                             ; check for DS$ hi
  4521  36e9 d0d5                                bne dskx2                                ; nope
  4522  36eb 48                                  pha
  4523  36ec 88                                  dey
  4524  36ed 20a922                              jsr indfmo
  4525  36f0 c57a                                cmp dsdesc+1                             ; check for DS$ lo
  4526  36f2 d0ca                                bne dskx1                                ; nope
  4527  36f4 a579                                lda dsdesc                               ; check if len=0
  4528  36f6 f0c6                                beq dskx1                                ; yup
  4529  36f8 68                                  pla                                      ; fall through to copy
  4530                          
  4531                          
  4532  36f9 a000               copy             ldy #0
  4533  36fb 20a922                              jsr indfmo
  4534  36fe 20735a                              jsr strini                               ; get room to copy string into
  4535  3701 a552                                lda dscpnt                               ; get pointer to old descriptor, so
  4536  3703 a453                                ldy dscpnt+1
  4537  3705 8570                                sta strng1                               ; movins can find string
  4538  3707 8471                                sty strng1+1
  4539  3709 20355b                              jsr movins                               ; copy it
  4540                          
  4541  370c a570                                lda strng1                               ; fix to free get strings
  4542  370e a471                                ldy strng1+1
  4543  3710 20cc5b                              jsr fretms                               ; free the string, if it is a temp
  4544                          
  4545  3713 a963                                lda #<dsctmp
  4546  3715 a000                                ldy #>dsctmp
  4547                          
  4548  3717 8552               copyc            sta dscpnt
  4549  3719 8453                                sty dscpnt+1
  4550  371b 8524                                sta index                                ; index points to new descriptor
  4551  371d 8425                                sty index+1
  4552  371f 20cc5b                              jsr fretms
  4553                          
  4554                          
  4555                          ;   Fix the strings by flagging the old string as garbage and the new
  4556                          ;   string by pointing it to its new descriptor.
  4557                          
  4558  3722 206737                              jsr stradj                               ; set up new string
  4559  3725 9011                                bcc l52_1                                ; leave it alone
  4560  3727 a000                                ldy #0
  4561  3729 a54b                                lda forpnt                               ; put in backwards link
  4562  372b da                                  phx
  4563  372c a224                                ldx #index
  4564  372e 20f022                              jsr sta_far_ram1
  4565  3731 c8                                  iny
  4566  3732 a54c                                lda forpnt+1
  4567  3734 20f022                              jsr sta_far_ram1
  4568  3737 fa                                  plx
  4569                          
  4570  3738 a54b               l52_1            lda forpnt                               ; fix old string
  4571  373a 8524                                sta index
  4572  373c a54c                                lda forpnt+1
  4573  373e 8525                                sta index+1
  4574  3740 206737                              jsr stradj                               ; point to old string
  4575  3743 9010                                bcc l52_2                                ; in text do not fix
  4576  3745 88                                  dey                                      ; restore y
  4577  3746 da                                  phx
  4578  3747 a224                                ldx #index
  4579  3749 a9ff                                lda #$ff                                 ; garbage flag
  4580  374b 20f022                              jsr sta_far_ram1
  4581  374e 88                                  dey
  4582  374f 68                                  pla                                      ; (was txa)
  4583  3750 48                                  pha
  4584  3751 20f022                              jsr sta_far_ram1                         ; store length
  4585  3754 fa                                  plx
  4586                          
  4587  3755 a002               l52_2            ldy #2                                   ; set the descriptor
  4588  3757 da                                  phx
  4589  3758 a24b                                ldx #forpnt
  4590  375a a952               l52_3            lda #dscpnt
  4591  375c 20d722                              jsr lda_far_ram1                         ; lda (dscpnt),y from RAM1
  4592  375f 20f022                              jsr sta_far_ram1                         ; sta (forpnt),y to   RAM1
  4593  3762 88                                  dey
  4594  3763 10f5                                bpl l52_3
  4595  3765 fa                                  plx
  4596  3766 60                                  rts
  4597                          
  4598                          
  4599                          ;   STRADJ takes the pointer index which points to a descriptor and
  4600                          ;   indexes to the desciptor's string data.  If the string is not in
  4601                          ;   string space (no action to take) we return with carry clear, else
  4602                          ;   we return with the pointer set to the link bytes in the string, the
  4603                          ;   length in .a and the carry set.
  4604                          
  4605  3767 a000               stradj           ldy #0
  4606  3769 20d522                              jsr indin1_ram1                          ; push length on stack
  4607  376c 48                                  pha
  4608  376d f036                                beq l53_5                                ; if length=0 do nothing
  4609  376f c8                                  iny
  4610  3770 20d522                              jsr indin1_ram1                          ; get low byte (into .x)
  4611  3773 aa                                  tax
  4612  3774 c8                                  iny
  4613  3775 20d522                              jsr indin1_ram1                          ; get high byte
  4614  3778 c53a                                cmp max_mem_1+1
  4615  377a 9006                                bcc l53_1                                ; ok
  4616  377c d027                                bne l53_5                                ; if above top of memory
  4617  377e e439                                cpx max_mem_1                            ; msb the same, test lsb
  4618  3780 b023                                bcs l53_5                                ; if above top of memory
  4619                          
  4620  3782 c536               l53_1            cmp fretop+1
  4621  3784 901f                                bcc l53_5                                ; if below fretop
  4622  3786 d004                                bne l53_2
  4623  3788 e435                                cpx fretop
  4624  378a 9019                                bcc l53_5                                ; if below fretop
  4625                          
  4626  378c c57b               l53_2            cmp dsdesc+2
  4627  378e d004                                bne l53_3                                ; fix
  4628  3790 e47a                                cpx dsdesc+1
  4629  3792 f011                                beq l53_5
  4630                          
  4631  3794 8624               l53_3            stx index                                ; ok set pointer
  4632  3796 8525                                sta index+1
  4633  3798 68                                  pla                                      ; get back length
  4634  3799 aa                                  tax                                      ; into x also
  4635  379a 18                                  clc
  4636  379b 6524                                adc index
  4637  379d 8524                                sta index
  4638  379f 9002                                bcc l53_4
  4639  37a1 e625                                inc index+1
  4640  37a3 38                 l53_4            sec                                      ; carry set
  4641  37a4 60                                  rts
  4642                          
  4643  37a5 68                 l53_5            pla                                      ; clean up stack
  4644  37a6 18                                  clc
  4645  37a7 60                                  rts
  4646                          
  4647                          ;.end
  4648                          ;[[command.printcmd]]
  4649                          
  4650                          
  4651                          
  4652                          ;***********************************************************
  4653                          ;*
  4654                          ;* PRINT   PRINT#   CMD
  4655                          ;*
  4656                          ;**********************************************************
  4657                          
  4658  37a8 20ae37             printn           jsr cmd                                  ; docmd
  4659  37ab 830701                              +lbra release_channels                   ; restore terminal
  4660                          
  4661                          
  4662  37ae 206c5d             cmd              jsr getbyt
  4663  37b1 f005                                beq l54_1
  4664  37b3 a92c                                lda #','                                 ; comma?
  4665  37b5 205d4e                              jsr synchr
  4666                          
  4667  37b8 08                 l54_1            php                                      ; save stat (beq=eof)
  4668  37b9 48                                  pha                                      ; save char
  4669  37ba 8615                                stx channl                               ; channel to output on
  4670  37bc 204968                              jsr coout
  4671  37bf 68                                  pla                                      ; get char back
  4672  37c0 28                                  plp                                      ; get stat back
  4673  37c1 8006                                bra print
  4674                          
  4675                          
  4676  37c3 203e38             strdon           jsr strprt
  4677                          
  4678  37c6 208522             newchr           jsr chrgot                               ; reget last character
  4679                          
  4680  37c9 f02c               print            beq crdo                                 ; terminator only, so print crlf
  4681  37cb c9fb                                cmp #using_token
  4682  37cd f31032                              +lbeq using
  4683                          
  4684                          
  4685                          
  4686  37d0 f032               printc           beq prtrts  ;here after seeing TAB(x) or "," or " ; " in which case
  4687                          ;a terminator does not mean a crlf but just RTS
  4688  37d2 c9a3                                cmp #tab_token                           ; TAB function?
  4689  37d4 f03f                                beq taber                                ; yes (c=1)
  4690  37d6 c9a6                                cmp #spc_token                           ; space function?
  4691  37d8 18                                  clc                                      ; clear carry
  4692  37d9 f03a                                beq taber                                ; yes (c=0)
  4693  37db c92c                                cmp #','                                 ; comma?
  4694  37dd f026                                beq comprt                               ; yes
  4695  37df c93b                                cmp #';'                                 ; a semicolon?
  4696  37e1 f04e                                beq notabr                               ; yes
  4697                          
  4698  37e3 20ef4c                              jsr frmevl                               ; evaluate the formula
  4699  37e6 ff0fda                              bbs7 valtyp,strdon                       ; branch if a string
  4700  37e9 208f64                              jsr fout
  4701  37ec 20855a                              jsr strlit                               ; build descriptor
  4702  37ef 203e38                              jsr strprt                               ; print the number
  4703  37f2 205838                              jsr outspc                               ; print a space
  4704  37f5 80cf                                bra newchr                               ; always goes
  4705                          
  4706                          
  4707                          
  4708  37f7 a90d               crdo             lda #cr
  4709  37f9 203d68                              jsr outch                                ; outdo
  4710                          
  4711  37fc 7f1505             crfin            bbr7 channl,prtrts
  4712  37ff a90a                                lda #lf
  4713  3801 203d68                              jsr outch                                ; outdo
  4714                          ; eor #$ff  ;????
  4715                          
  4716  3804 60                 prtrts           rts
  4717                          
  4718                          
  4719                          
  4720  3805 38                 comprt           sec
  4721  3806 20f0ff                              jsr _plot                                ; get tab position in x
  4722  3809 98                                  tya
  4723  380a 38                                  sec
  4724  380b e90a               morco1           sbc #column_width
  4725  380d b0fc                                bcs morco1
  4726  380f 49ff                                eor #$ff
  4727  3811 6901                                adc #1
  4728  3813 d017                                bne aspac
  4729                          
  4730  3815 08                 taber            php                                      ; remember if SPC(c=0) or TAB(c=1) function
  4731  3816 38                                  sec
  4732  3817 20f0ff                              jsr _plot                                ; read tab position
  4733  381a 8454                                sty trmpos
  4734  381c 20695d                              jsr gtbytc                               ; get value into accx
  4735  381f c929                                cmp #')'
  4736  3821 d327f6                              +lbne snerr
  4737  3824 28                                  plp
  4738  3825 9006                                bcc xspac
  4739  3827 8a                                  txa
  4740  3828 e554                                sbc trmpos
  4741  382a 9005                                bcc notabr                               ; negative, don't print any
  4742  382c aa                 aspac            tax
  4743  382d e8                 xspac            inx
  4744  382e ca                 xspac2           dex
  4745  382f d005                                bne xspac1
  4746                          
  4747                          
  4748  3831 208322             notabr           jsr chrget                               ; reget last character
  4749  3834 809a                                bra printc                               ; don't call crdo
  4750                          
  4751                          
  4752  3836 205838             xspac1           jsr outspc
  4753  3839 d0f3                                bne xspac2
  4754                          
  4755                          
  4756                          ; STROUT Routine
  4757                          ;
  4758                          ; Print the string pointed to by .x.  It must end with a null byte.
  4759                          
  4760  383b 20855a             strout           jsr strlit                               ; get a string literal
  4761                          
  4762  383e 206d5b             strprt           jsr frefac                               ; return temp pointer
  4763  3841 aa                                  tax                                      ; put count into counter
  4764  3842 a000                                ldy #0
  4765  3844 e8                                  inx                                      ; move one ahead
  4766  3845 ca                 strpr2           dex
  4767  3846 f0bc                                beq prtrts                               ; all done
  4768  3848 20d522                              jsr indin1_ram1                          ; lda (index),y
  4769  384b 203d68                              jsr outch                                ; outdo
  4770  384e c8                                  iny
  4771  384f c90d                                cmp #cr
  4772  3851 d0f2                                bne strpr2
  4773  3853 20fc37                              jsr crfin                                ; type rest of carriage return
  4774  3856 80ed                                bra strpr2                               ; and on and on
  4775                          
  4776  3858 a515               outspc           lda channl                               ; if terminal print skip chr., else print space
  4777  385a d003                                bne realsp
  4778  385c a91d                                lda #29                                  ; CBM cursor right (non-destructive skip char)
  4779  385e 2c                                  !text $2c
  4780                          
  4781  385f a920               realsp           lda #' '                                 ; space
  4782  3861 2c                                  !text $2c
  4783                          
  4784  3862 a93f               outqst           lda #'?'
  4785                          
  4786                          ;outdo
  4787  3864 4c3d68                              jmp outch                                ; output char in .a
  4788                          ; and #$ff ;????
  4789                          ; rts
  4790                          
  4791                          ;.end
  4792                          
  4793                          ;[[command.inputs]]
  4794                          
  4795                          
  4796  3867 20e258             get              jsr errdir                               ; direct mode illegal
  4797  386a 8576                                sta z_p_temp_1                           ; flag to distinguish between GET and GETKEY
  4798                          
  4799  386c c923                                cmp #'#'                                 ; is it GET# ?
  4800  386e f009                                beq getn                                 ; yes
  4801  3870 c9f9                                cmp #key_token                           ; is it GETKEY ?
  4802  3872 d015                                bne gettty                               ; no, must be plain GET
  4803  3874 208322                              jsr chrget                               ; yes, skip over KEY token
  4804  3877 8010                                bra gettty
  4805                          
  4806                          
  4807  3879 208322             getn             jsr chrget                               ; GET# move up to next byte
  4808  387c 206c5d                              jsr getbyt                               ; get channel into x
  4809  387f a92c                                lda #','                                 ; comma?
  4810  3881 205d4e                              jsr synchr
  4811  3884 8615                                stx channl
  4812  3886 205268                              jsr coin                                 ; chkin
  4813                          
  4814                          
  4815                          gettty                                                    ; GET
  4816  3889 a201                                ldx #<buf+1                              ; point to 0
  4817  388b a002                                ldy #>buf
  4818  388d a900                                lda #0                                   ; to stuff and to point
  4819  388f 8d0102                              sta buf+1                                ; zero it
  4820  3892 a940                                lda #$40                                 ; turn on v-bit
  4821  3894 201b39                              jsr inpco1                               ; do the get
  4822  3897 a615                                ldx channl
  4823  3899 d019                                bne release_channels                     ; restore terminal channels
  4824  389b 60                                  rts
  4825                          
  4826                          
  4827                          linputn                                                   ; input line from channel into a string var
  4828  389c 208322                              jsr chrget                               ; (eat input# token)
  4829  389f f787                                smb7 op
  4830  38a1 2c                                  !text $2c
  4831                          
  4832  38a2 7787               inputn           rmb7 op                                  ; flag INPUT# vs. LINPUT#
  4833  38a4 206c5d                              jsr getbyt                               ; get channel number
  4834  38a7 a92c                                lda #','                                 ; a comma?
  4835  38a9 205d4e                              jsr synchr
  4836  38ac 8615                                stx channl
  4837  38ae 205268                              jsr coin                                 ; chkin
  4838  38b1 20e938                              jsr notqti                               ; do input to variables
  4839                          
  4840                          
  4841                          release_channels                                          ; iodone, iorele.
  4842  38b4 20ccff                              jsr _clrch                               ; clear I/O channels
  4843                          ; ldx #0   ;restore normal terminal channels
  4844  38b7 8515                                sta channl                               ; (was stx)     [910909]
  4845  38b9 60                                  rts
  4846                          
  4847                          
  4848                          linput                                                    ; input line from console into a string var
  4849  38ba 208322                              jsr chrget                               ; (eat input token)
  4850  38bd f787                                smb7 op
  4851  38bf 2c                                  !text $2c
  4852                          
  4853  38c0 7787               input            rmb7 op                                  ; flag INPUT vs. LINPUT
  4854  38c2 c922                                cmp #'"'                                 ; a quote?
  4855  38c4 d023                                bne notqti                               ; no message
  4856  38c6 20164e                              jsr strtxt                               ; literalize the string in text
  4857                          
  4858  38c9 208522                              jsr chrgot                               ; looking for prompt string terminator  [910219]
  4859  38cc c92c                                cmp #','
  4860  38ce d011                                bne l55_1
  4861  38d0 8dff01                              sta buf_txtptr                           ; is comma- supress '?' after prompt  [910219]
  4862  38d3 208322                              jsr chrget                               ; eat comma
  4863  38d6 203e38                              jsr strprt                               ; print prompt
  4864  38d9 20e258                              jsr errdir                               ; error if direct mode
  4865  38dc 201c31                              jsr InputLine                            ; get first item
  4866  38df 8013                                bra getagn1                              ; see if there's more to do
  4867                          
  4868  38e1 a93b               l55_1            lda #';'                                 ; must end in semicolon
  4869  38e3 205d4e                              jsr synchr
  4870  38e6 203e38                              jsr strprt                               ; print prompt
  4871                          
  4872  38e9 20e258             notqti           jsr errdir                               ; use common routine since def direct
  4873  38ec a92c                                lda #','                                 ; get comma
  4874  38ee 8dff01                              sta buf_txtptr                           ; (data reader expects buffer to start with terminator)
  4875                          
  4876  38f1 201231             getagn           jsr PromptedInput                        ; type "?" and input a line of text
  4877  38f4 a515               getagn1          lda channl
  4878  38f6 f00d                                beq l56_1
  4879  38f8 20b7ff                              jsr _readst                              ; get status byte
  4880                          ; and #2   ; (assumes serial bus????)  [910618] eoi ok
  4881  38fb 2987                                and #%10000111                           ; serial: err if dnp, r/w timeout errors
  4882  38fd f006                                beq l56_1                                ; a-ok rs232: err if brk, ovr, frm, par errors
  4883  38ff 20b438                              jsr release_channels                     ; bad, close channel
  4884  3902 8344fc                              +lbra data                               ; skip rest of input
  4885                          
  4886  3905 ad0002             l56_1            lda buf                                  ; bufful. get anything?
  4887  3908 d00f                                bne inpcon                               ; yes- process input
  4888                          ; lda channl  ;didn't get anything.  is this keyboard? [901212]
  4889                          ; bne getagn  ; no- keep looking for data ????
  4890  390a 205b35                              jsr datan                                ; skip to end of statement
  4891  390d 833cfc                              +lbra addon
  4892                          
  4893                          
  4894  3910 7787               read             rmb7 op                                  ; flag READ vs. LREAD    [910102]
  4895  3912 a643                                ldx datptr                               ; get last data location
  4896  3914 a444                                ldy datptr+1
  4897  3916 a998                                lda #$98                                 ; initiator= read
  4898  3918 2c                                  !text $2c
  4899                          
  4900  3919 a900               inpcon           lda #0                                   ; initiator= input
  4901  391b 8513               inpco1           sta input_flag                           ; $98=read, $40=get, $00=input
  4902                          
  4903                          ; In the processing of DATA and READ statements, one pointer points to the data
  4904                          ; (i.e., the numbers being fetched) and another points to the list of variables.
  4905                          ;
  4906                          ; The pointer into the data always starts pointing to a terminator- a ",", ":", or EOL.
  4907                          ; At this point TXTPTR points to list of variables and (x,y) points to data or input line.
  4908                          
  4909  391d 8645                                stx inpptr                               ; pointer to data
  4910  391f 8446                                sty inpptr+1
  4911                          
  4912  3921 207c4f             inloop           jsr ptrget                               ; get a pointer to the variable
  4913  3924 854b                                sta forpnt                               ; store its address
  4914  3926 844c                                sty forpnt+1
  4915                          
  4916  3928 a201                                ldx #1
  4917  392a b53d               l57_1            lda txtptr,x                             ; move variable list pointer to 'vartxt'
  4918  392c 954d                                sta vartxt,x
  4919  392e b545                                lda inpptr,x                             ; move data line pointer to 'txtptr'
  4920  3930 953d                                sta txtptr,x
  4921  3932 ca                                  dex
  4922  3933 10f5                                bpl l57_1
  4923                          
  4924  3935 208522                              jsr chrgot                               ; get first data byte
  4925  3938 d02f                                bne datbk1                               ; not null, so we got something
  4926  393a 2413                                bit input_flag                           ; READ($98), GET($40), or INPUT($00)?
  4927  393c 501a                                bvc qdata                                ; branch if READ or INPUT
  4928  393e a576                                lda z_p_temp_1                           ; GET or GETKEY?
  4929  3940 c9f9                                cmp #key_token
  4930  3942 d008                                bne l57_3                                ; branch if GET
  4931                          
  4932  3944 205b68             l57_2            jsr cgetl                                ; GETKEY
  4933  3947 aa                                  tax                                      ; test if null
  4934  3948 f0fa                                beq l57_2                                ; it is null, keep scanning
  4935  394a d003                                bne l57_4                                ; got a key, go put it in var
  4936                          
  4937  394c 205b68             l57_3            jsr cgetl                                ; get a key if pressed, otherwise gets a zero
  4938  394f 8d0002             l57_4            sta buf
  4939  3952 a2ff                                ldx #<buf_txtptr
  4940  3954 a001                                ldy #>buf_txtptr
  4941  3956 800d                                bra datbk
  4942                          
  4943                          
  4944  3958 33f000             qdata            +lbmi datlop                             ; branch if READ
  4945  395b a515                                lda channl                               ; else it's INPUT
  4946  395d d003                                bne l58_1
  4947  395f 206238                              jsr outqst                               ; console input, so display '? ' prompt
  4948                          
  4949  3962 201231             l58_1            jsr PromptedInput                        ; get another line
  4950                          
  4951  3965 863d               datbk            stx txtptr                               ; set for CHRGET
  4952  3967 843e                                sty txtptr+1
  4953                          
  4954  3969 7f8708             datbk1           bbr7 op,l59_1                            ; no chrgot if LINPUT (want leading spaces) [910513]
  4955  396c 20a540                              jsr chargt
  4956  396f 208e22                              jsr chrtst
  4957  3972 8003                                bra l59_2
  4958                          
  4959  3974 208322             l59_1            jsr chrget                               ; get next data byte
  4960  3977 7f0f32             l59_2            bbr7 valtyp,l59_8                        ; get value type, input a number if numeric
  4961  397a 6f1309                              bbr6 input_flag,l59_4                    ; branch if not get, set quote
  4962  397d e8                                  inx
  4963  397e 863d                                stx txtptr
  4964  3980 a900               l59_3            lda #0                                   ; [901212]
  4965  3982 850a                                sta charac
  4966  3984 800f                                bra l59_5
  4967                          
  4968  3986 ff87f7             l59_4            bbs7 op,l59_3                            ; no terminators if LINPUT or LREAD  [901212]
  4969  3989 850a                                sta charac                               ; setqut.  assume quoted string
  4970  398b c922                                cmp #'"'                                 ; terminators ok?
  4971  398d f007                                beq l59_6                                ; yes (sets .c)
  4972  398f a93a                                lda #':'                                 ; set terminators to ":" and...
  4973  3991 850a                                sta charac
  4974  3993 a92c                                lda #','                                 ; ...comma
  4975                          
  4976  3995 18                 l59_5            clc                                      ; resetc
  4977  3996 850b               l59_6            sta endchr                               ; nowget
  4978  3998 a53d                                lda txtptr
  4979  399a a43e                                ldy txtptr+1
  4980  399c 6900                                adc #0                                   ; .c is set properly above
  4981  399e 9001                                bcc l59_7
  4982  39a0 c8                                  iny
  4983  39a1 208b5a             l59_7            jsr strlt2                               ; make a string descriptor for the value & copy if needed
  4984  39a4 20224e                              jsr st2txt                               ; copy strng2 to txtptr (st-2-txt... get it?)
  4985  39a7 20b536                              jsr inpcom                               ; do assignment
  4986  39aa 800d                                bra l59_9
  4987                          
  4988  39ac ff871d             l59_8            bbs7 op,l59_10                           ; error if LINPUT (string input only)  [901212]
  4989  39af a200                                ldx #0                                   ; numins. flag 'text bank' (0)
  4990  39b1 208d63                              jsr fin
  4991  39b4 a510                                lda intflg                               ; set codes on flags
  4992  39b6 209336                              jsr qintgr                               ; go decide on float
  4993                          
  4994  39b9 208522             l59_9            jsr chrgot                               ; strdn2. read last character
  4995  39bc f041                                beq trmok                                ; ":" or EOL is ok
  4996  39be c92c                                cmp #','                                 ; a comma?
  4997  39c0 f03d                                beq trmok
  4998                          
  4999  39c2 a513                                lda input_flag                           ; is this get, read, or input?
  5000  39c4 f00a                                beq l59_11                               ; input
  5001  39c6 3004                                bmi l59_10                               ; read
  5002  39c8 a615                                ldx channl                               ; get. if not kbd, go use 'bad file data error'
  5003  39ca d008                                bne l59_12
  5004                          
  5005  39cc a216               l59_10           ldx #errtm                               ; tmerr. 'get from kbd' or 'read' saw a bad type
  5006  39ce 8006                                bra l59_13                               ; always
  5007                          
  5008  39d0 a515               l59_11           lda channl
  5009  39d2 f005                                beq l59_14                               ; do again if keybd input
  5010  39d4 a218               l59_12           ldx #errbd                               ; input saw bad file data
  5011  39d6 8377f4             l59_13           +lbra error
  5012                          
  5013                          
  5014  39d9 20dc3c             l59_14           jsr highlight_text                       ; [911119]
  5015  39dc 207dff                              jsr _primm
  5016  39df 3f5245444f204652...                 !text "?REDO FROM START",cr,0
  5017  39f1 20cb3c                              jsr highlight_done                       ; [911119]
  5018                          
  5019  39f4 ad7211             ott              lda oldtxt
  5020  39f7 ac7311                              ldy oldtxt+1
  5021  39fa 853d                                sta txtptr                               ; put user back to beginning of input
  5022  39fc 843e                                sty txtptr+1
  5023  39fe 60                                  rts
  5024                          
  5025                          
  5026                          
  5027  39ff a201               trmok            ldx #1
  5028  3a01 b53d               l60_1            lda txtptr,x
  5029  3a03 9545                                sta inpptr,x                             ; save for more reads
  5030  3a05 b54d                                lda vartxt,x
  5031  3a07 953d                                sta txtptr,x                             ; point to variable list
  5032  3a09 ca                                  dex
  5033  3a0a 10f5                                bpl l60_1
  5034                          
  5035  3a0c 208522                              jsr chrgot                               ; look at last vartab character
  5036  3a0f f006                                beq l60_2                                ; that's the end of the list
  5037  3a11 205b4e                              jsr chkcom                               ; not end. check for comma
  5038  3a14 830bff                              +lbra inloop
  5039                          
  5040  3a17 a545               l60_2            lda inpptr                               ; put away a new data pntr name
  5041  3a19 a446                                ldy inpptr+1
  5042  3a1b 7f1305                              bbr7 input_flag,l60_3
  5043  3a1e 8543                                sta datptr
  5044  3a20 8444                                sty datptr+1
  5045  3a22 60                                  rts
  5046                          
  5047  3a23 a000               l60_3            ldy #0                                   ; last data chr could have been ',' or ':' but should be null
  5048  3a25 a945                                lda #inpptr
  5049  3a27 20c722                              jsr lda_far_ram0
  5050  3a2a f01d                                beq l60_4                                ; it is null
  5051  3a2c a515                                lda channl                               ; if not terminal, no type
  5052  3a2e d019                                bne l60_4
  5053                          
  5054  3a30 20dc3c                              jsr highlight_text                       ; [911119]
  5055  3a33 207dff                              jsr _primm
  5056  3a36 3f45585452412049...                 !text "?EXTRA IGNORED", cr,0
  5057  3a46 20cb3c                              jsr highlight_done                       ; [911119]
  5058                          
  5059  3a49 60                 l60_4            rts                                      ; do next statement
  5060                          
  5061                          
  5062                          ; DATLOP Routine Subroutine to find data.
  5063                          ;
  5064                          ; The search is made by using the execution code for data to skip over
  5065                          ; statements, the start word of each statement is compared with "data_token".
  5066                          ; Each new line number is stored in "datlin" so that if any error occurs while
  5067                          ; reading data the error message can give the line number of the bad data.
  5068                          
  5069  3a4a 205b35             datlop           jsr datan                                ; skip some text
  5070  3a4d c8                                  iny
  5071  3a4e aa                                  tax                                      ; end of line?
  5072  3a4f d016                                bne l61_1                                ; no
  5073  3a51 a20d                                ldx #errod                               ; yes, "no data" error
  5074  3a53 c8                                  iny
  5075  3a54 20c522                              jsr indtxt
  5076  3a57 f3f6f3                              +lbeq error
  5077                          
  5078  3a5a c8                                  iny
  5079  3a5b 20c522                              jsr indtxt                               ; get high byte of line number
  5080  3a5e 8541                                sta datlin
  5081  3a60 c8                                  iny
  5082  3a61 20c522                              jsr indtxt                               ; get low byte
  5083  3a64 c8                                  iny
  5084  3a65 8542                                sta datlin+1
  5085                          
  5086  3a67 204b35             l61_1            jsr addon                                ; nowlin.  txtptr+.y
  5087  3a6a 208522                              jsr chrgot                               ; span blanks
  5088  3a6d aa                                  tax                                      ; used later
  5089  3a6e e083                                cpx #data_token                          ; is it a DATA statement?
  5090  3a70 d0d8                                bne datlop                               ; not quite right, keep looking
  5091  3a72 83f5fe                              +lbra datbk1                             ; this is the one
  5092                          
  5093                          
  5094                          ;.end
  5095                          ;[[command.next]]
  5096                          
  5097                          
  5098                          
  5099                          ; Next routine
  5100                          ;
  5101                          ; 'FOR' entry on the stack has the following format:
  5102                          ;
  5103                          ; Low address
  5104                          ;  token (for_token) 1 byte
  5105                          ;  a pointer to the loop variable 2 bytes
  5106                          ;  the step 5 bytes
  5107                          ;  a byte reflecting the sign of the incr. 2 bytes
  5108                          ;  the upper value (packed) 5 bytes
  5109                          ;  the line number of the FOR statement 2 bytes
  5110                          ;  a text pointer into the FOR statement 2 bytes
  5111                          ; High address
  5112                          ;
  5113                          ; (total 16 bytes)
  5114                          
  5115  3a75 d013               next             bne l62_2                                ; hop if 'next' variable given
  5116  3a77 a0ff                                ldy #$ff                                 ; flag no specific 'for' variable
  5117  3a79 8014                                bra l62_3                                ; always
  5118                          
  5119  3a7b a012               l62_1            ldy #lenfor                              ; done, clean up stack
  5120  3a7d 20ef31                              jsr rlsstk                               ; release (y) items from stack
  5121  3a80 208522                              jsr chrgot
  5122  3a83 c92c                                cmp #','                                 ; ie., NEXT j,k
  5123  3a85 d069                                bne l62_7
  5124  3a87 208322                              jsr chrget
  5125                          
  5126  3a8a 207c4f             l62_2            jsr ptrget                               ; get pointer to variable in (a,y)
  5127  3a8d 854b                                sta forpnt
  5128                          
  5129  3a8f 844c               l62_3            sty forpnt+1
  5130  3a91 a981                                lda #for_token
  5131  3a93 204331                              jsr search                               ; look for FOR entry in run-time stack
  5132  3a96 f005                                beq l62_4                                ; branch if found
  5133  3a98 a20a                                ldx #errnf                               ; otherwise 'error, not found'
  5134  3a9a 83b3f3                              +lbra error
  5135                          
  5136                          
  5137                          ; Set up to move STEP value to FAC
  5138                          
  5139  3a9d 20e631             l62_4            jsr movfnd                               ; (fndpnt) => (tos)
  5140  3aa0 a53f                                lda fndpnt
  5141  3aa2 18                                  clc
  5142  3aa3 6903                                adc #3                                   ; offset to step value
  5143  3aa5 a440                                ldy fndpnt+1
  5144  3aa7 9001                                bcc l62_5
  5145  3aa9 c8                                  iny
  5146                          
  5147  3aaa 200e62             l62_5            jsr movfm                                ; actually "move from ROM", but sys stack is in "common"
  5148  3aad a008                                ldy #8                                   ; MOVFM doesn't move sign.  Get it
  5149  3aaf b13f                                lda (fndpnt),y
  5150  3ab1 8568                                sta facsgn
  5151                          
  5152                          ; Get pointer to FOR variable
  5153                          
  5154  3ab3 a001                                ldy #1
  5155  3ab5 b13f                                lda (fndpnt),y                           ; get lsb
  5156  3ab7 48                                  pha
  5157  3ab8 aa                                  tax
  5158  3ab9 c8                                  iny
  5159  3aba b13f                                lda (fndpnt),y                           ; get msb
  5160  3abc 48                                  pha
  5161  3abd a8                                  tay                                      ; msb in y
  5162  3abe 8a                                  txa                                      ; lsb in a
  5163  3abf 20bb5d                              jsr fadd                                 ; add STEP value to FOR variable (fadd gets from bank 1)
  5164  3ac2 7a                                  ply                                      ; msb in y
  5165  3ac3 fa                                  plx                                      ; lsb in x
  5166  3ac4 206262                              jsr movmf_ram1                           ; put result back into FOR variable in var bank
  5167                          
  5168                          ; Make (a,y) point at TO value in stack
  5169                          
  5170  3ac7 a53f                                lda fndpnt
  5171  3ac9 18                                  clc
  5172  3aca 6909                                adc #9
  5173  3acc a440                                ldy fndpnt+1
  5174  3ace 9001                                bcc l62_6
  5175  3ad0 c8                                  iny
  5176                          
  5177                          ; Test if loop done
  5178                          
  5179                          l62_6
  5180                          ; sta sw_rom_ram0 ;????
  5181  3ad1 20f162                              jsr fcomp                                ; compare FAC to value pointed to by (a,y)
  5182  3ad4 a008                                ldy #8
  5183  3ad6 38                                  sec
  5184  3ad7 f13f                                sbc (fndpnt),y                           ; (common area????)
  5185  3ad9 f0a0                                beq l62_1                                ; branch taken if done
  5186                          
  5187  3adb a011                                ldy #17                                  ; not done, set pointers to re-execute loop
  5188  3add b13f                                lda (fndpnt),y                           ; (common area????)
  5189  3adf 853d                                sta txtptr
  5190  3ae1 88                                  dey
  5191  3ae2 b13f                                lda (fndpnt),y
  5192  3ae4 853e                                sta txtptr+1
  5193  3ae6 88                                  dey
  5194  3ae7 b13f                                lda (fndpnt),y
  5195  3ae9 853c                                sta curlin+1
  5196  3aeb 88                                  dey
  5197  3aec b13f                                lda (fndpnt),y
  5198  3aee 853b                                sta curlin
  5199  3af0 60                 l62_7            rts
  5200                          
  5201                          ;.end
  5202                          ;[[command.dim]] .page
  5203                          
  5204                          
  5205                          ; The DIMension code sets DIMFLG and then falls into the variable search
  5206                          ; routine, which looks at DIMFLG at 3 different points:
  5207                          ;
  5208                          ; 1) If an entry is found, DIMFLG being on indicates a
  5209                          ;    doubly-defined variable.
  5210                          ; 2) When a new entry is being built, DIMFLG being on indicates
  5211                          ;    the indices should be used for the size of each index.
  5212                          ;    Otherwise the default of ten is used.
  5213                          ; 3) When the build entry code finishes, indexing will be done
  5214                          ;    only if DIMFLG is off.
  5215                          
  5216                          
  5217  3af1 205b4e             dim3             jsr chkcom                               ; must be a comma
  5218                          
  5219  3af4 aa                 dim              tax                                      ; make .x non-zero (.a must be non-zero to work correctly)
  5220  3af5 20814f                              jsr ptrgt1
  5221  3af8 208522                              jsr chrgot                               ; get last character
  5222  3afb d0f4                                bne dim3
  5223  3afd 60                                  rts
  5224                          
  5225                          ;.end
  5226                          ;[[command.sys]]
  5227                          
  5228                          
  5229                          
  5230  3afe 208a5d             sys              jsr getwrd                               ; convert arg to integer value
  5231  3b01 a516                                lda linnum                               ; set up arg's for call to 'long jsr'
  5232  3b03 8504                                sta _pclo
  5233  3b05 a517                                lda linnum+1
  5234  3b07 8503                                sta _pchi
  5235  3b09 add102                              lda current_bank
  5236  3b0c 8502                                sta _bank
  5237                          
  5238  3b0e 202679                              jsr optbyt                               ; (optional) .A reg arg
  5239  3b11 9002                                bcc l63_1
  5240  3b13 8606                                stx _a_reg
  5241                          
  5242  3b15 202679             l63_1            jsr optbyt                               ; (optional) .X reg arg
  5243  3b18 9002                                bcc l63_2
  5244  3b1a 8607                                stx _x_reg
  5245                          
  5246  3b1c 202679             l63_2            jsr optbyt                               ; (optional) .Y reg arg
  5247  3b1f 9009                                bcc l63_4
  5248  3b21 8608                                stx _y_reg
  5249                          
  5250  3b23 202679             l63_3            jsr optbyt                               ; (optional) .Z reg arg
  5251  3b26 9002                                bcc l63_4
  5252  3b28 8609                                stx _z_reg
  5253                          
  5254  3b2a 202679             l63_4            jsr optbyt                               ; (optional) .S reg arg
  5255  3b2d 9002                                bcc l63_5
  5256  3b2f 8605                                stx _s_reg
  5257                          
  5258  3b31 4c6eff             l63_5            jmp _jsr_far                             ; far, far away
  5259                          ;If returns, Kernel will update _reg's for us
  5260                          
  5261                          ;.end
  5262                          ;[[command.dma]]
  5263                          
  5264                          
  5265                          
  5266                          ; DMA - Set up for DMA operation (FETCH/STASH/SWAP)
  5267                          ;
  5268                          ;  Syntax:  DMA  command,length,source(l/h/b),destination(l/h/b)[,subcmd,mod(l/h)] [,...]
  5269                          
  5270                          
  5271                          dma                                                       ; params are not longer optional-  [910520] F018A
  5272  3b34 206c5d                              jsr getbyt                               ; get command
  5273  3b37 9009               l64_1            bcc l64_2
  5274  3b39 8a                                  txa                                      ; [910102]
  5275  3b3a 2904                                and #%00000100                           ;
  5276  3b3c d3c016                              +lbne fcerr                              ; (disallow chained DMA lists)
  5277  3b3f 8e5001                              stx dma2_cmd
  5278                          
  5279  3b42 20875d             l64_2            jsr comwrd                               ; get length
  5280                          ; bcc l64_3
  5281  3b45 8c5101                              sty dma2_cnt_lo
  5282  3b48 8d5201                              sta dma2_cnt_hi
  5283                          
  5284  3b4b 20875d             l64_3            jsr comwrd                               ; get source address & bank
  5285                          ; bcc l64_4
  5286  3b4e 8c5301                              sty dma2_src_lo
  5287  3b51 8d5401                              sta dma2_src_hi
  5288  3b54 20825d             l64_4            jsr combyt
  5289                          ; bcc l64_5
  5290  3b57 8e5501                              stx dma2_src_bank
  5291                          
  5292  3b5a 20875d             l64_5            jsr comwrd                               ; get destination address & bank
  5293                          ; bcc l64_6
  5294  3b5d 8c5601                              sty dma2_dest_lo
  5295  3b60 8d5701                              sta dma2_dest_hi
  5296  3b63 20825d             l64_6            jsr combyt
  5297                          ; bcc l64_7
  5298  3b66 8e5801                              stx dma2_dest_bank
  5299                          
  5300  3b69 202479             l64_7            jsr optzer                               ; get subcmd, default=0    [910520] F018A
  5301                          ; bcc l64_8
  5302  3b6c 8e5901                              stx dma2_subcmd
  5303                          
  5304  3b6f 202479             l64_8            jsr optzer                               ; get mod lo/hi, default=0   [910102]
  5305                          ; bcc l64_9
  5306  3b72 8e5a01                              stx dma2_mod_lo
  5307  3b75 202479             l64_9            jsr optzer
  5308                          ; bcc l64_10
  5309  3b78 8e5b01                              stx dma2_mod_hi
  5310                          
  5311  3b7b a000               l64_10           ldy #0                                   ; dma_list (bank 0)
  5312  3b7d a201                                ldx #>dma2_cmd
  5313  3b7f a950                                lda #<dma2_cmd
  5314  3b81 8c02d7                              sty dma_ctlr+2                           ; dma_list bank
  5315  3b84 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
  5316  3b87 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
  5317  3b8a 2c03d7             l64_11           bit dma_ctlr+3                           ; check status (in case IRQ enabled)  [910103]
  5318  3b8d 30fb                                bmi l64_11                               ; busy
  5319                          
  5320  3b8f 208522                              jsr chrgot                               ; eol?
  5321  3b92 f005                                beq l64_12                               ; yes
  5322  3b94 202679                              jsr optbyt                               ; no- continue after getting comma & next cmd byte
  5323  3b97 809e                                bra l64_1
  5324                          
  5325  3b99 60                 l64_12           rts
  5326                          
  5327                          ;.end
  5328                          ;[[command.trace]]
  5329                          
  5330                          
  5331                          
  5332                          
  5333                          tron                                                      ; trace mode on
  5334  3b9a d77e                                smb5 runmod                              ; trcflg
  5335  3b9c 60                                  rts
  5336                          
  5337                          
  5338                          troff                                                     ; trace mode off
  5339  3b9d 577e                                rmb5 runmod                              ; trcflg
  5340  3b9f 60                                  rts
  5341                          
  5342                          
  5343                          ;.end
  5344                          ;[[command.sys.returnreg]]
  5345                          
  5346                          
  5347                          
  5348                          ; RREG - Return values of 6502 registers following a SYS call.
  5349                          ;
  5350                          ; Syntax : RREG [.A variable [,[.X[...Z] variable] [,[.S variable] ]]]
  5351                          
  5352  3ba0 a900               rreg             lda #0
  5353  3ba2 850d                                sta count
  5354                          
  5355  3ba4 208522             l65_1            jsr chrgot
  5356  3ba7 f038                                beq l65_4                                ; reached end of statement- done
  5357  3ba9 c92c                                cmp #','                                 ; skip this arg?
  5358  3bab f022                                beq l65_3                                ; branch if so
  5359  3bad 207c4f                              jsr ptrget                               ; get pointer to target variable
  5360  3bb0 854b                                sta forpnt                               ; a little bit of set up so we can share LET code
  5361  3bb2 844c                                sty forpnt+1
  5362  3bb4 a50f                                lda valtyp                               ; what kind of variable name did ptrget find?
  5363  3bb6 d32f11                              +lbne chkerr                             ; type mismatch error if string
  5364                          
  5365  3bb9 a40d                                ldy count                                ; which register's value are we looking for?
  5366  3bbb b90600                              lda _a_reg,y                             ; .A, .X, .Y, & .Z are contiguious
  5367  3bbe c004                                cpy #4
  5368  3bc0 d002                                bne l65_2
  5369  3bc2 a505                                lda _s_reg                               ; but .S isn't
  5370                          
  5371  3bc4 a8                 l65_2            tay                                      ; low byte in .Y
  5372  3bc5 a900                                lda #0                                   ; high byte of zero
  5373  3bc7 203f4e                              jsr givayf                               ; go float it
  5374  3bca a510                                lda intflg                               ; set conditions for type of var (int/float)
  5375  3bcc 209336                              jsr qintgr                               ; ..and use part of LET to do the work
  5376                          
  5377  3bcf e60d               l65_3            inc count                                ; 5 registers to do
  5378  3bd1 a50d                                lda count
  5379  3bd3 c905                                cmp #5
  5380  3bd5 b00a                                bcs l65_4
  5381  3bd7 208522                              jsr chrgot                               ; was this e-o-statement?
  5382  3bda f005                                beq l65_4
  5383  3bdc 208322                              jsr chrget                               ; not e-o-s, skip over comma,
  5384  3bdf d0c3                                bne l65_1                                ; ..and go do next
  5385                          
  5386  3be1 60                 l65_4            rts
  5387                          
  5388                          ;.end
  5389                          ;[[command.midstring]]
  5390                          
  5391                          
  5392                          
  5393                          ; Alternate use of the MID$ function, as the target of an assignment.
  5394                          ;
  5395                          ; MID$(string_var,starting_position [,length]) = string_expression
  5396                          
  5397                          midd2
  5398                          midwrk           =midd2-1
  5399                          
  5400  3be2 20584e                              jsr chkopn                               ; check for '('
  5401  3be5 207c4f                              jsr ptrget                               ; get pointer to descriptor of string-var
  5402  3be8 854b                                sta forpnt                               ; store for later use
  5403  3bea 844c                                sty forpnt+1
  5404  3bec 20dd4c                              jsr chkstr                               ; check if string
  5405                          
  5406  3bef 20825d                              jsr combyt                               ; look for comma, followed by 1 byte starting address
  5407  3bf2 ca                                  dex                                      ; adjust starting addr
  5408  3bf3 8677                                stx hulp                                 ; store    " "
  5409                          
  5410  3bf5 c929                                cmp #')'                                 ; finished?
  5411  3bf7 f004                                beq l66_1                                ; branch if so (use default length)
  5412  3bf9 20825d                              jsr combyt                               ; ..else get length
  5413  3bfc 2c                                  !text $2c
  5414                          
  5415  3bfd a2ff               l66_1            ldx #$ff                                 ; default length
  5416  3bff 8676                                stx z_p_temp_1
  5417  3c01 20554e                              jsr chkcls                               ; look for ')'
  5418  3c04 a9b2                                lda #equal_token                         ; look for '='
  5419  3c06 205d4e                              jsr synchr
  5420  3c09 20ef4c                              jsr frmevl                               ; bring on the source!
  5421  3c0c 20dd4c                              jsr chkstr                               ; nothing funny
  5422                          
  5423  3c0f a002                                ldy #2                                   ; get string descriptors
  5424  3c11 a94b               l66_2            lda #forpnt                              ; target
  5425  3c13 20d722                              jsr lda_far_ram1                         ; lda (forpnt),y
  5426  3c16 995d00                              sta str1,y
  5427  3c19 20a922                              jsr indfmo                               ; source
  5428  3c1c 996000                              sta str2,y
  5429  3c1f 88                                  dey
  5430  3c20 10ef                                bpl l66_2
  5431                          
  5432                          ; Test for target string in text was removed-  all strings are copied to
  5433                          ; string RAM when they are created.
  5434                          
  5435  3c22 38                                  sec                                      ; adjust pointer to source string so that the same
  5436  3c23 a561                                lda str2+1                               ; ..index can load & save
  5437  3c25 e577                                sbc hulp
  5438  3c27 8561                                sta str2+1
  5439  3c29 b002                                bcs l66_3
  5440  3c2b c662                                dec str2+2
  5441                          
  5442  3c2d a576               l66_3            lda z_p_temp_1                           ; get specified length (or default)
  5443  3c2f c560                                cmp str2                                 ; compare with length of source
  5444  3c31 9002                                bcc l66_4                                ; ok if less,
  5445  3c33 a560                                lda str2                                 ; ..else use length of source
  5446  3c35 aa                 l66_4            tax
  5447  3c36 f01f                                beq l66_7                                ; done if length=0
  5448  3c38 18                                  clc
  5449  3c39 6577                                adc hulp                                 ; add length to starting posn.
  5450  3c3b b3c115                              +lbcs fcerr                              ; illegal quantity error if > 256
  5451  3c3e c55d                                cmp str1
  5452  3c40 9003                                bcc l66_5
  5453  3c42 d3ba15                              +lbne fcerr                              ; ...or if > target length
  5454                          
  5455  3c45 a477               l66_5            ldy hulp                                 ; get adjusted starting address
  5456  3c47 da                 l66_6            phx
  5457  3c48 a25e                                ldx #str1+1
  5458  3c4a a961                                lda #str2+1
  5459  3c4c 20d722                              jsr lda_far_ram1                         ; fetch from string bank
  5460  3c4f 20f022                              jsr sta_far_ram1                         ; this is what it's all about
  5461  3c52 c8                                  iny
  5462  3c53 fa                                  plx
  5463  3c54 ca                                  dex
  5464  3c55 d0f0                                bne l66_6                                ; keep going for specified length
  5465                          
  5466  3c57 83141f             l66_7            +lbra frefac                             ; free up temp. string, rts
  5467                          
  5468                          ;.end
  5469                          ;[[command.auto]]
  5470                          
  5471                          
  5472                          
  5473                          ; AUTO Increment
  5474                          ;   Syntax :    auto {line-number} (line-number = 0 means turn off)
  5475                          
  5476                          auto
  5477  3c5a 20ed58                              jsr errind
  5478  3c5d 202e32                              jsr linget
  5479  3c60 a516                                lda linnum
  5480  3c62 8574                                sta autinc
  5481  3c64 a517                                lda linnum+1
  5482  3c66 8575                                sta autinc+1
  5483  3c68 60                                  rts
  5484                          
  5485                          ;.end
  5486                          
  5487                          
  5488                          
  5489  3c69 aec702             help             ldx errnum                               ; check for error status
  5490  3c6c e8                                  inx
  5491  3c6d f022                                beq l67_1                                ; exit if there is no current error
  5492  3c6f adc802                              lda errlin
  5493  3c72 acc902                              ldy errlin+1
  5494  3c75 8516                                sta linnum
  5495  3c77 8417                                sty linnum+1
  5496  3c79 20fa31                              jsr FindLine                             ; find the beginning of line with error
  5497  3c7c 9013                                bcc l67_1                                ; exit if line not found?
  5498                          
  5499  3c7e 20f737                              jsr crdo                                 ; begin a new line
  5500  3c81 a616                                ldx linnum
  5501  3c83 a517                                lda linnum+1
  5502  3c85 ab5500                              ldz helper
  5503  3c88 4755                                rmb4 helper                              ; temporarily disable token highlighting
  5504  3c8a f755                                smb7 helper                              ; set 'help' flag for P1LINE
  5505  3c8c 207733                              jsr p1line                               ; display line & highlight error
  5506  3c8f 6455                                stz helper
  5507  3c91 7755               l67_1            rmb7 helper                              ; reset 'help' flag
  5508  3c93 8362fb                              +lbra crdo                               ; and return to caller
  5509                          
  5510                          
  5511                          
  5512                          helpsb                                                    ; logic to highlight error or find string
  5513  3c96 cf5532                              bbs4 helper,highlight_done               ; branch if highlighting tokens
  5514  3c99 df5514                              bbs5 helper,l68_3                        ; branch if FIND
  5515                          
  5516  3c9c a662                                ldx lowtr+1                              ; has P1LINE reached code in error?
  5517  3c9e 98                                  tya
  5518  3c9f 18                                  clc
  5519  3ca0 6561                                adc lowtr                                ; add character pointer to line pointer...
  5520  3ca2 9001                                bcc l68_1
  5521  3ca4 e8                                  inx
  5522  3ca5 ecce02             l68_1            cpx errtxt+1                             ; and compare to error pointer
  5523  3ca8 d005                                bne l68_2                                ; not there
  5524  3caa cdcd02                              cmp errtxt
  5525  3cad b02d                                bcs highlight_text                       ; we're there- begin highlighting
  5526  3caf 60                 l68_2            rts
  5527                          
  5528                          
  5529  3cb0 c43f               l68_3            cpy fndpnt                               ; at first character of find string?
  5530  3cb2 9013                                bcc l68_5                                ; before it
  5531  3cb4 adda02                              lda find_count
  5532  3cb7 f00e                                beq l68_5                                ; past it
  5533  3cb9 300d                                bmi l68_6                                ; at last character
  5534  3cbb c58a                                cmp fstr1+2
  5535  3cbd 9003                                bcc l68_4                                ; in middle of string
  5536  3cbf 20dc3c                              jsr highlight_text                       ; at first char- start highlight
  5537  3cc2 ceda02             l68_4            dec find_count                           ; one less character to highlight
  5538  3cc5 f0fb                                beq l68_4                                ; special case-
  5539                          ;make it negative for next time around
  5540  3cc7 60                 l68_5            rts
  5541                          
  5542  3cc8 eeda02             l68_6            inc find_count                           ; make it zero
  5543                          
  5544                          
  5545                          highlight_done                                            ; nasty kludge to colorize error or found text
  5546  3ccb add902                              lda highlight_save
  5547  3cce 300b                                bmi l69_1                                ; (unless it's already normal)
  5548  3cd0 85f1                                sta _color                               ; restore normal color
  5549  3cd2 0980                                ora #$80
  5550  3cd4 8dd902                              sta highlight_save                       ; mark highlight_save invalid
  5551  3cd7 7755                                rmb7 helper                              ; remove HELP flag
  5552  3cd9 1755                                rmb1 helper                              ; remove token flag
  5553  3cdb 60                 l69_1            rts
  5554                          
  5555                          
  5556                          highlight_text                                            ; nasty kludge to colorize error or found text
  5557  3cdc 2cd902                              bit highlight_save
  5558  3cdf 100a                                bpl l70_1                                ; (unless it's already highlighted)
  5559  3ce1 a5f1                                lda _color                               ; save current (normal) color
  5560  3ce3 8dd902                              sta highlight_save                       ; msb=0 to mark highlight_save valid
  5561  3ce6 add802                              lda highlight_color
  5562  3ce9 85f1                                sta _color                               ; change color to highlight
  5563  3ceb 60                 l70_1            rts
  5564                          
  5565                          ;.end
  5566                          ;[[command.gotosub]]
  5567                          
  5568                          
  5569                          
  5570                          ; GOSUB-  Push text pointer, line #, & gosub token on stack:
  5571                          ;
  5572                          ;  (bottom) highest memory
  5573                          ;===========================================================
  5574                          ;  txtptr+1 address of next statement
  5575                          ;  txtptr
  5576                          ;  ========
  5577                          ;  curlin+1 current line number
  5578                          ;  curlin
  5579                          ;  ========
  5580                          ;  'gosub' token <== (tos) top of stack pointer
  5581                          ;===========================================================
  5582                          ;  (top of stack) lowest memory
  5583                          
  5584                          
  5585  3cec cf7e6a             gosub            bbs4 runmod,edit_err                     ; [910620]
  5586  3cef 20393d                              jsr gosub_sub
  5587  3cf2 208522                              jsr chrgot                               ; get character and set carry for linget
  5588  3cf5 20fb3c                              jsr goto
  5589  3cf8 8313ef                              +lbra newstt
  5590                          
  5591                          
  5592  3cfb cf7e5b             goto             bbs4 runmod,edit_err                     ; [910620]
  5593  3cfe 202e32                              jsr linget                               ; pick up the line number in LINNUM
  5594  3d01 a50b                                lda endchr                               ; test if linget found any number
  5595  3d03 f345f1                              +lbeq snerr                              ; no number error
  5596                          
  5597  3d06 205e35             goto_1           jsr remn                                 ; jump to end of line (entry for interrupt code)
  5598  3d09 38                                  sec
  5599  3d0a a53b                                lda curlin
  5600  3d0c e516                                sbc linnum
  5601  3d0e a53c                                lda curlin+1
  5602  3d10 e517                                sbc linnum+1
  5603  3d12 b00b                                bcs luk4it
  5604  3d14 98                                  tya
  5605  3d15 38                                  sec
  5606  3d16 653d                                adc txtptr
  5607  3d18 a63e                                ldx txtptr+1
  5608  3d1a 9007                                bcc lukall
  5609  3d1c e8                                  inx
  5610  3d1d 8004                                bra lukall                               ; always goes
  5611                          
  5612                          
  5613  3d1f a52d               luk4it           lda txttab
  5614  3d21 a62e                                ldx txttab+1
  5615                          
  5616  3d23 20fe31             lukall           jsr FindLink                             ; (a,x) are all set up
  5617  3d26 9316f1                              +lbcc userr                              ; undefined statement error
  5618  3d29 a561                                lda lowtr
  5619  3d2b e901                                sbc #1
  5620  3d2d 853d                                sta txtptr
  5621  3d2f a562                                lda lowtr+1
  5622  3d31 e900                                sbc #0
  5623  3d33 853e                                sta txtptr+1
  5624  3d35 7f7e63                              bbr7 runmod,setexc                       ; branch if in direct mode
  5625  3d38 60                                  rts
  5626                          
  5627                          
  5628                          
  5629                          gosub_sub
  5630  3d39 a905                                lda #lengos                              ; free up necessary space on stack
  5631  3d3b 209431                              jsr getstk                               ; make sure there is room
  5632  3d3e a004                                ldy #lengos-1
  5633  3d40 a53e                                lda txtptr+1                             ; push on the text pointer
  5634  3d42 917c                                sta (tos),y                              ; (common area)
  5635  3d44 88                                  dey
  5636  3d45 a53d                                lda txtptr
  5637  3d47 917c                                sta (tos),y                              ; (common area)
  5638  3d49 88                                  dey
  5639  3d4a a53c                                lda curlin+1                             ; push on the current line number
  5640  3d4c 917c                                sta (tos),y                              ; (common area)
  5641  3d4e 88                                  dey
  5642  3d4f a53b                                lda curlin
  5643  3d51 917c                                sta (tos),y                              ; (common area)
  5644  3d53 88                                  dey
  5645  3d54 a98d                                lda #gosub_token                         ; (a) was smashed by GETSTK
  5646  3d56 917c                                sta (tos),y                              ; (common area)
  5647  3d58 60                                  rts
  5648                          
  5649                          
  5650                          edit_err
  5651  3d59 a22a                                ldx #edit_mode_error                     ; [910620]
  5652  3d5b 83f2f0                              +lbra error
  5653                          
  5654                          ;.end
  5655                          
  5656                          
  5657                          
  5658                          go_without_to
  5659  3d5e 208322                              jsr chrget                               ; what is next character?
  5660  3d61 c9a4                                cmp #to_token                            ; ..is it GO TO?
  5661  3d63 d005                                bne l71_1
  5662  3d65 208322                              jsr chrget                               ; ..yes, set up for goto
  5663  3d68 8091                                bra goto                                 ; ..bye!
  5664                          
  5665  3d6a 206c5d             l71_1            jsr getbyt                               ; is it GO 64?
  5666  3d6d e040                                cpx #64
  5667  3d6f d3d9f0                              +lbne snerr                              ; ...no, error
  5668                          
  5669                          ; The user wants to go to C64 mode.
  5670                          
  5671  3d72 20c378             l71_2            jsr are_you_sure
  5672  3d75 d03c                                bne cont_rts                             ; must have had second thoughts. never mind
  5673                          ; jsr put_io_in_map
  5674  3d77 4c53ff                              jmp _go_64
  5675                          
  5676                          
  5677                          ;.end
  5678                          ;[[command.continue]]
  5679                          
  5680                          
  5681                          ;**********************************************************
  5682                          ;*
  5683                          ;* CONTINUE Execution after STOP/END
  5684                          ;*
  5685                          ;**********************************************************
  5686                          
  5687  3d7a d037               cont             bne cont_rts                             ; make sure there is a terminator
  5688  3d7c cf7eda                              bbs4 runmod,edit_err                     ; [910620]
  5689  3d7f ff7e31                              bbs7 runmod,cont_rts                     ; if in run-mode just rts
  5690                          
  5691  3d82 a21a                                ldx #errcn                               ; continue error.
  5692  3d84 ac7311                              ldy oldtxt+1                             ; a stored txtptr of zero set up by INIT_STACK
  5693  3d87 f3c6f0                              +lbeq error                              ; indicates there is nothing to continue
  5694                          
  5695  3d8a ad7211                              lda oldtxt                               ; STOP, END, typing crlf to INPUT, and STOP key
  5696  3d8d 853d                                sta txtptr
  5697  3d8f 843e                                sty txtptr+1
  5698  3d91 ad7011                              lda oldlin
  5699  3d94 ac7111                              ldy oldlin+1
  5700  3d97 853b                                sta curlin
  5701  3d99 843c                                sty curlin+1
  5702                          
  5703  3d9b f77e               setexc           smb7 runmod                              ; set up run mode
  5704  3d9d a900                                lda #0
  5705  3d9f 8574                                sta autinc                               ; turn auto increment off
  5706  3da1 8575                                sta autinc+1
  5707  3da3 8ddc02                              sta intval                               ; enable & reset collision-trapping mechanism
  5708  3da6 85f6                                sta _autoinsert                          ; disable auto-insert mode ?????
  5709                          
  5710  3da8 a202                                ldx #2                                   ; turn off all interrupt trip flags
  5711  3daa 9ddd02             l72_1            sta int_trip_flag,x
  5712  3dad ca                                  dex
  5713  3dae 10fa                                bpl l72_1
  5714                          
  5715  3db0 2090ff                              jsr _setmsg                              ; turn kernel messages off & rts
  5716                          
  5717                          cont_rts
  5718  3db3 60                                  rts
  5719                          
  5720                          ;.end
  5721                          ;[[command.run]]
  5722                          
  5723                          
  5724                          ;***********************************************************
  5725                          ;*
  5726                          ;* RUN Command
  5727                          ;*
  5728                          ;* RUN [line_number]
  5729                          ;* RUN filename [[ON] Ddrive_number[,Uunit_number]]
  5730                          ;*
  5731                          ;* Entry:  RUN_A_PROGRAM sets up, links, and executes
  5732                          ;*  a program previously loaded into RAM.
  5733                          ;*
  5734                          ;***********************************************************
  5735                          
  5736  3db4 cf7ea2             run              bbs4 runmod,edit_err                     ; [910620]
  5737  3db7 f019                                beq run__10                              ; branch if no arguments
  5738  3db9 901d                                bcc run__20                              ; branch if number (i.e., RUN line_number)
  5739                          
  5740                          
  5741                          ; Here if of the form "RUN file_name"
  5742                          
  5743  3dbb e77e                                smb6 runmod                              ; set flag for load not to go to ready
  5744  3dbd 206971                              jsr dload                                ; use DLOAD's parser, and load the program
  5745  3dc0 b3742a                              +lbcs erexit                             ; if problem loading   [900801]
  5746                          
  5747                          run_a_program
  5748  3dc3 20f737                              jsr crdo                                 ; [911010]
  5749  3dc6 203e42                              jsr fix_links                            ; re-link the program
  5750  3dc9 209b3d                              jsr setexc                               ; set various run modes
  5751  3dcc 20a134                              jsr runc
  5752  3dcf 833cee                              +lbra newstt                             ; start executing
  5753                          
  5754                          
  5755                          ; Here if of the form "RUN"
  5756                          
  5757  3dd2 209b3d             run__10          jsr setexc                               ; set various run codes
  5758  3dd5 83caf6                              +lbra runc                               ; ..and start executing
  5759                          
  5760                          
  5761                          ; Here if of the form "RUN line_number"
  5762                          
  5763  3dd8 20cb34             run__20          jsr clearc                               ; first trash all variables
  5764  3ddb 208522                              jsr chrgot
  5765  3dde 20fb3c                              jsr goto                                 ; set up to execute from new line number
  5766  3de1 209b3d                              jsr setexc                               ; ..and do a little housekeeping,
  5767  3de4 8327ee                              +lbra newstt                             ; ..otherwise it's business as usual
  5768                          
  5769                          ;.end
  5770                          ;[[command.restore]]
  5771                          
  5772                          
  5773                          ;*********************************************************************
  5774                          ;*
  5775                          ;* RESTORE Command
  5776                          ;*
  5777                          ;* Reset pointers to next DATA statement.  Allows optional argument
  5778                          ;* specifying a specific line number, otherwise the default is the
  5779                          ;* beginning of text area.
  5780                          ;*
  5781                          ;*********************************************************************
  5782                          
  5783                          restor
  5784  3de7 f013                                beq restore__1                           ; branch if no argument...use default
  5785  3de9 208a5d                              jsr getwrd                               ; get 2 byte argument (???? no check for real number means a var legal)
  5786  3dec 8416                                sty linnum
  5787  3dee 8517                                sta linnum+1
  5788  3df0 20fa31                              jsr FindLine                             ; get pointer to specified line
  5789  3df3 9349f0                              +lbcc userr                              ; error if not found
  5790                          
  5791  3df6 a561                                lda lowtr                                ; decrement 2 byte pointer, and save it
  5792  3df8 a462                                ldy lowtr+1
  5793  3dfa 8005                                bra restore__2                           ; always
  5794                          
  5795                          
  5796                          restore__1                                                ; entry from FLOAD
  5797  3dfc 38                                  sec
  5798  3dfd a52d                                lda txttab
  5799  3dff a42e                                ldy txttab+1
  5800                          
  5801                          restore__2
  5802  3e01 e901                                sbc #1
  5803  3e03 b001                                bcs l73_1
  5804  3e05 88                                  dey
  5805  3e06 8543               l73_1            sta datptr
  5806  3e08 8444                                sty datptr+1
  5807  3e0a 60                                  rts
  5808                          
  5809                          ;.end
  5810                          ;[[command.renumber]]
  5811                          
  5812                          
  5813                          ;***********************************************************************
  5814                          ;
  5815                          ; RENUMBER Command
  5816                          ;
  5817                          ; Syntax:  RENUMBER [n1 [,[n2] ,n3]]
  5818                          ;
  5819                          ;  n1 = new start line number, default 10
  5820                          ;  n2 = line increment, default 10
  5821                          ;  n3 = start line, default first
  5822                          ;
  5823                          ; - Syntax error may occur for missing commas or bad line numbers.
  5824                          ; - Illegal quantity error for line increment of 0 or for bad range.
  5825                          ; - Overflow error if increment wraps line number during renumber,
  5826                          ;  line number too large error if renumbering would force line
  5827                          ;  numbers greater than 63999.
  5828                          ; - Out of memory error if the renumbered program would be too large.
  5829                          ; - Unresolved reference error if an imbedded line number references
  5830                          ;  a line which does not exist.
  5831                          ;
  5832                          ; Otherwise returns to "ready" mode upon completion.
  5833                          ;
  5834                          ;***********************************************************************
  5835                          
  5836                          
  5837                          ; Before any data is changed in any way, two preliminary passes are
  5838                          ; made to insure no errors would occur during the actual renumbering
  5839                          ; process (as detailed below).
  5840                          ;
  5841                          ; Pass 1 makes sure that the renumbered program would have no line
  5842                          ; numbers greater than 63999 (nothing is actually renumbered; the
  5843                          ; statement table is not modified).
  5844                          ;
  5845                          ; Pass 2 checks if the renumbered program would be too long and also
  5846                          ; checks for non-existant line number destinations.
  5847                          ;
  5848                          ; Pass 3 examines the entire statement table first for imbedded line
  5849                          ; numbers (branches) to fix. This is done by looking for keywords (GOTO,
  5850                          ; GOSUB, THEN, RUN) which are usually followed by line numbers. The old
  5851                          ; line number is mapped to a new value and the string representing the
  5852                          ; new branch label replaces the original text.
  5853                          ;
  5854                          ; Pass 4 then replaces the statement number bytes by their final values.
  5855                          ; and the table is relinked.
  5856                          
  5857                          
  5858                          testwd
  5859  3e0b 898a8da7                            !text goto_token,run_token,gosub_token,then_token
  5860  3e0f 8cd6d7d5                            !text restore_token,resume_token,trap_token,else_token
  5861                          
  5862                          renumber
  5863  3e13 20ed58                              jsr errind                               ; allowed only in direct mode
  5864                          
  5865                          ; Set up default values for n1, n2, and n3
  5866                          
  5867  3e16 a900                                lda #0                                   ; line #10...
  5868  3e18 a20a                                ldx #10
  5869  3e1a 8e7911                              stx renum_tmp_1                          ; default renum origin (n1)
  5870  3e1d 8d7a11                              sta renum_tmp_1+1
  5871  3e20 8e7b11                              stx renum_tmp_2                          ; default increment (n2)
  5872  3e23 8d7c11                              sta renum_tmp_2+1
  5873  3e26 855c                                sta hightr                               ; default start line # (n3)
  5874  3e28 855d                                sta hightr+1
  5875                          
  5876  3e2a 208522                              jsr chrgot                               ; any parameters?
  5877  3e2d f053                                beq ren_pass_1                           ; no...
  5878                          
  5879                          
  5880                          ; Check for new starting line number (n1)
  5881                          
  5882  3e2f 202e32                              jsr linget                               ; check for a number
  5883  3e32 a50b                                lda endchr                               ; was there one?
  5884  3e34 f00a                                beq renum_10                             ; no...use default
  5885  3e36 a516                                lda linnum
  5886  3e38 a617                                ldx linnum+1
  5887  3e3a 8d7911                              sta renum_tmp_1
  5888  3e3d 8e7a11                              stx renum_tmp_1+1
  5889                          
  5890                          ; Check for new increment
  5891                          
  5892                          renum_10
  5893  3e40 20f278                              jsr optwrd                               ; an increment given?
  5894  3e43 900c                                bcc renum_30                             ; no...use default
  5895                          
  5896  3e45 8c7b11                              sty renum_tmp_2
  5897  3e48 8d7c11                              sta renum_tmp_2+1
  5898  3e4b 0d7b11                              ora renum_tmp_2                          ; increment must be >0
  5899  3e4e f3ae13                              +lbeq fcerr                              ; illegal quantity error
  5900                          
  5901                          ; Check for starting line number
  5902                          
  5903                          renum_30
  5904  3e51 20f278                              jsr optwrd                               ; starting line number given?
  5905  3e54 902c                                bcc ren_pass_1                           ; no...
  5906                          
  5907  3e56 845c                                sty hightr
  5908  3e58 8416                                sty linnum
  5909  3e5a 855d                                sta hightr+1
  5910  3e5c 8517                                sta linnum+1
  5911  3e5e 20fa31                              jsr FindLine                             ; test for illegal renumber range
  5912  3e61 a561                                lda lowtr                                ; (n1 must be >= n3)
  5913  3e63 a662                                ldx lowtr+1
  5914  3e65 855a                                sta highds                               ; pointer to first statement to renumber
  5915  3e67 865b                                stx highds+1
  5916  3e69 ad7911                              lda renum_tmp_1
  5917  3e6c ae7a11                              ldx renum_tmp_1+1
  5918  3e6f 8516                                sta linnum
  5919  3e71 8617                                stx linnum+1
  5920  3e73 20fa31                              jsr FindLine                             ; lowtr = ptr to 1st stmt to be overlapped
  5921  3e76 38                                  sec
  5922  3e77 a561                                lda lowtr                                ; can't be smaller
  5923  3e79 e55a                                sbc highds
  5924  3e7b a562                                lda lowtr+1
  5925  3e7d e55b                                sbc highds+1
  5926  3e7f 937d13                              +lbcc fcerr                              ; bad...
  5927                          
  5928                          
  5929                          ;***********************************************************************
  5930                          ;**************  R E N U M B E R    P A S S    O N E  ******************
  5931                          ;***********************************************************************
  5932                          
  5933                          ; Pass 1 makes sure that the renumbered program will not have any line numbers
  5934                          ; greater than 63999 (however, nothing is actually renumbered in this pass).
  5935                          
  5936                          ren_pass_1
  5937  3e82 20472c                              jsr tto                                  ; save txtptr for restoration when done
  5938  3e85 207240                              jsr n1_reset                             ; put n1 in FAC, reset txtptr
  5939  3e88 20a540                              jsr chargt                               ; skip low link
  5940  3e8b c8                                  iny                                      ; (.y=1)
  5941  3e8c 20c522                              jsr indtxt                               ; skip high link
  5942  3e8f f03a                                beq ren_pass_2                           ; end of program => begin pass 2 (assumes txttab > 0)
  5943                          
  5944                          r_pass1_10
  5945  3e91 c8                                  iny                                      ; (.y=2)
  5946  3e92 20c522                              jsr indtxt                               ; line number low
  5947  3e95 38                                  sec
  5948  3e96 e55c                                sbc hightr                               ; in line range which is to be renumbered?
  5949  3e98 c8                                  iny                                      ; (.y=3)
  5950  3e99 20c522                              jsr indtxt                               ; line number high
  5951  3e9c e55d                                sbc hightr+1
  5952  3e9e b007                                bcs r_pass1_20                           ; yes => fake renumbering
  5953  3ea0 20ba3e                              jsr set_next                             ; goto next line
  5954  3ea3 d0ec                                bne r_pass1_10                           ; if z=0 then not end-of-text => keep going
  5955  3ea5 f024                                beq ren_pass_2                           ; else end
  5956                          
  5957                          r_pass1_20
  5958  3ea7 20ba3e                              jsr set_next                             ; goto next line
  5959  3eaa f01f                                beq ren_pass_2                           ; if z=1 then end-of-text => exit
  5960  3eac 209340                              jsr new_num                              ; create next line number
  5961  3eaf b004                                bcs r_pass1_30                           ; if c=1 then it wrapped => error
  5962  3eb1 c9f9                                cmp #>63999                              ; can't have lines > 63999
  5963  3eb3 90f2                                bcc r_pass1_20                           ; if c=0 then ok
  5964                          
  5965                          r_pass1_30                                                ; renumbering will generate an illegal line #
  5966  3eb5 a226                                ldx #err_too_large                       ; 'line number too large' error
  5967  3eb7 8396ef                              +lbra error
  5968                          
  5969                          set_next
  5970  3eba a000                                ldy #0                                   ; set for next BASIC line
  5971  3ebc 20c522                              jsr indtxt                               ; low link
  5972  3ebf aa                                  tax
  5973  3ec0 c8                                  iny                                      ; (.y=1)
  5974  3ec1 20c522                              jsr indtxt                               ; high link
  5975  3ec4 f004                                beq set_end                              ; if z=1 then end of program => exit
  5976  3ec6 863d                                stx txtptr
  5977  3ec8 853e                                sta txtptr+1
  5978  3eca 60                 set_end          rts
  5979                          
  5980                          
  5981                          ;***********************************************************************
  5982                          ;**************  R E N U M B E R    P A S S    T W O  ******************
  5983                          ;***********************************************************************
  5984                          
  5985                          ; Pass 2 checks if the renumbered program will be too long and also
  5986                          ; checks for non-existant line number destinations.
  5987                          
  5988                          ren_pass_2
  5989  3ecb 4f7e05                              bbr4 runmod,l74_1                        ; skip pass two and three if plain text (edit mode) [910620]
  5990  3ece 207240                              jsr n1_reset                             ; yes- just setup up starting line # and reset txtptr
  5991  3ed1 8014                                bra ren_pass_4                           ; then renumber just the text's line numbers
  5992                          
  5993  3ed3 a901               l74_1            lda #$01                                 ; set flag for 'pass 2'
  5994  3ed5 8576                                sta z_p_temp_1
  5995  3ed7 a582                                lda text_top                             ; copy top-of-text pointer for later use
  5996  3ed9 a683                                ldx text_top+1                           ; (we don't want to change original here)
  5997  3edb 853f                                sta fndpnt
  5998  3edd 8640                                stx fndpnt+1
  5999  3edf 20293f                              jsr imbed_lines                          ; search for imbedded lines (but don't change)
  6000                          
  6001                          
  6002                          
  6003                          ;***********************************************************************
  6004                          ;************  R E N U M B E R    P A S S    T H R E E  ****************
  6005                          ;***********************************************************************
  6006                          
  6007                          ; Pass 3 actually renumbers the imbedded destination line numbers
  6008                          ; which follow goto, gosub, trap, etc.
  6009                          
  6010                          ren_pass_3
  6011  3ee2 c676                                dec z_p_temp_1                           ; z_p_temp_1 = 0 (for pass 3)
  6012  3ee4 20293f                              jsr imbed_lines                          ; search for and update imbedded line #'s
  6013                          
  6014                          
  6015                          ;***********************************************************************
  6016                          ;*************  R E N U M B E R    P A S S    F O U R  *****************
  6017                          ;***********************************************************************
  6018                          
  6019                          ; Pass 4 actually renumbers the program line numbers & exits
  6020                          
  6021                          ren_pass_4
  6022  3ee7 20a340                              jsr chargt_x2                            ; skip link
  6023  3eea f031                                beq renumber_exit                        ; null link=> end-of-text, exit (assumes txttab > 0)
  6024  3eec 20a540                              jsr chargt                               ; not null...
  6025  3eef 8516                                sta linnum                               ; if line# >= start#, replace with facho
  6026  3ef1 c8                                  iny
  6027  3ef2 20c522                              jsr indtxt
  6028  3ef5 38                                  sec
  6029  3ef6 e55d                                sbc hightr+1
  6030  3ef8 901b                                bcc r_pass4_20                           ; no, let alone
  6031  3efa d006                                bne r_pass4_10                           ; yes, replace
  6032  3efc a516                                lda linnum
  6033  3efe e55c                                sbc hightr
  6034  3f00 9013                                bcc r_pass4_20                           ; no, let alone
  6035                          
  6036                          r_pass4_10
  6037  3f02 a564                                lda facho
  6038                          ; phx
  6039  3f04 200a23                              jsr sta_far_txt                          ; sta (txtptr),y  hi  (bleed-thru)
  6040  3f07 88                                  dey
  6041  3f08 a565                                lda facho+1
  6042  3f0a 200a23                              jsr sta_far_txt                          ; sta (txtptr),y  lo (bleed-thru)
  6043                          ; plx
  6044  3f0d 20a540                              jsr chargt                               ; skip past 2nd byte of line#
  6045  3f10 208a40                              jsr line_inc                             ; incr line# and scan to eol
  6046  3f13 80d2                                bra ren_pass_4                           ; always...
  6047                          
  6048                          r_pass4_20
  6049  3f15 20a540                              jsr chargt                               ; skip past line#
  6050  3f18 208d40                              jsr scan_thru                            ; scan to eol
  6051  3f1b 80ca                                bra ren_pass_4                           ; always...
  6052                          
  6053                          
  6054                          renumber_exit
  6055  3f1d 203e42                              jsr fix_links                            ; patch things up: relink & set eot
  6056                          
  6057                          direct_mode_exit
  6058  3f20 20f439                              jsr ott                                  ; restore txtptr for next command in buffer
  6059  3f23 a900                                lda #0                                   ; but disallow continuing
  6060  3f25 8d7311                              sta oldtxt+1
  6061  3f28 60                                  rts
  6062                          
  6063                          
  6064                          ;***********************************************************************
  6065                          ;*************  R E N U M B E R   S U B R O U T I N E S  ***************
  6066                          ;***********************************************************************
  6067                          
  6068                          ; Look for imbedded line #'s (after GOTO, GOSUB, etc.)
  6069                          ; but only change them in pass 3 (ie. z_p_temp_1 = 0)
  6070                          
  6071                          imbed_lines
  6072  3f29 201f35                              jsr reset_txtptr                         ; start at first line: load (txtptr) with (txttab)-1
  6073                          
  6074                          next_line
  6075  3f2c 20a340                              jsr chargt_x2                            ; skip link (assumes txttab > 0)
  6076  3f2f f34101                              +lbeq n1_reset                           ; null link: put current line # in fac, reset txtptr, exit
  6077  3f32 20a540                              jsr chargt                               ; line number
  6078  3f35 854b                                sta forpnt                               ; save in case there is an error
  6079  3f37 20a540                              jsr chargt
  6080  3f3a 854c                                sta forpnt+1
  6081                          
  6082                          next_char
  6083  3f3c 20a540                              jsr chargt                               ; first character in the line
  6084                          
  6085                          chk_quote
  6086  3f3f c922                                cmp #'"'                                 ; opening double quote?
  6087  3f41 d00b                                bne not_quote                            ; no...
  6088  3f43 20a540             l75_1            jsr chargt                               ; scan line
  6089  3f46 f0e4                                beq next_line                            ; end...
  6090  3f48 c922                                cmp #'"'                                 ; close double quote
  6091  3f4a d0f7                                bne l75_1                                ; no... continue
  6092  3f4c 80ee                                bra next_char                            ; yes... resume renumber
  6093                          
  6094                          not_quote
  6095  3f4e aa                                  tax                                      ; end of line?
  6096  3f4f f0db                                beq next_line                            ; yes...
  6097  3f51 10e9                                bpl next_char                            ; not a token...
  6098                          
  6099  3f53 a208                                ldx #8                                   ; check special token list
  6100  3f55 dd0a3e             l76_1            cmp testwd-1,x
  6101  3f58 f028                                beq iline_10                             ; a match...
  6102  3f5a ca                                  dex
  6103  3f5b d0f8                                bne l76_1                                ; continue until zero
  6104                          
  6105  3f5d c9cb                                cmp #go_token                            ; wasn't in the token list. check for 'go to'
  6106  3f5f d00b                                bne chk_escape                           ; not 'go', go check for 'collision' *c128 fix*
  6107  3f61 208322             hop_1            jsr chrget                               ; got a 'go', look for 'to'
  6108  3f64 f0c6                                beq next_line                            ; end of line, abort
  6109  3f66 c9a4                                cmp #to_token
  6110  3f68 f018                                beq iline_10                             ; got it! go to fix number routine
  6111  3f6a 80d0                                bra next_char                            ; no 'to', keep looking
  6112                          
  6113                          ; Look for 'COLLISION'.  This is an escape command. *c128 fix* ?????????
  6114                          
  6115                          chk_escape
  6116  3f6c c9fe                                cmp #esc_command_token
  6117  3f6e d0cc                                bne next_char
  6118  3f70 208322                              jsr chrget
  6119  3f73 f0ec                                beq hop_1                                ; end of line ,abort
  6120  3f75 c917                                cmp #collision_token
  6121  3f77 d0c3                                bne next_char
  6122  3f79 208322             l77_1            jsr chrget                               ; got it! skip over first argument
  6123  3f7c f0e3                                beq hop_1                                ; end of line, abort
  6124  3f7e c92c                                cmp #','
  6125  3f80 d0f7                                bne l77_1                                ; not there yet
  6126                          
  6127                          
  6128                          iline_10
  6129  3f82 a53d                                lda txtptr                               ; save current txtptr
  6130  3f84 8d7011                              sta oldlin
  6131  3f87 a53e                                lda txtptr+1
  6132  3f89 8d7111                              sta oldlin+1
  6133  3f8c 208322                              jsr chrget
  6134  3f8f b0ae                                bcs chk_quote                            ; not a #...
  6135  3f91 202e32                              jsr linget                               ; get line # from text
  6136  3f94 202340                              jsr form_line                            ; replace if this line # > n3
  6137  3f97 ad7011                              lda oldlin                               ; restore old txtptr
  6138  3f9a 853d                                sta txtptr
  6139  3f9c ad7111                              lda oldlin+1
  6140  3f9f 853e                                sta txtptr+1
  6141                          
  6142  3fa1 208322                              jsr chrget                               ; skip over leading spaces
  6143  3fa4 c33d                                dew txtptr                               ; then backup (txtptr) by 1
  6144  3fa6 a2ff                                ldx #$ff
  6145  3fa8 a576                                lda z_p_temp_1                           ; if this is pass2 then don't actually change
  6146  3faa f037                                beq p3code                               ; if z=1 then pass3 => ok to change
  6147  3fac 20b83f                              jsr p2code                               ; renumber 'pass two': trial run to see if enough room
  6148  3faf 208522                              jsr chrgot                               ; re-get last character from BASIC text & rts
  6149                          
  6150                          iline_20
  6151  3fb2 c92c                                cmp #','                                 ; comma from 'on'?
  6152  3fb4 f0cc                                beq iline_10                             ; it is...
  6153  3fb6 8087                                bra chk_quote                            ; no...
  6154                          
  6155                          
  6156                          ;*********** This part of imbed_lines executed in pass 2 only **********
  6157                          
  6158                          p2code                                                    ; updates text_top without actually changing lines
  6159  3fb8 e8                                  inx
  6160  3fb9 bd0101                              lda fbuffr+1,x                           ; get character from number
  6161  3fbc f01c                                beq l78_3                                ; end of number
  6162  3fbe 208322                              jsr chrget                               ; get digit from old number
  6163  3fc1 90f5                                bcc p2code                               ; digit...move on
  6164                          
  6165  3fc3 e33f               l78_1            inw fndpnt
  6166  3fc5 38                                  sec                                      ; have we run out of memory (theoretically)?
  6167  3fc6 a53f                                lda fndpnt                               ; (compare with limit-of-memory pointer)
  6168  3fc8 edcf02                              sbc max_mem_0
  6169  3fcb a540                                lda fndpnt+1
  6170  3fcd edd002                              sbc max_mem_0+1
  6171  3fd0 b36fee                              +lbcs omerr                              ; yes- out of memory error
  6172  3fd3 e8                                  inx                                      ; no - next...
  6173  3fd4 bd0101                              lda fbuffr+1,x
  6174  3fd7 d0ea                                bne l78_1
  6175  3fd9 60                 l78_2            rts                                      ; no more
  6176                          
  6177  3fda 208322             l78_3            jsr chrget
  6178  3fdd b0fa                                bcs l78_2                                ; old stuff after # is other char
  6179  3fdf c33f                                dew fndpnt                               ; digit...move down
  6180  3fe1 80f7                                bra l78_3                                ; still digits...
  6181                          
  6182                          
  6183                          ;*********** This part of imbed_lines executed in pass 3 only **********
  6184                          
  6185                          p3code
  6186  3fe3 e8                                  inx
  6187  3fe4 bd0101                              lda fbuffr+1,x                           ; get character from number
  6188  3fe7 f026                                beq l79_3                                ; end of number
  6189                          
  6190  3fe9 48                                  pha                                      ; save digit from new number
  6191  3fea 20a540                              jsr chargt                               ; get digit from old number
  6192  3fed c93a                                cmp #':'                                 ; command terminator or letter?
  6193  3fef b00c                                bcs l79_1
  6194  3ff1 c920                                cmp #' '                                 ; space? (fix for goto10 :rem)
  6195  3ff3 f008                                beq l79_1
  6196  3ff5 38                                  sec
  6197  3ff6 e930                                sbc #'0'                                 ; number?
  6198  3ff8 38                                  sec
  6199  3ff9 e9d0                                sbc #$d0
  6200  3ffb 9008                                bcc l79_2                                ; digit...move on
  6201                          
  6202  3ffd 20ac40             l79_1            jsr move_init                            ; other char...move up
  6203  4000 201741                              jsr moveup
  6204  4003 e382                                inw text_top
  6205                          
  6206  4005 68                 l79_2            pla
  6207  4006 da                                  phx
  6208  4007 a000                                ldy #0
  6209  4009 200a23                              jsr sta_far_txt                          ; put new digit in new number (bleed-thru)
  6210  400c fa                                  plx
  6211  400d 80d4                                bra p3code
  6212                          
  6213                          
  6214  400f 208322             l79_3            jsr chrget
  6215  4012 b09e                                bcs iline_20                             ; old stuff after # is other char
  6216                          
  6217  4014 20ac40             l79_4            jsr move_init                            ; digit...move down
  6218  4017 20c440                              jsr movedown
  6219  401a c382                                dew text_top
  6220  401c 208522                              jsr chrgot
  6221  401f 90f3                                bcc l79_4                                ; still digits...
  6222                          
  6223  4021 808f                                bra iline_20                             ; branch always
  6224                          
  6225                          
  6226                          ;*************************** FORM_LINE *********************************
  6227                          
  6228                          ; Remaps the destination line if it is greater than n3
  6229                          
  6230                          form_line
  6231  4023 207240                              jsr n1_reset
  6232                          find_it
  6233  4026 20a340                              jsr chargt_x2                            ; new line, skip over link
  6234  4029 d00d                                bne l80_1                                ; if we get to end-of-text without finding the
  6235  402b a227                                ldx #err_ref                             ; line # then 'unresolved reference' error
  6236  402d a54b                                lda forpnt
  6237  402f 853b                                sta curlin                               ; fake error routine into saying 'in line xxxxx'
  6238  4031 a54c                                lda forpnt+1
  6239  4033 853c                                sta curlin+1
  6240  4035 8318ee                              +lbra error
  6241                          
  6242  4038 20a540             l80_1            jsr chargt                               ; get line number low
  6243  403b 855a                                sta highds                               ; highds = current line# in loop
  6244  403d c516                                cmp linnum
  6245  403f d027                                bne l80_4
  6246  4041 20a540                              jsr chargt                               ; get line number high
  6247  4044 855b                                sta highds+1
  6248  4046 c517                                cmp linnum+1
  6249  4048 d023                                bne l80_5
  6250  404a 38                                  sec                                      ; if linnum < start#, no remapping
  6251  404b e55d                                sbc hightr+1
  6252  404d 9008                                bcc l80_2
  6253  404f d00e                                bne l80_3
  6254  4051 a516                                lda linnum
  6255  4053 e55c                                sbc hightr
  6256  4055 b008                                bcs l80_3
  6257                          
  6258  4057 a516               l80_2            lda linnum                               ; use same line#
  6259  4059 8565                                sta facho+1
  6260  405b a517                                lda linnum+1
  6261  405d 8564                                sta facho
  6262                          
  6263  405f a290               l80_3            ldx #$90                                 ; make replacement string
  6264  4061 38                                  sec
  6265  4062 20df62                              jsr floatc
  6266  4065 832824                              +lbra fout
  6267                          
  6268                          
  6269  4068 20a540             l80_4            jsr chargt
  6270  406b 855b                                sta highds+1                             ; (** 01/27/84 fix)
  6271                          
  6272  406d 207f40             l80_5            jsr line_add                             ; scan to end of line
  6273  4070 80b4                                bra find_it                              ; always
  6274                          
  6275                          
  6276                          ;*************************** N1_RESET **********************************
  6277                          
  6278                          ; Copies n1 (new renumber origin) into facho & sets (txtptr) = (txttab)-1
  6279                          
  6280                          n1_reset
  6281  4072 ad7911                              lda renum_tmp_1
  6282  4075 8565                                sta facho+1
  6283  4077 ad7a11                              lda renum_tmp_1+1
  6284  407a 8564                                sta facho
  6285  407c 83a1f4                              +lbra reset_txtptr
  6286                          
  6287                          
  6288                          ;*************************** LINE_ADD **********************************
  6289                          
  6290                          ; Adds n2 (new line increment) to line number stored in facho if the
  6291                          ; current line number (highds) >= n3 (line to start renumbering with).
  6292                          ; The line is then scanned.
  6293                          
  6294                          line_add
  6295  407f a55a                                lda highds                               ; if line# >= start# then incr new#
  6296  4081 38                                  sec
  6297  4082 e55c                                sbc hightr
  6298  4084 a55b                                lda highds+1
  6299  4086 e55d                                sbc hightr+1
  6300  4088 9003                                bcc scan_thru
  6301                          
  6302                          line_inc
  6303  408a 209340                              jsr new_num
  6304                          
  6305                          scan_thru
  6306  408d 20a540                              jsr chargt                               ; scan to end of line
  6307  4090 d0fb                                bne scan_thru
  6308  4092 60                                  rts
  6309                          
  6310                          
  6311                          ;**************************** NEW_NUM **********************************
  6312                          
  6313                          ; Adds n2 (the new line increment) to the line number stored in facho.
  6314                          
  6315                          new_num
  6316  4093 a565                                lda facho+1                              ; increment new line#
  6317  4095 18                                  clc
  6318  4096 6d7b11                              adc renum_tmp_2
  6319  4099 8565                                sta facho+1
  6320  409b a564                                lda facho
  6321  409d 6d7c11                              adc renum_tmp_2+1
  6322  40a0 8564                                sta facho
  6323  40a2 60                                  rts
  6324                          
  6325                          
  6326                          ;********************** CHARGT & CHARGT_X2 *****************************
  6327                          
  6328                          ; Chargt simulates chrget but doesn't ignore spaces & carry has no
  6329                          ; significance.  Chargt_x2 executes chargt twice.
  6330                          ; Used by Renumber, Find/Change, etc.
  6331                          
  6332                          chargt_x2
  6333  40a3 e33d                                inw txtptr                               ; jsr chargt
  6334                          chargt
  6335  40a5 a000                                ldy #0                                   ; increment txtptr
  6336  40a7 e33d                                inw txtptr
  6337  40a9 831ae2                              +lbra indtxt
  6338                          
  6339                          
  6340                          ;***********************************************************************
  6341                          ;************************* MEMORY MOVE ROUTINES ************************
  6342                          ;***********************************************************************
  6343                          
  6344                          ;****************************** MOVEINIT *******************************
  6345                          
  6346                          ; Setup for Renumber memory move.
  6347                          
  6348                          move_init
  6349  40ac a53d                                lda txtptr                               ; index1 = txtptr
  6350  40ae 8524                                sta index1
  6351  40b0 a53e                                lda txtptr+1
  6352  40b2 8525                                sta index1+1
  6353                          
  6354  40b4 a582                                lda text_top                             ; index2 = text_top
  6355  40b6 8526                                sta index2
  6356  40b8 a583                                lda text_top+1
  6357  40ba 8527                                sta index2+1
  6358                          
  6359  40bc a901                                lda #1                                   ; move 1 character
  6360  40be 850d                                sta count                                ; lo
  6361  40c0 3a                                  dec
  6362  40c1 856d                                sta argmo                                ; hi
  6363                          
  6364  40c3 60                                  rts
  6365                          
  6366                          
  6367                          ;****************************** MOVEDOWN *******************************
  6368                          
  6369                          ; Move block of BASIC text from INDEX1+COUNT to INDEX2 down to INDEX1.
  6370                          ; Used by commands Renumber, Find/Change.
  6371                          
  6372                          movedown
  6373  40c4 38                                  sec                                      ; set up DMA list:   [900524]
  6374  40c5 a526                                lda index2
  6375  40c7 e524                                sbc index1
  6376  40c9 8d4501                              sta dma1_cnt_lo                          ; cnt = index2-index1-count
  6377  40cc a527                                lda index2+1
  6378  40ce e525                                sbc index1+1
  6379  40d0 8d4601                              sta dma1_cnt_hi
  6380  40d3 38                                  sec
  6381  40d4 ad4501                              lda dma1_cnt_lo
  6382  40d7 e50d                                sbc count                                ; lo
  6383  40d9 8d4501                              sta dma1_cnt_lo
  6384  40dc ad4601                              lda dma1_cnt_hi
  6385  40df e56d                                sbc argmo                                ; hi
  6386  40e1 8d4601                              sta dma1_cnt_hi
  6387                          
  6388  40e4 18                                  clc
  6389  40e5 a524                                lda index1
  6390  40e7 8d4a01                              sta dma1_dest_lo                         ; dest = index1
  6391  40ea 650d                                adc count
  6392  40ec 8d4701                              sta dma1_src_lo                          ; src = index1+count
  6393  40ef a525                                lda index1+1
  6394  40f1 8d4b01                              sta dma1_dest_hi
  6395  40f4 656d                                adc argmo
  6396  40f6 8d4801                              sta dma1_src_hi
  6397                          
  6398  40f9 a584                                lda text_bank                            ; bank = BASIC text bank
  6399                          ; and #%00001111  ;      [910520] F018A
  6400  40fb 8d4901                              sta dma1_src_bank
  6401  40fe 8d4c01                              sta dma1_dest_bank
  6402                          
  6403                          execute_DMA1                                              ; [910620] Edit
  6404  4101 a900                                lda #0
  6405  4103 8d4401                              sta dma1_cmd                             ; command = copy from startpoint
  6406  4106 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
  6407                          
  6408  4109 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
  6409  410c a901                                lda #>dma1_cmd
  6410  410e 8d01d7                              sta dma_ctlr+1                           ; dma_list hi
  6411  4111 a944                                lda #<dma1_cmd
  6412  4113 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
  6413  4116 60                                  rts
  6414                          
  6415                          
  6416                          ;******************************* MOVEUP ********************************
  6417                          
  6418                          ; Move block of BASIC text from INDEX1 to INDEX2 up to INDEX2+COUNT.
  6419                          ; Used by commands Renumber, Find/Change.
  6420                          
  6421                          moveup
  6422  4117 38                                  sec                                      ; set up DMA list:   [900524]
  6423  4118 a526                                lda index2
  6424  411a e524                                sbc index1
  6425  411c 8d4501                              sta dma1_cnt_lo                          ; cnt = index2-index1
  6426  411f a527                                lda index2+1
  6427  4121 e525                                sbc index1+1
  6428  4123 8d4601                              sta dma1_cnt_hi
  6429                          
  6430  4126 c326                                dew index2                               ; (index2 = text_top = end+1)
  6431  4128 18                                  clc
  6432  4129 a526                                lda index2
  6433  412b 8d4701                              sta dma1_src_lo                          ; src = index2
  6434  412e 650d                                adc count
  6435  4130 8d4a01                              sta dma1_dest_lo                         ; dest = index2+count
  6436  4133 a527                                lda index2+1
  6437  4135 8d4801                              sta dma1_src_hi
  6438  4138 656d                                adc argmo
  6439  413a 8d4b01                              sta dma1_dest_hi
  6440                          
  6441                          ; lda dma_ctlr+3  ;dma controller version    [910520] F018A
  6442                          ; and #1
  6443                          ; beq l81_1   ; F018    removed [910808] F018B
  6444  413d a930                                lda #%00110000                           ; F018A,B
  6445  413f 8d4401             l81_1            sta dma1_cmd                             ; command=copy, source=start   [910102]
  6446                          ; php
  6447  4142 a584                                lda text_bank                            ; bank = BASIC text bank   [910520] F018A
  6448                          ; plp   ;version?    removed [910808] F018B
  6449                          ; bne l81_2   ; F018A
  6450                          ; and #%00001111  ; F018     [910102]
  6451                          ; ora #%01000000  ;(copy source=endpoint)    [910102]
  6452  4144 8d4901             l81_2            sta dma1_src_bank                        ; banks
  6453  4147 8d4c01                              sta dma1_dest_bank
  6454                          
  6455  414a a900                                lda #0                                   ; [910219]
  6456                          ; sta dma1_cmd  ; command = copy, source=endpoint
  6457  414c 8d4d01                              sta dma1_subcmd                          ; [910520] F018A
  6458                          ; dec a   ;      [910219]
  6459  414f 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
  6460  4152 a001                                ldy #>dma1_cmd                           ; dma_list
  6461  4154 a944                                lda #<dma1_cmd
  6462  4156 8c01d7                              sty dma_ctlr+1                           ; dma_list hi
  6463  4159 8d00d7                              sta dma_ctlr                             ; dma_list lo & trigger
  6464  415c 60                                  rts
  6465                          
  6466                          ;.end
  6467                          
  6468                          ;[[command.for]]
  6469                          
  6470                          ; FOR
  6471                          ;
  6472                          ; Push the following information on the run-time stack:
  6473                          ;
  6474                          ; (bottom)   highest memory
  6475                          ; =========================
  6476                          ;  txtptr    address of next statement
  6477                          ;  txtptr+1
  6478                          ;  ========
  6479                          ;  curlin+1  current line number
  6480                          ;  curlin
  6481                          ;  ========
  6482                          ;  to lo
  6483                          ;  to mo
  6484                          ;  to moh    'to' value
  6485                          ;  to ho
  6486                          ;  to exp
  6487                          ;  ========
  6488                          ;  step sign
  6489                          ;  step lo
  6490                          ;  step mo
  6491                          ;  step moh  'step' value
  6492                          ;  step ho
  6493                          ;  step exp
  6494                          ;  ========
  6495                          ;  forpnt+1  'for' variable pointer
  6496                          ;  forpnt
  6497                          ;  ========
  6498                          ;  'for' token       <== (tos) top of stack pointer
  6499                          ; ============================
  6500                          ; (top of stack)  lowest memory
  6501                          
  6502                          
  6503  415d a980               for              lda #$80
  6504  415f 8512                                sta subflg                               ; no arrays(), no integers%
  6505  4161 207636                              jsr let                                  ; get & set FOR variables
  6506  4164 a981                                lda #for_token                           ; set up for call to see if
  6507  4166 204331                              jsr search                               ; ..this 'for' variable is unique
  6508  4169 f008                                beq l82_1                                ; branch if not
  6509                          
  6510                          ; If the variable is not unique, (fndpnt) will point to last occurance
  6511                          ; in stack, and we will reset the stack to that point.  Otherwise we
  6512                          ; will adjust the pointer by 'lenfor' and start from that point.
  6513                          
  6514  416b a912                                lda #lenfor
  6515  416d 209431                              jsr getstk                               ; updates stack pointer, error if overflow
  6516  4170 20dd31                              jsr movtos                               ; (tos) => (fndpnt)
  6517                          
  6518  4173 20e631             l82_1            jsr movfnd                               ; (fndpnt) => (tos)   (redundant for new entries)
  6519  4176 205b35                              jsr datan                                ; find address of next statement
  6520  4179 98                                  tya                                      ; offset from (txtptr) in y
  6521  417a a011                                ldy #lenfor-1
  6522                          
  6523  417c 18                                  clc                                      ; Push address of next statement on stack
  6524  417d 653d                                adc txtptr
  6525  417f 917c                                sta (tos),y                              ; (common area)
  6526  4181 a53e                                lda txtptr+1
  6527  4183 6900                                adc #0
  6528  4185 88                                  dey
  6529  4186 917c                                sta (tos),y                              ; (common area)
  6530                          
  6531  4188 a53c                                lda curlin+1                             ; Push current line number on stack
  6532  418a 88                                  dey
  6533  418b 917c                                sta (tos),y                              ; (common area)
  6534  418d a53b                                lda curlin
  6535  418f 88                                  dey
  6536  4190 917c                                sta (tos),y                              ; (common area)
  6537                          
  6538  4192 a9a4                                lda #to_token                            ; Look for TO, must appear
  6539  4194 205d4e                              jsr synchr
  6540  4197 20db4c                              jsr chknum                               ; get TO value
  6541  419a 20d84c                              jsr frmnum
  6542  419d a568                                lda facsgn
  6543  419f 097f                                ora #$7f
  6544  41a1 2564                                and facho
  6545  41a3 8564                                sta facho
  6546                          
  6547  41a5 a204                                ldx #4
  6548  41a7 a00d                                ldy #lenfor-5
  6549  41a9 b563               l82_2            lda facexp,x                             ; Push faclo,mo,moh,ho,exp
  6550  41ab 917c                                sta (tos),y                              ; (common area)
  6551  41ad ca                                  dex
  6552  41ae 88                                  dey
  6553  41af 10f8                                bpl l82_2
  6554                          
  6555  41b1 a999                                lda #<fone                               ; Push STEP value
  6556  41b3 a05f                                ldy #>fone                               ; (point to default 'one' in ROM)
  6557  41b5 200e62                              jsr movfm
  6558  41b8 208522                              jsr chrgot
  6559  41bb c9a9                                cmp #step_token
  6560  41bd d006                                bne l82_3                                ; branch if no step given
  6561  41bf 208322                              jsr chrget
  6562  41c2 20d84c                              jsr frmnum
  6563                          
  6564  41c5 20c162             l82_3            jsr sign
  6565  41c8 48                                  pha                                      ; save sign for a moment
  6566  41c9 20b262                              jsr round
  6567  41cc 68                                  pla
  6568                          
  6569  41cd a008                                ldy #lenfor-10
  6570  41cf a205                                ldx #5
  6571  41d1 917c               l82_4            sta (tos),y                              ; (common area)
  6572  41d3 b562                                lda facexp-1,x
  6573  41d5 88                                  dey
  6574  41d6 ca                                  dex
  6575  41d7 10f8                                bpl l82_4
  6576                          
  6577  41d9 a54c                                lda forpnt+1                             ; Finally push pointer to 'for' variable, & 'for' token
  6578  41db 917c                                sta (tos),y                              ; (common area)
  6579  41dd a54b                                lda forpnt
  6580  41df 88                                  dey
  6581  41e0 917c                                sta (tos),y                              ; (common area)
  6582  41e2 a981                                lda #for_token
  6583  41e4 88                                  dey
  6584  41e5 917c                                sta (tos),y                              ; (common area)
  6585  41e7 60                                  rts
  6586                          
  6587                          ;.end
  6588                          ;[[command.delete]]
  6589                          
  6590                          
  6591                          
  6592                          ; Delete a range of source   -or-   Delete a disk file
  6593                          ;
  6594                          ; Syntax: DELETE from# - to# (same range parameters as LIST)
  6595                          ;  DELETE "filename" (same parameters as SCRATCH)
  6596                          
  6597                          ; Determine which form of DELETE we have...
  6598                          
  6599  41e8 9007               delete           bcc delete_line                          ; branch if a number (assume range parameter)
  6600  41ea c9ab                                cmp #minus_token
  6601  41ec f003                                beq delete_line                          ; branch if a dash (assume range parameter)
  6602  41ee 83e430                              +lbra scratch                            ; branch if string (assume filename or U#)
  6603                          
  6604                          delete_line
  6605  41f1 20ed58                              jsr errind                               ; direct mode only command
  6606  41f4 208522                              jsr chrgot                               ; requires line# or range, no default
  6607  41f7 f351ec                              +lbeq snerr                              ; error, none given
  6608                          
  6609  41fa 205042                              jsr range                                ; parse range, find starting line, ptr to ending line
  6610  41fd a561                                lda lowtr
  6611  41ff a662                                ldx lowtr+1
  6612  4201 8524                                sta index1                               ; (destination)
  6613  4203 8625                                stx index1+1
  6614                          
  6615  4205 20fa31                              jsr FindLine                             ; find ending line
  6616  4208 9015                                bcc l83_2                                ; branch if not found
  6617  420a a001                                ldy #1
  6618  420c 20ad22                              jsr indlow                               ; if eot, use this ptr.  else, need ptr to next
  6619  420f 88                                  dey
  6620  4210 aa                                  tax                                      ; save it in case of swap
  6621  4211 d005                                bne l83_1                                ; branch if not eot (end-of-text)
  6622  4213 20ad22                              jsr indlow
  6623  4216 f007                                beq l83_2                                ; branch if eot (null link bytes)
  6624                          
  6625  4218 20ad22             l83_1            jsr indlow
  6626  421b 8561                                sta lowtr                                ; (source)
  6627  421d 8662                                stx lowtr+1
  6628                          
  6629  421f a561               l83_2            lda lowtr                                ; check that start <= end
  6630  4221 38                                  sec
  6631  4222 e524                                sbc index1                               ; calculate delta
  6632  4224 850d                                sta count                                ; (count)
  6633  4226 a562                                lda lowtr+1                              ; (does not catch case where
  6634  4228 e525                                sbc index1+1                             ; start>end when end=start+1,
  6635  422a 856d                                sta argmo                                ; but it does no harm)
  6636  422c 050d                                ora count
  6637  422e f00e                                beq fix_links                            ; all done- nothing to move!?
  6638  4230 9318ec                              +lbcc snerr                              ; error- bad range (start > end)
  6639                          
  6640  4233 a582                                lda text_top                             ; setup for common DMA move routine: [900530]
  6641  4235 a683                                ldx text_top+1
  6642  4237 8526                                sta index2                               ; index2 = top
  6643  4239 8627                                stx index2+1                             ; index1 = destination
  6644                          ; count  = delta
  6645                          
  6646  423b 20c440                              jsr movedown                             ; delete the text, then relink & exit
  6647                          
  6648                          
  6649                          
  6650                          fix_links                                                 ; <<<<<<<<<<<<<<<<<<<<<<<<<<< entry from renumber
  6651                          
  6652  423e 20b930                              jsr link_program                         ; relink program
  6653  4241 a524                                lda index1
  6654  4243 a625                                ldx index1+1
  6655  4245 18                                  clc
  6656  4246 6902                                adc #2
  6657  4248 9001                                bcc l84_1
  6658  424a e8                                  inx
  6659  424b 8582               l84_1            sta text_top                             ; set eot pointer
  6660  424d 8683                                stx text_top+1
  6661  424f 60                                  rts                                      ; C128-04 fix: was 'jmp ready' (FAB)
  6662                          
  6663                          
  6664                          ;********************************
  6665                          ;*
  6666                          ;*    Input Range Parameters
  6667                          ;*
  6668                          ;********************************
  6669                          
  6670  4250 f012               range            beq l85_1                                ; a terminator from chrgot?
  6671  4252 9010                                bcc l85_1                                ; a number?
  6672  4254 c9ab                                cmp #minus_token                         ; a dash?
  6673  4256 d02e                                bne l85_4   ;if it's not a dash, error (C128-03 fix ; FAB)
  6674  4258 a001                                ldy #1
  6675  425a 20c522                              jsr indtxt                               ; let's peek, and see what follows the dash!
  6676  425d f027                                beq l85_4                                ; uh-oh! it's of the form 'delete -' - error
  6677  425f c93a                                cmp #':'                                 ; the other terminator
  6678  4261 f023                                beq l85_4                                ; ..still bad
  6679  4263 38                                  sec                                      ; set up for linget
  6680                          
  6681  4264 202e32             l85_1            jsr linget                               ; get first #
  6682  4267 20fa31                              jsr FindLine                             ; find it & set ptrs
  6683  426a 208522                              jsr chrgot                               ; get last char
  6684  426d f00c                                beq l85_2                                ; skip done
  6685  426f c9ab                                cmp #minus_token                         ; a dash?
  6686  4271 d013                                bne l85_4                                ; no- syntax error
  6687  4273 208322                              jsr chrget                               ; yes- skip dash
  6688  4276 202e32                              jsr linget                               ; get second #
  6689  4279 d00b                                bne l85_4                                ; error- wasn't a number
  6690                          
  6691  427b a50b               l85_2            lda endchr                               ; was a # input?
  6692  427d d006                                bne l85_3                                ; yes
  6693  427f a9ff                                lda #$ff                                 ; no - make max
  6694  4281 8516                                sta linnum
  6695  4283 8517                                sta linnum+1
  6696  4285 60                 l85_3            rts
  6697                          
  6698                          
  6699  4286 83c2eb             l85_4            +lbra snerr                              ; syntax error
  6700                          
  6701                          ;.end
  6702                          ;[[command.findchange]]
  6703                          
  6704                          
  6705                          
  6706                          ; FIND   "string"                    [,line_range]
  6707                          ; CHANGE "oldstring" TO "newstring"  [,line_range]
  6708                          ;
  6709                          ; where <"> delimiter can be any character, but only
  6710                          ; double-quotes will prevent tokenization of strings.
  6711                          ;
  6712                          ; N.B.: I am assuming that lines cannot be greater than 255 chars, as is
  6713                          ; the case where the line was entered "normally", that is, using LINGET.
  6714                          
  6715                          find
  6716  4289 7787                                rmb7 op                                  ; FIND flag
  6717  428b 2c                                  !text $2c
  6718                          
  6719                          change
  6720  428c f787                                smb7 op                                  ; CHANGE flag
  6721  428e 6787                                rmb6 op                                  ; reset change-all mode
  6722  4290 20ed58                              jsr errind                               ; report error if not in direct mode
  6723                          
  6724  4293 208522                              jsr chrgot                               ; get delimeter
  6725  4296 a200                                ldx #0                                   ; evaluate string args
  6726  4298 202644                              jsr delimit_string                       ; string1
  6727  429b a58a                                lda fstr1+2
  6728  429d f35f0f                              +lbeq fcerr                              ; error if string1 null
  6729  42a0 7f8713                              bbr7 op,l86_1                            ; branch if no string2
  6730  42a3 208322                              jsr chrget                               ; pick up required 'to' token
  6731  42a6 c9a4                                cmp #to_token
  6732  42a8 d3a0eb                              +lbne snerr                              ; error if missing
  6733  42ab 208322                              jsr chrget
  6734  42ae f39aeb                              +lbeq snerr                              ; error if eol
  6735  42b1 a203                                ldx #3
  6736  42b3 202644                              jsr delimit_string                       ; string2
  6737                          
  6738  42b6 208322             l86_1            jsr chrget                               ; line number range given?
  6739  42b9 f003                                beq l86_2                                ; no, eol
  6740  42bb 205b4e                              jsr chkcom                               ; yes, pick up required comma
  6741  42be 205042             l86_2            jsr range                                ; set up line number range (lowtr,linnum)
  6742  42c1 20472c                              jsr tto                                  ; save txtptr for restoration when done
  6743  42c4 7755                                rmb7 helper                              ; clear 'help' flag for 'p1line'
  6744  42c6 a555                                lda helper
  6745  42c8 48                                  pha
  6746  42c9 4755                                rmb4 helper                              ; temporarily disable token highlighting
  6747  42cb d755                                smb5 helper                              ; set   'find' flag for 'p1line'
  6748  42cd 800e                                bra find_loop_1                          ; begin
  6749                          
  6750                          
  6751                          find_loop
  6752  42cf a000                                ldy #0                                   ; move to next line (copy link bytes to lowtr)
  6753  42d1 20ad22                              jsr indlow
  6754  42d4 aa                                  tax
  6755  42d5 c8                                  iny
  6756  42d6 20ad22                              jsr indlow
  6757  42d9 8661                                stx lowtr
  6758  42db 8562                                sta lowtr+1
  6759                          
  6760                          find_loop_1
  6761  42dd a001                                ldy #1
  6762  42df 20ad22                              jsr indlow                               ; check link
  6763  42e2 d007                                bne l87_1                                ; not null- continue
  6764  42e4 88                                  dey
  6765  42e5 20ad22                              jsr indlow
  6766  42e8 f31e01                              +lbeq find_exit                          ; null- exit
  6767                          
  6768  42eb a002               l87_1            ldy #2
  6769  42ed 20ad22                              jsr indlow                               ; check line number
  6770  42f0 aa                                  tax
  6771  42f1 c8                                  iny
  6772  42f2 20ad22                              jsr indlow
  6773  42f5 c517                                cmp linnum+1
  6774  42f7 d004                                bne l87_2
  6775  42f9 e416                                cpx linnum
  6776  42fb f003                                beq l87_3                                ; line is <= last line requested, continue
  6777  42fd b30901             l87_2            +lbcs find_exit                          ; line is >  last line requested, exit
  6778                          
  6779  4300 a203               l87_3            ldx #3                                   ; set initial position - 1 (past link & line#)
  6780  4302 863f                                stx fndpnt
  6781                          
  6782                          
  6783                          find_loop_2
  6784  4304 20e1ff                              jsr _stop                                ; check stop key
  6785  4307 f31101                              +lbeq find_break                         ; exit if down
  6786                          
  6787  430a a63f                                ldx fndpnt                               ; duh, where are we?
  6788  430c 18                                  clc
  6789  430d 8a                                  txa                                      ; program:
  6790  430e 6561                                adc lowtr                                ; txtptr = line start + position in line
  6791  4310 853d                                sta txtptr
  6792  4312 a900                                lda #0
  6793  4314 6562                                adc lowtr+1
  6794  4316 853e                                sta txtptr+1                             ; search string:
  6795  4318 a300                                ldz #0                                   ; at the beginning
  6796                          
  6797  431a 20a540             l88_1            jsr chargt                               ; get next character from text
  6798  431d f0b0                                beq find_loop                            ; eol (no match this line)
  6799  431f e8                                  inx                                      ; bump pointer to next character
  6800  4320 d288                                cmp (fstr1),z                            ; character match?  ind okay- buffer
  6801  4322 d0f6                                bne l88_1                                ; no
  6802  4324 863f                                stx fndpnt                               ; yes- save next position
  6803                          
  6804  4326 1b                 l88_2            inz                                      ; bump position in search string
  6805  4327 d48a                                cpz fstr1+2                              ; string match?
  6806  4329 b00b                                bcs print_line                           ; yes
  6807  432b 20a540                              jsr chargt
  6808  432e f09f                                beq find_loop                            ; no- eol
  6809  4330 d288                                cmp (fstr1),z                            ; ind okay- buffer
  6810  4332 d0d0                                bne find_loop_2                          ; no- rewind to beginning of search string
  6811  4334 f0f0                                beq l88_2                                ; maybe- still more chars to compare
  6812                          
  6813                          
  6814                          ; Print the line of text at LOWTR, highlighting the section of code
  6815                          ; beginning at LOWTR+FNDPNT and running for FIND_COUNT characters.
  6816                          
  6817                          print_line
  6818  4336 20f737                              jsr crdo                                 ; get a new display line
  6819  4339 a58a                                lda fstr1+2                              ; length of string to highlight
  6820  433b 8dda02                              sta find_count
  6821  433e a002                                ldy #2
  6822  4340 20ad22                              jsr indlow                               ; get ms byte of line number
  6823  4343 aa                                  tax
  6824  4344 c8                                  iny
  6825  4345 20ad22                              jsr indlow                               ; get ls byte
  6826  4348 207733                              jsr p1line                               ; print #, space, and the line of code
  6827  434b 7f87b6                              bbr7 op,find_loop_2                      ; Find op? branch if so and continue search
  6828                          
  6829                          
  6830                          ; Change operation
  6831                          ; Query the user and replace string1 with string2 if he wants to.
  6832                          ; Options are  'Y' (yes),  '*' (do all),  'CR' (quit),  anything else means no.
  6833                          
  6834                          change_line
  6835  434e ef8720                              bbs6 op,l89_1                            ; branch if change-all mode set
  6836  4351 207dff                              jsr _primm                               ; prompt & get response
  6837  4354 0d204348414e4745...                 !text cr," CHANGE? ",0
  6838  435f 20d878                              jsr response_get
  6839  4362 c959                                cmp #'Y'
  6840  4364 f00b                                beq l89_1                                ; yes, change it
  6841  4366 c90d                                cmp #cr
  6842  4368 f39e00                              +lbeq find_exit                          ; cr only, abort entire operation
  6843  436b c92a                                cmp #'*'
  6844  436d d095                                bne find_loop_2                          ; *, change all.  else don't change
  6845  436f e787                                smb6 op
  6846                          
  6847                          ; Replace string1 with string2.  Requires moving text up/down beginning at
  6848                          ; LOWTR+FNDPNT+(LEN(string1)-LEN(string2)) through TEXT_TOP and copying
  6849                          ; string1 into text beginning at LOWTR+FNDPNT for LEN(string2) characters.
  6850                          
  6851  4371 a582               l89_1            lda text_top                             ; setup upper address of text to move (index2)
  6852  4373 8526                                sta index2
  6853  4375 a583                                lda text_top+1                           ; TEXT_TOP
  6854  4377 8527                                sta index2+1
  6855                          
  6856  4379 18                                  clc                                      ; setup lower address of text to move (index1)
  6857  437a a53f                                lda fndpnt
  6858  437c 6561                                adc lowtr
  6859  437e 8524                                sta index1                               ; LOWTR+FNDPNT
  6860  4380 a900                                lda #0
  6861  4382 856d                                sta argmo                                ; count hi
  6862  4384 6562                                adc lowtr+1
  6863  4386 8525                                sta index1+1
  6864                          
  6865  4388 38                                  sec                                      ; calc number of chars to insert/delete
  6866  4389 a58a                                lda fstr1+2                              ; LEN(string1)-LEN(string2)
  6867  438b e58d                                sbc fstr2+2
  6868  438d f052                                beq l89_6                                ; branch if string1 = string2 (no move)
  6869  438f 103d                                bpl l89_4                                ; branch if string1 > string2 (delete)
  6870                          ; else      string1 < string2 (insert)
  6871                          
  6872  4391 42                                  neg                                      ; Move memory up to make room for larger string2
  6873  4392 850d                                sta count
  6874  4394 a000                                ldy #0                                   ; first check for line too long
  6875  4396 20ad22                              jsr indlow
  6876  4399 650d                                adc count
  6877  439b 4b                                  taz
  6878  439c c8                                  iny
  6879  439d 20ad22                              jsr indlow                               ; (link+#chr)-line_sa must be <256
  6880  43a0 6900                                adc #0
  6881  43a2 a8                                  tay
  6882  43a3 38                                  sec
  6883  43a4 6b                                  tza
  6884  43a5 e561                                sbc lowtr
  6885  43a7 98                                  tya
  6886  43a8 e562                                sbc lowtr+1
  6887  43aa d3c432                              +lbne errlen                             ; error, line > 255 characters
  6888                          
  6889  43ad 18                                  clc                                      ; now check for sufficient memory
  6890  43ae a483                                ldy text_top+1
  6891  43b0 a50d                                lda count
  6892  43b2 6582                                adc text_top
  6893  43b4 9001                                bcc l89_2
  6894  43b6 c8                                  iny
  6895  43b7 ccd002             l89_2            cpy max_mem_0+1
  6896  43ba 9009                                bcc l89_3                                ; result is less than top-of-memory: ok
  6897  43bc d383ea                              +lbne omerr                              ; msb >  top, overflow
  6898  43bf cdcf02                              cmp max_mem_0                            ; msb's the same, test lsb's
  6899  43c2 b37dea                              +lbcs omerr                              ; lsb >= top, overflow
  6900  43c5 8582               l89_3            sta text_top
  6901  43c7 8483                                sty text_top+1                           ; set new top of text pointer
  6902  43c9 201741                              jsr moveup                               ; make room
  6903  43cc 8013                                bra l89_6                                ; go copy string2 into area
  6904                          
  6905  43ce 850d               l89_4            sta count                                ; Move memory down for smaller string2
  6906  43d0 a483                                ldy text_top+1
  6907  43d2 a582                                lda text_top
  6908  43d4 38                                  sec
  6909  43d5 e50d                                sbc count
  6910  43d7 b001                                bcs l89_5
  6911  43d9 88                                  dey
  6912  43da 8582               l89_5            sta text_top
  6913  43dc 8483                                sty text_top+1                           ; set new top of text pointer
  6914  43de 20c440                              jsr movedown                             ; squish out excess space
  6915                          
  6916  43e1 a58d               l89_6            lda fstr2+2                              ; Copy string2 into text
  6917  43e3 f015                                beq l89_8                                ; branch if null, nothing to copy
  6918  43e5 8dda02                              sta find_count                           ; how many characters to copy
  6919  43e8 a261                                ldx #lowtr
  6920  43ea a43f                                ldy fndpnt                               ; index into text
  6921  43ec a300                                ldz #0                                   ; index into string2
  6922  43ee b28b               l89_7            lda (fstr2),z                            ; ind okay- buffer
  6923  43f0 200c23                              jsr sta_far_ram0                         ; do the copy
  6924  43f3 c8                                  iny
  6925  43f4 1b                                  inz
  6926  43f5 ceda02                              dec find_count
  6927  43f8 d0f4                                bne l89_7
  6928                          
  6929  43fa 20b930             l89_8            jsr link_program                         ; relink program
  6930  43fd 18                                  clc
  6931  43fe a53f                                lda fndpnt                               ; place find position after new text
  6932  4400 658d                                adc fstr2+2
  6933  4402 3a                                  dec
  6934  4403 853f                                sta fndpnt
  6935  4405 83fdfe                              +lbra find_loop_2                        ; and resume searching
  6936                          
  6937                          
  6938                          find_exit
  6939  4408 20f737                              jsr crdo                                 ; normal exit
  6940  440b 68                                  pla
  6941  440c 8555                                sta helper                               ; restore token highlight status
  6942  440e 5755                                rmb5 helper                              ; remove 'find' flag
  6943  4410 830efb                              +lbra direct_mode_exit                   ; done
  6944                          
  6945                          
  6946                          
  6947                          find_omerr                                                ; out of memory
  6948  4413 a210                                ldx #errom
  6949  4415 2c                                  !text $2c
  6950                          find_errlen                                               ; string too long
  6951  4416 a217                                ldx #errls
  6952  4418 38                                  sec
  6953  4419 89                                  !text $89
  6954                          find_break                                                ; stop key break
  6955  441a 18                                  clc
  6956  441b 68                                  pla
  6957  441c 8555                                sta helper                               ; restore token highlight status
  6958  441e 5755                                rmb5 helper                              ; remove 'find' flag
  6959  4420 93afe8                              +lbcc break_exit                         ; [910925]
  6960  4423 832aea                              +lbra error
  6961                          
  6962                          
  6963                          delimit_string                                            ; command is in buffer, .x = ptr to strptr
  6964  4426 8564                                sta match                                ; delimiter character
  6965  4428 a53d                                lda txtptr                               ; point to first character in string
  6966  442a 1a                                  inc                                      ; (never wraps- string in input buffer)
  6967  442b 9588                                sta fstr1,x                              ; set pointer to string data
  6968  442d a53e                                lda txtptr+1
  6969  442f 9589                                sta fstr1+1,x
  6970  4431 a9ff                                lda #$ff                                 ; set string length
  6971  4433 958a                                sta fstr1+2,x
  6972                          
  6973  4435 f68a               l90_1            inc fstr1+2,x
  6974  4437 20a540                              jsr chargt                               ; build string
  6975  443a f30eea                              +lbeq snerr                              ; error if eol encountered inside string
  6976  443d c564                                cmp match
  6977  443f d0f4                                bne l90_1                                ; continue until matching delimiter found
  6978  4441 60                                  rts
  6979                          
  6980                          ;.end
  6981                          
  6982                          
  6983                          
  6984  4442 20675b             puctrl           jsr frmstr                               ; do frmevl,frestr. return with a=len, index=~string
  6985  4445 a8                                  tay
  6986  4446 88                                  dey
  6987  4447 c004                                cpy #4
  6988  4449 b3b30d                              +lbcs fcerr                              ; len > 4 is illegal value error
  6989                          
  6990  444c 20d522             l91_1            jsr indin1_ram1                          ; lda (index),y
  6991  444f 99d411                              sta puchrs,y
  6992  4452 88                                  dey
  6993  4453 10f7                                bpl l91_1
  6994  4455 60                                  rts
  6995                          
  6996                          ;.end
  6997                          
  6998                          ;[[command.trap]]
  6999                          
  7000                          
  7001                          trap
  7002                          ; jsr errdir ;why not????      [910925]
  7003  4456 208522                              jsr chrgot                               ; if no #, means 'turn off trap'
  7004  4459 f007                                beq l92_1
  7005  445b 208a5d                              jsr getwrd
  7006  445e 8cca02                              sty trapno
  7007  4461 2c                                  !text $2c
  7008                          
  7009  4462 a9ff               l92_1            lda #$ff                                 ; flag no trap
  7010  4464 8dcb02                              sta trapno+1
  7011  4467 60                                  rts
  7012                          
  7013                          ;.end
  7014                          ;[[command.resume]]
  7015                          
  7016                          
  7017                          
  7018                          
  7019                          ; RESUME command
  7020                          ;
  7021                          ; Used to resume execution following a TRAPped error.
  7022                          ;
  7023                          ; Syntax: RESUME [line_number | NEXT]
  7024                          ;
  7025                          ; Can take the following forms:
  7026                          ;
  7027                          ; RESUME   :resume executing at the statement which caused
  7028                          ;     the error.
  7029                          ; RESUME NEXT  :resume execution at the statement FOLLOWING
  7030                          ;     the statement which caused the error.
  7031                          ; RESUME line_number :resume at the specified line number.
  7032                          
  7033                          
  7034  4468 20e258             resume           jsr errdir                               ; no direct mode
  7035  446b aec902                              ldx errlin+1                             ; is there an error to resume from?
  7036  446e e8                                  inx
  7037  446f f077                                beq rescnt                               ; can't resume!
  7038  4471 208522                              jsr chrgot                               ; look for arguments
  7039  4474 f046                                beq resswp                               ; no arg's...restart err'd line
  7040  4476 9039                                bcc l93_3                                ; numeric argument
  7041  4478 c982                                cmp #next_token                          ; only other choice is 'next'
  7042  447a d3cee9                              +lbne snerr                              ; if not, syntax error
  7043                          
  7044  447d 20bc44                              jsr resswp                               ; resume execution with next stm't
  7045  4480 a000                                ldy #0
  7046  4482 20c522                              jsr indtxt
  7047  4485 d024                                bne l93_2                                ; must be a ':'
  7048  4487 c8                                  iny                                      ; must be a null,get next line
  7049  4488 20c522                              jsr indtxt                               ; make sure its not end-of-text
  7050  448b d007                                bne l93_1
  7051  448d c8                                  iny
  7052  448e 20c522                              jsr indtxt
  7053  4491 f3bae9                              +lbeq ready                              ; 2 nulls, eot. bye!
  7054                          
  7055  4494 a003               l93_1            ldy #3                                   ; new line, update pointers
  7056  4496 20c522                              jsr indtxt
  7057  4499 853b                                sta curlin
  7058  449b c8                                  iny
  7059  449c 20c522                              jsr indtxt
  7060  449f 853c                                sta curlin+1
  7061  44a1 98                                  tya
  7062  44a2 18                                  clc
  7063  44a3 653d                                adc txtptr
  7064  44a5 853d                                sta txtptr
  7065  44a7 9002                                bcc l93_2
  7066  44a9 e63e                                inc txtptr+1
  7067  44ab 208322             l93_2            jsr chrget                               ; skip over this character, into body of statement
  7068  44ae 8398f0                              +lbra data                               ; advance until null or ':', then rts
  7069                          
  7070                          
  7071  44b1 208a5d             l93_3            jsr getwrd                               ; resnum. numeric argument
  7072  44b4 8517                                sta linnum+1
  7073  44b6 20d644                              jsr resend
  7074  44b9 8364f8                              +lbra luk4it
  7075                          
  7076                          
  7077  44bc adcd02             resswp           lda errtxt                               ; backup one so chrget will work
  7078  44bf d003                                bne l94_1
  7079  44c1 cece02                              dec errtxt+1
  7080  44c4 cecd02             l94_1            dec errtxt
  7081                          
  7082  44c7 a201                                ldx #1
  7083  44c9 bdc802             l94_2            lda errlin,x                             ; restore line#
  7084  44cc 953b                                sta curlin,x
  7085  44ce bdcd02                              lda errtxt,x                             ; restore text pointer to statement
  7086  44d1 953d                                sta txtptr,x
  7087  44d3 ca                                  dex
  7088  44d4 10f3                                bpl l94_2
  7089                          
  7090                          
  7091  44d6 aecc02             resend           ldx tmptrp                               ; restore trap line to allow traps again
  7092  44d9 8ecb02                              stx trapno+1
  7093                          error_clear
  7094  44dc a2ff                                ldx #$ff
  7095  44de 8ec702                              stx errnum                               ; reset error status- he's saying he's fixed it
  7096  44e1 8ec802                              stx errlin
  7097  44e4 8ec902                              stx errlin+1                             ; flag 'no further resumes until next error'
  7098  44e7 60                                  rts
  7099                          
  7100                          
  7101  44e8 a21f               rescnt           ldx #errcr
  7102  44ea 8363e9                              +lbra error
  7103                          
  7104                          ;.end
  7105                          
  7106                          ;[[command.loops]]
  7107                          
  7108                          
  7109  44ed a001               do               ldy #1
  7110  44ef b93d00             l95_1            lda txtptr,y                             ; save current pointers for stack entry
  7111  44f2 997911                              sta tmptxt,y
  7112  44f5 b93b00                              lda curlin,y
  7113  44f8 997b11                              sta tmplin,y
  7114  44fb 88                                  dey
  7115  44fc 10f1                                bpl l95_1
  7116                          
  7117  44fe 208522                              jsr chrgot                               ; look for 'while' or 'until'
  7118  4501 f01b                                beq doyes                                ; unconditional
  7119  4503 c9fc                                cmp #until_token
  7120  4505 f010                                beq do10
  7121  4507 c9fd                                cmp #while_token
  7122  4509 d03f                                bne snrjmp
  7123                          
  7124                          
  7125                          ;  Here for WHILE
  7126                          
  7127  450b 20cf45                              jsr frmjmp
  7128  450e a563                                lda facexp
  7129  4510 d00c                                bne doyes                                ; conditional evaluated true
  7130                          
  7131  4512 208522             dono             jsr chrgot
  7132  4515 8039                                bra fnd010                               ; advance to end of block, do rts
  7133                          
  7134                          
  7135                          ;  Here for UNTIL
  7136                          
  7137  4517 20cf45             do10             jsr frmjmp
  7138  451a a563                                lda facexp
  7139  451c d0f4                                bne dono
  7140                          
  7141  451e a905               doyes            lda #5                                   ; 'do' needs 5 bytes on the run-time stack
  7142  4520 209431                              jsr getstk
  7143  4523 a004                                ldy #4                                   ; ..now stuff those 5 bytes!
  7144  4525 ad7a11                              lda tmptxt+1
  7145  4528 917c                                sta (tos),y                              ; (common area)
  7146  452a 88                                  dey
  7147  452b ad7911                              lda tmptxt
  7148  452e 917c                                sta (tos),y                              ; (common area)
  7149  4530 88                                  dey
  7150  4531 ad7c11                              lda tmplin+1
  7151  4534 917c                                sta (tos),y                              ; (common area)
  7152  4536 88                                  dey
  7153  4537 ad7b11                              lda tmplin
  7154  453a 917c                                sta (tos),y                              ; (common area)
  7155  453c 88                                  dey
  7156  453d a9eb                                lda #do_token
  7157  453f 917c                                sta (tos),y                              ; (common area)
  7158  4541 60                                  rts
  7159                          
  7160                          
  7161                          ;  Here for EXIT
  7162                          
  7163  4542 20a045             exit             jsr popdgo                               ; pop do entry off stack
  7164  4545 208522                              jsr chrgot
  7165  4548 f006                                beq fnd010
  7166  454a 83fee8             snrjmp           +lbra snerr
  7167                          
  7168                          
  7169                          
  7170                          ;  Find end of current block
  7171                          
  7172  454d 208322             fndend           jsr chrget
  7173                          
  7174  4550 f017               fnd010           beq l96_2                                ; end of statement
  7175  4552 c9ec                                cmp #loop_token
  7176  4554 f3f2ef                              +lbeq data                               ; a hit!  read to end of statement, rts
  7177  4557 c922                                cmp #'"'                                 ; quote
  7178  4559 f009                                beq l96_1
  7179  455b c9eb                                cmp #do_token
  7180  455d d0ee                                bne fndend                               ; keep looking
  7181  455f 204d45                              jsr fndend                               ; recursivly
  7182  4562 80ae                                bra dono                                 ; do a chrgot, go to fnd010
  7183                          
  7184                          
  7185  4564 203236             l96_1            jsr un_quote                             ; look for terminating quote, or end of statement
  7186  4567 d0e4                                bne fndend                               ; character after quote wasn't terminator, keep going
  7187                          
  7188  4569 c93a               l96_2            cmp #':'                                 ; end of line or end of stmt?
  7189  456b f0e0                                beq fndend                               ; just stmt, keep going
  7190  456d 7f7e3f                              bbr7 runmod,fnderr                       ; if direct mode, not found error
  7191  4570 a002                                ldy #2
  7192  4572 20c522                              jsr indtxt                               ; end of text?
  7193  4575 f038                                beq fnderr                               ; 'fraid so
  7194  4577 c8                                  iny                                      ; y=3
  7195  4578 20c522                              jsr indtxt                               ; update pointers
  7196  457b 853b                                sta curlin
  7197  457d c8                                  iny
  7198  457e 20c522                              jsr indtxt
  7199  4581 853c                                sta curlin+1
  7200  4583 98                                  tya
  7201  4584 18                                  clc
  7202  4585 653d                                adc txtptr
  7203  4587 853d                                sta txtptr
  7204  4589 90c2                                bcc fndend
  7205  458b e63e                                inc txtptr+1
  7206  458d 80be                                bra fndend
  7207                          
  7208                          
  7209  458f f035               loop             beq popngo                               ; no conditionals, just do it
  7210  4591 c9fd                                cmp #while_token
  7211  4593 f02c                                beq loop10
  7212  4595 c9fc                                cmp #until_token
  7213  4597 d0b1                                bne snrjmp
  7214                          
  7215                          ;  Here for UNTIL
  7216                          
  7217  4599 20cf45                              jsr frmjmp
  7218  459c a563                                lda facexp
  7219  459e f026                                beq popngo                               ; false, do it again!
  7220                          
  7221  45a0 a9eb               popdgo           lda #do_token                            ; pop, but don't go
  7222  45a2 204331                              jsr search
  7223  45a5 d015                                bne poperr                               ; branch if not found
  7224  45a7 20e631                              jsr movfnd
  7225  45aa a005                                ldy #5
  7226  45ac 8341ec                              +lbra rlsstk
  7227                          
  7228                          
  7229                          fnderr
  7230  45af ad7b11                              lda tmplin                               ; loop not found error: must make curlin match oldtxt
  7231  45b2 ae7c11                              ldx tmplin+1
  7232  45b5 853b                                sta curlin
  7233  45b7 863c                                stx curlin+1
  7234                          
  7235  45b9 a220                                ldx #errlnf
  7236  45bb 2c                                  !text $2c
  7237                          poperr
  7238  45bc a221                                ldx #errlwd                              ; loop without do
  7239  45be 838fe8                              +lbra error
  7240                          
  7241                          
  7242                          
  7243                          ;  Here for WHILE
  7244                          
  7245                          loop10
  7246  45c1 20cf45                              jsr frmjmp
  7247  45c4 f0da                                beq popdgo                               ; false, exit
  7248                          popngo
  7249  45c6 63d8ff                              bsr popdgo
  7250                          ; dey
  7251                          ; lda (fndpnt),y ;restore pointers
  7252                          ; sta txtptr+1
  7253                          ; dey
  7254                          ; lda (fndpnt),y
  7255                          ; sta txtptr
  7256                          ; dey
  7257                          ; lda (fndpnt),y
  7258  45c9 204279                              jsr retpat                               ; (** 01/18/84 fixes 'loop' to a direct mode 'do')
  7259                          ; lda (fndpnt),y
  7260                          ; sta curlin
  7261  45cc 831fff                              +lbra do
  7262                          
  7263                          frmjmp
  7264  45cf 208322                              jsr chrget
  7265  45d2 831b07                              +lbra frmevl
  7266                          
  7267                          ;.end
  7268                          ;[[command.key]]
  7269                          
  7270                          
  7271                          
  7272                          ;**************************************************************
  7273                          ;
  7274                          ;   KEY  Programmable Key Functions    [900725]
  7275                          ;
  7276                          ;**************************************************************
  7277                          
  7278  45d5 f033               key              beq Key_List                             ; KEY ? yes- no args
  7279                          
  7280  45d7 a6d1               l97_1            ldx _kyndx                               ; is function key buffered?
  7281  45d9 d0fc                                bne l97_1                                ; yes- hang until IRQ finishes processing it ????
  7282                          
  7283  45db c991                                cmp #on_token                            ; KEY ON ?
  7284  45dd d004                                bne l97_2
  7285  45df 57f7                                rmb5 _locks                              ; yes- reset Editor's lock bit
  7286  45e1 8024                                bra l97_4                                ; exit
  7287                          
  7288  45e3 c993               l97_2            cmp #load_token                          ; KEY LOAD <filename>[,D#,U#]
  7289  45e5 f3d500                              +lbeq Key_load
  7290                          
  7291  45e8 c994                                cmp #save_token                          ; KEY SAVE <filename>[,D#,U#]
  7292  45ea f33001                              +lbeq Key_Save
  7293                          
  7294  45ed c98c                                cmp #restore_token                       ; KEY RESTORE ?      [910925]
  7295  45ef d007                                bne l97_3                                ; no
  7296  45f1 57f7                                rmb5 _locks                              ; yes- reset Editor's lock bit (enable keys)
  7297  45f3 20b546                              jsr key_restore                          ; init key definitions
  7298  45f6 800f                                bra l97_4                                ; exit
  7299                          
  7300  45f8 c9fe               l97_3            cmp #esc_command_token                   ; KEY OFF ?
  7301  45fa d39f00                              +lbne Key_Change                         ; no- must be new key definition
  7302  45fd 208322                              jsr chrget
  7303  4600 c924                                cmp #off_token
  7304  4602 d346e8                              +lbne snerr                              ; no- bad syntax
  7305  4605 d7f7                                smb5 _locks                              ; yes- set Editor's lock bit
  7306  4607 837adc             l97_4            +lbra chrget                             ; exit
  7307                          
  7308                          
  7309                          ;**************************************************************
  7310                          ;
  7311                          ;   Key_List  List all function key definitions
  7312                          ;
  7313                          ;**************************************************************
  7314                          
  7315                          Key_List
  7316  460a a200                                ldx #0                                   ; display all key definitions
  7317  460c a000                                ldy #0
  7318                          
  7319  460e e8                 lstky1           inx                                      ; get key number = 1-16
  7320  460f bdff0f                              lda _pky_lengths-1,x                     ; get key size
  7321  4612 f05a                                beq lstest                               ; skip if key not defined
  7322  4614 8577                                sta keysiz                               ; save size
  7323  4616 8676                                stx z_p_temp_1                           ; save key number
  7324                          
  7325  4618 5a                                  phy
  7326  4619 a203                                ldx #3
  7327  461b bd8c46             l98_1            lda preamb,x                             ; print key preamble:
  7328  461e 20d2ff                              jsr _bsout
  7329  4621 ca                                  dex                                      ; 'KEY '
  7330  4622 10f7                                bpl l98_1
  7331  4624 a676                                ldx z_p_temp_1                           ; key number
  7332  4626 a900                                lda #0
  7333  4628 207f64                              jsr linprt
  7334  462b a92c                                lda #','
  7335  462d 20d2ff                              jsr _bsout                               ; comma
  7336                          
  7337  4630 7a                                  ply
  7338  4631 a207                                ldx #7                                   ; (length of 'keydat' string)
  7339  4633 b91010             lsloop           lda _pky_buffer,y                        ; print key definition
  7340  4636 c8                                  iny
  7341  4637 48                                  pha                                      ; save character
  7342  4638 da                                  phx                                      ; save position in output string
  7343                          
  7344  4639 a204                                ldx #4                                   ; check for special (non-printable) characters
  7345  463b dd9646             l99_1            cmp keychr-1,x
  7346  463e f033                                beq list_special                         ; yes, display it as 'CHR$(...)'
  7347  4640 ca                                  dex
  7348  4641 d0f8                                bne l99_1
  7349                          
  7350  4643 fa                                  plx                                      ; restore position
  7351  4644 e008                                cpx #8
  7352  4646 9007                                bcc l99_2                                ; 1st time thru- display leading quote
  7353  4648 d00a                                bne l99_3                                ; previous was a character- no additions needed
  7354  464a a92b                                lda #'+'                                 ; add since previous was quote or return
  7355  464c 20d2ff                              jsr _bsout
  7356  464f a922               l99_2            lda #'"'
  7357  4651 20d2ff                              jsr _bsout                               ; add leading quote
  7358  4654 68                 l99_3            pla                                      ; restore character
  7359  4655 20d2ff                              jsr _bsout                               ; display it
  7360  4658 a209                                ldx #9                                   ; mark normal character
  7361                          
  7362  465a c677               lstnd            dec keysiz
  7363  465c d0d5                                bne lsloop                               ; loop to end of definition
  7364  465e e009                                cpx #9
  7365  4660 9005                                bcc l100_1                               ; skip if previous not normal character
  7366  4662 a922                                lda #'"'
  7367  4664 20d2ff                              jsr _bsout                               ; add ending quote
  7368                          
  7369  4667 a98d               l100_1           lda #$8d
  7370  4669 20d2ff                              jsr _bsout                               ; add ending return (shifted)
  7371                          
  7372  466c a676                                ldx z_p_temp_1                           ; key number
  7373  466e e010               lstest           cpx #number_fkeys
  7374  4670 d09c                                bne lstky1                               ; ...loop until done all keys
  7375  4672 60                                  rts
  7376                          
  7377                          
  7378                          list_special
  7379  4673 fa                                  plx                                      ; restore .x
  7380  4674 bd8d46             l101_1           lda keydat-3,x                           ; display something like  ' "+CHR$( '
  7381  4677 20d2ff                              jsr _bsout
  7382  467a ca                                  dex
  7383  467b e003                                cpx #3
  7384  467d b0f5                                bcs l101_1
  7385  467f 68                                  pla                                      ; restore character
  7386  4680 203779                              jsr prtdec                               ; display decimal value of chr in .a
  7387  4683 a929                                lda #')'                                 ; finish off with closing paren.
  7388  4685 20d2ff                              jsr _bsout
  7389  4688 a208                                ldx #8                                   ; mark end of special
  7390  468a 80ce                                bra lstnd                                ; ..always
  7391                          
  7392                          
  7393  468c 2059454b           preamb           !text " YEK"                             ; key preamble
  7394                          
  7395  4690 28245248432b22     keydat           !text "($RHC+",$22                       ; chr$( string
  7396                          
  7397  4697 0d8d221b           keychr           !text cr,$8d,$22,esc                     ; special KEY chars- return, sft-return, quote, esc
  7398                          
  7399                          
  7400                          ;************************************************************************
  7401                          ;
  7402                          ;   Key_Change  Add, Delete or Change function key definition
  7403                          ;
  7404                          ;************************************************************************
  7405                          
  7406                          Key_Change
  7407  469b 206c5d                              jsr getbyt                               ; get key number (1-16)
  7408  469e 8676                                stx z_p_temp_1                           ; save key number     [910925]
  7409  46a0 ca                                  dex
  7410  46a1 e010                                cpx #number_fkeys
  7411  46a3 b3590b                              +lbcs fcerr                              ; exit - key number invalid
  7412                          
  7413                          ; stx z_p_temp_1 ;save key number
  7414  46a6 205b4e                              jsr chkcom                               ; look for comma
  7415  46a9 20675b                              jsr frmstr                               ; do frmevl, frestr. returns len in .a, addr in 'index'
  7416  46ac a8                                  tay                                      ; set up for call to do-a-key
  7417  46ad a901                                lda #1                                   ; tell do-a-key that string is in bank 1
  7418  46af 8526                                sta index+2
  7419  46b1 a924                                lda #index                               ; now .A points to (adr lo, adr hi, bank #)
  7420  46b3 a676                                ldx z_p_temp_1
  7421                          ; inx         [910925]
  7422                          key_restore
  7423                          ; jsr put_io_in_map
  7424  46b5 2068ff                              jsr _doakey                              ; re-define the key
  7425  46b8 b387e7                              +lbcs omerr                              ; bad return (.c=1)
  7426  46bb 60                                  rts                                      ; ok return  (.c=0)
  7427                          
  7428                          
  7429                          ;************************************************************************
  7430                          ;   Key_Load  Load function key definitions (from disk)   [900725]
  7431                          ;************************************************************************
  7432                          
  7433                          Key_load
  7434  46bc 20c946                              jsr GetLoadChannel                       ; get a channel      [911001]
  7435  46bf a010                                ldy #>_pky_lengths
  7436  46c1 a900                                lda #<_pky_lengths
  7437  46c3 20fa46                              jsr LoadBlock                            ; load it
  7438  46c6 835fec                              +lbra list_err                           ; release channel, close file, return to main
  7439                          
  7440                          
  7441                          GetLoadChannel                                            ; Used by KeyLoad and SpriteLoad    [911001]
  7442  46c9 208322                              jsr chrget                               ; eat LOAD token
  7443  46cc a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
  7444  46ce 202074                              jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 )
  7445  46d1 20dc77                              jsr chk1                                 ; check parameters
  7446  46d4 a900                                lda #0
  7447  46d6 8d8311                              sta dossa                                ; setup as dload would (0 = load channel)
  7448  46d9 201d71                              jsr find_la                              ; find an unused LA to use (cannot use reserved one)
  7449  46dc a009                                ldy #fopn
  7450  46de a204                                ldx #4
  7451  46e0 20fd70                              jsr open_file                            ; open the file
  7452  46e3 b033                                bcs LoadEOF                              ; exit if problem
  7453  46e5 ae8111                              ldx dosla
  7454  46e8 20c6ff                              jsr _chkin                               ; get input channel
  7455  46eb b02b                                bcs LoadEOF                              ; exit if bad??
  7456  46ed 20cfff                              jsr _basin                               ; waste dummy load address
  7457  46f0 20cfff                              jsr _basin
  7458  46f3 20b7ff                              jsr _readst                              ; prevent corruption if there's a problem
  7459  46f6 d01c                                bne LoadERR                              ; exit if problem
  7460  46f8 18                                  clc
  7461  46f9 60                                  rts
  7462                          
  7463                          
  7464                          LoadBlock
  7465  46fa 855a                                sta highds                               ; where to put data
  7466  46fc 845b                                sty highds+1
  7467                          LoadBlockNext
  7468  46fe a000                                ldy #0
  7469  4700 20cfff             l102_1           jsr _basin                               ; read definitions
  7470  4703 915a                                sta (highds),y
  7471  4705 20b7ff                              jsr _readst                              ; check channel status
  7472  4708 d00e                                bne LoadEOF                              ; exit if eof or error
  7473  470a 20e1ff                              jsr _stop
  7474  470d f009                                beq LoadEOF                              ; exit if stop key down
  7475  470f c8                                  iny
  7476  4710 d0ee                                bne l102_1                               ; continue up to 1 page maximum
  7477  4712 18                                  clc                                      ; indicate "more"
  7478  4713 60                                  rts
  7479                          
  7480                          
  7481                          LoadERR
  7482  4714 a21d                                ldx #erload                              ; Load Error
  7483  4716 38                                  sec
  7484  4717 89                                  !text $89
  7485                          
  7486                          LoadEOF
  7487  4718 18                                  clc
  7488  4719 830cec                              +lbra list_err                           ; release channel, close file, return to main
  7489                          
  7490                          
  7491                          ;************************************************************************
  7492                          ;   Key_Save  Save function key definitions (from disk)   [900725]
  7493                          ;************************************************************************
  7494                          
  7495                          Key_Save
  7496  471c 202e47                              jsr GetSaveChannel                       ; [910930]
  7497  471f a95a                                lda #highds                              ; set starting & ending addresses
  7498  4721 a010                                ldy #>_pky_lengths                       ; start address & pointer to it
  7499  4723 a200                                ldx #<_pky_lengths
  7500  4725 845b                                sty highds+1
  7501  4727 865a                                stx highds
  7502  4729 c8                                  iny                                      ; end address = start address + 256 + 1
  7503  472a e8                                  inx
  7504  472b 833e21                              +lbra savenb                             ; [910925]
  7505                          ; jsr _savesp  ;save it
  7506                          ;; clc   ; return no error  ????why not  [910404]
  7507                          ; bra exit_disk_op ; but if direct mode print DOS error  [910404]
  7508                          
  7509                          
  7510                          
  7511                          GetSaveChannel                                            ; Used by KeySave and SpriteSave    [910930]
  7512  472e 208322                              jsr chrget                               ; eat SAVE token
  7513  4731 a966                                lda #$66                                 ; parse:  filename [,U#] [,D#]
  7514  4733 202074                              jsr dosprs                               ; parse options
  7515  4736 20e177                              jsr chk2                                 ; check required parameters
  7516                          
  7517  4739 a009                                ldy #fopn                                ; DOS table offset
  7518  473b a904                                lda #4                                   ; length
  7519  473d 20f276                              jsr sendp
  7520  4740 a900                                lda #sys_bank                            ; set banks ???? buffer in system bank ????
  7521  4742 a200                                ldx #sys_bank
  7522  4744 4c6bff                              jmp _setbank
  7523                          
  7524                          ;.end
  7525                          
  7526                          ;[[command.bank]]
  7527                          
  7528                          
  7529                          ;************************************************************************
  7530                          ;*  Set Memory Bank for PEEK,POKE,WAIT,BLOAD,BSAVE and SYS,BOOT Commands
  7531                          ;*
  7532                          ;*  Syntax: BANK DATA  n  for PEEK,POKE,WAIT,BLOAD,BSAVE
  7533                          ;*  BANK SYS  [a,x,y,z] for SYS,BOOT Commands
  7534                          ;*
  7535                          ;* where   n=  %11111111  to access I/O area (System MAP)
  7536                          ;*      %0xxxxxxx to use physical bank n
  7537                          ;*
  7538                          ;* or      a,x,y,z  describe precise configuration for MAPper
  7539                          ;*    if omitted, the System MAP is to be used.
  7540                          ;*
  7541                          ;* The DATA option is to access data,  i.e., LDA/STA_far
  7542                          ;* The SYS  option is to execute code, i.e., JMP/JSR_far
  7543                          ;*
  7544                          ;*  Idea: BANK SCREEN n  when REC is finalized????
  7545                          ;************************************************************************
  7546                          
  7547  4747 206c5d             bank             jsr getbyt                               ; get bank number in .x
  7548  474a 8ed102                              stx current_bank
  7549  474d 60                                  rts
  7550                          
  7551                          
  7552                          ;.end
  7553                          ;[[command.play]]
  7554                          
  7555                          
  7556                          
  7557                          ; C65 Music Interpreter
  7558                          ;
  7559                          ; Syntax : PLAY "music_string"
  7560                          ;
  7561                          ; Where : music_string is a string of characters composed of:
  7562                          ;
  7563                          ; A..G   : notes
  7564                          ; W,H,Q,I,S : set note lengths to whole,half,quarter,eighth,sixteenth
  7565                          ; U   : set volume level   (0-9)
  7566                          ; O   : set octave    (0-6)
  7567                          ; T   : set current envelope  (0-9)
  7568                          ; V   : select voice to play  (1-6: 1-3 right, 4-6 left)
  7569                          ; X   : filter    (0-1: 0=off, 1=on)
  7570                          ; M   : measure
  7571                          ; R   : rest
  7572                          ; .   : dot
  7573                          ; #   : sharp
  7574                          ; $   : flat
  7575                          
  7576                          
  7577  474e 20675b             play             jsr frmstr                               ; frmevl,frestr,return w/ .A=len, (index)=>string
  7578                          ; sta sw_rom_ram0  ;????
  7579  4751 8576                                sta z_p_temp_1                           ; save number of characters
  7580  4753 207b49                              jsr clear_play_flags                     ; set 'dot' and 'sharp' to 0. return with Acc=0
  7581  4756 8577                                sta hulp                                 ; zero counter
  7582                          
  7583  4758 a477               l103_1           ldy hulp
  7584  475a c476                                cpy z_p_temp_1
  7585  475c f00a                                beq play_rts                             ; done!
  7586  475e 20d522                              jsr indin1_ram1
  7587  4761 206947                              jsr play_one_character
  7588  4764 e677                                inc hulp
  7589  4766 d0f0                                bne l103_1                               ; always
  7590                          play_rts
  7591  4768 60                                  rts
  7592                          
  7593                          
  7594                          play_one_character
  7595  4769 c920                                cmp #' '                                 ; spaces are a 'no-op'
  7596  476b f0fb                                beq play_rts
  7597                          
  7598  476d c941               l104_1           cmp #'A'                                 ; note name a-g?
  7599  476f 9005                                bcc l104_2
  7600  4771 c948                                cmp #'H'
  7601  4773 934601                              +lbcc play_note                          ; yes...play it
  7602                          
  7603  4776 a204               l104_2           ldx #4                                   ; test for notes,'w,h,q,i,s'
  7604  4778 dd9649             l104_3           cmp notes,x
  7605  477b f31d01                              +lbeq set_note_length
  7606  477e ca                                  dex
  7607  477f 10f7                                bpl l104_3
  7608                          
  7609  4781 c952                                cmp #'R'                                 ; rest?
  7610  4783 f3a101                              +lbeq play_rest
  7611  4786 c92e                                cmp #'.'                                 ; dotted note?
  7612  4788 f30c01                              +lbeq play_dot
  7613                          
  7614  478b a205                                ldx #5                                   ; test for v,o,t,x,u,m commands
  7615  478d dd9b49             l104_4           cmp mutabl,x
  7616  4790 f36c01                              +lbeq play_command
  7617  4793 ca                                  dex
  7618  4794 10f7                                bpl l104_4                               ; test all 5 characters in table
  7619                          
  7620  4796 c923                                cmp #'#'                                 ; sharp?
  7621  4798 f37d01                              +lbeq play_sharp
  7622  479b c924                                cmp #'$'                                 ; flat?
  7623  479d f37b01                              +lbeq play_flat
  7624                          
  7625                          
  7626                          ; Must be a digit here for Octave, Voice, envelope (T), filter (X), or volume (U)
  7627                          
  7628  47a0 38                                  sec
  7629  47a1 e930                                sbc #'0'                                 ; mask nybble
  7630  47a3 c90a                                cmp #10                                  ; must be in range 0..9
  7631  47a5 b3e900                              +lbcs play_bad_value
  7632                          
  7633  47a8 0edb11                              asl flag                                 ; octave, voice, envelope, filter, or volume?
  7634  47ab b041                                bcs set_voice
  7635  47ad 0edb11                              asl flag                                 ; octave, envelope, filter, or volume?
  7636  47b0 b047                                bcs set_octave
  7637  47b2 0edb11                              asl flag                                 ; envelope, filter, or volume?
  7638  47b5 b04c                                bcs set_envelope
  7639  47b7 0edb11                              asl flag                                 ; filter or volume?
  7640  47ba 9072                                bcc set_volume
  7641                          
  7642                          set_filter
  7643  47bc 207648                              jsr wait_for_all_quiet                   ; [910722]
  7644  47bf c902                                cmp #2
  7645  47c1 b3cd00                              +lbcs play_bad_value                     ; value too large
  7646  47c4 4a                                  lsr                                      ; .c=on/off
  7647  47c5 ac6f12                              ldy voice                                ; 0-5
  7648  47c8 be064a                              ldx filter_offset,y                      ; 0 0 0 4 4 4
  7649  47cb bd7a12                              lda filters1+2,x                         ; get current filter data for this SID  [910612]
  7650  47ce 195f79                              ora vbits,y                              ; update filter voice bit
  7651  47d1 b003                                bcs l105_1                               ; branch to turn filter on
  7652  47d3 595f79                              eor vbits,y                              ; else, turn filter off   [910612]
  7653                          
  7654  47d6 9d7a12             l105_1           sta filters1+2,x
  7655                          ; lda filters1+3,x ;why????     [910612]
  7656                          ; sta filters1+4,x ;save new filter-type/volume
  7657                          
  7658                          ; jsr put_io_in_map
  7659  47d9 b9004a                              lda SID_offset,y                         ; get hardware offset for current voice
  7660  47dc 29f0                                and #$f0                                 ; $00 or $20
  7661  47de a8                                  tay
  7662                          ; jsr go_slow  ;      [910716] 4567R7A
  7663  47df a303                                ldz #3
  7664  47e1 bd7812             l105_2           lda filters1,x                           ; update the hardware
  7665  47e4 9915d4                              sta sid1+21,y
  7666  47e7 e8                                  inx
  7667  47e8 c8                                  iny
  7668  47e9 3b                                  dez
  7669  47ea 10f5                                bpl l105_2
  7670                          ; jsr go_fast  ;      [910716] 4567R7A
  7671  47ec 8063                                bra clear_flag                           ; always
  7672                          
  7673                          
  7674                          set_voice
  7675  47ee 3a                                  dec
  7676  47ef c906                                cmp #6                                   ; stereo SIDs: 0-2=right, 3-5=left  [910612]
  7677  47f1 b39d00                              +lbcs play_bad_value
  7678  47f4 8d6f12                              sta voice                                ; 0-5
  7679  47f7 8058                                bra clear_flag                           ; always
  7680                          
  7681                          
  7682                          set_octave
  7683  47f9 c907                                cmp #7
  7684  47fb b39300                              +lbcs play_bad_value                     ; too big octave
  7685  47fe 8d7012                              sta octave                               ; set octave
  7686  4801 804e                                bra clear_flag                           ; always
  7687                          
  7688                          
  7689                          set_envelope
  7690  4803 206a48                              jsr wait_for_quiet                       ; [910626]
  7691  4806 aa                                  tax
  7692                          set_envelope_1                                            ; entry for initialization code
  7693                          ; jsr put_io_in_map
  7694  4807 ac6f12                              ldy voice
  7695  480a bd9d12                              lda wavtab,x
  7696  480d 996912                              sta waveform,y                           ; set waveform
  7697  4810 b9004a                              lda SID_offset,y                         ; get hardware offset for this voice
  7698  4813 a8                                  tay
  7699                          ; jsr go_slow  ;      [910716] 4567R7A
  7700  4814 bd8912                              lda atktab,x
  7701  4817 9905d4                              sta sid1+5,y                             ; set attack/decay
  7702  481a bd9312                              lda sustab,x
  7703  481d 9906d4                              sta sid1+6,y                             ; set sustain/release
  7704  4820 bda712                              lda pulslw,x
  7705  4823 9902d4                              sta sid1+2,y                             ; set pulse width - low byte
  7706  4826 bdb112                              lda pulshi,x
  7707  4829 9903d4                              sta sid1+3,y                             ; set pulse width - high byte
  7708                          ; jsr go_fast  ;      [910716] 4567R7A
  7709  482c 8023                                bra clear_flag
  7710                          
  7711                          
  7712                          set_volume
  7713  482e 207648                              jsr wait_for_all_quiet                   ; [910626]
  7714  4831 aa                                  tax
  7715  4832 ac6f12                              ldy voice                                ; [910612]
  7716  4835 b9064a                              lda filter_offset,y                      ; get filter offset for this voice
  7717  4838 a8                                  tay
  7718  4839 b97b12                              lda filters1+3,y                         ; get mode/volume for this SID
  7719  483c 29f0                                and #$f0                                 ; mask out old volume
  7720  483e 1d0c4a                              ora voltab,x                             ; add new volume
  7721  4841 997b12                              sta filters1+3,y                         ; save for filter change
  7722                          ; lda filters1+4,y ;get current filter-type/volume ????why  [910612]
  7723                          ; and #$f0
  7724                          ; ora voltab,x
  7725  4844 aa                                  tax
  7726  4845 ac6f12                              ldy voice
  7727  4848 b9004a                              lda SID_offset,y                         ; get hardware offset for current voice
  7728  484b 29f0                                and #$f0                                 ; $00 or $20
  7729  484d a8                                  tay
  7730                          ; jsr go_slow  ;      [910716] 4567R7A
  7731  484e 9b18d4                              stx sid1+24,y                            ; set new volume
  7732                          ; jsr go_fast  ;      [910716] 4567R7A
  7733                          ;fall into clear_flag
  7734                          
  7735                          clear_flag
  7736  4851 a900                                lda #0
  7737  4853 8ddb11                              sta flag
  7738  4856 60                                  rts
  7739                          
  7740                          
  7741                          go_fast
  7742  4857 a586                                lda sid_speed_flag
  7743  4859 0c31d0                              tsb vic+49
  7744  485c 60                                  rts
  7745                          
  7746                          
  7747                          go_slow
  7748  485d 48                                  pha
  7749  485e a940                                lda #$40
  7750  4860 2d31d0                              and vic+49
  7751  4863 1c31d0                              trb vic+49
  7752  4866 8586                                sta sid_speed_flag
  7753  4868 68                                  pla
  7754  4869 60                                  rts
  7755                          
  7756                          
  7757                          wait_for_quiet                                            ; Wait for current voice to be quiet  [910626]
  7758  486a ac6f12                              ldy voice
  7759  486d be9049                              ldx times2,y                             ; voice*2
  7760  4870 3c5e12             l106_1           bit voices+1,x                           ; test if voice is active   [910617]
  7761  4873 10fb                                bpl l106_1                               ; loop until inactive (IRQ)
  7762  4875 60                                  rts
  7763                          
  7764                          
  7765                          wait_for_all_quiet                                          ; Wait for all voices on this SID to be quiet [910626]
  7766  4876 a003                                ldy #3
  7767  4878 ae6f12                              ldx voice
  7768  487b e003                                cpx #3                                   ; determine left/right SID
  7769  487d b002                                bcs l107_1
  7770  487f a000                                ldy #0
  7771  4881 a303               l107_1           ldz #3                                   ; for each of 3 voices
  7772  4883 be9049             l107_2           ldx times2,y
  7773  4886 3c5e12             l107_3           bit voices+1,x                           ; wait for voice to be inactive (IRQ)
  7774  4889 10fb                                bpl l107_3
  7775  488b c8                                  iny                                      ; next voice
  7776  488c 3b                                  dez
  7777  488d d0f4                                bne l107_2                               ; until done 3 voices
  7778  488f 60                                  rts
  7779                          
  7780                          
  7781                          play_bad_value
  7782  4890 205148                              jsr clear_flag
  7783  4893 836909                              +lbra fcerr                              ; illegal quantity
  7784                          
  7785                          play_dot
  7786  4896 8d7212                              sta dnote
  7787  4899 60                                  rts
  7788                          
  7789                          
  7790                          
  7791                          set_note_length
  7792                          ; ldy #<beats  ;found note (.x), divide beats accordingly
  7793                          ; sty ntime
  7794                          ; ldy #>beats
  7795                          ; sty ntime+1
  7796                          
  7797  489a 2c0311                              bit _pal_ntsc                            ; determine if PAL or NTSC system  [910724]
  7798  489d 3006                                bmi l108_1                               ; ...branch if PAL
  7799  489f a3a0                                ldz #<beats_ntsc                         ; (whole note 4/4 time = 2 sec)
  7800  48a1 a005                                ldy #>beats_ntsc
  7801  48a3 8004                                bra l108_2
  7802  48a5 a3b0               l108_1           ldz #<beats_pal
  7803  48a7 a004                                ldy #>beats_pal
  7804  48a9 9c7612             l108_2           stz ntime
  7805  48ac 8c7712                              sty ntime+1
  7806                          
  7807  48af ca                 l108_3           dex
  7808  48b0 3008                                bmi l108_4                               ; finished dividing, exit
  7809  48b2 4e7712                              lsr ntime+1
  7810  48b5 6e7612                              ror ntime
  7811  48b8 80f5                                bra l108_3
  7812                          
  7813  48ba 60                 l108_4           rts
  7814                          
  7815                          
  7816                          play_note
  7817  48bb 38                                  sec
  7818  48bc e941                                sbc #'A'
  7819  48be aa                                  tax
  7820  48bf bda149                              lda scalen,x                             ; note #0-11
  7821  48c2 aa                                  tax
  7822  48c3 a906                                lda #6
  7823  48c5 38                                  sec
  7824  48c6 ed7012                              sbc octave
  7825  48c9 a8                                  tay
  7826  48ca 8a                                  txa
  7827  48cb 18                                  clc
  7828  48cc 6d7112                              adc sharp
  7829  48cf 1003                                bpl l109_1                               ; added sharp or nat
  7830  48d1 a90b                                lda #11                                  ; underflow
  7831  48d3 c8                                  iny                                      ; bump octave down
  7832  48d4 c90c               l109_1           cmp #12                                  ; overflow?
  7833  48d6 9003                                bcc l109_2                               ; no...
  7834  48d8 a900                                lda #0
  7835  48da 88                                  dey                                      ; bump octave up
  7836  48db aa                 l109_2           tax
  7837  48dc bda849                              lda scalel,x
  7838  48df 8d7412                              sta pitch
  7839                          
  7840  48e2 2c0311                              bit _pal_ntsc                            ; determine if PAL or NTSC system
  7841  48e5 3005                                bmi l109_3                               ; ...branch if PAL
  7842  48e7 bdb449                              lda scaleh,x                             ; continue as before patch
  7843  48ea 8009                                bra l109_4
  7844                          
  7845  48ec bdc049             l109_3           lda scalelp,x                            ; load from PAL tables
  7846  48ef 8d7412                              sta pitch
  7847  48f2 bdcc49                              lda scalehp,x
  7848                          
  7849  48f5 88                 l109_4           dey
  7850  48f6 3028                                bmi play_note_1                          ; go play note
  7851  48f8 4a                                  lsr
  7852  48f9 6e7412                              ror pitch
  7853  48fc 80f7                                bra l109_4
  7854                          
  7855                          
  7856                          play_command
  7857  48fe c94d                                cmp #'M'                                 ; measure?
  7858  4900 f007                                beq l110_1
  7859                          
  7860  4902 bd6d79                              lda rbits,x                              ; all others, set flag for next number
  7861  4905 8ddb11                              sta flag
  7862  4908 60                                  rts
  7863                          
  7864                          ; Wait for msb of all 3 voice counters to underflow
  7865                          
  7866                          ;l110_1 ldy #5
  7867                          ;l110_2 lda voices,y
  7868                          ; bpl l110_2
  7869                          ; dey
  7870                          ; dey
  7871                          ; bpl l110_2
  7872                          ; rts
  7873                          
  7874  4909 a005               l110_1           ldy #5                                   ; [910626]
  7875  490b be9049             l110_2           ldx times2,y
  7876  490e 3c5e12             l110_3           bit voices+1,x                           ; wait for voice to be inactive (IRQ)
  7877  4911 10fb                                bpl l110_3
  7878  4913 88                                  dey                                      ; next voice
  7879  4914 10f5                                bpl l110_2                               ; until done 6 voices
  7880  4916 60                                  rts
  7881                          
  7882                          
  7883                          
  7884                          play_sharp
  7885  4917 a901                                lda #1
  7886  4919 2c                                  !text $2c
  7887                          play_flat
  7888  491a a9ff                                lda #$ff
  7889  491c 8d7112                              sta sharp
  7890  491f 60                                  rts
  7891                          
  7892                          
  7893                          play_note_1                                               ; play a note
  7894  4920 8d7512                              sta pitch+1
  7895  4923 a900                                lda #0                                   ; flag 'not rest'
  7896  4925 2c                                  !text $2c                                ; hop
  7897                          play_rest
  7898  4926 a9ff                                lda #$ff                                 ; flag 'rest'
  7899  4928 48                                  pha                                      ; save flag
  7900  4929 ae6f12                              ldx voice
  7901  492c bc9049                              ldy times2,x                             ; y=x*2
  7902  492f b95e12             l111_1           lda voices+1,y                           ; test if there is a note playing
  7903  4932 10fb                                bpl l111_1                               ; and loop if so
  7904                          
  7905  4934 78                                  sei
  7906  4935 ad7612                              lda ntime                                ; load counter for current length
  7907  4938 995d12                              sta voices,y
  7908  493b ad7712                              lda ntime+1
  7909  493e 995e12                              sta voices+1,y
  7910  4941 ad7212                              lda dnote                                ; test if this is a dotted note
  7911  4944 f017                                beq l111_2                               ; no
  7912  4946 ad7712                              lda ntime+1
  7913  4949 4a                                  lsr                                      ; duration is 1.5 x current length
  7914  494a 48                                  pha
  7915  494b ad7612                              lda ntime
  7916  494e 6a                                  ror
  7917  494f 18                                  clc
  7918  4950 795d12                              adc voices,y
  7919  4953 995d12                              sta voices,y
  7920  4956 68                                  pla
  7921  4957 795e12                              adc voices+1,y
  7922  495a 995e12                              sta voices+1,y
  7923                          
  7924  495d 68                 l111_2           pla                                      ; test if this is a rest
  7925  495e 301a                                bmi l111_3                               ; and branch if so- clear play flags and exit [910722]
  7926                          
  7927                          ; jsr put_io_in_map
  7928                          ; jsr go_slow  ;      [910716] 4567R7A
  7929  4960 bc004a                              ldy SID_offset,x                         ; get offset to voice hardware
  7930  4963 ad7412                              lda pitch
  7931  4966 9900d4                              sta sid1,y
  7932  4969 ad7512                              lda pitch+1
  7933  496c 9901d4                              sta sid1+1,y
  7934  496f a908                                lda #$08                                 ; reset this voice
  7935  4971 9904d4                              sta sid1+4,y
  7936  4974 bd6912                              lda waveform,x                           ; and finally, turn on gate
  7937  4977 9904d4                              sta sid1+4,y
  7938                          ; jsr go_fast  ;      [910716] 4567R7A
  7939  497a 58                 l111_3           cli
  7940                          
  7941                          
  7942                          clear_play_flags
  7943  497b a900                                lda #0
  7944  497d 8d7112                              sta sharp                                ; clear flags
  7945  4980 8d7212                              sta dnote
  7946  4983 58                                  cli
  7947  4984 60                                  rts
  7948                          
  7949                          
  7950  4985 206c5d             tempo            jsr getbyt                               ; duration of whole note 4/4 time = 24/rate
  7951  4988 8a                                  txa
  7952  4989 f37308                              +lbeq fcerr                              ; can't be zero- illegal quantity error
  7953  498c 8e7312                              stx tempo_rate
  7954  498f 60                                  rts
  7955                          
  7956                          
  7957  4990 00020406080a       times2           !text 0,2,4,6,8,10                       ; [910612] stereo
  7958                          
  7959  4996 5748514953         notes            !text "WHQIS"                            ; sixteenth,eigth,quarter,half,and whole notes
  7960                          
  7961  499b 564f5458554d       mutabl           !text "VOTXUM"                           ; voice,octave,envelope,filter,volume,& measure
  7962                          
  7963  49a1 090b0002040507     scalen           !text 9,11,0,2,4,5,7                     ; a,b,c,d,e,f,g
  7964                          
  7965  49a8 0f0c46bf7d83       scalel           !text $0f,$0c,$46,$bf,$7d,$83            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (NTSC, octave 6)
  7966  49ae d67a73c87c97                        !text $d6,$7a,$73,$c8,$7c,$97            ; [910729]
  7967                          
  7968  49b4 43474b4f5459       scaleh           !text $43,$47,$4b,$4f,$54,$59            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (NTSC, octave 6)
  7969  49ba 5e646a70777e                        !text $5e,$64,$6a,$70,$77,$7e            ; [910729]
  7970                          
  7971  49c0 878bcc4e1424       scalelp          !text $87,$8b,$cc,$4e,$14,$24            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (PAL,  octave 6)
  7972  49c6 802d3291527a                        !text $80,$2d,$32,$91,$52,$7a            ; [910729]
  7973                          
  7974  49cc 43474b50555a       scalehp          !text $43,$47,$4b,$50,$55,$5a            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (PAL,  octave 6)
  7975  49d2 5f656b71787f                        !text $5f,$65,$6b,$71,$78,$7f            ; [910729]
  7976                          
  7977                          ;  Music envelope tables, default values downloaded to RAM:
  7978                          ;
  7979                          ; 0: piano   1: accordion    2: calliope  3: drum     4: flute
  7980                          ; 5: guitar  6: harpsichord  7: organ     8: trumpet  9: xylophone
  7981                          
  7982                          ;  Attack/decay rates
  7983                          
  7984  49d8 09c0000594090909...atkmus           !text $09,$c0,$00,$05,$94,$09,$09,$09,$89,$09
  7985                          
  7986                          ;  Sustain/release rates
  7987                          
  7988  49e2 00c0f05040210090...susmus           !text $00,$c0,$f0,$50,$40,$21,$00,$90,$41,$00
  7989                          
  7990                          ;  Waveform table
  7991                          
  7992  49ec 4121118111214141...wavmus           !text $41,$21,$11,$81,$11,$21,$41,$41,$41,$11
  7993                          
  7994                          ;  Pulse width hi table
  7995                          
  7996  49f6 0600000000000208...pwhmus           !text $06,$00,$00,$00,$00,$00,$02,$08,$02,$00
  7997                          
  7998                          ;  Offset tables
  7999                          
  8000                          SID_offset
  8001  4a00 00070e20272e                        !text $00,$07,$0e,$20,$27,$2e            ; [910612] stereo
  8002                          filter_offset
  8003  4a06 000000040404                        !text 0,0,0,4,4,4
  8004                          
  8005                          ;  Volume levels
  8006                          
  8007  4a0c 0001030507080a0c...voltab           !text 0,1,3,5,7,8,10,12,14,15
  8008                          
  8009                          ;.end
  8010                          ;[[command.filter]]
  8011                          
  8012                          
  8013                          
  8014                          ;******************************************************************
  8015                          ;
  8016                          ;  FILTER  sid, freq, lp, bp, hp, res   --  set values for filter
  8017                          ;
  8018                          ;     sid =  right (1), left (2)
  8019                          ;          freq =  filter frequency (0-1023)
  8020                          ;            lp =  low pass filter on (1) or off (0)
  8021                          ;            bp =  band pass filter on (1) or off (0)
  8022                          ;            hp =  high pass filter on (1) or off (0)
  8023                          ;           res =  resonance (0-15)
  8024                          ;
  8025                          ;******************************************************************
  8026                          
  8027  4a16 206c5d             filter           jsr getbyt                               ; get left/right SID    [910612]
  8028  4a19 ca                                  dex
  8029  4a1a e002                                cpx #2
  8030  4a1c b3e007                              +lbcs fcerr
  8031  4a1f bd084a                              lda filter_offset+2,x                    ; get filter offset for specified SID
  8032  4a22 8576                                sta z_p_temp_1
  8033  4a24 aa                                  tax
  8034                          
  8035  4a25 a000                                ldy #0
  8036  4a27 bd7812             l112_1           lda filters1,x                           ; save current voice's filter params
  8037  4a2a 998012                              sta fltsav,y
  8038  4a2d e8                                  inx
  8039  4a2e c8                                  iny
  8040  4a2f c004                                cpy #4
  8041  4a31 90f4                                bcc l112_1
  8042                          
  8043  4a33 20f278                              jsr optwrd                               ; get filter frequency
  8044  4a36 9017                                bcc l112_2                               ; skip if no value given
  8045  4a38 c908                                cmp #8                                   ; test m.s. byte
  8046  4a3a b3c207                              +lbcs fcerr                              ; error if > 2047
  8047  4a3d 8c8012                              sty fltsav                               ; save lower byte
  8048                          
  8049                          ; Idea: shift lower 3 bits of upper byte into lower byte, forming bits 10-3
  8050                          
  8051  4a40 8c8112                              sty fltsav+1
  8052  4a43 4a                                  lsr
  8053  4a44 6e8112                              ror fltsav+1
  8054  4a47 4a                                  lsr
  8055  4a48 6e8112                              ror fltsav+1                             ; save upper 7 bits (10-3)
  8056  4a4b 4a                                  lsr
  8057  4a4c 6e8112                              ror fltsav+1
  8058                          
  8059  4a4f a910               l112_2           lda #$10                                 ; start at type=LP
  8060  4a51 8d8412                              sta fltflg
  8061  4a54 ad8012                              lda fltsav
  8062                          
  8063  4a57 202679             l112_3           jsr optbyt                               ; get filter types (LP,BP,HP)
  8064  4a5a 9017                                bcc l112_6                               ; skip if no value input
  8065  4a5c e001                                cpx #1                                   ; (set .c: 0=0, 1=1)
  8066  4a5e 9005                                bcc l112_4
  8067  4a60 f003                                beq l112_4
  8068  4a62 839a07                              +lbra fcerr                              ; error if >1
  8069                          
  8070  4a65 ad8312             l112_4           lda fltsav+3                             ; get filter flags byte
  8071  4a68 0d8412                              ora fltflg                               ; set filter on
  8072  4a6b b003                                bcs l112_5                               ; skip if it should be on
  8073  4a6d 4d8412                              eor fltflg                               ; turn filter off
  8074  4a70 8d8312             l112_5           sta fltsav+3                             ; save value
  8075                          
  8076  4a73 0e8412             l112_6           asl fltflg                               ; shift for next filter
  8077  4a76 10df                                bpl l112_3                               ; loop 3 times
  8078                          
  8079  4a78 202679                              jsr optbyt                               ; get resonance value
  8080  4a7b 9016                                bcc l112_7                               ; skip if no value given
  8081                          ; cpx #16
  8082                          ; bcs fcerr  ;error if >15
  8083  4a7d 2010b5                              jsr chknyb                               ; [910930]
  8084  4a80 8a                                  txa
  8085  4a81 0a                                  asl                                      ; shift to upper nibble
  8086  4a82 0a                                  asl
  8087  4a83 0a                                  asl
  8088  4a84 0a                                  asl
  8089  4a85 8dbc12                              sta nibble
  8090  4a88 ad8212                              lda fltsav+2                             ; get current value
  8091  4a8b 290f                                and #$0f                                 ; mask it out
  8092  4a8d 0dbc12                              ora nibble                               ; add new value
  8093  4a90 8d8212                              sta fltsav+2                             ; save it
  8094                          
  8095  4a93 a676               l112_7           ldx z_p_temp_1                           ; hardware offset for this voice's filter [910612]
  8096  4a95 a000                                ldy #0
  8097  4a97 b98012             l112_8           lda fltsav,y                             ; copy new filter params to hardware
  8098  4a9a 9d7812                              sta filters1,x
  8099  4a9d e8                                  inx
  8100  4a9e c8                                  iny
  8101  4a9f c004                                cpy #4
  8102  4aa1 90f4                                bcc l112_8
  8103  4aa3 60                                  rts
  8104                          
  8105                          ;.end
  8106                          
  8107                          ;[[command.envelope]]
  8108                          
  8109                          
  8110                          ;****************************************************************
  8111                          ;
  8112                          ;  ENVELOPE n, attack, decay, sustain, release, waveform, pulse width
  8113                          ;        set music envelope
  8114                          ;                n = envelope number (0-9)
  8115                          ;            wave  =   0 : triangle waveform
  8116                          ;                      1 : sawtooth waveform
  8117                          ;                      2 : pulse waveform
  8118                          ;                      3 : noise waveform
  8119                          ;                      4 : ring modulation
  8120                          ;            pulse = pulse width if pulse waveform is selected (0-4095)
  8121                          ;
  8122                          ;******************************************************************
  8123                          
  8124                          envelope
  8125  4aa4 206c5d                              jsr getbyt                               ; get envelope number
  8126  4aa7 e00a                                cpx #10
  8127  4aa9 b35307                              +lbcs fcerr                              ; exit - invalid tone number
  8128  4aac 8e8512                              stx tonnum                               ; save number
  8129  4aaf bd8912                              lda atktab,x                             ; get attack/decay rates
  8130  4ab2 8d8612                              sta tonval
  8131  4ab5 bd9312                              lda sustab,x                             ; get sustain/release rates
  8132  4ab8 8d8712                              sta tonval+1
  8133  4abb bd9d12                              lda wavtab,x                             ; get waveform and filter
  8134  4abe 8d8812                              sta tonval+2
  8135                          
  8136  4ac1 a200                                ldx #0
  8137  4ac3 8ebb12             l113_1           stx parcnt
  8138  4ac6 202679                              jsr optbyt                               ; get parameter - attack or sustain
  8139  4ac9 9016                                bcc l113_2                               ; skip if no input
  8140  4acb 8a                                  txa
  8141  4acc 0a                                  asl
  8142  4acd 0a                                  asl                                      ; shift to upper nibble
  8143  4ace 0a                                  asl
  8144  4acf 0a                                  asl
  8145  4ad0 8dbc12                              sta nibble                               ; save it
  8146  4ad3 aebb12                              ldx parcnt
  8147  4ad6 bd8612                              lda tonval,x                             ; get current value
  8148  4ad9 290f                                and #$0f                                 ; mask it out
  8149  4adb 0dbc12                              ora nibble                               ; add new value
  8150  4ade 9d8612                              sta tonval,x                             ; save it
  8151                          
  8152  4ae1 202679             l113_2           jsr optbyt                               ; get decay or release rate
  8153  4ae4 9014                                bcc l113_3                               ; skip if no input
  8154  4ae6 8a                                  txa
  8155  4ae7 290f                                and #$0f                                 ; use only lower nibble
  8156  4ae9 8dbc12                              sta nibble                               ; save it
  8157  4aec aebb12                              ldx parcnt
  8158  4aef bd8612                              lda tonval,x                             ; get current value
  8159  4af2 29f0                                and #$f0                                 ; mask it out
  8160  4af4 0dbc12                              ora nibble                               ; add new value
  8161  4af7 9d8612                              sta tonval,x                             ; save it
  8162                          
  8163  4afa aebb12             l113_3           ldx parcnt
  8164  4afd e8                                  inx
  8165  4afe e001                                cpx #1
  8166  4b00 f0c1                                beq l113_1                               ; loop to do sustain/release rates
  8167  4b02 202679                              jsr optbyt                               ; get waveform
  8168  4b05 9011                                bcc l113_5                               ; skip if no value
  8169  4b07 a915                                lda #$15                                 ; assume ring modulation
  8170  4b09 e004                                cpx #4
  8171  4b0b f008                                beq l113_4                               ; skip if correct
  8172  4b0d b3ef06                              +lbcs fcerr                              ; error if >4
  8173  4b10 bd6979                              lda sbits+4,x                            ; get waveform bit
  8174  4b13 0901                                ora #1                                   ; set gate bit
  8175                          
  8176  4b15 8d8812             l113_4           sta tonval+2                             ; save waveform
  8177                          
  8178  4b18 20f278             l113_5           jsr optwrd                               ; is there a pulse width arg?
  8179  4b1b 9013                                bcc l113_6                               ; nope, done
  8180                          
  8181  4b1d aa                                  tax                                      ; save msb
  8182  4b1e ad8812                              lda tonval+2                             ; get waveform
  8183  4b21 2940                                and #$40
  8184  4b23 f00b                                beq l113_6                               ; skip if not pulse waveform
  8185  4b25 8a                                  txa
  8186  4b26 ae8512                              ldx tonnum                               ; get envelope number
  8187  4b29 9db112                              sta pulshi,x                             ; save high byte of pulse width
  8188  4b2c 98                                  tya
  8189  4b2d 9da712                              sta pulslw,x                             ; save low byte
  8190                          
  8191  4b30 ae8512             l113_6           ldx tonnum
  8192  4b33 ad8612                              lda tonval                               ; set inputted values
  8193  4b36 9d8912                              sta atktab,x
  8194  4b39 ad8712                              lda tonval+1
  8195  4b3c 9d9312                              sta sustab,x
  8196  4b3f ad8812                              lda tonval+2
  8197  4b42 9d9d12                              sta wavtab,x
  8198                          volrts
  8199  4b45 60                                  rts
  8200                          
  8201                          ;.end
  8202                          
  8203                          ;[[command.volume]]
  8204                          
  8205                          
  8206                          ;***************************************************************
  8207                          ;*
  8208                          ;*  VOLUME - set volume of SID chips
  8209                          ;*
  8210                          ;* Syntax : VOLUME [right] [,left]
  8211                          ;*
  8212                          ;* Where  : vol in 0..15
  8213                          ;*
  8214                          ;***************************************************************
  8215                          
  8216  4b46 f302e3             volume           +lbeq snerr                              ; stereo parameters    [910612]
  8217  4b49 c92c                                cmp #','
  8218  4b4b f017                                beq l114_1                               ; left volume only
  8219                          ; jsr getbyt  ;right volume in .x
  8220                          ; cpx #16
  8221                          ; bcs fcerr  ;too large
  8222  4b4d 200db5                              jsr getnyb                               ; [910930]
  8223  4b50 8676                                stx z_p_temp_1                           ; a temp (sorry fred)
  8224                          
  8225                          ; The way this is done must work with 'PLAY' without too much conflict.
  8226                          ; So, along with setting the SID 'volume' reg, we'll also set up PLAY's
  8227                          ; record of current volume as well.
  8228                          
  8229  4b52 ad7b12                              lda filters1+3
  8230  4b55 29f0                                and #$f0
  8231  4b57 0576                                ora z_p_temp_1
  8232  4b59 8d7b12                              sta filters1+3
  8233                          
  8234                          ; lda filters1+4  ;???? why     [910612]
  8235                          ; and #$f0
  8236                          ; ora z_p_temp_1
  8237                          ; sta filters1+4
  8238                          
  8239                          ; jsr put_io_in_map
  8240                          ; jsr go_slow  ;      [910716] 4567R7A
  8241  4b5c 8d18d4                              sta sid1+24
  8242                          ; jsr go_fast  ;      [910716] 4567R7A
  8243  4b5f 208522                              jsr chrgot
  8244  4b62 f0e1                                beq volrts
  8245                          
  8246  4b64 202679             l114_1           jsr optbyt                               ; get optional left parameter   [910612]
  8247  4b67 93e1e2                              +lbcc snerr                              ; comma but no value not given??
  8248  4b6a 2010b5                              jsr chknyb                               ; [910930]
  8249                          ; cpx #16
  8250                          ; bcs fcerr  ;too large
  8251  4b6d 8676                                stx z_p_temp_1                           ; a temp (sorry fred)
  8252                          
  8253  4b6f ad7f12                              lda filters2+3
  8254  4b72 29f0                                and #$f0
  8255  4b74 0576                                ora z_p_temp_1
  8256  4b76 8d7f12                              sta filters2+3
  8257                          
  8258                          ; lda filters2+4  ;???? why     [910612]
  8259                          ; and #$f0
  8260                          ; ora z_p_temp_1
  8261                          ; sta filters2+4
  8262                          
  8263                          ; jsr put_io_in_map
  8264                          ; jsr go_slow  ;      [910716] 4567R7A
  8265  4b79 8d38d4                              sta sid2+24
  8266                          ; jsr go_fast  ;      [910716] 4567R7A
  8267  4b7c 60                                  rts
  8268                          
  8269                          ;.end
  8270                          ;[[command.sound]]
  8271                          
  8272                          
  8273                          
  8274                          ;*****************************************************************************
  8275                          ;*
  8276                          ;*  SOUND - Produce sound effects
  8277                          ;*
  8278                          ;* Syntax : SOUND v, f, d [,[dir] [,[m] [,[s] [,[w] [,p] ]]]]
  8279                          ;*
  8280                          ;* Where : v   = voice    (1..6)
  8281                          ;*  f   = frequency    (0..65535)
  8282                          ;*  d   = duration    (0..32767 jiffys)
  8283                          ;*  dir = step direction  (0(up) ,1(down) or 2(oscillate)) default=0
  8284                          ;*  m   = minimum frequency  (if sweep is used) (0..65535) default=0
  8285                          ;*  s   = step value for effects  (0..32767) default=0
  8286                          ;*  w   = waveform  (0=triangle,1=saw,2=square,3=noise) default=2
  8287                          ;*  p   = pulse width  (0..4095) default=2048 (50% duty cycle)
  8288                          ;*
  8289                          ;*****************************************************************************
  8290                          
  8291  4b7d c99c               sound            cmp #clr_token                           ; SOUND CLR: init sound/music environment [910717]
  8292  4b7f f3d472                              +lbeq Sound_CLR                          ; yes
  8293                          
  8294  4b82 206c5d                              jsr getbyt                               ; get voice number in .X
  8295  4b85 ca                                  dex                                      ; adjust 1..3 to 0..2
  8296  4b86 e006                                cpx #6                                   ; [910612]
  8297  4b88 b37406             l115_1           +lbcs fcerr                              ; illegal value
  8298                          
  8299  4b8b 8ebd12             l115_2           stx sound_voice
  8300                          
  8301                          ; Get frequency
  8302                          
  8303  4b8e 20875d                              jsr comwrd                               ; eat comma, get frequency in y,a
  8304  4b91 8c6211                              sty temp_max_lo                          ; save our copy of max, also set up as current
  8305  4b94 8d6311                              sta temp_max_hi
  8306  4b97 8c6911                              sty temp_freq_lo
  8307  4b9a 8d6a11                              sta temp_freq_hi
  8308                          
  8309                          ; Get duration
  8310                          
  8311  4b9d 20875d                              jsr comwrd                               ; eat comma, get number of jiffys to play
  8312  4ba0 c980                                cmp #$80
  8313  4ba2 b0e4                                bcs l115_1
  8314  4ba4 8c6011                              sty temp_time_lo
  8315  4ba7 8d6111                              sta temp_time_hi
  8316                          
  8317                          ; Get sweep direction
  8318                          
  8319  4baa 202479                              jsr optzer                               ; get optional sweep (default = 0, up)
  8320  4bad e003                                cpx #3
  8321  4baf b0d7                                bcs l115_1
  8322  4bb1 8a                                  txa
  8323  4bb2 8d6611                              sta temp_direction
  8324  4bb5 2901                                and #1                                   ; set .Z if sweep up or oscillate
  8325  4bb7 08                                  php                                      ; save .Z for step (below)
  8326                          
  8327                          ; Get minimum frequency value (sweep lo)
  8328                          
  8329  4bb8 20f278                              jsr optwrd
  8330  4bbb 8c6411                              sty temp_min_lo
  8331  4bbe 8d6511                              sta temp_min_hi
  8332                          
  8333                          ; Get step value for sweep
  8334                          
  8335  4bc1 20f278                              jsr optwrd                               ; get optional step, default is zero
  8336  4bc4 28                                  plp                                      ; get flags from direction
  8337  4bc5 f00d                                beq l115_3                               ; branch if 'up' or oscillate
  8338  4bc7 48                                  pha                                      ; if 'down', make step 2's complement
  8339  4bc8 98                                  tya
  8340  4bc9 49ff                                eor #$ff
  8341  4bcb 18                                  clc
  8342  4bcc 6901                                adc #1
  8343  4bce a8                                  tay
  8344  4bcf 68                                  pla
  8345  4bd0 49ff                                eor #$ff
  8346  4bd2 6900                                adc #0
  8347  4bd4 8d6811             l115_3           sta temp_step_hi
  8348  4bd7 98                                  tya
  8349  4bd8 8d6711                              sta temp_step_lo
  8350                          
  8351                          ; Get waveform
  8352                          
  8353  4bdb a202                                ldx #2                                   ; get waveform. default is square (2)
  8354  4bdd 202679                              jsr optbyt
  8355  4be0 e004                                cpx #4
  8356  4be2 b0a4                                bcs l115_1                               ; illegal value
  8357  4be4 bd6979                              lda sbits+4,x                            ; get bit pattern for selected waveform
  8358  4be7 0901                                ora #1                                   ; add in the gate bit
  8359  4be9 8d6d11                              sta temp_waveform
  8360                          
  8361                          ; Get pulse width
  8362                          
  8363  4bec 20f278                              jsr optwrd                               ; get optional pulse width in y,a
  8364  4bef b004                                bcs l115_4
  8365  4bf1 a908                                lda #8                                   ; no arg's given, use default pulse width
  8366  4bf3 a000                                ldy #0
  8367  4bf5 c910               l115_4           cmp #16
  8368  4bf7 b08f                                bcs l115_1
  8369  4bf9 8c6b11                              sty temp_pulse_lo
  8370  4bfc 8d6c11                              sta temp_pulse_hi
  8371                          
  8372                          ; All arg's in, time to get to work
  8373                          
  8374  4bff ad6011                              lda temp_time_lo
  8375  4c02 0d6111                              ora temp_time_hi
  8376  4c05 f046                                beq l115_9                               ; special case: time=0 means 'kill it NOW'
  8377                          
  8378                          ; Wait for all current uses of this voice to time out
  8379                          
  8380  4c07 aebd12                              ldx sound_voice                          ; first test 'PLAY'
  8381  4c0a 8a                                  txa                                      ; make an index into PLAY's tables
  8382  4c0b 0a                                  asl
  8383  4c0c a8                                  tay
  8384  4c0d b95e12             l115_5           lda voices+1,y
  8385  4c10 10fb                                bpl l115_5
  8386                          
  8387  4c12 bdc412             l115_6           lda sound_time_hi,x                      ; now test 'SOUND'
  8388  4c15 10fb                                bpl l115_6
  8389                          
  8390                          ; All clear, now set up for current effect
  8391                          
  8392  4c17 a000                                ldy #0                                   ; download max freq l&h, min freq l&h,
  8393  4c19 b96211             l115_7           lda temp_max_lo,y                        ; ..sweep direction, step value l&h, & freq l&h
  8394  4c1c 9dca12                              sta sound_max_lo,x
  8395  4c1f e8                                  inx
  8396  4c20 e8                                  inx
  8397  4c21 e8                                  inx
  8398  4c22 e8                                  inx                                      ; [910612] stereo
  8399  4c23 e8                                  inx
  8400  4c24 e8                                  inx
  8401  4c25 c8                                  iny
  8402  4c26 c009                                cpy #9
  8403  4c28 90ef                                bcc l115_7
  8404                          
  8405                          ; Now set up SID
  8406                          
  8407  4c2a aebd12                              ldx sound_voice
  8408  4c2d bc004a                              ldy SID_offset,x                         ; get index to SID voices
  8409                          ; jsr put_io_in_map
  8410                          ; jsr go_slow  ;      [910716] 4567R7A
  8411                          
  8412  4c30 a908                                lda #$08                                 ; turn off SID gate
  8413  4c32 9904d4                              sta sid1+4,y
  8414                          
  8415  4c35 a900                                lda #0                                   ; set up attack & decay,
  8416  4c37 9905d4                              sta sid1+5,y
  8417  4c3a a9f0                                lda #$f0                                 ; ..and sustain & release
  8418  4c3c 9906d4                              sta sid1+6,y
  8419                          
  8420  4c3f a200                                ldx #0                                   ; set up freq (l&h), pulse width (l&h), & waveform
  8421  4c41 bd6911             l115_8           lda temp_freq_lo,x
  8422  4c44 9900d4                              sta sid1,y
  8423  4c47 c8                                  iny
  8424  4c48 e8                                  inx
  8425  4c49 e005                                cpx #5
  8426  4c4b d0f4                                bne l115_8
  8427                          ; jsr go_fast  ;      [910716] 4567R7A
  8428                          
  8429                          ; Now set up time to play
  8430                          
  8431  4c4d aebd12             l115_9           ldx sound_voice
  8432  4c50 ac6011                              ldy temp_time_lo
  8433  4c53 ad6111                              lda temp_time_hi
  8434                          
  8435  4c56 78                                  sei
  8436  4c57 9dc412                              sta sound_time_hi,x
  8437  4c5a 98                                  tya
  8438  4c5b 9dbe12                              sta sound_time_lo,x
  8439  4c5e 58                                  cli
  8440                          
  8441  4c5f 60                                  rts
  8442                          
  8443                          ;.end
  8444                          ;[[command.window]]
  8445                          
  8446                          
  8447                          
  8448                          ;****************************************************************
  8449                          ;*
  8450                          ;*  WINDOW Command
  8451                          ;*
  8452                          ;*  Syntax : WINDOW upper-left col, upper-left row,
  8453                          ;*      lower-left col, lower-right row [,clear]
  8454                          ;*
  8455                          ;*  Where  :  0 <= row <= 24
  8456                          ;*       0 <= column <= (80/40)
  8457                          ;*       clear : 0 (no) or 1 (yes)
  8458                          ;*
  8459                          ;****************************************************************
  8460                          
  8461  4c60 206c5d             window           jsr getbyt                               ; get u.l. col
  8462  4c63 e050                                cpx #80
  8463  4c65 7fd702                              bbr7 _mode,l116_1
  8464  4c68 e028                                cpx #40
  8465  4c6a b057               l116_1           bcs l116_4
  8466  4c6c 8e7911                              stx window_temp
  8467                          
  8468  4c6f 20825d                              jsr combyt                               ; get u.l. row
  8469  4c72 e019                                cpx #25
  8470  4c74 b04d                                bcs l116_4
  8471  4c76 8e7a11                              stx window_temp+1
  8472                          
  8473  4c79 20825d                              jsr combyt                               ; get l.r. column
  8474  4c7c e050                                cpx #80
  8475  4c7e 7fd702                              bbr7 _mode,l116_2
  8476  4c81 e028                                cpx #40
  8477  4c83 b03e               l116_2           bcs l116_4
  8478  4c85 8e7b11                              stx window_temp+2
  8479  4c88 ec7911                              cpx window_temp                          ; can't be less than u.l. column
  8480  4c8b 9036                                bcc l116_4
  8481                          
  8482  4c8d 20825d                              jsr combyt                               ; get l.r. row
  8483  4c90 e019                                cpx #25
  8484  4c92 b02f                                bcs l116_4
  8485  4c94 8e7c11                              stx window_temp+3
  8486  4c97 ec7a11                              cpx window_temp+1                        ; can't be less than u.l. row
  8487  4c9a 9027                                bcc l116_4
  8488                          
  8489  4c9c 202479                              jsr optzer                               ; get optional clear flag
  8490  4c9f e002                                cpx #2
  8491  4ca1 b020                                bcs l116_4
  8492  4ca3 da                                  phx
  8493                          
  8494  4ca4 ae7911                              ldx window_temp
  8495  4ca7 ad7a11                              lda window_temp+1
  8496  4caa 18                                  clc
  8497  4cab 202de0                              jsr _set_window
  8498                          
  8499  4cae ae7b11                              ldx window_temp+2
  8500  4cb1 ad7c11                              lda window_temp+3
  8501  4cb4 38                                  sec
  8502  4cb5 202de0                              jsr _set_window
  8503                          
  8504  4cb8 a213                                ldx #19                                  ; assume 'home', not 'cls'
  8505  4cba 68                                  pla
  8506  4cbb f002                                beq l116_3
  8507  4cbd a293                                ldx #147
  8508  4cbf 8a                 l116_3           txa
  8509  4cc0 4cd2ff                              jmp _bsout
  8510                          
  8511  4cc3 833905             l116_4           +lbra fcerr                              ; illegal value error
  8512                          
  8513                          ;.end
  8514                          ;[[command.fastslow]]
  8515                          
  8516                          
  8517                          
  8518                          ;***********************************************************************
  8519                          ;
  8520                          ;    FAST - put the system in FAST (4 MHz?) mode.
  8521                          ;
  8522                          ;***********************************************************************
  8523                          
  8524                          fast
  8525  4cc6 d382e1                              +lbne snerr                              ; no args      [910410]
  8526                          ; jsr put_io_in_map
  8527  4cc9 a940                                lda #%01000000
  8528  4ccb 0c31d0                              tsb vic+49                               ; set FAST (4MHz?) mode
  8529  4cce 60                                  rts
  8530                          
  8531                          
  8532                          
  8533                          ;***********************************************************************
  8534                          ;
  8535                          ;    SLOW - put the system in SLOW (1 MHz) mode.
  8536                          ;
  8537                          ;***********************************************************************
  8538                          
  8539                          slow
  8540  4ccf d379e1                              +lbne snerr                              ; no args      [910410]
  8541                          ; jsr put_io_in_map
  8542  4cd2 a940                                lda #%01000000
  8543  4cd4 1c31d0                              trb vic+49
  8544  4cd7 60                                  rts
  8545                          
  8546                          ;.end
  8547                          
  8548                          
  8549                          
  8550                          ; These routines check for certain VALTYP.   (c) is not preserved.
  8551                          
  8552                          
  8553                          
  8554  4cd8 20ef4c             frmnum           jsr frmevl
  8555                          
  8556  4cdb 18                 chknum           clc
  8557  4cdc 89                                  !text $89
  8558                          
  8559  4cdd 38                 chkstr           sec
  8560                          
  8561                          chkval
  8562                          ; bbs7 valtyp,docstr ;cannot do this- return status +/-/= needed!
  8563  4cde 240f                                bit valtyp
  8564  4ce0 3003                                bmi docstr
  8565  4ce2 b003                                bcs chkerr
  8566  4ce4 60                 chkok            rts
  8567                          
  8568  4ce5 b0fd               docstr           bcs chkok
  8569                          
  8570  4ce7 a216               chkerr           ldx #errtm
  8571  4ce9 2c                                  !text $2c
  8572                          
  8573  4cea a219               sterr            ldx #errst
  8574  4cec 8361e1                              +lbra error
  8575                          
  8576                          ;.end
  8577                          
  8578                          ;[[evaluate]]
  8579                          
  8580                          
  8581                          ; Formula Evaluator Routine
  8582                          ;
  8583                          ; The formula evaluator starts with (txtptr) pointing to the first character
  8584                          ; in the formula.  At the end (txtptr) points to the terminator.
  8585                          ; The result is left in the FAC.  On return (a) does not reflect the terminator.
  8586                          ;
  8587                          ; The formula evaluator uses the operator (optab) to determine precedence and
  8588                          ; dispatch addresses for each operator.
  8589                          ; A temporary result on the stack has the following format:
  8590                          ;
  8591                          ;     * The address of the operator routine.
  8592                          ;     * The floating point temporary result.
  8593                          ;     * The precedence of the operator.
  8594                          
  8595                          
  8596  4cef c33d               frmevl           dew txtptr                               ; txtptr points to 1st char. in formula
  8597  4cf1 a200                                ldx #0                                   ; dummy precedence = 0
  8598  4cf3 89                                  !text $89
  8599                          
  8600  4cf4 48                 lpoper           pha                                      ; save precedence
  8601  4cf5 da                                  phx
  8602  4cf6 ba                                  tsx                                      ; confirm enough system stack available (recursive calls)
  8603  4cf7 e089                                cpx #<sysstk+44                          ; bottom of stack + room for error handling
  8604  4cf9 90ef                                bcc sterr                                ; formula too complex
  8605  4cfb 20e24d                              jsr eval
  8606  4cfe a900                                lda #0
  8607  4d00 854f                                sta opmask
  8608                          
  8609  4d02 208522             tstop            jsr chrgot                               ; last char
  8610  4d05 38                 loprel           sec                                      ; prepare to subtract
  8611  4d06 e9b1                                sbc #greater_token                       ; is current character a relation?
  8612  4d08 9017                                bcc endrel                               ; no, relations all through
  8613  4d0a c903                                cmp #less_token-greater_token+1
  8614  4d0c b013                                bcs endrel                               ; really relational?  no, just big
  8615  4d0e c901                                cmp #1                                   ; reset carry for zero only
  8616  4d10 2a                                  rol                                      ; 0 to 1, 1 to 2, 2 to 4
  8617  4d11 4901                                eor #1
  8618  4d13 454f                                eor opmask                               ; bring in the old bits
  8619  4d15 c54f                                cmp opmask                               ; make sure that the new mask is bigger
  8620  4d17 9331e1                              +lbcc snerr                              ; syntax error, because two of the same
  8621  4d1a 854f                                sta opmask                               ; save mask
  8622  4d1c 208322                              jsr chrget
  8623  4d1f 80e4                                bra loprel                               ; get the next candidate
  8624                          
  8625                          
  8626  4d21 a64f               endrel           ldx opmask                               ; were there any?
  8627  4d23 d02c                                bne finrel                               ; yes, handle as special op
  8628  4d25 b39000                              +lbcs qop                                ; not an operator
  8629  4d28 6907                                adc #greater_token-plus_token
  8630  4d2a 938b00                              +lbcc qop                                ; not an operator
  8631  4d2d 650f                                adc valtyp                               ; (c)=1
  8632  4d2f f3c50d                              +lbeq cat                                ; only if (a)=0 and VALTYP=$FF (a string)
  8633                          
  8634  4d32 69ff                                adc #$ff                                 ; get back original (a)
  8635  4d34 8524                                sta index1
  8636  4d36 0a                                  asl                                      ; multiply by two
  8637  4d37 6524                                adc index1                               ; by three
  8638  4d39 a8                                  tay                                      ; set up for later
  8639                          
  8640  4d3a 68                 qprec            pla                                      ; get previous precedence
  8641  4d3b d94c29                              cmp optab,y                              ; is old precedence greater or equal?
  8642  4d3e b07c                                bcs qchnum                               ; yes, go operate
  8643  4d40 20db4c                              jsr chknum                               ; can't be string here
  8644                          
  8645  4d43 48                 doprec           pha                                      ; save old precedence
  8646                          
  8647  4d44 20644d             negprc           jsr dopre1                               ; save a return for op
  8648  4d47 68                                  pla                                      ; pull off previous precedence
  8649  4d48 a44d                                ldy opptr                                ; get pointer to op
  8650  4d4a 1011                                bpl qprec1                               ; that's a real operator
  8651  4d4c aa                                  tax                                      ; done?
  8652  4d4d f06b                                beq qopgo                                ; done!
  8653  4d4f 8074                                bra pulstk
  8654                          
  8655                          
  8656  4d51 460f               finrel           lsr valtyp                               ; get value type into (c)
  8657  4d53 8a                                  txa
  8658  4d54 2a                                  rol                                      ; put VALTYP into low order bit of mask
  8659  4d55 c33d                                dew txtptr                               ; decrement text pointer
  8660  4d57 a01b                                ldy #ptdorl-optab                        ; make (y) point at operator entry
  8661  4d59 854f                                sta opmask                               ; save the operation mask
  8662  4d5b 80dd                                bra qprec                                ; branch always
  8663                          
  8664                          
  8665                          qprec1                                                    ; note b7(VALTYP)=0 so CHKNUM call is ok
  8666  4d5d d94c29                              cmp optab,y                              ; last precedence is greater?
  8667  4d60 b063                                bcs pulstk                               ; yes, go operate
  8668  4d62 90df                                bcc doprec                               ; no, save argument and get other operand
  8669                          
  8670                          
  8671  4d64 b94e29             dopre1           lda optab+2,y
  8672  4d67 48                                  pha                                      ; disp addr goes on stack
  8673  4d68 b94d29                              lda optab+1,y
  8674  4d6b 48                                  pha
  8675  4d6c 20734d                              jsr pushf1                               ; save FAC on stack unpacked, precedence in (x)
  8676  4d6f a54f                                lda opmask                               ; (a) may be mask for rel
  8677  4d71 8081                                bra lpoper
  8678                          
  8679                          
  8680                          pushf1                                                    ; save FAC on stack unpacked
  8681  4d73 68                                  pla                                      ; first grab return address off stack
  8682  4d74 8524                                sta index1
  8683  4d76 68                                  pla
  8684  4d77 8525                                sta index1+1
  8685  4d79 e324                                inw index1
  8686                          
  8687  4d7b be4c29                              ldx optab,y                              ; precedence
  8688  4d7e a468                                ldy facsgn
  8689  4d80 5a                                  phy
  8690  4d81 20b262                              jsr round                                ; put rounded FAC on stack
  8691  4d84 a567                                lda faclo
  8692  4d86 48                                  pha
  8693  4d87 a566                                lda facmo
  8694  4d89 48                                  pha
  8695  4d8a a565                                lda facmoh
  8696  4d8c 48                                  pha
  8697  4d8d a564                                lda facho
  8698  4d8f 48                                  pha
  8699  4d90 a563                                lda facexp
  8700  4d92 48                                  pha
  8701  4d93 6c2400                              jmp (index1)                             ; return
  8702                          
  8703                          
  8704                          pullf1                                                    ; retrieve FAC from stack unpacked  [910402]
  8705  4d96 68                                  pla                                      ; first grab return address off stack
  8706  4d97 8524                                sta index1
  8707  4d99 68                                  pla
  8708  4d9a 8525                                sta index1+1
  8709  4d9c e324                                inw index1
  8710                          
  8711  4d9e a900                                lda #0                                   ; it's been rounded
  8712  4da0 8571                                sta facov
  8713  4da2 68                                  pla
  8714  4da3 8563                                sta facexp
  8715  4da5 68                                  pla
  8716  4da6 8564                                sta facho
  8717  4da8 68                                  pla
  8718  4da9 8565                                sta facmoh
  8719  4dab 68                                  pla
  8720  4dac 8566                                sta facmo
  8721  4dae 68                                  pla
  8722  4daf 8567                                sta faclo
  8723  4db1 68                                  pla
  8724  4db2 8568                                sta facsgn
  8725  4db4 6c2400                              jmp (index1)                             ; return
  8726                          
  8727                          
  8728  4db7 a0ff               qop              ldy #255
  8729  4db9 68                                  pla                                      ; get high precedence of last op
  8730  4dba f023               qopgo            beq qoprts                               ; done!
  8731                          
  8732  4dbc c964               qchnum           cmp #100                                 ; relational operator?
  8733  4dbe f003                                beq unpstk                               ; yes, don't check operand
  8734  4dc0 20db4c                              jsr chknum                               ; must be number
  8735                          
  8736  4dc3 844d               unpstk           sty opptr                                ; save operator's pointer for next time
  8737  4dc5 68                 pulstk           pla                                      ; get mask for rel op if it is one
  8738  4dc6 4a                                  lsr                                      ; setup .c for dorel's chkval
  8739  4dc7 8514                                sta domask                               ; save for "docmp"
  8740  4dc9 68                                  pla                                      ; unpack stack into arg
  8741  4dca 856a                                sta argexp
  8742  4dcc 68                                  pla
  8743  4dcd 856b                                sta argho
  8744  4dcf 68                                  pla
  8745  4dd0 856c                                sta argmoh
  8746  4dd2 68                                  pla
  8747  4dd3 856d                                sta argmo
  8748  4dd5 68                                  pla
  8749  4dd6 856e                                sta arglo
  8750  4dd8 68                                  pla
  8751  4dd9 856f                                sta argsgn
  8752  4ddb 4568                                eor facsgn                               ; get probable result sign
  8753  4ddd 8570                                sta arisgn                               ; sign used by add, sub, mul, div
  8754                          
  8755  4ddf a563               qoprts           lda facexp                               ; get it and set codes
  8756  4de1 60                                  rts                                      ; return
  8757                          
  8758  4de2 6c0a03             eval             jmp (ieval)
  8759                          
  8760  4de5 a900               neval            lda #0                                   ; assume numeric
  8761  4de7 850f                                sta valtyp
  8762                          
  8763  4de9 208322             eval0            jsr chrget                               ; get a character
  8764  4dec b005                                bcs eval2
  8765  4dee a200               eval1            ldx #0                                   ; flag 'bank 0' (text bank)
  8766  4df0 839b15                              +lbra fin                                ; it is a number
  8767                          
  8768  4df3 200250             eval2            jsr isletc                               ; variable name?
  8769  4df6 b07b                                bcs is_variable                          ; yes.
  8770  4df8 c9ff                                cmp #pi                                  ; pi?
  8771  4dfa d00a                                bne qdot
  8772  4dfc a91e                                lda #<pival
  8773  4dfe a05f                                ldy #>pival
  8774  4e00 200e62                              jsr movfm                                ; put value in for p1.
  8775  4e03 4c8322                              jmp chrget
  8776                          
  8777                          
  8778  4e06 c92e               qdot             cmp #'.'                                 ; constant?
  8779  4e08 f0e4                                beq eval1
  8780  4e0a c9ab                                cmp #minus_token                         ; negation?
  8781  4e0c f05e                                beq domin                                ; yes.
  8782  4e0e c9aa                                cmp #plus_token
  8783  4e10 f0d7                                beq eval0
  8784  4e12 c922                                cmp #'"'                                 ; string?
  8785  4e14 d015                                bne eval3
  8786                          
  8787  4e16 a53d               strtxt           lda txtptr
  8788  4e18 a43e                                ldy txtptr+1
  8789  4e1a 6900                                adc #0                                   ; c=1
  8790  4e1c 9001                                bcc strtx2
  8791  4e1e c8                                  iny
  8792  4e1f 20855a             strtx2           jsr strlit                               ; process string
  8793                          
  8794  4e22 a672               st2txt           ldx strng2
  8795  4e24 a473                                ldy strng2+1
  8796  4e26 863d                                stx txtptr
  8797  4e28 843e                                sty txtptr+1
  8798  4e2a 60                                  rts
  8799                          
  8800                          
  8801  4e2b c9a8               eval3            cmp #not_token                           ; not?
  8802  4e2d d016                                bne eval4
  8803  4e2f a018                                ldy #24
  8804  4e31 d03b                                bne gonprc                               ; branch always
  8805                          
  8806                          
  8807  4e33 20b458             notop            jsr ayint                                ; integerize
  8808  4e36 a567                                lda faclo                                ; get argument
  8809  4e38 49ff                                eor #$ff
  8810  4e3a a8                                  tay
  8811  4e3b a566                                lda facmo
  8812  4e3d 49ff                                eor #$ff
  8813                          
  8814  4e3f 20d758             givayf           jsr stoint                               ; integer to float routine
  8815  4e42 839614                              +lbra floats
  8816                          
  8817                          
  8818  4e45 c9a5               eval4            cmp #fn_token                            ; user defined function?
  8819  4e47 f3ec0a                              +lbeq fndoer                             ; yes
  8820  4e4a c9b4                                cmp #first_function_token                ; function name?
  8821  4e4c b3bfde                              +lbcs isfun                              ; yes
  8822                          ; (functions are the highest numbered
  8823                          ; tokens so no need to check further)
  8824                          
  8825  4e4f 20584e             parchk           jsr chkopn                               ; only thing left is formula in parens
  8826  4e52 20ef4c                              jsr frmevl                               ; a formula in parens
  8827                          
  8828  4e55 a929               chkcls           lda #')'                                 ; close paren?
  8829  4e57 2c                                  !text $2c
  8830                          
  8831  4e58 a928               chkopn           lda #'('                                 ; open paren?
  8832  4e5a 2c                                  !text $2c
  8833                          
  8834  4e5b a92c               chkcom           lda #','                                 ; comma?
  8835                          
  8836                          
  8837                          ; SYNCHR looks at the current character to make sure it is the specific
  8838                          ; thing loaded into (a) just before the call to SYNCHR.  If not, it calls
  8839                          ; the "syntax error" routine.  Otherwise it gobbles the next char and returns.
  8840                          ;
  8841                          ; (a)=new char and TXTPTR is advanced by CHRGET.
  8842                          
  8843                          
  8844  4e5d a000               synchr           ldy #0
  8845  4e5f 8578                                sta syntmp
  8846  4e61 20c522                              jsr indtxt
  8847  4e64 c578                                cmp syntmp
  8848  4e66 d3e2df                              +lbne snerr
  8849  4e69 4c8322                              jmp chrget                               ; ok
  8850                          
  8851                          
  8852                          
  8853                          domin
  8854                          l117_1           =negtab-optab                            ; negoff
  8855  4e6c a015                                ldy #l117_1                              ; precedence below '-'
  8856                          
  8857  4e6e 68                 gonprc           pla                                      ; get rid of rts addr.
  8858  4e6f 68                                  pla
  8859  4e70 83d2fe                              +lbra negprc                             ; do negation
  8860                          
  8861                          ;.end
  8862                          
  8863                          
  8864                          
  8865                          is_variable
  8866  4e73 207c4f                              jsr ptrget                               ; parse variable name, put name in varnam
  8867                          
  8868  4e76 8566               isvret           sta facmo                                ; save pointer to variable
  8869  4e78 8467                                sty facmo+1
  8870  4e7a a647                                ldx varnam
  8871  4e7c a448                                ldy varnam+1
  8872  4e7e a50f                                lda valtyp
  8873  4e80 f050                                beq is_numeric                           ; branch if numeric
  8874                          
  8875  4e82 a900                                lda #0
  8876  4e84 8571                                sta facov
  8877  4e86 e054                                cpx #'T'                                 ; TI$ is a special case. look for it
  8878  4e88 d013                                bne isvds                                ; no- go test for DS$
  8879  4e8a c0c9                                cpy #'I'+$80                             ; shifted I?
  8880  4e8c d043                                bne ds_rts                               ; no- and it's not DS$ either
  8881                          
  8882                          ; Variable name is TI$.  To see if this is 'the' TI$ and not an
  8883                          ; array TI$(), test to see if it has a pointer to the zero in "ROM".
  8884                          ; If it is an array item, its pointer will be to a real value, or
  8885                          ; a real zero.  If it isn't an array item, its pointer will point
  8886                          ; to a dummy zero in "ROM".
  8887                          
  8888  4e8e a567                                lda facmo+1
  8889  4e90 c902                                cmp #>zero
  8890  4e92 d03d                                bne ds_rts                               ; not TI$, not DS$
  8891  4e94 a566                                lda facmo
  8892  4e96 c9c4                                cmp #<zero
  8893  4e98 d037                                bne ds_rts
  8894  4e9a 835905                              +lbra Get_TI_String                      ; the one and only TI$
  8895                          
  8896                          
  8897  4e9d e044               isvds            cpx #'D'                                 ; is this DS$?
  8898  4e9f d030                                bne ds_rts                               ; no
  8899  4ea1 c0d3                                cpy #'S'+$80                             ; shifted S?
  8900  4ea3 d02c                                bne ds_rts                               ; no
  8901                          
  8902  4ea5 200e78                              jsr Check_DS                             ; yes- check DS$ allocation,
  8903                          ;  and get it if not in memory
  8904  4ea8 a0ff                                ldy #$ff
  8905  4eaa c8                 l118_1           iny                                      ; copy DS$ to a temp.
  8906  4eab a97a                                lda #dsdesc+1                            ; must first determine how big it is
  8907  4ead 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
  8908  4eb0 d0f8                                bne l118_1                               ; loop until terminating null found
  8909                          
  8910  4eb2 98                                  tya                                      ; length of string required
  8911  4eb3 20735a                              jsr strini                               ; get temp. string space & descriptor
  8912  4eb6 a8                                  tay
  8913  4eb7 f015                                beq l118_3                               ; (don't bother copying if length is 0)
  8914                          
  8915  4eb9 da                                  phx
  8916                          
  8917  4eba a264                                ldx #dsctmp+1                            ; ???? was ldx #frespc
  8918  4ebc a97a               l118_2           lda #dsdesc+1                            ; copy DS$ into temp
  8919  4ebe 88                                  dey
  8920  4ebf 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
  8921  4ec2 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
  8922  4ec5 98                                  tya
  8923  4ec6 d0f4                                bne l118_2
  8924  4ec8 fa                                  plx
  8925  4ec9 a579                                lda dsdesc                               ; a=length     [901014] FAB
  8926  4ecb 205d5b                              jsr mvdone                               ; ???? (does nothing on C128 - bug or oversight?)
  8927                          
  8928  4ece 83000c             l118_3           +lbra putnew
  8929                          
  8930  4ed1 60                 ds_rts           rts
  8931                          
  8932                          
  8933                          is_numeric
  8934  4ed2 7f100f                              bbr7 intflg,is_floating                  ; branch if not an integer
  8935  4ed5 a000                                ldy #0
  8936  4ed7 20a922                              jsr indfmo                               ; fetch high
  8937  4eda aa                                  tax
  8938  4edb c8                                  iny
  8939  4edc 20a922                              jsr indfmo                               ; fetch low
  8940  4edf a8                                  tay                                      ; put low in y
  8941  4ee0 8a                                  txa                                      ; get high in a
  8942  4ee1 835cff                              +lbra givayf                             ; float and return
  8943                          
  8944                          
  8945                          ; Screen out TI, ST, ER, and EL, and assign values to them.  First test
  8946                          ; if the pointer points to "ROM" zero.  If not, it can't be any of the above.
  8947                          
  8948                          is_floating
  8949  4ee4 a567                                lda facmo+1
  8950  4ee6 c902                                cmp #>zero
  8951  4ee8 d064                                bne gomovf                               ; not TI, etc.
  8952  4eea a566                                lda facmo
  8953  4eec c9c4                                cmp #<zero
  8954  4eee d05e                                bne gomovf                               ; not TI, etc.
  8955                          
  8956                          
  8957                          ; The pointer does point to the ROM zero.  Now it is necessary to
  8958                          ; examine the actual variable name case by case.
  8959                          
  8960  4ef0 e054                                cpx #'T'                                 ; TI?
  8961  4ef2 d007                                bne qstatv                               ; no
  8962  4ef4 c049                                cpy #'I'
  8963  4ef6 d056                                bne gomovf                               ; no, and it can't be ST either
  8964  4ef8 f34805                              +lbeq Get_TI
  8965                          
  8966                          
  8967  4efb e053               qstatv           cpx #'S'                                 ; ST?
  8968  4efd d00a                                bne qdsav                                ; no, go test DS
  8969  4eff c054                                cpy #'T'
  8970  4f01 d04b                                bne gomovf
  8971  4f03 20b7ff                              jsr _readst                              ; (???? system bank for rs232 st)
  8972  4f06 83ca13                              +lbra float
  8973                          
  8974                          
  8975  4f09 e044               qdsav            cpx #'D'                                 ; DS?
  8976  4f0b d026                                bne qerlin                               ; no, go test ER & EL
  8977  4f0d c053                                cpy #'S'
  8978  4f0f d03d                                bne gomovf
  8979                          
  8980                          ; Get disk status - make the first two characters of DS$ string into a number.
  8981                          
  8982  4f11 200e78                              jsr Check_DS                             ; get a DS$ string if one doesn't exist already
  8983  4f14 a000                                ldy #0
  8984  4f16 a97a                                lda #dsdesc+1
  8985  4f18 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
  8986  4f1b 290f                                and #$0f
  8987  4f1d 0a                                  asl
  8988  4f1e 8511                                sta garbfl
  8989  4f20 0a                                  asl
  8990  4f21 0a                                  asl
  8991  4f22 6511                                adc garbfl
  8992  4f24 8511                                sta garbfl
  8993  4f26 c8                                  iny
  8994  4f27 a97a                                lda #dsdesc+1
  8995  4f29 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
  8996  4f2c 290f                                and #$0f
  8997  4f2e 6511                                adc garbfl
  8998  4f30 83a013                              +lbra float
  8999                          
  9000                          
  9001  4f33 e045               qerlin           cpx #'E'                                 ; ER or EL?
  9002  4f35 d017                                bne gomovf
  9003  4f37 c052                                cpy #'R'
  9004  4f39 f00d                                beq qnumer
  9005  4f3b c04c                                cpy #'L'
  9006  4f3d d00f                                bne gomovf
  9007                          
  9008  4f3f adc902                              lda errlin+1                             ; want EL (last error line #)
  9009  4f42 acc802                              ldy errlin
  9010  4f45 838009                              +lbra nosflt
  9011                          
  9012  4f48 adc702             qnumer           lda errnum                               ; want ER (number of last error)
  9013  4f4b 838513                              +lbra float
  9014                          
  9015                          
  9016  4f4e a566               gomovf           lda facmo
  9017  4f50 a467                                ldy facmo+1
  9018                          
  9019  4f52 8524               movfrm           sta index1                               ; move value from RAM
  9020  4f54 8425                                sty index1+1
  9021                          
  9022  4f56 a000                                ldy #0
  9023  4f58 20d522                              jsr indin1_ram1
  9024  4f5b 8563                                sta facexp
  9025  4f5d 8471                                sty facov
  9026                          
  9027  4f5f c8                                  iny                                      ; (1)
  9028  4f60 20d522                              jsr indin1_ram1
  9029  4f63 8568                                sta facsgn
  9030  4f65 0980                                ora #$80
  9031  4f67 8564                                sta facho
  9032                          
  9033  4f69 c8                                  iny                                      ; (2)
  9034  4f6a 20d522                              jsr indin1_ram1
  9035  4f6d 8565                                sta facmoh
  9036                          
  9037  4f6f c8                                  iny                                      ; (3)
  9038  4f70 20d522                              jsr indin1_ram1
  9039  4f73 8566                                sta facmo
  9040                          
  9041  4f75 c8                                  iny                                      ; (4)
  9042  4f76 20d522                              jsr indin1_ram1
  9043  4f79 8567                                sta faclo
  9044  4f7b 60                                  rts
  9045                          
  9046                          ;.end
  9047                          
  9048                          
  9049                          
  9050                          ;  Read the variable name at the current text position and put a pointer
  9051                          ;  to its value in VARPNT.   TXTPTR points to the terminating character.
  9052                          ;  Note that evaluating subscripts in a variable name can cause recursive
  9053                          ;  calls to PTRGET, so all values must be stored on the stack.
  9054                          
  9055  4f7c a200               ptrget           ldx #0
  9056  4f7e 208522                              jsr chrgot
  9057  4f81 860e               ptrgt1           stx dimflg                               ; store flag away
  9058  4f83 8547               ptrgt2           sta varnam
  9059  4f85 208522                              jsr chrgot                               ; get current character
  9060  4f88 200250                              jsr isletc                               ; check for a letter
  9061  4f8b 93bdde                              +lbcc snerr                              ; not a letter
  9062                          
  9063  4f8e a200                                ldx #0                                   ; assume no second character
  9064  4f90 860f                                stx valtyp                               ; default is numeric
  9065  4f92 8610                                stx intflg                               ; assume floating
  9066  4f94 208322                              jsr chrget                               ; get following character
  9067  4f97 9005                                bcc l119_1                               ; branch if numeric
  9068  4f99 200250                              jsr isletc                               ; is it alpha?
  9069  4f9c 900b                                bcc l119_3                               ; no, no second character. branch
  9070  4f9e aa                 l119_1           tax                                      ; issec. save second character of name
  9071                          
  9072  4f9f 208322             l119_2           jsr chrget                               ; skip over remainder of name. we only care about 2 chars.
  9073  4fa2 90fb                                bcc l119_2                               ; ..eat numbers,
  9074  4fa4 200250                              jsr isletc
  9075  4fa7 b0f6                                bcs l119_2                               ; ..and alphas, too!
  9076                          
  9077  4fa9 c924               l119_3           cmp #'$'                                 ; nosec. is this a string?
  9078  4fab d006                                bne l119_4                               ; if not, VALTYP = 0
  9079  4fad a9ff                                lda #$ff
  9080  4faf 850f                                sta valtyp                               ; ..else, flag 'string'
  9081  4fb1 800f                                bra l119_5
  9082                          
  9083  4fb3 c925               l119_4           cmp #'%'                                 ; notstr. isn't string. is it integer?
  9084  4fb5 d012                                bne l119_6                               ; branch if not
  9085  4fb7 a512                                lda subflg
  9086                          ; bne snerr ; syntax error if integers disabled
  9087  4fb9 d32cfd                              +lbne chkerr                             ; integers disallowed- type mismatch error  [910114]
  9088  4fbc a980                                lda #$80                                 ; flag integer by turning on both high bits
  9089  4fbe 8510                                sta intflg
  9090  4fc0 0447                                tsb varnam
  9091                          
  9092  4fc2 8a                 l119_5           txa                                      ; turnon. turn on msb of second character
  9093  4fc3 0980                                ora #$80
  9094  4fc5 aa                                  tax
  9095  4fc6 208322                              jsr chrget                               ; get character after $ or %
  9096                          
  9097  4fc9 8648               l119_6           stx varnam+1                             ; strnam. store away second character
  9098  4fcb 38                                  sec
  9099  4fcc 0512                                ora subflg                               ; add flag whether to allow arrays
  9100  4fce e928                                sbc #'('
  9101  4fd0 f3b101                              +lbeq is_array                           ; note: won't match if SUBFLG set
  9102                          
  9103  4fd3 a000                                ldy #0
  9104  4fd5 8412                                sty subflg                               ; allow subscripts again
  9105  4fd7 a52f                                lda vartab                               ; place to start search
  9106  4fd9 a630                                ldx vartab+1
  9107                          
  9108  4fdb 8662               l119_7           stx lowtr+1                              ; stxfnd.
  9109  4fdd 8561               l119_8           sta lowtr
  9110  4fdf e432                                cpx arytab+1                             ; at end of table yet?
  9111  4fe1 d004                                bne l119_9
  9112  4fe3 c531                                cmp arytab
  9113  4fe5 f025                                beq notfns                               ; yes, we couldn't find it
  9114                          
  9115  4fe7 20bd22             l119_9           jsr indlow_ram1                          ; lda (lowtr),y
  9116  4fea c547                                cmp varnam                               ; compare high orders
  9117  4fec d00a                                bne l119_10
  9118  4fee c8                                  iny
  9119  4fef 20bd22                              jsr indlow_ram1
  9120  4ff2 c548                                cmp varnam+1                             ; and the low part?
  9121  4ff4 f32f01                              +lbeq finptr                             ; !!that's it!!
  9122                          
  9123  4ff7 88                                  dey
  9124  4ff8 18                 l119_10          clc
  9125  4ff9 a561                                lda lowtr
  9126  4ffb 6907                                adc #7                                   ; makes no difference among types
  9127  4ffd 90de                                bcc l119_8
  9128  4fff e8                                  inx
  9129  5000 80d9                                bra l119_7                               ; branch always
  9130                          
  9131                          
  9132                          
  9133                          
  9134                          ; Test for a letter: (c)=0 not a letter
  9135                          ;   (c)=1 a letter
  9136                          
  9137  5002 c941               isletc           cmp #'A'
  9138  5004 9005                                bcc l120_1                               ; if less than "a", return
  9139  5006 e95b                                sbc #'Z'+1                               ; $5a + 1
  9140  5008 38                                  sec
  9141  5009 e9a5                                sbc #$a5                                 ; reset carry if (a) .gt. "z".
  9142  500b 60                 l120_1           rts
  9143                          
  9144                          
  9145  500c ba                 notfns           tsx                                      ; check who's calling????
  9146  500d bd0201                              lda $102,x                               ; sniff processor stack
  9147  5010 c957                                cmp #>pointer_ret
  9148  5012 f004                                beq ldzr                                 ; special case if called by pointer function
  9149                          
  9150                          l121_1           = isvret-1
  9151  5014 c94e                                cmp #>l121_1                             ; is eval calling????
  9152  5016 d02a                                bne notevl                               ; no, carry on
  9153                          
  9154  5018 a9c4               ldzr             lda #<zero                               ; set up pointer to simulated zero
  9155  501a a002                                ldy #>zero
  9156  501c 60                                  rts                                      ; for strings or numeric
  9157                          
  9158                          
  9159  501d c0c9               qst001           cpy #'I'+$80                             ; we know first is T, is second <shift>I (TI$)?
  9160  501f f0f7                                beq ldzr
  9161  5021 c049                                cpy #'I'                                 ; or I (TI)?
  9162  5023 d031                                bne varok
  9163  5025 f018                                beq gobadv
  9164                          
  9165                          
  9166  5027 c0d3               qst004           cpy #'S'+$80                             ; check for DS$
  9167  5029 f014                                beq gobadv
  9168  502b c053                                cpy #'S'                                 ; check for DS
  9169  502d d027                                bne varok
  9170  502f f00e                                beq gobadv
  9171                          
  9172                          
  9173  5031 c054               qst002           cpy #'T'                                 ; check for ST
  9174  5033 d021                                bne varok
  9175  5035 f008                                beq gobadv
  9176                          
  9177                          
  9178  5037 c052               qst003           cpy #'R'                                 ; check for ER
  9179  5039 f004                                beq gobadv
  9180  503b c04c                                cpy #'L'                                 ; check for EL
  9181  503d d017                                bne varok
  9182                          
  9183                          
  9184  503f 8309de             gobadv           +lbra snerr
  9185                          
  9186                          
  9187                          
  9188  5042 a547               notevl           lda varnam
  9189  5044 a448                                ldy varnam+1
  9190  5046 c954                                cmp #'T'                                 ; screen out TI
  9191  5048 f0d3                                beq qst001
  9192  504a c953                                cmp #'S'                                 ; ...and ST
  9193  504c f0e3                                beq qst002
  9194  504e c945                                cmp #'E'                                 ; ...and ER and EL
  9195  5050 f0e5                                beq qst003
  9196  5052 c944                                cmp #'D'                                 ; ...and DS
  9197  5054 f0d1                                beq qst004
  9198                          
  9199                          
  9200  5056 a531               varok            lda arytab
  9201  5058 a432                                ldy arytab+1
  9202  505a 8561                                sta lowtr
  9203  505c 8462                                sty lowtr+1
  9204  505e a533                                lda strend
  9205  5060 a434                                ldy strend+1
  9206  5062 855c                                sta hightr
  9207  5064 845d                                sty hightr+1
  9208  5066 18                                  clc
  9209  5067 6907                                adc #7
  9210  5069 9001                                bcc l122_1                               ; not even
  9211  506b c8                                  iny
  9212                          
  9213  506c 855a               l122_1           sta highds
  9214  506e 845b                                sty highds+1
  9215  5070 203451                              jsr bltu
  9216  5073 a55a                                lda highds
  9217  5075 a45b                                ldy highds+1
  9218  5077 c8                                  iny
  9219  5078 8531                                sta arytab
  9220  507a 8432                                sty arytab+1
  9221                          
  9222                          
  9223                          ; Scan thru array entries for string arrays.  If any are found it will be
  9224                          ; necessary to adjust the back-links of the strings in that array, since
  9225                          ; the array descriptor block itself was moved.
  9226                          
  9227  507c 855a                                sta arypnt                               ; set pointer to arrays
  9228  507e 845b                                sty arypnt+1
  9229                          
  9230  5080 a55a               aryva2           lda arypnt
  9231  5082 a65b                                ldx arypnt+1
  9232                          
  9233  5084 e434               aryva3           cpx strend+1                             ; end of arrays?
  9234  5086 d004                                bne aryvgo
  9235  5088 c533                                cmp strend
  9236  508a f07e                                beq arydon                               ; ...finished
  9237                          
  9238                          
  9239  508c 8524               aryvgo           sta index1
  9240  508e 8625                                stx index1+1
  9241  5090 a000                                ldy #0
  9242  5092 20d522                              jsr indin1_ram1                          ; look at array name
  9243  5095 aa                                  tax
  9244  5096 c8                                  iny
  9245  5097 20d522                              jsr indin1_ram1                          ; name 2nd char
  9246  509a 08                                  php                                      ; save status reg
  9247  509b c8                                  iny
  9248  509c 20d522                              jsr indin1_ram1                          ; point to offset to next array
  9249  509f 655a                                adc arypnt
  9250  50a1 855a                                sta arypnt                               ; save start of next array in arypnt
  9251  50a3 c8                                  iny
  9252  50a4 20d522                              jsr indin1_ram1
  9253  50a7 655b                                adc arypnt+1
  9254  50a9 855b                                sta arypnt+1
  9255  50ab 28                                  plp                                      ; restore status
  9256  50ac 10d2                                bpl aryva2                               ; not a string type
  9257  50ae 8a                                  txa
  9258  50af 30cf                                bmi aryva2                               ; not a string array
  9259  50b1 c8                                  iny                                      ; ok we have a string array
  9260  50b2 20d522                              jsr indin1_ram1                          ; get number of dimensions
  9261  50b5 a000                                ldy #0
  9262  50b7 0a                                  asl                                      ; move index to ptr to 1st string (add 2*number of dims + 5)
  9263  50b8 6905                                adc #5
  9264  50ba 6524                                adc index1
  9265  50bc 8524                                sta index1
  9266  50be 9002                                bcc aryget
  9267  50c0 e625                                inc index1+1
  9268                          
  9269  50c2 a625               aryget           ldx index1+1
  9270  50c4 e45b                                cpx arypnt+1                             ; done with this array?
  9271  50c6 d004                                bne l123_1
  9272  50c8 c55a                                cmp arypnt
  9273  50ca f0b8                                beq aryva3                               ; yes
  9274                          
  9275  50cc a000               l123_1           ldy #0                                   ; process string pointer
  9276  50ce 20d522                              jsr indin1_ram1                          ; get length of string
  9277  50d1 f02a                                beq dvarts                               ; skip if null string
  9278  50d3 8578                                sta syntmp
  9279  50d5 c8                                  iny
  9280  50d6 20d522                              jsr indin1_ram1                          ; get lo byte of string ptr
  9281  50d9 18                                  clc
  9282  50da 6578                                adc syntmp                               ; and add string length
  9283  50dc 855c                                sta hightr
  9284  50de c8                                  iny
  9285  50df 20d522                              jsr indin1_ram1                          ; get hi byte of string ptr
  9286  50e2 6900                                adc #0                                   ; adjust high byte
  9287  50e4 855d                                sta hightr+1
  9288                          
  9289                          ; Fix backwards pointer by adding move length to it.
  9290                          
  9291  50e6 da                                  phx
  9292  50e7 a25c                                ldx #hightr
  9293  50e9 a000                                ldy #0
  9294  50eb 20a522                              jsr indhtr_ram1                          ; lda (hightr),y
  9295  50ee 6907                                adc #7                                   ; carry clear (careful!)
  9296  50f0 20f022                              jsr sta_far_ram1                         ; sta (hightr),y
  9297  50f3 c8                                  iny
  9298  50f4 20a522                              jsr indhtr_ram1                          ; lda (hightr),y
  9299  50f7 6900                                adc #0
  9300  50f9 20f022                              jsr sta_far_ram1                         ; sta (hightr),y
  9301  50fc fa                                  plx                                      ; done with this string
  9302                          
  9303                          ; Fix the next string in the array
  9304                          
  9305  50fd a903               dvarts           lda #strsiz
  9306  50ff 18                                  clc
  9307  5100 6524                                adc index1
  9308  5102 8524                                sta index1
  9309  5104 90bc                                bcc aryget
  9310  5106 e625                                inc index1+1
  9311  5108 80b8                                bra aryget                               ; branch always
  9312                          
  9313                          
  9314  510a da                 arydon           phx
  9315  510b a261                                ldx #lowtr
  9316  510d a000                                ldy #0
  9317  510f a547                                lda varnam
  9318  5111 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9319  5114 c8                                  iny                                      ; .y=1
  9320  5115 a548                                lda varnam+1
  9321  5117 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9322  511a a900                                lda #0
  9323  511c c8                 l124_1           iny
  9324  511d 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9325  5120 c006                                cpy #6
  9326  5122 d0f8                                bne l124_1
  9327  5124 fa                                  plx
  9328                          
  9329  5125 a561               finptr           lda lowtr
  9330  5127 18                                  clc
  9331  5128 6902                                adc #2
  9332  512a a462                                ldy lowtr+1
  9333  512c 9001                                bcc l125_1
  9334  512e c8                                  iny
  9335  512f 8549               l125_1           sta varpnt
  9336  5131 844a                                sty varpnt+1
  9337  5133 60                                  rts
  9338                          
  9339                          
  9340                          
  9341                          
  9342  5134 20af31             bltu             jsr reason
  9343  5137 8533                                sta strend
  9344  5139 8434                                sty strend+1
  9345  513b 38                                  sec
  9346  513c a55c                                lda hightr
  9347  513e e561                                sbc lowtr
  9348  5140 8524                                sta index
  9349  5142 a8                                  tay
  9350  5143 a55d                                lda hightr+1
  9351  5145 e562                                sbc lowtr+1
  9352  5147 aa                                  tax
  9353  5148 e8                                  inx
  9354  5149 98                                  tya
  9355  514a f02f                                beq decblt
  9356  514c a55c                                lda hightr
  9357  514e 38                                  sec
  9358  514f e524                                sbc index
  9359  5151 855c                                sta hightr
  9360  5153 b003                                bcs l126_1
  9361  5155 c65d                                dec hightr+1
  9362  5157 38                                  sec
  9363  5158 a55a               l126_1           lda highds
  9364  515a e524                                sbc index
  9365  515c 855a                                sta highds
  9366  515e b00e                                bcs moren1
  9367  5160 c65b                                dec highds+1
  9368  5162 900a                                bcc moren1
  9369                          
  9370  5164 20a522             bltlp            jsr indhtr_ram1                          ; lda (hightr),y
  9371  5167 da                                  phx
  9372  5168 a25a                                ldx #highds
  9373  516a 20f022                              jsr sta_far_ram1                         ; sta (highds),y
  9374  516d fa                                  plx
  9375                          
  9376  516e 88                 moren1           dey
  9377  516f d0f3                                bne bltlp
  9378  5171 20a522                              jsr indhtr_ram1                          ; lda (hightr),y
  9379  5174 da                                  phx
  9380  5175 a25a                                ldx #highds
  9381  5177 20f022                              jsr sta_far_ram1                         ; sta (highds),y
  9382  517a fa                                  plx
  9383                          
  9384  517b c65d               decblt           dec hightr+1
  9385  517d c65b                                dec highds+1
  9386  517f ca                                  dex
  9387  5180 d0ec                                bne moren1
  9388  5182 60                                  rts
  9389                          
  9390                          ;.end
  9391                          ;[[arrays]]
  9392                          
  9393                          
  9394                          
  9395                          ; The format of arrays in core:
  9396                          ;
  9397                          ; Descriptor: low  byte = first character
  9398                          ;   high byte = second character (msb is string flag)
  9399                          ; Length of array in memory in bytes (includes everything).
  9400                          ; Number of dimensions.
  9401                          ; For each dimension starting with the first a list (2 bytes each)
  9402                          ; of the max indice+1.
  9403                          ; The values.
  9404                          
  9405                          
  9406                          is_array
  9407  5183 a50e                                lda dimflg
  9408  5185 0510                                ora intflg
  9409  5187 48                                  pha                                      ; save DIMFLG for recursion
  9410  5188 a50f                                lda valtyp
  9411  518a 48                                  pha                                      ; save VALTYP for recursion
  9412  518b a000                                ldy #0                                   ; set number of dimensions to zero
  9413                          
  9414  518d 5a                 l127_1           phy                                      ; save number of dims
  9415  518e a548                                lda varnam+1
  9416  5190 48                                  pha
  9417  5191 a547                                lda varnam
  9418  5193 48                                  pha                                      ; save looks
  9419  5194 20a758                              jsr intidx                               ; evaluate indice into facmo&lo
  9420  5197 68                                  pla
  9421  5198 8547                                sta varnam
  9422  519a 68                                  pla
  9423  519b 8548                                sta varnam+1                             ; get back all...we're home
  9424  519d 7a                                  ply                                      ; (# of units)
  9425  519e ba                                  tsx
  9426  519f bd0201                              lda 258,x
  9427  51a2 48                                  pha                                      ; push DIMFLG and VALTYP further
  9428  51a3 bd0101                              lda 257,x
  9429  51a6 48                                  pha
  9430  51a7 a566                                lda indice                               ; put indice onto stack
  9431  51a9 9d0201                              sta 258,x                                ; under DIMFLG and VALTYP
  9432  51ac a567                                lda indice+1
  9433  51ae 9d0101                              sta 257,x
  9434  51b1 c8                                  iny                                      ; y counts # of subscripts
  9435  51b2 840d                                sty count                                ; protect y from chrget
  9436  51b4 208522                              jsr chrgot                               ; get terminating character
  9437  51b7 a40d                                ldy count
  9438  51b9 c92c                                cmp #','                                 ; more subscripts?
  9439  51bb f0d0                                beq l127_1                               ; yes
  9440                          
  9441                          
  9442  51bd 20554e                              jsr chkcls                               ; must be closed paren
  9443  51c0 68                                  pla
  9444  51c1 850f                                sta valtyp                               ; get VALTYP and
  9445  51c3 68                                  pla
  9446  51c4 8510                                sta intflg
  9447  51c6 297f                                and #$7f
  9448  51c8 850e                                sta dimflg                               ; DIMFLG off stack
  9449  51ca a631                                ldx arytab                               ; place to start search
  9450  51cc a532                                lda arytab+1
  9451                          
  9452                          
  9453  51ce 8661               l127_2           stx lowtr
  9454  51d0 8562                                sta lowtr+1
  9455  51d2 c534                                cmp strend+1                             ; end of arrays?
  9456  51d4 d004                                bne l127_3
  9457  51d6 e433                                cpx strend
  9458  51d8 f043                                beq notfdd                               ; a fine thing! no array!
  9459                          
  9460  51da a000               l127_3           ldy #0
  9461  51dc 20bd22                              jsr indlow_ram1                          ; get high of name from array bank (ram1)
  9462  51df c8                                  iny
  9463  51e0 c547                                cmp varnam                               ; compare high orders.
  9464  51e2 d007                                bne l127_4                               ; no way is it this. get the bite outta here
  9465  51e4 20bd22                              jsr indlow_ram1
  9466  51e7 c548                                cmp varnam+1                             ; low orders?
  9467  51e9 f018                                beq gotary                               ; well here it is
  9468                          
  9469  51eb c8                 l127_4           iny
  9470  51ec 20bd22                              jsr indlow_ram1                          ; get length
  9471  51ef 18                                  clc
  9472  51f0 6561                                adc lowtr
  9473  51f2 aa                                  tax
  9474  51f3 c8                                  iny
  9475  51f4 20bd22                              jsr indlow_ram1
  9476  51f7 6562                                adc lowtr+1
  9477  51f9 90d3                                bcc l127_2                               ; always branches
  9478                          
  9479                          
  9480  51fb a212               bserr            ldx #errbs                               ; get bad sub error number
  9481  51fd 2c                                  !text $2c
  9482                          
  9483  51fe a20e               fcerr            ldx #errfc                               ; too big. Illegal Quantity error
  9484  5200 834ddc                              +lbra error
  9485                          
  9486                          
  9487                          
  9488  5203 a213               gotary           ldx #errdd                               ; perhaps a "re-dimension" error
  9489  5205 a50e                                lda dimflg                               ; test the DIMFLG
  9490  5207 d346dc                              +lbne error
  9491  520a 206c53                              jsr fmaptr
  9492  520d a004                                ldy #4
  9493  520f 20bd22                              jsr indlow_ram1
  9494  5212 8578                                sta syntmp
  9495  5214 a50d                                lda count                                ; get number of dims input.
  9496  5216 c578                                cmp syntmp                               ; # of dims the same?
  9497  5218 d0e1                                bne bserr                                ; same so get definition.
  9498  521a 83b300                              +lbra getdef
  9499                          
  9500                          
  9501                          ; Come here when variable is not found in the array table to build an entry.
  9502                          ;
  9503                          ; Put down the descriptor.
  9504                          ; Setup number of dimensions.
  9505                          ; Make sure there is room for the new entry.
  9506                          ; Remember VARPNT.
  9507                          ; Tally=4.
  9508                          ; Skip two locs for later fill in of size.
  9509                          ; LOOP: Get an indice.
  9510                          ;  Put down number+1 and increment VARPTR.
  9511                          ;  Tally=tally*number+1
  9512                          ;  Decrement number of dims.
  9513                          ;  Bne LOOP
  9514                          ; Call REASON with (a,b) reflecting last loc of variable.
  9515                          ; Update STREND
  9516                          ; Zero all.
  9517                          ; Make tally include maxdims and descriptor.
  9518                          ; Put down tally
  9519                          ; If called by dimension, return.
  9520                          ;  Else index into the variable as if it were found on the initial search.
  9521                          
  9522                          notfdd
  9523  521d 206c53                              jsr fmaptr                               ; form ARYPNT
  9524  5220 20af31                              jsr reason
  9525  5223 a000                                ldy #0
  9526  5225 8473                                sty curtol+1
  9527  5227 a205                                ldx #5
  9528  5229 a547                                lda varnam
  9529  522b 08                                  php
  9530  522c da                                  phx
  9531  522d a261                                ldx #lowtr                               ; point to string/array bank
  9532  522f 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9533  5232 fa                                  plx
  9534  5233 28                                  plp
  9535  5234 1001                                bpl l128_1
  9536  5236 ca                                  dex
  9537                          
  9538  5237 c8                 l128_1           iny                                      ; notflt.
  9539  5238 a548                                lda varnam+1
  9540  523a 08                                  php
  9541  523b da                                  phx
  9542  523c a261                                ldx #lowtr                               ; point to string/array bank
  9543  523e 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9544  5241 fa                                  plx
  9545  5242 28                                  plp
  9546  5243 1002                                bpl l128_2
  9547  5245 ca                                  dex
  9548  5246 ca                                  dex
  9549                          
  9550  5247 8672               l128_2           stx curtol
  9551  5249 a50d                                lda count                                ; save number of dimensions
  9552  524b c8                                  iny
  9553  524c c8                                  iny
  9554  524d c8                                  iny
  9555  524e a261                                ldx #lowtr                               ; point to string/array bank
  9556  5250 20f022                              jsr sta_far_ram1                         ; sta (lowtr),y
  9557                          
  9558  5253 a20b               l128_3           ldx #11                                  ; loppta. default size
  9559  5255 a900                                lda #0
  9560  5257 6f0e08                              bbr6 dimflg,l128_4                       ; not in a dim statement
  9561  525a 68                                  pla                                      ; get low order of indice
  9562  525b 18                                  clc
  9563  525c 6901                                adc #1
  9564  525e aa                                  tax
  9565  525f 68                                  pla                                      ; get high order of indice
  9566  5260 6900                                adc #0
  9567                          
  9568  5262 c8                 l128_4           iny                                      ; notdim.
  9569  5263 da                                  phx
  9570  5264 a261                                ldx #lowtr
  9571  5266 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; store high part of indice
  9572  5269 fa                                  plx
  9573  526a c8                                  iny
  9574  526b 8a                                  txa
  9575  526c da                                  phx
  9576  526d a261                                ldx #lowtr
  9577  526f 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; store low part of indice
  9578  5272 fa                                  plx
  9579  5273 203753                              jsr umult                                ; (a,x)+(curtol)*(lowtr,y)
  9580  5276 8672                                stx curtol                               ; save new tally
  9581  5278 8573                                sta curtol+1
  9582  527a a424                                ldy index
  9583  527c c60d                                dec count                                ; any more indices left?
  9584  527e d0d3                                bne l128_3                               ; yes
  9585  5280 655b                                adc arypnt+1
  9586  5282 b3bddb                              +lbcs omerr                              ; overflow
  9587  5285 855b                                sta arypnt+1                             ; compute where to zero
  9588  5287 a8                                  tay
  9589  5288 8a                                  txa
  9590  5289 655a                                adc arypnt
  9591  528b 9004                                bcc l128_5
  9592  528d c8                                  iny
  9593  528e f3b1db                              +lbeq omerr
  9594                          
  9595  5291 20af31             l128_5           jsr reason                               ; grease.  get room
  9596  5294 8533                                sta strend
  9597  5296 8434                                sty strend+1                             ; new end of storage
  9598  5298 a900                                lda #0                                   ; storing (a) is faster than clear
  9599  529a e673                                inc curtol+1
  9600  529c a472                                ldy curtol
  9601  529e f00c                                beq l128_7
  9602                          
  9603  52a0 88                 l128_6           dey                                      ; zero out new entry
  9604  52a1 08                                  php
  9605  52a2 da                                  phx
  9606  52a3 a25a                                ldx #arypnt
  9607  52a5 20f022                              jsr sta_far_ram1                         ; sta (arypnt),y
  9608  52a8 fa                                  plx
  9609  52a9 28                                  plp
  9610  52aa d0f4                                bne l128_6                               ; no. continue
  9611                          
  9612  52ac c65b               l128_7           dec arypnt+1                             ; deccur.
  9613  52ae c673                                dec curtol+1
  9614  52b0 d0ee                                bne l128_6                               ; do another block
  9615  52b2 e65b                                inc arypnt+1                             ; bump back up. will use later
  9616  52b4 38                                  sec
  9617  52b5 a533                                lda strend                               ; restore (a)
  9618  52b7 e561                                sbc lowtr                                ; determine length
  9619  52b9 a002                                ldy #2
  9620  52bb da                                  phx
  9621  52bc a261                                ldx #lowtr
  9622  52be 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; low
  9623  52c1 a534                                lda strend+1
  9624  52c3 c8                                  iny
  9625  52c4 e562                                sbc lowtr+1
  9626  52c6 20f022                              jsr sta_far_ram1 ;sta (lowtr),y          ; high
  9627  52c9 fa                                  plx
  9628  52ca a50e                                lda dimflg                               ; quit here if this is a DIM statement
  9629  52cc d068                                bne dimrts                               ; bye!
  9630  52ce c8                                  iny
  9631                          
  9632                          
  9633                          ; At this point (LOWTR,y) points beyond the size to the number of dimensions.
  9634                          ; Strategy:
  9635                          ;  NUMDIM = number of dimensions
  9636                          ;  curtol = 0
  9637                          ;  INLPNM: Get a new indice
  9638                          ;   Make sure indice is not too big
  9639                          ;   Multiply CURTOL by CURMAX
  9640                          ;   Add indice to CURTOL
  9641                          ;   NUMDIM=NUMDIM-1
  9642                          ;   bne INLPNM
  9643                          ;  Use (CURTOL)*4 as offset
  9644                          
  9645                          
  9646  52cf 20bd22             getdef           jsr indlow_ram1                          ; get # of dim's from string bank
  9647  52d2 850d                                sta count                                ; save a counter
  9648  52d4 a900                                lda #0                                   ; zero (curtol)
  9649  52d6 8572                                sta curtol
  9650                          
  9651  52d8 8573               inlpnm           sta curtol+1
  9652  52da fa                                  plx                                      ; get low indice
  9653  52db 8666                                stx indice
  9654  52dd c8                                  iny
  9655  52de 20bd22                              jsr indlow_ram1
  9656  52e1 8578                                sta syntmp
  9657  52e3 68                                  pla                                      ; and the high part
  9658  52e4 8567                                sta indice+1
  9659  52e6 c578                                cmp syntmp                               ; compare with max indice
  9660  52e8 900f                                bcc inlpn2
  9661  52ea d00a                                bne bserr7                               ; if greater, "bad subscript" error
  9662  52ec c8                                  iny
  9663  52ed 20bd22                              jsr indlow_ram1
  9664  52f0 8578                                sta syntmp
  9665  52f2 e478                                cpx syntmp
  9666  52f4 9004                                bcc inlpn1
  9667                          
  9668  52f6 8303ff             bserr7           +lbra bserr
  9669                          
  9670                          
  9671  52f9 c8                 inlpn2           iny
  9672  52fa a573               inlpn1           lda curtol+1                             ; don't multiply if curtol=0
  9673  52fc 0572                                ora curtol
  9674  52fe 18                                  clc                                      ; prepare to get indice back
  9675  52ff f00a                                beq l129_1                               ; get high part of indice back
  9676  5301 203753                              jsr umult                                ; multiply (curtol) by (5&6,lowtr)
  9677  5304 8a                                  txa
  9678  5305 6566                                adc indice                               ; add in (indice)
  9679  5307 aa                                  tax
  9680  5308 98                                  tya
  9681  5309 a424                                ldy index1
  9682                          
  9683  530b 6567               l129_1           adc indice+1
  9684  530d 8672                                stx curtol
  9685  530f c60d                                dec count                                ; any more?
  9686  5311 d0c5                                bne inlpnm                               ; yes
  9687  5313 8573                                sta curtol+1
  9688  5315 a205                                ldx #5
  9689  5317 a547                                lda varnam
  9690  5319 1001                                bpl l129_2
  9691  531b ca                                  dex
  9692  531c a548               l129_2           lda varnam+1
  9693  531e 1002                                bpl l129_3
  9694  5320 ca                                  dex
  9695  5321 ca                                  dex
  9696  5322 862a               l129_3           stx addend
  9697  5324 a900                                lda #0
  9698  5326 204253                              jsr umultd                               ; on rts, a & y = hi. x = lo.
  9699  5329 8a                                  txa
  9700  532a 655a                                adc arypnt
  9701  532c 8549                                sta varpnt
  9702  532e 98                                  tya
  9703  532f 655b                                adc arypnt+1
  9704  5331 854a                                sta varpnt+1
  9705  5333 a8                                  tay
  9706  5334 a549                                lda varpnt
  9707  5336 60                 dimrts           rts
  9708                          
  9709                          
  9710                          ; Integer arithmetic routines.
  9711                          ;
  9712                          ; Two byte unsigned integer multiply.
  9713                          ; This is for multiply dimensioned arrays.
  9714                          ; (a,b)=(curtol)*(5&6,x).
  9715                          
  9716                          umult
  9717  5337 8424                                sty index
  9718  5339 20bd22                              jsr indlow_ram1
  9719  533c 852a                                sta addend                               ; low, then high
  9720  533e 88                                  dey
  9721  533f 20bd22                              jsr indlow_ram1                          ; put (5&6,lowtr) in faster memory
  9722                          
  9723  5342 852b               umultd           sta addend+1
  9724  5344 a910                                lda #16
  9725  5346 855f                                sta deccnt
  9726  5348 a200                                ldx #0                                   ; clear the accs
  9727  534a a000                                ldy #0                                   ; result initially zero
  9728                          
  9729  534c 8a                 umultc           txa
  9730  534d 0a                                  asl                                      ; multiply by two
  9731  534e aa                                  tax
  9732  534f 98                                  tya
  9733  5350 2a                                  rol
  9734  5351 a8                                  tay
  9735  5352 b3edda                              +lbcs omerr                              ; to much!
  9736  5355 0672                                asl curtol
  9737  5357 2673                                rol curtol+1
  9738  5359 900c                                bcc umlcnt                               ; nothing in this position to multiply
  9739  535b 18                                  clc
  9740  535c 8a                                  txa
  9741  535d 652a                                adc addend
  9742  535f aa                                  tax
  9743  5360 98                                  tya
  9744  5361 652b                                adc addend+1
  9745  5363 a8                                  tay
  9746  5364 b3dbda                              +lbcs omerr                              ; man, just too much!
  9747                          
  9748  5367 c65f               umlcnt           dec deccnt                               ; done?
  9749  5369 d0e1                                bne umultc                               ; keep it up
  9750  536b 60                                  rts                                      ; yes, all done
  9751                          
  9752                          
  9753  536c a50d               fmaptr           lda count
  9754  536e 0a                                  asl
  9755  536f 6905                                adc #5                                   ; point to entries. ((c) cleared by asl)
  9756  5371 6561                                adc lowtr
  9757  5373 a462                                ldy lowtr+1
  9758  5375 9001                                bcc l130_1
  9759  5377 c8                                  iny
  9760  5378 855a               l130_1           sta arypnt
  9761  537a 845b                                sty arypnt+1
  9762  537c 60                                  rts
  9763                          
  9764                          ;.end
  9765                          ;[[command.time]]
  9766                          
  9767                          
  9768                          
  9769                          ; TI$="hh:mm:ss.t" Allows optional colons to delimit parameters and
  9770                          ;   allows input to be abbrieviated (eg., TI$="h:mm" or
  9771                          ;   even TI$=""), defaulting to "00" for unspecified
  9772                          ;   parameters.  24-hour clock (00:00:00.0 to 23:59:59.9).
  9773                          ;   901010 F.Bowen
  9774                          
  9775                          Set_TI_String
  9776  537d 206d5b                              jsr frefac                               ; we won't need it
  9777  5380 850d                                sta count                                ; save length
  9778                          
  9779  5382 a000                                ldy #0                                   ; our pointer into TI$ assignment
  9780  5384 8487                                sty time                                 ; default time to zero, in case it's not fully specified
  9781  5386 8488                                sty time+1
  9782  5388 8489                                sty time+2
  9783  538a 848a                                sty time+3
  9784                          
  9785  538c a203                                ldx #3                                   ; parameter pointer (3=hr,2=min,1=sec,0=tenths)
  9786  538e 20d453             l131_1           jsr GetTimeDigit                         ; get first digit, convert to BCD
  9787  5391 b013                                bcs l131_2                               ; colon or eos
  9788  5393 9587                                sta time,x
  9789  5395 20d453                              jsr GetTimeDigit                         ; get second digit, convert to BCD
  9790  5398 b00c                                bcs l131_2                               ; colon or eos
  9791                          
  9792  539a 1687                                asl time,x                               ; move first digit to msd
  9793  539c 1687                                asl time,x
  9794  539e 1687                                asl time,x
  9795  53a0 1687                                asl time,x
  9796  53a2 1587                                ora time,x                               ; combine with second digit
  9797  53a4 9587                                sta time,x                               ; now we have a time element of packed BCD
  9798                          
  9799  53a6 b587               l131_2           lda time,x
  9800  53a8 ddf153                              cmp MaxTimeValues,x                      ; check for parameter too big
  9801  53ab b351fe                              +lbcs fcerr                              ; hr>23, min>59, sec>59, tenths>9
  9802                          
  9803  53ae ca                                  dex                                      ; check if done
  9804  53af 3012                                bmi l131_4                               ; yes- all parameters accounted for
  9805  53b1 c40d                                cpy count
  9806  53b3 b013                                bcs l131_5                               ; yes- end of string
  9807                          
  9808  53b5 20d522                              jsr indin1_ram1                          ; check for optional colon (or period)   [910103]
  9809  53b8 c93a                                cmp #':'
  9810  53ba f004                                beq l131_3
  9811  53bc c92e                                cmp #'.'
  9812  53be d0ce                                bne l131_1                               ; not there
  9813  53c0 c8                 l131_3           iny                                      ; it's there- skip over it
  9814                          
  9815  53c1 80cb                                bra l131_1                               ; loop until done
  9816                          
  9817                          
  9818  53c3 c40d               l131_4           cpy count                                ; done
  9819  53c5 93a922                              +lbcc errlen                             ; error if string too long
  9820                          
  9821  53c8 ab8700             l131_5           ldz time                                 ; tenths  0-9
  9822  53cb a588                                lda time+1                               ; seconds 0-59
  9823  53cd a689                                ldx time+2                               ; minutes 0-59
  9824  53cf a48a                                ldy time+3                               ; hours  0-23
  9825  53d1 4cdbff                              jmp _SetTime                             ; Go set time & exit
  9826                          
  9827                          
  9828                          ; Get an ASCII digit, make sure it's in range 0-9 or a colon.
  9829                          ; if no digit to get, default to '0'
  9830                          ;
  9831                          ; exit with .c=0 if okay  (.A contains BCD)
  9832                          ;    .c=1 if colon or eos (.A invalid)
  9833                          
  9834                          GetTimeDigit
  9835  53d4 a900                                lda #0                                   ; default to '0'
  9836  53d6 c40d                                cpy count
  9837  53d8 b014                                bcs l132_1                               ; exit if at end of string (carry set)
  9838                          
  9839  53da 20d522                              jsr indin1_ram1                          ; else get a character from string
  9840  53dd c8                                  iny                                      ; point to next character
  9841  53de c92e                                cmp #'.'                                 ; [910103]
  9842  53e0 f00c                                beq l132_1                               ; terminator (period) (carry set)
  9843  53e2 c930                                cmp #'0'                                 ; check character, only 0-9 allowed
  9844  53e4 9318fe                              +lbcc fcerr                              ; too small
  9845  53e7 c93a                                cmp #':'
  9846  53e9 9003                                bcc l132_1                               ; just right  (carry clear)
  9847  53eb d311fe                              +lbne fcerr                              ; too big
  9848                          ; falls through if colon (carry set)
  9849                          
  9850  53ee 290f               l132_1           and #$0f                                 ; make BCD
  9851  53f0 60                                  rts
  9852                          
  9853                          
  9854                          
  9855                          MaxTimeValues
  9856  53f1 10606024                            !text $10,$60,$60,$24                    ; t,s,m,h in packed BCD
  9857                          
  9858                          
  9859                          ; x$=TI$  Return a string of the form "hh:mm:ss.t", including colons.
  9860                          
  9861                          Get_TI_String
  9862  53f5 207054                              jsr ReadSystemClock                      ; get time as packed BCD
  9863                          
  9864  53f8 a90a                                lda #10                                  ; get string space for 10 characters
  9865  53fa 207b5a                              jsr strspa
  9866  53fd a8                                  tay                                      ; length
  9867  53fe 88                                  dey                                      ; index
  9868                          
  9869  53ff a587                                lda time                                 ; build TI$ string in 'fbuffr'
  9870  5401 0930                                ora #'0'                                 ; (build string backwards, from last chr to first)
  9871  5403 a264                                ldx #dsctmp+1
  9872  5405 20f022                              jsr sta_far_ram1                         ; put tenths (special case- only 1 digit)
  9873  5408 88                                  dey
  9874  5409 a92e                                lda #'.'
  9875  540b 20f022                              jsr sta_far_ram1                         ; put period (special case)   [910103]
  9876  540e 88                                  dey
  9877  540f a201                                ldx #1
  9878  5411 800a                                bra l133_2
  9879                          
  9880  5413 da                 l133_1           phx                                      ; element pointer (1=secs, 2=mins, 3=hrs)
  9881  5414 a264                                ldx #dsctmp+1
  9882  5416 a93a                                lda #':'
  9883  5418 20f022                              jsr sta_far_ram1                         ; put colon
  9884  541b 88                                  dey
  9885  541c fa                                  plx
  9886                          
  9887  541d b587               l133_2           lda time,x
  9888  541f 4b                                  taz
  9889  5420 290f                                and #$0f                                 ; do lsd first, since we're working backwards
  9890  5422 0930                                ora #'0'
  9891  5424 da                                  phx
  9892  5425 a264                                ldx #dsctmp+1
  9893  5427 20f022                              jsr sta_far_ram1                         ; put lsd
  9894  542a 88                                  dey
  9895  542b 6b                                  tza                                      ; then do msd
  9896  542c 4a                                  lsr
  9897  542d 4a                                  lsr
  9898  542e 4a                                  lsr
  9899  542f 4a                                  lsr
  9900  5430 0930                                ora #'0'
  9901  5432 20f022                              jsr sta_far_ram1                         ; put msd
  9902  5435 fa                                  plx
  9903  5436 e8                                  inx                                      ; next packed element
  9904  5437 88                                  dey
  9905  5438 10d9                                bpl l133_1                               ; loop until done
  9906                          
  9907  543a a90a                                lda #10                                  ; length
  9908  543c 205d5b                              jsr mvdone                               ; update frespc ????
  9909  543f 838f06                              +lbra putnew                             ; make descriptor in dsctmp real
  9910                          
  9911                          
  9912                          ;[[time]]
  9913                          ; TI. Convert 24-hour TOD into tenths of seconds.  901010 F.Bowen
  9914                          
  9915                          Get_TI
  9916  5442 207054                              jsr ReadSystemClock                      ; glance at the clock, get time as h:m:s:t
  9917  5445 6467                                stz faclo                                ; init accumulator with tenths (0-9, so nothing to convert)
  9918  5447 a300                                ldz #0
  9919  5449 6466                                stz facmo
  9920  544b 6465                                stz facmoh
  9921                          
  9922  544d a203                                ldx #3                                   ; convert time (BCD) to tenths of seconds (binary) since midnight
  9923  544f 207c54             l134_1           jsr TimeMultiply
  9924  5452 18                                  clc
  9925  5453 6567                                adc faclo
  9926  5455 8567                                sta faclo
  9927  5457 a52b                                lda product+1
  9928  5459 6566                                adc facmo
  9929  545b 8566                                sta facmo
  9930  545d a52c                                lda product+2
  9931  545f 6565                                adc facmoh
  9932  5461 8565                                sta facmoh                               ; (can't overflow since 23:59:59:9 -> 863999 ($0D2EFF)
  9933  5463 ca                                  dex
  9934  5464 d0e9                                bne l134_1                               ; next factor
  9935                          
  9936  5466 a900                                lda #0                                   ; float value in FAC
  9937  5468 8564                                sta facho                                ; zero msb, facov, facsgn
  9938  546a a2a0                                ldx #160                                 ; set facov for time
  9939  546c 38                                  sec                                      ; normal fac
  9940  546d 83760e                              +lbra floatb                             ; do it
  9941                          
  9942                          
  9943                          
  9944                          ReadSystemClock
  9945  5470 20deff                              jsr _ReadTime                            ; get packed BCD, y=hrs, x=min, a=sec, z=tenths
  9946                          ; (assumes system clock was set properly!)
  9947  5473 6487                                stz time                                 ; tenths  0-9
  9948  5475 8588                                sta time+1                               ; seconds  0-59
  9949  5477 8689                                stx time+2                               ; minutes  0-59
  9950  5479 848a                                sty time+3                               ; hours  0-59
  9951  547b 60                                  rts
  9952                          
  9953                          
  9954                          ; Unsigned Integer Multiply: Time * Factor  -> Tenths_of_Seconds
  9955                          ;     A   *  (B,C)  ->      (D,E,F)
  9956                          
  9957                          TimeMultiply
  9958  547c b587                                lda time,x                               ; convert packed BCD to binary
  9959  547e 290f                                and #$0f
  9960  5480 8564                                sta facho
  9961  5482 b587                                lda time,x                               ; 10x = 8x + 2x
  9962  5484 29f0                                and #$f0
  9963  5486 4a                                  lsr                                      ; msd x 8
  9964  5487 9587                                sta time,x
  9965  5489 4a                                  lsr
  9966  548a 4a                                  lsr                                      ; msd x 2
  9967  548b 18                                  clc
  9968  548c 6564                                adc facho                                ; lsd
  9969  548e 7587                                adc time,x
  9970  5490 9587                                sta time,x                               ; can't overflow ($99->153)
  9971                          
  9972  5492 8a                                  txa                                      ; make a word pointer from byte pointer
  9973  5493 0a                                  asl
  9974  5494 a8                                  tay
  9975  5495 b9b954                              lda TimeFactor-2,y                       ; multiplicand = TimeFactor,y  (2 bytes)
  9976  5498 8528                                sta multiplicand                         ; multiplier = Time,x x (1 byte)
  9977  549a b9ba54                              lda TimeFactor-1,y                       ; -----------
  9978  549d 8529                                sta multiplicand+1
  9979  549f a900                                lda #0                                   ; product lo   (3 bytes)
  9980  54a1 852b                                sta product+1                            ; mid
  9981  54a3 852c                                sta product+2                            ; hi
  9982                          
  9983  54a5 a010                                ldy #16                                  ; 16-bit multiplicand
  9984  54a7 0a                 l135_1           asl
  9985  54a8 eb2b00                              row product+1
  9986  54ab eb2800                              row multiplicand                         ; multiplier * multiplicand -> product
  9987  54ae 9007                                bcc l135_2
  9988  54b0 18                                  clc
  9989  54b1 7587                                adc time,x
  9990  54b3 9002                                bcc l135_2
  9991  54b5 e32b                                inw product+1                            ; (does no error check, since using time factors
  9992  54b7 88                 l135_2           dey                                      ; in ROM and maximum time multiplier of 59 there
  9993  54b8 d0ed                                bne l135_1                               ; is no danger of overflow)
  9994                          
  9995                          ; sta product
  9996  54ba 60                                  rts                                      ; (.X is preserved)
  9997                          
  9998                          
  9999                          TimeFactor
 10000  54bb 0a00                                !word 10                                 ; tenths per second  (max    59*10 =    590 ($0024E)
 10001  54bd 5802                                !word 600                                ; per minute  (max   59*600 =  35400 ($08A48)
 10002  54bf a08c                                !word 36000                              ; per hour    (max 23*36000 = 828000 ($CA260)
 10003                          
 10004                          ;[[command.sleep]]
 10005                          
 10006                          
 10007                          
 10008                          ;*******************************************************************************
 10009                          ;*
 10010                          ;* SLEEP Command - Postpone all activity for a specified number of seconds
 10011                          ;*
 10012                          ;* Syntax:  SLEEP n
 10013                          ;*
 10014                          ;* Where n is the number of seconds to remain inactive,
 10015                          ;* expressed as a positive value < 65536.
 10016                          ;*
 10017                          ;*******************************************************************************
 10018                          
 10019  54c1 208a5d             sleep            jsr getwrd                               ; get argument in (y,a)
 10020                          
 10021                          ; Multiply # of seconds to sleep by 60.  This will be the number of 'jiffies'
 10022                          ; to hibernate.  Store this value in 3 consecutive locations the kernel will
 10023                          ; decrement as a 24-bit binary value, and wait for an underflow.
 10024                          ;
 10025                          ; ldx #0   ;THIS CODE REPLACED    [910730]
 10026                          ; php
 10027                          ; sei   ;silence, please!
 10028                          ; sty _sleep_counter
 10029                          ; sta _sleep_counter+1
 10030                          ; stx _sleep_counter+2 ;sleep_counter = n
 10031                          ;
 10032                          ; jsr sleep_times_2 ;sleep_counter = 2n
 10033                          ; jsr add_xay_to_sleep ;sleep_counter = 3n
 10034                          ; jsr sleep_times_4 ;sleep_counter = 12n
 10035                          ;
 10036                          ; ldy _sleep_counter
 10037                          ; lda _sleep_counter+1
 10038                          ; ldx _sleep_counter+2 ;(xay) = 12n
 10039                          ;
 10040                          ; jsr sleep_times_4 ;sleep_counter = 48n
 10041                          ; jsr add_xay_to_sleep ;sleep_counter = 60n !!!!!
 10042                          ;
 10043                          ; plp
 10044                          ;
 10045                          ;1$ jsr is_stop_key_down
 10046                          ; ldx _sleep_counter+2
 10047                          ; inx   ;underflow?
 10048                          ; bne 1$   ;no, loop
 10049                          ; rts
 10050                          ;
 10051                          ;
 10052                          ;sleep_times_4
 10053                          ; jsr sleep_times_2
 10054                          ;sleep_times_2
 10055                          ; asl _sleep_counter
 10056                          ; rol _sleep_counter+1
 10057                          ; rol _sleep_counter+2
 10058                          ; rts
 10059                          ;
 10060                          ;add_xay_to_sleep
 10061                          ; pha
 10062                          ; tya
 10063                          ; adc _sleep_counter
 10064                          ; sta _sleep_counter
 10065                          ; pla
 10066                          ; adc _sleep_counter+1
 10067                          ; sta _sleep_counter+1
 10068                          ; txa
 10069                          ; adc _sleep_counter+2
 10070                          ; sta _sleep_counter+2
 10071                          ; rts
 10072                          
 10073                          
 10074                          ; SLEEP is now based upon the system hardware TOD clock (same one used by TI$).  This
 10075                          ; makes it accurate, something it was not when it was based upon the frame rate.
 10076                          
 10077  54c4 8487                                sty time                                 ; Number of seconds to "sleep"   [910730] new
 10078  54c6 8588                                sta time+1
 10079                          
 10080  54c8 20deff             l136_1           jsr _ReadTime                            ; Get current time
 10081  54cb 6489                                stz time+2                               ; tenths
 10082  54cd 858a                                sta time+3                               ; seconds
 10083                          
 10084  54cf 20cc2c             l136_2           jsr is_stop_key_down                     ; Allow user to abort
 10085  54d2 20deff                              jsr _ReadTime                            ; Wait for seconds to increment
 10086  54d5 c58a                                cmp time+3
 10087  54d7 f0f6                                beq l136_2
 10088  54d9 858a                                sta time+3
 10089                          
 10090  54db 20deff             l136_3           jsr _ReadTime                            ; Wait for tenths to increment
 10091  54de d489                                cpz time+2
 10092  54e0 d0f9                                bne l136_3
 10093                          
 10094  54e2 c387                                dew time                                 ; Decrement sleep period 1 second
 10095  54e4 d0e9                                bne l136_2                               ; Loop until sleep period over
 10096                          
 10097  54e6 60                                  rts
 10098                          
 10099                          ;.end
 10100                          ;[[command.wait]]
 10101                          
 10102                          
 10103                          
 10104                          ; WAIT<location>,<mask1>[,<mask2>] statement waits until the contents of
 10105                          ; <location> is nonzero when XORed with mask2 and then ANDed with mask1.
 10106                          ; If mask2 is not present, it is assumed to be zero.
 10107                          
 10108  54e7 207c5d             wait             jsr getnum                               ; get required mask1
 10109  54ea 864b                                stx andmsk
 10110  54ec a200                                ldx #0
 10111  54ee 208522                              jsr chrgot
 10112  54f1 f003                                beq l137_1
 10113  54f3 20825d                              jsr combyt                               ; get optional mask2
 10114  54f6 864c               l137_1           stx eormsk
 10115                          
 10116  54f8 db                                  phz
 10117  54f9 abd102                              ldz current_bank                         ; set up bank number for fetch
 10118  54fc a216                                ldx #poker                               ; ..and address
 10119  54fe a000                                ldy #0                                   ; ..and index
 10120                          
 10121  5500 2cd102             l137_2           bit current_bank
 10122  5503 3004                                bmi l137_3                               ; NOMAP?
 10123  5505 2074ff                              jsr _lda_far                             ; lda (poker),y
 10124  5508 2c                                  !text $2c
 10125                          
 10126  5509 b116               l137_3           lda (poker),y
 10127  550b 454c                                eor eormsk
 10128  550d 254b                                and andmsk
 10129  550f f0ef                                beq l137_2
 10130  5511 fb                                  plz
 10131  5512 60                                  rts                                      ; got a nonzero
 10132                          
 10133                          ;.end
 10134                          ;[[function.fre]]
 10135                          
 10136                          
 10137                          
 10138                          ;*****************************************************************************
 10139                          ; FRE(n) Function
 10140                          ;
 10141                          ; Where: n=0 returns amount of free RAM in bank 0. This is the area
 10142                          ;  between top of text (TEXT_TOP) and top of RAM (MAX_MEM_0).
 10143                          ;
 10144                          ;  n=1 returns amount of free ram in bank 1. This is the area
 10145                          ;  between top of arrays (STREND) and bottom of strings (FRETOP).
 10146                          ;
 10147                          ;  n=2 returns the amount (???? presence) of expansion RAM.
 10148                          ;
 10149                          ;*****************************************************************************
 10150                          
 10151  5513 206f5d             fre              jsr conint                               ; get integer argument in .x
 10152  5516 e001                                cpx #1                                   ; which bank?
 10153  5518 f015                                beq l138_1                               ; go do bank one
 10154  551a e002                                cpx #2                                   ; go do expansion banks   [910107]
 10155  551c f020                                beq l138_2                               ; else it must be bank zero
 10156  551e b3defc                              +lbcs fcerr                              ; any other is unpleasant to talk about
 10157                          
 10158  5521 38                                  sec                                      ; FRE(text_bank)
 10159  5522 adcf02                              lda max_mem_0
 10160  5525 e582                                sbc text_top
 10161  5527 a8                                  tay                                      ; set up result for nosflt
 10162  5528 add002                              lda max_mem_0+1
 10163  552b e583                                sbc text_top+1
 10164  552d 8014                                bra l138_3                               ; assumes text_top < max_mem
 10165                          
 10166                          
 10167  552f 20335c             l138_1           jsr garba2                               ; FRE(var_bank) do garbage collect first
 10168  5532 38                                  sec
 10169  5533 a535                                lda fretop
 10170  5535 e533                                sbc strend
 10171  5537 a8                                  tay
 10172  5538 a536                                lda fretop+1
 10173  553a e534                                sbc strend+1
 10174  553c 8005                                bra l138_3
 10175                          
 10176  553e ac0711             l138_2           ldy _expansion                           ; FRE(expansion banks)    [910107]
 10177  5541 a900                                lda #0
 10178                          
 10179  5543 838203             l138_3           +lbra nosflt                             ; go float the number (y,a)=(lo,hi)
 10180                          
 10181                          ;.end
 10182                          ;[[function.val]]
 10183                          
 10184                          
 10185                          
 10186                          ; The VAL function takes a string and turns it into a number by interpreting
 10187                          ; the PETSCII digits etc.  Except for the problem that a terminator must be
 10188                          ; supplied by replacing the character beyond the string, VAL is merely a call
 10189                          ; to floating point input (FIN).
 10190                          
 10191  5546 205c5a             val              jsr len1                                 ; get length
 10192  5549 f3fe08                              +lbeq zerofc                             ; return 0 if len=0
 10193                          
 10194                          ; Use text to fp number code by faking a new text poiner
 10195                          
 10196  554c 18                 val_1            clc                                      ; ///jump table entry.  convert PETSCII to floating point
 10197  554d 6524                                adc index1
 10198  554f 8572                                sta strng2                               ; add length to index1 and put in strng2
 10199  5551 a525                                lda index1+1
 10200  5553 6900                                adc #0
 10201  5555 8573                                sta strng2+1
 10202                          
 10203  5557 a000                                ldy #0
 10204  5559 a972                                lda #strng2
 10205  555b 20d722                              jsr lda_far_ram1                         ; replace character after string with $00 (fake EOL)
 10206  555e 48                                  pha                                      ; save old character
 10207  555f 98                                  tya                                      ; (.A=0)
 10208  5560 a272                                ldx #strng2
 10209  5562 20f022                              jsr sta_far_ram1 ;sta (strng2),y         ; ..and put in null
 10210  5565 205f64                              jsr fin_chrget_2                         ; get character pointed to and set flags.(sorta like chrgot)
 10211  5568 a201                                ldx #1                                   ; flag 'bank 1'
 10212  556a 208d63                              jsr fin                                  ; go do evaluation
 10213  556d 68                                  pla                                      ; get saved character
 10214  556e da                                  phx
 10215  556f a272                                ldx #strng2
 10216  5571 a000                                ldy #0
 10217  5573 20f022                              jsr sta_far_ram1 ;sta (strng2),y         ; restore zeroed-out character
 10218  5576 fa                                  plx
 10219  5577 60                                  rts
 10220                          
 10221                          ;.end
 10222                          ;[[function.dec]]
 10223                          
 10224                          
 10225                          
 10226                          ; DEC convert a hex string representing a 2-byte integer into decimal.
 10227                          
 10228  5578 205c5a             dcml             jsr len1                                 ; find length of string
 10229  557b 8526                                sta index2                               ; len ret. in a
 10230  557d a000                                ldy #0
 10231  557f 8427                                sty index2+1                             ; zero char counter
 10232  5581 8473                                sty strng2+1                             ; zero out value
 10233  5583 8472                                sty strng2
 10234                          
 10235  5585 c426               l139_1           cpy index2                               ; evaluated all characters?
 10236  5587 f034                                beq l139_4                               ; branch if so
 10237  5589 20d522                              jsr indin1_ram1                          ; get next character from string
 10238  558c c8                                  iny
 10239  558d c920                                cmp #' '                                 ; ignore spaces
 10240  558f f0f4                                beq l139_1
 10241  5591 e627                                inc index2+1
 10242  5593 a627                                ldx index2+1
 10243  5595 e005                                cpx #5
 10244  5597 b02b                                bcs decbad                               ; can't have more than 4 characters
 10245                          
 10246  5599 c930                                cmp #'0'
 10247  559b 9027                                bcc decbad                               ; bad if < 0
 10248  559d c93a                                cmp #':'                                 ; '9'+1
 10249  559f 900a                                bcc l139_2                               ; ok if  = 0-9
 10250  55a1 c941                                cmp #'A'
 10251  55a3 901f                                bcc decbad                               ; bad if > 9  and < A
 10252  55a5 c947                                cmp #'G'
 10253  55a7 b01b                                bcs decbad                               ; bad if > F
 10254                          
 10255  55a9 e907                                sbc #7                                   ; adjust if A-F  (.c is clr)
 10256  55ab e92f               l139_2           sbc #$2f                                 ; adjust to $00..$0f (.c is set)
 10257  55ad 0a                                  asl                                      ; shift low nibble to high
 10258  55ae 0a                                  asl
 10259  55af 0a                                  asl
 10260  55b0 0a                                  asl
 10261                          
 10262  55b1 a204                                ldx #4                                   ; mult. old val. by 16, add new
 10263  55b3 0a                 l139_3           asl
 10264  55b4 2672                                rol strng2
 10265  55b6 2673                                rol strng2+1
 10266  55b8 ca                                  dex
 10267  55b9 d0f8                                bne l139_3
 10268  55bb 80c8                                bra l139_1
 10269                          
 10270  55bd a472               l139_4           ldy strng2                               ; get lsb of value,
 10271  55bf a573                                lda strng2+1                             ; & msb,
 10272  55c1 830403                              +lbra nosflt                             ; go float 2 byte unsigned integer
 10273                          
 10274                          
 10275                          decbad
 10276  55c4 8338fc                              +lbra fcerr                              ; illegal qty error
 10277                          
 10278                          ;.end
 10279                          
 10280                          ;[[command.peekpoke]]
 10281                          
 10282                          
 10283                          
 10284  55c7 fc1600             peek             phw poker                                ; ..also happens to be LINNUM!   [910911]
 10285  55ca 20db4c                              jsr chknum
 10286  55cd 208d5d                              jsr getadr
 10287  55d0 a000                                ldy #0                                   ; index
 10288  55d2 2cd102                              bit current_bank
 10289  55d5 300b                                bmi l140_1                               ; NOMAP?
 10290                          
 10291  55d7 db                                  phz
 10292  55d8 abd102                              ldz current_bank                         ; set up bank number for Kernel's fetch
 10293  55db a216                                ldx #poker                               ; ..and address
 10294  55dd 2074ff                              jsr _lda_far                             ; lda (poker),y
 10295  55e0 fb                                  plz
 10296  55e1 2c                                  !text $2c
 10297                          
 10298  55e2 b116               l140_1           lda (poker),y
 10299  55e4 a8                                  tay                                      ; get byte into .y
 10300  55e5 68                                  pla
 10301  55e6 8517                                sta poker+1                              ; restore linnum
 10302  55e8 68                                  pla
 10303  55e9 8516                                sta poker
 10304  55eb 83e502                              +lbra sngflt                             ; float it
 10305                          
 10306                          
 10307  55ee 207c5d             poke             jsr getnum
 10308  55f1 8a                 l141_1           txa                                      ; set up value to store for Kernel 'stash' routine
 10309  55f2 a000                                ldy #0                                   ; ..and index
 10310  55f4 78                                  sei                                      ; to allow poking IRQ vector, etc.  [910612]
 10311  55f5 2cd102                              bit current_bank
 10312  55f8 300b                                bmi l141_2                               ; (anything >1Meg means NOMAP)
 10313                          
 10314  55fa db                                  phz
 10315  55fb a216                                ldx #poker                               ; ..and address
 10316  55fd abd102                              ldz current_bank                         ; ..finally, get the bank number
 10317  5600 2077ff                              jsr _sta_far                             ; sta (poker),y
 10318  5603 fb                                  plz
 10319  5604 2c                                  !text $2c
 10320                          
 10321  5605 9116               l141_2           sta (poker),y                            ; NoMap
 10322                          
 10323  5607 208522             l141_3           jsr chrgot                               ; eol?
 10324  560a f00a                                beq l141_4                               ; yes
 10325  560c e316                                inw poker                                ; no- increment address
 10326                          ; lda poker  ; check for segment wrap (FFFF->0000) [910911]
 10327                          ; ora poker+1
 10328  560e f331d8                              +lbeq omerr                              ; [910916]
 10329  5611 202679                              jsr optbyt                               ; & get next [,byte]
 10330  5614 b0db                                bcs l141_1
 10331                          
 10332  5616 58                 l141_4           cli                                      ; [910612]
 10333  5617 60                                  rts
 10334                          
 10335                          
 10336                          ;.end
 10337                          
 10338                          ;[[function.errstr]]
 10339                          
 10340                          
 10341  5618 20c162             errd             jsr sign                                 ; get sign
 10342  561b 300c                                bmi l142_1                               ; (allow err$(er) when er=-1)
 10343  561d 206f5d                              jsr conint                               ; get integer arg in x
 10344  5620 ca                                  dex
 10345  5621 8a                                  txa                                      ; error # (0 to max-1)
 10346  5622 c92a                                cmp #last_error_message                  ; check range
 10347  5624 900f                                bcc l142_2                               ; ok
 10348  5626 a200                                ldx #0                                   ; too high, return null
 10349  5628 2c                                  !text $2c
 10350                          
 10351  5629 a202               l142_1           ldx #2                                   ; no error, return "ok"    [910911]
 10352  562b a96a                                lda #<ok_error_message
 10353  562d a029                                ldy #>ok_error_message
 10354  562f 8526                                sta index2
 10355  5631 8427                                sty index2+1
 10356  5633 8013                                bra l142_5                               ; pass it
 10357                          
 10358  5635 20a92b             l142_2           jsr erstup                               ; look up the error, set up a pointer to it
 10359  5638 a0ff                                ldy #$ff                                 ; determine how long it is
 10360  563a a200                                ldx #0
 10361  563c e8                 l142_3           inx                                      ; count printing characters
 10362  563d c8                 l142_4           iny
 10363  563e b126                                lda (index2),y                           ; (rom: ind.ok)
 10364  5640 3006                                bmi l142_5                               ; msb set means last
 10365  5642 c920                                cmp #' '
 10366  5644 90f7                                bcc l142_4                               ; don't count non-printers
 10367  5646 80f4                                bra l142_3                               ; count all others
 10368                          
 10369  5648 8a                 l142_5           txa                                      ; message length
 10370  5649 207b5a                              jsr strspa                               ; get space
 10371  564c aa                                  tax
 10372  564d f01d                                beq l142_7                               ; null
 10373                          
 10374                          ; sta sw_rom_ram1  ;set up string bank????
 10375  564f a200                                ldx #0
 10376  5651 a0ff                                ldy #$ff
 10377  5653 c8                 l142_6           iny                                      ; copy message into memory
 10378  5654 b126                                lda (index2),y                           ; (rom: ind.ok)
 10379  5656 c920                                cmp #' '
 10380  5658 90f9                                bcc l142_6                               ; skip non-printers
 10381                          
 10382  565a 48                                  pha
 10383  565b 297f                                and #$7f
 10384  565d 5a                                  phy                                      ; swap x&y
 10385  565e da                                  phx
 10386  565f 7a                                  ply
 10387  5660 a264                                ldx #dsctmp+1
 10388  5662 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y to RAM1
 10389  5665 5a                                  phy                                      ; swap x&y
 10390  5666 fa                                  plx
 10391  5667 7a                                  ply
 10392  5668 e8                                  inx
 10393  5669 68                                  pla                                      ; test if msb was set
 10394  566a 10e7                                bpl l142_6
 10395                          
 10396  566c 835903             l142_7           +lbra chrd1                              ; pla,pla,jmp putnew
 10397                          
 10398                          
 10399                          ;.end
 10400                          ;[[function.hexstr]]
 10401                          
 10402                          
 10403                          
 10404  566f 20db4c             hexd             jsr chknum
 10405  5672 fc1600                              phw poker                                ; save linnum    [910911]
 10406  5675 208d5d                              jsr getadr                               ; 2 byte val in (poker)
 10407  5678 a904                                lda #4
 10408  567a 207b5a                              jsr strspa
 10409  567d a000                                ldy #0
 10410  567f a517                                lda poker+1
 10411  5681 209256                              jsr hexit
 10412  5684 a516                                lda poker
 10413  5686 209256                              jsr hexit
 10414  5689 68                                  pla                                      ; restore linnum
 10415  568a 8517                                sta poker+1
 10416  568c 68                                  pla
 10417  568d 8516                                sta poker
 10418  568f 833603                              +lbra chrd1                              ; pla,pla,jmp putnew
 10419                          
 10420  5692 48                 hexit            pha
 10421  5693 4a                                  lsr
 10422  5694 4a                                  lsr
 10423  5695 4a                                  lsr
 10424  5696 4a                                  lsr
 10425  5697 209b56                              jsr dohex
 10426  569a 68                                  pla
 10427                          
 10428  569b 290f               dohex            and #$0f
 10429  569d c90a                                cmp #$0a
 10430  569f 9002                                bcc l143_1
 10431  56a1 6906                                adc #6
 10432  56a3 6930               l143_1           adc #'0'
 10433  56a5 da                                  phx
 10434  56a6 a264                                ldx #dsctmp+1
 10435  56a8 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
 10436  56ab fa                                  plx
 10437  56ac c8                                  iny
 10438  56ad 60                                  rts
 10439                          
 10440                          ;.end
 10441                          ;[[function.joy]]
 10442                          
 10443                          
 10444                          
 10445                          ;*************************************************************
 10446                          ; JOY (n)  -- Return joystick status
 10447                          ;
 10448                          ; where: n =  1  return position of joystick-1
 10449                          ;       2  return position of joystick-2
 10450                          ;
 10451                          ; result:      0  no direction, no button
 10452                          ;       1-8    direction (see below), no button
 10453                          ;       128 no direction, button
 10454                          ;       129-136 direction & button  128 + [1...8]
 10455                          ;
 10456                          ; button--->  128        1
 10457                          ;       8     2
 10458                          ; stick--->  7           3
 10459                          ;       6     4
 10460                          ;          5
 10461                          ;
 10462                          ;*************************************************************
 10463                          
 10464  56ae 206f5d             joy              jsr conint                               ; get 1 byte arg in x
 10465  56b1 ca                                  dex
 10466  56b2 e002                                cpx #2                                   ; make sure arg. is valid
 10467  56b4 b348fb                              +lbcs fcerr                              ; >1, error
 10468                          
 10469  56b7 8a                                  txa
 10470  56b8 4901                                eor #1                                   ; invert to match legends on case
 10471  56ba aa                                  tax
 10472  56bb 08                                  php                                      ; save status
 10473                          
 10474                          ; jsr put_io_in_map
 10475  56bc 78                                  sei                                      ; disable IRQ to inhibit kybd
 10476  56bd ad00dc                              lda d1pra
 10477  56c0 48                                  pha                                      ; save kybd output lines
 10478  56c1 a0ff                                ldy #$ff
 10479  56c3 8c00dc                              sty d1pra                                ; set to not read any kybd inputs
 10480                          
 10481  56c6 bd00dc             l144_1           lda d1pra,x                              ; read joystick values
 10482  56c9 dd00dc                              cmp d1pra,x                              ; debounce
 10483  56cc d0f8                                bne l144_1
 10484                          
 10485  56ce aa                                  tax                                      ; save joystick values
 10486  56cf 68                                  pla
 10487  56d0 8d00dc                              sta d1pra                                ; reset kybd output lines
 10488  56d3 8a                                  txa                                      ; restore joystick values
 10489  56d4 28                                  plp                                      ; restore status
 10490  56d5 290f                                and #$0f                                 ; test which direction
 10491  56d7 a8                                  tay
 10492  56d8 b9e356                              lda joytab-5,y                           ; get direction indicator
 10493  56db a8                                  tay                                      ; save direction : 0-8
 10494  56dc 8a                                  txa                                      ; restore joystick value
 10495  56dd 2910                                and #$10                                 ; test if button triggered
 10496  56df d004                                bne l144_2                               ; skip if not
 10497  56e1 98                                  tya
 10498  56e2 0980                                ora #$80                                 ; show trigger depressed
 10499  56e4 a8                                  tay
 10500  56e5 83eb01             l144_2           +lbra sngflt                             ; float 1 byte arg in y.
 10501                          
 10502  56e8 0402030006080700...joytab           !text 4,2,3,0,6,8,7,0,5,1,0
 10503                          
 10504                          ;.end
 10505                          
 10506                          ;[[function.potpen]]
 10507                          
 10508                          
 10509                          ;***********************************************************
 10510                          ; POT(n)  --  Read paddles
 10511                          ;
 10512                          ;    n = 1 : paddle-1 - X-position
 10513                          ;  2 : paddle-1 - Y-position
 10514                          ;  3 : paddle-2 - X-position
 10515                          ;  4 : paddle-2 - Y-position
 10516                          ;
 10517                          ;     result >= 256 --  trigger set
 10518                          ;***********************************************************
 10519                          
 10520  56f3 20554e             pot              jsr chkcls                               ; look for closing paren
 10521  56f6 206f5d                              jsr conint                               ; get 1-byte arg in .x
 10522  56f9 ca                                  dex
 10523  56fa e004                                cpx #4
 10524  56fc b300fb                              +lbcs fcerr                              ; value error
 10525                          
 10526                          ; jsr put_io_in_map
 10527  56ff 8a                                  txa                                      ; convert arg (0-3) into paddle enables
 10528  5700 4a                                  lsr                                      ; .c= X/Y   .a= port 1/2
 10529  5701 aa                                  tax
 10530  5702 bd6b79                              lda sbits+6,x
 10531  5705 aa                                  tax                                      ; (CIA paddle port, $40/$80)
 10532  5706 a900                                lda #0
 10533  5708 2a                                  rol
 10534  5709 a8                                  tay                                      ; (SID x/y offset,  $00/$01)
 10535                          
 10536  570a 8e6e11                              stx pot_temp_1                           ; save which port
 10537  570d 08                                  php                                      ; save IRQ enable while we
 10538  570e 78                                  sei                                      ; disable IRQ to inhibit keyboard scan
 10539  570f ad00dc                              lda d1pra
 10540  5712 48                                  pha                                      ; save kybd output lines
 10541  5713 8e00dc                              stx d1pra                                ; turn on correct paddle
 10542                          
 10543  5716 205d48                              jsr go_slow
 10544  5719 a200                                ldx #0
 10545  571b e8                 l145_1           inx                                      ; delay to let pot be read by SID
 10546  571c d0fd                                bne l145_1
 10547                          
 10548  571e b919d4             l145_2           lda sid1+25,y                            ; read pot
 10549  5721 d919d4                              cmp sid1+25,y                            ; debounce
 10550  5724 d0f8                                bne l145_2
 10551  5726 8d6f11                              sta pot_temp_2                           ; save pot value
 10552  5729 205748                              jsr go_fast
 10553                          
 10554  572c a200                                ldx #0                                   ; set index to d1pra
 10555  572e 2c6e11                              bit pot_temp_1                           ; test if pot-0,1 or pot-2,3
 10556  5731 3001                                bmi l145_3                               ; skip if pot 2,3
 10557  5733 e8                                  inx                                      ; index to d1prb
 10558  5734 a904               l145_3           lda #04                                  ; use joy line-2
 10559  5736 88                                  dey                                      ; test if pot-x or pot-y
 10560  5737 3001                                bmi l145_4                               ; skip if pot-x
 10561  5739 0a                                  asl                                      ; use joy line-3
 10562  573a a0ff               l145_4           ldy #$ff
 10563  573c 8c00dc                              sty d1pra                                ; disable keybd inputs
 10564  573f c8                                  iny                                      ; set to zero for no trigger
 10565  5740 3d00dc                              and d1pra,x                              ; test if trigger set
 10566  5743 d001                                bne l145_5                               ; skip if not trigger
 10567  5745 c8                                  iny                                      ; return value >255 for trigger
 10568  5746 68                 l145_5           pla
 10569  5747 8d00dc                              sta d1pra                                ; restore keybd lines
 10570  574a 98                                  tya
 10571  574b ac6f11                              ldy pot_temp_2                           ; restore pot value
 10572  574e 28                                  plp                                      ; restore status
 10573  574f 837601                              +lbra nosflt                             ; output 2-byte result
 10574                          
 10575                          
 10576                          ;*************************************************************
 10577                          ;  LPEN(n)  --  Read light pen
 10578                          ;
 10579                          ; n = 0 x position
 10580                          ;     1 y position
 10581                          ;*************************************************************
 10582                          
 10583  5752 20554e             lpen             jsr chkcls                               ; look for closing parens
 10584  5755 206f5d                              jsr conint                               ; get 1 byte arg in .X
 10585                          ; dex   ;convert [1-2] to [0-1]
 10586  5758 e002                                cpx #2
 10587  575a b3a2fa                              +lbcs fcerr                              ; bad value
 10588                          
 10589  575d a900                                lda #0
 10590  575f 78                                  sei
 10591  5760 bce802                              ldy lightpen_xpos,x                      ; get latched light pen value (a=msb, y=lsb)
 10592  5763 9de802                              sta lightpen_xpos,x                      ; reset to zero (????preserve last latched position)
 10593  5766 58                                  cli
 10594  5767 e000                                cpx #0
 10595  5769 d006                                bne l146_1                               ; done if y position
 10596  576b 98                                  tya
 10597  576c 0a                                  asl                                      ; else multiply *2 to get correct x position
 10598  576d a8                                  tay                                      ; lsb
 10599  576e a900                                lda #0
 10600  5770 2a                                  rol                                      ; msb
 10601  5771 835401             l146_1           +lbra nosflt                             ; float it (y,a)
 10602                          
 10603                          
 10604                          ;.end
 10605                          ;[[function.pointer]]
 10606                          
 10607                          
 10608                          
 10609                          ;******************************************************************
 10610                          ;
 10611                          ; POINTER(var_name) - Return address of descriptor for var_name
 10612                          ;
 10613                          ;******************************************************************
 10614                          
 10615  5774 208322             pointer          jsr chrget                               ; skip over escape token
 10616  5777 20584e                              jsr chkopn                               ; test for open paren
 10617  577a 200250                              jsr isletc                               ; test if character follows parens
 10618  577d 93cbd6                              +lbcc snerr                              ; ...syntax error if not.
 10619  5780 207c4f                              jsr ptrget                               ; look for this varname in table
 10620                          
 10621                          pointer_ret      =*-1
 10622  5783 aa                                  tax
 10623  5784 5a                                  phy
 10624  5785 20554e                              jsr chkcls                               ; look for closing paren
 10625  5788 8a                                  txa
 10626  5789 a8                                  tay
 10627  578a 68                                  pla
 10628  578b c902                                cmp #>zero                               ; is this a dummy pointer?
 10629  578d d003                                bne l147_1
 10630  578f a900                                lda #0                                   ; if so, return 0
 10631  5791 a8                                  tay
 10632  5792 833301             l147_1           +lbra nosflt
 10633                          
 10634                          ;.end
 10635                          ;[[operator.xor]]
 10636                          
 10637                          
 10638                          
 10639                          ;**************************************************************
 10640                          ;*
 10641                          ;*   XOR - Exclusive-or two 16 bit arguments
 10642                          ;*
 10643                          ;* Syntax : XOR (arg1, arg2)
 10644                          ;*
 10645                          ;**************************************************************
 10646                          
 10647  5795 fc1600             xor              phw poker                                ; protect the poker value (could be in use)  [910911]
 10648  5798 20db4c                              jsr chknum
 10649  579b 208d5d                              jsr getadr                               ; get first arg
 10650  579e 48                                  pha                                      ; save MSB
 10651  579f 5a                                  phy                                      ; save LSB
 10652                          
 10653  57a0 20875d                              jsr comwrd                               ; check for comma, get word
 10654  57a3 20554e                              jsr chkcls                               ; check for closing parens
 10655                          
 10656  57a6 68                                  pla
 10657  57a7 4516                                eor poker                                ; xor LSB (comwrd left a copy of its arg in POKER)
 10658  57a9 a8                                  tay
 10659  57aa 68                                  pla
 10660  57ab 4517                                eor poker+1                              ; ..and MSB
 10661  57ad 20c758                              jsr nosflt                               ; ..and go float 'em
 10662                          
 10663  57b0 68                                  pla
 10664  57b1 8517                                sta poker+1
 10665  57b3 68                                  pla
 10666  57b4 8516                                sta poker
 10667  57b6 60                                  rts
 10668                          
 10669                          ;.end
 10670                          ;[[operator.mod]]
 10671                          
 10672                          
 10673                          
 10674                          ;**************************************************************
 10675                          ;*
 10676                          ;* MOD  -  Modulus of a number
 10677                          ;*
 10678                          ;* Syntax : MOD (number, range)
 10679                          ;*      910402 FAB
 10680                          ;**************************************************************
 10681                          
 10682                          ; Calculate   MOD = NUMBER-RANGE*INT(NUMBER/RANGE)
 10683                          
 10684  57b7 20db4c             mod              jsr chknum                               ; 1st arg in FAC1 (number)
 10685  57ba 20734d                              jsr pushf1                               ; save two copies of it for later
 10686  57bd 20734d                              jsr pushf1
 10687  57c0 205b4e                              jsr chkcom                               ; check for comma
 10688  57c3 20d84c                              jsr frmnum                               ; 2nd arg in FAC1 (range)
 10689  57c6 20554e                              jsr chkcls                               ; check for closing paren
 10690                          
 10691  57c9 20a362                              jsr movaf                                ; save range in FAC2
 10692  57cc 20964d                              jsr pullf1                               ; get back number in FAC1
 10693  57cf a205                                ldx #5                                   ; swap FAC1 and FAC2
 10694  57d1 b563               l148_1           lda facexp,x
 10695  57d3 b46a                                ldy argexp,x
 10696  57d5 956a                                sta argexp,x
 10697  57d7 9463                                sty facexp,x
 10698  57d9 ca                                  dex
 10699  57da 10f5                                bpl l148_1
 10700  57dc 20734d                              jsr pushf1                               ; save one copy of range for later
 10701                          
 10702  57df 207861                              jsr fdivt_c65                            ; number/range
 10703  57e2 206363                              jsr int                                  ; INT(number/range)
 10704  57e5 20a362                              jsr movaf                                ; round & move to FAC2
 10705  57e8 20964d                              jsr pullf1                               ; retrieve arg2 (range)
 10706  57eb 206360                              jsr fmultt_c65                           ; range*INT(number/range)
 10707  57ee 20fc65                              jsr negop                                ; -range*INT(number/range)
 10708  57f1 20a362                              jsr movaf                                ; move to FAC2
 10709  57f4 20964d                              jsr pullf1                               ; retrieve arg1 (number)
 10710  57f7 83230c                              +lbra faddt_c65                          ; number-range*INT(number/range)
 10711                          
 10712                          
 10713                          ;.end
 10714                          
 10715                          ;[[function.rwindow]]
 10716                          
 10717                          
 10718                          ;******************************************************************************
 10719                          ;
 10720                          ; RWINDOW  - Returns information about the current console display environment.
 10721                          ;
 10722                          ;   Syntax : RWINDOW (n)
 10723                          ;
 10724                          ;   Where: n=0 : number of lines in the current window
 10725                          ;   =1 : number of rows in the current window
 10726                          ;   =2 : returns either 40 or 80, depending on the
 10727                          ;   current console device
 10728                          ;
 10729                          ;******************************************************************************
 10730                          
 10731  57fa 20554e             rwindow          jsr chkcls
 10732  57fd 206f5d                              jsr conint
 10733  5800 e002                                cpx #2
 10734  5802 f015                                beq l149_2                               ; return current console
 10735  5804 b3f8f9                              +lbcs fcerr
 10736                          
 10737  5807 e000                                cpx #0
 10738  5809 d007                                bne l149_1
 10739                          
 10740  580b a5e4                                lda _screen_bottom
 10741  580d 38                                  sec
 10742  580e e5e5                                sbc _screen_top
 10743  5810 800d                                bra l149_3                               ; always
 10744                          
 10745  5812 a5e7               l149_1           lda _screen_right
 10746  5814 38                                  sec
 10747  5815 e5e6                                sbc _screen_left
 10748  5817 8006                                bra l149_3                               ; always
 10749                          
 10750                          
 10751  5819 a950               l149_2           lda #80                                  ; assume 80 col
 10752  581b 7fd701                              bbr7 _mode,l149_3
 10753  581e 4a                                  lsr
 10754  581f a8                 l149_3           tay
 10755  5820 83b000                              +lbra sngflt                             ; float 1 byte arg in .Y
 10756                          
 10757                          ;.end
 10758                          ;[[function.rnd]]
 10759                          
 10760                          
 10761                          
 10762                          ;    Random Number Function  RND(x)
 10763                          ;
 10764                          ;  x=0 ==> generate a random number based on hardware clock & noisy POT lines
 10765                          ;  x<0 ==> seed a reproducable, pseudo-random number generator
 10766                          ;  x>0 ==> generate a reproducable pseudo-random # based upon seed value above
 10767                          
 10768                          
 10769  5823 20c162             rnd              jsr sign                                 ; get sign into .a
 10770                          
 10771  5826 3042               rnd_0            bmi l150_2                               ; /// entry from jump table
 10772  5828 d02b                                bne l150_1
 10773                          
 10774                          
 10775                          ; Get value from hardware
 10776                          
 10777  582a 205d48                              jsr go_slow                              ; Use CIA#1 timer B & SID#2 pot X & Y for seeds  [910314]
 10778  582d ad39d4                              lda sid2+25                              ; go slow to read POT-X
 10779  5830 0a                                  asl
 10780  5831 0a                                  asl
 10781  5832 0a                                  asl
 10782  5833 0a                                  asl
 10783  5834 0d3ad4                              ora sid2+26                              ; and POT-Y
 10784  5837 4d12d0                              eor vic+18                               ; ???? should be okay- we're in Slow mode
 10785  583a 8565                                sta facmoh
 10786  583c 205748                              jsr go_fast                              ; restore speed
 10787  583f ad06dc                              lda d1pra+6                              ; timer B is free-running
 10788  5842 8566                                sta facmo
 10789  5844 ad07dc                              lda d1pra+7
 10790  5847 8567                                sta faclo
 10791  5849 4564                                eor facho
 10792  584b 6565                                adc facmoh
 10793  584d 4566                                eor facmo
 10794  584f 6567                                adc faclo
 10795  5851 8564                                sta facho
 10796  5853 8025                                bra l150_3
 10797                          
 10798                          
 10799  5855 a974               l150_1           lda #<rndx                               ; get last one into FAC
 10800  5857 a011                                ldy #>rndx
 10801  5859 200e62                              jsr movfm
 10802  585c a990                                lda #<rmulc
 10803  585e a058                                ldy #>rmulc                              ; FAC was zero.  restore last one
 10804  5860 204860                              jsr rommlt                               ; multiply by random constant
 10805  5863 a995                                lda #<raddc
 10806  5865 a058                                ldy #>raddc
 10807  5867 205160                              jsr romadd                               ; add random constant
 10808                          
 10809  586a a667               l150_2           ldx faclo
 10810  586c a564                                lda facho
 10811  586e 8567                                sta faclo
 10812  5870 8664                                stx facho                                ; reverse hi and lo
 10813  5872 a665                                ldx facmoh
 10814  5874 a566                                lda facmo
 10815  5876 8565                                sta facmoh
 10816  5878 8666                                stx facmo
 10817                          
 10818  587a a900               l150_3           lda #0                                   ; strnex.  make number positive
 10819  587c 8568                                sta facsgn
 10820  587e a563                                lda facexp                               ; put exp where it will
 10821  5880 8571                                sta facov                                ; be shifted in by normal
 10822  5882 a980                                lda #$80
 10823  5884 8563                                sta facexp                               ; make result between 0 and 1
 10824  5886 20295e                              jsr normal                               ; normalize
 10825  5889 a274                                ldx #<rndx
 10826  588b a011                                ldy #>rndx
 10827  588d 83ab09                              +lbra movmf                              ; put new one into memory
 10828                          
 10829  5890 9835447a00         rmulc            !text 152,53,68,122,0
 10830  5895 6828b14600         raddc            !text 104,40,177,70,0
 10831                          
 10832                          ;.end
 10833                          
 10834                          ;[[math]]
 10835                          
 10836                          
 10837  589a 9080000000         n32768           !text $90,$80,0,0,0
 10838                          
 10839                          
 10840  589f 20b458             flpint           jsr ayint
 10841  58a2 a566                                lda facmo
 10842  58a4 a467                                ldy  faclo
 10843  58a6 60                                  rts
 10844                          
 10845                          
 10846  58a7 208322             intidx           jsr chrget
 10847  58aa 20ef4c                              jsr frmevl                               ; get a number
 10848                          
 10849                          
 10850  58ad 20db4c             posint           jsr chknum
 10851  58b0 a568                                lda facsgn
 10852  58b2 300d                                bmi nonono                               ; if negative, blow him out
 10853                          
 10854                          
 10855  58b4 a563               ayint            lda facexp
 10856  58b6 c990                                cmp #$90                                 ; FAC > 32767?
 10857  58b8 900a                                bcc qintgo
 10858  58ba a99a                                lda #<n32768                             ; get address of -32768
 10859  58bc a058                                ldy #>n32768
 10860  58be 20f162                              jsr fcomp                                ; see if FAC=((x))
 10861                          
 10862  58c1 d33bf9             nonono           +lbne fcerr                              ; no, FAC is too big
 10863  58c4 836a0a             qintgo           +lbra qint                               ; go shove it
 10864                          
 10865                          
 10866                          ; Float an unsigned double byte integer
 10867                          ; Entry:  MSB in (a), LSB in (y)
 10868                          
 10869  58c7 20d758             nosflt           jsr stoint
 10870  58ca 38                                  sec                                      ; sign is positive
 10871  58cb 83120a                              +lbra floatc
 10872                          
 10873                          
 10874                          
 10875  58ce 38                 pos              sec
 10876  58cf 20f0ff                              jsr _plot                                ; get tab pos in .y
 10877                          
 10878  58d2 a900               sngflt           lda #0
 10879  58d4 8369f5                              +lbra givayf                             ; float it
 10880                          
 10881                          
 10882                          
 10883  58d7 a200               stoint           ldx #0                                   ; move int to fac & compute proper exponents
 10884  58d9 860f                                stx valtyp
 10885  58db 8564                                sta facho
 10886  58dd 8465                                sty facho+1
 10887  58df a290                                ldx #$90
 10888  58e1 60                 storts           rts
 10889                          
 10890                          
 10891                          
 10892                          ; See if we are in direct mode, and complain if so.
 10893                          
 10894  58e2 ff7efc             errdir           bbs7 runmod,storts                       ; goto error if not in run mode
 10895                          
 10896  58e5 a215                                ldx #errid                               ; input direct error code
 10897  58e7 2c                                  !text $2c
 10898                          
 10899  58e8 a21b               errguf           ldx #erruf
 10900  58ea 8363d5                              +lbra error
 10901                          
 10902                          
 10903  58ed 7f7ef1             errind           bbr7 runmod,storts                       ; goto error if not in direct mode
 10904  58f0 a222                                ldx #erroid
 10905  58f2 835bd5                              +lbra error
 10906                          
 10907                          ;.end
 10908                          
 10909                          ;[[function.userdef]]
 10910                          
 10911                          
 10912                          ; User Defined Function Code
 10913                          ;
 10914                          ; Note only single arguments are allowed to functions, and functions must
 10915                          ; be of the single line form:
 10916                          ;
 10917                          ;  DEF FNA(x)=x~2 + x-2
 10918                          ;
 10919                          ; No strings may be involved with these functions.
 10920                          ;
 10921                          ; Idea: create a simple variable entry whose first character has the MSB set.
 10922                          ; The value will be:
 10923                          ;
 10924                          ;  A text pointer to the formula
 10925                          ;  A pointer to the argument variable
 10926                          
 10927  58f5 202259             def              jsr getfnm                               ; get a pointer to the function
 10928  58f8 20e258                              jsr errdir
 10929  58fb 20584e                              jsr chkopn                               ; must have a (
 10930  58fe a980                                lda #$80
 10931  5900 8512                                sta subflg                               ; prohibit subscripted & integer variables
 10932  5902 207c4f                              jsr ptrget                               ; get pointer to argument
 10933  5905 20db4c                              jsr chknum                               ; is it a number?
 10934  5908 20554e                              jsr chkcls                               ; must have )
 10935  590b a9b2                                lda #equal_token                         ; followed by =
 10936  590d 205d4e                              jsr synchr
 10937  5910 48                                  pha
 10938  5911 a54a                                lda varpnt+1
 10939  5913 48                                  pha
 10940  5914 a549                                lda varpnt
 10941  5916 48                                  pha
 10942  5917 a53e                                lda txtptr+1
 10943  5919 48                                  pha
 10944  591a a53d                                lda txtptr
 10945  591c 48                                  pha
 10946  591d 204835                              jsr data
 10947  5920 8073                                bra deffin
 10948                          
 10949                          
 10950                          ; Subroutine to get a pointer to a function name
 10951                          
 10952  5922 a9a5               getfnm           lda #fn_token                            ; must start with fn
 10953  5924 205d4e                              jsr synchr
 10954  5927 0980                                ora #$80                                 ; put function bit on
 10955  5929 8512                                sta subflg                               ; (disallows array & integer variables)
 10956  592b 20834f                              jsr ptrgt2                               ; get pointer to function or create anew
 10957  592e 8550                                sta defpnt
 10958  5930 8451                                sty defpnt+1
 10959  5932 83a7f3                              +lbra chknum                             ; make sure it's not a string, and return
 10960                          
 10961                          
 10962  5935 202259             fndoer           jsr getfnm                               ; get the function's name
 10963  5938 a551                                lda defpnt+1
 10964  593a 48                                  pha
 10965  593b a550                                lda defpnt
 10966  593d 48                                  pha
 10967  593e 204f4e                              jsr parchk                               ; evaluate parameter
 10968  5941 20db4c                              jsr chknum
 10969  5944 68                                  pla
 10970  5945 8550                                sta defpnt
 10971  5947 68                                  pla
 10972  5948 8551                                sta defpnt+1
 10973  594a a002                                ldy #2
 10974  594c 209922                              jsr inddef                               ; get pointer to the variable
 10975  594f 8549                                sta varpnt                               ; save variable pointer
 10976  5951 aa                                  tax
 10977  5952 c8                                  iny
 10978  5953 209922                              jsr inddef
 10979  5956 f090                                beq errguf
 10980  5958 854a                                sta varpnt+1
 10981  595a c8                                  iny                                      ; since def uses only 4
 10982                          
 10983                          
 10984  595b a949               defstf           lda #varpnt
 10985  595d 20d722                              jsr lda_far_ram1
 10986  5960 48                                  pha                                      ; push it all on the stack, since we might be recursing
 10987  5961 88                                  dey
 10988  5962 10f7                                bpl defstf
 10989  5964 a44a                                ldy varpnt+1
 10990                          
 10991  5966 206262                              jsr movmf_ram1                           ; put current FAC into our argument variable
 10992  5969 a53e                                lda txtptr+1                             ; save variable pointer
 10993  596b 48                                  pha
 10994  596c a53d                                lda txtptr
 10995  596e 48                                  pha
 10996  596f 209922                              jsr inddef                               ; get pointer to function
 10997  5972 853d                                sta txtptr
 10998  5974 c8                                  iny
 10999  5975 209922                              jsr inddef
 11000  5978 853e                                sta txtptr+1
 11001  597a a54a                                lda varpnt+1                             ; save variable pointer
 11002  597c 48                                  pha
 11003  597d a549                                lda varpnt
 11004  597f 48                                  pha
 11005  5980 20d84c                              jsr frmnum                               ; evaluate variable, and check numeric
 11006  5983 68                                  pla
 11007  5984 8550                                sta defpnt
 11008  5986 68                                  pla
 11009  5987 8551                                sta defpnt+1
 11010  5989 208522                              jsr chrgot
 11011  598c d3bcd4                              +lbne snerr                              ; it didn't terminate, syntax error
 11012                          
 11013  598f 68                                  pla                                      ; restore text pointer
 11014  5990 853d                                sta txtptr
 11015  5992 68                                  pla
 11016  5993 853e                                sta txtptr+1
 11017                          
 11018  5995 a000               deffin           ldy #0
 11019  5997 68                 l151_1           pla                                      ; get old arg value off stack,
 11020  5998 da                                  phx
 11021  5999 a250                                ldx #defpnt
 11022  599b 20f022                              jsr sta_far_ram1 ;sta (defpnt),y         ; and put it back in variable
 11023  599e fa                                  plx
 11024  599f c8                                  iny
 11025  59a0 c005                                cpy #5
 11026  59a2 d0f3                                bne l151_1
 11027  59a4 60                                  rts
 11028                          
 11029                          ;.end
 11030                          ;[[function.stringmisc]]
 11031                          
 11032                          
 11033                          
 11034                          
 11035                          ; The STR$() function takes a number and gives a string with
 11036                          ; the characters the output of the number would have given.
 11037                          
 11038  59a5 20db4c             strd             jsr chknum                               ; arg has to be numeric
 11039  59a8 a000                                ldy #0
 11040  59aa 209164                              jsr foutc                                ; do its output
 11041  59ad 68                                  pla
 11042  59ae 68                                  pla
 11043                          
 11044  59af a9ff               timstr           lda #<lofbuf
 11045  59b1 a000                                ldy #>lofbuf
 11046  59b3 83d000                              +lbra strlit
 11047                          
 11048                          
 11049                          ; CHR$() creates a string which contains as its only character the PETSCII
 11050                          ; equivalent of the integer argument (#) which must be < 256.
 11051                          
 11052  59b6 206f5d             chrd             jsr conint                               ; get integer in range
 11053  59b9 da                                  phx
 11054  59ba a901                                lda #1                                   ; one-character string
 11055  59bc 207b5a                              jsr strspa                               ; get space for string
 11056  59bf a000                                ldy #0
 11057  59c1 68                                  pla
 11058                          ; phx   ;set up string bank
 11059  59c2 a264                                ldx #dsctmp+1
 11060  59c4 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
 11061                          ; plx
 11062                          
 11063  59c7 68                 chrd1            pla                                      ; get rid of "chknum" return address
 11064  59c8 68                                  pla
 11065  59c9 830501                              +lbra putnew                             ; setup FAC to point to desc
 11066                          
 11067                          
 11068                          ; The following is the LEFT$($,#) function.  It takes the leftmost # characters
 11069                          ; of the string.  If # > len of the string, it returns the whole string.
 11070                          
 11071  59cc 203e5a             leftd            jsr pream                                ; test parameters
 11072  59cf 48                                  pha                                      ; # arg
 11073  59d0 20a122                              jsr inddpt                               ; string len
 11074  59d3 8578                                sta syntmp
 11075  59d5 68                                  pla
 11076  59d6 c578                                cmp syntmp
 11077  59d8 98                                  tya                                      ; that's all there is to LEFT$
 11078                          
 11079  59d9 9005               rleft            bcc l152_1
 11080  59db 20a122                              jsr inddpt
 11081  59de aa                                  tax                                      ; put length into x
 11082  59df 98                                  tya                                      ; zero (a), the offset
 11083  59e0 48                 l152_1           pha                                      ; save offset
 11084  59e1 8a                 rleft2           txa
 11085  59e2 48                 rleft3           pha                                      ; save length
 11086  59e3 207b5a                              jsr strspa                               ; get space
 11087  59e6 a552                                lda dscpnt
 11088  59e8 a453                                ldy dscpnt+1
 11089  59ea 20715b                              jsr fretmp
 11090  59ed 7a                                  ply
 11091  59ee 68                                  pla
 11092  59ef 18                                  clc
 11093  59f0 6524                                adc index                                ; compute where to copy
 11094  59f2 8524                                sta index
 11095  59f4 9002                                bcc l153_1
 11096  59f6 e625                                inc index+1
 11097  59f8 98                 l153_1           tya
 11098  59f9 204a5b                              jsr movdo                                ; go move it
 11099  59fc 83d200                              +lbra putnew
 11100                          
 11101                          
 11102                          
 11103  59ff 203e5a             rightd           jsr pream
 11104  5a02 48                                  pha
 11105  5a03 20a122                              jsr inddpt
 11106  5a06 8578                                sta syntmp
 11107  5a08 68                                  pla
 11108  5a09 18                                  clc                                      ; (length des'd)-(length)-1
 11109  5a0a e578                                sbc syntmp
 11110  5a0c 49ff                                eor #$ff                                 ; negate
 11111  5a0e 80c9                                bra rleft
 11112                          
 11113                          
 11114                          ; MID$($,#) returns string with chars from # position onward. If # > LEN($)
 11115                          ; then return null string.  MID($,#,#) returns string with characters from
 11116                          ; # position for #2 characters.  If #2 goes past end of string return as much
 11117                          ; as possible.
 11118                          
 11119  5a10 a9ff               midd             lda #255                                 ; default
 11120  5a12 8567                                sta faclo                                ; save for later compare
 11121  5a14 208522                              jsr chrgot                               ; get current character
 11122  5a17 c929                                cmp #')'                                 ; is it a right paren )?
 11123  5a19 f003                                beq l154_1                               ; no third paren.
 11124                          ; jsr chkcom  ;must have comma
 11125                          ; jsr getbyt  ;get the length into "faclo"
 11126  5a1b 20825d                              jsr combyt                               ; [910820]
 11127                          
 11128  5a1e 203e5a             l154_1           jsr pream                                ; check it out
 11129  5a21 f3dbf7                              +lbeq fcerr                              ; illegal qty error
 11130  5a24 ca                                  dex                                      ; compute offset
 11131  5a25 da                                  phx
 11132  5a26 da                                  phx                                      ; preserve a while (2 copies)
 11133  5a27 a200                                ldx #0
 11134  5a29 20a122                              jsr inddpt                               ; get length of what's left
 11135  5a2c 8578                                sta syntmp
 11136  5a2e 68                                  pla
 11137  5a2f 18                                  clc
 11138  5a30 e578                                sbc syntmp
 11139  5a32 b0ad                                bcs rleft2                               ; give null string
 11140  5a34 49ff                                eor #$ff                                 ; in sub c was 0 so just complement
 11141  5a36 c567                                cmp faclo                                ; greater than what's desired
 11142  5a38 90a8                                bcc rleft3                               ; no, just copy that much
 11143  5a3a a567                                lda faclo                                ; get length of what's desired
 11144  5a3c b0a4                                bcs rleft3                               ; copy it
 11145                          
 11146                          
 11147                          
 11148                          
 11149                          ; Common routine used by RIGHT$, LEFT$, MID$, for parameter chk and setup.
 11150                          
 11151  5a3e 20554e             pream            jsr chkcls                               ; param list should end
 11152  5a41 7a                                  ply
 11153  5a42 68                                  pla
 11154  5a43 8557                                sta jmper+1                              ; get return address
 11155  5a45 68                                  pla                                      ; get rid of fingo's jsr ret addr
 11156  5a46 68                                  pla
 11157  5a47 fa                                  plx                                      ; get length
 11158  5a48 68                                  pla
 11159  5a49 8552                                sta dscpnt
 11160  5a4b 68                                  pla
 11161  5a4c 8553                                sta dscpnt+1
 11162  5a4e a557                                lda jmper+1
 11163  5a50 48                                  pha
 11164  5a51 5a                                  phy
 11165  5a52 a000                                ldy #0
 11166  5a54 8a                                  txa
 11167  5a55 60                                  rts
 11168                          
 11169                          
 11170                          
 11171                          ; The function LEN$() returns the length of the string passed as an argument.
 11172                          
 11173  5a56 630400             len              bsr len1
 11174  5a59 8377fe                              +lbra sngflt
 11175                          
 11176  5a5c 206a5b             len1             jsr frestr                               ; free up string
 11177  5a5f a200                                ldx #0
 11178  5a61 860f                                stx valtyp                               ; force numeric
 11179  5a63 a8                                  tay                                      ; set condition codes
 11180  5a64 60                                  rts                                      ; done
 11181                          
 11182                          
 11183                          
 11184                          
 11185                          
 11186                          ; The following is the ASC$() function.  It returns an integer which is the
 11187                          ; decimal equivalent of the PETSCII string argument.
 11188                          
 11189  5a65 205c5a             asc              jsr len1
 11190  5a68 f006                                beq l155_1                               ; it was null (zero length)
 11191  5a6a a000                                ldy #0
 11192  5a6c 20d522                              jsr indin1_ram1                          ; get 1st character
 11193  5a6f a8                                  tay
 11194  5a70 8360fe             l155_1           +lbra sngflt
 11195                          
 11196                          ;.end
 11197                          
 11198                          
 11199                          
 11200                          
 11201                          
 11202                          ; STRINI gets string space for the creation of a string and creates
 11203                          ; a descriptor for it in DSCTMP.
 11204                          
 11205                          strini
 11206  5a73 a666                                ldx facmo                                ; get facmo to store in dscpnt
 11207  5a75 a467                                ldy facmo+1
 11208  5a77 8652                                stx dscpnt                               ; retain the descriptor pointer
 11209  5a79 8453                                sty dscpnt+1
 11210                          
 11211  5a7b 20dd5b             strspa           jsr getspa                               ; get string space
 11212  5a7e 8664                                stx dsctmp+1                             ; save location
 11213  5a80 8465                                sty dsctmp+2
 11214  5a82 8563                                sta dsctmp                               ; save length
 11215  5a84 60                                  rts                                      ; done
 11216                          
 11217                          
 11218                          ; STRLT2 takes the string literal whose first character is pointed to by
 11219                          ; (xreg)+1 and builds a descriptor for it.  The descriptor is initially
 11220                          ; built in DSCTMP, but PUTNEW transfers it into a temporary and leaves a
 11221                          ; pointer to the temporary in FACMO & FACLO.  The characters other than the
 11222                          ; zero that terminates the string should be set up in CHARAC and ENDCHR.
 11223                          ; If the terminator is a quote, the quote is skipped over.  Leading quotes
 11224                          ; should be skipped before call.  On return, the character after the string
 11225                          ; literal is pointed to by (strng2).
 11226                          
 11227                          
 11228  5a85 a222               strlit           ldx #'"'                                 ; assume string ends on quote
 11229  5a87 860a                                stx charac
 11230  5a89 860b                                stx endchr
 11231                          
 11232  5a8b 8570               strlt2           sta strng1                               ; save pointer to string
 11233  5a8d 8471                                sty strng1+1
 11234  5a8f 8564                                sta dsctmp+1                             ; in case no strcpy
 11235  5a91 8465                                sty dsctmp+2
 11236                          
 11237  5a93 a0ff                                ldy #255                                 ; initialize character count
 11238  5a95 c8                 strget           iny
 11239  5a96 20b122                              jsr indst1                               ; get character
 11240  5a99 f00c                                beq l156_2                               ; if zero
 11241  5a9b c50a                                cmp charac                               ; this terminator?
 11242  5a9d f004                                beq l156_1                               ; yes
 11243  5a9f c50b                                cmp endchr
 11244  5aa1 d0f2                                bne strget                               ; look further
 11245                          
 11246  5aa3 c922               l156_1           cmp #'"'                                 ; strfin.  quote?
 11247  5aa5 f001                                beq l156_3
 11248                          
 11249  5aa7 18                 l156_2           clc
 11250  5aa8 8463               l156_3           sty dsctmp                               ; no, back up. retain count
 11251  5aaa 98                                  tya
 11252  5aab 6570                                adc strng1                               ; wishing to set (txtptr)
 11253  5aad 8572                                sta strng2
 11254  5aaf a671                                ldx strng1+1
 11255  5ab1 9001                                bcc l156_4
 11256  5ab3 e8                                  inx
 11257  5ab4 8673               l156_4           stx strng2+1
 11258  5ab6 98                                  tya
 11259                          
 11260                          
 11261                          strlit_1                                                  ; //// entry from SPRSAV
 11262  5ab7 20735a                              jsr strini
 11263  5aba a8                                  tay
 11264  5abb f013                                beq putnew                               ; length=0, don't bother copying
 11265  5abd 48                                  pha                                      ; save length
 11266  5abe da                                  phx
 11267  5abf a237                                ldx #frespc
 11268  5ac1 88                 l157_1           dey
 11269  5ac2 20b122                              jsr indst1                               ; lda (strng1),y in bank 0
 11270  5ac5 20f022                              jsr sta_far_ram1                         ; sta (frespc),y in bank 1
 11271  5ac8 98                                  tya
 11272  5ac9 d0f6                                bne l157_1
 11273  5acb fa                                  plx
 11274  5acc 68                                  pla                                      ; restore length
 11275  5acd 205d5b                              jsr mvdone                               ; finish up by updating frespc
 11276                          
 11277                          
 11278                          ; Some string function is returning a result in DSCTMP.  Set up a temp
 11279                          ; descriptor with DSCTMP in it.  Put a pointer to the descriptor in FACMO&LO
 11280                          ; and flag the result as a string type.
 11281                          
 11282  5ad0 a618               putnew           ldx temppt                               ; pointer to first free temp
 11283  5ad2 e024                                cpx #tempst+strsiz+strsiz+strsiz
 11284  5ad4 f314f2                              +lbeq sterr                              ; string temporary error
 11285                          
 11286  5ad7 a563                                lda dsctmp                               ; length
 11287  5ad9 9500                                sta 0,x
 11288  5adb a564                                lda dsctmp+1                             ; pointer to string lo
 11289  5add 9501                                sta 1,x
 11290  5adf a565                                lda dsctmp+2                             ; hi
 11291  5ae1 9502                                sta 2,x
 11292                          
 11293  5ae3 a000                                ldy #0                                   ; pointer to temp. descriptor
 11294  5ae5 8666                                stx facmo                                ; lo
 11295  5ae7 8467                                sty facmo+1                              ; hi
 11296  5ae9 8471                                sty facov
 11297  5aeb 88                                  dey                                      ; ($ff)
 11298  5aec 840f                                sty valtyp                               ; type is string
 11299  5aee 8619                                stx lastpt                               ; set pointer to last-used temp
 11300                          
 11301  5af0 e8                                  inx
 11302  5af1 e8                                  inx
 11303  5af2 e8                                  inx                                      ; point further
 11304  5af3 8618                                stx temppt                               ; save pointer to next temp, if any
 11305  5af5 60                                  rts                                      ; all done
 11306                          
 11307                          
 11308                          ; The following routine concatenates two strings.  At this point, the FAC
 11309                          ; contains the first one and (txtptr) points to the + sign.
 11310                          
 11311  5af6 a567               cat              lda faclo                                ; push high order onto stack
 11312  5af8 48                                  pha
 11313  5af9 a566                                lda facmo                                ; and the low
 11314  5afb 48                                  pha
 11315  5afc 20e24d                              jsr eval                                 ; can come back here since operator is known
 11316  5aff 20dd4c                              jsr chkstr                               ; must be string
 11317  5b02 68                                  pla
 11318  5b03 8570                                sta strng1                               ; get high order of old descriptor
 11319  5b05 68                                  pla
 11320  5b06 8571                                sta strng1+1
 11321  5b08 a000                                ldy #0
 11322  5b0a 20b522                              jsr indst1_ram1                          ; get length of old string
 11323  5b0d 8578                                sta syntmp
 11324  5b0f 20a922                              jsr indfmo
 11325  5b12 18                                  clc
 11326  5b13 6578                                adc syntmp
 11327  5b15 b3591b                              +lbcs errlen                             ; result >255, error "long string"
 11328                          
 11329  5b18 20735a                              jsr strini                               ; sizeok.  initialize string
 11330  5b1b 20355b                              jsr movins                               ; move it
 11331  5b1e a552                                lda dscpnt                               ; get pointer to second
 11332  5b20 a453                                ldy dscpnt+1
 11333  5b22 20715b                              jsr fretmp                               ; free it
 11334  5b25 204a5b                              jsr movdo                                ; move second string
 11335  5b28 a570                                lda strng1
 11336  5b2a a471                                ldy strng1+1
 11337  5b2c 20715b                              jsr fretmp
 11338  5b2f 20d05a                              jsr putnew
 11339  5b32 83cef1                              +lbra tstop                              ; "cat" reenters frmevl from tstop
 11340                          
 11341                          
 11342  5b35 a000               movins           ldy #0                                   ; get address of string
 11343  5b37 20b522                              jsr indst1_ram1
 11344  5b3a 48                                  pha
 11345  5b3b c8                                  iny
 11346  5b3c 20b522                              jsr indst1_ram1
 11347  5b3f aa                                  tax
 11348  5b40 c8                                  iny
 11349  5b41 20b522                              jsr indst1_ram1
 11350  5b44 a8                                  tay
 11351  5b45 68                                  pla
 11352                          
 11353  5b46 8624               movstr           stx index                                ; adr in (x,y), len in a
 11354  5b48 8425                                sty index+1
 11355                          
 11356  5b4a a8                 movdo            tay
 11357  5b4b f010                                beq mvdone
 11358                          
 11359  5b4d 48                                  pha
 11360  5b4e da                                  phx
 11361  5b4f a237                                ldx #frespc
 11362  5b51 88                 l158_1           dey
 11363  5b52 20d522                              jsr indin1_ram1
 11364  5b55 20f022                              jsr sta_far_ram1                         ; sta (frespc),y
 11365  5b58 98                                  tya
 11366  5b59 d0f6                                bne l158_1
 11367  5b5b fa                                  plx
 11368  5b5c 68                                  pla
 11369                          
 11370  5b5d 18                 mvdone           clc                                      ; update frespc pointer
 11371  5b5e 6537                                adc frespc
 11372  5b60 8537                                sta frespc
 11373  5b62 9002                                bcc l159_1
 11374  5b64 e638                                inc frespc+1
 11375  5b66 60                 l159_1           rts
 11376                          
 11377                          
 11378                          ;[[string.manager]]
 11379                          ; FRETMP is passed a string descriptor pntr in (a,y).  A check is made to see
 11380                          ; if the string descriptor points to the last temporary descriptor allocated by
 11381                          ; putnew.  If so, the temporary is freed up by the updating of (temppt).  If a
 11382                          ; string is freed up, a further check sees if it was the last one created and if
 11383                          ; so, (fretop) is updated to reflect the fact that the space is no longer in use.
 11384                          ; The address of the actual string is returned in (x,y) and its length in (a).
 11385                          
 11386  5b67 20ef4c             frmstr           jsr frmevl
 11387                          
 11388  5b6a 20dd4c             frestr           jsr chkstr                               ; make sure it's a string
 11389  5b6d a566               frefac           lda facmo                                ; free up string pointed to by FAC
 11390  5b6f a467                                ldy facmo+1
 11391  5b71 8524               fretmp           sta index                                ; get length for later
 11392  5b73 8425                                sty index+1
 11393  5b75 20cc5b                              jsr fretms                               ; check desc. if last
 11394  5b78 d03c                                bne l160_3                               ; one then scratch it
 11395  5b7a 206737                              jsr stradj                               ; index points to link
 11396  5b7d 9037                                bcc l160_3                               ; literal no fix
 11397                          
 11398  5b7f da                                  phx                                      ; .x=length
 11399  5b80 88                                  dey                                      ; .y=1
 11400  5b81 a224                                ldx #index
 11401  5b83 a9ff                                lda #$ff                                 ; flag string as garbage
 11402  5b85 20f022                              jsr sta_far_ram1                         ; sta (index),y
 11403  5b88 68                                  pla
 11404  5b89 48                                  pha                                      ; get length, but leave copy on stack
 11405  5b8a 88                                  dey
 11406  5b8b a224                                ldx #index
 11407  5b8d 20f022                              jsr sta_far_ram1 ;sta (index),y          ; put in length
 11408                          
 11409  5b90 49ff                                eor #$ff                                 ; put index back
 11410  5b92 38                                  sec                                      ; to first byte
 11411  5b93 6524                                adc index
 11412  5b95 a425                                ldy index+1
 11413  5b97 b001                                bcs l160_1
 11414  5b99 88                                  dey
 11415  5b9a 8524               l160_1           sta index
 11416  5b9c 8425                                sty index+1
 11417                          
 11418  5b9e aa                                  tax                                      ; lo into x
 11419  5b9f 68                                  pla                                      ; pull length from stack
 11420  5ba0 c436                                cpy fretop+1                             ; = to fretop?
 11421  5ba2 d038                                bne frerts
 11422  5ba4 e435                                cpx fretop
 11423  5ba6 d034                                bne frerts
 11424                          
 11425                          
 11426                          ; The string was the last one put into string space.  Save garbage
 11427                          ; collection some time by freeing up. (length + 2)
 11428                          
 11429  5ba8 48                                  pha                                      ; save length on stack
 11430  5ba9 38                                  sec                                      ; plus one
 11431  5baa 6535                                adc fretop
 11432  5bac 8535                                sta fretop
 11433  5bae 9002                                bcc l160_2
 11434  5bb0 e636                                inc fretop+1
 11435  5bb2 e335               l160_2           inw fretop                               ; + one more
 11436  5bb4 68                                  pla                                      ; pull length off stack
 11437  5bb5 60                                  rts
 11438                          
 11439                          
 11440  5bb6 a000               l160_3           ldy #0                                   ; set up x,y,a and index
 11441  5bb8 20d522                              jsr indin1_ram1                          ; length
 11442  5bbb 48                                  pha                                      ; on stack
 11443  5bbc c8                                  iny
 11444  5bbd 20d522                              jsr indin1_ram1                          ; pointer lo
 11445  5bc0 aa                                  tax
 11446  5bc1 c8                                  iny
 11447  5bc2 20d522                              jsr indin1_ram1                          ; pointer hi
 11448  5bc5 a8                                  tay
 11449  5bc6 8624                                stx index
 11450  5bc8 8425                                sty index+1
 11451  5bca 68                                  pla                                      ; get back length
 11452  5bcb 60                                  rts
 11453                          
 11454                          
 11455                          
 11456  5bcc c41a               fretms           cpy lastpt+1                             ; last entry to temp?
 11457  5bce d00c                                bne frerts
 11458  5bd0 c519                                cmp lastpt
 11459  5bd2 d008                                bne frerts
 11460  5bd4 8518                                sta temppt
 11461  5bd6 e903                                sbc #strsiz                              ; point to lst one
 11462  5bd8 8519                                sta lastpt                               ; update temp pointer
 11463  5bda a000                                ldy #0                                   ; also clears zflg so we do rest of fretmp
 11464  5bdc 60                 frerts           rts                                      ; all done
 11465                          
 11466                          ;.end
 11467                          ;[[string.garbage]]
 11468                          
 11469                          
 11470                          
 11471                          ;  Get space for a string, perhaps forcing garbage collection.
 11472                          ;
 11473                          ;  Entry:  a = # of chars
 11474                          ;  Exit:   (x,y) pointer to space, otherwise
 11475                          ;          blows off to 'out of string space' error
 11476                          ;          (also preserves .a and sets frespc= y,x = -> at space.)
 11477                          
 11478                          
 11479  5bdd 4611               getspa           lsr garbfl                               ; signal no garbage collection yet
 11480                          
 11481  5bdf aa                 tryag2           tax                                      ; save in x also
 11482  5be0 f042                                beq getrts                               ; length of 0 no go...
 11483  5be2 48                                  pha                                      ; save a (length) on stack
 11484  5be3 a535                                lda fretop                               ; lo byte
 11485  5be5 38                                  sec                                      ; for subtract
 11486  5be6 e902                                sbc #2                                   ; minus 2 (link bytes)
 11487  5be8 a436                                ldy fretop+1
 11488  5bea b001                                bcs l161_1
 11489  5bec 88                                  dey
 11490  5bed 8524               l161_1           sta index1                               ; save for later
 11491  5bef 8425                                sty index1+1
 11492  5bf1 8a                                  txa
 11493  5bf2 49ff                                eor #$ff
 11494  5bf4 38                                  sec
 11495  5bf5 6524                                adc index1
 11496  5bf7 b001                                bcs l161_2
 11497  5bf9 88                                  dey
 11498  5bfa c434               l161_2           cpy strend+1
 11499  5bfc 9027                                bcc garbag
 11500  5bfe d004                                bne strfre
 11501  5c00 c533                                cmp strend
 11502  5c02 9021                                bcc garbag                               ; clean up
 11503                          
 11504                          
 11505  5c04 8537               strfre           sta frespc
 11506  5c06 8438                                sty frespc+1
 11507  5c08 a001                                ldy #1                                   ; flag string as garbage
 11508  5c0a a9ff                                lda #$ff
 11509  5c0c da                                  phx                                      ; set up string bank
 11510  5c0d a224                                ldx #index1
 11511  5c0f 20f022                              jsr sta_far_ram1 ;sta (index1),y         ; flag
 11512  5c12 fa                                  plx
 11513  5c13 88                                  dey
 11514  5c14 68                                  pla                                      ; length
 11515  5c15 da                                  phx                                      ; set up string bank
 11516  5c16 a224                                ldx #index1
 11517  5c18 20f022                              jsr sta_far_ram1 ;sta (index1),y         ; length
 11518  5c1b fa                                  plx
 11519  5c1c a637                                ldx frespc
 11520  5c1e a438                                ldy frespc+1
 11521  5c20 8635                                stx fretop
 11522  5c22 8436                                sty fretop+1                             ; save new (fretop)
 11523  5c24 60                 getrts           rts
 11524                          
 11525                          
 11526  5c25 a511               garbag           lda garbfl
 11527  5c27 3318d2                              +lbmi omerr                              ; if out of memory
 11528  5c2a 20335c                              jsr garba2
 11529  5c2d 38                                  sec
 11530  5c2e 6611                                ror garbfl
 11531  5c30 68                                  pla                                      ; get back string length
 11532  5c31 80ac                                bra tryag2                               ; always branches
 11533                          
 11534                          
 11535                          
 11536                          ; Routine looks for and squashes out any unused string space it finds, thus
 11537                          ; returning the space for future use by the string routines.  GARBA2 is called
 11538                          ; only when BASIC needs space or the FRE() function is used.
 11539                          
 11540                          
 11541  5c33 a618               garba2           ldx temppt                               ; ptr to temp. strings
 11542  5c35 e01b               l162_1           cpx #tempst                              ; any out there?
 11543  5c37 f016                                beq l162_2                               ; none
 11544  5c39 20505d                              jsr slr1                                 ; setup ptr (tempf2) to temp. string's bkptr
 11545  5c3c f0f7                                beq l162_1                               ; (skip if null string!)
 11546  5c3e 8a                                  txa                                      ; .x = lsb of ptr to descriptor
 11547  5c3f da                                  phx                                      ; set up string bank
 11548  5c40 a25e                                ldx #tempf2
 11549  5c42 a000                                ldy #0
 11550  5c44 20f022                              jsr sta_far_ram1 ;(tempf2),y             ; place backpointer on string to temp. descr
 11551  5c47 98                                  tya                                      ; .a = msb of ptr (0)
 11552  5c48 c8                                  iny
 11553  5c49 20f022                              jsr sta_far_ram1                         ; (tempf2),y
 11554  5c4c fa                                  plx
 11555  5c4d 80e6                                bra l162_1                               ; always
 11556                          
 11557                          
 11558  5c4f a000               l162_2           ldy #0                                   ; set up flag
 11559  5c51 845a                                sty highds
 11560  5c53 a639                                ldx max_mem_1
 11561  5c55 a43a                                ldy max_mem_1+1
 11562  5c57 8661                                stx grbtop                               ; set both pointers
 11563  5c59 8650                                stx grbpnt
 11564  5c5b 8637                                stx frespc
 11565  5c5d 8462                                sty grbtop+1
 11566  5c5f 8451                                sty grbpnt+1
 11567  5c61 8438                                sty frespc+1
 11568  5c63 8a                                  txa
 11569                          
 11570                          
 11571                          ; do while (grbpnt <= fretop)
 11572                          
 11573  5c64 20de5c             gloop            jsr chkgrb                               ; check garbage string
 11574  5c67 d00c                                bne l163_2                               ; if not garbage
 11575                          
 11576  5c69 88                 l163_1           dey                                      ; back up to length
 11577  5c6a 20b922                              jsr indgrb
 11578  5c6d 20325d                              jsr movpnt                               ; move grbpnt to next
 11579  5c70 38                                  sec
 11580  5c71 665a                                ror highds                               ; indicate garbage string found
 11581  5c73 80ef                                bra gloop                                ; always
 11582                          
 11583  5c75 245a               l163_2           bit highds
 11584  5c77 1052                                bpl l163_6                               ; if garbage string not found
 11585  5c79 a200                                ldx #0
 11586  5c7b 865a                                stx highds                               ; clear indicator
 11587                          
 11588  5c7d a902                                lda #2                                   ; skip pointers past
 11589                          
 11590                          ; Move a string over garbage
 11591                          
 11592  5c7f da                 l163_3           phx
 11593  5c80 a261                                ldx #grbtop
 11594  5c82 a001                                ldy #1                                   ; move the link bytes
 11595  5c84 20b922                              jsr indgrb
 11596  5c87 20f022                              jsr sta_far_ram1                         ; sta (grbtop),y
 11597  5c8a 88                                  dey
 11598  5c8b 20b922                              jsr indgrb
 11599  5c8e 20f022                              jsr sta_far_ram1                         ; sta (grbtop),y
 11600  5c91 fa                                  plx
 11601                          
 11602  5c92 20d522                              jsr indin1_ram1
 11603  5c95 aa                                  tax
 11604  5c96 20415d                              jsr movtop                               ; move top pointer
 11605  5c99 8537                                sta frespc                               ; save in frespc
 11606  5c9b 8438                                sty frespc+1
 11607  5c9d 8a                                  txa
 11608  5c9e 20325d                              jsr movpnt                               ; move grbpnt
 11609  5ca1 8a                                  txa                                      ; put length-1 in .y
 11610  5ca2 a8                                  tay
 11611                          
 11612  5ca3 88                 l163_4           dey
 11613  5ca4 20b922                              jsr indgrb
 11614  5ca7 da                                  phx
 11615  5ca8 a261                                ldx #grbtop
 11616  5caa 20f022                              jsr sta_far_ram1                         ; sta (grbtop),y
 11617  5cad fa                                  plx
 11618  5cae ca                                  dex
 11619  5caf d0f2                                bne l163_4
 11620                          
 11621  5cb1 a002                                ldy #2                                   ; fix the descriptor
 11622  5cb3 da                                  phx
 11623  5cb4 a224                                ldx #index1
 11624  5cb6 b96000             l163_5           lda grbtop-1,y
 11625  5cb9 20f022                              jsr sta_far_ram1                         ; sta (index1),y
 11626  5cbc 88                                  dey
 11627  5cbd d0f7                                bne l163_5
 11628  5cbf fa                                  plx
 11629                          
 11630  5cc0 a550                                lda grbpnt                               ; check pointer
 11631  5cc2 a451                                ldy grbpnt+1
 11632  5cc4 20de5c                              jsr chkgrb                               ; check garbage string
 11633  5cc7 f0a0                                beq l163_1                               ; if garbage found
 11634  5cc9 d0b4                                bne l163_3                               ; always
 11635                          
 11636  5ccb a000               l163_6           ldy #0                                   ; skip over good strings
 11637  5ccd 20d522                              jsr indin1_ram1
 11638  5cd0 aa                                  tax
 11639  5cd1 20415d                              jsr movtop
 11640  5cd4 8537                                sta frespc
 11641  5cd6 8438                                sty frespc+1
 11642  5cd8 8a                                  txa
 11643  5cd9 20325d                              jsr movpnt
 11644  5cdc 8086                                bra gloop
 11645                          
 11646                          ;[[string.garbage.utils]]
 11647                          
 11648                          ; Subroutines used for garbage collection.
 11649                          ;
 11650                          ;  Compare for (y,a) = fretop.
 11651                          ; Entry  (y,a) = address of current string descriptor.
 11652                          ; Exits to caller if (y,a) = fretop, else z flag set if garbage string.
 11653                          ;      z flag clear if not garbage string.
 11654                          ; In either case pointers are setup for next loop and string movement.
 11655                          ; If carry clear (y,a) <= fretop
 11656                          
 11657                          
 11658  5cde c436               chkgrb           cpy fretop+1                             ; end of strings?
 11659  5ce0 9029                                bcc l164_5
 11660  5ce2 d006                                bne l164_1                               ; if not equal
 11661  5ce4 c535                                cmp fretop
 11662  5ce6 f023                                beq l164_5
 11663  5ce8 9021                                bcc l164_5
 11664                          
 11665  5cea 245a               l164_1           bit highds                               ; check flag
 11666  5cec 3005                                bmi l164_2                               ; if empty string found
 11667  5cee a902                                lda #2                                   ; skip pointers past
 11668  5cf0 20415d                              jsr movtop                               ; move top pointer
 11669                          
 11670  5cf3 a902               l164_2           lda #2                                   ; skip pointers past
 11671  5cf5 20325d                              jsr movpnt                               ; move pointers
 11672  5cf8 a001                                ldy #1
 11673  5cfa 20b922                              jsr indgrb                               ; garbage?
 11674  5cfd c9ff                                cmp #$ff
 11675  5cff f009                                beq l164_4                               ; yes
 11676                          
 11677  5d01 20b922             l164_3           jsr indgrb                               ; to link bytes
 11678  5d04 992400                              sta index1,y
 11679  5d07 88                                  dey
 11680  5d08 10f7                                bpl l164_3                               ; if two bytes not moved
 11681  5d0a 60                 l164_4           rts
 11682                          
 11683                          
 11684  5d0b a618               l164_5           ldx temppt                               ; ptr to temp. strings
 11685                          
 11686  5d0d e01b               l164_6           cpx #tempst                              ; any out there?
 11687  5d0f f016                                beq l164_7                               ; no
 11688  5d11 20505d                              jsr slr1                                 ; setup ptr (tempf2) to temp. string's bkptr.
 11689  5d14 f0f7                                beq l164_6                               ; (skip if null string!)
 11690  5d16 da                                  phx
 11691  5d17 a25e                                ldx #tempf2
 11692  5d19 a000                                ldy #0                                   ; .a = string length
 11693  5d1b 20f022                              jsr sta_far_ram1 ;sta (tempf2),y         ; remove backpointer built at garba2
 11694  5d1e c8                                  iny
 11695  5d1f a9ff                                lda #$ff
 11696  5d21 20f022                              jsr sta_far_ram1 ;sta (tempf2),y         ; and mark as garbage
 11697  5d24 fa                                  plx
 11698  5d25 80e6                                bra l164_6                               ; always
 11699                          
 11700  5d27 68                 l164_7           pla                                      ; throw away return address
 11701  5d28 68                                  pla
 11702  5d29 a537                                lda frespc                               ; fix fretop and frespc
 11703  5d2b a438                                ldy frespc+1
 11704  5d2d 8535                                sta fretop
 11705  5d2f 8436                                sty fretop+1
 11706  5d31 60                                  rts
 11707                          
 11708                          
 11709  5d32 49ff               movpnt           eor #$ff                                 ; comp and add
 11710  5d34 38                                  sec
 11711  5d35 6550                                adc grbpnt
 11712  5d37 a451                                ldy grbpnt+1
 11713  5d39 b001                                bcs l165_1
 11714  5d3b 88                                  dey
 11715  5d3c 8550               l165_1           sta grbpnt
 11716  5d3e 8451                                sty grbpnt+1
 11717  5d40 60                                  rts
 11718                          
 11719                          
 11720                          
 11721  5d41 49ff               movtop           eor #$ff                                 ; comp and add
 11722  5d43 38                                  sec
 11723  5d44 6561                                adc grbtop
 11724  5d46 a462                                ldy grbtop+1
 11725  5d48 b001                                bcs l166_1
 11726  5d4a 88                                  dey
 11727  5d4b 8561               l166_1           sta grbtop
 11728  5d4d 8462                                sty grbtop+1
 11729  5d4f 60                                  rts
 11730                          
 11731                          
 11732                          
 11733  5d50 ca                 slr1             dex                                      ; .x = ptr to temp. string descriptor
 11734  5d51 b500                                lda 0,x                                  ; msb of ptr to string
 11735  5d53 855f                                sta tempf2+1
 11736  5d55 ca                                  dex
 11737  5d56 b500                                lda 0,x                                  ; lsb of ptr to string
 11738  5d58 855e                                sta tempf2
 11739  5d5a ca                                  dex
 11740  5d5b b500                                lda 0,x                                  ; string length
 11741  5d5d 48                                  pha                                      ; save for later test
 11742  5d5e 18                                  clc
 11743  5d5f 655e                                adc tempf2                               ; want ptr to string's backpointer
 11744  5d61 855e                                sta tempf2
 11745  5d63 9002                                bcc l167_1
 11746  5d65 e65f                                inc tempf2+1
 11747  5d67 68                 l167_1           pla   ;.a=len & set z flag               ; .x=next desc. ptr
 11748  5d68 60                                  rts
 11749                          
 11750                          ;.end
 11751                          ;[[math.ext2]]
 11752                          
 11753                          
 11754                          
 11755  5d69 208322             gtbytc           jsr chrget
 11756                          
 11757  5d6c 20d84c             getbyt           jsr frmnum                               ; read formula into FAC
 11758                          
 11759  5d6f 20ad58             conint           jsr posint                               ; convert the FAC to a single byte int
 11760  5d72 a666                                ldx facmo
 11761  5d74 d388f4                              +lbne fcerr                              ; result must be <= 255
 11762  5d77 a667                                ldx faclo
 11763  5d79 4c8522                              jmp chrgot                               ; set condition codes on terminator
 11764                          
 11765                          
 11766                          getnum                                                    ; get 2-byte value in y,a: check for a comma, get 1 byte val in x
 11767  5d7c 20d84c                              jsr frmnum                               ; get address
 11768  5d7f 208d5d                              jsr getadr                               ; get that location
 11769                          
 11770                          combyt                                                    ; check for a comma, get a 1 byte value in x
 11771  5d82 205b4e                              jsr chkcom                               ; check for comma
 11772  5d85 80e5                                bra getbyt                               ; get something to store and return
 11773                          
 11774                          
 11775  5d87 205b4e             comwrd           jsr chkcom
 11776                          
 11777  5d8a 20d84c             getwrd           jsr frmnum                               ; get an unsigned 2-byte value in y,a
 11778                          
 11779  5d8d a568               getadr           lda facsgn                               ; for this entry, value can't be < 0
 11780  5d8f 336df4                              +lbmi fcerr                              ; function call error
 11781                          
 11782                          getsad                                                    ; get a signed 2-byte value in (y,a), ///entry from sprcor
 11783  5d92 a563                                lda facexp                               ; examine exponent
 11784  5d94 c991                                cmp #145
 11785  5d96 b366f4                              +lbcs fcerr                              ; function call error
 11786  5d99 203063                              jsr qint                                 ; integerize it
 11787  5d9c a566                                lda facmo
 11788  5d9e a467                                ldy facmo+1
 11789  5da0 8416                                sty poker
 11790  5da2 8517                                sta poker+1
 11791  5da4 60                                  rts                                      ; it's all done
 11792                          
 11793                          ;.end
 11794                          ;[[math.ext3]]
 11795                          
 11796                          
 11797                          
 11798                          ; Floating Point Math Package configuration:
 11799                          ;
 11800                          ; Throughout the math package the floating point format is as follows:
 11801                          ;
 11802                          ; the sign of the first bit of the mantissa.
 11803                          ; the mantissa is 24 bits long.
 11804                          ; the binary point is to the left of the msb.
 11805                          ; number = mantissa * 2 ~ exponent.
 11806                          ; the mantissa is positive with a 1 assumed to be where the sign bit is.
 11807                          ; the sign of the exponent is the first bit of the exponent.
 11808                          ; the exponent is stored in excess $80, i.e., with a bias of +$80.
 11809                          ; so, the exponent is a signed 8 bit number with $80 added to it.
 11810                          ; an exponent of zero means the number is zero.
 11811                          ; the other bytes may not be assumed to be zero.
 11812                          ; to keep the same number in the fac while shifting,
 11813                          ; to shift right, exp:=exp+1.
 11814                          ; to shift left,  exp:=exp-1.
 11815                          ;
 11816                          ; In memory the number looks like this:
 11817                          ; the exponent as a signed number +$80.
 11818                          ; the sign bit in 7, bits 2-8 of mantissa are bits 6-0.
 11819                          ;  remember bit 1 of mantissa is always a one.
 11820                          ; bits 9-16 of the mantissa.
 11821                          ; bits 17-24 of the mantisa.
 11822                          ;
 11823                          ; Arithmetic routine calling conventions:
 11824                          ;
 11825                          ;   For one-argument functions:
 11826                          ; the argument is in the fac.
 11827                          ; the result is left in the fac.
 11828                          ;   For two-argument operations:
 11829                          ; the first argument is in arg (argexp,ho,mo,lo and argsgn).
 11830                          ;       the second argument is in the fac.
 11831                          ; the result is left in the fac.
 11832                          ;
 11833                          ; The "t" entry points to the two argument operations have both arguments setup
 11834                          ; in the respective registers. Before calling arg may have been popped off the
 11835                          ; stack and into arg, for example. The other entry point assumes (xreg) points
 11836                          ; to the argument somewhere in memory. it is unpacked into arg by "conupk".
 11837                          ;
 11838                          ; On the stack, the sgn is pushed on first, the lo,mo,ho, and finally exp.
 11839                          ; Note all things are kept unpacked in arg, fac and on the stack.
 11840                          ;
 11841                          ; It is only when something is stored away that it is packed to four bytes,
 11842                          ; the unpacked format has a sn byte reflecting the sign of the ho turned on.
 11843                          ; The exp is the same as stored format. This is done for speed of operation.
 11844                          
 11845                          
 11846  5da5 20f760             fsub             jsr conupk
 11847                          
 11848  5da8 a568               fsubt            lda facsgn
 11849  5daa 49ff                                eor #$ff                                 ; complement it
 11850  5dac 8568                                sta facsgn
 11851  5dae 456f                                eor argsgn                               ; complement arisgn
 11852  5db0 8570                                sta arisgn
 11853  5db2 a563                                lda facexp                               ; set codes on facexp
 11854  5db4 8008                                bra faddt                                ; (y)=argexp
 11855                          
 11856  5db6 20e75e             fadd5            jsr shiftr                               ; do a long shift
 11857  5db9 903b                                bcc fadd4                                ; continue with addition
 11858                          
 11859  5dbb 20f760             fadd             jsr conupk
 11860  5dbe f3d304             faddt            +lbeq movfa                              ; if fac=0, result is in arg
 11861  5dc1 a671                                ldx facov
 11862  5dc3 8658                                stx oldov
 11863  5dc5 a26a                                ldx #argexp                              ; default is shift argument
 11864  5dc7 a56a                                lda argexp                               ; if arg=0, fac is result
 11865                          
 11866  5dc9 a8                 faddc            tay                                      ; also copy (a) into (y)
 11867  5dca f38300                              +lbeq zerrts                             ; return
 11868  5dcd 38                                  sec
 11869  5dce e563                                sbc facexp
 11870  5dd0 f024                                beq fadd4                                ; no shifting
 11871  5dd2 9012                                bcc fadda                                ; branch if argexp < facexp
 11872  5dd4 8463                                sty facexp                               ; resulting exponent
 11873  5dd6 a46f                                ldy argsgn                               ; since arg is bigger, its
 11874  5dd8 8468                                sty facsgn                               ; sign is sign of result
 11875  5dda 49ff                                eor #$ff                                 ; shift a negative number of palces
 11876  5ddc 6900                                adc #0                                   ; complete negation, w/ c=1
 11877  5dde a000                                ldy #0                                   ; zero oldov
 11878  5de0 8458                                sty oldov
 11879  5de2 a263                                ldx #fac                                 ; shift the FAC instead
 11880  5de4 8004                                bra fadd1
 11881                          
 11882  5de6 a000               fadda            ldy #0
 11883  5de8 8471                                sty facov
 11884                          
 11885  5dea c9f9               fadd1            cmp #$f9                                 ; for speed and necessity.  gets most likely case to
 11886                          ;SHIFTR fastest and allows shifting of neg nums by QUINT
 11887  5dec 30c8                                bmi fadd5                                ; shift big
 11888  5dee a8                                  tay
 11889  5def a571                                lda facov                                ; set facov
 11890  5df1 5601                                lsr 1,x                                  ; gets 0 in the MSB
 11891  5df3 20fe5e                              jsr rolshf                               ; do the rolling
 11892                          
 11893  5df6 7f7057             fadd4            bbr7 arisgn,fadd2                        ; get resulting sign and if positive, add. carry is clear
 11894  5df9 a063                                ldy #facexp
 11895  5dfb e06a                                cpx #argexp                              ; fac is bigger
 11896  5dfd f002                                beq l168_1
 11897  5dff a06a                                ldy #argexp                              ; arg is bigger
 11898                          
 11899  5e01 38                 l168_1           sec                                      ; subit.
 11900  5e02 49ff                                eor #$ff
 11901  5e04 6558                                adc oldov
 11902  5e06 8571                                sta facov
 11903  5e08 b90400                              lda 4,y
 11904  5e0b f504                                sbc 4,x
 11905  5e0d 8567                                sta faclo
 11906  5e0f b90300                              lda 3,y
 11907  5e12 f503                                sbc 3,x
 11908  5e14 8566                                sta facmo
 11909  5e16 b90200                              lda 2,y
 11910  5e19 f502                                sbc 2,x
 11911  5e1b 8565                                sta facmoh
 11912  5e1d b90100                              lda 1,y
 11913  5e20 f501                                sbc 1,x
 11914  5e22 8564                                sta facho
 11915                          
 11916  5e24 b003               fadflt           bcs normal                               ; here if signs differ. if carry, FAC is set ok
 11917  5e26 20995e                              jsr negfac                               ; negate (FAC)
 11918                          
 11919  5e29 a000               normal           ldy #0
 11920  5e2b 98                                  tya
 11921  5e2c 18                                  clc
 11922                          
 11923  5e2d a664               l169_1           ldx facho
 11924  5e2f d049                                bne norm1
 11925  5e31 a665                                ldx facho+1                              ; shift 8 bits at a time for speed
 11926  5e33 8664                                stx facho
 11927  5e35 a666                                ldx facmoh+1
 11928  5e37 8665                                stx facmoh
 11929  5e39 a667                                ldx facmo+1
 11930  5e3b 8666                                stx facmo
 11931  5e3d a671                                ldx facov
 11932  5e3f 8667                                stx faclo
 11933  5e41 8471                                sty facov
 11934  5e43 6908                                adc #8
 11935  5e45 c920                                cmp #32
 11936  5e47 d0e4                                bne l169_1
 11937                          
 11938  5e49 a900               zerofc           lda #0                                   ; not needed by NORMAL, but by others
 11939  5e4b 8563               zerof1           sta facexp                               ; number must be zero
 11940  5e4d 8568               zeroml           sta facsgn                               ; make sign positive
 11941  5e4f 60                 zerrts           rts                                      ; all done
 11942                          
 11943                          
 11944  5e50 6558               fadd2            adc oldov
 11945  5e52 8571                                sta facov
 11946  5e54 a567                                lda faclo
 11947  5e56 656e                                adc arglo
 11948  5e58 8567                                sta faclo
 11949  5e5a a566                                lda facmo
 11950  5e5c 656d                                adc argmo
 11951  5e5e 8566                                sta facmo
 11952  5e60 a565                                lda facmoh
 11953  5e62 656c                                adc argmoh
 11954  5e64 8565                                sta facmoh
 11955  5e66 a564                                lda facho
 11956  5e68 656b                                adc argho
 11957  5e6a 8564                                sta facho
 11958  5e6c 8019                                bra squeez                               ; go round if signs same
 11959                          
 11960                          
 11961  5e6e 6901               norm2            adc #1                                   ; decrement shift counter
 11962  5e70 0671                                asl facov                                ; shift all left one bit
 11963  5e72 2667                                rol faclo
 11964  5e74 2666                                rol facmo
 11965  5e76 2665                                rol facmoh
 11966  5e78 2664                                rol facho
 11967                          
 11968  5e7a 10f2               norm1            bpl norm2                                ; if msb=0 shift again
 11969  5e7c 38                                  sec
 11970  5e7d e563                                sbc facexp
 11971  5e7f b0c8                                bcs zerofc
 11972  5e81 49ff                                eor #$ff
 11973  5e83 6901                                adc #1                                   ; complement
 11974  5e85 8563                                sta facexp
 11975                          
 11976  5e87 900f               squeez           bcc rndrts                               ; bits to shift?
 11977  5e89 e663               rndshf           inc facexp
 11978  5e8b f3bacf                              +lbeq overr
 11979  5e8e 6664                                ror facho
 11980  5e90 6665                                ror facmoh
 11981  5e92 6666                                ror facmo
 11982  5e94 6667                                ror faclo
 11983  5e96 6671                                ror facov
 11984  5e98 60                 rndrts           rts                                      ; all done adding
 11985                          
 11986                          
 11987  5e99 a568               negfac           lda facsgn
 11988  5e9b 49ff                                eor #$ff                                 ; complement FAC entirely
 11989  5e9d 8568                                sta facsgn
 11990                          
 11991  5e9f a564               negfch           lda facho
 11992  5ea1 49ff                                eor #$ff                                 ; complement just the number
 11993  5ea3 8564                                sta facho
 11994  5ea5 a565                                lda facmoh
 11995  5ea7 49ff                                eor #$ff
 11996  5ea9 8565                                sta facmoh
 11997  5eab a566                                lda facmo
 11998  5ead 49ff                                eor #$ff
 11999  5eaf 8566                                sta facmo
 12000  5eb1 a567                                lda faclo
 12001  5eb3 49ff                                eor #$ff
 12002  5eb5 8567                                sta faclo
 12003  5eb7 a571                                lda facov
 12004  5eb9 49ff                                eor #$ff
 12005  5ebb 8571                                sta facov
 12006  5ebd e671                                inc facov
 12007  5ebf d00e                                bne incfrt
 12008                          
 12009  5ec1 e667               incfac           inc faclo
 12010  5ec3 d00a                                bne incfrt
 12011  5ec5 e666                                inc facmo
 12012  5ec7 d006                                bne incfrt                               ; if no carry, return
 12013  5ec9 e665                                inc facmoh
 12014  5ecb d002                                bne incfrt
 12015  5ecd e664                                inc facho                                ; carry complement
 12016  5ecf 60                 incfrt           rts
 12017                          
 12018                          
 12019                          ; SHIFTR shifts (x+1:x+3) (-a) bits right.  Shifts bits to start with
 12020                          ; if possible.
 12021                          
 12022  5ed0 a227               mulshf           ldx #resho-1                             ; entry point for multiplier
 12023  5ed2 b404               shftr2           ldy 4,x                                  ; shift bits first
 12024  5ed4 8471                                sty facov
 12025  5ed6 b403                                ldy 3,x
 12026  5ed8 9404                                sty 4,x
 12027  5eda b402                                ldy 2,x                                  ; get mo
 12028  5edc 9403                                sty 3,x                                  ; store lo
 12029  5ede b401                                ldy 1,x                                  ; get ho
 12030  5ee0 9402                                sty 2,x                                  ; store mo
 12031  5ee2 acd702                              ldy bits
 12032  5ee5 9401                                sty 1,x                                  ; store ho
 12033                          
 12034  5ee7 6908               shiftr           adc #8
 12035  5ee9 30e7                                bmi shftr2
 12036  5eeb f0e5                                beq shftr2
 12037  5eed e908                                sbc #8                                   ; c can be either 1,0 and it works!
 12038  5eef a8                                  tay
 12039  5ef0 a571                                lda facov
 12040  5ef2 b014                                bcs shftrt                               ; equiv to beq here
 12041                          
 12042  5ef4 1601               shftr3           asl 1,x
 12043  5ef6 9002                                bcc l170_1
 12044  5ef8 f601                                inc 1,x
 12045  5efa 7601               l170_1           ror 1,x
 12046  5efc 7601                                ror 1,x                                  ; yes, two of them
 12047                          
 12048  5efe 7602               rolshf           ror 2,x
 12049  5f00 7603                                ror 3,x
 12050  5f02 7604                                ror 4,x                                  ; one more time
 12051  5f04 6a                                  ror
 12052  5f05 c8                                  iny
 12053  5f06 d0ec                                bne shftr3                               ; $$$ (most expensive!!!)
 12054                          
 12055  5f08 18                 shftrt           clc                                      ; clear output of FACOV
 12056  5f09 60                                  rts
 12057                          
 12058                          ;.end
 12059                          ;[[math.const]]
 12060                          
 12061                          
 12062                          
 12063                          ; Constants used by LOG, EXP, TRIG, and others.
 12064                          
 12065  5f0a 7f00000000         fr4              !text 127,0,0,0,0                        ; 1/4
 12066  5f0f 8080000000         neghlf           !text 128,128,0,0,0                      ; -0.5
 12067  5f14 8000000000         fhalf            !text 128,0,0,0,0                        ; 0.5
 12068  5f19 8420000000         tenc             !text 132,32,0,0,0                       ; 10.0
 12069  5f1e 82490fdaa1         pival            !text 130,73,15,218,161                  ; pi
 12070  5f23 81490fdaa2         pi2              !text 129,73,15,218,162                  ; pi/2
 12071  5f28 83490fdaa2         twopi            !text 131,73,15,218,162                  ; pi*2
 12072                          
 12073  5f2d 9b3ebc1ffd         n0999            !text $9b,$3e,$bc,$1f,$fd
 12074  5f32 9e6e6b27fd         n9999            !text $9e,$6e,$6b,$27,$fd
 12075  5f37 9e6e6b2800         nmil             !text $9e,$6e,$6b,$28,$00
 12076                          
 12077                          foutbl                                                    ; powers of 10
 12078  5f3c fa0a1f00                            !text 250,10,31,0                        ; -100,000,000
 12079  5f40 00989680                            !text 0,152,150,128                      ; 10,000,000
 12080  5f44 fff0bdc0                            !text 255,240,189,192                    ; -1,000,000
 12081  5f48 000186a0                            !text 0,1,134,160                        ; 100,000
 12082  5f4c ffffd8f0                            !text 255,255,216,240                    ; -10,000
 12083  5f50 000003e8                            !text 0,0,3,232                          ; 1,000
 12084  5f54 ffffff9c                            !text 255,255,255,156                    ; -100
 12085  5f58 0000000a                            !text 0,0,0,10                           ; 10
 12086  5f5c ffffffff                            !text 255,255,255,255                    ; -1
 12087                          fdcend
 12088                          
 12089                          ; .byte @377,@337,@012,@200 ;-2,160,000 for time converter removed [901014]
 12090                          ; .byte @000,@003,@113,@300 ;   216,000
 12091                          ; .byte @377,@377,@163,@140 ;   -36,000
 12092                          ; .byte @000,@000,@016,@020 ;     3,600
 12093                          ; .byte @377,@377,@375,@250 ;      -600
 12094                          ; .byte @000,@000,@000,@074 ;        60
 12095                          ;timend
 12096                          
 12097  5f60 03                 logcn2           !text 3                                  ; degree-1
 12098  5f61 7f5e56cb79                          !text 127,94,86,203,121                  ; 0.43425594188
 12099  5f66 80139b0b64                          !text 128,19,155,11,100                  ; 0.57658454134
 12100  5f6b 8076389316                          !text 128,118,56,147,22                  ; 0.96180075921
 12101  5f70 8238aa3b20                          !text 130,56,170,59,32                   ; 2.8853900728
 12102                          
 12103  5f75 07                 expcon           !text 7                                  ; degree-1
 12104  5f76 7134583e56                          !text 113,52,88,62,86                    ; 0.000021498763697
 12105  5f7b 74167eb31b                          !text 116,22,126,179,27                  ; 0.00014352314036
 12106  5f80 772feee385                          !text 119,47,238,227,133                 ; 0.0013422634824
 12107  5f85 7a1d841c2a                          !text 122,29,132,28,42                   ; 0.0096140170199
 12108  5f8a 7c6359580a                          !text 124,99,89,88,10                    ; 0.055505126860
 12109  5f8f 7e75fde7c6                          !text 126,117,253,231,198                ; 0.24022638462
 12110  5f94 8031721810                          !text 128,49,114,24,16                   ; 0.69314718600
 12111  5f99 8100000000         fone             !text 129,0,0,0,0                        ; 1.0
 12112                          
 12113  5f9e 8138aa3b29         logeb2           !text 129,56,170,59,41                   ; log(e) base 2
 12114  5fa3 803504f334         sqr05            !text 128,53,4,243,52                    ; 0.707106781 sqr(0.5)
 12115  5fa8 813504f334         sqr20            !text 129,53,4,243,52                    ; 1.41421356 sqr(2.0)
 12116  5fad 80317217f8         log2             !text 128,49,114,23,248                  ; 0.693147181 ln(2)
 12117                          
 12118                          
 12119  5fb2 05                 sincon           !text 5                                  ; degree-1 trig
 12120  5fb3 84e61a2d1b                          !text 132,230,26,45,27
 12121  5fb8 862807fbf8                          !text 134,40,7,251,248
 12122  5fbd 8799688901                          !text 135,153,104,137,1
 12123  5fc2 872335dfe1                          !text 135,35,53,223,225
 12124  5fc7 86a55de728                          !text 134,165,93,231,40
 12125  5fcc 83490fdaa2                          !text 131,73,15,218,162
 12126                          
 12127  5fd1 0b                 atncon           !text 11                                 ; degree-1
 12128  5fd2 76b383bdd3                          !text 118,179,131,189,211
 12129  5fd7 791ef4a6f5                          !text 121,30,244,166,245
 12130  5fdc 7b83fcb010                          !text 123,131,252,176,16
 12131  5fe1 7c0c1f67ca                          !text 124,12,31,103,202
 12132  5fe6 7cde53cbc1                          !text 124,222,83,203,193
 12133  5feb 7d1464704c                          !text 125,20,100,112,76
 12134  5ff0 7db7ea517a                          !text 125,183,234,81,122
 12135  5ff5 7d6330887e                          !text 125,99,48,136,126
 12136  5ffa 7e9244993a                          !text 126,146,68,153,58
 12137  5fff 7e4ccc91c7                          !text 126,76,204,145,199
 12138  6004 7faaaaaa13                          !text 127,170,170,170,19
 12139  6009 8100000000                          !text 129,0,0,0,0
 12140                          
 12141                          ;[[math.log]]
 12142                          
 12143                          ; Natural Log Function
 12144                          ;
 12145                          ; Calculation is by   LN(f*2^n) = (n+LOG2(f))*LN(2)
 12146                          ; An approximation polynomial is used to calculate LOG2(f).
 12147                          
 12148                          
 12149  600e 20c162             log              jsr sign                                 ; is it positive?
 12150  6011 f3ebf1                              +lbeq fcerr                              ; can't tolerate neg or zero
 12151                          
 12152  6014 a563                                lda facexp                               ; get exponent into (a)
 12153  6016 e97f                                sbc #$7f                                 ; remove bias (carry is off)
 12154  6018 48                                  pha                                      ; save exponent a while
 12155  6019 a980                                lda #$80
 12156  601b 8563                                sta facexp                               ; result is FAC in range (0.5,1)
 12157  601d a9a3                                lda #<sqr05                              ; get pointer to sqr(0.5)
 12158  601f a05f                                ldy #>sqr05
 12159  6021 205160                              jsr romadd
 12160  6024 a9a8                                lda #<sqr20
 12161  6026 a05f                                ldy #>sqr20
 12162  6028 205d60                              jsr romdiv
 12163  602b a999                                lda #<fone
 12164  602d a05f                                ldy #>fone
 12165  602f 205760                              jsr romsub
 12166  6032 a960                                lda #<logcn2
 12167  6034 a05f                                ldy #>logcn2
 12168  6036 205a66                              jsr polyx                                ; evaluate approximation polynomial
 12169  6039 a90f                                lda #<neghlf                             ; add in last constant
 12170  603b a05f                                ldy #>neghlf
 12171  603d 205160                              jsr romadd
 12172  6040 68                                  pla                                      ; get exponent back
 12173  6041 201464                              jsr finlog
 12174  6044 a9ad                                lda #<log2                               ; multiply result by ln(2)
 12175  6046 a05f                                ldy #>log2
 12176                          
 12177                          
 12178  6048 20cc60             rommlt           jsr romupk
 12179  604b 8023                                bra fmultt                               ; multiply together
 12180                          
 12181                          
 12182  604d a914               faddh            lda #<fhalf
 12183  604f a05f                                ldy #>fhalf
 12184                          
 12185  6051 20cc60             romadd           jsr romupk
 12186  6054 8368fd                              +lbra faddt
 12187                          
 12188                          
 12189  6057 20cc60             romsub           jsr romupk
 12190  605a 834cfd                              +lbra fsubt
 12191                          
 12192                          
 12193  605d 20cc60             romdiv           jsr romupk
 12194  6060 832301                              +lbra fdivt
 12195                          
 12196                          ;[[math.multiply]]
 12197                          
 12198                          ; Multiplication        FAC = ARG*FAC
 12199                          
 12200                          fmultt_c65                                                ; [910402]
 12201  6063 a56f                                lda argsgn
 12202  6065 4568                                eor facsgn
 12203  6067 8570                                sta arisgn                               ; resultant sign
 12204  6069 a663                                ldx facexp                               ; set signs on thing to multiply
 12205  606b 8003                                bra fmultt                               ; go multiply
 12206                          
 12207  606d 20f760             fmult            jsr conupk                               ; unpack the constant into arg for use
 12208                          
 12209  6070 f059               fmultt           beq multrt                               ; if FAC=0, return.  FAC is set
 12210  6072 202761                              jsr muldiv                               ; fix up the exponents
 12211  6075 a900                                lda #0                                   ; to clear result
 12212  6077 8528                                sta resho
 12213  6079 8529                                sta resmoh
 12214  607b 852a                                sta resmo
 12215  607d 852b                                sta reslo
 12216  607f a571                                lda facov
 12217  6081 209e60                              jsr mltpl1                               ; *** THIS fixes the DBL-0 bug without causing other grief!  C128-04 FAB
 12218  6084 a567                                lda faclo                                ; multiply arg by faclo
 12219  6086 209b60                              jsr mltply
 12220  6089 a566                                lda facmo                                ; multiply arg by facmo
 12221  608b 209b60                              jsr mltply
 12222  608e a565                                lda facmoh
 12223  6090 209e60                              jsr mltpl1                               ; *** THIS fixes the DBL-0 bug without causing other grief!  C128-04 FAB
 12224  6093 a564                                lda facho                                ; multiply arg by facho
 12225  6095 209e60                              jsr mltpl1
 12226  6098 836101                              +lbra movfr                              ; move result into FAC
 12227                          
 12228                          
 12229  609b f333fe             mltply           +lbeq mulshf                             ; normalize result and return. shift result right 1 byte.  exits with .c=0
 12230  609e 4a                 mltpl1           lsr
 12231  609f 0980                                ora #$80                                 ; will flag end of shifting
 12232                          
 12233  60a1 a8                 l171_1           tay
 12234  60a2 9019                                bcc l171_2                               ; if mult bit=0, just shift
 12235  60a4 18                                  clc
 12236  60a5 a52b                                lda reslo
 12237  60a7 656e                                adc arglo
 12238  60a9 852b                                sta reslo
 12239  60ab a52a                                lda resmo
 12240  60ad 656d                                adc argmo
 12241  60af 852a                                sta resmo
 12242  60b1 a529                                lda resmoh
 12243  60b3 656c                                adc argmoh
 12244  60b5 8529                                sta resmoh
 12245  60b7 a528                                lda resho
 12246  60b9 656b                                adc argho
 12247  60bb 8528                                sta resho
 12248                          
 12249  60bd 6628               l171_2           ror resho
 12250  60bf 6629                                ror resmoh
 12251  60c1 662a                                ror resmo
 12252  60c3 662b                                ror reslo
 12253  60c5 6671                                ror facov                                ; save for rounding
 12254  60c7 98                                  tya
 12255  60c8 4a                                  lsr                                      ; clear msb so we get a closer to 0
 12256  60c9 d0d6                                bne l171_1                               ; slow as a turtle
 12257                          
 12258  60cb 60                 multrt           rts
 12259                          
 12260                          
 12261                          ;[[math.unpack]]
 12262                          ; Unpack a ROM constant into the FAC
 12263                          
 12264  60cc 8524               romupk           sta index1
 12265  60ce 8425                                sty index1+1
 12266  60d0 a004                                ldy #4
 12267  60d2 b124                                lda (index1),y                           ; it's in ROM, so ok to use ind
 12268  60d4 856e                                sta arglo
 12269  60d6 88                                  dey
 12270  60d7 b124                                lda (index1),y
 12271  60d9 856d                                sta argmo
 12272  60db 88                                  dey
 12273  60dc b124                                lda (index1),y
 12274  60de 856c                                sta argmoh
 12275  60e0 88                                  dey
 12276  60e1 b124                                lda (index1),y
 12277  60e3 856f                                sta argsgn
 12278  60e5 4568                                eor facsgn
 12279  60e7 8570                                sta arisgn
 12280  60e9 a56f                                lda argsgn
 12281  60eb 0980                                ora #$80
 12282  60ed 856b                                sta argho
 12283  60ef 88                                  dey
 12284  60f0 b124                                lda (index1),y
 12285  60f2 856a                                sta argexp
 12286  60f4 a563                                lda facexp                               ; sets code of facexp
 12287  60f6 60                                  rts
 12288                          
 12289                          
 12290                          ; Unpack a RAM constant into the FAC
 12291                          
 12292  60f7 8524               conupk           sta index1
 12293  60f9 8425                                sty index1+1
 12294                          
 12295                          ; lda mmu_config_reg
 12296                          ; pha   ;preserve caller's memory config????
 12297                          
 12298  60fb a004                                ldy #4
 12299  60fd 20d522                              jsr indin1_ram1
 12300  6100 856e                                sta arglo
 12301  6102 88                                  dey
 12302  6103 20d522                              jsr indin1_ram1
 12303  6106 856d                                sta argmo
 12304  6108 88                                  dey
 12305  6109 20d522                              jsr indin1_ram1
 12306  610c 856c                                sta argmoh
 12307  610e 88                                  dey
 12308  610f 20d522                              jsr indin1_ram1
 12309  6112 856f                                sta argsgn
 12310  6114 4568                                eor facsgn
 12311  6116 8570                                sta arisgn
 12312  6118 a56f                                lda argsgn
 12313  611a 0980                                ora #$80
 12314  611c 856b                                sta argho
 12315  611e 88                                  dey
 12316  611f 20d522                              jsr indin1_ram1
 12317  6122 856a                                sta argexp
 12318                          
 12319                          ; pla
 12320                          ; sta mmu_config_reg ;restore caller's memory config????
 12321                          
 12322  6124 a563                                lda facexp                               ; set codes of facexp
 12323  6126 60                                  rts
 12324                          
 12325                          
 12326                          ; Check special cases and add exponents for FMULT, FDIV
 12327                          
 12328                          muldiv
 12329  6127 a56a                                lda argexp                               ; exp of arg=0?
 12330  6129 f01f               mldexp           beq zeremv                               ; so we get zero exponent
 12331  612b 18                                  clc
 12332  612c 6563                                adc facexp                               ; result is in (a)
 12333  612e 9005                                bcc l172_1                               ; find (c) xor (n)
 12334  6130 3315cd                              +lbmi overr                              ; overflow if bits match
 12335  6133 18                                  clc
 12336  6134 2c                                  !text $2c
 12337                          
 12338  6135 1013               l172_1           bpl zeremv                               ; underflow
 12339  6137 6980                                adc #$80                                 ; add bias
 12340  6139 8563                                sta facexp
 12341  613b f310fd                              +lbeq zeroml                             ; zero the rest of it
 12342  613e a570                                lda arisgn
 12343  6140 8568                                sta facsgn                               ; arisgn is result's sign
 12344  6142 60                                  rts                                      ; done
 12345                          
 12346                          
 12347  6143 a568               mldvex           lda facsgn                               ; get sign
 12348  6145 49ff                                eor #$ff                                 ; complement it
 12349  6147 33fecc                              +lbmi overr
 12350                          
 12351  614a 68                 zeremv           pla                                      ; get addr off stack
 12352  614b 68                                  pla
 12353  614c 83fbfc                              +lbra zerofc                             ; underflow
 12354                          
 12355                          
 12356                          ; Multiply FAC by 10
 12357                          
 12358  614f 20a362             mul10            jsr movaf                                ; copy FAC into ARG
 12359  6152 aa                                  tax
 12360  6153 f012                                beq mul10r                               ; if (FAC)=0, got answer
 12361  6155 18                                  clc
 12362  6156 6902                                adc #2                                   ; augment exp by 2
 12363  6158 b3edcc                              +lbcs overr                              ; overflow
 12364                          
 12365  615b a200               finml6           ldx #0
 12366  615d 8670                                stx arisgn                               ; signs are same
 12367  615f 20c95d                              jsr faddc                                ; add together
 12368  6162 e663                                inc facexp                               ; multiply by two
 12369  6164 f3e1cc                              +lbeq overr                              ; overflow
 12370                          
 12371  6167 60                 mul10r           rts
 12372                          
 12373                          
 12374  6168 20a362             div10            jsr movaf                                ; move FAC to ARG
 12375  616b a919                                lda #<tenc
 12376  616d a05f                                ldy #>tenc                               ; point to constant of 10.0
 12377  616f a200                                ldx #0                                   ; signs are both positive
 12378                          
 12379  6171 8670               fdivf            stx arisgn
 12380  6173 200e62                              jsr movfm                                ; put it into FAC
 12381  6176 800d                                bra fdivt
 12382                          
 12383                          fdivt_c65                                                 ; [910402]
 12384  6178 a56f                                lda argsgn
 12385  617a 4568                                eor facsgn
 12386  617c 8570                                sta arisgn                               ; resultant sign
 12387  617e a663                                ldx facexp                               ; set signs on thing to divide
 12388  6180 8003                                bra fdivt                                ; go divide
 12389                          
 12390  6182 20f760             fdiv             jsr conupk                               ; unpack constant
 12391  6185 f3bdcc             fdivt            +lbeq doverr                             ; can't divide by zero
 12392  6188 20b262                              jsr round                                ; take FACOV into account in FAC
 12393  618b a900                                lda #0                                   ; negate facexp
 12394  618d 38                                  sec
 12395  618e e563                                sbc facexp
 12396  6190 8563                                sta facexp
 12397  6192 202761                              jsr muldiv                               ; fix up exponents
 12398  6195 e663                                inc facexp                               ; scale it right
 12399  6197 f3aecc                              +lbeq overr                              ; overflow
 12400  619a a2fc                                ldx #$fc                                 ; set up procedure
 12401  619c a901                                lda #1
 12402                          
 12403                          
 12404                          divide                                                    ; this is the best code in the whole pile
 12405  619e a46b                                ldy argho                                ; see what relation holds
 12406  61a0 c464                                cpy facho
 12407  61a2 d010                                bne savquo                               ; (c)=0,1. n(c=0)=0.
 12408  61a4 a46c                                ldy argmoh
 12409  61a6 c465                                cpy facmoh
 12410  61a8 d00a                                bne savquo
 12411  61aa a46d                                ldy argmo
 12412  61ac c466                                cpy facmo
 12413  61ae d004                                bne savquo
 12414  61b0 a46e                                ldy arglo
 12415  61b2 c467                                cpy faclo
 12416                          
 12417  61b4 08                 savquo           php
 12418  61b5 2a                                  rol                                      ; save result
 12419  61b6 9009                                bcc qshft                                ; if not done, continue
 12420  61b8 e8                                  inx
 12421  61b9 952b                                sta reslo,x
 12422  61bb f031                                beq ld100
 12423  61bd 1033                                bpl divnrm                               ; note this req 1 no ram then access
 12424  61bf a901                                lda #1
 12425                          
 12426  61c1 28                 qshft            plp                                      ; return condition codes
 12427  61c2 b00e                                bcs divsub                               ; FAC <= ARG
 12428                          
 12429  61c4 066e               shfarg           asl arglo                                ; shift ARG one place left
 12430  61c6 266d                                rol argmo
 12431  61c8 266c                                rol argmoh
 12432  61ca 266b                                rol argho
 12433  61cc b0e6                                bcs savquo                               ; save a result of one for this position and divide
 12434  61ce 30ce                                bmi divide                               ; if msb on, go decide whether to sub
 12435  61d0 10e2                                bpl savquo
 12436                          
 12437                          
 12438  61d2 a8                 divsub           tay                                      ; notice c must be on here
 12439  61d3 a56e                                lda arglo
 12440  61d5 e567                                sbc faclo
 12441  61d7 856e                                sta arglo
 12442  61d9 a56d                                lda argmo
 12443  61db e566                                sbc facmo
 12444  61dd 856d                                sta argmo
 12445  61df a56c                                lda argmoh
 12446  61e1 e565                                sbc facmoh
 12447  61e3 856c                                sta argmoh
 12448  61e5 a56b                                lda argho
 12449  61e7 e564                                sbc facho
 12450  61e9 856b                                sta argho
 12451  61eb 98                                  tya
 12452  61ec 80d6                                bra shfarg
 12453                          
 12454                          
 12455                          
 12456  61ee a940               ld100            lda #$40                                 ; only want two more bits
 12457  61f0 80cf                                bra qshft                                ; always branches
 12458                          
 12459                          
 12460                          
 12461  61f2 0a                 divnrm           asl                                      ; get last two bits into MSB and B6
 12462  61f3 0a                                  asl
 12463  61f4 0a                                  asl
 12464  61f5 0a                                  asl
 12465  61f6 0a                                  asl
 12466  61f7 0a                                  asl
 12467  61f8 8571                                sta facov
 12468  61fa 28                                  plp
 12469                          
 12470                          
 12471                          
 12472  61fb a528               movfr            lda resho                                ; move result to FAC
 12473  61fd 8564                                sta facho
 12474  61ff a529                                lda resmoh
 12475  6201 8565                                sta facmoh
 12476  6203 a52a                                lda resmo
 12477  6205 8566                                sta facmo
 12478  6207 a52b                                lda reslo                                ; move lo and sign
 12479  6209 8567                                sta faclo
 12480  620b 831cfc                              +lbra normal                             ; all done
 12481                          
 12482                          
 12483                          
 12484  620e 8524               movfm            sta index1                               ; move memory into FAC from ROM (unpacked)
 12485  6210 8425                                sty index1+1
 12486  6212 a004                                ldy #4
 12487  6214 b124                                lda (index1),y
 12488  6216 8567                                sta faclo
 12489  6218 88                                  dey
 12490  6219 b124                                lda (index1),y
 12491  621b 8566                                sta facmo
 12492  621d 88                                  dey
 12493  621e b124                                lda (index1),y
 12494  6220 8565                                sta facmoh
 12495  6222 88                                  dey
 12496  6223 b124                                lda (index1),y
 12497  6225 8568                                sta facsgn
 12498  6227 0980                                ora #$80
 12499  6229 8564                                sta facho
 12500  622b 88                                  dey
 12501  622c b124                                lda (index1),y
 12502  622e 8563                                sta facexp
 12503  6230 8471                                sty facov
 12504  6232 60                                  rts
 12505                          
 12506                          
 12507                          ; Move number from FAC to memory
 12508                          
 12509  6233 a25e               mov2f            ldx #tempf2                              ; move from FAC to temp FAC2
 12510  6235 2c                                  !text $2c
 12511                          
 12512  6236 a259               mov1f            ldx #tempf1                              ; move from FAC to temp FAC1
 12513                          
 12514  6238 a000                                ldy #0
 12515  623a 20b262             movmf            jsr round
 12516  623d 8624                                stx index1
 12517  623f 8425                                sty index1+1
 12518  6241 a004                                ldy #4
 12519  6243 a567                                lda faclo
 12520  6245 9124                                sta (index),y                            ; BasePage
 12521  6247 88                                  dey
 12522  6248 a566                                lda facmo
 12523  624a 9124                                sta (index),y                            ; BasePage
 12524  624c 88                                  dey
 12525  624d a565                                lda facmoh
 12526  624f 9124                                sta (index),y                            ; BasePage
 12527  6251 88                                  dey
 12528  6252 a568                                lda facsgn                               ; include sign in ho
 12529  6254 097f                                ora #$7f
 12530  6256 2564                                and facho
 12531  6258 9124                                sta (index),y                            ; BasePage
 12532  625a 88                                  dey
 12533  625b a563                                lda facexp
 12534  625d 9124                                sta (index),y                            ; BasePage
 12535  625f 8471                                sty facov                                ; zero it since rounded
 12536  6261 60                                  rts                                      ; (y)=0
 12537                          
 12538                          
 12539                          movmf_ram1
 12540  6262 20b262                              jsr round
 12541  6265 8624                                stx index1
 12542  6267 8425                                sty index1+1
 12543  6269 da                                  phx
 12544  626a a224                                ldx #index
 12545  626c a004                                ldy #4
 12546  626e a567                                lda faclo
 12547  6270 20f022                              jsr sta_far_ram1                         ; sta (index),y
 12548  6273 88                                  dey
 12549  6274 a566                                lda facmo
 12550  6276 20f022                              jsr sta_far_ram1                         ; sta (index),y
 12551  6279 88                                  dey
 12552  627a a565                                lda facmoh
 12553  627c 20f022                              jsr sta_far_ram1                         ; sta (index),y
 12554  627f 88                                  dey
 12555  6280 a568                                lda facsgn                               ; include sign in ho
 12556  6282 097f                                ora #$7f
 12557  6284 2564                                and facho
 12558  6286 20f022                              jsr sta_far_ram1                         ; sta (index),y
 12559  6289 88                                  dey
 12560  628a a563                                lda facexp
 12561  628c 20f022                              jsr sta_far_ram1                         ; sta (index),y
 12562  628f 8471                                sty facov                                ; zero it since rounded
 12563  6291 fa                                  plx
 12564  6292 60                                  rts                                      ; (y)=0
 12565                          
 12566                          
 12567  6293 a56f               movfa            lda argsgn
 12568                          
 12569  6295 8568               movfa1           sta facsgn
 12570                          
 12571  6297 a205                                ldx #5
 12572  6299 b569               l173_1           lda argexp-1,x
 12573  629b 9562                                sta facexp-1,x
 12574  629d ca                                  dex
 12575  629e d0f9                                bne l173_1
 12576  62a0 8671                                stx facov
 12577  62a2 60                                  rts
 12578                          
 12579                          
 12580  62a3 20b262             movaf            jsr round
 12581                          
 12582  62a6 a206               movef            ldx #6
 12583  62a8 b562               l174_1           lda facexp-1,x
 12584  62aa 9569                                sta argexp-1,x
 12585  62ac ca                                  dex
 12586  62ad d0f9                                bne l174_1
 12587  62af 8671                                stx facov                                ; zero it since rounded
 12588  62b1 60                 movrts           rts
 12589                          
 12590                          
 12591                          
 12592  62b2 a563               round            lda facexp                               ; zero?
 12593  62b4 f0fb                                beq movrts                               ; yes, done rounding
 12594  62b6 0671                                asl facov                                ; round?
 12595  62b8 90f7                                bcc movrts                               ; no, msb off
 12596                          
 12597  62ba 20c15e             incrnd           jsr incfac                               ; yes, add one to lsb(FAC) /// entry from EXP
 12598                          ;note .c=1 since incfac doesn't touch .c
 12599  62bd f3cafb                              +lbeq rndshf                             ; carry:   squeeze msb in and rts
 12600  62c0 60                                  rts                                      ; no carry: rts now
 12601                          
 12602                          
 12603                          
 12604                          ; Put sign in FAC into (a).
 12605                          
 12606  62c1 a563               sign             lda facexp
 12607  62c3 f009                                beq signrt                               ; if number is zero, so is result
 12608                          
 12609  62c5 a568               fcsign           lda facsgn
 12610  62c7 2a                 fcomps           rol
 12611  62c8 a9ff                                lda #$ff                                 ; assume negative
 12612  62ca b002                                bcs signrt
 12613  62cc a901                                lda #1                                   ; get +1
 12614  62ce 60                 signrt           rts
 12615                          
 12616                          
 12617                          
 12618                          ; SGN function
 12619                          
 12620  62cf 20c162             sgn              jsr sign
 12621                          
 12622                          ;float the signed integer in accb
 12623  62d2 8564               float            sta facho                                ; put (accb) in high order
 12624  62d4 a900                                lda #0
 12625  62d6 8565                                sta facho+1
 12626  62d8 a288                                ldx #$88                                 ; get the exponent
 12627                          ;float the signed number in FAC
 12628                          
 12629                          
 12630  62da a564               floats           lda facho
 12631  62dc 49ff                                eor #$ff
 12632  62de 2a                                  rol                                      ; get comp of sign in carry
 12633  62df a900               floatc           lda #0                                   ; zero (a) but not carry
 12634  62e1 8567                                sta faclo
 12635  62e3 8566                                sta facmo
 12636                          
 12637  62e5 8663               floatb           stx facexp
 12638  62e7 8571                                sta facov
 12639  62e9 8568                                sta facsgn
 12640  62eb 8337fb                              +lbra fadflt
 12641                          
 12642                          
 12643                          
 12644                          
 12645                          ; Absolute value of FAC
 12646                          
 12647  62ee 4668               abs              lsr facsgn
 12648  62f0 60                                  rts
 12649                          
 12650                          
 12651                          
 12652                          ; Compare two numbers:
 12653                          ;
 12654                          ; a=1  if  ARG < FAC
 12655                          ; a=0  if  ARG = FAC
 12656                          ; a=-1 if  ARG > FAC
 12657                          
 12658  62f1 8526               fcomp            sta index2
 12659  62f3 8427                                sty index2+1
 12660  62f5 a000                                ldy #0
 12661  62f7 b126                                lda (index2),y                           ; has argexp
 12662  62f9 c8                                  iny                                      ; bump pointer up
 12663  62fa aa                                  tax                                      ; save a in x and reset codes
 12664  62fb f0c4                                beq sign
 12665  62fd b126                                lda (index2),y
 12666  62ff 4568                                eor facsgn                               ; signs the same
 12667  6301 30c2                                bmi fcsign                               ; signs differ so result is
 12668  6303 e463                                cpx facexp                               ; sign of FAC again
 12669  6305 d021                                bne l175_1
 12670                          
 12671  6307 b126                                lda (index2),y
 12672  6309 0980                                ora #$80
 12673  630b c564                                cmp facho
 12674  630d d019                                bne l175_1
 12675  630f c8                                  iny
 12676  6310 b126                                lda (index2),y
 12677  6312 c565                                cmp facmoh
 12678  6314 d012                                bne l175_1
 12679  6316 c8                                  iny
 12680  6317 b126                                lda (index2),y
 12681  6319 c566                                cmp facmo
 12682  631b d00b                                bne l175_1
 12683  631d c8                                  iny
 12684  631e a97f                                lda #$7f
 12685  6320 c571                                cmp facov
 12686  6322 b126                                lda (index2),y
 12687  6324 e567                                sbc faclo                                ; get zero if equal
 12688  6326 f028                                beq qintrt                               ; rts
 12689                          
 12690  6328 a568               l175_1           lda facsgn
 12691  632a 9002                                bcc l175_2
 12692  632c 49ff                                eor #$ff
 12693  632e 8097               l175_2           bra fcomps                               ; a part of sign sets up (a)
 12694                          
 12695                          ;.end
 12696                          ;[[math.ext4]]
 12697                          
 12698                          
 12699                          
 12700                          ; Quick Greatest Integer Function
 12701                          ;
 12702                          ; Leaves INT(FAC) in FACHO&MO&LO signed
 12703                          ; Assumes FAC < 2~23 =8388608
 12704                          
 12705  6330 a563               qint             lda facexp
 12706  6332 f04f                                beq clrfac                               ; if zero, got it
 12707  6334 38                                  sec
 12708  6335 e9a0                                sbc #$a0                                 ; get number of places to shift
 12709                          
 12710  6337 7f680a                              bbr7 facsgn,l176_1
 12711                          
 12712  633a aa                                  tax
 12713  633b a9ff                                lda #$ff
 12714  633d 8dd702                              sta bits                                 ; put $ff in when shftr shifts bytes
 12715  6340 209f5e                              jsr negfch                               ; truly negate quantity in FAC
 12716  6343 8a                                  txa
 12717                          
 12718  6344 a263               l176_1           ldx #fac
 12719  6346 c9f9                                cmp #$f9
 12720  6348 1007                                bpl qint1                                ; if number of places > 7 shift 1 place at a time
 12721  634a 20e75e                              jsr shiftr                               ; start shifting bytes, then bits
 12722  634d 8cd702                              sty bits                                 ; zero bits since adder wants zero
 12723  6350 60                 qintrt           rts
 12724                          
 12725                          
 12726  6351 a8                 qint1            tay                                      ; put count in counter
 12727  6352 a568                                lda facsgn
 12728  6354 2980                                and #$80                                 ; get sign bit
 12729  6356 4664                                lsr facho                                ; save first shifted byte
 12730  6358 0564                                ora facho
 12731  635a 8564                                sta facho
 12732  635c 20fe5e                              jsr rolshf                               ; shift the rest
 12733  635f 8cd702                              sty bits                                 ; zero (bits)
 12734  6362 60                                  rts
 12735                          
 12736                          
 12737                          
 12738                          ; Greatest Integer Function
 12739                          
 12740  6363 a563               int              lda facexp
 12741  6365 c9a0                                cmp #$a0
 12742  6367 b023                                bcs intrts                               ; forget it
 12743  6369 20b262                              jsr round                                ; round FAC per FACOV (fixes the  INT(.9+.1) -> 0  Microsoft bug.  FAB)
 12744  636c 203063                              jsr qint                                 ; INT(FAC)
 12745  636f 8471                                sty facov                                ; clr overflow byte
 12746  6371 a568                                lda facsgn
 12747  6373 8468                                sty facsgn                               ; make FAC look positive
 12748  6375 4980                                eor #$80                                 ; get complement of sign in carry
 12749  6377 2a                                  rol
 12750  6378 a9a0                                lda #$a0                                 ; @230+8
 12751  637a 8563                                sta facexp
 12752  637c a567                                lda faclo
 12753  637e 850a                                sta integr
 12754  6380 83a2fa                              +lbra fadflt
 12755                          
 12756                          
 12757  6383 8564               clrfac           sta facho                                ; make it really zero
 12758  6385 8565                                sta facmoh
 12759  6387 8566                                sta facmo
 12760  6389 8567                                sta faclo
 12761  638b a8                                  tay
 12762  638c 60                 intrts           rts
 12763                          
 12764                          ;[[math.fpin]]
 12765                          
 12766                          
 12767                          ; Floating Point Input Routine.
 12768                          ;
 12769                          ; Number input is left in FAC.  At entry (TXTPTR) points to the first character
 12770                          ; in a text buffer.  The first character is also in (a).  FIN packs the digits
 12771                          ; into the FAC as an integer and keeps track of where the decimal point is.
 12772                          ; (DPTFLG) tells whether a dp has been seen.  (DECCNT) is the number of digits
 12773                          ; after the dp.  At the end (DECCNT) and the exponent are used to determine how
 12774                          ; many times to multiply or divide by ten to get the correct number.
 12775                          
 12776                          
 12777  638d 8ed202             fin              stx fin_bank                             ; save bank number where string is stored
 12778                          
 12779  6390 a000                                ldy #0                                   ; zero facsgn, sgnflg
 12780  6392 a20a                                ldx #$0a                                 ; zero exp and ho (and moh)
 12781  6394 945f               l177_1           sty deccnt,x                             ; zero mo and lo
 12782  6396 ca                                  dex                                      ; zero tenexp and expsgn
 12783  6397 10fb                                bpl l177_1                               ; zero deccnt, dptflg
 12784                          
 12785  6399 900f                                bcc findgq                               ; flags still set from chrget
 12786  639b c92d                                cmp #'-'                                 ; a negative sign?
 12787  639d d004                                bne qplus                                ; no, try plus sign
 12788  639f 8669                                stx sgnflg                               ; it's negative. (x=@377)
 12789  63a1 8004                                bra finc                                 ; always branches
 12790                          
 12791                          
 12792  63a3 c92b               qplus            cmp #'+'                                 ; plus sign?
 12793  63a5 d005                                bne fin1                                 ; yes, skip it
 12794                          
 12795  63a7 205764             finc             jsr fin_chrget
 12796                          
 12797  63aa 9056               findgq           bcc findig
 12798                          
 12799  63ac c92e               fin1             cmp #'.'                                 ; the dp?
 12800  63ae f02c                                beq findp                                ; no kidding
 12801  63b0 c945                                cmp #'E'                                 ; exponent follows
 12802  63b2 d02d                                bne fine                                 ; no
 12803                          
 12804  63b4 205764                              jsr fin_chrget                           ; yes, get another, to check sign of exponent
 12805  63b7 9017                                bcc fnedg1                               ; is it a digit. (easier than backing up pointer)
 12806  63b9 c9ab                                cmp #minus_token                         ; minus?
 12807  63bb f00e                                beq finec1                               ; negate
 12808  63bd c92d                                cmp #'-'                                 ; minus sign?
 12809  63bf f00a                                beq finec1
 12810  63c1 c9aa                                cmp #plus_token                          ; plus?
 12811  63c3 f008                                beq finec
 12812  63c5 c92b                                cmp #'+'                                 ; plus sign?
 12813  63c7 f004                                beq finec
 12814  63c9 8007                                bra finec2
 12815                          
 12816  63cb 6662               finec1           ror expsgn                               ; turn it on
 12817                          
 12818  63cd 205764             finec            jsr fin_chrget                           ; get another
 12819                          
 12820  63d0 9055               fnedg1           bcc finedg                               ; it is a digit
 12821  63d2 7f620c             finec2           bbr7 expsgn,fine
 12822  63d5 a900                                lda #0
 12823  63d7 38                                  sec
 12824  63d8 e560                                sbc tenexp
 12825  63da 8007                                bra fine1
 12826                          
 12827  63dc 6661               findp            ror dptflg
 12828  63de 6f61c6                              bbr6 dptflg,finc
 12829                          
 12830  63e1 a560               fine             lda tenexp
 12831  63e3 38                 fine1            sec
 12832  63e4 e55f                                sbc deccnt                               ; get number of places to shift
 12833  63e6 8560                                sta tenexp
 12834  63e8 f012                                beq finqng                               ; negate?
 12835  63ea 1009                                bpl finmul                               ; positive, so multiply
 12836                          
 12837  63ec 206861             findiv           jsr div10
 12838  63ef e660                                inc tenexp                               ; done?
 12839  63f1 d0f9                                bne findiv                               ; no
 12840  63f3 8007                                bra finqng                               ; yes
 12841                          
 12842                          
 12843  63f5 204f61             finmul           jsr mul10
 12844  63f8 c660                                dec tenexp                               ; done?
 12845  63fa d0f9                                bne finmul                               ; no
 12846  63fc a569               finqng           lda sgnflg
 12847  63fe 33fc01                              +lbmi negop                              ; if negative, negate and return
 12848  6401 60                                  rts                                      ; if positive, return
 12849                          
 12850                          
 12851                          
 12852  6402 48                 findig           pha
 12853  6403 7f6102                              bbr7 dptflg,l178_1
 12854  6406 e65f                                inc deccnt
 12855  6408 204f61             l178_1           jsr mul10
 12856  640b 68                                  pla                                      ; get it back
 12857  640c 38                                  sec
 12858  640d e930                                sbc #'0'
 12859  640f 201464                              jsr finlog                               ; add it in
 12860  6412 8093                                bra finc
 12861                          
 12862                          
 12863                          
 12864  6414 48                 finlog           pha
 12865  6415 20a362                              jsr movaf                                ; save it for later
 12866  6418 68                                  pla
 12867  6419 20d262                              jsr float                                ; float the value in (a)
 12868                          
 12869                          faddt_c65                                                 ; [910402]
 12870  641c a56f                                lda argsgn
 12871  641e 4568                                eor facsgn
 12872  6420 8570                                sta arisgn                               ; resultant sign
 12873  6422 a663                                ldx facexp                               ; set signs on thing to add
 12874  6424 8398f9                              +lbra faddt                              ; add together and return
 12875                          
 12876                          
 12877                          ; Pack in the next digit of the exponent.
 12878                          ; Multiply the old exp by 10 and add in the next digit.
 12879                          ; (note: does not check for exp overflow)
 12880                          
 12881  6427 a560               finedg           lda tenexp                               ; get exp so far
 12882  6429 c90a                                cmp #10                                  ; will result be >= 100?
 12883  642b 9008                                bcc l179_1
 12884  642d a964                                lda #100
 12885  642f ff6220                              bbs7 expsgn,l179_4                       ; if neg exp, no chk for overr
 12886  6432 8313ca                              +lbra overr
 12887                          
 12888  6435 0a                 l179_1           asl                                      ; max is 120
 12889  6436 0a                                  asl                                      ; mult by 2 twice
 12890  6437 18                                  clc                                      ; possible shift out of high
 12891  6438 6560                                adc tenexp                               ; like multiplying by five
 12892  643a 0a                                  asl                                      ; and now by ten
 12893  643b 18                                  clc
 12894  643c a000                                ldy #0
 12895  643e 8578                                sta syntmp
 12896                          
 12897  6440 add202                              lda fin_bank                             ; text or string bank?
 12898  6443 d005                                bne l179_2
 12899  6445 20c522                              jsr indtxt                               ; text
 12900  6448 8003                                bra l179_3
 12901  644a 20d522             l179_2           jsr indin1_ram1                          ; string
 12902                          
 12903  644d 6578               l179_3           adc syntmp
 12904  644f 38                                  sec
 12905  6450 e930                                sbc #'0'
 12906  6452 8560               l179_4           sta tenexp                               ; save result
 12907  6454 8377ff                              +lbra finec
 12908                          
 12909                          
 12910                          ; Get a character from either text or string area, and set the flags
 12911                          ; in the manner performed by CHRGET.
 12912                          
 12913                          fin_chrget
 12914  6457 add202                              lda fin_bank                             ; text or string bank?
 12915  645a f327be                              +lbeq chrget                             ; get byte from text bank via normal CHRGET mechanism
 12916                          
 12917                          fin_chrget_1                                              ; get byte from string bank via modified CHRGET mechanism
 12918  645d e324                                inw index1
 12919                          fin_chrget_2
 12920  645f a000                                ldy #0
 12921  6461 20d522                              jsr indin1_ram1
 12922  6464 c93a                                cmp #':'
 12923  6466 b00a                                bcs l180_1
 12924  6468 c920                                cmp #' '
 12925  646a f0f1                                beq fin_chrget_1                         ; skip over spaces
 12926  646c 38                                  sec
 12927  646d e930                                sbc #'0'                                 ; set up .c as CHRGET would
 12928  646f 38                                  sec
 12929  6470 e9d0                                sbc #$d0
 12930  6472 60                 l180_1           rts
 12931                          
 12932                          ;.end
 12933                          ;[[math.ext5]]
 12934                          
 12935                          
 12936                          
 12937  6473 207dff             inprt            jsr _primm
 12938  6476 20494e2000                          !text " IN ",0
 12939                          
 12940  647b a53c               curprt           lda curlin+1
 12941  647d a63b                                ldx curlin
 12942                          
 12943  647f 8564               linprt           sta facho
 12944  6481 8665                                stx facho+1
 12945  6483 a290                                ldx #$90                                 ; exponent of 16
 12946  6485 38                                  sec                                      ; number is positive
 12947  6486 20df62                              jsr floatc
 12948  6489 209164                              jsr foutc
 12949  648c 83add3                              +lbra strout                             ; print and return
 12950                          
 12951                          
 12952  648f a001               fout             ldy #1
 12953  6491 a920               foutc            lda #' '                                 ; if positive, print space
 12954  6493 7f6802                              bbr7 facsgn,l181_1
 12955  6496 a92d                                lda #'-'                                 ; if neg
 12956  6498 99ff00             l181_1           sta fbuffr-1,y                           ; store the character
 12957  649b 8568                                sta facsgn                               ; make FAC pos for QINT
 12958  649d 8472                                sty fbufpt                               ; save for later
 12959  649f c8                                  iny
 12960  64a0 a930                                lda #'0'                                 ; get zero to type if FAC=0
 12961  64a2 a663                                ldx facexp
 12962  64a4 f30901                              +lbeq fout19
 12963                          
 12964  64a7 a900                                lda #0
 12965  64a9 e080                                cpx #$80                                 ; is number < 1?
 12966  64ab f002                                beq l181_2                               ; no
 12967  64ad b009                                bcs l181_3
 12968                          
 12969  64af a937               l181_2           lda #<nmil                               ; mult by 10~6
 12970  64b1 a05f                                ldy #>nmil
 12971  64b3 204860                              jsr rommlt
 12972  64b6 a9f7                                lda #$f7
 12973  64b8 855f               l181_3           sta deccnt                               ; save count or zero it
 12974                          
 12975  64ba a932               l181_4           lda #<n9999
 12976  64bc a05f                                ldy #>n9999
 12977  64be 20f162                              jsr fcomp                                ; is number > 999999.499 or 999999999.5?
 12978  64c1 f01e                                beq l181_9                               ; go to biggies
 12979  64c3 1012                                bpl l181_7                               ; yes, make it smaller
 12980                          
 12981  64c5 a92d               l181_5           lda #<n0999
 12982  64c7 a05f                                ldy #>n0999
 12983  64c9 20f162                              jsr fcomp                                ; is number > 99999.9499 or 99999999.90625?
 12984  64cc f002                                beq l181_6
 12985  64ce 100e                                bpl l181_8                               ; yes. done multiplying
 12986                          
 12987  64d0 204f61             l181_6           jsr mul10                                ; make it bigger
 12988  64d3 c65f                                dec deccnt
 12989  64d5 d0ee                                bne l181_5                               ; see if that does it (this always goes)
 12990                          
 12991  64d7 206861             l181_7           jsr div10                                ; make it smaller
 12992  64da e65f                                inc deccnt
 12993  64dc d0dc                                bne l181_4                               ; see if that does it (this always goes)
 12994                          
 12995  64de 204d60             l181_8           jsr faddh                                ; add a half to round up
 12996                          
 12997                          
 12998  64e1 203063             l181_9           jsr qint                                 ; biggies.
 12999  64e4 a201                                ldx #1                                   ; decimal point count
 13000  64e6 a55f                                lda deccnt
 13001  64e8 18                                  clc
 13002  64e9 690a                                adc #$0a                                 ; should number be printed in E notation?  (ie, is number .lt. .01?)
 13003  64eb 3009                                bmi l181_10                              ; yes
 13004  64ed c90b                                cmp #$0b                                 ; is it > 999999 or 9999999999?
 13005  64ef b006                                bcs l181_11                              ; yes, use E notation
 13006  64f1 69ff                                adc #$ff                                 ; number of places before decimal point
 13007  64f3 aa                                  tax                                      ; put into accx
 13008  64f4 a902                                lda #2                                   ; no E notation
 13009  64f6 38                 l181_10          sec
 13010                          
 13011  64f7 e902               l181_11          sbc #2                                   ; effectively add 5 to orig exp
 13012  64f9 8560                                sta tenexp                               ; that is the exponent to print
 13013  64fb 865f                                stx deccnt                               ; number of decimal places
 13014  64fd 8a                                  txa
 13015  64fe f002                                beq l181_12
 13016  6500 1013                                bpl l181_14                              ; some places before dec pnt
 13017                          
 13018  6502 a472               l181_12          ldy fbufpt                               ; get pointer to output
 13019  6504 a92e                                lda #'.'                                 ; put in "."
 13020  6506 c8                                  iny
 13021  6507 99ff00                              sta fbuffr-1,y
 13022  650a 8a                                  txa
 13023  650b f006                                beq l181_13
 13024  650d a930                                lda #'0'                                 ; get the ensuing zero
 13025  650f c8                                  iny
 13026  6510 99ff00                              sta fbuffr-1,y
 13027                          
 13028  6513 8472               l181_13          sty fbufpt                               ; save it for later
 13029                          
 13030  6515 a000               l181_14          ldy #0
 13031                          
 13032  6517 a280               foutim           ldx #$80                                 ; first pass through, accb has msb set
 13033  6519 a567               fout2            lda faclo
 13034  651b 18                                  clc
 13035  651c 793f5f                              adc foutbl+3,y
 13036  651f 8567                                sta faclo
 13037  6521 a566                                lda facmo
 13038  6523 793e5f                              adc foutbl+2,y
 13039  6526 8566                                sta facmo
 13040  6528 a565                                lda facmoh
 13041  652a 793d5f                              adc foutbl+1,y
 13042  652d 8565                                sta facmoh
 13043  652f a564                                lda facho
 13044  6531 793c5f                              adc foutbl,y
 13045  6534 8564                                sta facho
 13046  6536 e8                                  inx                                      ; it was done yet another time
 13047  6537 b004                                bcs l182_1
 13048  6539 10de                                bpl fout2
 13049  653b 3002                                bmi l182_2
 13050                          
 13051  653d 30da               l182_1           bmi fout2
 13052  653f 8a                 l182_2           txa
 13053  6540 9004                                bcc l182_3                               ; can use (a) as is
 13054  6542 49ff                                eor #$ff                                 ; find 11.(a)
 13055  6544 690a                                adc #10                                  ; c is still on to complete negation, and will always be on after
 13056                          
 13057  6546 692f               l182_3           adc #'0'-1                               ; get a character to print
 13058  6548 c8                                  iny
 13059  6549 c8                                  iny
 13060  654a c8                                  iny
 13061  654b c8                                  iny
 13062  654c 8449                                sty fdecpt
 13063  654e a472                                ldy fbufpt
 13064  6550 c8                                  iny                                      ; point to place to store output
 13065  6551 aa                                  tax
 13066  6552 297f                                and #$7f                                 ; get rid of msb
 13067  6554 99ff00                              sta fbuffr-1,y
 13068  6557 c65f                                dec deccnt
 13069  6559 d006                                bne l182_4                               ; not time for dp yet
 13070  655b a92e                                lda #'.'
 13071  655d c8                                  iny
 13072  655e 99ff00                              sta fbuffr-1,y                           ; store dp
 13073                          
 13074  6561 8472               l182_4           sty fbufpt                               ; store pointer for later
 13075  6563 a449                                ldy fdecpt
 13076  6565 8a                                  txa                                      ; complement accb
 13077  6566 49ff                                eor #$ff                                 ; complement acca
 13078  6568 2980                                and #$80                                 ; save only msb
 13079  656a aa                                  tax
 13080  656b c024                                cpy #fdcend-foutbl
 13081                          ; beq l182_5  ;for time converter ????   removed [901014]
 13082                          ; cpy #timend-foutbl
 13083  656d d0aa                                bne fout2                                ; continue with output
 13084                          
 13085  656f a472               l182_5           ldy fbufpt                               ; get back output pointer
 13086  6571 b9ff00             l182_6           lda fbuffr-1,y                           ; remove trailing blanks
 13087  6574 88                                  dey
 13088  6575 c930                                cmp #'0'
 13089  6577 f0f8                                beq l182_6
 13090  6579 c92e                                cmp #'.'
 13091  657b f001                                beq l182_7                               ; ran into dp,  stop
 13092  657d c8                                  iny                                      ; something else, save it
 13093                          
 13094  657e a92b               l182_7           lda #'+'
 13095  6580 a660                                ldx tenexp
 13096  6582 f02e                                beq fout17                               ; no exponent to output
 13097  6584 1008                                bpl l182_8
 13098  6586 a900                                lda #0
 13099  6588 38                                  sec
 13100  6589 e560                                sbc tenexp
 13101  658b aa                                  tax
 13102  658c a92d                                lda #'-'                                 ; exponent is negative
 13103                          
 13104  658e 990101             l182_8           sta fbuffr+1,y                           ; store sign of exponent
 13105  6591 a945                                lda #'E'
 13106  6593 990001                              sta fbuffr,y                             ; store the 'E' character
 13107  6596 8a                                  txa
 13108                          
 13109  6597 a22f                                ldx #'0'-1
 13110  6599 38                                  sec
 13111  659a e8                 l182_9           inx                                      ; move closer to output value
 13112  659b e90a                                sbc #10                                  ; subtract 10
 13113  659d b0fb                                bcs l182_9                               ; not negative yet
 13114                          
 13115  659f 693a                                adc #'9'+1                               ; get second output character
 13116  65a1 990301                              sta fbuffr+3,y                           ; store high digit
 13117  65a4 8a                                  txa
 13118  65a5 990201                              sta fbuffr+2,y                           ; store low digit
 13119  65a8 a900                                lda #0                                   ; put in terminator
 13120  65aa 990401                              sta fbuffr+4,y
 13121  65ad 8008                                bra fout20                               ; return
 13122                          
 13123                          
 13124  65af 99ff00             fout19           sta fbuffr-1,y                           ; store the character
 13125  65b2 a900               fout17           lda #0                                   ; store the terminator
 13126  65b4 990001                              sta fbuffr,y
 13127                          
 13128  65b7 a900               fout20           lda #<fbuffr
 13129  65b9 a001                                ldy #>fbuffr
 13130  65bb 60                                  rts                                      ; all done
 13131                          
 13132                          
 13133                          ; Exponentiation and Square Root Functions.
 13134                          ;
 13135                          ; square root function - sqr(a)
 13136                          ; use sqr(x) = x^.5
 13137                          
 13138  65bc 20a362             sqr              jsr movaf                                ; move FAC into ARG
 13139  65bf a914                                lda #<fhalf
 13140  65c1 a05f                                ldy #>fhalf
 13141                          
 13142  65c3 200e62             fpwr             jsr movfm                                ; put memory into FAC    ARG^MEM
 13143                          
 13144                          
 13145                          ; Last thing fetched is facexp into accx.
 13146                          ;
 13147                          ; Exponentiation --- x^y.
 13148                          ; n.b. 0^0=1
 13149                          ; First check if y=0, and if so the result is one.
 13150                          ; Next  check if x=0, and if so the result is zero.
 13151                          ; Then  check if x>0:
 13152                          ; if not check that y is an integer.
 13153                          ; if so negate x, so that lg doesn't give fcerr.
 13154                          ; If x is negative and y is odd, negate the result returned by exp.
 13155                          ; To compute the result use x^y = EXP((y*LOG(x))
 13156                          
 13157                          
 13158  65c6 f03f               fpwrt            beq exp                                  ; if FAC=0, just exponentiate that  ARG^FAC
 13159  65c8 a56a                                lda argexp                               ; is x=0?
 13160  65ca f37ff8                              +lbeq zerof1                             ; zero FAC
 13161                          
 13162  65cd a250                                ldx #<tempf3                             ; save it for later in a temp
 13163  65cf a000                                ldy #>tempf3
 13164  65d1 203a62                              jsr movmf                                ; FAC->MEM
 13165                          
 13166  65d4 a56f                                lda argsgn                               ; note y=0 already. that's good, in case no one calls int.
 13167  65d6 100f                                bpl l183_1                               ; no problems if x>0
 13168  65d8 206363                              jsr int                                  ; integerize the FAC
 13169  65db a950                                lda #<tempf3                             ; get addr of comperand
 13170  65dd a000                                ldy #>tempf3
 13171  65df 20f162                              jsr fcomp                                ; equal?
 13172  65e2 d003                                bne l183_1                               ; leave x neg. log will blow him out
 13173                          ;a=-1 and y is irrelavant
 13174  65e4 98                                  tya                                      ; negative x. make positive
 13175  65e5 a40a                                ldy integr                               ; get evenness
 13176                          
 13177  65e7 209562             l183_1           jsr movfa1                               ; alternate entry point.    ARG->FAC
 13178  65ea 5a                                  phy                                      ; save evenness for later
 13179  65eb 200e60                              jsr log                                  ; find log
 13180  65ee a950                                lda #<tempf3                             ; multiply FAC times LOG(x)
 13181  65f0 a000                                ldy #>tempf3
 13182  65f2 206d60                              jsr fmult
 13183  65f5 200766                              jsr exp                                  ; exponentiate the FAC
 13184  65f8 68                                  pla
 13185  65f9 4a                                  lsr                                      ; is it even?
 13186  65fa 900a                                bcc negrts                               ; yes. or x>0
 13187                          ;negate the number in FAC
 13188                          
 13189                          
 13190                          negop                                                     ; /// entry point
 13191  65fc a563                                lda facexp
 13192  65fe f006                                beq negrts
 13193  6600 a568                                lda facsgn
 13194  6602 49ff                                eor #$ff
 13195  6604 8568                                sta facsgn
 13196  6606 60                 negrts           rts
 13197                          
 13198                          ;.end
 13199                          ;[[math.ext6]]
 13200                          
 13201                          
 13202                          
 13203                          ; Exponentation Function
 13204                          ;
 13205                          ; First save the original argument and multiply the FAC by LOG2(e).  The
 13206                          ; result is used to determine if overflow will occur since
 13207                          ;
 13208                          ;  EXP(x) = 2^(x*LOG2(e))
 13209                          ;
 13210                          ; where
 13211                          ;  LOG2(e) = LOG(e), base 2
 13212                          ;
 13213                          ; Then save the integer part of this to scale the answer at the end, since
 13214                          ; 2^y=2^INT(y)*2^(y-INT(y)) and 2^INT(y) are easy to compute.  Now compute
 13215                          ;
 13216                          ;  2^(x*LOG2(e)-INT(x*LOG2(e))
 13217                          ; by
 13218                          ;  p(LOG(2)*(INT(x*LOG2(e))+1)-x
 13219                          ;
 13220                          ; where p is an approximation polynomial. The result is then scaled by the
 13221                          ; power of two previously saved.  Re: Taylor expansion.
 13222                          
 13223                          
 13224  6607 a99e               exp              lda #<logeb2                             ; multiply by LOG(e) base 2
 13225  6609 a05f                                ldy #>logeb2
 13226  660b 204860                              jsr rommlt                               ; LOGEB2->ARG, FAC=FAC*ARG
 13227  660e a571                                lda facov
 13228  6610 6950                                adc #$50                                 ; ????
 13229  6612 9003                                bcc l184_1
 13230  6614 20ba62                              jsr incrnd
 13231                          
 13232  6617 8558               l184_1           sta oldov
 13233  6619 20a662                              jsr movef                                ; to save in ARG without round.  ARG=FAC, facov=0)
 13234  661c a563                                lda facexp
 13235  661e c988                                cmp #$88                                 ; if ABS(FAC) >= 128, too big
 13236  6620 9003                                bcc l184_3
 13237                          
 13238  6622 204361             l184_2           jsr mldvex                               ; overflow or overflow
 13239  6625 206363             l184_3           jsr int                                  ; FAC=INT(FAC), uses facov
 13240  6628 a50a                                lda integr                               ; get low part
 13241  662a 18                                  clc
 13242  662b 6981                                adc #$81
 13243  662d f0f3                                beq l184_2                               ; overflow or overflow!!
 13244                          
 13245  662f 38                                  sec
 13246  6630 e901                                sbc #1                                   ; subtract it
 13247  6632 48                                  pha                                      ; save a while
 13248                          
 13249  6633 a205                                ldx #5                                   ; swap FAC and ARG
 13250  6635 b56a               l184_4           lda argexp,x
 13251  6637 b463                                ldy facexp,x
 13252  6639 9563                                sta facexp,x
 13253  663b 946a                                sty argexp,x
 13254  663d ca                                  dex
 13255  663e 10f5                                bpl l184_4
 13256                          
 13257  6640 a558                                lda oldov
 13258  6642 8571                                sta facov
 13259  6644 20a85d                              jsr fsubt                                ; FAC=ARG-FAC
 13260  6647 20fc65                              jsr negop                                ; negate FAC
 13261  664a a975                                lda #<expcon
 13262  664c a05f                                ldy #>expcon
 13263  664e 207066                              jsr poly
 13264  6651 a900                                lda #0
 13265  6653 8570                                sta arisgn                               ; multiply by positive 1.0
 13266                          
 13267  6655 68                                  pla                                      ; recall scale factor
 13268  6656 202961                              jsr mldexp                               ; modify facexp and check for overflow
 13269  6659 60                                  rts                                      ; (has to do jsr due to pla's in muldiv)
 13270                          
 13271                          ;[[math.polyeval]]
 13272                          
 13273                          
 13274                          ; Polynomial Evaluator and the Random Number Generator.
 13275                          ;
 13276                          ; Evaluate  p(x^2)*x
 13277                          ; The pointer to degree is in (a,y) and the constants follow the degree.
 13278                          ; For x=FAC, compute  c0*x + c1*x^3 + c2*x^5 + c3*x^7 +...+ c(n)*x^(2*n+1)
 13279                          
 13280                          
 13281  665a 8572               polyx            sta polypt                               ; retain polynomial pointer for later
 13282  665c 8473                                sty polypt+1
 13283  665e 203662                              jsr mov1f                                ; save FAC in factmp (y=0 upon return)
 13284  6661 a959                                lda #tempf1
 13285  6663 206d60                              jsr fmult                                ; compute x^2.
 13286  6666 207466                              jsr poly1                                ; compute p(x^2).
 13287  6669 a959                                lda #<tempf1
 13288  666b a000                                ldy #>tempf1
 13289  666d 83fef9                              +lbra fmult                              ; multiply by FAC again
 13290                          
 13291                          
 13292                          ; Polynomial Evaluator
 13293                          ;
 13294                          ; Pointer to degree is in (a,y).
 13295                          ; Compute:  c0+c1*x+c2*x^2+c3*x^3+c4*x^4...+c(n-1)*x^(n-1)+c(n)*x^n
 13296                          ;  which is roughly (LOG(2)^n)/LOG(EXP(1))/n!
 13297                          
 13298                          
 13299  6670 8572               poly             sta polypt
 13300  6672 8473                                sty polypt+1
 13301                          
 13302  6674 203362             poly1            jsr mov2f                                ; save FAC (rounds, .y=0)
 13303  6677 b172                                lda (polypt),y
 13304  6679 8569                                sta degree
 13305  667b e372                                inw polypt
 13306  667d a572                                lda polypt
 13307  667f a473                                ldy polypt+1
 13308                          
 13309  6681 204860             l185_1           jsr rommlt
 13310  6684 a572                                lda polypt                               ; get current pointer
 13311  6686 a473                                ldy polypt+1
 13312  6688 18                                  clc
 13313  6689 6905                                adc #5
 13314  668b 9001                                bcc l185_2
 13315  668d c8                                  iny
 13316  668e 8572               l185_2           sta polypt
 13317  6690 8473                                sty polypt+1
 13318  6692 205160                              jsr romadd                               ; add in constant
 13319  6695 a95e                                lda #<tempf2                             ; multiply the original FAC
 13320  6697 a000                                ldy #>tempf2
 13321  6699 c669                                dec degree                               ; done?
 13322  669b d0e4                                bne l185_1
 13323  669d 60                                  rts                                      ; yes
 13324                          
 13325                          ;.end
 13326                          ;[[math.ext7]]
 13327                          
 13328                          
 13329                          
 13330                          ; Sine, Cosine, and Tangent Functions.
 13331                          
 13332                          
 13333                          
 13334                          ; Cosine function cos(x)=sin(x+pi/2)
 13335                          
 13336                          
 13337  669e a923               cos              lda #<pi2                                ; pointer to pi/2
 13338  66a0 a05f                                ldy #>pi2
 13339  66a2 205160                              jsr romadd                               ; add it in.  fall into sine
 13340                          
 13341                          
 13342                          
 13343                          ; Sine function
 13344                          ;
 13345                          ; Use identities to get FAC in quadrants I or IV.  The FAC is divided by 2*pi
 13346                          ; and the integer part is ignored because sin(x+2*pi)=sin(x).  Then the
 13347                          ; argument can be compared with pi/2 by comparing the result of the division
 13348                          ; with pi/2(2*pi)=1/4.  Identities are then used to get the result in quadrants
 13349                          ; I or IV.  An approximation polynomial is then used to compute sin(x).
 13350                          
 13351                          
 13352  66a5 20a362             sin              jsr movaf
 13353  66a8 a928                                lda #<twopi                              ; get pointer to divisor
 13354  66aa a05f                                ldy #>twopi
 13355  66ac a66f                                ldx argsgn                               ; get sign of result
 13356  66ae 207161                              jsr fdivf
 13357  66b1 20a362                              jsr movaf                                ; get result into ARG
 13358  66b4 206363                              jsr int                                  ; integerize FAC
 13359  66b7 a900                                lda #0
 13360  66b9 8570                                sta arisgn                               ; always have the same sign
 13361  66bb 20a85d                              jsr fsubt                                ; keep only the fractional part
 13362  66be a90a                                lda #<fr4                                ; get pointer to 1/4
 13363  66c0 a05f                                ldy #>fr4
 13364  66c2 205760                              jsr romsub
 13365  66c5 a568                                lda facsgn                               ; save sign for later
 13366  66c7 48                                  pha
 13367  66c8 100d                                bpl sin1                                 ; first quadrant
 13368  66ca 204d60                              jsr faddh                                ; add 1/2 to FAC
 13369  66cd a568                                lda facsgn                               ; sign is negative?
 13370  66cf 3009                                bmi sin2
 13371  66d1 a514                                lda tansgn                               ; quads II and III come here
 13372  66d3 49ff                                eor #$ff
 13373  66d5 8514                                sta tansgn
 13374                          
 13375  66d7 20fc65             sin1             jsr negop                                ; if positive, negate it
 13376                          
 13377  66da a90a               sin2             lda #<fr4                                ; pointer to 1/4
 13378  66dc a05f                                ldy #>fr4
 13379  66de 205160                              jsr romadd                               ; add it in
 13380  66e1 68                                  pla                                      ; get original quadrant
 13381  66e2 1003                                bpl l186_1
 13382  66e4 20fc65                              jsr negop                                ; if negative, negate result
 13383                          
 13384  66e7 a9b2               l186_1           lda #<sincon
 13385  66e9 a05f                                ldy #>sincon
 13386  66eb 836dff                              +lbra polyx                              ; do approximation polyomial
 13387                          
 13388                          
 13389                          
 13390                          ; Tangent function
 13391                          
 13392                          
 13393  66ee 203662             tan              jsr mov1f                                ; move FAC into temporary
 13394  66f1 a900                                lda #0
 13395  66f3 8514                                sta tansgn                               ; remember whether to negate
 13396  66f5 20a566                              jsr sin                                  ; compute the sin
 13397  66f8 a250                                ldx #<tempf3
 13398  66fa a000                                ldy #>tempf3
 13399  66fc 203a62                              jsr movmf                                ; put sign into other temp
 13400  66ff a959                                lda #<tempf1
 13401  6701 a000                                ldy #>tempf1
 13402  6703 200e62                              jsr movfm                                ; put this memory location into FAC
 13403  6706 a900                                lda #0
 13404  6708 8568                                sta facsgn                               ; start off positive
 13405  670a a514                                lda tansgn
 13406  670c 201c67                              jsr l187_1                               ; compute cosine
 13407  670f a950                                lda #<tempf3
 13408  6711 a000                                ldy #>tempf3                             ; address of sine value
 13409                          ; bra fdiv ;divide sine by cosine and return
 13410  6713 20f760                              jsr conupk                               ; unpack constant    [910226] FAB
 13411  6716 f32fc7                              +lbeq overr                              ; overflow error     "
 13412  6719 836afa                              +lbra fdivt                              ; "
 13413                          
 13414  671c 48                 l187_1           pha                                      ; cosc.
 13415  671d 80b8                                bra sin1
 13416                          
 13417                          
 13418                          ; Arctangent function
 13419                          ;
 13420                          ; Use identities to get arg between 0 and 1 and then use an approximation
 13421                          ; polynomial to compute arctan(x).
 13422                          
 13423                          
 13424  671f a568               atn              lda facsgn                               ; what is sign?
 13425  6721 48                                  pha                                      ; save for later
 13426  6722 1003                                bpl l188_1
 13427  6724 20fc65                              jsr negop                                ; if negative, negate FAC
 13428                          ;use arctan(x)=-arctan(-x)
 13429  6727 a563               l188_1           lda facexp
 13430  6729 48                                  pha                                      ; save this too for later
 13431  672a c981                                cmp #$81                                 ; see if FAC >= 1.0
 13432  672c 9007                                bcc l188_2                               ; it is less than 1
 13433  672e a999                                lda #<fone                               ; get pntr to 1.0
 13434  6730 a05f                                ldy #>fone
 13435  6732 205d60                              jsr romdiv                               ; compute reciprocal
 13436                          ;use aectan(x)=pi/2-arctan(1/x)
 13437  6735 a9d1               l188_2           lda #<atncon                             ; pointer to arctan constants
 13438  6737 a05f                                ldy #>atncon
 13439  6739 205a66                              jsr polyx
 13440  673c 68                                  pla
 13441  673d c981                                cmp #$81                                 ; was original argument < 1?
 13442  673f 9007                                bcc l188_3                               ; yes
 13443  6741 a923                                lda #<pi2
 13444  6743 a05f                                ldy #>pi2
 13445  6745 205760                              jsr romsub                               ; subtract arctan from pi/2
 13446                          
 13447  6748 68                 l188_3           pla                                      ; was original aurgument positive?
 13448  6749 1003                                bpl l188_4                               ; yes
 13449  674b 83affe                              +lbra negop                              ; if negative, negate result
 13450                          
 13451  674e 60                 l188_4           rts                                      ; all done
 13452                          
 13453                          ;.end
 13454                          ;[[boot]]
 13455                          
 13456                          
 13457                          
 13458                          ;****************************************************************************
 13459                          ; BOOT  Boot has three modes of operation...
 13460                          ;
 13461                          ;   1. *B*LOAD a given binary file and SYS to its load address.
 13462                          ;   2. *D*LOAD a BASIC file named AUTOBOOT.C65* and RUN it.
 13463                          ;   3. BOOT SYS loads the home sector to $0400 and JMPs to it.
 13464                          ;
 13465                          ; For modes 1 & 2, syntax is the same as BLOAD.  Differentiate
 13466                          ; between the two modes via the presence of a filename.  All other
 13467                          ; parameters, such as drive and device numbers, are utilized in the
 13468                          ; normal manner.  For mode 3 there are no options.  It's intended
 13469                          ; to boot a new OS.  BASIC is turned off if it's successful.  If it
 13470                          ; fails, the run time stack & sprites might be corrupted.
 13471                          ;****************************************************************************
 13472                          
 13473  674f c99e               boot             cmp #sys_token                           ; BOOTSYS?      [910111]
 13474  6751 d00d                                bne l189_1                               ; no
 13475  6753 208322                              jsr chrget                               ; yes- eat token
 13476  6756 2059ff                              jsr _bootsys                             ; attempt to boot a new OS
 13477  6759 902f                                bcc l189_4                               ; returned to us after successful install
 13478  675b a224                                ldx #errbdk                              ; bootsys failed, report 'bad disk'????
 13479  675d 83f0c6                              +lbra error
 13480                          
 13481  6760 4f7e03             l189_1           bbr4 runmod,l189_2                       ; Error if in Edit mode     [910620]
 13482  6763 83f4d5                              +lbra edit_err
 13483                          
 13484  6766 a900               l189_2           lda #0                                   ; BOOT "filename"     [910417]
 13485  6768 850c                                sta verck                                ; want 'load', not 'verify'
 13486  676a a9e6                                lda #$e6                                 ; set up parameters for DOS parser like BLOAD
 13487  676c a2fc                                ldx #$fc
 13488  676e 202274                              jsr dosprx                               ; parse the command
 13489  6771 0f7f17                              bbr0 parsts,l189_5                       ; was there a filename?  branch if not
 13490  6774 20ed71                              jsr bload_boot                           ; yes- bload it
 13491  6777 b3bd00                              +lbcs erexit                             ; load error
 13492                          
 13493                          ; ldx current_bank ;assume no B(ank) arg was given    [910114]
 13494                          ; bbr0 parstx,l189_3  ; correct, use current setup
 13495  677a ae8c11                              ldx dosbnk                               ; else use given bank number
 13496  677d 8602               l189_3           stx _bank
 13497  677f a5ac                                lda _starting_addr                       ; set up address BLOAD loaded to
 13498  6781 8504                                sta _pclo
 13499  6783 a5ad                                lda _starting_addr+1
 13500  6785 8503                                sta _pchi
 13501  6787 206eff                              jsr _jsr_far                             ; call it
 13502  678a 60                 l189_4           rts
 13503                          
 13504  678b a0ff               l189_5           ldy #$ff
 13505  678d c8                 l189_6           iny                                      ; Copy default filename from ROM into buffer
 13506  678e b92868                              lda autoboot_filename,y
 13507  6791 999111                              sta savram,y
 13508  6794 d0f7                                bne l189_6                               ; null terminated
 13509                          
 13510  6796 8c8511                              sty dosf1l                               ; length not counting terminator
 13511  6799 e77e                                smb6 runmod                              ; set flag for load not to go to ready
 13512  679b 207b71                              jsr dload_boot                           ; Load it
 13513  679e b39600                              +lbcs erexit                             ; error if problems
 13514  67a1 8320d6                              +lbra run_a_program                      ; else go run it
 13515                          
 13516                          
 13517                          ; AUTOBOOT_CSG Runs a system diagnostic if PB0 is low after initialization.
 13518                          ;  Diagnostic is copied to RAM-0 from ROM-2 and jumped to.
 13519                          
 13520                          autobootCSG                                               ; Run ROMed diagnostic if PB0 low   [911105]
 13521  67a4 ad01dd                              lda $dd01
 13522  67a7 4a                                  lsr
 13523  67a8 b032                                bcs autoboot                             ; no, try to boot from disk
 13524                          
 13525  67aa 78                                  sei                                      ; prevent IRQ from wacking code DL'd to $1xxx  [911106]
 13526  67ab a20b                                ldx #12-1
 13527  67ad bdd067             l190_1           lda l190_2,x                             ; prep DMA list
 13528  67b0 9d4401                              sta dma1_cmd,x
 13529  67b3 ca                                  dex
 13530  67b4 10f7                                bpl l190_1
 13531                          
 13532  67b6 a900                                lda #0
 13533  67b8 a201                                ldx #>dma1_cmd                           ; copy program from ROM to RAM
 13534  67ba a044                                ldy #<dma1_cmd
 13535  67bc 8d02d7                              sta dma_ctlr+2                           ; dma_list bank
 13536  67bf 8e01d7                              stx dma_ctlr+1                           ; dma_list hi
 13537  67c2 8c00d7                              sty dma_ctlr                             ; dma_list lo & trigger
 13538                          
 13539                          ; jmp run_a_program ;if 'program' was BASIC
 13540                          ; lda #0   ;else set up arg's for call to 'long jmp'  [911105]
 13541  67c5 8502                                sta _bank
 13542  67c7 8504                                sta _pclo
 13543  67c9 a910                                lda #$10
 13544  67cb 8503                                sta _pchi
 13545  67cd 4c71ff                              jmp _jmp_far                             ; jump to code, no return.  NOTE: this *MAPs* RAM-0 into context!
 13546                          
 13547                          ; move from $024001 to $002001, $3FFF bytes  BASIC program
 13548                          ;l190_2 .byte $00,$ff,$3f,$01,$40,$02,$01,$20,$00,$00,$00,$00
 13549                          
 13550                          ; move from $024000 to $1000, $4000 bytes   Diagnostic  [911105]
 13551  67d0 0000400040020010...l190_2           !text $00,$00,$40,$00,$40,$02,$00,$10,$00,0,0,0
 13552                          
 13553                          
 13554                          ; AUTOBOOT Attempts to RUN a disk program after cold startup.  The
 13555                          ;  program must be a BASIC program called "AUTOBOOT.C65*"
 13556                          
 13557                          autoboot
 13558  67dc a900                                lda #0                                   ; Select internal drive
 13559  67de 8d80d0                              sta fdc
 13560  67e1 2c82d0             l191_1           bit fdc+2                                ; busywait
 13561  67e4 30fb                                bmi l191_1
 13562  67e6 ad83d0                              lda fdc+3                                ; See if a diskette is present
 13563  67e9 2908                                and #$08
 13564  67eb f03a                                beq l191_3                               ; exit with no action taken if not
 13565                          
 13566  67ed a9e6                                lda #$e6                                 ; set up parameters for DOS parser like BLOAD
 13567  67ef a2fc                                ldx #$fc
 13568  67f1 202274                              jsr dosprx                               ; let the parser init DOS stuff
 13569                          
 13570  67f4 a0ff                                ldy #$ff
 13571  67f6 c8                 l191_2           iny                                      ; Copy filename from ROM into buffer
 13572  67f7 b92868                              lda autoboot_filename,y
 13573  67fa 999111                              sta savram,y
 13574  67fd d0f7                                bne l191_2                               ; null terminated
 13575  67ff 8c8511                              sty dosf1l                               ; length not counting terminator
 13576                          
 13577  6802 a941                                lda #%01000001                           ; set flag for load indicating autoboot
 13578  6804 857e                                sta runmod                               ; set flag for load not to go to ready
 13579  6806 207b71                              jsr dload_boot                           ; skip parser & load it
 13580                          
 13581  6809 a900                                lda #0                                   ; clear autoboot flags
 13582  680b 857e                                sta runmod
 13583  680d da                                  phx                                      ; save end address
 13584  680e 5a                                  phy
 13585  680f 20b7ff                              jsr _readst                              ; get status report, but check it later
 13586  6812 48                                  pha
 13587  6813 209a78                              jsr Suck_DS                              ; clear any DOS errors (to kill error LED)
 13588  6816 68                                  pla                                      ; now check I/O status
 13589  6817 7a                                  ply
 13590  6818 fa                                  plx
 13591  6819 29bf                                and #$bf                                 ; EOI is okay
 13592  681b d00a                                bne l191_3                               ; outside problems
 13593  681d b008                                bcs l191_3                               ; inside problems
 13594                          
 13595  681f 8682                                stx text_top                             ; success- set end address & run it
 13596  6821 8483                                sty text_top+1
 13597  6823 58                                  cli
 13598  6824 839dd5                              +lbra run_a_program
 13599                          
 13600  6827 60                 l191_3           rts                                      ; failure- go_ready
 13601                          
 13602                          
 13603                          autoboot_filename
 13604  6828 4155544f424f4f54...                 !text "AUTOBOOT.C65*",0
 13605                          
 13606                          
 13607                          
 13608                          
 13609  6836 aa                 erexit           tax                                      ; set termination flags
 13610  6837 d316c6                              +lbne error                              ; normal error
 13611  683a 8395c4                              +lbra break_exit                         ; user break
 13612                          
 13613                          
 13614                          
 13615  683d 20d2ff             outch            jsr _bsout
 13616  6840 b0f4                                bcs erexit
 13617  6842 60                                  rts
 13618                          
 13619                          
 13620                          
 13621  6843 20cfff             inchr            jsr _basin
 13622  6846 b0ee                                bcs erexit
 13623  6848 60                                  rts
 13624                          
 13625                          
 13626                          coout
 13627                          ; jsr put_io_in_map
 13628  6849 20c9ff                              jsr _chkout
 13629  684c 20c169                              jsr dschk                                ; see if device # >=4, and clear DS if so
 13630  684f b0e5                                bcs erexit                               ; take error exit of there was one
 13631  6851 60                                  rts
 13632                          
 13633                          
 13634                          coin
 13635                          ; jsr put_io_in_map
 13636  6852 20c6ff                              jsr _chkin
 13637  6855 20c169                              jsr dschk                                ; see if device # >=4, and clear DS if so
 13638  6858 b0dc                                bcs erexit
 13639  685a 60                                  rts
 13640                          
 13641                          cgetl
 13642                          ; jsr put_io_in_map
 13643  685b 20e4ff                              jsr _getin
 13644  685e b371c4                              +lbcs break_exit                         ; 'stop' key was pressed
 13645  6861 60                                  rts
 13646                          
 13647                          
 13648  6862 202569             save             jsr plsv                                 ; parse parameters, dschk
 13649                          
 13650                          
 13651                          savenp                                                    ; Save Program (from DSave)
 13652  6865 a682                                ldx text_top                             ; ending address
 13653  6867 a483                                ldy text_top+1
 13654  6869 a92d                                lda #<txttab                             ; pointer to start address
 13655                          
 13656                          
 13657                          savenb                                                    ; Save Binary (from BSave & KEY SAVE)
 13658                          ; jsr put_io_in_map
 13659  686b 20d8ff                              jsr _savesp                              ; save it
 13660                          
 13661                          ; Any changes to the following code must be duplicated at:
 13662                          ;  bload
 13663                          ;  load (load_file)
 13664                          
 13665                          exit_disk_op
 13666                          exit_disk_operation
 13667  686e 08                                  php                                      ; preserve kernel error status (.c)
 13668  686f 48                                  pha                                      ; preserve kernel error # (.a)
 13669  6870 206e72                              jsr print_dos_error                      ; print DOS error msg if any only in direct mode
 13670  6873 68                                  pla
 13671  6874 28                                  plp
 13672  6875 900f                                bcc l192_3                               ; branch if no error (rts)
 13673  6877 ff7e0a                              bbs7 runmod,l192_2                       ; branch if run mode (erexit)
 13674  687a c904                                cmp #errfnf                              ; is it 'file not found' catch-all?
 13675  687c d005                                bne l192_1                               ; no  (erexit)
 13676  687e 8dc702                              sta errnum                               ; yes- save error # for 'er'
 13677  6881 0980                                ora #$80                                 ; but no errdis
 13678  6883 38                 l192_1           sec
 13679  6884 b0b0               l192_2           bcs erexit                               ; exit if kernel problem (rts)
 13680  6886 60                 l192_3           rts
 13681                          
 13682                          
 13683  6887 a901               verify           lda #1                                   ; verify flag
 13684  6889 2c                                  !text $2c                                ; skip two bytes
 13685                          
 13686  688a a900               load             lda #0                                   ; load flag
 13687  688c 850c                                sta verck
 13688  688e 4f7e03             l193_1           bbr4 runmod,l193_2                       ; Error if in Edit mode     [910620]
 13689  6891 83c6d4                              +lbra edit_err
 13690  6894 202569             l193_2           jsr plsv                                 ; parse parameters, dschk
 13691                          
 13692                          cld10                                                     ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< entry from dload
 13693                          ; jsr put_io_in_map
 13694  6897 a50c                                lda verck
 13695  6899 a62d                                ldx txttab                               ; .x and .y have alt...
 13696  689b a42e                                ldy txttab+1                             ; ...load address
 13697                          
 13698                          ; Any changes to the following code must be duplicated at:
 13699                          ;  bload
 13700                          ;  save (exit_disk_op)
 13701                          
 13702                          load_file
 13703  689d 20d5ff                              jsr _loadsp                              ; load it
 13704  68a0 8f7e36                              bbs0 runmod,cld20                        ; skip error checks if autoboot (rts)
 13705  68a3 da                                  phx                                      ; save end address
 13706  68a4 5a                                  phy
 13707  68a5 08                                  php                                      ; save kernel load status (.c)
 13708  68a6 48                                  pha                                      ; save kernel error # (.a)
 13709  68a7 20b7ff                              jsr _readst                              ; save I/O status byte
 13710  68aa 857f                                sta parsts
 13711  68ac 206e72                              jsr print_dos_error                      ; report error msg if any only in direct mode
 13712  68af 68                                  pla                                      ; restore error stuff
 13713  68b0 28                                  plp
 13714  68b1 9010                                bcc l194_3                               ; branch if no error (rts)
 13715  68b3 ff7e0a                              bbs7 runmod,l194_2                       ; branch if run mode (erexit)
 13716  68b6 c904                                cmp #errfnf                              ; is it 'file not found' catch-all?
 13717  68b8 d005                                bne l194_1                               ; no  (erexit)
 13718  68ba 8dc702                              sta errnum                               ; yes- save error # for 'er'
 13719  68bd 0980                                ora #$80                                 ; but no errdis
 13720  68bf 38                 l194_1           sec
 13721  68c0 b374ff             l194_2           +lbcs erexit                             ; exit if kernel problem
 13722  68c3 7a                 l194_3           ply                                      ; restore end address
 13723  68c4 fa                                  plx
 13724  68c5 a50c                                lda verck
 13725  68c7 f011                                beq cld50                                ; was load
 13726                          
 13727                          ; Finish verify
 13728                          
 13729                          verify_check
 13730  68c9 a21c                                ldx #ervfy                               ; assume error
 13731                          ; jsr _readst  ;read status
 13732  68cb cf7f14                              bbs4 parsts,cld55                        ; branch if 'verify' error
 13733  68ce ff7e08                              bbs7 runmod,cld20                        ; branch if not direct mode
 13734                          verify_ok
 13735  68d1 207dff                              jsr _primm
 13736  68d4 0d4f4b0d00                          !text cr,"OK", cr,0
 13737  68d9 60                 cld20            rts
 13738                          
 13739                          
 13740                          
 13741                          ; Finish load
 13742                          
 13743                          cld50
 13744                          ; jsr _readst  ;check I/O status
 13745  68da a57f                                lda parsts
 13746  68dc 29bf                                and #%10111111                           ; EOI is okay, so mask it
 13747  68de f005                                beq cld60                                ; good- finish load operation
 13748                          
 13749                          load_error
 13750  68e0 a21d                                ldx #erload
 13751  68e2 836bc5             cld55            +lbra error
 13752                          
 13753                          
 13754  68e5 8682               cld60            stx text_top
 13755  68e7 8483                                sty text_top+1                           ; end load address
 13756                          
 13757  68e9 ff7e0c                              bbs7 runmod,cld70                        ; branch if not direct mode
 13758  68ec ef7eea                              bbs6 runmod,cld20                        ; special "RUN file_name" flag...get out here (rts)
 13759                          
 13760  68ef 20b930                              jsr link_program                         ; relink
 13761  68f2 20a134                              jsr runc                                 ; clear vars
 13762  68f5 83f6c5                              +lbra ready_2                            ; print 'ready' & return to main
 13763                          
 13764                          
 13765                          ; Program load
 13766                          
 13767  68f8 201f35             cld70            jsr reset_txtptr
 13768  68fb 20b930                              jsr link_program
 13769  68fe 8306cc                              +lbra fload
 13770                          
 13771                          
 13772  6901 207469             open             jsr paoc                                 ; parse statement
 13773  6904 20c0ff                              jsr _open                                ; open it
 13774  6907 8009                                bra close_out_1
 13775                          
 13776                          
 13777                          
 13778  6909 207469             close            jsr paoc                                 ; parse statement
 13779                          ; jsr put_io_in_map
 13780  690c a54b                                lda andmsk                               ; get la
 13781                          
 13782                          
 13783                          close_out                                                 ; enter with .a=LA   [900725]
 13784  690e 18                                  clc                                      ; flag a real close
 13785  690f 20c3ff                              jsr _close                               ; close it
 13786                          
 13787                          close_out_1
 13788  6912 08                                  php
 13789  6913 48                                  pha
 13790  6914 a5ba                                lda _fa                                  ; special error checking if disk op
 13791  6916 c908                                cmp #8
 13792  6918 9005                                bcc l195_1
 13793  691a 68                                  pla
 13794  691b 28                                  plp
 13795  691c 8350ff                              +lbra exit_disk_operation                ; disk
 13796                          
 13797  691f 68                 l195_1           pla                                      ; something else
 13798  6920 28                                  plp
 13799  6921 b313ff                              +lbcs erexit
 13800  6924 60                                  rts
 13801                          
 13802                          
 13803                          ; Parse LOAD, SAVE, & VERIFY commands
 13804                          
 13805                          plsv
 13806  6925 a900                                lda #0                                   ; set default filename (none)
 13807  6927 20bdff                              jsr _setnam
 13808  692a ae0611                              ldx _default_drive                       ; set default device # (dosffn)
 13809  692d a000                                ldy #0                                   ; command 0
 13810  692f 20baff                              jsr _setlfs
 13811  6932 a584                                lda text_bank                            ; all loads to   bank 0 ???? set default memory banks
 13812  6934 a685                                ldx var_bank                             ; all names from bank 1 ????   [910620]
 13813  6936 206bff                              jsr _setbank
 13814                          
 13815  6939 206169                              jsr paoc20                               ; by-pass junk
 13816  693c 20b869                              jsr paoc15                               ; get/set file name
 13817  693f 206169                              jsr paoc20                               ; by-pass junk
 13818  6942 205b69                              jsr plsv7                                ; get ',fa'
 13819  6945 a000                                ldy #0                                   ; command 0
 13820  6947 864b                                stx andmsk
 13821  6949 20baff                              jsr _setlfs
 13822  694c 206169                              jsr paoc20                               ; by-pass junk
 13823  694f 205b69                              jsr plsv7                                ; get ',sa'
 13824  6952 8a                                  txa                                      ; new command
 13825  6953 a8                                  tay
 13826  6954 a64b                                ldx andmsk                               ; device #
 13827  6956 20baff                              jsr _setlfs
 13828  6959 8066                                bra dschk                                ; make dosfa current   [900801]
 13829                          
 13830                          
 13831                          
 13832                          ; Look for comma followed by byte
 13833                          
 13834  695b 206969             plsv7            jsr paoc30
 13835  695e 830cf4                              +lbra getbyt
 13836                          
 13837                          
 13838                          
 13839                          ; Skip return if next char is end
 13840                          
 13841  6961 208522             paoc20           jsr chrgot
 13842  6964 d002                                bne paocx
 13843  6966 68                                  pla
 13844  6967 68                                  pla
 13845  6968 60                 paocx            rts
 13846                          
 13847                          
 13848                          
 13849                          ; Check for comma and good stuff
 13850                          
 13851  6969 205b4e             paoc30           jsr chkcom                               ; check comma
 13852                          
 13853  696c 208522             paoc32           jsr chrgot                               ; get current character
 13854  696f d0f7                                bne paocx                                ; is okay
 13855  6971 83d7c4                              +lbra snerr                              ; bad...end of line
 13856                          
 13857                          
 13858                          ; Parse OPEN/CLOSE
 13859                          
 13860  6974 a900               paoc             lda #sys_bank                            ; ????      [910620]
 13861  6976 a685                                ldx var_bank                             ;
 13862  6978 206bff                              jsr _setbank                             ; filename bank     (string bank)????
 13863  697b 20bdff                              jsr _setnam                              ; default file name (null)
 13864  697e 206c69                              jsr paoc32                               ; must get something
 13865  6981 206c5d                              jsr getbyt                               ; get la
 13866  6984 864b                                stx andmsk
 13867  6986 8a                                  txa
 13868  6987 ae0611                              ldx _default_drive                       ; default device
 13869  698a a000                                ldy #0                                   ; default command
 13870  698c 20baff                              jsr _setlfs                              ; store it
 13871  698f 206169                              jsr paoc20                               ; skip junk
 13872  6992 205b69                              jsr plsv7
 13873  6995 864c                                stx eormsk
 13874  6997 a000                                ldy #0                                   ; default sa (command)
 13875  6999 a54b                                lda andmsk                               ; get la
 13876  699b e003                                cpx #3
 13877  699d 9001                                bcc l196_1
 13878  699f 88                                  dey                                      ; if sa not given and fa=serial bus, default to $ff
 13879  69a0 20baff             l196_1           jsr _setlfs                              ; store them
 13880  69a3 206169                              jsr paoc20                               ; skip junk
 13881  69a6 205b69                              jsr plsv7                                ; get sa
 13882  69a9 8a                                  txa
 13883  69aa a8                                  tay
 13884  69ab a64c                                ldx eormsk
 13885  69ad a54b                                lda andmsk
 13886  69af 20baff                              jsr _setlfs                              ; set up real everything
 13887  69b2 206169                              jsr paoc20
 13888  69b5 206969                              jsr paoc30
 13889                          
 13890  69b8 20675b             paoc15           jsr frmstr                               ; do frmevl, frestr. return with len in a, index =~string
 13891  69bb 20dd5b                              jsr getspa                               ; ????fixes old PET bug- load"string",val(chr$(56)) [910917]
 13892                          ; ldx index1
 13893                          ; ldy index1+1
 13894  69be 20bdff                              jsr _setnam                              ; bank always set at plsv
 13895                          ;fall into dschk     [900801]
 13896                          
 13897                          
 13898                          
 13899  69c1 08                 dschk            php                                      ; check if current device >=8, and clear DS if so
 13900  69c2 48                                  pha
 13901  69c3 a5ba                                lda _fa
 13902  69c5 c901                                cmp #1
 13903  69c7 d005                                bne l197_1
 13904  69c9 ad0611                              lda _default_drive
 13905  69cc 85ba                                sta _fa
 13906  69ce c908               l197_1           cmp #8                                   ; ????     [900807]
 13907  69d0 9006                                bcc l197_2
 13908  69d2 8d8211                              sta dosfa                                ; also make last DOS device = current device
 13909  69d5 208278                              jsr Clear_DS
 13910  69d8 68                 l197_2           pla
 13911  69d9 28                                  plp
 13912  69da 60                                  rts
 13913                          
 13914                          
 13915                          ;k_readst
 13916                          ; jsr put_io_in_map
 13917                          ; jmp _readst
 13918                          
 13919                          
 13920                          
 13921                          ;k_setlfs
 13922                          ; jsr put_io_in_map
 13923                          ; jmp _setlfs
 13924                          
 13925                          
 13926                          
 13927                          ;k_setnam
 13928                          ; jsr put_io_in_map
 13929                          ; jmp _setnam
 13930                          
 13931                          
 13932                          
 13933                          ;k_basin
 13934                          ; jsr put_io_in_map
 13935                          ; jmp _basin
 13936                          
 13937                          
 13938                          ;k_bsout
 13939                          ; jsr put_io_in_map
 13940                          ; jmp _bsout
 13941                          
 13942                          
 13943                          ;k_clrch
 13944                          ; jsr put_io_in_map
 13945                          ; jmp _clrch
 13946                          
 13947                          
 13948                          
 13949                          ;k_close
 13950                          ; jsr put_io_in_map
 13951                          ; jmp _close
 13952                          
 13953                          
 13954                          
 13955                          ;k_clall
 13956                          ; jsr put_io_in_map
 13957                          ; jmp _clall
 13958                          
 13959                          
 13960                          
 13961                          ;k_primm
 13962                          ; jsr put_io_in_map
 13963                          ; jmp _primm
 13964                          
 13965                          
 13966                          ;k_setbank
 13967                          ; jsr put_io_in_map
 13968                          ; jmp _setbank
 13969                          ; rts
 13970                          
 13971                          
 13972                          ;k_plot
 13973                          ; sta sw_rom_ram0  ;????
 13974                          ; jmp _plot
 13975                          
 13976                          
 13977                          ;k_stop
 13978                          ; jsr put_io_in_map
 13979                          ; jmp _stop
 13980                          
 13981                          ;.end
 13982                          ;[[command.print.using]]
 13983                          
 13984                          
 13985                          ; Print Using - Formatted print routine
 13986                          ;
 13987                          ; Entered by cmd, print, or print#
 13988                          ; Syntax:  PRINT USING"****";a;b;c
 13989                          
 13990  69db 202c2e24           pudefs           !text " ,.$"                             ; default:  fill, comma, dec pnt, money symbol
 13991                          
 13992  69df a2ff               using            ldx #$ff
 13993  69e1 8eeb11                              stx endfd
 13994  69e4 208322                              jsr chrget
 13995  69e7 20ef4c                              jsr frmevl                               ; evaluate format string
 13996  69ea 20dd4c                              jsr chkstr                               ; must be string type...
 13997                          
 13998  69ed a566                                lda facmo                                ; save temp descriptor
 13999  69ef 48                                  pha
 14000  69f0 a567                                lda facmo+1
 14001  69f2 48                                  pha
 14002                          
 14003  69f3 a002                                ldy #2                                   ; move (facmo),1&2 to form,form+1
 14004  69f5 20a922             l198_1           jsr indfmo
 14005  69f8 88                                  dey
 14006  69f9 993f00                              sta form,y
 14007  69fc d0f7                                bne l198_1
 14008                          
 14009  69fe 20a922                              jsr indfmo                               ; get length
 14010  6a01 8dea11                              sta lfor
 14011  6a04 a8                                  tay
 14012  6a05 f00b                                beq l198_3                               ; syntax error if length is zero
 14013                          
 14014  6a07 88                 l198_2           dey
 14015  6a08 209d22                              jsr indfrm
 14016  6a0b c923                                cmp #'#'                                 ; at least one # in format?
 14017  6a0d f006                                beq l198_4                               ; yes...
 14018  6a0f 98                                  tya                                      ; no...end of format
 14019  6a10 d0f5                                bne l198_2                               ; no...
 14020  6a12 8336c4             l198_3           +lbra snerr                              ; yes...syntax error
 14021                          
 14022                          
 14023  6a15 a93b               l198_4           lda #';'                                 ; '
 14024  6a17 205d4e             eex2             jsr synchr                               ; check character
 14025  6a1a 8476                                sty z_p_temp_1                           ; clear flag for anaf
 14026  6a1c 8cd811                              sty bnr                                  ; set pointer to begin of no
 14027  6a1f 20ef4c                              jsr frmevl                               ; evaluate expression
 14028  6a22 7f0f39                              bbr7 valtyp,conv                         ; branch if numeric
 14029                          
 14030  6a25 20536c                              jsr ini                                  ; init counters and flags
 14031  6a28 20a16d                              jsr anaf                                 ; analyze format
 14032  6a2b aee011                              ldx chsn                                 ; > or = in format field
 14033  6a2e f015                                beq prcha                                ; branch if not
 14034  6a30 a200                                ldx #0
 14035  6a32 38                                  sec
 14036  6a33 ade611                              lda cform
 14037  6a36 e577                                sbc hulp                                 ; .a=room left in field
 14038  6a38 900b                                bcc prcha                                ; branch if no room left
 14039  6a3a a23d                                ldx #'='
 14040  6a3c ece011                              cpx chsn                                 ; = in field
 14041  6a3f d003                                bne l199_1                               ; branch if not
 14042  6a41 4a                                  lsr                                      ; .a=.a/2
 14043  6a42 6900                                adc #0                                   ; add 1 if odd
 14044                          
 14045  6a44 aa                 l199_1           tax                                      ; store no of blanks in x
 14046  6a45 a000               prcha            ldy #0
 14047  6a47 8a                 chx              txa
 14048  6a48 f005                                beq cpef                                 ; branch if no blanks
 14049  6a4a ca                                  dex
 14050                          
 14051  6a4b a920               oblk             lda #' '                                 ; output a blank
 14052  6a4d 8008                                bra outc                                 ; always
 14053                          
 14054                          
 14055  6a4f c477               cpef             cpy hulp                                 ; end of string reached?
 14056  6a51 b0f8                                bcs oblk                                 ; output blank if yes
 14057  6a53 20d522                              jsr indin1_ram1                          ; lda (index),y
 14058  6a56 c8                                  iny
 14059                          
 14060  6a57 209a6d             outc             jsr cdout                                ; output character
 14061  6a5a d0eb                                bne chx                                  ; branch if not ready
 14062  6a5c 8029                                bra reay
 14063                          
 14064                          
 14065                          
 14066  6a5e 208f64             conv             jsr fout                                 ; convert mfp to decimal
 14067                          
 14068  6a61 a0ff                                ldy #$ff                                 ; build descriptor for fout string
 14069  6a63 c8                 l200_1           iny                                      ; how big IS it?
 14070  6a64 b90001                              lda fbuffr,y
 14071  6a67 d0fa                                bne l200_1
 14072  6a69 98                                  tya
 14073  6a6a 207b5a                              jsr strspa                               ; jsr getspa,stx dsctmp+1,sty dsctmp+2,sta dsctmp,rts
 14074                          
 14075  6a6d da                                  phx
 14076  6a6e a000                                ldy #0
 14077  6a70 a264                                ldx #dsctmp+1
 14078  6a72 b90001             l200_2           lda fbuffr,y
 14079  6a75 f006                                beq l200_3
 14080  6a77 20f022                              jsr sta_far_ram1                         ; sta (dsctmp+1),y
 14081  6a7a c8                                  iny
 14082  6a7b d0f5                                bne l200_2
 14083                          
 14084  6a7d fa                 l200_3           plx
 14085  6a7e 20d05a                              jsr putnew
 14086  6a81 20536c                              jsr ini                                  ; init counters and flags
 14087  6a84 20a46a                              jsr fform                                ; output one formatted number
 14088                          
 14089  6a87 208522             reay             jsr chrgot                               ; get old character
 14090  6a8a c92c                                cmp #','                                 ; comma?
 14091  6a8c f089                                beq eex2                                 ; continue print use if yes
 14092  6a8e 38                                  sec
 14093  6a8f 6676                                ror z_p_temp_1                           ; set flag for anaf
 14094  6a91 20a16d                              jsr anaf                                 ; print rest of format
 14095  6a94 7a                                  ply                                      ; restore descriptor
 14096  6a95 68                                  pla
 14097  6a96 20715b                              jsr fretmp
 14098  6a99 208522                              jsr chrgot
 14099  6a9c c93b                                cmp #';'                                 ; semi-colon?
 14100  6a9e d357cd                              +lbne crdo                               ; end of print using
 14101  6aa1 4c8322                              jmp chrget                               ; branch if yes
 14102                          
 14103                          ;[[command.fform]]
 14104                          
 14105                          
 14106                          ;  FFORM - output a number to format
 14107                          ;
 14108                          ;  Number is in fbuffr,  format checked by anaf
 14109                          
 14110                          fform
 14111                          ; sta sw_rom_ram0 ;????
 14112  6aa4 add411                              lda pufill
 14113  6aa7 8de811                              sta blfd                                 ; set working fill char
 14114  6aaa a9ff                                lda #$ff
 14115  6aac 8de711             ana              sta sno                                  ; save blank or '-' in sno
 14116  6aaf 8002                                bra insy
 14117                          
 14118                          
 14119  6ab1 867f               stp              stx point                                ; set point pointer
 14120  6ab3 c477               insy             cpy hulp                                 ; end of no reached?
 14121  6ab5 f032                                beq eoa                                  ; branch if yes
 14122  6ab7 b90001                              lda fbuffr,y                             ; get character of no
 14123  6aba c8                                  iny
 14124  6abb c920                                cmp #' '                                 ; blank?
 14125  6abd f0f4                                beq insy                                 ; yes...span
 14126  6abf c92d                                cmp #'-'                                 ; sign no negative
 14127  6ac1 f0e9                                beq ana                                  ; yes...
 14128  6ac3 c92e                                cmp #'.'                                 ; decimal point?
 14129  6ac5 f0ea                                beq stp                                  ; yes...
 14130  6ac7 c945                                cmp #'E'                                 ; is char 'e'?
 14131  6ac9 f010                                beq lsg                                  ; yes...
 14132  6acb 9d0001                              sta fbuffr,x                             ; move number
 14133  6ace 8ed911                              stx enr                                  ; update end-no pointer
 14134  6ad1 e8                                  inx
 14135  6ad2 247f                                bit point                                ; point pointer set?
 14136  6ad4 10dd                                bpl insy                                 ; yes...
 14137  6ad6 eedf11                              inc vn                                   ; count digits before point
 14138  6ad9 80d8                                bra insy
 14139                          
 14140                          
 14141  6adb b90001             lsg              lda fbuffr,y
 14142  6ade c92d                                cmp #'-'                                 ; sign of exponent negative
 14143  6ae0 d003                                bne l201_1                               ; no...
 14144  6ae2 6edd11                              ror usgn                                 ; make sign negative
 14145  6ae5 c8                 l201_1           iny
 14146  6ae6 8cde11                              sty uexp                                 ; set exponent pointer
 14147                          
 14148  6ae9 a57f               eoa              lda point                                ; decimal found?
 14149  6aeb 1002                                bpl l202_1                               ; yes...
 14150  6aed 867f                                stx point                                ; no...add point
 14151                          
 14152  6aef 20a16d             l202_1           jsr anaf                                 ; analyze format
 14153  6af2 ade111                              lda vf
 14154  6af5 c9ff                                cmp #$ff
 14155  6af7 f029                                beq l202_3                               ; field overflow
 14156  6af9 ade411                              lda fesp                                 ; exponent in field
 14157  6afc f03f                                beq cff                                  ; convert to f format if not
 14158  6afe adde11                              lda uexp                                 ; exponent in number?
 14159  6b01 d012                                bne l202_2                               ; yes...
 14160  6b03 aed911                              ldx enr
 14161  6b06 20286c                              jsr et2                                  ; add exponent to number
 14162  6b09 de0201                              dec fbuffr+2,x
 14163  6b0c e8                                  inx
 14164  6b0d 8ede11                              stx uexp
 14165  6b10 20af6c                              jsr alg                                  ; delete leading zeros
 14166  6b13 f025                                beq hup                                  ; all zero
 14167                          
 14168  6b15 ace311             l202_2           ldy posp                                 ; + or - in format?
 14169  6b18 d017                                bne sswe                                 ; yes...
 14170  6b1a ace711                              ldy sno                                  ; +?
 14171  6b1d 3012                                bmi sswe                                 ; yes...
 14172  6b1f ade111                              lda vf
 14173                          
 14174  6b22 f068               l202_3           beq errf                                 ; no room for sign
 14175  6b24 cee111                              dec vf                                   ; reserve room
 14176  6b27 d005                                bne l202_4
 14177  6b29 ade211                              lda nf                                   ; one #?
 14178  6b2c f05e                                beq errf                                 ; yes...error
 14179                          
 14180  6b2e eedc11             l202_4           inc swe
 14181                          
 14182  6b31 20a36b             sswe             jsr shpn                                 ; shift decimal point
 14183  6b34 206d6c                              jsr uround                               ; round number
 14184  6b37 20a36b                              jsr shpn                                 ; shift again if necessary
 14185                          
 14186  6b3a 839401             hup              +lbra chout                              ; output number
 14187                          
 14188                          
 14189                          
 14190  6b3d acde11             cff              ldy uexp                                 ; exponent in no?
 14191  6b40 f015                                beq l203_2                               ; no...
 14192  6b42 8577                                sta hulp                                 ; delete exponent
 14193  6b44 38                                  sec                                      ; adjust decimal point
 14194  6b45 6ee511                              ror etof                                 ; set e-to-f flag
 14195  6b48 a47f                                ldy point
 14196  6b4a addd11                              lda usgn                                 ; exec nos3 or nos4
 14197  6b4d 1005                                bpl l203_1                               ; depends on sign of exp
 14198  6b4f 20db6b                              jsr nos3
 14199  6b52 800c                                bra l203_3
 14200                          
 14201  6b54 20bd6b             l203_1           jsr nos4
 14202                          
 14203  6b57 a47f               l203_2           ldy point                                ; at start of no?
 14204  6b59 f005                                beq l203_3                               ; yes...
 14205  6b5b 20b36c                              jsr cho                                  ; no = 0 ?
 14206  6b5e f005                                beq l203_4                               ; yes...no round
 14207                          
 14208  6b60 206d6c             l203_3           jsr uround
 14209  6b63 8003                                bra l203_5
 14210                          
 14211  6b65 cedf11             l203_4           dec vn                                   ; adjust...no was 0
 14212  6b68 38                 l203_5           sec
 14213  6b69 ade111                              lda vf
 14214  6b6c eddf11                              sbc vn
 14215  6b6f 901b                                bcc errf                                 ; no fit...error
 14216  6b71 8ddc11                              sta swe                                  ; save difference
 14217  6b74 ace311                              ldy posp                                 ; + or -?
 14218  6b77 d01b                                bne ahp                                  ; yes...
 14219  6b79 ace711                              ldy sno                                  ; get sign
 14220  6b7c 3016                                bmi ahp                                  ; positive...
 14221  6b7e a8                                  tay
 14222  6b7f f00b                                beq errf                                 ; no room for sign
 14223  6b81 88                                  dey
 14224  6b82 d013                                bne ldvn                                 ; swe<>1
 14225  6b84 ade211                              lda nf
 14226  6b87 0ddf11                              ora vn                                   ; both zero?
 14227  6b8a d0ae                                bne hup                                  ; no...
 14228                          
 14229                          
 14230  6b8c a92a               errf             lda #'*'                                 ; format error
 14231  6b8e 209a6d             stout            jsr cdout                                ; fill field with stars
 14232  6b91 d0fb                                bne stout
 14233  6b93 60                                  rts
 14234                          
 14235                          
 14236  6b94 a8                 ahp              tay                                      ; output no if swe=0
 14237  6b95 f0a3                                beq hup
 14238  6b97 addf11             ldvn             lda vn
 14239  6b9a d09e                                bne hup                                  ; vn<>0
 14240  6b9c cedc11                              dec swe                                  ; add extra 0
 14241  6b9f e676                                inc z_p_temp_1                           ; before decimal point
 14242  6ba1 8097                                bra hup
 14243                          
 14244                          
 14245                          ; Using- shift decimal point
 14246                          
 14247  6ba3 38                 shpn             sec
 14248  6ba4 ade111                              lda vf
 14249  6ba7 eddf11                              sbc vn
 14250  6baa f038                                beq rdy                                  ; format o.k
 14251  6bac a47f                                ldy point
 14252  6bae 9016                                bcc pntl                                 ; vf<vn
 14253  6bb0 8577                                sta hulp
 14254                          
 14255  6bb2 ccd911             incy             cpy enr                                  ; end of no reached?
 14256  6bb5 f002                                beq ity
 14257  6bb7 b001                                bcs nos1                                 ; yes...
 14258                          
 14259  6bb9 c8                 ity              iny
 14260  6bba eedf11             nos1             inc vn
 14261  6bbd 20f16b             nos4             jsr eado                                 ; adjust exponent
 14262  6bc0 c677                                dec hulp                                 ; ready?
 14263  6bc2 d0ee                                bne incy                                 ; no...
 14264  6bc4 f01c                                beq poit
 14265                          
 14266  6bc6 49ff               pntl             eor #$ff
 14267  6bc8 6901                                adc #1
 14268  6bca 8577                                sta hulp                                 ; =vn-vf
 14269                          
 14270  6bcc ccd811             decy             cpy bnr                                  ; begin of no?
 14271  6bcf f006                                beq inz1                                 ; yes...
 14272  6bd1 88                                  dey
 14273  6bd2 cedf11                              dec vn
 14274  6bd5 8002                                bra inz2
 14275                          
 14276                          
 14277  6bd7 e676               inz1             inc z_p_temp_1                           ; add leading zeros
 14278  6bd9 a980               inz2             lda #$80
 14279  6bdb 20f36b             nos3             jsr eadj                                 ; adjust exponent
 14280  6bde c677                                dec hulp                                 ; ready?
 14281  6be0 d0ea                                bne decy                                 ; no...
 14282                          
 14283  6be2 847f               poit             sty point                                ; decimal point pointer
 14284  6be4 60                 rdy              rts
 14285                          
 14286                          
 14287                          ; Using- adjust exponent
 14288                          
 14289  6be5 d039               sexp             bne retrn                                ; no over/underflow
 14290  6be7 4909                                eor #$09                                 ; .a is 0 or 9
 14291  6be9 9d0001                              sta fbuffr,x                             ; digit back in exp
 14292  6bec ca                                  dex                                      ; = 0 or 9
 14293  6bed ecde11                              cpx uexp
 14294  6bf0 60                                  rts
 14295                          
 14296                          
 14297  6bf1 a900               eado             lda #0
 14298  6bf3 aede11             eadj             ldx uexp
 14299  6bf6 e8                                  inx
 14300  6bf7 2ce511                              bit etof                                 ; e-to-f flag on?
 14301  6bfa 3010                                bmi l204_2                               ; yes...
 14302  6bfc 4ddd11                              eor usgn
 14303  6bff f00b                                beq l204_2                               ; ++ or --
 14304                          
 14305  6c01 20366c             l204_1           jsr tag3                                 ; inc exp, overflow?
 14306  6c04 20e56b                              jsr sexp                                 ; digit 0 if yes
 14307  6c07 b0f8                                bcs l204_1                               ; try second digit
 14308  6c09 833cc2                              +lbra overr                              ; exp>99
 14309                          
 14310  6c0c bd0001             l204_2           lda fbuffr,x
 14311  6c0f de0001                              dec fbuffr,x                             ; decrement exp
 14312  6c12 c930                                cmp #'0'                                 ; underflow on digit?
 14313  6c14 20e56b                              jsr sexp                                 ; set digit=9 if yes...
 14314  6c17 b0f3                                bcs l204_2                               ; try 2nd digit
 14315  6c19 2ce511                              bit etof                                 ; flag off?
 14316  6c1c 1005                                bpl et3                                  ; yes...
 14317  6c1e 847f                                sty point                                ; decimal point pointer
 14318                          
 14319  6c20 68                 retrn            pla
 14320  6c21 68                                  pla
 14321  6c22 60                                  rts                                      ; return to fform/main
 14322                          
 14323                          
 14324  6c23 addd11             et3              lda usgn
 14325  6c26 4980                                eor #$80                                 ; reverse sign exp
 14326  6c28 8ddd11             et2              sta usgn
 14327  6c2b a930                                lda #'0'
 14328  6c2d 9d0101                              sta fbuffr+1,x                           ; exp<0 here
 14329  6c30 a931                                lda #'1'
 14330  6c32 9d0201                              sta fbuffr+2,x
 14331  6c35 60                                  rts
 14332                          
 14333                          
 14334  6c36 bd0001             tag3             lda fbuffr,x                             ; get digit of exp
 14335  6c39 fe0001                              inc fbuffr,x                             ; increment digit
 14336  6c3c c939                                cmp #'9'                                 ; overflow
 14337  6c3e 60                                  rts                                      ; return .z set
 14338                          
 14339                          
 14340                          ; Using- ansub: load format field char in .a
 14341                          
 14342  6c3f 18                 ansub            clc
 14343  6c40 c8                                  iny                                      ; begin format?
 14344  6c41 f005                                beq l205_1                               ; yes...
 14345  6c43 ccea11                              cpy lfor                                 ; end?
 14346  6c46 9004                                bcc l205_2                               ; no...
 14347                          
 14348  6c48 a476               l205_1           ldy z_p_temp_1                           ; <>0?
 14349  6c4a d0d4                                bne retrn                                ; yes...
 14350                          
 14351  6c4c 209d22             l205_2           jsr indfrm
 14352  6c4f eee611                              inc cform                                ; pointer to field
 14353  6c52 60                                  rts
 14354                          
 14355                          
 14356                          ;  Using- ini: init counters and flags
 14357                          
 14358  6c53 206d5b             ini              jsr frefac                               ; free temp descriptor
 14359  6c56 8577                                sta hulp                                 ; length string
 14360  6c58 a20a                                ldx #$0a                                 ; printed in hulp
 14361  6c5a a900                                lda #0
 14362                          
 14363  6c5c 9ddc11             l206_1           sta swe,x                                ; init working registers
 14364  6c5f ca                                  dex
 14365  6c60 10fa                                bpl l206_1
 14366  6c62 8edb11                              stx flag                                 ; comma flag =ff
 14367  6c65 867f                                stx point                                ; point pointer=ff
 14368  6c67 8eda11                              stx dolr                                 ; dollar flag=ff
 14369  6c6a aa                                  tax                                      ; x=y=0
 14370  6c6b a8                                  tay
 14371  6c6c 60                                  rts
 14372                          
 14373                          
 14374                          ; Using- round number
 14375                          
 14376  6c6d 18                 uround           clc
 14377  6c6e a57f                                lda point
 14378  6c70 6de211                              adc nf                                   ; overflow?
 14379  6c73 b039                                bcs rrts                                 ; yes...
 14380  6c75 38                                  sec
 14381  6c76 e576                                sbc z_p_temp_1                           ; underflow?
 14382  6c78 9034                                bcc rrts                                 ; yes...
 14383  6c7a cdd911                              cmp enr                                  ; anything to round?
 14384  6c7d f002                                beq l207_1                               ; yes...
 14385  6c7f b02d                                bcs rrts                                 ; no...
 14386                          
 14387  6c81 cdd811             l207_1           cmp bnr                                  ; again...
 14388  6c84 9028                                bcc rrts                                 ; no...
 14389  6c86 aa                                  tax
 14390  6c87 bd0001                              lda fbuffr,x                             ; get digit
 14391  6c8a c935                                cmp #'5'                                 ; <5 ?
 14392  6c8c 9020                                bcc rrts                                 ; yes...no round
 14393                          
 14394  6c8e ecd811             l207_2           cpx bnr                                  ; begin of no reached?
 14395  6c91 f00a                                beq l207_3                               ; yes..add 1
 14396  6c93 ca                                  dex
 14397  6c94 20366c                              jsr tag3                                 ; increment digit
 14398  6c97 8ed911                              stx enr                                  ; new end of no pointer
 14399  6c9a f0f2                                beq l207_2                               ; branch on overflow
 14400  6c9c 60                                  rts
 14401                          
 14402  6c9d a931               l207_3           lda #'1'
 14403  6c9f 9d0001                              sta fbuffr,x
 14404  6ca2 e8                                  inx
 14405  6ca3 867f                                stx point
 14406  6ca5 c676                                dec z_p_temp_1                           ; # of 0's before '.'
 14407  6ca7 1005                                bpl rrts                                 ; no underflow
 14408  6ca9 e676                                inc z_p_temp_1                           ; underflow...back to 0
 14409  6cab eedf11                              inc vn
 14410  6cae 60                 rrts             rts
 14411                          
 14412                          
 14413                          ; Using- alg: delete leading zeros of no
 14414                          
 14415  6caf a47f               alg              ldy point                                ; start with a .?
 14416  6cb1 f017                                beq szer                                 ; yes...
 14417                          
 14418  6cb3 acd811             cho              ldy bnr
 14419  6cb6 b90001             cmo              lda fbuffr,y                             ; start with a 0?
 14420  6cb9 c930                                cmp #'0'
 14421  6cbb 60                                  rts
 14422                          
 14423                          
 14424  6cbc e67f               nbr              inc point                                ; adjust point
 14425  6cbe 20f16b                              jsr eado                                 ; and exponent
 14426  6cc1 eed811                              inc bnr                                  ; and pointer to begin of no
 14427  6cc4 ccd911                              cpy enr                                  ; end of number?
 14428  6cc7 f0e5                                beq rrts                                 ; yes...
 14429  6cc9 c8                                  iny
 14430                          
 14431  6cca 20b66c             szer             jsr cmo                                  ; zero in no?
 14432  6ccd f0ed                                beq nbr                                  ; yes...
 14433  6ccf 60                                  rts                                      ; no...
 14434                          
 14435                          
 14436                          ; Using- chout: print number
 14437                          
 14438  6cd0 adda11             chout            lda dolr                                 ; dollar flag set?
 14439  6cd3 3002                                bmi l208_1                               ; no...
 14440  6cd5 e676                                inc z_p_temp_1                           ; make room for $
 14441                          
 14442  6cd7 aed811             l208_1           ldx bnr                                  ; start of #
 14443  6cda ca                                  dex
 14444  6cdb ace911                              ldy begfd                                ; begin of field
 14445                          
 14446  6cde 209d22             afrm             jsr indfrm
 14447  6ce1 c8                                  iny
 14448  6ce2 c92c                                cmp #','                                 ; comma?
 14449  6ce4 d00f                                bne punt                                 ; no...
 14450  6ce6 2cdb11                              bit flag                                 ; comma flag on?
 14451  6ce9 3005                                bmi bout                                 ; yes, do a fill char
 14452                          ; sta sw_rom_ram0 ;????
 14453  6ceb add511                              lda pucoma
 14454  6cee 8064                                bra out                                  ; no,...output a comma char
 14455                          
 14456                          
 14457  6cf0 ade811             bout             lda blfd
 14458  6cf3 805f                                bra out
 14459                          
 14460                          
 14461  6cf5 c92e               punt             cmp #'.'                                 ; decimal point?
 14462  6cf7 d005                                bne afplus
 14463                          ; sta sw_rom_ram0 ;????
 14464  6cf9 add611                              lda pudot                                ; yes...
 14465  6cfc 8056                                bra out
 14466                          
 14467                          
 14468  6cfe c92b               afplus           cmp #'+'                                 ; plus?
 14469  6d00 f03a                                beq ispl                                 ; yes...
 14470  6d02 c92d                                cmp #'-'                                 ; minus?
 14471  6d04 f031                                beq ispl1                                ; yes...
 14472  6d06 c95e                                cmp #'^'                                 ; up arrow?
 14473  6d08 d070                                bne pndd                                 ; no...
 14474  6d0a a945                                lda #'E'
 14475  6d0c 209a6d                              jsr cdout
 14476  6d0f acde11                              ldy uexp
 14477  6d12 20b66c                              jsr cmo                                  ; first dig of exp zero?
 14478  6d15 d006                                bne l209_1                               ; no...
 14479  6d17 c8                                  iny
 14480  6d18 20b66c                              jsr cmo                                  ; second digit?
 14481  6d1b f007                                beq l209_2                               ; yes
 14482                          
 14483  6d1d a92d               l209_1           lda #'-'
 14484  6d1f 2cdd11                              bit usgn
 14485  6d22 3002                                bmi l209_3
 14486                          
 14487  6d24 a92b               l209_2           lda #'+'
 14488  6d26 209a6d             l209_3           jsr cdout                                ; output sign exp
 14489  6d29 aede11                              ldx uexp
 14490  6d2c bd0001                              lda fbuffr,x
 14491  6d2f 209a6d                              jsr cdout                                ; output first dig exp
 14492  6d32 aceb11                              ldy endfd
 14493  6d35 8013                                bra telx
 14494                          
 14495  6d37 ade711             ispl1            lda sno                                  ; positive?
 14496  6d3a 30b4                                bmi bout                                 ; yes...out blank or *
 14497  6d3c ade711             ispl             lda sno                                  ; output sgn
 14498  6d3f 8013                                bra out
 14499                          
 14500                          
 14501  6d41 a576               zerot            lda z_p_temp_1                           ; # of zeros
 14502  6d43 d017                                bne zerot1
 14503  6d45 ecd911                              cpx enr                                  ; end of # reached?
 14504  6d48 f005                                beq zout                                 ; yes...output zero
 14505                          
 14506  6d4a e8                 telx             inx
 14507  6d4b bd0001                              lda fbuffr,x                             ; get digit
 14508  6d4e 2c                                  !text $2c                                ; skip
 14509                          
 14510  6d4f a930               zout             lda #'0'                                 ; output zero
 14511                          
 14512  6d51 4edb11             outs             lsr flag                                 ; clear comma flag
 14513                          
 14514  6d54 209a6d             out              jsr cdout                                ; output character
 14515  6d57 f355ff                              +lbeq rrts
 14516  6d5a 8082                                bra afrm                                 ; not ready...
 14517                          
 14518                          
 14519  6d5c c676               zerot1           dec z_p_temp_1                           ; count leading zeros
 14520  6d5e adda11                              lda dolr                                 ; $ flag set?
 14521  6d61 30ec                                bmi zout                                 ; no...output zero
 14522                          
 14523  6d63 209d22                              jsr indfrm                               ; take a peek at the next character in the format string
 14524  6d66 c92c                                cmp #','                                 ; if it's a comma, we got problems
 14525  6d68 d007                                bne l210_1                               ; ...branch if no comma & resume normal processing
 14526                          
 14527  6d6a ade811                              lda blfd                                 ; here's the "$,999.99" bug fix:
 14528  6d6d 209a6d                              jsr cdout                                ; print a 'fill' character instead of the '$'
 14529  6d70 c8                                  iny                                      ; and increment format string pointer past comma
 14530                          
 14531  6d71 38                 l210_1           sec                                      ; resume normal processing
 14532  6d72 6eda11                              ror dolr                                 ; clear the dollar flag & go on to print '$'
 14533                          ; sta sw_rom_ram0 ;????
 14534  6d75 add711                              lda pumony
 14535  6d78 80d7                                bra outs                                 ; output money symbol
 14536                          
 14537                          
 14538  6d7a addc11             pndd             lda swe                                  ; # of blanks
 14539  6d7d f0c2                                beq zerot
 14540  6d7f cedc11                              dec swe                                  ; count !
 14541                          
 14542  6d82 d36cff             l211_1           +lbne bout                               ; out blank or *
 14543  6d85 ade311                              lda posp                                 ; + or - in field?
 14544  6d88 30f8                                bmi l211_1                               ; yes...out blank or *
 14545                          
 14546  6d8a 209d22             l211_2           jsr indfrm
 14547  6d8d c92c                                cmp #','                                 ; comma?
 14548  6d8f d0a6                                bne ispl1                                ; no...out sign
 14549  6d91 ade811                              lda blfd                                 ; yes...
 14550  6d94 209a6d                              jsr cdout                                ; out blank or *
 14551  6d97 c8                                  iny
 14552  6d98 80f0                                bra l211_2
 14553                          
 14554                          
 14555                          
 14556  6d9a 203d68             cdout            jsr outch ;outdo                         ; char out
 14557  6d9d cee611                              dec cform                                ; count it
 14558  6da0 60                                  rts
 14559                          
 14560                          
 14561                          ; Using- anaf: analyze format
 14562                          
 14563  6da1 aceb11             anaf             ldy endfd                                ; format pointer
 14564  6da4 203f6c             gfor             jsr ansub
 14565  6da7 20536e                              jsr comp                                 ; check special chars
 14566  6daa d014                                bne pchar                                ; no match...
 14567  6dac 8ce911                              sty begfd                                ; save beginning of field
 14568  6daf 9019                                bcc ffoun                                ; # was found
 14569  6db1 aa                                  tax                                      ; save char
 14570                          
 14571  6db2 203f6c             sfur             jsr ansub                                ; get next format char
 14572  6db5 b005                                bcs l212_1                               ; stop on wrap-around
 14573  6db7 205b6e                              jsr com1                                 ; compare specials
 14574  6dba f009                                beq foun1                                ; found some...
 14575                          
 14576  6dbc ace911             l212_1           ldy begfd
 14577  6dbf 8a                                  txa
 14578  6dc0 203d68             pchar            jsr outch ;outdo                         ; out character
 14579  6dc3 80df                                bra gfor
 14580                          
 14581                          
 14582  6dc5 b0eb               foun1            bcs sfur                                 ; no #...keep looking
 14583  6dc7 ace911                              ldy begfd
 14584  6dca a676               ffoun            ldx z_p_temp_1
 14585  6dcc d078                                bne trts
 14586  6dce 8ee611                              stx cform
 14587  6dd1 88                                  dey
 14588                          
 14589  6dd2 cee611             hyo2             dec cform                                ; correct counter
 14590  6dd5 203f6c             hyo              jsr ansub                                ; get next format char
 14591  6dd8 b072                                bcs efo                                  ; end of format
 14592  6dda c92c                                cmp #','                                 ; comma?
 14593  6ddc f0f7                                beq hyo                                  ; yes...ignore it
 14594  6dde 202a6e                              jsr isp                                  ; + or - in format?
 14595  6de1 90ef                                bcc hyo2                                 ; yes...
 14596  6de3 c92e                                cmp #'.'                                 ; decimal point?
 14597  6de5 d008                                bne avf1                                 ; no...
 14598  6de7 e8                                  inx
 14599  6de8 e002                                cpx #2                                   ; more than 1 decimal?
 14600  6dea 90e9                                bcc hyo                                  ; no...
 14601  6dec 835cc0             ero              +lbra snerr                              ; yes...syntax error
 14602                          
 14603                          
 14604  6def 205f6e             avf1             jsr com2                                 ; =, >, or # in field
 14605  6df2 d00a                                bne llar                                 ; no...
 14606  6df4 9003                                bcc hyo1                                 ; was #
 14607  6df6 8de011                              sta chsn                                 ; was > or =
 14608                          
 14609  6df9 fee111             hyo1             inc vf,x
 14610  6dfc 80d7                                bra hyo
 14611                          
 14612  6dfe c924               llar             cmp #'$'                                 ; dollar?
 14613  6e00 d00e                                bne expo                                 ; no...
 14614  6e02 2cda11                              bit dolr                                 ; test flag
 14615  6e05 10f2                                bpl hyo1                                 ; no...
 14616  6e07 18                                  clc
 14617  6e08 6eda11                              ror dolr                                 ; set flag
 14618  6e0b cee111                              dec vf
 14619  6e0e 80e9                                bra hyo1
 14620                          
 14621  6e10 c95e               expo             cmp #'^'                                 ; up arrow?
 14622  6e12 d016                                bne isp                                  ; no...
 14623  6e14 a202                                ldx #$02
 14624  6e16 203f6c             l213_1           jsr ansub                                ; must be 4 up arrows
 14625  6e19 b0d1                                bcs ero
 14626  6e1b c95e                                cmp #'^'                                 ; up arrow?
 14627  6e1d d0cd                                bne ero
 14628  6e1f ca                                  dex
 14629  6e20 10f4                                bpl l213_1
 14630  6e22 eee411                              inc fesp                                 ; set exp flag
 14631  6e25 203f6c                              jsr ansub                                ; next format char
 14632  6e28 b022                                bcs efo                                  ; end of format
 14633                          
 14634  6e2a c92b               isp              cmp #'+'                                 ; plus?
 14635  6e2c d019                                bne chom                                 ; no...
 14636  6e2e ade711                              lda sno                                  ; sign neg?
 14637  6e31 1005                                bpl spos                                 ; yes...
 14638  6e33 a92b                                lda #'+'
 14639  6e35 8de711                              sta sno
 14640                          
 14641  6e38 ade311             spos             lda posp                                 ; + or - already?
 14642  6e3b d0af                                bne ero
 14643  6e3d 6ee311                              ror posp                                 ; make posp neg/clc
 14644  6e40 8ceb11                              sty endfd                                ; end field pointer
 14645  6e43 eee611                              inc cform                                ; correct counter
 14646  6e46 60                 trts             rts
 14647                          
 14648                          
 14649  6e47 c92d               chom             cmp #'-'                                 ; minus?
 14650  6e49 f0ed                                beq spos                                 ; yes...
 14651  6e4b 38                                  sec
 14652  6e4c 8ceb11             efo              sty endfd                                ; end field pointer
 14653  6e4f ceeb11                              dec endfd
 14654  6e52 60                                  rts
 14655                          
 14656                          
 14657                          ; Using- comp: compare .a with symbols
 14658                          
 14659  6e53 c92b               comp             cmp #'+'
 14660  6e55 f015                                beq rt
 14661  6e57 c92d                                cmp #'-'
 14662  6e59 f011                                beq rt
 14663                          
 14664  6e5b c92e               com1             cmp #'.'
 14665  6e5d f00d                                beq rt
 14666                          
 14667  6e5f c93d               com2             cmp #'='
 14668  6e61 f009                                beq rt
 14669  6e63 c93e                                cmp #'>'
 14670  6e65 f005                                beq rt
 14671  6e67 c923                                cmp #'#'
 14672  6e69 d001                                bne rt
 14673  6e6b 18                                  clc
 14674  6e6c 60                 rt               rts
 14675                          
 14676                          ;.end
 14677                          
 14678                          
 14679                          ;[[function.instr]]
 14680                          
 14681                          ;  INSTRing - Find position of str1 in str2 at or after position n
 14682                          ;
 14683                          ; Usage: INSTR(a$,b${,n})
 14684                          
 14685  6e6d a566               instr            lda facmo                                ; save pointer to temporary descriptors
 14686  6e6f 8dd302                              sta tmpdes
 14687  6e72 a567                                lda facmo+1
 14688  6e74 8dd402                              sta tmpdes+1
 14689                          
 14690  6e77 20ef4c                              jsr frmevl                               ; get next arg
 14691  6e7a 20dd4c                              jsr chkstr                               ; must be string
 14692  6e7d a566                                lda facmo
 14693  6e7f 8dd502                              sta tmpdes+2
 14694  6e82 a567                                lda facmo+1
 14695  6e84 8dd602                              sta tmpdes+3
 14696                          
 14697  6e87 a201                                ldx #1                                   ; default starting position
 14698  6e89 8667                                stx faclo
 14699  6e8b 208522                              jsr chrgot
 14700  6e8e c929                                cmp #')'                                 ; any length argument?
 14701  6e90 f003                                beq l214_1                               ; branch if not
 14702  6e92 20825d                              jsr combyt                               ; else go get a one byte argument
 14703                          
 14704  6e95 20554e             l214_1           jsr chkcls                               ; look for )
 14705  6e98 a667                                ldx faclo
 14706  6e9a f362e3                              +lbeq fcerr                              ; starting position can't be 0
 14707  6e9d ca                                  dex
 14708  6e9e 8663                                stx positn
 14709                          
 14710  6ea0 a203                                ldx #3                                   ; copy 'pointers to temp descriptors' to zero page
 14711  6ea2 bdd302             l214_2           lda tmpdes,x
 14712  6ea5 9559                                sta ptarg1,x
 14713  6ea7 ca                                  dex
 14714  6ea8 10f8                                bpl l214_2
 14715                          
 14716  6eaa a002                                ldy #2                                   ; now get the descriptors
 14717  6eac a959               l214_3           lda #ptarg1
 14718  6eae 20d722                              jsr lda_far_ram1                         ; lda (ptarg1),y
 14719  6eb1 995d00                              sta str1,y
 14720  6eb4 a95b                                lda #ptarg2
 14721  6eb6 20d722                              jsr lda_far_ram1                         ; lda (ptarg2),y
 14722  6eb9 996000                              sta str2,y
 14723  6ebc 88                                  dey
 14724  6ebd 10ed                                bpl l214_3
 14725                          
 14726  6ebf a560                                lda str2                                 ; check if string 2 is null
 14727  6ec1 f03b                                beq l214_8                               ; if so, return 0
 14728                          
 14729  6ec3 a900               l214_4           lda #0
 14730  6ec5 8564                                sta match
 14731  6ec7 18                                  clc
 14732  6ec8 a560                                lda str2                                 ; length of string 2
 14733  6eca 6563                                adc positn
 14734  6ecc b030                                bcs l214_8                               ; too long, not found
 14735  6ece c55d                                cmp str1                                 ; see if > length of string 1
 14736  6ed0 9002                                bcc l214_5                               ; < len string 1
 14737  6ed2 d02a                                bne l214_8                               ; must be >, not found
 14738                          
 14739  6ed4 a464               l214_5           ldy match
 14740  6ed6 c460                                cpy str2                                 ; if match len = str len, then found
 14741  6ed8 f01f                                beq l214_7
 14742  6eda 98                                  tya
 14743  6edb 18                                  clc
 14744  6edc 6563                                adc positn                               ; compare str1(s+p+m) with str2(m)
 14745  6ede a8                                  tay
 14746  6edf a95e                                lda #str1+1
 14747  6ee1 20d722                              jsr lda_far_ram1                         ; lda (str1+1),y
 14748  6ee4 8578                                sta syntmp
 14749  6ee6 a464                                ldy match
 14750  6ee8 a961                                lda #str2+1
 14751  6eea 20d722                              jsr lda_far_ram1                         ; lda (str2+1),y
 14752  6eed c578                                cmp syntmp
 14753  6eef f004                                beq l214_6
 14754  6ef1 e663                                inc positn                               ; not the same, start over from next positn
 14755  6ef3 80ce                                bra l214_4                               ; always
 14756                          
 14757  6ef5 e664               l214_6           inc match                                ; count characters that match
 14758  6ef7 80db                                bra l214_5                               ; always
 14759                          
 14760                          
 14761  6ef9 e663               l214_7           inc positn                               ; found
 14762  6efb a563                                lda positn
 14763  6efd 2c                                  !text $2c
 14764                          
 14765  6efe a900               l214_8           lda #0                                   ; not found
 14766                          ; sta sw_rom_ram0 ;????
 14767  6f00 48                                  pha
 14768  6f01 add502                              lda tmpdes+2                             ; free temp descriptors
 14769  6f04 acd602                              ldy tmpdes+3
 14770  6f07 20715b                              jsr fretmp
 14771                          ; sta sw_rom_ram0 ;????
 14772  6f0a add302                              lda tmpdes
 14773  6f0d acd402                              ldy tmpdes+1
 14774  6f10 20715b                              jsr fretmp
 14775  6f13 7a                                  ply
 14776  6f14 83bce9                              +lbra sngflt                             ; float 1 byte in .y
 14777                          
 14778                          ;.end
 14779                          
 14780                          
 14781                          
 14782                          ;[[function.type]]
 14783                          
 14784                          ; TYPE  types a given disk (SEQ) file to output channel
 14785                          ;
 14786                          
 14787  6f17 a300               type             ldz #0
 14788                          
 14789                          open_SEQ_file
 14790  6f19 db                                  phz                                      ; save EDIT load flag    [910620]
 14791  6f1a a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
 14792  6f1c 202074                              jsr dosprs                               ; (like dopen:      0 0 0 *  * 0 0 1 )
 14793  6f1f 20dc77                              jsr chk1                                 ; check parameters
 14794  6f22 201d71                              jsr find_la                              ; find an available LA
 14795  6f25 200d71                              jsr find_sa                              ; find an available SA
 14796  6f28 a011                                ldy #fopnseq
 14797  6f2a a206                                ldx #6
 14798  6f2c 20fd70                              jsr open_file                            ; open the file
 14799  6f2f b3f6c3                              +lbcs list_err                           ; exit if error
 14800  6f32 fb                                  plz                                      ; [910620]
 14801  6f33 f001                                beq l215_1
 14802  6f35 60                                  rts                                      ; or exit if called by EDIT load routine
 14803                          
 14804  6f36 20e1ff             l215_1           jsr _stop                                ; check stop key
 14805  6f39 f03c                                beq l215_6                               ; exit if down
 14806  6f3b ae8111                              ldx dosla
 14807  6f3e 20c6ff                              jsr _chkin                               ; get input channel
 14808  6f41 b034                                bcs l215_6                               ; exit if bad??
 14809  6f43 a200                                ldx #0
 14810  6f45 e0ff               l215_2           cpx #255                                 ; check buffer (buflen????)
 14811                          ; bcs 99$   ; 'too long' error
 14812  6f47 f011                                beq l215_3                               ; allow long lines   [910620]
 14813  6f49 20cfff                              jsr _basin                               ; read file data
 14814  6f4c 9d0013                              sta dosstr,x                             ; buffer it
 14815  6f4f e8                                  inx                                      ; bump buffer pointer
 14816  6f50 a8                                  tay                                      ; save char
 14817  6f51 20b7ff                              jsr _readst                              ; check channel status
 14818  6f54 d004                                bne l215_3                               ; exit if eof or error
 14819  6f56 c00d                                cpy #cr
 14820  6f58 d0eb                                bne l215_2                               ; loop until eol
 14821                          
 14822  6f5a 08                 l215_3           php                                      ; save input channel status (beq=eol, bne=eof/err)
 14823  6f5b 8e7b11                              stx t4                                   ; save character count
 14824  6f5e 20c770                              jsr dcato                                ; get output channel
 14825  6f61 a200                                ldx #0
 14826  6f63 ec7b11             l215_4           cpx t4                                   ; check buffer
 14827  6f66 b009                                bcs l215_5                               ; end of buffered data
 14828  6f68 bd0013                              lda dosstr,x                             ; output data
 14829  6f6b 20d2ff                              jsr _bsout
 14830  6f6e e8                                  inx                                      ; bump buffer pointer
 14831  6f6f d0f2                                bne l215_4                               ; loop until end of buffer
 14832                          
 14833  6f71 20ccff             l215_5           jsr _clrch
 14834  6f74 28                                  plp                                      ; check input status
 14835  6f75 f0bf                                beq l215_1                               ; loop until eof or bad status
 14836                          
 14837  6f77 83a7c3             l215_6           +lbra list_exit                          ; release channel, close file, return to main
 14838                          
 14839                          ;99$ jsr _clrch  ;non-I/O trouble   removed [910620]
 14840                          ; lda dosla  ; shut down disk & report BASIC error
 14841                          ; clc
 14842                          ; jsr _close
 14843                          ; bra errlen  ;buffer overflow: report 'string too long'
 14844                          
 14845                          ;[[command.disk]]
 14846                          
 14847                          
 14848                          
 14849                          ; DISK "command_string" [,U#] [,D#]     new [910123]
 14850                          
 14851                          disk
 14852  6f7a a9f6                                lda #$f6                                 ; parse:  command_string [,U#]
 14853  6f7c 202074                              jsr dosprs
 14854  6f7f 20dc77                              jsr chk1                                 ; check parameters
 14855  6f82 a900                                lda #doslfn                              ; la (reserved la)
 14856  6f84 8d8111                              sta dosla
 14857  6f87 a96f                                lda #$6f
 14858  6f89 8d8311                              sta dossa                                ; sa (command channel)
 14859  6f8c a053                                ldy #fdisk
 14860  6f8e a202                                ldx #2                                   ; add "/" [911108]
 14861  6f90 20fd70                              jsr open_file                            ; open command channel & send command string
 14862  6f93 08                                  php                                      ; save error status    [910404]
 14863  6f94 48                                  pha
 14864  6f95 a900                                lda #doslfn                              ; close it
 14865  6f97 38                                  sec                                      ; not a real close
 14866  6f98 20c3ff                              jsr _close                               ; close it
 14867  6f9b 68                                  pla                                      ; [910404]
 14868  6f9c 28                                  plp
 14869  6f9d 83cff8                              +lbra exit_disk_op                       ; common error check & exit path ????
 14870                          
 14871                          
 14872                          ;.end
 14873                          ;[[dos.setup]]
 14874                          
 14875                          
 14876                          
 14877                          ; These routines take tokens and values after the following BASIC keywords:
 14878                          ;
 14879                          ;  DOPEN,   DCLOSE,  APPEND,  CONCAT, RECORD
 14880                          ;  DLOAD,   DSAVE,   DVERIFY, BLOAD,  BSAVE
 14881                          ;  FORMAT,  COLLECT, BACKUP,  COPY
 14882                          ;  CATALOG, RENAME,  SCRATCH, DCLEAR
 14883                          ;
 14884                          ; It then parses the following line and finds syntax errors, checks for values
 14885                          ; out of range, and sets variables in the zero-page to be passed to the disk
 14886                          ; message generator.
 14887                          
 14888                          
 14889                          directory                                                 ; display disk directory (catalog)
 14890  6fa0 208522                              jsr chrgot                               ; get current chr
 14891  6fa3 c9fe                                cmp #esc_command_token                   ; eat dirECTORY kludge if it's there
 14892  6fa5 d00b                                bne l216_1
 14893  6fa7 208322                              jsr chrget                               ; (esc token + another)
 14894  6faa c929                                cmp #ectory_token
 14895  6fac d39cbe                              +lbne snerr
 14896  6faf 208322                              jsr chrget                               ; yes- get next good char
 14897                          
 14898  6fb2 201e74             l216_1           jsr dospar                               ; parse the line
 14899  6fb5 a57f                                lda parsts                               ; check options
 14900  6fb7 29e6                                and #$e6
 14901  6fb9 d38fbe                              +lbne snerr
 14902                          
 14903  6fbc a001                                ldy #fdir                                ; table offset for directory
 14904  6fbe 2c8f11                              bit dosflags                             ; want recoverable files? [901024]
 14905  6fc1 5002                                bvc l216_2                               ; no
 14906  6fc3 a005                                ldy #fdirr                               ; yes
 14907  6fc5 a201               l216_2           ldx #1                                   ; just $
 14908  6fc7 a57f                                lda parsts                               ; check for default
 14909  6fc9 2911                                and #$11                                 ; no drive?
 14910  6fcb f006                                beq l216_4
 14911  6fcd 4a                                  lsr
 14912  6fce 9002                                bcc l216_3                               ; just drive
 14913  6fd0 e8                                  inx                                      ; drive and filename
 14914  6fd1 e8                                  inx
 14915  6fd2 e8                 l216_3           inx
 14916  6fd3 8a                 l216_4           txa                                      ; a now has length
 14917  6fd4 20f276                              jsr sendp                                ; build
 14918                          
 14919  6fd7 a200                                ldx #sys_bank                            ; set banks????  fname in system space, bank0 [910620]
 14920  6fd9 8a                                  txa                                      ; (load bank is don't care- we're not actually loading)
 14921  6fda 206bff                              jsr _setbank
 14922                          
 14923  6fdd a060                                ldy #$60                                 ; sa, load floppy
 14924  6fdf ae8211                              ldx dosfa
 14925  6fe2 a900                                lda #doslfn                              ; lfn
 14926  6fe4 20baff                              jsr _setlfs                              ; set file parameters
 14927  6fe7 20c0ff                              jsr _open                                ; open it...
 14928  6fea 9009                                bcc l216_5                               ; ...ok
 14929  6fec 48                                  pha
 14930  6fed 204f70                              jsr dcat11                               ; ...error, shut down and report
 14931  6ff0 fa                                  plx
 14932  6ff1 38                                  sec
 14933  6ff2 835bbe                              +lbra error
 14934                          
 14935  6ff5 a515               l216_5           lda channl                               ; determine DIR vs LDIR
 14936  6ff7 d05e                                bne ldir                                 ; if output channel not default (screen)
 14937                          ; use LDIR
 14938                          
 14939                          ; Get length in blocks
 14940                          
 14941  6ff9 a200               dir              ldx #doslfn
 14942  6ffb 20c6ff                              jsr _chkin
 14943  6ffe b04f                                bcs dcat11                               ; if problem??
 14944  7000 20b7ff                              jsr _readst                              ; check status
 14945  7003 d04a                                bne dcat11                               ; exit if bad status
 14946  7005 20f737                              jsr crdo                                 ; output new line
 14947  7008 a003                                ldy #3                                   ; loop counter
 14948                          
 14949  700a 8c7911             dcat3            sty t3                                   ; save counter
 14950                          
 14951  700d 20cfff             l217_1           jsr _basin                               ; get char
 14952  7010 8d7b11                              sta t4
 14953  7013 20cfff                              jsr _basin                               ; get char
 14954  7016 8d7c11                              sta t4+1
 14955  7019 20b7ff                              jsr _readst                              ; check status
 14956  701c d031                                bne dcat11                               ; exit if eof or bad status
 14957  701e ce7911                              dec t3
 14958  7021 d0ea                                bne l217_1                               ; if not done
 14959                          
 14960                          ; Output blocks number
 14961                          
 14962  7023 ae7b11                              ldx t4
 14963  7026 ad7c11                              lda t4+1
 14964  7029 207f64                              jsr linprt                               ; output number
 14965  702c a920                                lda #' '
 14966  702e 20d2ff                              jsr _bsout                               ; output a space
 14967                          
 14968                          ; Get name & output it
 14969                          
 14970  7031 20b7ff             dcat4            jsr _readst                              ; get status
 14971  7034 d016                                bne dcat10                               ; if bad status
 14972  7036 20cfff                              jsr _basin                               ; get char
 14973  7039 f005                                beq dcat5                                ; if eol
 14974  703b 20d2ff                              jsr _bsout                               ; echo char
 14975  703e 80f1                                bra dcat4                                ; continue to process name until eol or err
 14976                          
 14977                          ; Here on end of name
 14978                          
 14979  7040 20f737             dcat5            jsr crdo                                 ; output new line
 14980  7043 20e1ff                              jsr _stop                                ; check stop key
 14981  7046 f007                                beq dcat11                               ; exit if stop request
 14982                          
 14983                          ; Process next
 14984                          
 14985  7048 a002                                ldy #2                                   ; perform 2 times
 14986  704a 80be                                bra dcat3
 14987                          
 14988                          
 14989                          ; Exit directory
 14990                          
 14991  704c 20f737             dcat10           jsr crdo                                 ; flush current line
 14992  704f 20b438             dcat11           jsr release_channels                     ; release cmd channel, restore terminal
 14993  7052 a900                                lda #doslfn
 14994  7054 83b8f8                              +lbra close_out                          ; [900725]
 14995                          
 14996                          ;[[command.ldir]]
 14997                          
 14998                          ; LDIR  same as DIR, except it buffers each line to reduce
 14999                          ;       talker/listener turnaround time.  Even so, it is still
 15000                          ; unacceptably slow for normal screen output, which is
 15001                          ; why it was split out from the original DIRECTORY routine.
 15002                          ;
 15003                          
 15004                          ; Read block count
 15005                          
 15006                          ldir
 15007  7057 a9c0                                lda #$c0                                 ; serial bus kludge for open4,4:cmd4:dir ????
 15008  7059 2d09d6                              and $d609
 15009  705c 1c09d6                              trb $d609                                ; disable fast serial bus
 15010  705f 8586                                sta sid_speed_flag                       ; but save enables so we can restore them
 15011                          
 15012  7061 a003                                ldy #3                                   ; loop counter (3=skip fake load adr & link bytes)
 15013  7063 8c7911             l218_1           sty t3                                   ; save counter
 15014  7066 a200                                ldx #doslfn
 15015  7068 20c6ff                              jsr _chkin
 15016  706b b053                                bcs ldir_end                             ; problem??
 15017                          
 15018  706d 20b7ff             l218_2           jsr _readst                              ; check status
 15019  7070 d04e                                bne ldir_end                             ; exit if bad status
 15020  7072 20cfff                              jsr _basin                               ; get block count
 15021  7075 8d0013                              sta dosstr                               ; buffer it
 15022  7078 20cfff                              jsr _basin
 15023  707b 8d0113                              sta dosstr+1
 15024  707e ce7911                              dec t3
 15025  7081 d0ea                                bne l218_2                               ; continue eating bytes until we have block count
 15026                          
 15027                          ; Read filename
 15028                          
 15029  7083 a201                                ldx #1                                   ; buffer index-1
 15030  7085 e8                 l218_3           inx
 15031  7086 20b7ff                              jsr _readst                              ; check status
 15032  7089 d035                                bne ldir_end                             ; exit if eof or bad status
 15033  708b 20cfff                              jsr _basin                               ; buffer next character
 15034  708e 9d0013                              sta dosstr,x
 15035  7091 d0f2                                bne l218_3                               ; loop until eol (null terminator)
 15036                          
 15037                          ; Print one line of directory
 15038                          
 15039  7093 20c770                              jsr dcato                                ; get output channel
 15040  7096 ae0013                              ldx dosstr
 15041  7099 ad0113                              lda dosstr+1
 15042  709c 207f64                              jsr linprt                               ; print blocks
 15043                          
 15044  709f a920                                lda #' '
 15045  70a1 20d2ff                              jsr _bsout                               ; print space
 15046                          
 15047  70a4 a202                                ldx #2
 15048  70a6 bd0013             l218_4           lda dosstr,x
 15049  70a9 f006                                beq l218_5
 15050  70ab 20d2ff                              jsr _bsout                               ; print filename (null terminated)
 15051  70ae e8                                  inx
 15052  70af d0f5                                bne l218_4
 15053                          
 15054  70b1 20f737             l218_5           jsr crdo                                 ; print return
 15055  70b4 20ccff                              jsr _clrch
 15056  70b7 20e1ff                              jsr _stop                                ; check stop key
 15057  70ba f004                                beq ldir_end                             ; exit if stop request
 15058                          
 15059                          ; Continue with next line
 15060                          
 15061  70bc a002                                ldy #2                                   ; set to skip fake link bytes
 15062  70be 80a3                                bra l218_1                               ; loop
 15063                          
 15064                          
 15065                          ldir_end
 15066  70c0 a586                                lda sid_speed_flag                       ; serial bus kludge for open4,4:cmd4:dir ????
 15067  70c2 0c09d6                              tsb $d609                                ; restore fast serial bus enables
 15068  70c5 8088                                bra dcat11
 15069                          
 15070                          
 15071                          
 15072  70c7 20ccff             dcato            jsr _clrch
 15073  70ca a615                                ldx channl                               ; restore output channel
 15074  70cc f003                                beq l219_1                               ; branch if screen (default output)
 15075  70ce 4cc9ff                              jmp _chkout                              ; else get output channel
 15076                          
 15077  70d1 60                 l219_1           rts
 15078                          
 15079                          
 15080                          ;[[function.dopen]]
 15081                          ; DOPEN dfn(,t(,r))
 15082                          
 15083  70d2 a922               dopen            lda #$22                                 ; set error flag
 15084  70d4 202074                              jsr dosprs                               ; parse the line
 15085  70d7 200478                              jsr chk6                                 ; check required parameters
 15086  70da 200d71                              jsr find_sa                              ; find unused secondary address
 15087  70dd a009                                ldy #fopn                                ; fcb format pointer
 15088  70df a204                                ldx #4                                   ; normal length
 15089  70e1 6f7f13                              bbr6 parsts,open_it                      ; relative record? branch if not relative
 15090  70e4 a208                                ldx #8                                   ; random access length
 15091  70e6 800f                                bra open_it                              ; [910925]
 15092                          
 15093                          ;l220_1 jsr open_file  ;open it
 15094                          ; bra exit_disk_op ;report any DOS errors, & return to main [910404]
 15095                          
 15096                          
 15097                          
 15098                          ; APPEND
 15099                          
 15100  70e8 a9e2               append           lda #$e2                                 ; set error flags
 15101  70ea 202074                              jsr dosprs                               ; parse the line
 15102  70ed 200478                              jsr chk6                                 ; check required parameters
 15103  70f0 200d71                              jsr find_sa                              ; find secondary address
 15104  70f3 a028                                ldy #fapn                                ; tabld index
 15105  70f5 a205                                ldx #5                                   ; length
 15106                          open_it
 15107  70f7 20fd70                              jsr open_file                            ; open it
 15108  70fa 8372f7                              +lbra exit_disk_op                       ; report any DOS errors, & return to main [910404]
 15109                          
 15110                          
 15111                          
 15112                          open_file                                                 ; dop2.
 15113  70fd 8a                                  txa                                      ; set length into a
 15114  70fe 20f276                              jsr sendp
 15115  7101 20ccff                              jsr _clrch
 15116  7104 a200                                ldx #sys_bank                            ; fname is in system space, bank0  [910620]
 15117  7106 8a                                  txa                                      ; (load bank not req'd)????
 15118  7107 206bff                              jsr _setbank
 15119  710a 4cc0ff                              jmp _open
 15120                          
 15121                          
 15122                          ; Find an available secondary address
 15123                          
 15124                          find_sa
 15125  710d a061                                ldy #$61                                 ; 2-14 possible
 15126                          
 15127  710f c8                 l220_1           iny
 15128  7110 c06f                                cpy #$6f
 15129  7112 f017                                beq too_many_files                       ; if none available error
 15130  7114 2062ff                              jsr _lkupsa                              ; kernel will lookup this sa in its tables
 15131  7117 90f6                                bcc l220_1                               ; if used keep looking
 15132  7119 8c8311                              sty dossa                                ; save secondary address
 15133  711c 60                                  rts                                      ; return .y = sa
 15134                          
 15135                          
 15136                          
 15137                          ; Find an available logical address
 15138                          
 15139                          find_la
 15140  711d a900                                lda #0                                   ; 1-127 possible
 15141                          
 15142  711f 1a                 l221_1           inc
 15143  7120 3009                                bmi too_many_files                       ; if none available error
 15144  7122 205fff                              jsr _lkupla                              ; kernel will lookup this la in its tables
 15145  7125 90f8                                bcc l221_1                               ; if used keep looking
 15146  7127 8d8111                              sta dosla                                ; save logical address
 15147  712a 60                                  rts                                      ; return .a = la
 15148                          
 15149                          
 15150                          
 15151                          
 15152                          too_many_files
 15153  712b a201                                ldx #errtmf                              ; too many files open
 15154  712d 8320bd                              +lbra error
 15155                          
 15156                          
 15157                          ; Close disk file
 15158                          
 15159  7130 a9f3               dclose           lda #$f3                                 ; set error flags
 15160  7132 202074                              jsr dosprs                               ; parse the line
 15161  7135 208278                              jsr Clear_DS
 15162  7138 2f7f06                              bbr2 parsts,dclall                       ; any la given?  branch if not
 15163  713b ad8111                              lda dosla
 15164  713e 83cef7                              +lbra close_out
 15165                          
 15166  7141 ad8211             dclall           lda dosfa                                ; get disk #
 15167                          ; jsr put_io_in_map
 15168  7144 4c50ff                              jmp _close_all                           ; close all channels
 15169                          
 15170                          
 15171                          
 15172                          ; DSAVE dfn
 15173                          
 15174  7147 4f7e03             dsave            bbr4 runmod,l222_1                       ; PROGRAM or EDIT mode?    [910620]
 15175  714a 83ab4c                              +lbra edit_save                          ; edit
 15176                          
 15177  714d a966               l222_1           lda #$66                                 ; set error flags
 15178  714f 202074                              jsr dosprs                               ; parse the line
 15179  7152 20e177                              jsr chk2                                 ; check required parameters
 15180  7155 a009                                ldy #fopn                                ; table offset
 15181  7157 a904                                lda #4                                   ; ..length,
 15182  7159 20f276                              jsr sendp
 15183                          
 15184  715c a584                                lda text_bank                            ; default to text bank set up banks???? [910620]
 15185  715e a200                                ldx #sys_bank                            ; fname is in system space, bank0
 15186  7160 206bff                              jsr _setbank
 15187  7163 8300f7                              +lbra savenp
 15188                          
 15189                          
 15190                          ; DVERIFY
 15191                          
 15192  7166 a901               dverify          lda #1                                   ; flag 'verify'
 15193  7168 2c                                  !text $2c
 15194                          
 15195                          
 15196                          
 15197                          ; DLOAD dfn
 15198                          
 15199  7169 a900               dload            lda #0
 15200  716b 850c                                sta verck                                ; set load flag (for verify check later)
 15201                          
 15202  716d 4f7e03                              bbr4 runmod,l223_1                       ; PROGRAM or EDIT mode?    [910620]
 15203  7170 839b4b                              +lbra edit_load                          ; edit
 15204                          
 15205  7173 a9e6               l223_1           lda #$e6                                 ; set error flags
 15206  7175 202074                              jsr dosprs                               ; parse the line
 15207  7178 20e177                              jsr chk2                                 ; check required parameters
 15208                          
 15209                          
 15210                          dload_boot                                                ; <<<<<<<<<<<<<<<<<< entry for BOOT'AUTOBOOT.C65'
 15211  717b a900                                lda #0
 15212  717d 8d8311                              sta dossa                                ; set relocate flag
 15213  7180 a009                                ldy #fopn                                ; table offset
 15214  7182 a904                                lda #4                                   ; ..length
 15215  7184 20f276                              jsr sendp
 15216                          
 15217  7187 a584                                lda text_bank                            ; set up banks ???? want text_bank ????  [910620]
 15218  7189 a200                                ldx #sys_bank                            ; fname is in system space, bank0
 15219  718b 206bff                              jsr _setbank
 15220                          
 15221  718e 8307f7                              +lbra cld10                              ; finish load, using 'LOAD' code.
 15222                          
 15223                          
 15224                          ; BSAVE
 15225                          
 15226  7191 a966               bsave            lda #$66                                 ; std error flag
 15227  7193 a2f8                                ldx #$f8                                 ; auxiliary error flag (allow bank, start & end address)
 15228  7195 202274                              jsr dosprx                               ; parse options
 15229  7198 20e177                              jsr chk2                                 ; check required parameters
 15230                          
 15231  719b a580                                lda parstx                               ; check for starting & ending addresses
 15232  719d 2906                                and #6
 15233  719f c906                                cmp #6
 15234  71a1 d3a7bc                              +lbne snerr                              ; ..if not present, syntax error
 15235                          
 15236  71a4 ad8011                              lda dosofh+1                             ; check that ea>sa
 15237  71a7 cd7e11                              cmp dosofl+1
 15238  71aa 9352e0                              +lbcc fcerr                              ; ...error
 15239  71ad d00c                                bne l224_1
 15240  71af ad7f11                              lda dosofh
 15241  71b2 cd7d11                              cmp dosofl
 15242  71b5 9347e0                              +lbcc fcerr                              ; ...error
 15243  71b8 f344e0                              +lbeq fcerr
 15244                          
 15245  71bb a009               l224_1           ldy #fopn                                ; table offset
 15246  71bd a904                                lda #4                                   ; ..length
 15247  71bf 20f276                              jsr sendp
 15248                          
 15249  71c2 ad8c11                              lda dosbnk                               ; get requested bank
 15250  71c5 a200                                ldx #sys_bank                            ; ..and name will be in system bank
 15251  71c7 206bff                              jsr _setbank                             ; ..and go set up bank
 15252                          
 15253  71ca ae7d11                              ldx dosofl                               ; start addr
 15254  71cd ac7e11                              ldy dosofl+1
 15255  71d0 a95a                                lda #highds                              ; ..and a pointer to start address
 15256  71d2 865a                                stx highds
 15257  71d4 845b                                sty highds+1
 15258  71d6 ae7f11                              ldx dosofh                               ; end addr
 15259  71d9 ac8011                              ldy dosofh+1
 15260  71dc 838df6                              +lbra savenb
 15261                          
 15262                          
 15263                          
 15264                          ; DVERIFY
 15265                          
 15266  71df a901               bverify          lda #1                                   ; flag 'verify'
 15267  71e1 2c                                  !text $2c
 15268                          
 15269                          
 15270                          ;[[command.bload]]
 15271                          
 15272                          ; BLOAD dfn
 15273                          
 15274  71e2 a900               bload            lda #0                                   ; flag 'load'
 15275  71e4 850c                                sta verck                                ; eventually the 'load' routine will look here
 15276                          
 15277  71e6 a9e6                                lda #$e6                                 ; std error flag
 15278  71e8 a2fc                                ldx #$fc                                 ; aux error flag (allow bank & load address)
 15279  71ea 202274                              jsr dosprx                               ; parse options
 15280                          
 15281                          bload_boot                                                ; <<<<<<<<<<<<<<<<<<<<<< entry for BOOT'filename'
 15282  71ed 20e177                              jsr chk2                                 ; check required parameters
 15283  71f0 ae7d11                              ldx dosofl                               ; get starting address high
 15284  71f3 ac7e11                              ldy dosofl+1                             ; ..and lo
 15285  71f6 a900                                lda #0                                   ; assume x & y not both=ff (means real add., not def)
 15286  71f8 e0ff                                cpx #$ff
 15287  71fa d006                                bne l225_1
 15288  71fc c0ff                                cpy #$ff
 15289  71fe d002                                bne l225_1
 15290  7200 a9ff                                lda #$ff                                 ; use defaults
 15291  7202 8d8311             l225_1           sta dossa
 15292                          
 15293  7205 a009                                ldy #fopn                                ; table offset
 15294  7207 a904                                lda #4                                   ; ..length,
 15295  7209 20f276                              jsr sendp                                ; ...and go send parameters
 15296                          
 15297  720c ad8c11                              lda dosbnk
 15298  720f a200                                ldx #sys_bank
 15299  7211 206bff                              jsr _setbank
 15300                          
 15301  7214 a50c                                lda verck                                ; flag LOAD or VERIFY
 15302  7216 ae7d11                              ldx dosofl                               ; get starting address high
 15303  7219 ac7e11                              ldy dosofl+1                             ; ..and lo (in case this isn't a 'default' load)
 15304  721c 20d5ff                              jsr _loadsp                              ; load it
 15305                          
 15306                          ; Any changes to the following code must be duplicated at:
 15307                          ;  load (load_file)
 15308                          ;  save (exit_disk_op)
 15309                          
 15310  721f 08                                  php                                      ; save kernel load status (.c)
 15311  7220 48                                  pha                                      ; save kernel error # (.a)
 15312  7221 20b7ff                              jsr _readst                              ; save I/O status byte
 15313  7224 857f                                sta parsts
 15314  7226 206e72                              jsr print_dos_error                      ; report DOS problems
 15315  7229 68                                  pla                                      ; restore error stuff
 15316  722a 28                                  plp
 15317  722b 9010                                bcc l225_4                               ; branch if no error (rts)
 15318  722d ff7e0a                              bbs7 runmod,l225_3                       ; branch if run mode (erexit)
 15319  7230 c904                                cmp #errfnf                              ; is it 'file not found' catch-all?
 15320  7232 d005                                bne l225_2                               ; no  (erexit)
 15321  7234 8dc702                              sta errnum                               ; yes- save error # for 'er'
 15322  7237 0980                                ora #$80                                 ; but no errdis
 15323  7239 38                 l225_2           sec
 15324  723a b3faf5             l225_3           +lbcs erexit                             ; exit if kernel problem (rts)
 15325                          
 15326  723d a50c               l225_4           lda verck                                ; load or verify operation?
 15327  723f d388f6                              +lbne verify_check                       ; verify
 15328                          
 15329                          ; jsr _readst  ;  read status
 15330  7242 a57f                                lda parsts                               ; load
 15331  7244 29bf                                and #%10111111                           ; EOI is okay, so mask it
 15332  7246 d398f6                              +lbne load_error                         ; load error
 15333  7249 18                                  clc
 15334  724a 60                                  rts
 15335                          
 15336                          ;[[command.header]]
 15337                          
 15338                          
 15339                          ; HEADER nddn [,id]  (alias: FORMAT)
 15340                          
 15341  724b 201e74             header           jsr dospar                               ; parse the line
 15342  724e 20dc77                              jsr chk1                                 ; check parameter errors
 15343  7251 2901                                and #$01
 15344  7253 c901                                cmp #$01
 15345  7255 d3f3bb                              +lbne snerr                              ; if required parameters not present
 15346                          
 15347  7258 20e7ff                              jsr _clall                               ; close all files
 15348  725b 20c378                              jsr are_you_sure                         ; confirm if in direct mode
 15349  725e d072                                bne header_rts                           ; exit if 'no' response
 15350  7260 a02d                                ldy #fhed                                ; tabld index
 15351  7262 a904                                lda #4                                   ; length
 15352  7264 ae8d11                              ldx dosdid                               ; check for diskid
 15353  7267 f002                                beq l226_1
 15354  7269 a906                                lda #6                                   ; length with id
 15355                          
 15356  726b 20f973             l226_1           jsr trans                                ; build and send command
 15357                          ;fall into 'print_dos_error'
 15358                          
 15359                          ;[[dos.errors]]
 15360                          
 15361                          print_dos_error                                           ; [900725]
 15362  726e ff7e61                              bbs7 runmod,header_rts                   ; branch if not direct mode
 15363  7271 200e78                              jsr Check_DS                             ; get current disk error message
 15364  7274 a000                                ldy #0
 15365  7276 a97a                                lda #dsdesc+1
 15366  7278 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y peek at first character
 15367  727b c932                                cmp #'2'
 15368  727d 9053                                bcc header_rts                           ; branch if no error occured ('00' or '01')
 15369  727f c937                                cmp #'7'
 15370  7281 d00a                                bne l227_1                               ; [900730]
 15371  7283 c8                                  iny
 15372  7284 a97a                                lda #dsdesc+1
 15373  7286 20d722                              jsr lda_far_ram1                         ; might be '73' powerup message
 15374  7289 c933                                cmp #'3'
 15375  728b f045                                beq header_rts                           ; yup
 15376                          
 15377                          ; ldx #errbdk  ; bad disk error (carry is set)
 15378                          ; bra error
 15379                          
 15380                          ; Print DOS error message as if it were a BASIC error message   [900910]
 15381                          
 15382  728d a9ff               l227_1           lda #$ff                                 ; reset error line
 15383  728f 8dc802                              sta errlin                               ;
 15384  7292 8dc902                              sta errlin+1
 15385  7295 20ccff                              jsr _clrch
 15386                          ; inc a   ;a=0 restore output to screen   [910909]
 15387  7298 8515                                sta channl
 15388  729a 2027af                              jsr RestoreTextScreen                    ; make sure we're in text mode????  [910404]
 15389  729d 200935                              jsr init_stack                           ; clean up system, string temps, etc.  [910121]
 15390                          
 15391  72a0 20dc3c                              jsr highlight_text                       ; [910624]
 15392  72a3 207dff                              jsr _primm                               ; start a new line with '?DOS: '
 15393  72a6 0d3f444f533a2000                    !text cr,"?DOS: ",0                      ; (to distinguish ?DOS: SYNTAX ERROR from ?SYNTAX ERROR)
 15394                          
 15395  72ae a003                                ldy #3                                   ; print text part of message only
 15396  72b0 a97a                                lda #dsdesc+1
 15397  72b2 20d722                              jsr lda_far_ram1                         ; skip err#, comma, & leading space if any
 15398  72b5 c920                                cmp #' '
 15399  72b7 d00a                                bne l227_3
 15400  72b9 c8                                  iny
 15401  72ba a97a               l227_2           lda #dsdesc+1
 15402  72bc 20d722                              jsr lda_far_ram1
 15403  72bf c92c                                cmp #','                                 ; finished at comma preceding trk, sector
 15404  72c1 f006                                beq l227_4
 15405  72c3 203d68             l227_3           jsr outch
 15406  72c6 c8                                  iny
 15407  72c7 10f1                                bpl l227_2                               ; loop always (bpl=failsafe)
 15408                          
 15409  72c9 20cb3c             l227_4           jsr highlight_done                       ; [910624]
 15410  72cc 20f737                              jsr crdo
 15411  72cf 837cbb                              +lbra ready                              ; we're in direct mode, error msg has been printed, abort
 15412                          
 15413                          header_rts
 15414  72d2 18                                  clc
 15415  72d3 60                                  rts
 15416                          
 15417                          ;[[command.scratch]]
 15418                          
 15419                          ; SCRATCH sdfn  aliases: DELETE, ERASE
 15420                          
 15421  72d4 201e74             scratch          jsr dospar                               ; parse the line
 15422  72d7 20dc77                              jsr chk1
 15423  72da 20c378                              jsr are_you_sure                         ; confirm if in direct mode
 15424  72dd d02b                                bne l228_4                               ; branch if 'no' response given
 15425                          
 15426  72df a049                                ldy #fscr                                ; offset
 15427  72e1 a904                                lda #4                                   ; length
 15428  72e3 2c8f11                              bit dosflags                             ; scratch or recover?
 15429  72e6 5004                                bvc l228_1                               ; scratch
 15430  72e8 a04d                                ldy #frscr                               ; recover
 15431  72ea a906                                lda #6
 15432  72ec 20f973             l228_1           jsr trans                                ; transmit scratch command
 15433  72ef 201378                              jsr Read_DS                              ; read error channel & update DS$
 15434                          
 15435  72f2 ff7e15                              bbs7 runmod,l228_4                       ; branch if not direct mode
 15436  72f5 20f737                              jsr crdo                                 ; output cr
 15437                          
 15438  72f8 a000                                ldy #0                                   ; display 'files scratched' DOS message
 15439  72fa a97a               l228_2           lda #dsdesc+1
 15440  72fc 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y
 15441  72ff f006                                beq l228_3                               ; if end of error message
 15442  7301 203d68                              jsr outch                                ; print it
 15443  7304 c8                                  iny
 15444  7305 10f3                                bpl l228_2                               ; always (bpl=failsafe)
 15445                          
 15446  7307 20f737             l228_3           jsr crdo                                 ; done
 15447                          
 15448  730a 60                 l228_4           rts
 15449                          
 15450                          
 15451                          ;[[command.record]]
 15452                          ; RECORD- relative record access
 15453                          
 15454  730b a923               record           lda #'#'
 15455  730d 205d4e                              jsr synchr                               ; syntax error if not 'record#'
 15456                          
 15457  7310 206c5d                              jsr getbyt                               ; get lfn in x
 15458  7313 e000                                cpx #0
 15459  7315 f3e7de                              +lbeq fcerr                              ; cannot be zero
 15460  7318 8e8111                              stx dosla                                ; save logical address
 15461                          
 15462  731b 20875d                              jsr comwrd                               ; check for comma, get record number in 'poker'
 15463                          
 15464  731e a201                                ldx #1                                   ; set up to get starting byte # - default is 1
 15465  7320 202679                              jsr optbyt
 15466  7323 8e8b11                              stx dosrcl                               ; save byte position (pos)    [911024]
 15467  7326 8a                                  txa                                      ; cpx #0
 15468  7327 f3d5de                              +lbeq fcerr                              ; if out of range
 15469  732a e8                                  inx                                      ; cpx #$ff
 15470  732b f3d1de                              +lbeq fcerr                              ; if out of range
 15471                          
 15472  732e ad8111                              lda dosla                                ; get logical address
 15473                          ; jsr put_io_in_map
 15474  7331 205fff                              jsr _lkupla                              ; logical to physical map
 15475  7334 b01a                                bcs l229_1                               ; if file not found (not open)    [910404]
 15476  7336 8c9011                              sty dossa_temp                           ; save secondary address
 15477                          
 15478  7339 8e8211                              stx dosfa                                ; set up device number for trans routine
 15479  733c a900                                lda #0
 15480  733e 8d8111                              sta dosla                                ; set up logical address for trans routine
 15481  7341 a96f                                lda #$6f
 15482  7343 8d8311                              sta dossa                                ; and secondary address, too!
 15483                          
 15484  7346 a055                                ldy #frec                                ; set pointer
 15485  7348 a904                                lda #4                                   ; process five bytes
 15486  734a 20f973                              jsr trans                                ; send command
 15487  734d 831fff                              +lbra print_dos_error                    ; if any
 15488                          
 15489  7350 a203               l229_1           ldx #errfno                              ; file not found err (file not open)   [910404]
 15490  7352 83fbba                              +lbra error
 15491                          
 15492                          ;[[command.DCLEAR]]
 15493                          
 15494                          ; DCLEAR - reinitilaize the drive
 15495                          
 15496  7355 201e74             dclear           jsr dospar                               ; parse the line
 15497  7358 a0ff                                ldy #finit                               ; set code
 15498  735a a902                                lda #2
 15499  735c 20f973                              jsr trans                                ; send command
 15500  735f 206e72                              jsr print_dos_error                      ; if any
 15501  7362 83ddfd                              +lbra dclall
 15502                          
 15503                          ;[[command.collect]]
 15504                          ; COLLECT v<drive#>
 15505                          
 15506  7365 201e74             collect          jsr dospar                               ; parse the line
 15507  7368 20ed77                              jsr chk3                                 ; check optional parameters
 15508  736b 20e7ff                              jsr _clall                               ; close all files
 15509  736e a033                                ldy #fcoll                               ; tabld offset
 15510  7370 a901                                lda #1                                   ; length
 15511  7372 4f7f01                              bbr4 parsts,l230_1
 15512  7375 1a                                  inc                                      ; include drive
 15513  7376 20f973             l230_1           jsr trans                                ; send command
 15514  7379 83f3fe                              +lbra print_dos_error                    ; if any
 15515                          
 15516                          
 15517                          ;[[command.copy]]
 15518                          
 15519                          ; COPY cdddfn=sdsfn
 15520                          
 15521  737c 201e74             dcopy            jsr dospar                               ; parse the line
 15522  737f 2930                                and #$30
 15523  7381 c930                                cmp #$30                                 ; check required parameters
 15524  7383 d024                                bne l231_1                               ; branch if single drive copy
 15525  7385 a57f                                lda parsts                               ; else check for dual drive params
 15526  7387 29c7                                and #$c7
 15527  7389 f023                                beq l231_2
 15528  738b 2903                                and #3                                   ; special check for 2nd filename   [910717]
 15529  738d c903                                cmp #3
 15530  738f f018                                beq l231_1                               ; branch if given
 15531  7391 a92a                                lda #'*'
 15532  7393 8d8d11                              sta dosdid                               ; else supply "*" for him, just like 'name2'
 15533  7396 a901                                lda #1
 15534  7398 a28d                                ldx #<dosdid
 15535  739a a011                                ldy #>dosdid
 15536  739c 8d8711                              sta dosf2l
 15537  739f 8e8911                              stx dosf2a
 15538  73a2 8c8a11                              sty dosf2a+1
 15539  73a5 a902                                lda #2                                   ; and set filename2 flag
 15540  73a7 047f                                tsb parsts                               ; set flag in status
 15541  73a9 a57f               l231_1           lda parsts
 15542  73ab 20f377                              jsr chk4
 15543                          ; lda parsts
 15544  73ae a039               l231_2           ldy #fcopy                               ; tabld offset
 15545  73b0 a908                                lda #8                                   ; length
 15546  73b2 20f973                              jsr trans                                ; send command
 15547  73b5 83b7fe                              +lbra print_dos_error                    ; if any
 15548                          
 15549                          
 15550                          
 15551                          ;[[command.concat]]
 15552                          ; CONCAT
 15553                          
 15554  73b8 201e74             concat           jsr dospar                               ; parse the line
 15555  73bb 20f377                              jsr chk4
 15556  73be a01f                                ldy #fconc                               ; offset
 15557  73c0 a90c                                lda #12                                  ; length
 15558  73c2 20f973                              jsr trans                                ; send command
 15559  73c5 83a7fe                              +lbra print_dos_error                    ; if any
 15560                          
 15561                          
 15562                          
 15563                          ;[[command.rename]]
 15564                          
 15565                          ; RENAME rdddfn=sdsfn
 15566                          
 15567  73c8 a9e4               rename           lda #$e4                                 ; set error flags
 15568  73ca 202074                              jsr dosprs                               ; parse the line
 15569  73cd 20fa77                              jsr chk5
 15570  73d0 a041                                ldy #fren                                ; offset
 15571  73d2 a908                                lda #8                                   ; length
 15572  73d4 20f973                              jsr trans                                ; send command
 15573  73d7 8395fe                              +lbra print_dos_error                    ; if any
 15574                          
 15575                          
 15576                          
 15577                          ; BACKUP D<destination_drive>=D<source_drive>
 15578                          ;
 15579                          ; where destination|source_drive is [0...9]
 15580                          
 15581  73da a9c7               backup           lda #$c7                                 ; set error flags
 15582  73dc 202074                              jsr dosprs                               ; parse the line
 15583  73df 2930                                and #$30                                 ; required parameters
 15584  73e1 c930                                cmp #$30
 15585  73e3 d365ba                              +lbne snerr
 15586  73e6 20c378                              jsr are_you_sure
 15587  73e9 f001                                beq l232_1                               ; if run mode or not 'yes'
 15588  73eb 60                                  rts
 15589                          
 15590  73ec 204171             l232_1           jsr dclall                               ; close disk
 15591  73ef a035                                ldy #fbak
 15592  73f1 a904                                lda #4                                   ; length
 15593  73f3 20f973                              jsr trans                                ; send command
 15594  73f6 8376fe                              +lbra print_dos_error                    ; if any
 15595                          
 15596                          ;[[command.trans]]
 15597                          
 15598                          
 15599                          ; Trans subroutine
 15600                          
 15601  73f9 20f276             trans            jsr sendp                                ; build string to output
 15602  73fc 20ccff                              jsr _clrch
 15603  73ff a200                                ldx #sys_bank                            ; name is in system space, bank0 ????  [910620]
 15604  7401 8a                                  txa
 15605  7402 206bff                              jsr _setbank
 15606  7405 20c0ff                              jsr _open                                ; send it...
 15607  7408 08                                  php                                      ; save error status (.c)
 15608  7409 48                                  pha                                      ; save error code (if any)
 15609  740a ad8111                              lda dosla
 15610  740d 38                                  sec
 15611  740e 20c3ff                              jsr _close                               ; special close...
 15612  7411 68                                  pla                                      ; pop error
 15613  7412 28                                  plp                                      ; pop error status
 15614  7413 b321f4                              +lbcs erexit                             ; ...branch if there was an error opening
 15615  7416 60                                  rts
 15616                          
 15617                          ;.end
 15618                          ;[[dos.parser]]
 15619                          
 15620                          
 15621                          
 15622                          ; This is the DOS parser routine which looks at lines passed to it and
 15623                          ; verifies that the syntax is proper.  -mgm 7/23/79-
 15624                          ;
 15625                          ; Entry  (dosprs)
 15626                          ; a = parsts bit which must be zero.
 15627                          ;
 15628                          ; Exit  a = parsts as follows
 15629                          ;
 15630                          ;    ---------------------------------
 15631                          ;    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 15632                          ;    ---------------------------------
 15633                          ;      ^   ^   ^   ^   ^   ^   ^   ^
 15634                          ;      |   |   |   |   |   |   |   |_____ fn1 set for the first filename
 15635                          ;      |   |   |   |   |   |   |_______ fn2 set for second filename
 15636                          ;      |   |   |   |   |   |_________ la set when #lfn parsed
 15637                          ;      |   |   |   |   |___________ fa set for device number
 15638                          ;      |   |   |   |_____________ d1 set for first disk unit
 15639                          ;      |   |   |_______________ d2 set for second disk unit
 15640                          ;      |   |_________________ dosrcl set for record size
 15641                          ;      |___________________ @ set when @ encountered
 15642                          ;
 15643                          ; The following are the vaild bit patterns for parsts after parsing for the
 15644                          ; various keywords:
 15645                          ;
 15646                          ;       7 6 5 4  3 2 1 0
 15647                          ;
 15648                          ;     header  0 0 0 *  * 0 0 1
 15649                          ;     collect 0 0 0 *  * 0 0 0
 15650                          ;     dclear  0 0 0 *  * 0 0 0
 15651                          ;     backup  0 0 1 1  * 0 0 0
 15652                          ;     copy    0 0 1 1  * 0 0 0
 15653                          ;      or..   0 0 * *  * 0 1 1
 15654                          ;     concat  0 0 * *  * 0 1 1
 15655                          ;     bsave   * 0 0 *  * 0 0 1
 15656                          ;     dsave   * 0 0 *  * 0 0 1
 15657                          ;     bload   0 0 0 *  * 0 0 1
 15658                          ;     dload   0 0 0 *  * 0 0 1
 15659                          ;     dverify 0 0 0 *  * 0 0 1
 15660                          ;     catalog 0 0 0 *  * 0 0 *
 15661                          ;     rename  0 0 0 *  * 0 1 1
 15662                          ;     append  0 0 0 *  * 1 0 1
 15663                          ;     scratch 0 0 0 *  * 0 0 1
 15664                          ;     dopen   * * 0 *  * 1 0 1
 15665                          ;     dclose  0 0 0 0  * * 0 0
 15666                          ;             ^ ^ ^ ^  ^ ^ ^ ^
 15667                          ;             @ l d d  f l f f
 15668                          ;             r r 2 1  a a n n
 15669                          ;             p e          2 1
 15670                          ;             l l
 15671                          ;
 15672                          ;      "0" bits are required to be clear
 15673                          ;      "1" bits are required to be set
 15674                          ;      "*" bits are optional parameters
 15675                          
 15676                          ; Entry (dosprs):
 15677                          ;  parstx shall be set to prevent any auxiliary options to be specified.
 15678                          ;
 15679                          ; Entry (dosprx):
 15680                          ;  .x = parstx bits which must be zero.
 15681                          ;
 15682                          ; Exit:  .x = parstx as follows:
 15683                          ;
 15684                          ;     ---------------------------------
 15685                          ;     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
 15686                          ;     ---------------------------------
 15687                          ;       ^   ^   ^   ^   ^   ^   ^   ^____ bnk is set for bank option
 15688                          ;       |   |   |   |   |   |   | ______ offl set for 1st address
 15689                          ;       |   |   |   |   |   |_________ offh set for 2nd address
 15690                          ;       |   |   |   |   |___________ unused
 15691                          ;       |   |   |   |_____________ unused
 15692                          ;       |   |   |_______________ unused
 15693                          ;       |   |_________________ unused
 15694                          ;       |___________________ unused
 15695                          ;
 15696                          ; The following are the valid bit patterns for parstx after parsing for the
 15697                          ; various keywords.  These options are allowed for load/save commands only.
 15698                          ;
 15699                          ;    7 6 5 4  3 2 1 0
 15700                          ;
 15701                          ;   bsave   0 0 0 0  0 1 1 *
 15702                          ;   bload   0 0 0 0  0 0 * *
 15703                          ;   bverify 0 0 0 0  0 0 * *
 15704                          ;   [auto]boot 0 0 0 0  0 0 * *
 15705                          ;    ^ ^ ^ ^  ^ ^ ^ ^
 15706                          ;    ? ? ? ?  ? o o b
 15707                          ;        f f n
 15708                          ;        h l k
 15709                          ;
 15710                          ;      "0" bits are required to be clear
 15711                          ;      "1" bits are required to be set
 15712                          ;      "*" bits are optional parameters
 15713                          
 15714  7417 ffffffff           dostbl           !word $ffff,$ffff                        ; default start/end address
 15715  741b 00086f                              !text doslfn,dosffn,$6f                  ; default la/fa/sa
 15716                          
 15717                          
 15718  741e a900               dospar           lda #0                                   ; DOS Parser
 15719                          
 15720                          dosprs                                                    ; special error flag entry
 15721  7420 a2ff                                ldx #$ff                                 ; no aux options!
 15722                          
 15723                          dosprx                                                    ; spec aux error flag entry
 15724  7422 48                                  pha                                      ; save error flags
 15725  7423 da                                  phx
 15726  7424 a900                                lda #0
 15727  7426 857f                                sta parsts                               ; reset parser status/option words
 15728  7428 8580                                sta parstx
 15729                          
 15730  742a a20d                                ldx #dosspc                              ; clear DOS scratch area   [900522]
 15731  742c 9d8311             l233_1           sta xcnt-1,x
 15732  742f ca                                  dex                                      ; no filenames, null lengths
 15733  7430 d0fa                                bne l233_1
 15734                          
 15735  7432 a206                                ldx #dossa-dosofl                        ; set some defaults from table
 15736  7434 bd1774             l233_2           lda dostbl,x
 15737  7437 9d7d11                              sta dosofl,x                             ; start/end adr = $FFFF, la/fa/sa
 15738  743a ca                                  dex
 15739  743b 10f7                                bpl l233_2
 15740                          
 15741  743d ae0611                              ldx _default_drive                       ; set default device   [900522]
 15742  7440 8e8211                              stx dosfa
 15743  7443 aed102                              ldx current_bank                         ; set current bank
 15744  7446 8e8c11                              stx dosbnk
 15745                          
 15746  7449 208522                              jsr chrgot                               ; get next character from command string
 15747  744c d00f                                bne parse1                               ; if eol stick with defaults, else begin parsing
 15748                          
 15749                          
 15750                          ; Done parsing, check for errors, return if everything okay
 15751                          
 15752  744e 68                 done             pla                                      ; get aux error flag
 15753  744f 2580                                and parstx                               ; repeated or illegal params?
 15754  7451 d3f7b9                              +lbne snerr                              ; yes- report syntax error
 15755  7454 68                                  pla                                      ; get error flags
 15756  7455 208c76                              jsr prmrpt
 15757  7458 a57f                                lda parsts
 15758  745a a680                                ldx parstx
 15759  745c 60                                  rts
 15760                          
 15761                          
 15762                          ; Parse given parameters.  what it is  example
 15763                          ;     -------------------- ---------
 15764  745d c922               parse1           cmp #'"'
 15765  745f f30201                              +lbeq name1                              ; explicit filename "file"
 15766  7462 c928                                cmp #'('
 15767  7464 f3fd00                              +lbeq name1                              ; evaluate filename (f$)
 15768  7467 c923                                cmp #'#'
 15769  7469 f039                                beq logadr                               ; logical file number #1
 15770  746b c955                                cmp #'U'
 15771  746d f029                                beq unit1                                ; unit number  U8
 15772  746f c944                                cmp #'D'
 15773  7471 f06d                                beq drv1                                 ; drive number  D0
 15774  7473 c950                                cmp #'P'
 15775  7475 f3b700                              +lbeq doffl                              ; load/save address P1234
 15776  7478 c942                                cmp #'B'
 15777  747a f022                                beq dbank1                               ; load/save bank   B0
 15778  747c c957                                cmp #'W'
 15779  747e f038                                beq reclen                               ; write mode  W
 15780  7480 c94c                                cmp #'L'
 15781  7482 f034                                beq reclen                               ; record length  L80
 15782  7484 c952                                cmp #'R'
 15783  7486 f3ce00                              +lbeq recover                            ; recover mode  R
 15784  7489 c949                                cmp #'I'
 15785  748b f06b                                beq ident                                ; ID   Ixx
 15786  748d c991                                cmp #on_token
 15787                          ; beq on1   ; ON token  ON
 15788                          
 15789  748f d3b9b9                              +lbne snerr                              ; none of these, syntax error
 15790                          
 15791                          
 15792  7492 20fe75             on1              jsr on
 15793  7495 83e400                              +lbra del1
 15794                          
 15795                          
 15796  7498 200a76             unit1            jsr unit                                 ; do unit# parsing
 15797  749b 83de00                              +lbra del1                               ; always
 15798                          
 15799                          
 15800  749e 202476             dbank1           jsr dbank
 15801  74a1 83d800                              +lbra del1                               ; always
 15802                          
 15803                          
 15804  74a4 a904               logadr           lda #4
 15805  74a6 208c76                              jsr prmrpt                               ; check for repeated parameter
 15806  74a9 20695d                              jsr gtbytc                               ; getval
 15807  74ac 8a                                  txa                                      ; cpx #0
 15808  74ad f34fdd                              +lbeq fcerr                              ; if illegal value
 15809  74b0 8e8111                              stx dosla
 15810  74b3 a904                                lda #4                                   ; set logical address flag
 15811  74b5 83c400                              +lbra del1                               ; get next parameter
 15812                          
 15813                          
 15814  74b8 aa                 reclen           tax                                      ; save char
 15815  74b9 a940                                lda #$40
 15816  74bb 208c76                              jsr prmrpt                               ; check for repeated parameter
 15817  74be e057                                cpx #'W'
 15818  74c0 d005                                bne l234_1
 15819  74c2 208322                              jsr chrget
 15820  74c5 8014                                bra l234_4                               ; set parsts
 15821                          
 15822  74c7 a201               l234_1           ldx #1                                   ; a kludge to allow  DOPEN#lf,"relfile",L  [911024]
 15823  74c9 208322                              jsr chrget
 15824  74cc f003                                beq l234_2                               ; eol? open existing rel file
 15825  74ce 206c5d                              jsr getbyt                               ; get reclen (was getval)
 15826  74d1 8e8b11             l234_2           stx dosrcl                               ; store parcel
 15827  74d4 8a                                  txa                                      ; cpx #0
 15828  74d5 f001                                beq l234_3                               ; zero illegal dosrcl
 15829  74d7 e8                                  inx                                      ; cpx #255
 15830  74d8 f324dd             l234_3           +lbeq fcerr                              ; illegal dosrcl
 15831                          
 15832  74db a940               l234_4           lda #$40                                 ; set dosrcl flag &
 15833  74dd 839c00                              +lbra del1
 15834                          
 15835                          
 15836  74e0 a910               drv1             lda #$10
 15837  74e2 208c76                              jsr prmrpt                               ; check for repeated parameter
 15838  74e5 20695d                              jsr gtbytc                               ; getval
 15839  74e8 e00a                                cpx #10
 15840  74ea b312dd                              +lbcs fcerr                              ; illegal drv# if >9 [allow 0: to 9: ?????]
 15841  74ed 8e8611                              stx dosds1
 15842  74f0 8e8811                              stx dosds2
 15843  74f3 a910                                lda #$10
 15844  74f5 838400                              +lbra del1
 15845                          
 15846                          
 15847  74f8 a980               ident            lda #$80                                 ; set ID flag
 15848  74fa 0c8f11                              tsb dosflags
 15849  74fd d34bb9                              +lbne snerr                              ; repeated parameter
 15850  7500 208322                              jsr chrget                               ; get next character
 15851  7503 c928                                cmp #'('                                 ; c65: allow I(ID$) syntax  [900710]
 15852  7505 d019                                bne l235_1
 15853  7507 20675b                              jsr frmstr                               ; get ID from var
 15854  750a c902                                cmp #2
 15855  750c 935c01                              +lbcc err_mfn                            ; if length < 2, error
 15856  750f a000                                ldy #0
 15857  7511 20d522                              jsr indin1_ram1                          ; else grab first two characters
 15858  7514 8d8d11                              sta dosdid
 15859  7517 c8                                  iny
 15860  7518 20d522                              jsr indin1_ram1
 15861  751b 8d8e11                              sta dosdid+1
 15862  751e 805d                                bra delim1                               ; continue
 15863                          
 15864  7520 8d8d11             l235_1           sta dosdid                               ; m(txtptr => dosdid
 15865  7523 208322                              jsr chrget
 15866  7526 8d8e11                              sta dosdid+1
 15867  7529 208322                              jsr chrget                               ; continue
 15868  752c 8052                                bra delim2
 15869                          
 15870                          
 15871  752e a902               doffl            lda #$02                                 ; check aux status
 15872  7530 209276                              jsr prxrpt
 15873  7533 207576                              jsr getoff                               ; get offset value
 15874  7536 8c7d11                              sty dosofl
 15875  7539 8d7e11                              sta dosofl+1
 15876  753c a902                                lda #$02
 15877  753e 0580               dlimx1           ora parstx                               ; set aux status bits
 15878  7540 8580                                sta parstx
 15879  7542 d039                                bne delim1                               ; try for next param
 15880                          
 15881                          
 15882  7544 a904               doffh            lda #$04
 15883  7546 209276                              jsr prxrpt
 15884  7549 207576                              jsr getoff
 15885  754c 8c7f11                              sty dosofh
 15886  754f 8d8011                              sta dosofh+1
 15887  7552 a904                                lda #$04
 15888  7554 80e8                                bra dlimx1                               ; set aux status
 15889                          
 15890                          
 15891  7556 a940               recover          lda #$40
 15892  7558 0c8f11                              tsb dosflags                             ; set 'recover' bit
 15893  755b d3edb8                              +lbne snerr                              ; if repeated parameter
 15894  755e 208322                              jsr chrget                               ; continue
 15895  7561 801d                                bra delim2
 15896                          
 15897                          
 15898  7563 a901               name1            lda #1                                   ; name1 allowed only once
 15899  7565 203676                              jsr newnam                               ; do name parsing
 15900  7568 8d8511                              sta dosf1l
 15901                          
 15902  756b a000                                ldy #0
 15903  756d 20d522             l236_1           jsr indin1_ram1
 15904  7570 999111                              sta savram,y                             ; copy name into buffer
 15905  7573 c8                                  iny
 15906  7574 cc8511                              cpy dosf1l
 15907  7577 90f4                                bcc l236_1                               ; ...copy all of it
 15908  7579 a901                                lda #1                                   ; set name1 flag
 15909                          
 15910                          
 15911  757b 047f               del1             tsb parsts
 15912                          
 15913  757d 208522             delim1           jsr chrgot
 15914  7580 d016               delim2           bne nxxx
 15915  7582 83cafe                              +lbra done                               ; <cr>/<> => done
 15916                          
 15917                          
 15918  7585 c991               next6            cmp #on_token
 15919  7587 f309ff                              +lbeq on1
 15920  758a c9a4                                cmp #to_token                            ; "to" token
 15921  758c d3bcb8                              +lbne snerr                              ; syntax error
 15922                          
 15923                          ;  If "to" is not followed by an offset param, then do file2 params.
 15924                          ;  Otherwise, do high offset and continue with file0 options.
 15925                          
 15926  758f 208322                              jsr chrget
 15927  7592 c950                                cmp #'P'
 15928  7594 d00f                                bne pars22
 15929  7596 f0ac                                beq doffh
 15930                          
 15931                          
 15932  7598 c92c               nxxx             cmp #','
 15933  759a d0e9                                bne next6
 15934  759c 208322                              jsr chrget
 15935  759f 83bcfe                              +lbra parse1
 15936                          
 15937                          
 15938  75a2 208322             parse2           jsr chrget
 15939  75a5 c944               pars22           cmp #'D'
 15940  75a7 f010                                beq l237_1
 15941  75a9 c991                                cmp #on_token                            ; "on" token
 15942  75ab f020                                beq on2
 15943  75ad c955                                cmp #'U'
 15944  75af f021                                beq unit2
 15945  75b1 c922                                cmp #'"'
 15946  75b3 f022                                beq name2
 15947  75b5 c928                                cmp #'('
 15948  75b7 f01e                                beq name2
 15949                          
 15950  75b9 a920               l237_1           lda #$20
 15951  75bb 208c76                              jsr prmrpt                               ; check for repeated parameter
 15952  75be 20695d                              jsr gtbytc                               ; getval
 15953  75c1 e00a                                cpx #10
 15954  75c3 b339dc                              +lbcs fcerr                              ; illegal drive #  [allow 0: to 9: ????]
 15955  75c6 8e8811                              stx dosds2
 15956  75c9 a920                                lda #$20
 15957  75cb 801a                                bra del2
 15958                          
 15959  75cd 20fe75             on2              jsr on
 15960  75d0 8015                                bra del2
 15961                          
 15962                          
 15963  75d2 200a76             unit2            jsr unit                                 ; do unit# parsing
 15964  75d5 8010                                bra del2                                 ; always
 15965                          
 15966  75d7 a902               name2            lda #2                                   ; name2 allowed only once
 15967  75d9 203676                              jsr newnam
 15968  75dc 8d8711                              sta dosf2l
 15969  75df 8e8911                              stx dosf2a
 15970  75e2 8c8a11                              sty dosf2a+1
 15971                          
 15972  75e5 a902                                lda #2                                   ; set filename2 flag &
 15973  75e7 047f               del2             tsb parsts                               ; set flag in status
 15974  75e9 208522                              jsr chrgot
 15975  75ec f360fe                              +lbeq done                               ; done on <cr>/<>
 15976  75ef c92c                                cmp #','
 15977  75f1 f0af                                beq parse2
 15978  75f3 c991                                cmp #on_token                            ; "on" token
 15979  75f5 f0d6                                beq on2
 15980  75f7 c955                                cmp #'U'
 15981  75f9 f0d7                                beq unit2
 15982  75fb 834db8                              +lbra snerr
 15983                          
 15984                          
 15985  75fe 208322             on               jsr chrget
 15986  7601 c942                                cmp #'B'
 15987  7603 f01f                                beq dbank
 15988  7605 c955                                cmp #'U'
 15989  7607 d341b8                              +lbne snerr
 15990                          
 15991                          
 15992  760a 20695d             unit             jsr gtbytc                               ; getval
 15993  760d e01f                                cpx #31
 15994  760f b05c                                bcs err_ild                              ; error if >30
 15995  7611 e001                                cpx #1                                   ; drive 1 = use system default drive  [910221]
 15996  7613 d005                                bne l238_1
 15997  7615 ae0611                              ldx _default_drive
 15998  7618 8004                                bra l238_2
 15999  761a e004               l238_1           cpx #4
 16000  761c 904f                                bcc err_ild                              ; error if <4
 16001  761e 8e8211             l238_2           stx dosfa
 16002  7621 a908                                lda #$08                                 ; set parser's unit flag
 16003  7623 60                                  rts
 16004                          
 16005                          
 16006  7624 a901               dbank            lda #$01                                 ; repeated param?
 16007  7626 209276                              jsr prxrpt
 16008  7629 20695d                              jsr gtbytc                               ; getval
 16009                          ; cpx #16  ;bank too large?
 16010                          ; bcs fcerr ;illegal qty
 16011  762c 8e8c11                              stx dosbnk
 16012  762f a901                                lda #$01
 16013  7631 0480                                tsb parstx                               ; set bnk bit in aux status
 16014  7633 a900                                lda #0                                   ; .a=std status wrd, no bits to set
 16015  7635 60                                  rts
 16016                          
 16017                          
 16018                          newnam
 16019  7636 48                                  pha                                      ; save nam1,2 for subdir check later  [901115]
 16020  7637 208c76                              jsr prmrpt                               ; check for repeated parameter
 16021  763a 20675b                              jsr frmstr
 16022  763d aa                                  tax                                      ; save length of string
 16023  763e f02a                                beq err_mfn                              ; if length = 0
 16024  7640 a000                                ldy #0
 16025  7642 20d522                              jsr indin1_ram1
 16026  7645 c940                                cmp #'@'                                 ; Replace file convention?
 16027  7647 d00c                                bne l239_1                               ; no
 16028  7649 a980                                lda #$80                                 ; yes- check for repeated param
 16029  764b 208c76                              jsr prmrpt
 16030  764e f77f                                smb7 parsts                              ; set "@" flag
 16031  7650 ca                                  dex                                      ; decrement length
 16032  7651 e324                                inw index1                               ; increment past "@"
 16033  7653 800c                                bra lenchk
 16034                          
 16035  7655 c92f               l239_1           cmp #'/'                                 ; Subdirectory (partition)?   [901115]
 16036  7657 d008                                bne lenchk                               ; no
 16037  7659 68                                  pla                                      ; yes- recall nam1 or nam2
 16038  765a 0c8f11                              tsb dosflags                             ; set appropriate '/' flag (.a=1 or 2)
 16039  765d ca                                  dex                                      ; decrement length
 16040  765e e324                                inw index1                               ; increment past "@"
 16041  7660 89                                  !text $89
 16042                          
 16043                          
 16044  7661 68                 lenchk           pla                                      ; [901115]
 16045  7662 8a                                  txa                                      ; Check filename length
 16046  7663 f005                                beq err_mfn                              ; too small, missing filename  [901115]
 16047                          ; cmp #17  ;  ???? (problem if name has ',P')
 16048                          ; bcs errlen ; too long
 16049  7665 a624                                ldx index1
 16050  7667 a425                                ldy index1+1                             ; ok- return pointer to filename
 16051  7669 60                                  rts
 16052                          
 16053                          
 16054  766a a208               err_mfn          ldx #err_missing_fname
 16055  766c 2c                                  !text $2c
 16056                          
 16057  766d a209               err_ild          ldx #err_illegal_device
 16058  766f 2c                                  !text $2c
 16059                          
 16060  7670 a217               errlen           ldx #errls                               ; string or filename too long
 16061  7672 83dbb7                              +lbra error
 16062                          
 16063                          
 16064                          
 16065                          ; Get next value routine (use gtbytc instead!)
 16066                          
 16067                          ;getval jsr chrget ;get nxt chr
 16068                          ; beq snerr ;if end of statement
 16069                          ; bra getbyt ;       [911024]
 16070                          
 16071                          ; bcc getbyt ;can be numeric, go evaluate it  why this crap ????
 16072                          ; jsr chkopn ;or a "("
 16073                          ; jsr getbyt ;anything else is an error
 16074                          ; bra chkcls ;need closing ")"
 16075                          
 16076                          
 16077                          
 16078                          ; Get next 2-byte expression.  Exit: .a,.y (high,low) value
 16079                          
 16080  7675 208322             getoff           jsr chrget                               ; get nxt chr
 16081  7678 f3d0b7                              +lbeq snerr                              ; if end of statement
 16082  767b 930de7                              +lbcc getwrd                             ; can be num. const, go evaluate it
 16083  767e 20584e                              jsr chkopn                               ; or a "("
 16084  7681 208a5d                              jsr getwrd                               ; expr
 16085  7684 20554e                              jsr chkcls                               ; need closing ")"
 16086  7687 a416                                ldy poker
 16087  7689 a517                                lda poker+1
 16088  768b 60                                  rts
 16089                          
 16090                          
 16091                          
 16092                          ; Prmrpt checks for a repeated parameter.
 16093                          ;
 16094                          ; Entry: .a contains parsts flag to check
 16095                          
 16096                          
 16097  768c 257f               prmrpt           and parsts                               ; compare mask with status
 16098  768e d3bab7                              +lbne snerr                              ; error if bit previously set
 16099  7691 60                                  rts
 16100                          
 16101                          
 16102                          
 16103                          ; Prxrpt checks for a repeated parameter.
 16104                          ;
 16105                          ; Entry: .a contains parstx flag to check
 16106                          
 16107                          
 16108  7692 2580               prxrpt           and parstx                               ; and with parstx
 16109  7694 d3b4b7                              +lbne snerr                              ; if bit previously set
 16110  7697 60                                  rts
 16111                          
 16112                          ;.end
 16113                          
 16114                          
 16115                          
 16116                          ; CBM-2001 BASIC-4 disk verb processors.  -- rsr 7-24-79 --
 16117                          ;
 16118                          ; Token Table Definitions
 16119                          
 16120                          xsca             =$c2                                     ; send dossca
 16121                          xid              =$d0                                     ; sends disk id
 16122                          xd1              =$d1                                     ; sends dosds1
 16123                          xd2              =$d2                                     ; sends dosds2
 16124                          xrec             =$e0                                     ; sends S for SEQ, or dosrcl
 16125                          xwrt             =$e1                                     ; sends W or L
 16126                          xrcl             =$e2                                     ; send low ((poker))
 16127                          xfat             =$f0                                     ; sends "@" or "/" if specified
 16128                          xfn1             =$f1                                     ; sends filename1
 16129                          xfn2             =$f2                                     ; sends filename2
 16130                          
 16131                          
 16132                          ; Tabld - used to build disk command strings
 16133                          
 16134                          tabld
 16135                          finit            = $ff                                    ; Dclear
 16136  7698 49d1                                !text "I",xd1
 16137                          
 16138                          fdir             = *-tabld-1                              ; Dir
 16139  769a 24d13af1                            !text "$",xd1,":",xfn1
 16140                          
 16141                          fdirr            = *-tabld-1                              ; Recover Dir  [901024]
 16142  769e 5fd13af1                            !text "_",xd1,":",xfn1                   ; ('_'=CBM backarrow, $5F)
 16143                          
 16144                          fopn             = *-tabld-1                              ; Dopen
 16145  76a2 f0d13af12ce12ce0                    !text xfat,xd1,":",xfn1,",",xwrt,",",xrec
 16146                          
 16147                          fopnseq          = *-tabld-1                              ; Type   [900801]
 16148  76aa f0d13af12c53                        !text xfat,xd1,":",xfn1,",S"
 16149                          
 16150                          fsavseq          = *-tabld-1                              ; EDIT_SAVE  [910620]
 16151  76b0 f0d13af12c532c57                    !text xfat,xd1,":",xfn1,",S,W"
 16152                          
 16153                          fconc            = *-tabld-1                              ; Concat
 16154  76b8 43d23af23dd23af2...                 !text "C",xd2,":",xfn2,"=",xd2,":",xfn2,","
 16155                          
 16156                          fapn             = *-tabld-1                              ; Append
 16157  76c1 d13af12c41                          !text xd1,":",xfn1,",A"
 16158                          
 16159                          fhed             = *-tabld-1                              ; Header
 16160  76c6 4ed13af12cd0                        !text "N",xd1,":",xfn1,",",xid
 16161                          
 16162                          fcoll            = *-tabld-1                              ; Collect
 16163  76cc 56d1                                !text "V",xd1
 16164                          
 16165                          fbak             = *-tabld-1                              ; Backup
 16166  76ce 44d23dd1                            !text "D",xd2,"=",xd1
 16167                          
 16168                          fcopy            = *-tabld-1                              ; Copy
 16169  76d2 43d23af23dd13af1                    !text "C",xd2,":",xfn2,"=",xd1,":",xfn1
 16170                          
 16171                          fren             = *-tabld-1                              ; Rename
 16172  76da 52d13af23dd13af1                    !text "R",xd1,":",xfn2,"=",xd1,":",xfn1
 16173                          
 16174                          fscr             = *-tabld-1                              ; Scratch
 16175  76e2 53d13af1                            !text "S",xd1,":",xfn1
 16176                          
 16177                          frscr            = *-tabld-1                              ; Recover Del  [901024]
 16178  76e6 462d52d13af1                        !text "F-R",xd1,":",xfn1
 16179                          
 16180                          fdisk            = *-tabld-1                              ; Disk command  [910123]
 16181  76ec f0f1                                !text xfat,xfn1                          ; pass '/' [911030]
 16182                          
 16183                          frec             = *-tabld-1                              ; Record
 16184  76ee 50c2e2e0                            !text "P",xsca,xrcl,xrec
 16185                          
 16186                          
 16187                          ;[[dos.sendparam]]
 16188                          ; Send parameters to device
 16189                          ;
 16190                          ; Entry: .a = number of bytes in format
 16191                          ;  .y = pointer to TABLD entry
 16192                          
 16193  76f2 8d8411             sendp            sta xcnt                                 ; save number of string bytes
 16194  76f5 5a                                  phy
 16195  76f6 208278                              jsr Clear_DS                             ; clear old status
 16196                          
 16197  76f9 a200                                ldx #0
 16198  76fb 68                 sdp1             pla
 16199  76fc ce8411                              dec xcnt
 16200  76ff 304d                                bmi tranr
 16201  7701 a8                                  tay
 16202  7702 c8                                  iny                                      ; move down table
 16203  7703 5a                                  phy
 16204  7704 b99876                              lda tabld,y                              ; get next entry
 16205  7707 103f                                bpl sdp5                                 ; if not escape code
 16206  7709 c9c2                                cmp #xsca                                ; if not secondary address
 16207  770b f058                                beq rsca
 16208  770d c9d0                                cmp #xid
 16209  770f f06a                                beq rid                                  ; if disk id
 16210  7711 c9e2                                cmp #xrcl
 16211  7713 f38400                              +lbeq rdcn                               ; if record number
 16212  7716 c9e1                                cmp #xwrt
 16213  7718 f06d                                beq rwrt                                 ; if W or L
 16214  771a c9f0                                cmp #xfat
 16215  771c f04c                                beq rfat                                 ; if "@" symbol request
 16216  771e c9f1                                cmp #xfn1
 16217  7720 f38100                              +lbeq rsfn                               ; if filename 1
 16218  7723 c9f2                                cmp #xfn2
 16219  7725 f39200                              +lbeq rdfn                               ; if filename 2
 16220  7728 c9e0                                cmp #xrec
 16221  772a d00a                                bne sdp2                                 ; if not record type
 16222  772c ad8b11                              lda dosrcl                               ; get rec #
 16223  772f c901                                cmp #1                                   ; kludge to allow DOPEN#lf,"relfile",L  [911024]
 16224  7731 d015                                bne sdp5                                 ; (note RECORD byte 0 = byte 1 anyhow)
 16225  7733 3a                                  dec
 16226  7734 8012                                bra sdp5                                 ; always branch
 16227                          
 16228  7736 c9d1               sdp2             cmp #xd1
 16229  7738 d005                                bne sdp3                                 ; if not drive 1
 16230  773a ad8611                              lda dosds1
 16231  773d 8007                                bra sdp4                                 ; always branch
 16232                          
 16233  773f c9d2               sdp3             cmp #xd2
 16234  7741 d0b8                                bne sdp1                                 ; if not drive 2, continue
 16235  7743 ad8811                              lda dosds2
 16236  7746 0930               sdp4             ora #'0'                                 ; change # to PETSCII
 16237                          
 16238  7748 9d0013             sdp5             sta dosstr,x                             ; else into buffer
 16239  774b e8                                  inx
 16240  774c 80ad                                bra sdp1                                 ; always
 16241                          
 16242                          
 16243  774e 8a                 tranr            txa                                      ; length to a
 16244  774f 48                                  pha
 16245  7750 a200                                ldx #<dosstr                             ; set filename
 16246  7752 a013                                ldy #>dosstr
 16247  7754 20bdff                              jsr _setnam
 16248                          
 16249  7757 ad8111                              lda dosla                                ; set channel
 16250  775a ae8211                              ldx dosfa
 16251  775d ac8311                              ldy dossa
 16252  7760 20baff                              jsr _setlfs
 16253                          
 16254  7763 68                                  pla
 16255  7764 60                                  rts
 16256                          
 16257                          
 16258                          
 16259                          
 16260  7765 ad9011             rsca             lda dossa_temp                           ; secondary address (record)
 16261  7768 80de                                bra sdp5                                 ; always
 16262                          
 16263                          
 16264  776a 7f7f04             rfat             bbr7 parsts,l240_1                       ; if "@" not encountered
 16265  776d a940                                lda #'@'
 16266  776f 80d7                                bra sdp5                                 ; always
 16267                          
 16268  7771 ad8f11             l240_1           lda dosflags
 16269  7774 4a                                  lsr
 16270  7775 9084                                bcc sdp1                                 ; if "/" not encountered
 16271  7777 a92f                                lda #'/'
 16272  7779 80cd                                bra sdp5
 16273                          
 16274                          
 16275                          ; ID subroutine
 16276                          
 16277  777b ad8d11             rid              lda dosdid                               ; include id
 16278  777e 9d0013                              sta dosstr,x
 16279  7781 e8                                  inx
 16280  7782 ad8e11                              lda dosdid+1
 16281  7785 80c1                                bra sdp5                                 ; always
 16282                          
 16283                          
 16284  7787 ad8b11             rwrt             lda dosrcl                               ; check for L or W
 16285  778a f004                                beq l241_1                               ; zero then write
 16286  778c a94c                                lda #'L'
 16287  778e 80b8                                bra sdp5                                 ; always
 16288                          
 16289  7790 a953               l241_1           lda #'S'                                 ; send W,S
 16290  7792 8d8b11                              sta dosrcl
 16291  7795 a957                                lda #'W'
 16292  7797 80af                                bra sdp5                                 ; always
 16293                          
 16294                          
 16295                          
 16296                          ; Move record number
 16297                          
 16298  7799 a516               rdcn             lda poker
 16299  779b 9d0013                              sta dosstr,x
 16300  779e a517                                lda poker+1
 16301  77a0 e8                                  inx
 16302  77a1 80a5                                bra sdp5                                 ; always
 16303                          
 16304                          
 16305                          ; Move file names
 16306                          
 16307  77a3 ac8511             rsfn             ldy dosf1l                               ; file name 1: get length
 16308  77a6 f030                                beq rdrt0                                ; if null string
 16309                          
 16310  77a8 a000                                ldy #0                                   ; move name to dosstr
 16311  77aa b99111             l242_1           lda savram,y
 16312  77ad 9d0013                              sta dosstr,x
 16313  77b0 e8                                  inx
 16314  77b1 c8                                  iny
 16315  77b2 cc8511                              cpy dosf1l
 16316  77b5 d0f3                                bne l242_1                               ; if move not complete
 16317  77b7 8020                                bra rdrt1                                ; always
 16318                          
 16319                          
 16320  77b9 ad8911             rdfn             lda dosf2a
 16321  77bc 8524                                sta index1
 16322  77be ad8a11                              lda dosf2a+1
 16323  77c1 8525                                sta index1+1
 16324  77c3 ac8711                              ldy dosf2l
 16325  77c6 f010                                beq rdrt0                                ; if null string
 16326                          
 16327  77c8 a000                                ldy #0                                   ; move name to dosstr
 16328  77ca 20d522             l243_1           jsr indin1_ram1
 16329  77cd 9d0013                              sta dosstr,x
 16330  77d0 e8                                  inx
 16331  77d1 c8                                  iny
 16332  77d2 cc8711                              cpy dosf2l
 16333  77d5 d0f3                                bne l243_1                               ; if move not complete
 16334  77d7 89                                  !text $89                                ; hop
 16335                          
 16336  77d8 ca                 rdrt0            dex                                      ; case cdd=sd
 16337  77d9 8320ff             rdrt1            +lbra sdp1                               ; get next symbol
 16338                          
 16339                          
 16340                          ; Syntax checker DOS write
 16341                          
 16342  77dc 29e6               chk1             and #$e6                                 ; for HEADER, DLOAD, SCRATCH, TYPE, LIST
 16343  77de d36ab6                              +lbne snerr
 16344                          
 16345  77e1 a57f               chk2             lda parsts                               ; for DSAVE
 16346  77e3 2901                                and #1
 16347  77e5 c901                                cmp #1                                   ; check required parameters
 16348  77e7 d361b6                              +lbne snerr                              ; error if 1 missing
 16349  77ea a57f                                lda parsts                               ; reload for return
 16350  77ec 60                                  rts
 16351                          
 16352                          
 16353  77ed 29e7               chk3             and #$e7                                 ; for COLLECT
 16354  77ef d359b6                              +lbne snerr                              ; check optional parameters
 16355  77f2 60                                  rts
 16356                          
 16357                          
 16358  77f3 29c4               chk4             and #$c4                                 ; for COPY, CONCAT
 16359  77f5 d353b6                              +lbne snerr                              ; check optional parameters
 16360  77f8 a57f                                lda parsts
 16361  77fa 2903               chk5             and #3                                   ; for RENAME
 16362  77fc c903                                cmp #3                                   ; check required parameters
 16363  77fe d34ab6                              +lbne snerr
 16364  7801 a57f                                lda parsts                               ; reload for return
 16365  7803 60                                  rts
 16366                          
 16367                          
 16368  7804 2905               chk6             and #5                                   ; for APPEND, DOPEN
 16369  7806 c905                                cmp #5                                   ; check required parameters
 16370  7808 d340b6                              +lbne snerr
 16371  780b a57f                                lda parsts                               ; reload for rts
 16372  780d 60                                  rts
 16373                          
 16374                          ;.end
 16375                          
 16376                          
 16377                          
 16378                          ; Allocate DS$ if nesessary, but use old DS$ string otherwise
 16379                          ; Called by DS$ and DS
 16380                          
 16381                          Check_DS                                                  ; chkds.
 16382  780e a579                                lda dsdesc
 16383  7810 f005                                beq Read_DS_1                            ; branch if DS$ is not in memory
 16384  7812 60                                  rts                                      ; else return & use old one
 16385                          
 16386                          
 16387                          ; Allocate DS$ if necessary & Read DOS error channel
 16388                          
 16389                          Read_DS                                                   ; errchl.
 16390  7813 a579                                lda dsdesc                               ; has DS$ space been allocated?
 16391  7815 d01a                                bne Read_DS_2                            ; yes
 16392                          
 16393                          Read_DS_1
 16394  7817 a928                                lda #40                                  ; no- get 40 char string
 16395  7819 8579                                sta dsdesc
 16396  781b 20dd5b                              jsr getspa                               ; allocate space for DS$
 16397  781e 867a                                stx dsdesc+1                             ; low address of string
 16398  7820 847b                                sty dsdesc+2                             ; high   "    "    "
 16399  7822 a27a                                ldx #dsdesc+1                            ; set up string back pointer to dsdesc
 16400  7824 a028                                ldy #40
 16401  7826 a979                                lda #<dsdesc
 16402  7828 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y
 16403  782b c8                                  iny
 16404  782c a900                                lda #>dsdesc
 16405  782e 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y
 16406                          
 16407                          Read_DS_2
 16408  7831 ae8211                              ldx dosfa                                ; fa
 16409  7834 e002                                cpx #2
 16410  7836 b006                                bcs l244_1                               ; if =0 or 1 use default  [910429]
 16411  7838 ae0611                              ldx _default_drive                       ; (was dosffn)   [900710]
 16412  783b 8e8211                              stx dosfa
 16413  783e a900               l244_1           lda #doslfn                              ; la (reserved la)
 16414  7840 a06f                                ldy #$6f                                 ; sa (command channel)
 16415  7842 20baff                              jsr _setlfs
 16416  7845 a900                                lda #0                                   ; no name (so no setbank)
 16417  7847 20bdff                              jsr _setnam
 16418  784a 20c0ff                              jsr _open                                ; get command channel
 16419  784d a200                                ldx #doslfn
 16420  784f 20c6ff                              jsr _chkin
 16421  7852 b023                                bcs l244_4                               ; a problem (file already open??)
 16422                          
 16423  7854 a0ff                                ldy #$ff
 16424  7856 c8                 l244_2           iny                                      ; read disk error message
 16425  7857 20cfff                              jsr _basin
 16426  785a c90d                                cmp #cr
 16427  785c f009                                beq l244_3                               ; if eol
 16428  785e a27a                                ldx #dsdesc+1
 16429  7860 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y copy to DS$
 16430  7863 c028                                cpy #40
 16431  7865 90ef                                bcc l244_2                               ; loop unless too long
 16432                          
 16433  7867 a900               l244_3           lda #0                                   ; errend.
 16434  7869 a27a                                ldx #dsdesc+1                            ; terminate DS$ with a null
 16435  786b 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y
 16436                          
 16437  786e 20ccff                              jsr _clrch                               ; shut down command channel
 16438  7871 a900                                lda #doslfn
 16439  7873 38                                  sec                                      ; not a real close
 16440  7874 4cc3ff                              jmp _close                               ; close it and rts
 16441                          
 16442  7877 48                 l244_4           pha                                      ; errbad.
 16443  7878 206778                              jsr l244_3
 16444  787b 208278                              jsr Clear_DS                             ; flag 'no DS available'
 16445  787e fa                                  plx                                      ; get error
 16446  787f 83ceb5                              +lbra error
 16447                          
 16448                          
 16449                          ; Clear_DS subroutine - forget current DS$ message, if any
 16450                          ;
 16451                          
 16452                          Clear_DS                                                  ; oldclr.
 16453  7882 a579                                lda dsdesc                               ; check for allocation
 16454  7884 f013                                beq l245_1                               ; branch if not allocated
 16455                          
 16456  7886 5a                                  phy                                      ; mark current DS$ string as garbage
 16457  7887 da                                  phx
 16458                          ; lda #40   ;   standard DS$ allocation
 16459  7888 a8                                  tay
 16460  7889 a27a                                ldx #dsdesc+1
 16461  788b 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y length of garbage
 16462  788e c8                                  iny
 16463  788f a9ff                                lda #$ff
 16464  7891 20f022                              jsr sta_far_ram1                         ; sta (dsdesc+1),y garbage flagged
 16465  7894 1a                                  inc
 16466  7895 8579                                sta dsdesc                               ; (0)    kill DS$
 16467  7897 fa                                  plx
 16468  7898 7a                                  ply
 16469                          
 16470  7899 60                 l245_1           rts
 16471                          
 16472                          
 16473                          ; Read DOS error message, but don't care what it is.  Want to stop disk LED blink.
 16474                          ;
 16475                          
 16476                          Suck_DS
 16477  789a ae8211                              ldx dosfa                                ; fa
 16478  789d a900                                lda #doslfn                              ; la (reserved la)
 16479  789f a06f                                ldy #$6f                                 ; sa (command channel)
 16480  78a1 20baff                              jsr _setlfs
 16481  78a4 a900                                lda #0                                   ; no name (so no setbank)
 16482  78a6 20bdff                              jsr _setnam
 16483  78a9 20c0ff                              jsr _open                                ; get command channel
 16484  78ac a200                                ldx #doslfn
 16485  78ae 20c6ff                              jsr _chkin
 16486  78b1 b007                                bcs l246_2                               ; skip input if problem
 16487                          
 16488  78b3 20cfff             l246_1           jsr _basin                               ; read disk error message
 16489  78b6 c90d                                cmp #cr
 16490  78b8 d0f9                                bne l246_1                               ; loop until eol
 16491                          
 16492  78ba 20ccff             l246_2           jsr _clrch                               ; shut down command channel
 16493  78bd a900                                lda #doslfn
 16494  78bf 38                                  sec                                      ; not a real close
 16495  78c0 4cc3ff                              jmp _close                               ; close it
 16496                          
 16497                          
 16498                          ; R-U-sure subroutine
 16499                          
 16500                          are_you_sure
 16501                          
 16502  78c3 ff7e29                              bbs7 runmod,response_fake                ; branch if not direct mode
 16503                          
 16504  78c6 207dff                              jsr _primm                               ; else prompt user for y/n answer
 16505  78c9 41524520594f5520...                 !text "ARE YOU SURE? ", 0
 16506                          
 16507                          
 16508                          response_get
 16509  78d8 20ccff                              jsr _clrch                               ; clear channel for basin
 16510  78db 20cfff                              jsr _basin                               ; next char
 16511  78de 48                                  pha                                      ; save first char of reply
 16512                          
 16513  78df c90d               l247_1           cmp #cr                                  ; eat chars until end of line
 16514  78e1 f005                                beq l247_2                               ; if cr received, exit
 16515  78e3 20cfff                              jsr _basin
 16516  78e6 d0f7                                bne l247_1                               ; continue to ignore
 16517                          
 16518  78e8 20d2ff             l247_2           jsr _bsout                               ; new line     [910212] FAB
 16519  78eb 68                                  pla
 16520  78ec c959                                cmp #'Y'                                 ; z set means ans=y.....
 16521  78ee 60                                  rts
 16522                          
 16523                          
 16524                          response_fake
 16525  78ef a900                                lda #0                                   ; ...or not in direct mode
 16526  78f1 60                                  rts
 16527                          
 16528                          ;.end
 16529                          
 16530                          
 16531                          
 16532                          ;*****************************************************************
 16533                          ;  OPTWRD - get an optional, unsigned 2-byte value in y,a.
 16534                          ;
 16535                          ;      case 1 : pointer at end of line:
 16536                          ;   return a=y=0, clear c to flag 'default'
 16537                          ;      case 2 : pointer is at comma, next non-blank is also a comma:
 16538                          ;   return a=y=0, clear c to flag 'default'
 16539                          ;      case 3 : pointer is at comma, next non-blank is not a comma:
 16540                          ;   get word in y,a, set c to flag 'non-default'
 16541                          ;*****************************************************************
 16542                          
 16543  78f2 208522             optwrd           jsr chrgot
 16544  78f5 f00c                                beq l248_1
 16545  78f7 205b4e                              jsr chkcom
 16546  78fa c92c                                cmp #','
 16547  78fc f005                                beq l248_1
 16548  78fe 208a5d                              jsr getwrd
 16549  7901 38                                  sec
 16550  7902 60                                  rts
 16551                          
 16552  7903 a900               l248_1           lda #0
 16553  7905 a8                                  tay
 16554                          
 16555  7906 18                 optw99           clc
 16556  7907 60                                  rts
 16557                          
 16558                          
 16559  7908 205b4e             comsad           jsr chkcom                               ; get a comma & signed 2-byte arg in y,a   [910307]
 16560  790b 83d83e                              +lbra sadwrd
 16561                          
 16562                          
 16563                          
 16564  790e 208522             optsad           jsr chrgot                               ; get a comma & optional, signed 2-byte arg in y,a [910307]
 16565  7911 f00c                                beq l249_1                               ; eol, therefore this arg is not specified
 16566  7913 205b4e                              jsr chkcom                               ; eat comma
 16567  7916 c92c                                cmp #','                                 ; is next a comma too?
 16568  7918 f005                                beq l249_1                               ; yes, therefore this arg is not specified
 16569  791a 20e5b7                              jsr sadwrd                               ; get signed word
 16570  791d 38                                  sec
 16571  791e 60                                  rts
 16572                          
 16573  791f a900               l249_1           lda #0                                   ; default optional arg to zero
 16574  7921 a8                                  tay
 16575  7922 18                                  clc
 16576  7923 60                                  rts
 16577                          
 16578                          
 16579                          ;*****************************************************************
 16580                          ;  OPTBYT - get an optional 1 byte value in x.
 16581                          ;
 16582                          ;  Enter with default value in x.
 16583                          ;
 16584                          ;      case 1 : pointer at end of line:
 16585                          ;   return default x.
 16586                          ;      case 2 : pointer is at comma, next non-blank is also a comma:
 16587                          ;   return default x.
 16588                          ;      case 3 : pointer is at comma, next non-blank is not a comma:
 16589                          ;   get byte in x.
 16590                          ;*****************************************************************
 16591                          
 16592  7924 a200               optzer           ldx #0                                   ; optional byte, with default=0
 16593                          
 16594  7926 208522             optbyt           jsr chrgot
 16595  7929 f0db                                beq optw99                               ; EOL: clc/rts
 16596  792b 205b4e                              jsr chkcom
 16597  792e c92c                                cmp #','
 16598  7930 f0d4                                beq optw99                               ; Comma: clc/rts
 16599  7932 206c5d                              jsr getbyt
 16600  7935 38                                  sec
 16601  7936 60                                  rts
 16602                          
 16603                          
 16604                          prtdec
 16605  7937 5a                                  phy
 16606  7938 da                                  phx
 16607  7939 aa                                  tax                                      ; prints decimal value of chr in .a
 16608  793a a900                                lda #0
 16609  793c 207f64                              jsr linprt
 16610  793f fa                                  plx
 16611  7940 7a                                  ply
 16612  7941 60                                  rts
 16613                          
 16614                          
 16615                          
 16616                          retpat                                                    ; f.bowen
 16617  7942 88                                  dey                                      ; [910828]
 16618  7943 b13f                                lda (fndpnt),y                           ; restore pointers
 16619  7945 853e                                sta txtptr+1
 16620  7947 88                                  dey
 16621  7948 b13f                                lda (fndpnt),y
 16622  794a 853d                                sta txtptr
 16623  794c 88                                  dey
 16624  794d b13f                                lda (fndpnt),y
 16625                          
 16626  794f 853c                                sta curlin+1                             ; fixes a problem when RETURNing to a GOSUB in direct mode
 16627  7951 88                                  dey                                      ; or LOOPing to a DO in direct mode. 'curlin+1' must not be
 16628  7952 aa                                  tax                                      ; restored to $ff without also resetting 'runmod'
 16629  7953 e8                                  inx
 16630  7954 d004                                bne l250_1                               ; branch if GOSUB or DO was from a program
 16631  7956 a9c0                                lda #%11000000
 16632  7958 147e                                trb runmod                               ; else force return to direct mode
 16633                          
 16634  795a b13f               l250_1           lda (fndpnt),y
 16635  795c 853b                                sta curlin
 16636  795e 60                                  rts
 16637                          
 16638                          
 16639  795f 010204010204       vbits            !text $01,$02,$04,$01,$02,$04            ; for stereo filter, volume bit setting
 16640  7965 0102040810204080   sbits            !text $01,$02,$04,$08,$10,$20,$40,$80
 16641  796d 8040201008040201   rbits            !text $80,$40,$20,$10,$08,$04,$02,$01
 16642                          
 16643                          ;.end
 16644                          ;[[handler.irq]]
 16645                          
 16646                          
 16647                          
 16648                          basic_irq
 16649                          ; lda _vicIRQ  ;a VIC raster interrupt?
 16650                          ; and #%10000001  ; (used to update moving sprites & sound stuff)
 16651                          ; cmp #%10000001
 16652                          ; bne collision_irq ; no, go check other VIC interrupts
 16653                          
 16654  7975 addb02                              lda irq_wrap_flag                        ; filter out wrapped IRQ calls (allows interruptable code)
 16655  7978 f001                                beq l251_1                               ; it's ok
 16656  797a 60                                  rts                                      ; exit- we're already handling one interrupt
 16657                          
 16658  797b eedb02             l251_1           inc irq_wrap_flag                        ; shut the door
 16659  797e 58                                  cli                                      ; but leave the window open
 16660                          
 16661                          
 16662                          ; Test if there was a VIC collision/light pen interrupt
 16663                          
 16664                          collision_irq
 16665                          ; sei
 16666  797f a5a0                                lda _vicIRQ                              ; check VIC IRQ flags
 16667  7981 290e                                and #%00001110                           ; mask all but lp, s/s, and s/bgnd flags
 16668  7983 f04c                                beq l252_5                               ; exit if none set
 16669  7985 14a0                                trb _vicIRQ                              ; else reset flags we're going to handle
 16670  7987 4a                                  lsr                                      ; shift out raster interrupt bit (not used)
 16671                          
 16672                          ; Test for 3 types of collision interrupts : sprite/sprite, sprite/bgnd, & light pen
 16673                          
 16674  7988 a001                                ldy #1                                   ; loop for sprite/bgnd and sprite/sprite collision check
 16675  798a 4a                 l252_1           lsr
 16676  798b 901b                                bcc l252_4                               ; bit not set ==> not source of interrupt
 16677                          
 16678  798d 48                                  pha
 16679  798e b91ed0                              lda vic+30,y                             ; accumulate collision data (resets register)
 16680  7991 19e602                              ora collisions,y
 16681  7994 99e602                              sta collisions,y
 16682                          
 16683  7997 addc02                              lda intval                               ; allowable interrupts
 16684  799a c000                                cpy #0                                   ; examine selected bit
 16685  799c f001                                beq l252_2
 16686  799e 4a                                  lsr
 16687  799f 4a                 l252_2           lsr
 16688  79a0 9005                                bcc l252_3                               ; BASIC doesn't want this interrupt
 16689  79a2 a9ff                                lda #$ff
 16690  79a4 99dd02                              sta int_trip_flag,y                      ; turn on trip flag
 16691                          
 16692  79a7 68                 l252_3           pla
 16693                          
 16694  79a8 88                 l252_4           dey
 16695  79a9 10df                                bpl l252_1
 16696                          
 16697                          
 16698                          ; Check light pen latch
 16699                          
 16700  79ab 4a                                  lsr
 16701  79ac 9023                                bcc l252_5                               ; LightPen latch not valid
 16702                          
 16703  79ae ae31d0                              ldx vic+49                               ; 4567R7 bug- must read LP_latches in Slow mode????
 16704  79b1 a940                                lda #%01000000                           ; [910618]
 16705  79b3 1c31d0                              trb vic+49
 16706  79b6 ac13d0                              ldy vic+19                               ; save latched x position
 16707  79b9 8ce802                              sty lightpen_xpos
 16708  79bc ac14d0                              ldy vic+20                               ; save latched y position
 16709  79bf 8ce902                              sty lightpen_ypos
 16710  79c2 8e31d0                              stx vic+49                               ; restore speed     [910618]
 16711                          
 16712  79c5 addc02                              lda intval                               ; is BASIC interested in our little find?
 16713  79c8 2904                                and #4
 16714  79ca f005                                beq l252_5                               ; no, move on to next IRQ task
 16715  79cc a9ff                                lda #$ff
 16716  79ce 8ddf02                              sta int_trip_flag+2                      ; yes- let BASIC know we caught one
 16717                          
 16718                          l252_5
 16719                          
 16720                          ; Update moving sprites
 16721                          
 16722                          movspr_irq
 16723  79d1 ad15d0                              lda vic+21                               ; any sprites active?    [910212]
 16724  79d4 f3f100                              +lbeq music_irq                          ; no- skip ahead
 16725                          
 16726  79d7 a007                                ldy #7                                   ; check each of 8 sprites
 16727  79d9 ad15d0             l253_1           lda vic+21                               ; is this sprite is enabled?
 16728  79dc 396579                              and sbits,y
 16729  79df f03d                                beq l253_5                               ; sprite not enabled
 16730                          
 16731  79e1 befeb7                              ldx sproff,y                             ; get offset to sprite info from a table
 16732  79e4 bd0512                              lda sprite_data,x                        ; is this sprite moving (speed >0 )?
 16733  79e7 f035                                beq l253_5                               ; sprite not moving
 16734  79e9 1005                                bpl l253_2                               ; sprite moving, no destination
 16735  79eb 633700                              bsr movspr_to_irq                        ; sprite moving to a destination [910809]
 16736  79ee 802e                                bra l253_5
 16737                          
 16738  79f0 9d0612             l253_2           sta sprite_data+1,x                      ; set counter
 16739  79f3 98                 l253_3           tya                                      ; convert sprite# to a VIC register pointer
 16740  79f4 0a                                  asl
 16741  79f5 a8                                  tay
 16742  79f6 bd0712                              lda sprite_data+2,x                      ; get angle sign
 16743  79f9 3a                                  dec                                      ; subtract 1 for cosine
 16744  79fa e8                                  inx
 16745  79fb e8                                  inx
 16746  79fc c8                                  iny
 16747  79fd 20c67b                              jsr sprsub                               ; update y position
 16748  7a00 ca                                  dex
 16749  7a01 ca                                  dex
 16750  7a02 88                                  dey
 16751  7a03 bd0712                              lda sprite_data+2,x
 16752  7a06 20c67b                              jsr sprsub                               ; update x position
 16753  7a09 08                                  php
 16754  7a0a 98                                  tya
 16755  7a0b 4a                                  lsr                                      ; restore index (.Y=sprite pointer)
 16756  7a0c a8                                  tay
 16757  7a0d 28                                  plp
 16758  7a0e 9009                                bcc l253_4                               ; skip if no overflow
 16759  7a10 ad10d0                              lda vic+16                               ; get x position msb bits ???vic_save
 16760  7a13 596579                              eor sbits,y                              ; invert bit
 16761  7a16 8d10d0                              sta vic+16                               ; ???vic_save
 16762  7a19 de0612             l253_4           dec sprite_data+1,x
 16763  7a1c d0d5                                bne l253_3                               ; loop until counter done
 16764                          
 16765  7a1e 88                 l253_5           dey                                      ; check next sprite
 16766  7a1f 10b8                                bpl l253_1                               ; loop until done moving all sprites
 16767  7a21 83a400                              +lbra music_irq                          ; then continue with next IRQ task
 16768                          
 16769                          movspr_to_irq                                             ; [910809]
 16770  7a24 5a                                  phy                                      ; sprite #
 16771  7a25 293f                                and #$3f                                 ; speed factor
 16772  7a27 4b                                  taz
 16773  7a28 98                                  tya                                      ; vic sprite index
 16774  7a29 0a                                  asl
 16775  7a2a a8                                  tay
 16776                          
 16777  7a2b 38                 l254_1           sec                                      ; for i = 1 to abs(greatr)
 16778  7a2c bd0612                              lda sprite_data+1,x
 16779  7a2f e901                                sbc #1
 16780  7a31 9d0612                              sta sprite_data+1,x
 16781  7a34 b011                                bcs l254_2
 16782  7a36 bd0712                              lda sprite_data+2,x
 16783  7a39 e900                                sbc #0
 16784  7a3b 9d0712                              sta sprite_data+2,x
 16785  7a3e b007                                bcs l254_2
 16786  7a40 a900                                lda #0
 16787  7a42 9d0512                              sta sprite_data,x                        ; done!  sprite is at its destination
 16788  7a45 7a                                  ply                                      ; remember sprite #
 16789  7a46 60                                  rts
 16790                          
 16791  7a47 bd0812             l254_2           lda sprite_data+3,x                      ; ptr(lesser)
 16792  7a4a 3c0f12                              bit sprite_data+10,x
 16793  7a4d 3009                                bmi l254_3                               ; if e > 0
 16794  7a4f 3c0812                              bit sprite_data+3,x                      ; sgn(lesser) (b7=1=neg, b6=1=pos, else 0)
 16795  7a52 20907a                              jsr drwinc                               ; pos(lesser) = pos(lesser) + sgn(lesser)
 16796                          
 16797  7a55 bd0912                              lda sprite_data+4,x                      ; ptr(greater)
 16798  7a58 4a                 l254_3           lsr                                      ; which f?
 16799  7a59 b014                                bcs l254_4
 16800  7a5b bd0e12                              lda sprite_data+9,x                      ; e = e + f1
 16801  7a5e 7d0a12                              adc sprite_data+5,x
 16802  7a61 9d0e12                              sta sprite_data+9,x
 16803  7a64 bd0f12                              lda sprite_data+10,x
 16804  7a67 7d0b12                              adc sprite_data+6,x
 16805  7a6a 9d0f12                              sta sprite_data+10,x
 16806  7a6d 8013                                bra l254_5
 16807                          
 16808  7a6f 18                 l254_4           clc
 16809  7a70 bd0e12                              lda sprite_data+9,x                      ; e = e + f2
 16810  7a73 7d0c12                              adc sprite_data+7,x
 16811  7a76 9d0e12                              sta sprite_data+9,x
 16812  7a79 bd0f12                              lda sprite_data+10,x
 16813  7a7c 7d0d12                              adc sprite_data+8,x
 16814  7a7f 9d0f12                              sta sprite_data+10,x
 16815                          
 16816  7a82 bd0912             l254_5           lda sprite_data+4,x                      ; ptr(greater)
 16817  7a85 3c0912                              bit sprite_data+4,x                      ; sgn(greater) (b7=1=neg, b6=1=pos, else 0)
 16818  7a88 20907a                              jsr drwinc                               ; pos(greater) = pos(greater) + sgn(greater)
 16819                          
 16820  7a8b 3b                                  dez                                      ; count
 16821  7a8c d09d                                bne l254_1
 16822  7a8e 7a                                  ply                                      ; remember sprite #
 16823  7a8f 60                                  rts                                      ; done this frame
 16824                          
 16825                          
 16826  7a90 08                 drwinc           php
 16827  7a91 2901                                and #1                                   ; adjust .y for x or y position
 16828  7a93 f001                                beq l255_1                               ; 0=x
 16829  7a95 c8                                  iny                                      ; 1=y
 16830  7a96 28                 l255_1           plp
 16831  7a97 300b                                bmi l255_2                               ; enter with b7=negative, b6=positive, else zero
 16832  7a99 5027                                bvc l255_4
 16833                          
 16834  7a9b b900d0                              lda vic,y                                ; positive direction
 16835  7a9e 1a                                  inc
 16836  7a9f 9900d0                              sta vic,y
 16837  7aa2 8009                                bra l255_3
 16838                          
 16839  7aa4 b900d0             l255_2           lda vic,y                                ; negative direction
 16840  7aa7 3a                                  dec
 16841  7aa8 9900d0                              sta vic,y
 16842  7aab c9ff                                cmp #$ff
 16843                          
 16844  7aad d013               l255_3           bne l255_4                               ; no wrap
 16845  7aaf 98                                  tya
 16846  7ab0 8901                                bit #1
 16847  7ab2 d00e                                bne l255_4                               ; wrap in y okay
 16848  7ab4 4a                                  lsr
 16849  7ab5 a8                                  tay
 16850  7ab6 b96579                              lda sbits,y                              ; wrap in x- toggle msb
 16851  7ab9 4d10d0                              eor vic+16
 16852  7abc 8d10d0                              sta vic+16
 16853  7abf 98                                  tya
 16854  7ac0 0a                                  asl
 16855  7ac1 a8                                  tay
 16856                          
 16857  7ac2 98                 l255_4           tya                                      ; restore y to sprite offset
 16858  7ac3 29fe                                and #$fe
 16859  7ac5 a8                                  tay
 16860  7ac6 60                                  rts
 16861                          
 16862                          
 16863                          ; Play music, if in progress
 16864                          
 16865                          music_irq
 16866  7ac7 a200                                ldx #0
 16867  7ac9 bc5e12             l256_1           ldy voices+1,x
 16868  7acc 3025                                bmi l256_2                               ; skip if not active
 16869                          
 16870  7ace bd5d12                              lda voices,x
 16871  7ad1 38                                  sec
 16872  7ad2 ed7312                              sbc tempo_rate                           ; decrement current value by current tempo
 16873  7ad5 9d5d12                              sta voices,x
 16874  7ad8 b019                                bcs l256_2
 16875  7ada 98                                  tya                                      ; lda voices+1,x
 16876  7adb e900                                sbc #0
 16877  7add 9d5e12                              sta voices+1,x
 16878  7ae0 b011                                bcs l256_2                               ; ok, no underflow
 16879                          
 16880  7ae2 8a                                  txa
 16881  7ae3 4a                                  lsr                                      ; get offset to waveform
 16882  7ae4 a8                                  tay
 16883  7ae5 b96912                              lda waveform,y                           ; get waveform
 16884  7ae8 29fe                                and #$fe                                 ; mask out gate bit
 16885  7aea 48                                  pha
 16886  7aeb b9004a                              lda SID_offset,y                         ; get offset to correct oscillator
 16887  7aee a8                                  tay
 16888  7aef 68                                  pla
 16889                          ; jsr go_slow  ;      [910716] 4567R7A
 16890  7af0 9904d4                              sta sid1+4,y                             ; turn off sound
 16891                          ; jsr go_fast  ;      [910716] 4567R7A
 16892                          
 16893  7af3 e8                 l256_2           inx
 16894  7af4 e8                                  inx
 16895  7af5 e00c                                cpx #6+6                                 ; [910612]
 16896  7af7 90d0                                bcc l256_1                               ; loop for 6 voices
 16897                          ;then continue with next IRQ task
 16898                          
 16899                          ; Test if SOUND command wants anything
 16900                          
 16901                          sound_irq
 16902  7af9 a005                                ldy #6-1                                 ; test six voices    [910612]
 16903  7afb b9c412             l257_1           lda sound_time_hi,y                      ; active if msb clear
 16904  7afe 1006                                bpl l257_3
 16905  7b00 88                 l257_2           dey
 16906  7b01 10f8                                bpl l257_1
 16907  7b03 83bc00                              +lbra basic_irq_end
 16908                          
 16909  7b06 18                 l257_3           clc                                      ; add step to frequency
 16910  7b07 b9f412                              lda sound_freq_lo,y
 16911  7b0a 79e812                              adc sound_step_lo,y
 16912  7b0d 99f412                              sta sound_freq_lo,y
 16913  7b10 b9fa12                              lda sound_freq_hi,y
 16914  7b13 79ee12                              adc sound_step_hi,y
 16915  7b16 99fa12                              sta sound_freq_hi,y
 16916                          
 16917  7b19 b9e212                              lda sound_direction,y                    ; test if this is up or down
 16918  7b1c aa                                  tax
 16919  7b1d 2901                                and #1
 16920  7b1f f02d                                beq l257_6                               ; branch if up
 16921                          
 16922                          ; If step direction is down, .C==0 OR freq < min  ==> reset value
 16923                          
 16924  7b21 900f                                bcc l257_4                               ; underflow, reset
 16925  7b23 38                                  sec
 16926  7b24 b9f412                              lda sound_freq_lo,y
 16927  7b27 f9d612                              sbc sound_min_lo,y
 16928  7b2a b9fa12                              lda sound_freq_hi,y
 16929  7b2d f9dc12                              sbc sound_min_hi,y
 16930  7b30 b04c                                bcs l257_9                               ; no borrow, don't reset
 16931                          
 16932  7b32 e002               l257_4           cpx #2                                   ; is 'cycle' bit set?
 16933  7b34 900a                                bcc l257_5                               ; no, keep direction 'down'
 16934                          
 16935  7b36 20ab7b                              jsr negate_step                          ; make step 2's comp
 16936  7b39 a902                                lda #2                                   ; change direction to 'up'
 16937  7b3b 99e212                              sta sound_direction,y
 16938  7b3e d032                                bne l257_8                               ; go reset for 'up'
 16939                          
 16940  7b40 b9ca12             l257_5           lda sound_max_lo,y                       ; reset to max
 16941  7b43 99f412                              sta sound_freq_lo,y
 16942  7b46 b9d012                              lda sound_max_hi,y
 16943  7b49 99fa12                              sta sound_freq_hi,y
 16944  7b4c 8030                                bra l257_9                               ; go update SID frequency
 16945                          
 16946                          ; If step direction is up, overflow (.C==1) OR freq > max ==> reset frequency
 16947                          
 16948  7b4e b014               l257_6           bcs l257_7                               ; overflow, must reset
 16949  7b50 b9fa12                              lda sound_freq_hi,y                      ; 16 bit compare (yech!)
 16950  7b53 d9d012                              cmp sound_max_hi,y
 16951  7b56 9026                                bcc l257_9                               ; freq < max, no reset
 16952  7b58 d00a                                bne l257_7                               ; freq > max, reset
 16953  7b5a b9f412                              lda sound_freq_lo,y                      ; msb's the same, test lsb's
 16954  7b5d d9ca12                              cmp sound_max_lo,y
 16955  7b60 901c                                bcc l257_9                               ; freq < max, no reset
 16956  7b62 f01a                                beq l257_9                               ; freq = max, no reset
 16957                          
 16958  7b64 e002               l257_7           cpx #2                                   ; is this 'cycle'?
 16959  7b66 900a                                bcc l257_8                               ; no, go reset for next 'up'
 16960                          
 16961  7b68 20ab7b                              jsr negate_step                          ; make step 2's comp
 16962  7b6b a903                                lda #3                                   ; change direction to 'down'
 16963  7b6d 99e212                              sta sound_direction,y
 16964  7b70 d0ce                                bne l257_5                               ; go reset for next 'down'
 16965                          
 16966  7b72 b9d612             l257_8           lda sound_min_lo,y                       ; set freq to minimum value
 16967  7b75 99f412                              sta sound_freq_lo,y
 16968  7b78 b9dc12                              lda sound_min_hi,y
 16969  7b7b 99fa12                              sta sound_freq_hi,y
 16970                          
 16971                          ; Update SID frequency registers
 16972                          
 16973                          l257_9
 16974                          ; jsr go_slow  ;      [910716] 4567R7A
 16975  7b7e be004a                              ldx SID_offset,y                         ; get index to SID voices
 16976  7b81 b9f412                              lda sound_freq_lo,y
 16977  7b84 9d00d4                              sta sid1,x
 16978  7b87 b9fa12                              lda sound_freq_hi,y
 16979  7b8a 9d01d4                              sta sid1+1,x
 16980                          ; jsr go_fast  ;      [910716] 4567R7A
 16981                          
 16982                          ; Decrement total time - see if it's time to bring down the curtain
 16983                          
 16984  7b8d 98                                  tya
 16985  7b8e aa                                  tax
 16986  7b8f bdbe12                              lda sound_time_lo,x                      ; 16 bit decrement - not very pretty
 16987  7b92 d003                                bne l257_10
 16988  7b94 dec412                              dec sound_time_hi,x
 16989  7b97 debe12             l257_10          dec sound_time_lo,x
 16990                          
 16991  7b9a bdc412                              lda sound_time_hi,x                      ; underflow?
 16992  7b9d 1361ff                              +lbpl l257_2                             ; nope
 16993                          
 16994                          ; Time to turn off this voice
 16995                          
 16996                          ; jsr go_slow  ;      [910716] 4567R7A
 16997  7ba0 a908                                lda #$08
 16998  7ba2 be004a                              ldx SID_offset,y
 16999  7ba5 9d04d4                              sta sid1+4,x
 17000                          ; jsr go_fast  ;      [910716] 4567R7A
 17001  7ba8 8356ff                              +lbra l257_2
 17002                          
 17003                          
 17004                          negate_step
 17005  7bab b9e812                              lda sound_step_lo,y
 17006  7bae 49ff                                eor #$ff
 17007  7bb0 18                                  clc
 17008  7bb1 6901                                adc #1
 17009  7bb3 99e812                              sta sound_step_lo,y
 17010  7bb6 b9ee12                              lda sound_step_hi,y
 17011  7bb9 49ff                                eor #$ff
 17012  7bbb 6900                                adc #0
 17013  7bbd 99ee12                              sta sound_step_hi,y
 17014  7bc0 60                                  rts
 17015                          
 17016                          
 17017                          
 17018                          ; Here is where BASIC_IRQ exits
 17019                          
 17020                          basic_irq_end
 17021  7bc1 cedb02                              dec irq_wrap_flag                        ; open the door to IRQ
 17022  7bc4 58                                  cli
 17023  7bc5 60                                  rts
 17024                          
 17025                          
 17026                          ; Update sprite position subroutine
 17027                          
 17028  7bc6 48                 sprsub           pha                                      ; save angle phase
 17029  7bc7 18                                  clc
 17030  7bc8 bd0812                              lda sprite_data+3,x                      ; add low bytes
 17031  7bcb 7d0c12                              adc sprite_data+7,x
 17032  7bce 9d0c12                              sta sprite_data+7,x
 17033  7bd1 bd0912                              lda sprite_data+4,x                      ; add high bytes
 17034  7bd4 7d0d12                              adc sprite_data+8,x
 17035  7bd7 9d0d12                              sta sprite_data+8,x
 17036  7bda 68                                  pla                                      ; get angle sign
 17037  7bdb 9012                                bcc l258_3                               ; skip if no carry - do not update position
 17038  7bdd 4a                                  lsr
 17039  7bde 4a                                  lsr                                      ; test if positive or negative
 17040  7bdf b900d0                              lda vic,y                                ; ???vic_save
 17041  7be2 b004                                bcs l258_1                               ; skip if negative
 17042  7be4 6901                                adc #1                                   ; increment position
 17043  7be6 8004                                bra l258_2
 17044                          
 17045  7be8 e901               l258_1           sbc #1                                   ; decrement position
 17046  7bea c9ff                                cmp #$ff                                 ; set carry if underflow
 17047  7bec 9900d0             l258_2           sta vic,y                                ; decrement position  ???vic_save
 17048  7bef 60                 l258_3           rts
 17049                          
 17050                          ;.end
 17051                          ;[[command.mouse]]
 17052                          
 17053                          
 17054                          
 17055                          ;***********************************************************************
 17056                          ;*   MOUSE  ON  [,[port] [,[sprite] [,[hotspot] [,X/Yposition] ]]]
 17057                          ;*   MOUSE  OFF
 17058                          ;*    where: port     = (1...3) for joyport 1, 2, or either (both)
 17059                          ;*  sprite   = (0...7) sprite pointer
 17060                          ;*  hotspot  = x,y offset in sprite, default 0,0
 17061                          ;*  position = normal, relative, or angluar coordinates
 17062                          ;*
 17063                          ;*      (defaults to sprite 0, port 2, last hotspot & position)
 17064                          ;***********************************************************************
 17065                          
 17066  7bf0 c991               mouse            cmp #on_token                            ; new [910122]
 17067  7bf2 f010                                beq l259_1
 17068  7bf4 2016b5                              jsr chkesc
 17069  7bf7 c924                                cmp #off_token
 17070  7bf9 d34fb2                              +lbne snerr
 17071                          
 17072                          ;    The Kernel MOUSE_CMD is called to install or remove mouse driver.
 17073                          ; .a= B7,6 set to install mouse in game port 2 ($80), 1 ($40), or both ($C0)
 17074                          ; .a= 0 to disable mouse driver
 17075                          ; .x= 0-7 physical sprite pointer
 17076                          
 17077  7bfc a900                                lda #0                                   ; TURN MOUSE OFF
 17078  7bfe 201be0                              jsr _mouse                               ; do it
 17079  7c01 831f39                              +lbra chkeos                             ; eat token & exit after checking for eos
 17080                          
 17081                          ;TURN MOUSE ON
 17082  7c04 208322             l259_1           jsr chrget                               ; eat token
 17083  7c07 a202                                ldx #2                                   ; get (optional) port# in .X
 17084  7c09 202679                              jsr optbyt                               ; if not present default to port 2
 17085  7c0c e004                                cpx #4                                   ;
 17086  7c0e b3eed5                              +lbcs fcerr                              ; illegal value
 17087  7c11 da                                  phx
 17088                          
 17089  7c12 a200                                ldx #0                                   ; get (optional) sprite# in .X
 17090  7c14 202679                              jsr optbyt                               ; if not present default to sprite 0
 17091  7c17 e008                                cpx #8
 17092  7c19 b3e3d5                              +lbcs fcerr                              ; illegal value
 17093  7c1c 8676                                stx z_p_temp_1
 17094  7c1e bcfeb7                              ldy sproff,x                             ; kill moving sprite
 17095  7c21 a900                                lda #0                                   ; get offset to speed data
 17096  7c23 990512                              sta sprite_data,y                        ; reset sprite's speed value
 17097                          
 17098  7c26 68                                  pla                                      ; setup for Kernel call- get port# into b7,6
 17099  7c27 6a                                  ror                                      ; .a= port(s), .x=sprite
 17100  7c28 6a                                  ror
 17101  7c29 6a                                  ror
 17102  7c2a 201be0                              jsr _mouse                               ; do it (???? do after coord error check)
 17103                          
 17104                          
 17105  7c2d 202679                              jsr optbyt                               ; get (optional) hotspot, x  new [910307]
 17106  7c30 9014                                bcc l259_2                               ; not given
 17107  7c32 e018                                cpx #24
 17108  7c34 b3c8d5                              +lbcs fcerr                              ; out of range (0-23)
 17109  7c37 8a                                  txa
 17110  7c38 42                                  neg
 17111  7c39 aa                                  tax
 17112  7c3a 6918                                adc #24
 17113  7c3c 8d3d11                              sta _mouse_left
 17114  7c3f 8a                                  txa
 17115  7c40 18                                  clc
 17116  7c41 6957                                adc #87
 17117  7c43 8d3e11                              sta _mouse_right
 17118                          
 17119  7c46 202679             l259_2           jsr optbyt                               ; get (optional) hotspot, y
 17120  7c49 9014                                bcc l259_3                               ; not given
 17121  7c4b e015                                cpx #21
 17122  7c4d b3afd5                              +lbcs fcerr                              ; out of range (0-20)
 17123  7c50 8a                                  txa
 17124  7c51 42                                  neg
 17125  7c52 aa                                  tax
 17126  7c53 6932                                adc #50
 17127  7c55 8d3b11                              sta _mouse_top
 17128  7c58 8a                                  txa
 17129  7c59 18                                  clc
 17130  7c5a 69fa                                adc #250
 17131  7c5c 8d3c11                              sta _mouse_bottom
 17132                          
 17133  7c5f 208522             l259_3           jsr chrgot                               ; get (optional) position coordinate  [910123]
 17134  7c62 f028                                beq l259_4                               ; eol, use this sprite's last position
 17135  7c64 20c3b7                              jsr sprcor                               ; else get first coordinate
 17136  7c67 2cf411                              bit numcnt                               ; test coordinate type
 17137  7c6a 73deb1                              +lbvs snerr                              ; syntax error
 17138  7c6d 8cf011                              sty xdest                                ; save coordinate value
 17139  7c70 8cf211                              sty xdest+2
 17140  7c73 8df111                              sta xdest+1
 17141  7c76 8df311                              sta xdest+3
 17142                          
 17143  7c79 a97f                                lda #$7f                                 ; flag 'mouse' for movspr call  [910808]
 17144  7c7b 8587                                sta op
 17145  7c7d 20c3b7                              jsr sprcor                               ; get second coordinate
 17146  7c80 2cf411                              bit numcnt                               ; test type of coordinate
 17147  7c83 53bf39                              +lbvc movspr_normal                      ; position sprite, normal coordinates
 17148  7c86 339e39                              +lbmi movspr_angle                       ; angular coordinates
 17149  7c89 83bfb1                              +lbra snerr                              ; else error
 17150                          
 17151  7c8c 60                 l259_4           rts
 17152                          
 17153                          ;.end
 17154                          ;[[function.rmouse]]
 17155                          
 17156                          
 17157                          ;************************************************************************
 17158                          ;*   RMOUSE Returns in variable list current status of mouse *
 17159                          ;*         *
 17160                          ;*   Syntax: RMOUSE [Xposition [,Yposition [, Buttons] ]]  *
 17161                          ;*         *
 17162                          ;*   Where: X,Yposition = current position of mouse pointer sprite *
 17163                          ;*  Button      = current status of mouse buttons  *
 17164                          ;*         *
 17165                          ;*   0   = no button     *
 17166                          ;*   1   = right button    *
 17167                          ;*   128 = left button    *
 17168                          ;*   129 = both buttons    *
 17169                          ;*         *
 17170                          ;* If a mouse is not installed, "-1" is returned for all vars. *
 17171                          ;* If both ports are enabled, buttons from each port are merged. *
 17172                          ;************************************************************************
 17173                          
 17174  7c8d a900               rmouse           lda #0                                   ; Init
 17175  7c8f 850d                                sta count                                ; variable count = 0
 17176  7c91 3a                                  dec
 17177  7c92 a205                                ldx #6-1
 17178  7c94 9587               l260_1           sta grapnt,x                             ; positions/buttons = -1
 17179  7c96 ca                                  dex
 17180  7c97 10fb                                bpl l260_1
 17181                          
 17182  7c99 ad3511                              lda _mouse_enable                        ; Is there a mouse in the house?
 17183  7c9c 29c0                                and #%11000000
 17184  7c9e f050                                beq l260_5                               ; no, exit
 17185  7ca0 48                                  pha                                      ; yes, save port assigns for later
 17186  7ca1 78                                  sei
 17187  7ca2 ac3611                              ldy _mouse_pointer                       ; Where is it?  Get pointer to sprite
 17188  7ca5 b900d0                              lda vic,y                                ; Get X position    ???vic_save
 17189  7ca8 8587                                sta grapnt                               ; lsb
 17190  7caa b96579                              lda sbits,y
 17191  7cad 2d10d0                              and vic+16                               ; msb    ???vic_save
 17192  7cb0 f002                                beq l260_2
 17193  7cb2 a901                                lda #1                                   ; convert to 0 or 1
 17194  7cb4 8588               l260_2           sta grapnt+1
 17195  7cb6 c8                                  iny                                      ; Get Y position
 17196  7cb7 b900d0                              lda vic,y                                ; lsb    ???vic_save
 17197  7cba 8589                                sta grapnt+2
 17198  7cbc a900                                lda #0                                   ; msb (fake it)
 17199  7cbe 858a                                sta grapnt+3
 17200                          
 17201  7cc0 858b                                sta grapnt+4                             ; Init button status
 17202  7cc2 858c                                sta grapnt+5
 17203  7cc4 ab00dc                              ldz d1pra                                ; Set up port & read buttons
 17204  7cc7 a9ff                                lda #$ff                                 ; save kybd output lines (IRQ already disabled)
 17205  7cc9 8d00dc                              sta d1pra                                ; set to not read any kybd inputs
 17206                          
 17207  7ccc a000                                ldy #0                                   ; which port?
 17208  7cce fa                                  plx                                      ; recall port assignments
 17209  7ccf 8a                 l260_3           txa
 17210  7cd0 0a                                  asl                                      ; .c=1 if this one
 17211  7cd1 aa                                  tax
 17212  7cd2 900f                                bcc l260_4                               ; not this one
 17213  7cd4 b900dc                              lda d1pra,y                              ; read it (logical port is opposite physical port)
 17214  7cd7 2911                                and #%00010001                           ; want left, right buttons only
 17215  7cd9 4911                                eor #%00010001                           ; (invert, since low means button down)
 17216  7cdb 048b                                tsb grapnt+4
 17217  7cdd 2910                                and #%00010000                           ; shift left button to msb
 17218  7cdf f002                                beq l260_4
 17219  7ce1 f78b                                smb7 grapnt+4
 17220  7ce3 c8                 l260_4           iny                                      ; next port
 17221  7ce4 c002                                cpy #2
 17222  7ce6 90e7                                bcc l260_3
 17223                          
 17224  7ce8 a97e                                lda #%01111110                           ; clean up
 17225  7cea 148b                                trb grapnt+4                             ; fix button register
 17226  7cec 9c00dc                              stz d1pra                                ; restore port for Kernel
 17227  7cef 58                                  cli
 17228                          
 17229                          ; At this point, we have snapshot the current mouse status.
 17230                          ; Now pass requested info along in a manner very similar to RREG...
 17231                          
 17232  7cf0 208522             l260_5           jsr chrgot                               ; Get a variable name from variable list
 17233  7cf3 f032                                beq l260_8                               ; eol- exit
 17234  7cf5 c92c                                cmp #','                                 ;
 17235  7cf7 f01a                                beq l260_7                               ; null- skip this arg
 17236  7cf9 207c4f                              jsr ptrget                               ; Get pointer to target variable
 17237  7cfc 854b                                sta forpnt                               ; set up so we can share LET code
 17238  7cfe 844c                                sty forpnt+1
 17239  7d00 a50f                                lda valtyp                               ; what kind of variable name did ptrget find?
 17240  7d02 d3e3cf                              +lbne chkerr                             ; string- type mismatch error
 17241                          
 17242  7d05 a60d               l260_6           ldx count                                ; Make assignment
 17243  7d07 b487                                ldy grapnt,x                             ; low byte
 17244  7d09 b588                                lda grapnt+1,x                           ; high byte
 17245  7d0b 203f4e                              jsr givayf                               ; float it
 17246  7d0e a510                                lda intflg                               ; set flags for type of var (int/float)
 17247  7d10 209336                              jsr qintgr                               ; use part of LET to do the work
 17248                          
 17249  7d13 e60d               l260_7           inc count                                ; Next assignment
 17250  7d15 e60d                                inc count
 17251  7d17 a60d                                ldx count
 17252  7d19 e006                                cpx #6                                   ; there are 3 possible
 17253  7d1b b00a                                bcs l260_8                               ; done all 3, exit
 17254  7d1d 208522                              jsr chrgot                               ; check terminator
 17255  7d20 f005                                beq l260_8                               ; eol- exit
 17256  7d22 205b4e                              jsr chkcom                               ; check delimiter
 17257  7d25 80c9                                bra l260_5                               ; loop until done
 17258                          
 17259  7d27 60                 l260_8           rts
 17260                          
 17261                          ;.end
 17262                          ;[[command.cursor]]
 17263                          
 17264                          
 17265                          
 17266                          ;*****************************************************************
 17267                          ;*   CURSOR [ON|OFF,] [column] [,row [,style] ]
 17268                          ;*
 17269                          ;*   where: column,row = x,y logical screen position
 17270                          ;*  style      = flashing (0) or solid (1)
 17271                          ;*  ON,OFF     = to turn the cursor on or off
 17272                          ;*****************************************************************
 17273                          
 17274  7d28 c991               cursor           cmp #on_token                            ; Check for ON | OFF
 17275  7d2a 18                                  clc
 17276  7d2b f046                                beq l261_3                               ; turn cursor on (.c=0)
 17277  7d2d c9fe                                cmp #esc_command_token
 17278  7d2f d00a                                bne l261_1                               ; (might be a function)
 17279  7d31 2016b5                              jsr chkesc
 17280  7d34 c924                                cmp #off_token                           ; turn cursor off (.c=1)
 17281  7d36 f03b                                beq l261_3
 17282  7d38 8310b1                              +lbra snerr
 17283                          
 17284  7d3b 48                 l261_1           pha                                      ; Evaluate cursor position parameters
 17285  7d3c 38                                  sec
 17286  7d3d 20f0ff                              jsr _plot                                ; get current cursor position & save it
 17287  7d40 8688                                stx srow
 17288  7d42 8487                                sty column
 17289                          
 17290  7d44 a687                                ldx column                               ; get new column, default=current column
 17291  7d46 68                                  pla
 17292  7d47 c92c                                cmp #','
 17293  7d49 f003                                beq l261_2                               ; not given, use default
 17294  7d4b 206c5d                              jsr getbyt
 17295  7d4e 8687               l261_2           stx column
 17296  7d50 a688                                ldx srow                                 ; get new row, default=current row
 17297  7d52 202679                              jsr optbyt
 17298                          ; stx srow
 17299  7d55 a487                                ldy column
 17300  7d57 18                                  clc
 17301  7d58 20f0ff                              jsr _plot                                ; set new cursor position
 17302  7d5b b3a1d4                              +lbcs fcerr                              ; error if bad position
 17303                          
 17304  7d5e 202479                              jsr optzer                               ; Get new cursor type   ???? assumes screen output
 17305  7d61 901d                                bcc l261_4                               ; not given, exit
 17306  7d63 a91b                                lda #esc
 17307  7d65 20d2ff                              jsr _bsout                               ; use escape sequence to set
 17308  7d68 8a                                  txa
 17309  7d69 2901                                and #1
 17310  7d6b 4901                                eor #1                                   ; [910808]
 17311  7d6d 18                                  clc
 17312  7d6e 6945                                adc #'E'                                 ; 0=F=flash, 1=E=solid
 17313  7d70 4cd2ff                              jmp _bsout                               ; set it and exit
 17314                          
 17315  7d73 2030e0             l261_3           jsr _cursor                              ; Turn cursor ON or OFF per .c
 17316                          
 17317  7d76 208322                              jsr chrget                               ; eat token, get next character
 17318  7d79 f005                                beq l261_4                               ; eol- exit
 17319  7d7b 205b4e                              jsr chkcom                               ; else, must be comma
 17320  7d7e 80bb                                bra l261_1                               ; it is- go evaluate position
 17321                          
 17322  7d80 60                 l261_4           rts                                      ; eol
 17323                          
 17324                          ;[[function.rcursor]]
 17325                          
 17326                          
 17327                          ;************************************************************************
 17328                          ;*   RCURSOR Returns in variable list current cursor position *
 17329                          ;*         *
 17330                          ;*   Syntax: RCURSOR [column [,row] ]    *
 17331                          ;************************************************************************
 17332                          
 17333  7d81 38                 rcursor          sec                                      ; new [910228]
 17334  7d82 20f0ff                              jsr _plot                                ; get current cursor position & save it
 17335  7d85 8688                                stx srow
 17336  7d87 8487                                sty column
 17337                          
 17338  7d89 a200                                ldx #0                                   ; just like RREG and RMOUSE...
 17339  7d8b 860d                                stx count
 17340  7d8d 208522             l262_1           jsr chrgot                               ; Get a variable name from variable list
 17341  7d90 f030                                beq l262_4                               ; eol- exit
 17342  7d92 c92c                                cmp #','                                 ;
 17343  7d94 f01a                                beq l262_3                               ; null- skip this arg
 17344  7d96 207c4f                              jsr ptrget                               ; Get pointer to target variable
 17345  7d99 854b                                sta forpnt                               ; set up so we can share LET code
 17346  7d9b 844c                                sty forpnt+1
 17347  7d9d a50f                                lda valtyp                               ; what kind of variable name did ptrget find?
 17348  7d9f d346cf                              +lbne chkerr                             ; string- type mismatch error
 17349                          
 17350  7da2 a60d               l262_2           ldx count                                ; Make assignment
 17351  7da4 b487                                ldy column,x                             ; low byte
 17352  7da6 a900                                lda #0                                   ; high byte
 17353  7da8 203f4e                              jsr givayf                               ; float it
 17354  7dab a510                                lda intflg                               ; set flags for type of var (int/float)
 17355  7dad 209336                              jsr qintgr                               ; use part of LET to do the work
 17356                          
 17357  7db0 e60d               l262_3           inc count                                ; Next assignment
 17358  7db2 a60d                                ldx count
 17359  7db4 e002                                cpx #2                                   ; there are 2 possible
 17360  7db6 b00a                                bcs l262_4                               ; done 2, exit
 17361  7db8 208522                              jsr chrgot                               ; check terminator
 17362  7dbb f005                                beq l262_4                               ; eol- exit
 17363  7dbd 205b4e                              jsr chkcom                               ; check delimiter
 17364  7dc0 80cb                                bra l262_1                               ; loop until done
 17365                          
 17366  7dc2 60                 l262_4           rts
 17367                          
 17368                          ;.end
 17369                          
 17370                          
 17371                          
 17372                          AutoScroll
 17373  7dc3 48                                  pha                                      ; save character for Editor
 17374  7dc4 ff7e1e                              bbs7 runmod,AutoScrollno                 ; branch if not direct mode
 17375  7dc7 a415                                ldy channl                               ; is output redirected?
 17376  7dc9 d01a                                bne AutoScrollno                         ; yes- can't do scroll (need to read screen)
 17377  7dcb a52d                                lda txttab
 17378  7dcd a62e                                ldx txttab+1                             ; is there a program in memory to scroll?
 17379  7dcf 853d                                sta txtptr
 17380  7dd1 863e                                stx txtptr+1
 17381  7dd3 c8                                  iny                                      ; (1)
 17382  7dd4 20c522                              jsr indtxt
 17383  7dd7 d011                                bne AutoScrollyes                        ; yes- continue
 17384  7dd9 800a                                bra AutoScrollno                         ; no-  exit
 17385                          
 17386                          AutoScrollpop
 17387  7ddb 68                                  pla
 17388  7ddc 68                                  pla
 17389                          AutoScrollng
 17390  7ddd a67f                                ldx point                                ; restore cursor position
 17391  7ddf a480                                ldy point+1
 17392  7de1 18                                  clc
 17393  7de2 20f0ff                              jsr _plot
 17394                          AutoScrollno
 17395  7de5 1755                                rmb1 helper                              ; remove LINGET flag
 17396  7de7 68                                  pla                                      ; restore character
 17397  7de8 38                                  sec                                      ; return to Editor with no action taken
 17398  7de9 60                                  rts
 17399                          
 17400                          AutoScrollyes
 17401  7dea 663f                                ror form                                 ; save .c=direction (character already on stack)
 17402  7dec 38                                  sec
 17403  7ded 20f0ff                              jsr _plot                                ; get current cursor position & save it
 17404  7df0 867f                                stx point
 17405  7df2 8480                                sty point+1
 17406  7df4 9755                                smb1 helper                              ; set flag for LINGET not to go to error if it has problems
 17407  7df6 ff3f3d                              bbs7 form,AutoScrolldn                   ; branch according to direction of scroll...
 17408                          
 17409                          
 17410                          AutoScrollup                                              ; wanting to scroll up
 17411  7df9 38                                  sec
 17412  7dfa a5e4                                lda _screen_bottom                       ; put cursor at bottom of screen
 17413  7dfc e5e5                                sbc _screen_top
 17414  7dfe 8540                                sta form+1                               ; save where it is- we'll be printing line there
 17415  7e00 aa                                  tax
 17416  7e01 20a87e                              jsr AutoSearch                           ; search for a line number on screen, put it in linnum
 17417  7e04 20fa31                              jsr FindLine                             ; find the line in program
 17418  7e07 900e                                bcc l263_1   ;  line not found           ; we have a pointer to the next line
 17419  7e09 a000                                ldy #0
 17420  7e0b 20ad22                              jsr indlow                               ; find the next line, the one we want to print, via link bytes
 17421  7e0e aa                                  tax
 17422  7e0f c8                                  iny
 17423  7e10 20ad22                              jsr indlow
 17424  7e13 8661                                stx lowtr                                ; advance pointer to it
 17425  7e15 8562                                sta lowtr+1
 17426  7e17 a640               l263_1           ldx form+1                               ; put cursor back at bottom of screen
 17427  7e19 a000                                ldy #0
 17428  7e1b 18                                  clc
 17429  7e1c 20f0ff                              jsr _plot
 17430  7e1f 20f737             l263_2           jsr crdo                                 ; get a blank line to print on- scroll screen up
 17431  7e22 a001                                ldy #1
 17432  7e24 20ad22                              jsr indlow                               ; end of program marker?
 17433  7e27 d05f                                bne AutoScrollprint                      ; no-  print this line & exit
 17434  7e29 a52d                                lda txttab                               ; yes- loop to start of program,
 17435  7e2b a62e                                ldx txttab+1
 17436  7e2d 8561                                sta lowtr
 17437  7e2f 8662                                stx lowtr+1
 17438  7e31 20f737                              jsr crdo                                 ; and add an extra newline
 17439  7e34 80e9                                bra l263_2
 17440                          
 17441                          
 17442                          AutoScrolldn                                              ; wanting to scroll down
 17443  7e36 a200                                ldx #0                                   ; put cursor at top of screen
 17444  7e38 20a87e                              jsr AutoSearch                           ; search for a line number on screen, put it in linnum
 17445  7e3b a200                                ldx #0                                   ; get a blank line to print on
 17446  7e3d a000                                ldy #0                                   ; put cursor at top of screen
 17447  7e3f 18                                  clc
 17448  7e40 20f0ff                              jsr _plot
 17449  7e43 207dff             l264_1           jsr _primm                               ; and scroll screen (kill any pending Editor modes, too)
 17450  7e46 1b1b1b5700                          !text esc,esc,esc,"W",0
 17451  7e4b 20fa31                              jsr FindLine                             ; find the line in program whose number we found on screen
 17452  7e4e a561                                lda lowtr                                ; (does not matter if it or next higher line is found)
 17453  7e50 c52d                                cmp txttab
 17454  7e52 d012                                bne l264_2
 17455  7e54 a562                                lda lowtr+1
 17456  7e56 c52e                                cmp txttab+1
 17457  7e58 d00c                                bne l264_2
 17458  7e5a a9ff                                lda #$ff                                 ; special case- it's the very first line, want to wrap to last line
 17459  7e5c 8517                                sta linnum+1                             ; fake pointer to the last line,
 17460  7e5e 207dff                              jsr _primm                               ; scroll screen to insert extra space,
 17461  7e61 1b5700                              !text esc,"W",0
 17462  7e64 80dd                                bra l264_1                               ; and go around again
 17463                          
 17464  7e66 a52d               l264_2           lda txttab                               ; start at beginning of program (txttab) and find the line which points at (lowtr)
 17465  7e68 a62e                                ldx txttab+1
 17466  7e6a 8524               l264_3           sta index                                ; pointer to link bytes
 17467  7e6c 8625                                stx index+1
 17468  7e6e a001                                ldy #1
 17469  7e70 20c122                              jsr indin1                               ; get link bytes
 17470  7e73 aa                                  tax
 17471  7e74 88                                  dey
 17472  7e75 20c122                              jsr indin1
 17473  7e78 e462                                cpx lowtr+1                              ; do link bytes point at target line?
 17474  7e7a d0ee                                bne l264_3
 17475  7e7c c561                                cmp lowtr
 17476  7e7e d0ea                                bne l264_3                               ; no- use these link bytes to find next line
 17477                          
 17478  7e80 a524                                lda index                                ; yes- copy pointer
 17479  7e82 a625                                ldx index+1
 17480  7e84 8561                                sta lowtr
 17481  7e86 8662                                stx lowtr+1
 17482                          ; bra AutoScrollprint ; print the line & exit
 17483                          
 17484                          
 17485                          AutoScrollprint
 17486  7e88 a002                                ldy #2                                   ; get line number to print
 17487  7e8a 20ad22                              jsr indlow
 17488  7e8d aa                                  tax
 17489  7e8e c8                                  iny
 17490  7e8f 20ad22                              jsr indlow
 17491  7e92 207733                              jsr p1line                               ; print the number & the line
 17492                          ; bra AutoScrolldone ;Normal exit
 17493                          
 17494                          AutoScrolldone
 17495  7e95 207dff                              jsr _primm                               ; kill special Editor modes
 17496  7e98 1b1b00                              !text esc,esc,0
 17497  7e9b a67f                                ldx point                                ; restore cursor position
 17498  7e9d a480                                ldy point+1
 17499  7e9f 18                                  clc
 17500  7ea0 20f0ff                              jsr _plot
 17501  7ea3 1755                                rmb1 helper                              ; remove LINGET flag
 17502  7ea5 68                                  pla                                      ; restore character
 17503  7ea6 18                                  clc                                      ; return to Editor, with flag we handled character
 17504  7ea7 60                                  rts
 17505                          
 17506                          AutoSearch
 17507  7ea8 a000                                ldy #0                                   ; search for any line number on screen in leftmost column
 17508  7eaa 18                                  clc
 17509  7eab 20f0ff                              jsr _plot                                ; move to beginning of next line
 17510                          ; bcs AutoScrollpop ;  exit if no more lines
 17511  7eae b02a                                bcs l265_4                               ; no more lines- fake one   [910716]
 17512  7eb0 38                                  sec
 17513  7eb1 20f0ff                              jsr _plot                                ; else check if wrapped line
 17514  7eb4 b018                                bcs l265_1                               ; it's wrapped- move up one line
 17515  7eb6 a5e0                                lda _pnt
 17516  7eb8 65e6                                adc _screen_left                         ; (.c=0)
 17517  7eba 853d                                sta txtptr                               ; copy screen address of logical line to txtptr
 17518  7ebc a5e1                                lda _pnt+1
 17519  7ebe 6900                                adc #0
 17520  7ec0 853e                                sta txtptr+1
 17521  7ec2 a000                                ldy #0                                   ; get first character on this line in window
 17522  7ec4 b13d                                lda (txtptr),y
 17523                          ; jsr indtxt  ;    (I did not want to limit search to the first column,
 17524  7ec6 c93a                                cmp #'9'+1                               ; but it was way too slow searching the entire screen)
 17525  7ec8 b004                                bcs l265_1                               ; it's not a number
 17526  7eca c930                                cmp #'0'
 17527  7ecc b008                                bcs l265_3                               ; it's a digit 0-9, continue
 17528                          
 17529  7ece ff3f02             l265_1           bbs7 form,l265_2                         ; not on this line- move to next line
 17530  7ed1 ca                                  dex                                      ; move up one line
 17531  7ed2 89                                  !text $89
 17532  7ed3 e8                 l265_2           inx                                      ; move down one line
 17533  7ed4 80d2                                bra AutoSearch                           ; loop until we find a numeric digit or run out of lines
 17534                          
 17535  7ed6 18                 l265_3           clc                                      ; found a digit, get entire number into linnum & rts
 17536  7ed7 8355b3                              +lbra linget
 17537                          
 17538  7eda a9ff               l265_4           lda #$ff                                 ; no line found, fake end of program   [910716]
 17539  7edc 8517                                sta linnum+1
 17540  7ede 60                                  rts
 17541                          
 17542                          
 17543                          
 17544                          
 17545                          ;.end
 17546                          ;[[command.screen]]
 17547                          
 17548                          
 17549                          
 17550                                           * = $af00                                ; [911001]
 17551                          
 17552                          ;*****************************************************************
 17553                          ; SCREEN DEF      define a screen
 17554                          ; SCREEN SET  set draw, view screen
 17555                          ; SCREEN CLR  clear a screen
 17556                          ; SCREEN OPEN  open a screen
 17557                          ; SCREEN CLOSE  close a screen
 17558                          ;*****************************************************************
 17559                          
 17560                          Screen
 17561  af00 c99f                                cmp #open_token                          ; else dispatch per secondary token...
 17562  af02 f39200                              +lbeq ScreenOpen
 17563  af05 c9a0                                cmp #close_token
 17564  af07 f39e00                              +lbeq ScreenClose
 17565  af0a c996                                cmp #def_token
 17566  af0c f058                                beq ScreenDef
 17567  af0e c99c                                cmp #clr_token
 17568  af10 f020                                beq ScreenClr
 17569                          
 17570  af12 2016b5                              jsr chkesc                               ; [910930]
 17571                          ; cmp #esc_command_token
 17572                          ; bne l266_1
 17573                          ; jsr chrget  ; get past escape token
 17574  af15 c92d                                cmp #set_token
 17575  af17 f02f                                beq ScreenSet
 17576  af19 832f7f             l266_1           +lbra snerr                              ; report syntax error
 17577                          
 17578                          
 17579                          CheckGraphicMode
 17580  af1c 2c4b1f                              bit $1f4b                                ; Check draw screen allocation   [910711]
 17581  af1f 3001                                bmi NoGraphicArea
 17582  af21 60                                  rts                                      ; ok
 17583                          
 17584                          
 17585                          NoGraphicArea
 17586  af22 a223                                ldx #errng                               ; bad- no graphic area????
 17587  af24 83297f                              +lbra error
 17588                          
 17589                          
 17590                          RestoreTextScreen                                          ; [910404]
 17591  af27 a9ff                                lda #$ff                                 ; [910930]
 17592  af29 8d001f                              sta GKI__parm1                           ; leave drawscreen as is
 17593  af2c 8d011f                              sta GKI__parm2                           ; set viewscreen to text
 17594  af2f 6c0e80                              jmp ($800e)                              ; kg65.screen
 17595                          
 17596                          ; lda vic+49  ;Check graphic screen allocation
 17597                          ; and #%00010000
 17598                          ; beq 99$   ; we're in text mode
 17599                          ;; bit $1f43
 17600                          ;; bmi NoGraphicArea
 17601                          ;
 17602                          ; sei
 17603                          ; lda #$80
 17604                          ; bit _mode  ;40/80 mode, 0=80 128=40
 17605                          ; bmi l267_1
 17606                          ;
 17607                          ; tsb vic+49  ; 80
 17608                          ; lda #1
 17609                          ; trb vic+22  ;  fix x-scroll register
 17610                          ; bra 99$
 17611                          ;
 17612                          ;l267_1 trb vic+49  ; 40
 17613                          ; lda #1
 17614                          ; tsb vic+22  ;  fix x-scroll register
 17615                          ;
 17616                          ;99$ cli
 17617                          ;; lda #0
 17618                          ;; sta _graphm  ;text mode????
 17619                          ; rts
 17620                          
 17621                          
 17622                          ;*****************************************************************
 17623                          ; SCNCLR  clear a text or graphic screen
 17624                          ;
 17625                          ;  Syntax : SCNCLR  [ColorReg]
 17626                          ;
 17627                          ; if [ColorReg] not specified, clears text screen
 17628                          ; else clears the graphic screen with given value.
 17629                          ;*****************************************************************
 17630                          
 17631                          ScreenClr
 17632  af32 208322                              jsr chrget                               ; eat token & fall into SCNCLR
 17633                          
 17634                          scnclr
 17635  af35 d005                                bne C65__screenclear                     ; have a parameter, go clear graphic screen
 17636                          
 17637  af37 a993                                lda #$93
 17638  af39 4cd2ff                              jmp _bsout                               ; no parameter, clear text screen
 17639                          ; rts
 17640                          
 17641                          
 17642                          
 17643                          ;*****************************************************************
 17644                          ;* SCREEN CLR  clear a graphic screen
 17645                          ;*
 17646                          ;*  Syntax : SCREEN CLR  color_reg#
 17647                          ;*
 17648                          ;*           parm1 = color reg#  0-255
 17649                          ;*****************************************************************
 17650                          
 17651                          C65__screenclear
 17652  af3c 206c5d                              jsr getbyt                               ; get color register # (range 0-255)?????
 17653                          ;limit to range allowed by current screen def?
 17654  af3f 8e001f                              stx GKI__parm1
 17655  af42 201caf                              jsr CheckGraphicMode
 17656  af45 6c0c80                              jmp ($800c)                              ; bra screenclear
 17657                          
 17658                          
 17659                          ;*****************************************************************
 17660                          ;* SCREEN SET  specify draw & view screens
 17661                          ;*
 17662                          ;*  Syntax : SCREEN SET  [DrawScreen] [,ViewScreen]
 17663                          ;*
 17664                          ;*           parm1 = draw screen # 0-3, 255=don't change    [910711]
 17665                          ;*           parm2 = view screen # 0-3, 255=text
 17666                          ;*****************************************************************
 17667                          
 17668                          ScreenSet
 17669  af48 208322                              jsr chrget                               ; advance past token
 17670                          
 17671                          C65__screen
 17672                          ; beq snerr  ;missing args??      [911017]
 17673  af4b a2ff                                ldx #255                                 ; [911028]
 17674  af4d c92c                                cmp #','
 17675  af4f f003                                beq l267_1                               ; options byte only
 17676                          
 17677  af51 206c5d                              jsr getbyt                               ; get draw screen# in .x
 17678                          ; cpx #4   ;       [910711]
 17679                          ; bcs 20$   ;  out of range error???? (255=leave alone)  [910930]
 17680  af54 8e001f             l267_1           stx GKI__parm1
 17681                          
 17682  af57 ae691f                              ldx $1f69                                ; current viewscreen     [911017]
 17683  af5a 202679                              jsr optbyt                               ; eat a comma, get view screen# in .x
 17684                          ; cpx #4   ;
 17685                          ;20$ bcs fcerr  ;  out of range error???? (255=text)   [910930]
 17686  af5d 8e011f                              stx GKI__parm2
 17687                          
 17688  af60 220e80                              jsr ($800e)                              ; kg65.screen
 17689  af63 b0bd                                bcs NoGraphicArea
 17690  af65 60                                  rts
 17691                          
 17692                          
 17693                          ;*****************************************************************
 17694                          ;* SCREEN DEF  define a graphic screen
 17695                          ;*
 17696                          ;*  Syntax : SCREEN DEF  screen#, width, height, depth
 17697                          ;*
 17698                          ;*           parm1 = screen#           0-3    [910711]
 17699                          ;*           parm2 = width             0=320, 1=640, 2=1280
 17700                          ;*           parm3 = height            0=200, 1=400
 17701                          ;*           parm4 = depth             1-8 bitplanes (2-256 colors)
 17702                          ;*****************************************************************
 17703                          
 17704                          ScreenDef
 17705  af66 208322                              jsr chrget                               ; advance past token
 17706                          
 17707                          C65__screendef
 17708  af69 206c5d                              jsr getbyt                               ; get screen number
 17709  af6c e004                                cpx #4                                   ; range 0-3   [910711]
 17710  af6e b01d                                bcs l268_1
 17711  af70 8e001f                              stx GKI__parm1                           ; screen#
 17712                          
 17713  af73 20825d                              jsr combyt                               ; get width
 17714  af76 e003                                cpx #3                                   ; range 0-2 ???? 1280 mode ????
 17715  af78 b013                                bcs l268_1
 17716  af7a 8e011f                              stx GKI__parm2                           ; width
 17717                          
 17718  af7d 20825d                              jsr combyt                               ; get height
 17719  af80 e002                                cpx #2                                   ; range 0-1
 17720  af82 b009                                bcs l268_1
 17721  af84 8e021f                              stx GKI__parm3                           ; height
 17722                          
 17723  af87 20825d                              jsr combyt                               ; get depth (# bitplanes)
 17724  af8a ca                                  dex                                      ; convert 1-8 to 0-7
 17725  af8b e008                                cpx #8                                   ; range 0-7
 17726  af8d b36fa2             l268_1           +lbcs fcerr                              ; illegal quantity error
 17727  af90 8e031f                              stx GKI__parm4                           ; depth
 17728                          
 17729  af93 6c0680                              jmp ($8006)                              ; bra screendef
 17730                          
 17731                          
 17732                          ;*****************************************************************
 17733                          ;* SCREEN OPEN  open a graphic screen for viewing or drawing
 17734                          ;*
 17735                          ;*  Syntax : SCREEN OPEN screen#
 17736                          ;*
 17737                          ;*           parm1 = screen#      0-3    [910711]
 17738                          ;*****************************************************************
 17739                          
 17740                          
 17741                          ScreenOpen
 17742  af96 208322                              jsr chrget                               ; advance past Open token
 17743                          
 17744                          C65__screenopen
 17745  af99 206c5d                              jsr getbyt                               ; get screen# in .x
 17746  af9c e004                                cpx #4                                   ; range 0-3   [910711]
 17747  af9e b35ea2                              +lbcs fcerr                              ; branch if out of range
 17748                          
 17749  afa1 8e001f                              stx GKI__parm1
 17750  afa4 6c0880                              jmp ($8008)                              ; screenopen    [910826]
 17751                          
 17752                          ; bcs NoGraphicArea ; bad ???? let user catch via RGRAPHIC
 17753                          ; rts
 17754                          
 17755                          
 17756                          ;*****************************************************************
 17757                          ;* SCREEN CLOSE  close a graphic screen
 17758                          ;*
 17759                          ;*  Syntax : SCREEN CLOSE screen#
 17760                          ;*
 17761                          ;*           parm1 = screen#  0-3    [910711]
 17762                          ;*****************************************************************
 17763                          
 17764                          
 17765                          ScreenClose
 17766  afa7 208322                              jsr chrget                               ; advance past Close token
 17767                          
 17768                          C65__screenclose
 17769  afaa 206c5d                              jsr getbyt                               ; get screen#
 17770  afad e004                                cpx #4                                   ; range 0-3   [910711]
 17771  afaf b34da2                              +lbcs fcerr                              ; branch if out of range
 17772  afb2 8e001f                              stx GKI__parm1
 17773                          
 17774  afb5 6c0a80                              jmp ($800a)                              ; bra screenclose
 17775                          
 17776                          ;[[command.pen]]
 17777                          
 17778                          ;*****************************************************************
 17779                          ;* PEN
 17780                          ;*
 17781                          ;*  Syntax : PEN  Pen#, ColorReg
 17782                          ;*
 17783                          ;*           parm1 = pen#  0-2
 17784                          ;*           parm2 = color reg#  0-255
 17785                          ;*****************************************************************
 17786                          
 17787                          C65__setpen
 17788  afb8 206c5d                              jsr getbyt                               ; get pen#
 17789  afbb e003                                cpx #3                                   ; range 0-2
 17790  afbd b33fa2                              +lbcs fcerr                              ; branch if out of range
 17791  afc0 8e001f                              stx GKI__parm1
 17792                          
 17793  afc3 20825d                              jsr combyt                               ; get color reg#
 17794                          ;???? error check for max color allowed
 17795                          ; for the current screen.
 17796  afc6 8e011f                              stx GKI__parm2
 17797                          
 17798  afc9 6c1080                              jmp ($8010)                              ; bra setpen
 17799                          
 17800                          ;[[command.dmode]]
 17801                          
 17802                          
 17803                          ;*****************************************************************
 17804                          ;* DMODE   Set Draw Mode
 17805                          ;*
 17806                          ;*  Syntax : DMODE  jam, complement, stencil, style, thickness
 17807                          ;*
 17808                          ;*         parm1 = jam           0-1
 17809                          ;*         parm2 = complement (XOR) 0-1
 17810                          ;*         parm3 = stencil       0-1  <<< not implemented  [911003]
 17811                          ;*         parm4 = style         0-3  <<< only 0-1 implemented [911003]
 17812                          ;*         parm5 = thickness     1-8  <<< not implemented  [911003]
 17813                          ;*******************************************************************
 17814                          
 17815                          C65__setdmode
 17816  afcc 206c5d                              jsr getbyt                               ; jam mode
 17817  afcf e002                                cpx #2
 17818  afd1 b026                                bcs l269_1
 17819  afd3 8e001f                              stx GKI__parm1
 17820                          
 17821  afd6 20825d                              jsr combyt                               ; complement (xor) mode
 17822  afd9 e002                                cpx #2                                   ; (ignores jam mode if set)
 17823  afdb b01c                                bcs l269_1
 17824  afdd 8e011f                              stx GKI__parm2
 17825                          
 17826  afe0 20825d                              jsr combyt                               ; stencil mode (not implemented)
 17827  afe3 e002                                cpx #2
 17828  afe5 b012                                bcs l269_1
 17829  afe7 8e021f                              stx GKI__parm3
 17830                          
 17831  afea 20825d                              jsr combyt                               ; style mode
 17832  afed e004                                cpx #4                                   ; 0=solid, 1=pattern, 2=tile (not implemented), 3=reserved
 17833  afef b008                                bcs l269_1
 17834  aff1 8e031f                              stx GKI__parm4
 17835                          
 17836  aff4 20825d                              jsr combyt                               ; thickness mode (not implemented)
 17837                          ; dex   ; adjust to 0-7     [911003]
 17838  aff7 e009                                cpx #8+1
 17839  aff9 b303a2             l269_1           +lbcs fcerr                              ; illegal quantity error
 17840  affc 8e041f                              stx GKI__parm5
 17841                          
 17842  afff 6c1480                              jmp ($8014)                              ; bra setdmode
 17843                          
 17844                          ;[[command.dpat]]
 17845                          
 17846                          
 17847                          ;*****************************************************************
 17848                          ;* DPAT   set draw pattern
 17849                          ;*
 17850                          ;*  Syntax : DPAT  type [, # bytes, byte1, byte2, byte3, byte4]
 17851                          ;*
 17852                          ;*           parm1 = type        0-63  <<< only 0-4 implemented [911003]
 17853                          ;*           parm2 = # bytes     1-4
 17854                          ;*           parm3 = byte1       0-255
 17855                          ;*           parm4 = byte2       0-255
 17856                          ;*           parm5 = byte3       0-255
 17857                          ;*           parm6 = byte4       0-255
 17858                          ;*****************************************************************
 17859                          
 17860                          C65__setdpat
 17861  b002 206c5d                              jsr getbyt                               ; get pattern type
 17862  b005 e005                                cpx #4+1                                 ; 63+1       [911028]
 17863  b007 b3f5a1             l270_1           +lbcs fcerr                              ; if out of range
 17864  b00a 8e001f                              stx GKI__parm1
 17865  b00d 8a                                  txa
 17866  b00e d033                                bne l270_2                               ; if parm1 is 0 then get extra stuff
 17867                          
 17868  b010 20825d                              jsr combyt                               ; get number of bytes
 17869  b013 e005                                cpx #5
 17870  b015 b0f0                                bcs l270_1                               ; too many bytes
 17871  b017 8e011f                              stx GKI__parm2
 17872  b01a 8676                                stx z_p_temp_1                           ; save for count
 17873                          
 17874  b01c 20825d                              jsr combyt                               ; get byte 1
 17875  b01f 8e021f                              stx GKI__parm3
 17876  b022 c676                                dec z_p_temp_1
 17877  b024 f01d                                beq l270_2
 17878  b026 33d6a1                              +lbmi fcerr                              ; too few bytes
 17879                          
 17880  b029 20825d                              jsr combyt                               ; get byte 2
 17881  b02c 8e031f                              stx GKI__parm4
 17882  b02f c676                                dec z_p_temp_1
 17883  b031 f010                                beq l270_2
 17884                          
 17885  b033 20825d                              jsr combyt                               ; get byte 3
 17886  b036 8e041f                              stx GKI__parm5
 17887  b039 c676                                dec z_p_temp_1
 17888  b03b f006                                beq l270_2
 17889                          
 17890  b03d 20825d                              jsr combyt                               ; get byte 4
 17891  b040 8e051f                              stx GKI__parm6
 17892                          
 17893  b043 6c1680             l270_2           jmp ($8016)                              ; bra setdpat
 17894                          
 17895                          ;[[command.palette]]
 17896                          
 17897                          
 17898                          ;*****************************************************************
 17899                          ;* PALETTE   set palette colors
 17900                          ;*
 17901                          ;*  Syntax : PALETTE {screen|COLOR}, color_index, red, green, blue
 17902                          ;*           PALETTE RESTORE
 17903                          ;*
 17904                          ;*           parm1 = screen  0-3     [910711]
 17905                          ;*           parm2 = color_index 0-255
 17906                          ;*           parm3 = red           0-31 (b0-3 red, b4=fgbg)  [910520]
 17907                          ;*           parm4 = green         0-15
 17908                          ;*           parm5 = blue          0-15
 17909                          ;*****************************************************************
 17910                          
 17911                          C65__setpalette
 17912  b046 c98c                                cmp #restore_token                       ; restore palette?
 17913  b048 d006                                bne l271_1                               ; no
 17914  b04a 208322                              jsr chrget                               ; yes- advance past Restore token
 17915  b04d 4c27e0                              jmp _palette_init
 17916                          
 17917  b050 c9e7               l271_1           cmp #color_token                         ; set physical color register?
 17918  b052 d00b                                bne l271_2                               ; no- set logical color register
 17919  b054 8d001f                              sta GKI__parm1
 17920  b057 208322                              jsr chrget                               ; yes- advance past Color token
 17921  b05a 206c5d                              jsr getbyt
 17922  b05d 800e                                bra l271_3
 17923                          
 17924  b05f 206c5d             l271_2           jsr getbyt                               ; get screen#
 17925  b062 e004                                cpx #4                                   ; [910711]
 17926  b064 b398a1                              +lbcs fcerr
 17927  b067 8e001f                              stx GKI__parm1
 17928                          
 17929  b06a 20825d                              jsr combyt                               ; get color reg #
 17930  b06d 8e011f             l271_3           stx GKI__parm2                           ; (GKI will check for out of range????)
 17931                          
 17932                          set_palette
 17933  b070 20825d                              jsr combyt                               ; get red & fgbg
 17934  b073 e020                                cpx #32                                  ; [910520]
 17935  b075 b387a1                              +lbcs fcerr
 17936  b078 8e021f                              stx GKI__parm3
 17937                          
 17938  b07b 200ab5                              jsr getcomnyb                            ; get green
 17939                          ; cpx #16
 17940                          ; bcs 10$
 17941  b07e 8e031f                              stx GKI__parm4
 17942                          
 17943  b081 200ab5                              jsr getcomnyb                            ; get blue
 17944                          ; cpx #16
 17945                          ; bcs fcerr  ; illegal quantity error
 17946  b084 8e041f                              stx GKI__parm5
 17947                          
 17948  b087 ad001f                              lda GKI__parm1                           ; logical or physical color register?
 17949  b08a 1017                                bpl l272_1                               ; logical
 17950  b08c ae011f                              ldx GKI__parm2
 17951  b08f ad021f                              lda GKI__parm3                           ; physical
 17952  b092 9d00d1                              sta _red,x
 17953  b095 ad031f                              lda GKI__parm4
 17954  b098 9d00d2                              sta _green,x
 17955  b09b ad041f                              lda GKI__parm5
 17956  b09e 9d00d3                              sta _blue,x
 17957  b0a1 8006                                bra l272_2
 17958                          
 17959  b0a3 221280             l272_1           jsr ($8012)                              ; go set screen palette
 17960  b0a6 b37afe                              +lbcs NoGraphicArea                      ; illegal screen# or color#  [910917]
 17961                          
 17962  b0a9 202679             l272_2           jsr optbyt                               ; get another color reg # ?
 17963  b0ac 8e011f                              stx GKI__parm2
 17964  b0af b0bf                                bcs set_palette                          ; yes- loop
 17965  b0b1 60                                  rts
 17966                          
 17967                          ;[[command.line]]
 17968                          
 17969                          ;*****************************************************************
 17970                          ;* LINE  draw a dot, a line or a stick shape
 17971                          ;*
 17972                          ;*  Syntax : LINE  x0, y0 [,[x1] [,y1]]...
 17973                          ;*
 17974                          ;* parm1,2 = x0 (lo/hi)
 17975                          ;* parm3,4 = y0
 17976                          ;* parm5,6 = x1 (x1,y1)=(x0,y0) if not specified
 17977                          ;* parm7,8 = y1
 17978                          ;*****************************************************************
 17979                          
 17980                          C65__line
 17981  b0b2 c984                                cmp #input_token                         ; special check for 'line input#'  [910103]
 17982  b0b4 f3e687                              +lbeq linputn                            ; yes
 17983  b0b7 c985                                cmp #input_token+1                       ; special check for 'line input'
 17984  b0b9 f3ff87                              +lbeq linput                             ; yes
 17985                          
 17986  b0bc 201caf                              jsr CheckGraphicMode
 17987  b0bf 20e5b7                              jsr sadwrd                               ; get x0
 17988  b0c2 8c001f                              sty GKI__parm1
 17989  b0c5 8d011f                              sta GKI__parm2
 17990  b0c8 8c041f                              sty GKI__parm5                           ; [910228]
 17991  b0cb 8d051f                              sta GKI__parm6
 17992                          
 17993  b0ce 200879                              jsr comsad                               ; get y0
 17994  b0d1 8c021f                              sty GKI__parm3
 17995  b0d4 8d031f                              sta GKI__parm4
 17996  b0d7 8c061f                              sty GKI__parm7                           ; [910228]
 17997  b0da 8d071f                              sta GKI__parm8
 17998                          
 17999  b0dd 200e79                              jsr optsad                               ; get x1     [910228]
 18000  b0e0 9006                                bcc l273_2                               ; use x0
 18001  b0e2 8c041f             l273_1           sty GKI__parm5
 18002  b0e5 8d051f                              sta GKI__parm6
 18003                          
 18004  b0e8 200e79             l273_2           jsr optsad                               ; get y1     [910228]
 18005  b0eb 9006                                bcc l273_3                               ; use y0
 18006  b0ed 8c061f                              sty GKI__parm7
 18007  b0f0 8d071f                              sta GKI__parm8
 18008                          
 18009  b0f3 221880             l273_3           jsr ($8018)                              ; draw a line from x0,y0 to x1,y1
 18010                          
 18011  b0f6 a203                                ldx #3
 18012  b0f8 bd041f             l273_4           lda GKI__parm5,x                         ; copy x1,y1 to x0,y0
 18013  b0fb 9d001f                              sta GKI__parm1,x
 18014  b0fe ca                                  dex
 18015  b0ff 10f7                                bpl l273_4
 18016                          
 18017  b101 200e79                              jsr optsad                               ; more?
 18018  b104 b0dc                                bcs l273_1                               ; yes, continue
 18019  b106 60                                  rts
 18020                          
 18021                          ;[[command.box]]
 18022                          
 18023                          ;*****************************************************************
 18024                          ;* BOX   draw a 4-sided figure
 18025                          ;*
 18026                          ;*  Syntax :  BOX x0,y0, x1,y1, x2,y2, x3,y3 [,solid flag]
 18027                          ;*
 18028                          ;* parm1,2   = x0  (lo/hi)
 18029                          ;* parm3,4   = y0
 18030                          ;* parm5,6   = x1
 18031                          ;* parm7,8   = y1
 18032                          ;* parm9,10  = x2
 18033                          ;* parm11,12 = y2
 18034                          ;* parm13,14 = x3
 18035                          ;* parm15,16 = y3
 18036                          ;* parm17    = solid flag
 18037                          ;*****************************************************************
 18038                          
 18039                          C65__box
 18040  b107 201caf                              jsr CheckGraphicMode
 18041  b10a 20e5b7                              jsr sadwrd                               ; get x0
 18042  b10d 8c001f                              sty GKI__parm1
 18043  b110 8d011f                              sta GKI__parm2
 18044                          
 18045  b113 200879                              jsr comsad                               ; get y0
 18046  b116 8c021f                              sty GKI__parm3
 18047  b119 8d031f                              sta GKI__parm4
 18048                          
 18049  b11c 200879                              jsr comsad                               ; get x1
 18050  b11f 8c041f                              sty GKI__parm5
 18051  b122 8d051f                              sta GKI__parm6
 18052                          
 18053  b125 200879                              jsr comsad                               ; get y1
 18054  b128 8c061f                              sty GKI__parm7
 18055  b12b 8d071f                              sta GKI__parm8
 18056                          
 18057  b12e 200879                              jsr comsad                               ; get x2
 18058  b131 8c081f                              sty GKI__parm9
 18059  b134 8d091f                              sta GKI__parm10
 18060                          
 18061  b137 200879                              jsr comsad                               ; get y2
 18062  b13a 8c0a1f                              sty GKI__parm11
 18063  b13d 8d0b1f                              sta GKI__parm12
 18064                          
 18065  b140 200879                              jsr comsad                               ; get x3
 18066  b143 8c0c1f                              sty GKI__parm13
 18067  b146 8d0d1f                              sta GKI__parm14
 18068                          
 18069  b149 200879                              jsr comsad                               ; get y3
 18070  b14c 8c0e1f                              sty GKI__parm15
 18071  b14f 8d0f1f                              sta GKI__parm16
 18072                          
 18073  b152 202479                              jsr optzer                               ; get solid flag
 18074  b155 8e101f                              stx GKI__parm17
 18075                          
 18076  b158 6c1a80                              jmp ($801a)                              ; bra box
 18077                          
 18078                          ;[[command.circle]]
 18079                          
 18080                          ;*****************************************************************
 18081                          ;* CIRCLE   draw a Circle
 18082                          ;*
 18083                          ;*  Syntax : CIRCLE  CenterX, CenterY, radius [,solid flag]
 18084                          ;*
 18085                          ;*         parm1 = center x lo
 18086                          ;*         parm2 = center x hi
 18087                          ;*         parm3 = center y lo
 18088                          ;*         parm4 = center y hi
 18089                          ;*         parm5 = radius lo
 18090                          ;*         parm6 = radius hi
 18091                          ;*         parm7 = solid flag 0=no, 1=yes
 18092                          ;*****************************************************************
 18093                          
 18094                          C65__circle
 18095  b15b 201caf                              jsr CheckGraphicMode
 18096  b15e 20e5b7                              jsr sadwrd                               ; get center x
 18097  b161 8c001f                              sty GKI__parm1
 18098  b164 8d011f                              sta GKI__parm2
 18099                          
 18100  b167 200879                              jsr comsad                               ; get center y
 18101  b16a 8c021f                              sty GKI__parm3
 18102  b16d 8d031f                              sta GKI__parm4
 18103                          
 18104  b170 200879                              jsr comsad                               ; get radius
 18105  b173 8c041f                              sty GKI__parm5
 18106  b176 8d051f                              sta GKI__parm6
 18107                          
 18108  b179 202479                              jsr optzer                               ; get solid flag
 18109  b17c e002                                cpx #2
 18110  b17e b37ea0                              +lbcs fcerr
 18111  b181 8e061f                              stx GKI__parm7
 18112                          
 18113  b184 6c1c80                              jmp ($801c)                              ; bra circle
 18114                          
 18115                          
 18116                          ;[[command.ellipse]]
 18117                          
 18118                          
 18119                          ;*****************************************************************
 18120                          ;* ELLIPSE   draw an Ellipse
 18121                          ;*
 18122                          ;*  Syntax : ELLIPSE  CenterX, CenterY, RadiusX,  RadiusY  [,solid flag]
 18123                          ;*
 18124                          ;*         parm1 = center x lo
 18125                          ;*         parm2 = center x hi
 18126                          ;*         parm3 = center y lo
 18127                          ;*         parm4 = center y hi
 18128                          ;*         parm5 = x radius lo
 18129                          ;*         parm6 = x radius hi
 18130                          ;*         parm7 = y radius lo
 18131                          ;*         parm8 = y radius hi
 18132                          ;*         parm9 = solid flag 0-1
 18133                          ;*****************************************************************
 18134                          
 18135                          C65__ellipse
 18136  b187 201caf                              jsr CheckGraphicMode
 18137  b18a 20e5b7                              jsr sadwrd                               ; get center x
 18138  b18d 8c001f                              sty GKI__parm1
 18139  b190 8d011f                              sta GKI__parm2
 18140                          
 18141  b193 200879                              jsr comsad                               ; get center y
 18142  b196 8c021f                              sty GKI__parm3
 18143  b199 8d031f                              sta GKI__parm4
 18144                          
 18145  b19c 200879                              jsr comsad                               ; get xradius
 18146  b19f 8c041f                              sty GKI__parm5
 18147  b1a2 8d051f                              sta GKI__parm6
 18148                          
 18149  b1a5 200879                              jsr comsad                               ; get yradius
 18150  b1a8 8c061f                              sty GKI__parm7
 18151  b1ab 8d071f                              sta GKI__parm8
 18152                          
 18153  b1ae 202479                              jsr optzer                               ; get solid flag
 18154  b1b1 e002                                cpx #2
 18155  b1b3 b349a0                              +lbcs fcerr
 18156  b1b6 8e081f                              stx GKI__parm9
 18157                          
 18158  b1b9 6c2080                              jmp ($8020)                              ; bra ellipse
 18159                          
 18160                          ;[[command.polygon]]
 18161                          
 18162                          
 18163                          
 18164                          ;*****************************************************************
 18165                          ;* POLYGON   draw a regular n-sided Polygon
 18166                          ;*
 18167                          ;*  POLYGON  X,Y, Xradius, Yradius, sides [,drawsides [,subtend [,angle [,solid] ]]]
 18168                          ;*
 18169                          ;*         parm1 = center x lo
 18170                          ;*         parm2 = center x hi
 18171                          ;*         parm3 = center y lo
 18172                          ;*         parm4 = center y hi
 18173                          ;*         parm5 = xradius lo
 18174                          ;*         parm6 = xradius hi
 18175                          ;*         parm7 = yradius lo
 18176                          ;*         parm8 = yradius hi
 18177                          ;*         parm9 = solid flag 0-1
 18178                          ;*         parm10 = sa lo (starting angle 0-360)
 18179                          ;*         parm11 = sa hi
 18180                          ;*         parm12 = # of sides to draw (1 to 127)
 18181                          ;*         parm13 = # of sides (3 to parm12)
 18182                          ;*         parm14 = subtend flag 0-1
 18183                          ;****************************************************************
 18184                          
 18185                          C65__polygon                                              ; changed BASIC syntax to something more reasonable [910923] FAB
 18186  b1bc 201caf                              jsr CheckGraphicMode
 18187  b1bf 20e5b7                              jsr sadwrd                               ; get center x
 18188  b1c2 8c001f                              sty GKI__parm1
 18189  b1c5 8d011f                              sta GKI__parm2
 18190                          
 18191  b1c8 200879                              jsr comsad                               ; get center y
 18192  b1cb 8c021f                              sty GKI__parm3
 18193  b1ce 8d031f                              sta GKI__parm4
 18194                          
 18195  b1d1 20875d                              jsr comwrd                               ; get x radius
 18196  b1d4 8c041f                              sty GKI__parm5
 18197  b1d7 8d051f                              sta GKI__parm6
 18198                          
 18199  b1da 20875d                              jsr comwrd                               ; get y radius
 18200  b1dd 8c061f                              sty GKI__parm7
 18201  b1e0 8d071f                              sta GKI__parm8
 18202                          
 18203  b1e3 20825d                              jsr combyt                               ; get number of sides
 18204  b1e6 e003                                cpx #3
 18205  b1e8 900d                                bcc l274_2                               ; too few
 18206  b1ea e080                                cpx #128
 18207  b1ec b310a0             l274_1           +lbcs fcerr                              ; too many
 18208  b1ef 8e0c1f                              stx GKI__parm13
 18209                          
 18210                          ; ldx GKI__parm13  ;get number of sides to draw (default=#sides)
 18211  b1f2 202679                              jsr optbyt
 18212  b1f5 e001                                cpx #1                                   ; must be at least 1 side
 18213  b1f7 9305a0             l274_2           +lbcc fcerr
 18214  b1fa 8e0b1f                              stx GKI__parm12
 18215  b1fd ca                                  dex
 18216  b1fe ec0c1f                              cpx GKI__parm13                          ; draw sides must be <= #sides
 18217  b201 b0e9                                bcs l274_1
 18218                          
 18219  b203 202479                              jsr optzer                               ; get subtend flag
 18220                          ; cpx #2
 18221                          ; bcs l274_1
 18222  b206 8e0d1f                              stx GKI__parm14
 18223                          
 18224  b209 20f278                              jsr optwrd                               ; get starting angle (default=0 degrees)
 18225  b20c 8c091f                              sty GKI__parm10                          ; lo
 18226  b20f 8d0a1f                              sta GKI__parm11                          ; hi
 18227                          
 18228  b212 202479                              jsr optzer                               ; get solid flag
 18229                          ; cpx #2
 18230                          ; bcs l274_1
 18231  b215 8e081f                              stx GKI__parm9
 18232                          
 18233  b218 6c1e80                              jmp ($801e)                              ; bra polygon
 18234                          
 18235                          ;[[command.set]]
 18236                          
 18237                          
 18238                          
 18239                          ;  SET  A multipurpose command initiator
 18240                          
 18241                          
 18242                          C65__set
 18243  b21b c995                                cmp #verify_token                        ; SET VERIFY <ON | OFF>  new [910429]
 18244  b21d f39c00                              +lbeq verify_mode
 18245  b220 c996                                cmp #def_token                           ; SET DEF unit
 18246  b222 d00c                                bne l275_1
 18247  b224 2085b2                              jsr getdisknum_1
 18248  b227 8e0611                              stx _default_drive
 18249  b22a 8e8211                              stx dosfa                                ; Make last DOS device = current device
 18250  b22d 8353c6                              +lbra Clear_DS
 18251                          
 18252                          
 18253                          
 18254  b230 2016b5             l275_1           jsr chkesc                               ; Must be ESCape token
 18255  b233 c940                                cmp #disk_token                          ; ok so far
 18256  b235 d3047c                              +lbne bad_command                        ; unknown command
 18257                          
 18258                          
 18259                          
 18260                          
 18261  b238 2085b2                              jsr getdisknum_1                         ; SET DISK # [<,|TO> #]
 18262  b23b 8e8211                              stx dosfa                                ; got current disk unit #
 18263                          
 18264  b23e 208522                              jsr chrgot                               ; check delimiter (comma, 'TO', or eos)
 18265  b241 f33fc6                              +lbeq Clear_DS                           ; eos- just change DOS' current drive [910417]
 18266  b244 c92c                                cmp #','                                 ; not eos, must be comma or 'TO'
 18267  b246 f005                                beq l275_2
 18268  b248 c9a4                                cmp #to_token
 18269  b24a d3fe7b                              +lbne snerr
 18270                          
 18271  b24d 2085b2             l275_2           jsr getdisknum_1                         ; skip delimiter
 18272  b250 8e8811                              stx dosds2                               ; got new disk unit #
 18273                          
 18274                          
 18275                          
 18276                          ;  Open disk command channel & pass it 'renumber' command
 18277                          
 18278  b253 204171                              jsr dclall                               ; Close any open files????
 18279                          
 18280  b256 a205                                ldx #6-1
 18281  b258 bd7fb2             l275_3           lda disk_renum_cmd,x                     ; move command to RAM, setup for open
 18282  b25b 9d9111                              sta savram,x
 18283  b25e ca                                  dex
 18284  b25f 10f7                                bpl l275_3
 18285  b261 ad8811                              lda dosds2
 18286  b264 0920                                ora #32                                  ; make new # a talk/listen address
 18287  b266 8d9711                              sta savram+6
 18288  b269 ad8811                              lda dosds2
 18289  b26c 0940                                ora #64
 18290  b26e 8d9811                              sta savram+7
 18291                          
 18292  b271 a908                                lda #8                                   ; command string length
 18293  b273 2096b2                              jsr SendDiskCmd                          ; Send command
 18294  b276 ad8811                              lda dosds2
 18295  b279 8d8211                              sta dosfa                                ; Make last DOS device = current device
 18296  b27c 8394b6                              +lbra close_out_1                        ; common error check & exit path ????
 18297                          
 18298                          
 18299  b27f 4d2d57770002       disk_renum_cmd   !text "M-W",119,0,2                      ; Renumber Drive command
 18300                          
 18301                          
 18302                          
 18303                          ;  GetDiskNum - Get a (required) disk number and check it
 18304                          
 18305                          getdisknum_1
 18306  b285 208322                              jsr chrget                               ; skip current character
 18307                          getdisknum
 18308  b288 206c5d                              jsr getbyt                               ; get number in .x
 18309  b28b e008                                cpx #8                                   ; check range (8-30)
 18310  b28d 936f9f                              +lbcc fcerr
 18311  b290 e01f                                cpx #31
 18312  b292 b36a9f                              +lbcs fcerr
 18313  b295 60                                  rts                                      ; returns only if okay
 18314                          
 18315                          
 18316                          
 18317                          ;  SendDiskCmd - Send command in SAVRAM to disk, length in .A
 18318                          
 18319                          SendDiskCmd
 18320                          ; lda #   ; command string length
 18321  b296 a291                                ldx #<savram                             ; address
 18322  b298 a011                                ldy #>savram
 18323  b29a 20bdff                              jsr _setnam
 18324  b29d a200                                ldx #sys_bank                            ; ???? sysbank ????
 18325  b29f 206bff                              jsr _setbank
 18326  b2a2 20ccff                              jsr _clrch                               ; Restore normal channels, establish our's
 18327  b2a5 ae8211                              ldx dosfa                                ; fa
 18328  b2a8 a900                                lda #doslfn                              ; la (reserved la)
 18329  b2aa a06f                                ldy #$6f                                 ; sa (command channel)
 18330  b2ac 20baff                              jsr _setlfs
 18331  b2af 20c0ff                              jsr _open                                ; open channel & send command
 18332  b2b2 a900                                lda #doslfn                              ; close it already
 18333  b2b4 38                                  sec                                      ; not a real close
 18334  b2b5 20c3ff                              jsr _close
 18335  b2b8 83c8c5                              +lbra Clear_DS                           ; Exit
 18336                          
 18337                          
 18338                          ;  SET VERIFY <ON | OFF> Set DOS verify-after-write mode for 3.5" drives
 18339                          
 18340                          verify_mode
 18341  b2bb 208322                              jsr chrget                               ; eat 'verify' token, get next  new [910429]
 18342  b2be c991                                cmp #on_token
 18343  b2c0 38                                  sec
 18344  b2c1 f009                                beq l276_1                               ; turn verify on (.c=1)
 18345  b2c3 2016b5                              jsr chkesc
 18346  b2c6 c924                                cmp #off_token                           ; turn cursor off (.c=0)
 18347  b2c8 d3807b                              +lbne snerr
 18348  b2cb 18                                  clc
 18349                          
 18350                          ;  Open disk command channel & pass it 'verify' command
 18351                          
 18352  b2cc 08                 l276_1           php                                      ; Save mode
 18353  b2cd 2022b5                              jsr chkeos                               ; eat 'on/off' token, error if not eos
 18354                          
 18355  b2d0 a203                                ldx #4-1
 18356  b2d2 bdecb2             l276_2           lda verify_cmd,x                         ; move command to RAM, setup for open
 18357  b2d5 9d9111                              sta savram,x
 18358  b2d8 ca                                  dex
 18359  b2d9 10f7                                bpl l276_2
 18360                          
 18361  b2db a900                                lda #0                                   ; form on/off flag
 18362  b2dd 28                                  plp
 18363  b2de 2a                                  rol
 18364  b2df 0930                                ora #$30
 18365  b2e1 8d9511                              sta savram+4
 18366                          
 18367  b2e4 a905                                lda #5                                   ; command string length
 18368  b2e6 2096b2                              jsr SendDiskCmd                          ; Send command
 18369  b2e9 8327b6                              +lbra close_out_1                        ; common error check & exit path ????
 18370                          
 18371                          
 18372  b2ec 55303e56           verify_cmd       !text "U0>V"                             ; Verify on/off command
 18373                          
 18374                          ;.end
 18375                          ;[[command.char]]
 18376                          
 18377                          
 18378                          
 18379                          ;*****************************************************************
 18380                          ;* CHAR   draw a character string
 18381                          ;*
 18382                          ;*  Syntax : CHAR column, row, height, width, direction, "string" [,charsetadr [,bank]]
 18383                          ;*
 18384                          ;* parm1  = column#
 18385                          ;* parm2  = row lo
 18386                          ;* parm3  = row hi
 18387                          ;* parm4  = height
 18388                          ;* parm5  = width
 18389                          ;* parm6  = direction
 18390                          ;* parm7  = len of string
 18391                          ;* parm8  = lo addr of string
 18392                          ;* parm9  = hi addr of string
 18393                          ;* parm10 = lo addr of character set $29800 default
 18394                          ;* parm11 = hi addr of character set
 18395                          ;* parm12 = bank of character set   [910912]
 18396                          ;****************************************************************
 18397                          
 18398                          C65__char
 18399  b2f0 201caf                              jsr CheckGraphicMode
 18400  b2f3 206c5d                              jsr getbyt                               ; get column
 18401  b2f6 8e001f                              stx GKI__parm1
 18402                          
 18403  b2f9 200879                              jsr comsad                               ; get row
 18404  b2fc 8c011f                              sty GKI__parm2
 18405  b2ff 8d021f                              sta GKI__parm3
 18406                          
 18407  b302 20825d                              jsr combyt                               ; get height
 18408  b305 8e031f                              stx GKI__parm4
 18409                          
 18410  b308 20825d                              jsr combyt                               ; get width
 18411  b30b 8e041f                              stx GKI__parm5
 18412                          
 18413  b30e 20825d                              jsr combyt                               ; get direction
 18414  b311 8e051f                              stx GKI__parm6
 18415                          
 18416  b314 205b4e                              jsr chkcom
 18417  b317 20ef4c                              jsr frmevl                               ; evaluate the string
 18418  b31a 20dd4c                              jsr chkstr                               ; type mismatch error if not string
 18419  b31d a000                                ldy #0
 18420  b31f 20a922                              jsr indfmo                               ; pointer to string descriptor is left in the fac by frmevl
 18421  b322 8d061f                              sta GKI__parm7                           ; length  ???? check for null string ????
 18422  b325 48                                  pha
 18423  b326 c8                                  iny
 18424  b327 20a922                              jsr indfmo
 18425  b32a 8d071f                              sta GKI__parm8                           ; adrlo
 18426  b32d c8                                  iny
 18427  b32e 20a922                              jsr indfmo
 18428  b331 8d081f                              sta GKI__parm9                           ; adrhi
 18429  b334 206d5b                              jsr frefac                               ; [910917]
 18430  b337 68                                  pla
 18431  b338 20dd5b                              jsr getspa
 18432                          
 18433  b33b 20f278                              jsr optwrd                               ; get charset address (????bank)
 18434  b33e b004                                bcs l277_1                               ; given
 18435  b340 a000                                ldy #<$9800                              ; not given- use ROM as default   [910207] FAB
 18436  b342 a998                                lda #>$9800                              ; ???? uc/lc or graphic set ????
 18437  b344 8c091f             l277_1           sty GKI__parm10                          ; lo
 18438  b347 8d0a1f                              sta GKI__parm11                          ; hi
 18439  b34a a202                                ldx #2                                   ; default to ROM bank 2    [910912] FAB
 18440  b34c 202679                              jsr optbyt
 18441  b34f 8e0b1f                              stx GKI__parm12
 18442                          
 18443  b352 ad061f                              lda GKI__parm7                           ; ???? check for null string ????
 18444  b355 f003                                beq l277_2
 18445  b357 6c2c80                              jmp ($802c)                              ; bra kg65.char
 18446                          
 18447  b35a 60                 l277_2           rts
 18448                          
 18449                          ;[[command.paint]]
 18450                          
 18451                          
 18452                          
 18453                          ;*****************************************************************
 18454                          ;* PAINT   fill a graphic area with color
 18455                          ;*
 18456                          ;*  Syntax : PAINT x, y [,mode [,color]]
 18457                          ;*
 18458                          ;* parm1  = x lo
 18459                          ;* parm2  = x lo
 18460                          ;* parm3  = y lo
 18461                          ;* parm4  = y hi
 18462                          ;* parm5  = mode
 18463                          ;* parm6  = color
 18464                          ;*
 18465                          ;* fill color is pen-A
 18466                          ; mode 0: fill region defined by color at x,y (default) new modes [910916] FAB
 18467                          ; mode 1: fill region using given color as boundary
 18468                          ; mode 2: fill connected region
 18469                          ;****************************************************************
 18470                          
 18471                          C65__paint                                                ; new [910228] FAB
 18472  b35b 201caf                              jsr CheckGraphicMode
 18473  b35e 20e5b7                              jsr sadwrd                               ; get x
 18474  b361 8c001f                              sty GKI__parm1
 18475  b364 8d011f                              sta GKI__parm2
 18476                          
 18477  b367 200879                              jsr comsad                               ; get y
 18478  b36a 8c021f                              sty GKI__parm3
 18479  b36d 8d031f                              sta GKI__parm4
 18480                          
 18481  b370 a200                                ldx #0                                   ; [910916]
 18482  b372 202679                              jsr optbyt                               ; mode, default = 0 (fill region pointed to)
 18483  b375 e003                                cpx #3
 18484  b377 b3859e                              +lbcs fcerr                              ; (range 0-2)
 18485  b37a 8e041f                              stx GKI__parm5
 18486  b37d a200                                ldx #0
 18487  b37f 202679                              jsr optbyt                               ; boundary color, default = 0
 18488  b382 8e051f                              stx GKI__parm6
 18489                          
 18490  b385 20335c             l278_1           jsr garba2                               ; create space in var bank for paint stack [910716]
 18491  b388 a533                                lda strend
 18492  b38a 8d061f                              sta GKI__parm7                           ; pass pointer to bottom of bank-1 free space
 18493  b38d a534                                lda strend+1                             ; (top of stack)
 18494  b38f 8d071f                              sta GKI__parm8
 18495  b392 38                                  sec
 18496  b393 a535                                lda fretop                               ; pass pointer to top of free space
 18497  b395 e903                                sbc #3                                   ; (bottom of stack)
 18498  b397 8d081f                              sta GKI__parm9
 18499  b39a a536                                lda fretop+1
 18500  b39c e900                                sbc #0
 18501  b39e 8d091f                              sta GKI__parm10
 18502                          
 18503  b3a1 222e80                              jsr ($802e)                              ; bra paint
 18504  b3a4 b001                                bcs l278_2                               ; error- stack overflow or stop key
 18505  b3a6 60                                  rts
 18506                          
 18507  b3a7 e010               l278_2           cpx #errom
 18508  b3a9 f3a47a                              +lbeq error                              ; stack overflow, say 'out of memory'
 18509  b3ac 832379                              +lbra break_exit                         ; user hit stop key
 18510                          
 18511                          ;[[command.loadiff]]
 18512                          
 18513                          
 18514                          
 18515                          ;*****************************************************************
 18516                          ;*   LOADIFF "filename" [,U#] [,D#]
 18517                          ;*
 18518                          ;* ???? requires SCREEN already opened   910402 FAB
 18519                          ;*****************************************************************
 18520                          
 18521                          loadiff
 18522  b3af 201caf                              jsr CheckGraphicMode
 18523  b3b2 a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
 18524  b3b4 202074                              jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 )
 18525  b3b7 20dc77                              jsr chk1                                 ; check parameters
 18526  b3ba a900                                lda #0
 18527  b3bc 8d8311                              sta dossa                                ; setup as dload would (0 = load channel)
 18528  b3bf 201d71                              jsr find_la                              ; find an available la to use (cannot use reserved one)
 18529  b3c2 a009                                ldy #fopn
 18530  b3c4 a204                                ldx #4
 18531  b3c6 20fd70                              jsr open_file                            ; open the file
 18532  b3c9 b006                                bcs l279_1                               ; exit if error
 18533                          
 18534  b3cb ae8111                              ldx dosla
 18535                          ; stx GKI__parm1
 18536  b3ce 20c6ff                              jsr _chkin                               ; get input channel
 18537  b3d1 b3547f             l279_1           +lbcs list_err                           ; exit if error
 18538                          
 18539  b3d4 222a80                              jsr ($802a)                              ; Load it
 18540                          
 18541                          exit_GKI_disk_op
 18542  b3d7 08                                  php                                      ; preserve completion status
 18543  b3d8 48                                  pha
 18544  b3d9 20ccff                              jsr _clrch
 18545  b3dc ad8111                              lda dosla
 18546  b3df 200e69                              jsr close_out                            ; close channel
 18547                          
 18548  b3e2 20cc2c                              jsr is_stop_key_down                     ; weed out BREAK error
 18549  b3e5 fa                                  plx
 18550  b3e6 28                                  plp
 18551  b3e7 b3667a                              +lbcs error                              ; must be I/O or file data error
 18552  b3ea 60                                  rts                                      ; load was successful
 18553                          
 18554                          ;[[command.saveiff]]
 18555                          
 18556                          ;*****************************************************************
 18557                          ;*
 18558                          ;*   SAVEIFF "[@]filename" [,U#] [,D#]      [910930] FAB
 18559                          ;*
 18560                          ;*****************************************************************
 18561                          
 18562                          saveiff
 18563  b3eb 201caf                              jsr CheckGraphicMode
 18564  b3ee a966                                lda #$66                                 ; set error flags
 18565  b3f0 202074                              jsr dosprs                               ; parse the line
 18566  b3f3 20e177                              jsr chk2                                 ; check required parameters
 18567  b3f6 a901                                lda #1
 18568  b3f8 8d8311                              sta dossa                                ; setup as dsave would (1 = save channel)
 18569  b3fb 201d71                              jsr find_la                              ; find an available la to use (cannot use reserved one)
 18570  b3fe a009                                ldy #fopn
 18571  b400 a204                                ldx #4
 18572  b402 20fd70                              jsr open_file                            ; open the file
 18573  b405 b006                                bcs l280_1                               ; exit if error
 18574                          
 18575  b407 ae8111                              ldx dosla
 18576                          ; stx GKI__parm1
 18577  b40a 20c9ff                              jsr _chkout                              ; get output channel
 18578  b40d b3187f             l280_1           +lbcs list_err                           ; exit if error
 18579                          
 18580  b410 223a80                              jsr ($803a)                              ; Save it
 18581  b413 80c2                                bra exit_GKI_disk_op
 18582                          
 18583                          ; php   ;preserve completion status
 18584                          ; pha
 18585                          ; jsr _clrch
 18586                          ; lda dosla
 18587                          ; jsr close_out  ;close channel
 18588                          ;
 18589                          ; jsr is_stop_key_down ; weed out BREAK error
 18590                          ; plx
 18591                          ; plp
 18592                          ; bcs error  ; must be I/O or file data error
 18593                          ; rts   ; load was successful
 18594                          
 18595                          ;.end
 18596                          ;[[command.viewport]]
 18597                          
 18598                          
 18599                          
 18600                          ;*****************************************************************
 18601                          ;*   VIEWPORT <CLR | DEF>  x, y, viewport_width, viewport_height
 18602                          ;*
 18603                          ;* assumes SCREEN already opened   910626 FAB
 18604                          ;*****************************************************************
 18605                          
 18606                          C65__Viewport
 18607  b415 48                                  pha                                      ; save secondary command
 18608  b416 208322                              jsr chrget                               ; advance past it
 18609  b419 201caf                              jsr CheckGraphicMode                     ; make sure a screen is open
 18610                          
 18611  b41c 20e5b7                              jsr sadwrd                               ; get x0
 18612  b41f 8c001f                              sty GKI__parm1
 18613  b422 8d011f                              sta GKI__parm2
 18614                          
 18615  b425 200879                              jsr comsad                               ; get y0
 18616  b428 8c021f                              sty GKI__parm3
 18617  b42b 8d031f                              sta GKI__parm4
 18618                          
 18619  b42e 200879                              jsr comsad                               ; get width (delta-x)
 18620  b431 8c041f                              sty GKI__parm5
 18621  b434 8d051f                              sta GKI__parm6
 18622                          
 18623  b437 200879                              jsr comsad                               ; get height (delta-y)
 18624  b43a 8c061f                              sty GKI__parm7
 18625  b43d 8d071f                              sta GKI__parm8
 18626                          
 18627  b440 68                                  pla                                      ; dispatch per secondary token...
 18628  b441 c99c                                cmp #clr_token
 18629  b443 f008                                beq l281_1
 18630  b445 c996                                cmp #def_token
 18631  b447 d3017a                              +lbne snerr                              ; error
 18632                          
 18633  b44a 6c3080                              jmp ($8030)                              ; define viewport & return
 18634                          
 18635  b44d 6c2280             l281_1           jmp ($8022)                              ; clear viewport (???? make this a box command)
 18636                          
 18637                          
 18638                          C65__copy
 18639                          C65__cut
 18640                          C65__paste
 18641  b450 4c3b2e                              jmp bad_command
 18642                          
 18643                          ;[[command.genlock]]
 18644                          
 18645                          
 18646                          
 18647                          ;*****************************************************************
 18648                          ;* GENLOCK  set/reset genlock mode & color registers
 18649                          ;*
 18650                          ;*  Syntax: GENLOCK <ON[,color#[,...]] | OFF[,color#,R,G,B]>
 18651                          ;*****************************************************************
 18652                          
 18653  b453 8d001f             genlock          sta GKI__parm1                           ; save token as flag for set palette   [910107]
 18654  b456 c991                                cmp #on_token
 18655  b458 f028                                beq l282_4
 18656  b45a 2016b5                              jsr chkesc
 18657  b45d c924                                cmp #off_token
 18658  b45f d3e979                              +lbne snerr
 18659                          ;TURN GENLOCK OFF
 18660  b462 ad31d0                              lda vic+49                               ; any interlaced bitplanes on?
 18661  b465 2919                                and #%00011001
 18662  b467 c919                                cmp #%00011001
 18663  b469 f005                                beq l282_1                               ; yes, leave interlace mode on
 18664                          
 18665  b46b a901                                lda #%00000001
 18666  b46d 1c31d0                              trb vic+49                               ; no, turn interlace off
 18667  b470 a902               l282_1           lda #%00000010
 18668  b472 1c30d0                              trb vic+48                               ; reset external sync mode
 18669                          ; beq l282_2   ;       [910114]
 18670                          ; lda vic+63  ;       [910111]
 18671                          ; inc a   ;  adjust vert. position (chip bug ????)
 18672                          ; inc a   ;  (to be handled by a custom C65 genlock board)
 18673                          ; inc a
 18674                          ; sta vic+63
 18675                          
 18676  b475 208322             l282_2           jsr chrget                               ; eat token
 18677  b478 202679                              jsr optbyt                               ; get (optional) color reg# in .X
 18678  b47b 8e011f                              stx GKI__parm2                           ; save it
 18679  b47e b3f0fb                              +lbcs set_palette                        ; if present, go do it & exit
 18680  b481 60                 l282_3           rts                                      ; if not present (eol), exit
 18681                          
 18682                          
 18683  b482 a901               l282_4           lda #%00000001                           ; TURN GENLOCK ON
 18684  b484 0c31d0                              tsb vic+49                               ; set interlace mode
 18685  b487 0a                                  asl
 18686  b488 0c30d0                              tsb vic+48                               ; set external sync mode
 18687                          ; bne l282_5   ;       [910114]
 18688                          ; lda vic+63  ;       [910111]
 18689                          ; dec a   ;  adjust vert. position (chip bug ????)
 18690                          ; dec a   ;  (to be handled by a custom C65 genlock board)
 18691                          ; dec a
 18692                          ; sta vic+63
 18693                          
 18694  b48b 208322             l282_5           jsr chrget                               ; eat token
 18695  b48e 202679             l282_6           jsr optbyt                               ; get (optional) color reg# in .X
 18696  b491 90ee                                bcc l282_3                               ; if not present (eol), exit
 18697  b493 a910                                lda #%00010000                           ; if present, set FGBG bit in red palette
 18698  b495 9d00d1                              sta _red,x
 18699  b498 80f4                                bra l282_6                               ; loop
 18700                          
 18701                          ;[[command.color]]
 18702                          
 18703                          
 18704                          
 18705                          
 18706                          ;*****************************************************************
 18707                          ;* COLOR       <ON | OFF> Enable|Disable SW & HW color
 18708                          ;* FOREGROUND  color# Set Foreground color (text)
 18709                          ;* HIGHLIGHT   color# Set Highlight color (text)
 18710                          ;* BACKGROUND  color# Set VIC Background color
 18711                          ;* BORDER      color# Set VIC Border color
 18712                          ;*****************************************************************
 18713                          
 18714  b49a c92c               color            cmp #','                                 ; optional first arg
 18715  b49c f01f                                beq l283_3
 18716  b49e c991                                cmp #on_token                            ; SOFTWARE (Editor) color mode
 18717  b4a0 f00b                                beq l283_2
 18718  b4a2 2016b5                              jsr chkesc
 18719  b4a5 c924                                cmp #off_token
 18720  b4a7 d3a179             l283_1           +lbne snerr
 18721                          
 18722  b4aa a05b                                ldy #'['                                 ; OFF (color & attributes)
 18723  b4ac 2c                                  !text $2c
 18724  b4ad a05d               l283_2           ldy #']'                                 ; ON
 18725  b4af a91b                                lda #esc
 18726  b4b1 20d2ff                              jsr _bsout                               ; do it
 18727  b4b4 98                                  tya
 18728  b4b5 20d2ff                              jsr _bsout
 18729  b4b8 208322                              jsr chrget                               ; eat token
 18730  b4bb f01d                                beq l283_6                               ; eol- exit
 18731                          
 18732  b4bd 205b4e             l283_3           jsr chkcom                               ; else must be comma, eat & get next
 18733                          ; jsr chrgot  ;      [910930]
 18734  b4c0 c991                                cmp #on_token                            ; HARDWARE (Vic) color mode
 18735  b4c2 f00e                                beq l283_4
 18736  b4c4 2016b5                              jsr chkesc
 18737  b4c7 c924                                cmp #off_token
 18738  b4c9 d0dc                                bne l283_1
 18739                          
 18740  b4cb a902                                lda #%00000010                           ; OFF (monochrome)
 18741  b4cd 0c31d0                              tsb vic+49
 18742  b4d0 8005                                bra l283_5
 18743                          
 18744  b4d2 a902               l283_4           lda #%00000010                           ; ON
 18745  b4d4 1c31d0                              trb vic+49
 18746  b4d7 83aa6d             l283_5           +lbra chrget                             ; exit after eating last token
 18747                          
 18748  b4da 60                 l283_6           rts                                      ; exit after encountering eol
 18749                          
 18750                          
 18751                          foreground
 18752  b4db 200db5                              jsr getnyb                               ; Set text foreground color
 18753  b4de 86f1                                stx _color
 18754  b4e0 60                                  rts
 18755                          
 18756                          
 18757                          
 18758                          highlight
 18759  b4e1 f36779                              +lbeq snerr                              ; missing args??     [911017]
 18760  b4e4 c92c                                cmp #','
 18761  b4e6 f006                                beq l284_1                               ; options byte only
 18762                          
 18763  b4e8 206c5d                              jsr getbyt                               ; Set text highlight color
 18764  b4eb 8ed802                              stx highlight_color
 18765                          
 18766  b4ee 202479             l284_1           jsr optzer                               ; set options:     [911001]
 18767  b4f1 9008                                bcc l284_2                               ; comma but no value not given??
 18768  b4f3 8a                                  txa
 18769  b4f4 2903                                and #3                                   ; 0= error msgs only
 18770  b4f6 0a                                  asl                                      ; 1= REMs
 18771  b4f7 0a                                  asl                                      ; 2= tokens
 18772  b4f8 0a                                  asl
 18773  b4f9 8555                                sta helper
 18774  b4fb 60                 l284_2           rts
 18775                          
 18776                          
 18777                          
 18778                          background
 18779  b4fc 200db5                              jsr getnyb                               ; Set Vic background color
 18780  b4ff 8e21d0                              stx vic+33
 18781  b502 60                                  rts
 18782                          
 18783                          
 18784                          
 18785                          border
 18786  b503 200db5                              jsr getnyb                               ; Set Vic border color
 18787  b506 8e20d0                              stx vic+32
 18788  b509 60                                  rts
 18789                          
 18790                          
 18791                          getcomnyb
 18792  b50a 205b4e                              jsr chkcom                               ; check for comma
 18793                          getnyb
 18794  b50d 206c5d                              jsr getbyt                               ; Get a nybble, check range (0-15)
 18795                          chknyb
 18796  b510 e010                                cpx #16
 18797  b512 b3ea9c                              +lbcs fcerr
 18798  b515 60                                  rts
 18799                          
 18800                          
 18801                          
 18802                          chkesc                                                    ; Check for escape token, error if not, else get next token
 18803  b516 c9fe                                cmp #esc_command_token
 18804  b518 d33079                              +lbne snerr
 18805  b51b 208322                              jsr chrget
 18806  b51e f32a79                              +lbeq snerr                              ; eos? report error if so
 18807  b521 60                                  rts
 18808                          
 18809                          
 18810                          
 18811                          chkeos                                                    ; Check for next byte = end of statement, error if not
 18812  b522 208322                              jsr chrget
 18813  b525 d32379                              +lbne snerr                              ; eos? report error if not
 18814  b528 60                                  rts
 18815                          
 18816                          
 18817                          ;.end
 18818                          ;[[command.sprite]]
 18819                          
 18820                          
 18821                          
 18822                          ;************************************************************************************
 18823                          ; SPRITE CLR
 18824                          ; SPRITE {LOAD|SAVE} "filename" [,Ddrive] [,Udevice]
 18825                          ; SPRITE sprite [,enable [,color [,priority [,xexp [,yexp [,resolution] ]]]]]
 18826                          ;
 18827                          ; where: sprite  :== sprite number (1-8)
 18828                          ;  enable  :== enable  (0=off, 1=on)
 18829                          ;  color  :== color  (0-15)
 18830                          ;  priority :== sprite/bgnd  (0=sprite, 1=bgnd)
 18831                          ;  xexp  :== expand x direction (0=no, 1=yes)
 18832                          ;  yexp  :== expand y direction (0=no, 1=yes)
 18833                          ;  resolution :== resolution  (0=hires, 1=multicolor)
 18834                          ;************************************************************************************
 18835                          
 18836  b529 c99c               sprite           cmp #clr_token                           ; SPRITE CLR: init environment   [910717]
 18837  b52b f3a709                              +lbeq Sprite_CLR                         ; yes
 18838  b52e c994                                cmp #save_token                          ; SPRITE SAVE: save sprite data   [911001]
 18839  b530 f048                                beq Sprite_Save                          ; yes
 18840  b532 c993                                cmp #load_token                          ; SPRITE LOAD: load sprite data   [911001]
 18841  b534 f057                                beq Sprite_Load                          ; yes
 18842                          
 18843  b536 20b5b5                              jsr get_sprite_number                    ; get sprite number in z_p_temp_1
 18844  b539 202679                              jsr optbyt                               ; look for (optional) enable
 18845  b53c 9005                                bcc l285_1                               ; none here, don't change
 18846  b53e a015                                ldy #21
 18847  b540 209fb5                              jsr sprbit                               ; set/clear sprite bit
 18848                          
 18849  b543 202679             l285_1           jsr optbyt                               ; get (optional) color
 18850  b546 9009                                bcc l285_2                               ; branch if no arg
 18851  b548 2010b5                              jsr chknyb                               ; [910109]
 18852  b54b 8a                                  txa
 18853  b54c a676                                ldx z_p_temp_1                           ; get back sprite number
 18854                          ; jsr put_io_in_map
 18855  b54e 9d27d0                              sta vic+39,x
 18856                          
 18857  b551 202679             l285_2           jsr optbyt                               ; look for (optional) priority
 18858  b554 9005                                bcc l285_3
 18859  b556 a01b                                ldy #27
 18860  b558 209fb5                              jsr sprbit
 18861                          
 18862  b55b 202679             l285_3           jsr optbyt                               ; look for (optional) x expansion
 18863  b55e 9005                                bcc l285_4
 18864  b560 a01d                                ldy #29
 18865  b562 209fb5                              jsr sprbit
 18866                          
 18867  b565 202679             l285_4           jsr optbyt                               ; look for (optional) y expansion
 18868  b568 9005                                bcc l285_5
 18869  b56a a017                                ldy #23
 18870  b56c 209fb5                              jsr sprbit
 18871                          
 18872  b56f 202679             l285_5           jsr optbyt                               ; look for (optional) resolution
 18873  b572 9005                                bcc l285_6
 18874  b574 a01c                                ldy #28
 18875  b576 209fb5                              jsr sprbit
 18876                          
 18877  b579 60                 l285_6           rts
 18878                          
 18879                          
 18880                          Sprite_Save                                               ; Just like Key_Save     [911001]
 18881  b57a 202e47                              jsr GetSaveChannel
 18882  b57d a95a                                lda #highds                              ; set starting & ending addresses
 18883  b57f a006                                ldy #>sprite_base                        ; start address & pointer to it
 18884  b581 a200                                ldx #<sprite_base
 18885  b583 845b                                sty highds+1
 18886  b585 865a                                stx highds
 18887  b587 c8                                  iny                                      ; end address = start address + 512 + 1
 18888  b588 c8                                  iny
 18889  b589 e8                                  inx
 18890  b58a 83dfb2                              +lbra savenb                             ; [910925]
 18891                          
 18892                          
 18893                          
 18894                          Sprite_Load
 18895  b58d 20c946                              jsr GetLoadChannel                       ; get a channel      [911001]
 18896  b590 a006                                ldy #>sprite_base
 18897  b592 a900                                lda #<sprite_base
 18898  b594 20fa46                              jsr LoadBlock                            ; load first block
 18899  b597 e65b                                inc highds+1
 18900  b599 20fe46                              jsr LoadBlockNext                        ; load second block
 18901  b59c 83897d                              +lbra list_err                           ; release channel, close file, return to main
 18902                          
 18903                          
 18904                          ;  Set or clear a bit in a VIC register
 18905                          ;
 18906                          ; .X = 1 to set, 0 to clear
 18907                          ; .Y = register in VIC to operate opon
 18908                          
 18909  b59f 8a                 sprbit           txa
 18910  b5a0 4a                                  lsr                                      ; put lsb in .C (0 clear, 1 set sprite bit)
 18911  b5a1 d35b9c                              +lbne fcerr                              ; only 0 or 1, please.
 18912                          ; jsr put_io_in_map
 18913  b5a4 a676                                ldx z_p_temp_1                           ; get sprite number
 18914  b5a6 bd6579                              lda sbits,x
 18915  b5a9 1900d0                              ora vic,y
 18916  b5ac b003                                bcs l286_1
 18917  b5ae 5d6579                              eor sbits,x
 18918  b5b1 9900d0             l286_1           sta vic,y
 18919  b5b4 60                                  rts
 18920                          
 18921                          
 18922                          get_sprite_number
 18923  b5b5 206c5d                              jsr getbyt
 18924                          ; dex        [910221]
 18925  b5b8 e008                                cpx #8
 18926  b5ba b3429c                              +lbcs fcerr
 18927  b5bd 8676                                stx z_p_temp_1
 18928  b5bf 60                                  rts
 18929                          
 18930                          ;.end
 18931                          ;[[command.movspr]]
 18932                          
 18933                          
 18934                          
 18935                          ;****************************************************************
 18936                          ; Move Sprite.  Position sprite and optionally animate it.
 18937                          ;
 18938                          ;   MOVSPR n, [ p | x#y ]   or   MOVSPR n, p1 TO p2, speed
 18939                          ;
 18940                          ;  n = Sprite number (0-7)
 18941                          ; p = (x,y) coordinate.
 18942                          ;  Relative and angular distances  are relative to
 18943                          ;  current sprite position and scaled if scaling is on.
 18944                          ; x#y = Constant movement at an angle-x with speed-y.
 18945                          ;****************************************************************
 18946                          
 18947  b5c0 a900               movspr           lda #0                                   ; flag 'movspr' initial coord   [910808]
 18948  b5c2 8587                                sta op                                   ; (0=movspr, $80=movspr_to, $7f=mouse)
 18949  b5c4 20b5b5                              jsr get_sprite_number                    ; get sprite #
 18950  b5c7 20c3b7                              jsr sprcor                               ; get first coordinate (y,a)
 18951                          movspr_1                                                  ; entry to eval destination coordinate  [910808]
 18952  b5ca 2cf411                              bit numcnt                               ; test coordinate type
 18953  b5cd 737b78                              +lbvs snerr                              ; syntax error
 18954  b5d0 8cf011                              sty xdest                                ; save coordinate value
 18955  b5d3 8cf211                              sty xdest+2
 18956  b5d6 8df111                              sta xdest+1
 18957  b5d9 8df311                              sta xdest+3
 18958                          
 18959  b5dc 20c3b7                              jsr sprcor                               ; get second coordinate (y,a)
 18960  b5df 2cf411                              bit numcnt                               ; test coordinate type & dispatch accordingly
 18961  b5e2 5060                                bvc movspr_normal                        ; normal coordinates
 18962  b5e4 3040                                bmi movspr_angle                         ; angular coordinates
 18963                          
 18964  b5e6 2487                                bit op                                   ; angle#speed, test if allowed
 18965  b5e8 336078                              +lbmi snerr                              ; ng- movspr_to call
 18966  b5eb 5a                                  phy                                      ; ok- save speed value
 18967  b5ec a004                                ldy #xdest-vwork
 18968  b5ee 20b5ba                              jsr getang                               ; get angle of movement
 18969  b5f1 a676                                ldx z_p_temp_1                           ; get sprite number
 18970  b5f3 bcfeb7                              ldy sproff,x                             ; get offset to speed data
 18971  b5f6 a900                                lda #0
 18972  b5f8 990512                              sta sprite_data,y                        ; turn off sprite speed
 18973  b5fb c8                                  iny
 18974                          
 18975  b5fc a203                                ldx #3
 18976  b5fe 5efb11             l287_1           lsr sinval,x
 18977  b601 ca                                  dex
 18978  b602 7efb11                              ror sinval,x
 18979  b605 ca                                  dex
 18980  b606 10f6                                bpl l287_1
 18981                          
 18982  b608 78                 l287_2           sei
 18983  b609 e8                                  inx                                      ; x=0
 18984  b60a bdfa11                              lda angsgn,x                             ; move angle data to speed data
 18985  b60d c8                                  iny
 18986  b60e 990512                              sta sprite_data,y
 18987  b611 e004                                cpx #4
 18988  b613 d0f3                                bne l287_2
 18989                          
 18990  b615 a900                                lda #0                                   ; clear speed angle counts
 18991  b617 c8                 l287_3           iny
 18992  b618 990512                              sta sprite_data,y
 18993  b61b ca                                  dex
 18994  b61c d0f9                                bne l287_3
 18995                          
 18996  b61e 68                                  pla                                      ; restore speed value
 18997  b61f 293f                                and #$3f                                 ; limit range (0-63) ????  [910806]
 18998  b621 99fb11                              sta sprite_data-10,y                     ; start sprite movement
 18999  b624 58                                  cli
 19000  b625 60                                  rts
 19001                          
 19002                          movspr_angle
 19003                          ; jsr swapxy  ;swap y and a (eventually) : y ==> x
 19004                          ; tay   ;        a ==> y
 19005                          ; txa   ;        x ==> a
 19006  b626 48                                  pha
 19007  b627 98                                  tya
 19008  b628 7a                                  ply
 19009                          
 19010  b629 20b8ba                              jsr gtang1                               ; get angle values
 19011                          ; ldx #xdest-vwork
 19012                          ; jsr scalxy  ;scale lengths
 19013  b62c a204                                ldx #xdest-vwork
 19014  b62e 18                                  clc
 19015                          
 19016  b62f 2011bb             l288_1           jsr angmlt                               ; multiply lengths*angles for x and y
 19017  b632 9dec11                              sta vwork,x
 19018  b635 98                                  tya
 19019  b636 9ded11                              sta vwork+1,x
 19020  b639 e8                                  inx
 19021  b63a e8                                  inx
 19022  b63b e006                                cpx #ydest-vwork
 19023  b63d f0f0                                beq l288_1                               ; loop to do y-position
 19024                          
 19025  b63f 6ef411                              ror numcnt                               ; shift in carry to set msb
 19026  b642 8006                                bra movspr_position                      ; go place sprite
 19027                          
 19028                          
 19029                          movspr_normal                                             ; [910122]
 19030  b644 8cf211                              sty xdest+2                              ; save second coordinate (y,a)
 19031  b647 8df311                              sta xdest+3
 19032                          ; ldx #xdest-vwork
 19033                          ; jsr scalxy  ;scale the coordinates
 19034                          
 19035                          
 19036                          movspr_position
 19037  b64a 78                                  sei                                      ; [910123]
 19038  b64b a576                                lda z_p_temp_1                           ; get sprite number
 19039  b64d aa                                  tax                                      ; use as an index
 19040  b64e 0a                                  asl
 19041  b64f a8                                  tay                                      ; get sprite-number * 2 as another index
 19042                          
 19043  b650 7f8701                              bbr7 op,l289_1
 19044  b653 60                                  rts                                      ; >>>exit here if movspr_to call   [910808]
 19045                          
 19046  b654 adf211             l289_1           lda xdest+2                              ; get y-coordinate
 19047  b657 0ef411                              asl numcnt                               ; test if relative
 19048  b65a 9009                                bcc l289_3                               ; skip if absolute
 19049  b65c 18                                  clc
 19050  b65d 1003                                bpl l289_2                               ; skip if normal coordinates
 19051  b65f 49ff                                eor #$ff
 19052  b661 38                                  sec                                      ; invert to subtract if angular
 19053  b662 7901d0             l289_2           adc vic+1,y                              ; add to current sprite y-value  ???vic_save
 19054                          
 19055  b665 9901d0             l289_3           sta vic+1,y                              ; save new sprite y-position  ???vic_save
 19056  b668 adf011                              lda xdest                                ; get low byte of x-coordinate
 19057  b66b 0ef411                              asl numcnt                               ; test if relative
 19058  b66e 1011                                bpl l289_5                               ; skip if absolute
 19059  b670 18                                  clc
 19060  b671 7900d0                              adc vic,y                                ; add current sprite x-position  ???vic_save
 19061  b674 9900d0                              sta vic,y                                ; save sprite x-position   ???vic_save
 19062  b677 b003                                bcs l289_4                               ; skip if carry
 19063  b679 eef111                              inc xdest+1                              ; invert lsb
 19064                          
 19065  b67c ad10d0             l289_4           lda vic+16                               ; get x-position msb bits  ???vic_save
 19066  b67f 8009                                bra l289_6                               ; test if need to invert msb bit
 19067                          
 19068  b681 9900d0             l289_5           sta vic,y                                ; save new sprite x-position  ???vic_save
 19069  b684 ad10d0                              lda vic+16                               ; ???vic_save
 19070  b687 1d6579                              ora sbits,x                              ; set x-position msb bit
 19071                          
 19072  b68a 4ef111             l289_6           lsr xdest+1                              ; match to lsb of x-coordinate high byte
 19073  b68d b003                                bcs l289_7                               ; skip if should be set
 19074  b68f 5d6579                              eor sbits,x                              ; reset bit
 19075                          
 19076  b692 8d10d0             l289_7           sta vic+16                               ; save position msb bits   ???vic_save
 19077                          ; cli
 19078                          ;1l289_1 rts   ; mouse or movspr_to
 19079                          
 19080                          
 19081                          movspr_to                                                 ; setup for moving sprite to a particular position
 19082                          ;we have already positioned the sprite onscreen
 19083  b695 208522                              jsr chrgot                               ; reget terminating character
 19084  b698 c9a4                                cmp #to_token
 19085  b69a f002                                beq l290_1                               ; not our call
 19086  b69c 58                                  cli
 19087  b69d 60                                  rts
 19088                          
 19089  b69e f787               l290_1           smb7 op                                  ; it's for us- let everybody else know we're in charge
 19090  b6a0 208322                              jsr chrget                               ; move to next non-space character
 19091  b6a3 18                                  clc
 19092  b6a4 20c6b7                              jsr sprcor_1                             ; go get & evaluate destination coordinate
 19093  b6a7 20cab5                              jsr movspr_1                             ; returns with sprite# in .x, VIC sprite index in .y,
 19094                          ;P1 in VIC sprite regs, and P2 in x,ydest
 19095  b6aa 0ef411                              asl numcnt                               ; Y: handle specific coordinate types
 19096  b6ad 900f                                bcc l290_3                               ; skip if absolute
 19097  b6af 18                                  clc
 19098  b6b0 adf211                              lda xdest+2                              ; get y-coordinate
 19099  b6b3 1003                                bpl l290_2                               ; skip if normal coordinates
 19100  b6b5 49ff                                eor #$ff
 19101  b6b7 38                                  sec                                      ; invert to subtract if angular
 19102  b6b8 7901d0             l290_2           adc vic+1,y                              ; add to current sprite y-value ???vic_save
 19103  b6bb 8df211                              sta xdest+2                              ; save sprite destination y-position
 19104                          
 19105  b6be 0ef411             l290_3           asl numcnt                               ; X: handle specific coordinate types
 19106  b6c1 100f                                bpl l290_4                               ; skip if absolute
 19107  b6c3 18                                  clc
 19108  b6c4 adf011                              lda xdest                                ; get low byte of x-coordinate
 19109  b6c7 7900d0                              adc vic,y                                ; add current sprite x-position  ???vic_save
 19110  b6ca 8df011                              sta xdest                                ; save sprite destination x-position
 19111  b6cd 9003                                bcc l290_4
 19112  b6cf eef111                              inc xdest+1
 19113                          
 19114  b6d2 5a                 l290_4           phy
 19115  b6d3 20825d                              jsr combyt                               ; get speed parameter
 19116  b6d6 8a                                  txa
 19117  b6d7 293f                                and #$3f                                 ; limit range (0-63) ????
 19118  b6d9 0980                                ora #$80
 19119  b6db 8d8411                              sta xcnt                                 ; save in temp.
 19120  b6de 7a                                  ply
 19121                          
 19122  b6df b900d0                              lda vic,y                                ; copy current sprite pos'n to line vars
 19123  b6e2 8dec11                              sta xpos                                 ; in preparation for line calculations
 19124  b6e5 b901d0                              lda vic+1,y
 19125  b6e8 8dee11                              sta ypos
 19126  b6eb a900                                lda #0
 19127  b6ed 8ded11                              sta xpos+1
 19128  b6f0 8def11                              sta ypos+1
 19129  b6f3 98                                  tya
 19130  b6f4 4a                                  lsr
 19131  b6f5 a8                                  tay
 19132  b6f6 b96579                              lda sbits,y
 19133  b6f9 2d10d0                              and vic+16
 19134  b6fc f003                                beq l290_5
 19135  b6fe eeed11                              inc xpos+1
 19136                          l290_5
 19137                          
 19138                          ;******************************************************************
 19139                          ;  MOVSPR n, p1 TO p2 - move a sprite along line from p1 to p2
 19140                          ;
 19141                          ; The following is performed now:
 19142                          ;
 19143                          ;           absx    = abs(destx-posx) : absy = abs(desty-posy)
 19144                          ;           sgnx    = sgn(destx-posx) : sgny = sgn(desty-posy)
 19145                          ;                     ( sgn=(1,0,-1) if (+,0,-) )
 19146                          ;           greatr  = index to the greatr of absx,absy
 19147                          ;           lesser  = index to the smaller of absx,absy
 19148                          ;
 19149                          ;           fct1    = 2*min(absx,absy)
 19150                          ;           fct2    = fct1 - 2*max(absx,absy)
 19151                          ;           error   = fct1 - max(absx,absy)
 19152                          ;
 19153                          ; The following is performed during IRQ:
 19154                          ;
 19155                          ;           for i:= 1 to max(absx,absy) do begin
 19156                          ;                 movspr n, posx, posy
 19157                          ;                 if error > 0 then begin
 19158                          ;                      pos(lesser):= pos(lesser) + sgn(lesser)
 19159                          ;                      error:= error + fct2
 19160                          ;                      end
 19161                          ;                      else error:= error + fct1
 19162                          ;                 pos(greatr):= pos(greatr) + sgn(greatr)
 19163                          ;           end;
 19164                          ;
 19165                          ; (modification of C128 Bresenham DrawLn algorithm 910808 F.Bowen)
 19166                          ;******************************************************************
 19167                          
 19168                          movspr_line
 19169  b701 a202                                ldx #ypos-vwork
 19170  b703 a006                                ldy #ydest-vwork
 19171  b705 a900               l291_1           lda #0
 19172  b707 9d9511                              sta xsgn,x                               ; init direction pointers
 19173  b70a 9d9611                              sta xsgn+1,x
 19174  b70d 207fbb                              jsr abstwo                               ; get absolute value of coordinate differences
 19175  b710 1008                                bpl l291_2                               ; and determine direction
 19176  b712 de9511                              dec xsgn,x                               ; negative direction
 19177  b715 de9611                              dec xsgn+1,x
 19178  b718 800b                                bra l291_4
 19179                          
 19180  b71a c900               l291_2           cmp #0
 19181  b71c d004                                bne l291_3
 19182  b71e c000                                cpy #0
 19183  b720 f003                                beq l291_4                               ; zero direction
 19184  b722 fe9511             l291_3           inc xsgn,x                               ; positive direction
 19185  b725 9d9111             l291_4           sta xabs,x
 19186  b728 0a                                  asl
 19187  b729 9d9911                              sta fct,x                                ; fct(x,y) = 2*abs(x,y)
 19188  b72c 98                                  tya
 19189  b72d 9d9211                              sta xabs+1,x
 19190  b730 2a                                  rol
 19191  b731 9d9a11                              sta fct+1,x
 19192  b734 ca                                  dex
 19193  b735 ca                                  dex
 19194  b736 a004                                ldy #xdest-vwork                         ; loop to do in x-direction
 19195  b738 e000                                cpx #xpos-vwork
 19196  b73a f0c9                                beq l291_1
 19197                          
 19198  b73c a202                                ldx #yabs-savram                         ; determine max(xabs,yabs)
 19199  b73e a000                                ldy #xabs-savram
 19200  b740 205cbb                              jsr subtwo_savram
 19201  b743 a900                                lda #0
 19202  b745 2a                                  rol
 19203  b746 2a                                  rol                                      ; a = c * 2
 19204  b747 8d0312                              sta lesser                               ; index to smaller delta
 19205  b74a 4902                                eor #2
 19206  b74c 8d0412                              sta greatr                               ; index to greater delta
 19207                          
 19208  b74f 18                                  clc
 19209  b750 a908                                lda #fct-savram
 19210  b752 6d0312                              adc lesser
 19211  b755 48                                  pha
 19212  b756 a8                                  tay
 19213  b757 4902                                eor #2
 19214  b759 aa                                  tax
 19215  b75a 205cbb                              jsr subtwo_savram                        ; fct(greatr) = fct(lesser)-fct(greatr)
 19216  b75d 9d9111                              sta savram,x
 19217  b760 8b9211                              sty savram+1,x
 19218                          
 19219  b763 7a                                  ply                                      ; fct(lesser)
 19220  b764 18                                  clc
 19221  b765 a900                                lda #xabs-savram
 19222  b767 6d0412                              adc greatr
 19223  b76a aa                                  tax
 19224  b76b 205cbb                              jsr subtwo_savram                        ; error = fct(lesser) - abs(greatr)
 19225  b76e 8d9d11                              sta errval
 19226  b771 8c9e11                              sty errval+1
 19227                          
 19228                          ; At this point, we've positioned the sprite at the start position, and have
 19229                          ; calculated everything we need to move it along a line towards the destination
 19230                          ; position.  All that's left is to copy the working vars into the sprite_data
 19231                          ; tables where the IRQ routine can find & diddle with our data.
 19232                          ;
 19233                          ;    move ang/dist move line
 19234                          ;  offset= 0 b7=0+speed b7=1+speed
 19235                          ;   1 counter  counter lo
 19236                          ;   2 angle sign         hi
 19237                          ;   3,4 delta-X  dir+min/max
 19238                          ;   5,6 delta-Y  fct1
 19239                          ;   7,8 total-X  fct2
 19240                          ;   9,10 total-Y  error
 19241                          
 19242  b774 a476                                ldy z_p_temp_1                           ; sprite #
 19243  b776 befeb7                              ldx sproff,y                             ; sprite IRQ table offset
 19244                          
 19245  b779 ad8411                              lda xcnt                                 ; set speed factor
 19246  b77c 9d0512                              sta sprite_data,x
 19247  b77f ac0412                              ldy greatr
 19248  b782 b99111                              lda xabs,y                               ; set counter = max(xyabs)
 19249  b785 9d0612                              sta sprite_data+1,x
 19250  b788 b99211                              lda xabs+1,y
 19251  b78b 9d0712                              sta sprite_data+2,x
 19252  b78e b99511                              lda xsgn,y                               ; set dir(max) and max
 19253  b791 199611                              ora xsgn+1,y
 19254  b794 2903                                and #3
 19255  b796 4a                                  lsr
 19256  b797 6a                                  ror
 19257  b798 0d0412                              ora greatr
 19258  b79b 6a                                  ror
 19259  b79c 9d0912                              sta sprite_data+4,x
 19260  b79f ac0312                              ldy lesser
 19261  b7a2 b99511                              lda xsgn,y                               ; set dir(min) and min
 19262  b7a5 199611                              ora xsgn+1,y
 19263  b7a8 2903                                and #3
 19264  b7aa 4a                                  lsr
 19265  b7ab 6a                                  ror
 19266  b7ac 0d0312                              ora lesser
 19267  b7af 6a                                  ror
 19268  b7b0 9d0812                              sta sprite_data+3,x
 19269  b7b3 a000                                ldy #0                                   ; set f1, f2, and e
 19270  b7b5 b99911             l291_5           lda fct,y
 19271  b7b8 9d0a12                              sta sprite_data+5,x
 19272  b7bb e8                                  inx
 19273  b7bc c8                                  iny
 19274  b7bd c006                                cpy #6
 19275  b7bf 90f4                                bcc l291_5
 19276                          
 19277  b7c1 58                                  cli
 19278  b7c2 60                                  rts                                      ; done!
 19279                          
 19280                          ;[[command.sprcor]]
 19281                          
 19282                          
 19283                          ;  SPRCOR  -- Get sprite position coordinate
 19284                          ;
 19285                          
 19286  b7c3 20ebb7             sprcor           jsr chkcom_1                             ; check for a comma
 19287                          sprcor_1
 19288  b7c6 6ef411                              ror numcnt                               ; reset msb if comma else set msb
 19289  b7c9 100b                                bpl l292_1                               ; skip if got a comma
 19290  b7cb c93b                                cmp #';'                                 ; test if angular data
 19291  b7cd f013                                beq l292_3                               ; skip if yes - 2 msb's = 1 1
 19292  b7cf c923                                cmp #'#'                                 ; test if speed type
 19293  b7d1 f00e                                beq l292_2                               ; skip if yes - 2 msb's = 0 1
 19294  b7d3 837576                              +lbra snerr                              ; syntax error if none of above
 19295                          
 19296  b7d6 208522             l292_1           jsr chrgot                               ; test for relative coordinate
 19297  b7d9 c9aa                                cmp #plus_token                          ; test if plus sign
 19298  b7db f005                                beq l292_3                               ; skip if yes - show relative
 19299  b7dd c9ab                                cmp #minus_token                         ; test if minus sign
 19300  b7df f001                                beq l292_3                               ; skip if yes - show relative
 19301  b7e1 18                 l292_2           clc                                      ; reset to show absolute
 19302  b7e2 6ef411             l292_3           ror numcnt                               ; shift in second flag bit
 19303                          
 19304  b7e5 20d84c             sadwrd           jsr frmnum                               ; get number     label [910307]
 19305  b7e8 83a8a5                              +lbra getsad                             ; get signed 2 byte coordinate,do rts
 19306                          
 19307                          
 19308                          ;*************************************************************
 19309                          ; CHKCOM_1  --  Check for a comma
 19310                          ;
 19311                          ;  carry set & eq = end of string
 19312                          ;  carry set & neq = not a comma
 19313                          ;  carry clear = a comma
 19314                          ;*************************************************************
 19315                          
 19316                          chkcom_1
 19317  b7eb 208522                              jsr chrgot                               ; get character in input stream
 19318  b7ee f00d                                beq l293_2                               ; skip if end of string
 19319  b7f0 c92c                                cmp #','                                 ; check if a comma
 19320  b7f2 18                                  clc
 19321  b7f3 f001                                beq l293_1                               ; skip if yes
 19322  b7f5 38                                  sec                                      ; set carry if not
 19323  b7f6 08                 l293_1           php
 19324  b7f7 48                                  pha
 19325  b7f8 208322                              jsr chrget                               ; move to next non-space character
 19326  b7fb 68                                  pla
 19327  b7fc 28                                  plp
 19328  b7fd 60                 l293_2           rts
 19329                          
 19330                          
 19331  b7fe 000b16212c37424d   sproff           !text 0,11,22,33,44,55,66,77             ; sprite offsets into speed table
 19332                          
 19333                          ;.end
 19334                          ;[[command.sprcolor]]
 19335                          
 19336                          
 19337                          
 19338                          ;**************************************************************
 19339                          ;*
 19340                          ;*   SPRCOLOR - Set sprite multicolor registers
 19341                          ;*
 19342                          ;* syntax : SPRCOLOR [multicolor_1] [,multicolor_2]
 19343                          ;*
 19344                          ;**************************************************************
 19345                          
 19346                          sprcolor
 19347  b806 c92c                                cmp #','                                 ; is there a first arg?
 19348  b808 f006                                beq l294_1                               ; nope, skip to second
 19349                          
 19350  b80a 200db5                              jsr getnyb                               ; get 1 byte arg in .X, range 0-15
 19351                          ; jsr put_io_in_map
 19352  b80d 8e25d0                              stx vic+37
 19353                          
 19354  b810 202679             l294_1           jsr optbyt                               ; get (optional) 1 byte arg in .X
 19355  b813 9006                                bcc l294_2
 19356  b815 2010b5                              jsr chknyb                               ; range 0-15
 19357                          ; jsr put_io_in_map
 19358  b818 8e26d0                              stx vic+38
 19359                          
 19360  b81b 60                 l294_2           rts
 19361                          
 19362                          ;.end
 19363                          
 19364                          
 19365                          
 19366                          ;***************************************************************
 19367                          ;  SPRSAV ( n1 / s1$ ) , ( n2 / s2$ )
 19368                          ;   - move string(s1) or sprite(n1) to string(s2) or sprite(n2)
 19369                          ;               n1 & n2 = a sprite number (1-8)
 19370                          ;                   s1$ = a string variable or expression
 19371                          ;                   s2$ = a string variable
 19372                          ;***************************************************************
 19373                          
 19374  b81c 20a9b8             sprsav           jsr savinp                               ; evaluate 1st expression
 19375  b81f b02f                                bcs l295_2                               ; skip if source is a string
 19376  b821 854b                                sta forpnt
 19377  b823 844c                                sty forpnt+1                             ; save sprite address
 19378  b825 a03e                                ldy #62
 19379                          
 19380  b827 b14b               l295_1           lda (forpnt),y                           ; move sprite def to save area
 19381  b829 999111                              sta savram,y
 19382  b82c 88                                  dey
 19383  b82d 10f8                                bpl l295_1
 19384                          
 19385  b82f c8                                  iny                                      ; (0)
 19386  b830 8cd111                              sty savram+64                            ; save sprite column length
 19387  b833 8cd311                              sty savram+66                            ; save sprite row length
 19388  b836 a917                                lda #23
 19389  b838 8dd011                              sta savram+63
 19390  b83b a914                                lda #20
 19391  b83d 8dd211                              sta savram+65
 19392  b840 a291                                ldx #<savram                             ; set ptr to start of sprite def
 19393  b842 a011                                ldy #>savram
 19394  b844 8670                                stx strng1                               ; **
 19395  b846 8471                                sty strng1+1                             ; **
 19396                          
 19397  b848 a943                                lda #67                                  ; set sprite length including lengths
 19398  b84a 20b75a                              jsr strlit_1                             ; **get string space, copy savram to it
 19399  b84d 20c2b8                              jsr desc_free                            ; **free up temp descriptor
 19400                          
 19401  b850 8eff11             l295_2           stx savsiz                               ; save source length
 19402  b853 8d0012                              sta savsiz+1
 19403  b856 8c0112                              sty savsiz+2                             ; save source start address
 19404                          
 19405  b859 205b4e                              jsr chkcom                               ; check for a comma
 19406  b85c a53d                                lda txtptr                               ; save basic text pointer
 19407  b85e 8d0312                              sta sprtmp_1
 19408  b861 a53e                                lda txtptr+1
 19409  b863 8d0412                              sta sprtmp_2
 19410  b866 20a9b8                              jsr savinp                               ; get next destination parameter
 19411  b869 b022                                bcs savs50                               ; skip if string
 19412                          
 19413  b86b 8587                                sta grapnt
 19414  b86d 8488                                sty grapnt+1                             ; save sprite address
 19415  b86f ad0012                              lda savsiz+1
 19416  b872 854b                                sta forpnt                               ; get source address
 19417  b874 ad0112                              lda savsiz+2
 19418  b877 854c                                sta forpnt+1
 19419  b879 a000                                ldy #0
 19420  b87b ccff11             l295_3           cpy savsiz                               ; test index vs source length
 19421  b87e f00c                                beq l295_4                               ; exit if source depleted
 19422  b880 a94b                                lda #forpnt                              ; move source byte to sprite
 19423  b882 20d722                              jsr lda_far_ram1                         ; (from ram bank 1)
 19424                          ; sta sw_rom_ram0
 19425  b885 9187                                sta (grapnt),y                           ; (to sprite area in bank 0)????
 19426  b887 c8                                  iny
 19427  b888 c03f                                cpy #63
 19428  b88a d0ef                                bne l295_3
 19429  b88c 60                 l295_4           rts
 19430                          
 19431                          
 19432  b88d ad0312             savs50           lda sprtmp_1                             ; restore basic text pointer
 19433  b890 853d                                sta txtptr
 19434  b892 ad0412                              lda sprtmp_2
 19435  b895 853e                                sta txtptr+1
 19436  b897 207c4f                              jsr ptrget                               ; get symbol table descriptor for string dest.
 19437  b89a 854b                                sta forpnt
 19438  b89c 844c                                sty forpnt+1                             ; save symbol table address
 19439  b89e a9ff                                lda #<savsiz
 19440  b8a0 8566                                sta facmo                                ; save descriptor address of source
 19441  b8a2 a911                                lda #>savsiz
 19442  b8a4 8567                                sta facmo+1
 19443  b8a6 830d7e                              +lbra inpcom                             ; move source to dest, do rts (snerr if not eol)
 19444                          
 19445                          
 19446  b8a9 20ef4c             savinp           jsr frmevl                               ; evaluate expression
 19447  b8ac ff0f13                              bbs7 valtyp,desc_free                    ; exit if a string
 19448  b8af 206f5d                              jsr conint                               ; get one byte integer in .X
 19449                          ; dex    ;adjust sprite 1..8 to 0..7  [910220]
 19450  b8b2 e008                                cpx #8
 19451  b8b4 b34899                              +lbcs fcerr                              ; bad value
 19452  b8b7 8a                                  txa                                      ; move sprite number to .A
 19453  b8b8 4a                                  lsr
 19454  b8b9 6a                                  ror
 19455  b8ba 6a                                  ror                                      ; get sprite address
 19456  b8bb a006                                ldy #>sprite_base
 19457  b8bd 9001                                bcc l296_1
 19458  b8bf c8                                  iny
 19459  b8c0 18                 l296_1           clc                                      ; flag 'sprite' (as opposed to 'string')
 19460  b8c1 60                                  rts
 19461                          
 19462                          
 19463                          desc_free                                                 ; free temporary descriptor, set up pointers to string.
 19464  b8c2 a566                                lda facmo                                ; get address of temp descriptor
 19465  b8c4 a467                                ldy facmo+1
 19466  b8c6 20cc5b                              jsr fretms
 19467  b8c9 a000                                ldy #0                                   ; get len, addr of string
 19468  b8cb 20a922                              jsr indfmo
 19469  b8ce aa                                  tax
 19470  b8cf c8                                  iny
 19471  b8d0 20a922                              jsr indfmo
 19472  b8d3 48                                  pha
 19473  b8d4 c8                                  iny
 19474  b8d5 20a922                              jsr indfmo
 19475  b8d8 a8                                  tay
 19476  b8d9 68                                  pla
 19477  b8da 38                                  sec                                      ; flag 'string found'
 19478  b8db 60                                  rts                                      ; return w/ x=len, (a,y)==> string
 19479                          
 19480                          ;.end
 19481                          ;[[command.collision]]
 19482                          
 19483                          
 19484                          
 19485                          ;*****************************************************************
 19486                          ; COLLISION Command
 19487                          ;
 19488                          ; Syntax:  COLLISION n [,address]
 19489                          ;
 19490                          ; Where:   n= 1 ==> sprite / sprite
 19491                          ;   2 ==> sprite / background
 19492                          ;   3 ==> light pen
 19493                          ;
 19494                          ; Address ==> BASIC line number to trap to on interrupt
 19495                          ;      (no address ==> disable trapping)
 19496                          ;*****************************************************************
 19497                          
 19498                          collision
 19499  b8dc 206c5d                              jsr getbyt                               ; get type in .X
 19500  b8df ca                                  dex                                      ; adjust 1..3 to 0..2
 19501  b8e0 e003                                cpx #3
 19502  b8e2 b31a99                              +lbcs fcerr                              ; value error
 19503                          
 19504  b8e5 da                                  phx                                      ; save collision type
 19505  b8e6 20f278                              jsr optwrd                               ; get address (line number) in .Y,.A (optional)
 19506  b8e9 fa                                  plx
 19507                          ; php   ;save .C (.C == 1 ==> real value)
 19508  b8ea 9de302                              sta int_adr_hi,x                         ; save address given
 19509  b8ed 8be002                              sty int_adr_lo,x
 19510                          
 19511  b8f0 addc02                              lda intval                               ; this records valid interrupts
 19512  b8f3 1d6579                              ora sbits,x                              ; set correct bit
 19513                          ; plp
 19514  b8f6 b003                                bcs l297_1                               ; ..unless this is a 'clear',
 19515  b8f8 5d6579                              eor sbits,x                              ; ..in which case we'll reset bit
 19516  b8fb 8ddc02             l297_1           sta intval
 19517  b8fe 60                                  rts
 19518                          
 19519                          ;.end
 19520                          ;[[function.rcolor]]
 19521                          
 19522                          
 19523                          
 19524                          ;************************************************************************
 19525                          ;  RCOLOR (source)  --  return current color assigned to source
 19526                          ;   0  :  Background color
 19527                          ;   1  :  Foreground color
 19528                          ;   2  :  Highlight color
 19529                          ;   3  :  Border color
 19530                          ;************************************************************************
 19531                          
 19532  b8ff 206f5d             rcolor           jsr conint                               ; evaluate integer argument, put in .X
 19533                          ; jsr put_io_in_map
 19534                          
 19535  b902 e004                                cpx #4
 19536  b904 b3f898                              +lbcs fcerr                              ; illegal qty
 19537  b907 8a                                  txa
 19538  b908 0a                                  asl                                      ; make into word pointer
 19539  b909 aa                                  tax
 19540  b90a bd1eb9                              lda color_source,x                       ; get address of source
 19541  b90d 8587                                sta grapnt
 19542  b90f bd1fb9                              lda color_source+1,x
 19543  b912 8588                                sta grapnt+1
 19544  b914 a000                                ldy #0
 19545  b916 b187                                lda (grapnt),y                           ; read source (aways system space or I/O????)
 19546  b918 290f                                and #$0f                                 ; mask unused bits
 19547  b91a a8                                  tay
 19548                          ; iny   ; make color match keytops
 19549  b91b 83b59f                              +lbra sngflt                             ; float 1 byte in .Y
 19550                          
 19551                          color_source
 19552  b91e 21d0f100d80220d0                    !word vic+33,_color,highlight_color,vic+32
 19553                          
 19554                          ;[[function.rgraphic]]
 19555                          
 19556                          
 19557                          
 19558                          ; Return graphic screen status & parameters      [910826]
 19559                          ; RGRAPHIC (screen, param) where param = 0 open (1), closed (0), or invalid (>1)
 19560                          ;            1 width  (0=320, 1=640, 2=1280)
 19561                          ;            2 height (0=200, 1=400)
 19562                          ;            3 depth (1-8 bitplanes)
 19563                          ;            4 bitplanes used  (bitmask)
 19564                          ;            5 bank A blocks used (bitmask)
 19565                          ;            6 bank B blocks used (bitmask)
 19566                          ;            7 drawscreen # (0-3)
 19567                          ;            8 viewscreen # (0-3)
 19568                          ;            9 drawmodes  (bitmask)
 19569                          ;           10 pattern type  (bitmask)
 19570                          ;
 19571                          ; Requires a kludge, because RGR used to be a normal 1-arg function in the C128
 19572                          ; but now it takes two args.
 19573                          
 19574                          rgraphic
 19575                          ; jsr CheckGraphicMode ;verify screen open
 19576  b926 68                                  pla                                      ; remove token from stack
 19577  b927 20e8b9                              jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820]
 19578                          
 19579  b92a 20584e                              jsr chkopn                               ; check for open paren
 19580  b92d 206c5d                              jsr getbyt                               ; get screen # in .X
 19581  b930 8e001f                              stx GKI__parm1
 19582  b933 20825d                              jsr combyt                               ; get param # in .X
 19583  b936 e00b                                cpx #10+1                                ; [911028]
 19584  b938 b007                                bcs l298_1                               ; illegal param #
 19585  b93a da                                  phx
 19586  b93b 20554e                              jsr chkcls                               ; check for closing parens
 19587                          
 19588  b93e 223880                              jsr ($8038)                              ; read screen params
 19589  b941 b3bb98             l298_1           +lbcs fcerr                              ; bad input????
 19590                          
 19591  b944 ad011f                              lda GKI__parm2
 19592  b947 fa                                  plx                                      ; get back desired param #
 19593  b948 ca                                  dex
 19594  b949 1006                                bpl l298_2
 19595  b94b 4980                                eor #$80                                 ; make 0=closed, 1=open, >1=invalid
 19596  b94d 4a                                  lsr
 19597  b94e 4a                                  lsr
 19598  b94f 8003                                bra l298_3                               ; return screen open status
 19599                          
 19600  b951 ca                 l298_2           dex
 19601  b952 1008                                bpl l298_5
 19602  b954 4a                 l298_3           lsr
 19603  b955 4a                 l298_4           lsr
 19604  b956 4a                                  lsr
 19605  b957 4a                                  lsr
 19606  b958 2903                                and #3
 19607  b95a 8012                                bra l298_8                               ; return width, height
 19608                          
 19609  b95c ca                 l298_5           dex
 19610  b95d 1004                                bpl l298_6
 19611  b95f 2908                                and #8
 19612  b961 80f2                                bra l298_4
 19613  b963 ca                 l298_6           dex
 19614  b964 1005                                bpl l298_7
 19615  b966 2907                                and #7                                   ; return depth
 19616  b968 1a                                  inc                                      ; make depth 1-8
 19617  b969 8003                                bra l298_8
 19618                          
 19619  b96b bd021f             l298_7           lda GKI__parm3,x                         ; return bp bask, banks, etc.
 19620  b96e a8                 l298_8           tay
 19621  b96f 20d258                              jsr sngflt                               ; float 1 byte arg in .y
 19622                          
 19623  b972 20f9b9                              jsr PopParms                             ; restore Graphics parameters & LINNUM
 19624  b975 60                                  rts
 19625                          
 19626                          ;[[function.pixel]]
 19627                          
 19628                          ; Return the color of a given X,Y pixel location on the drawscreen  [910801]
 19629                          ;  PIXEL (x,y)
 19630                          
 19631  b976 201caf             pixel            jsr CheckGraphicMode                     ; verify screen open
 19632  b979 20e8b9                              jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820]
 19633                          
 19634  b97c 20925d                              jsr getsad                               ; get x
 19635  b97f 8c001f                              sty GKI__parm1
 19636  b982 8d011f                              sta GKI__parm2
 19637  b985 200879                              jsr comsad                               ; get y
 19638  b988 8c021f                              sty GKI__parm3
 19639  b98b 8d031f                              sta GKI__parm4
 19640  b98e 20554e                              jsr chkcls                               ; check for closing parens
 19641                          
 19642  b991 223280                              jsr ($8032)                              ; get Bitplane data at pixel (x,y), returned in .y
 19643  b994 20d258                              jsr sngflt                               ; go float 1 byte arg in .Y
 19644                          
 19645  b997 20f9b9                              jsr PopParms                             ; restore graphics parameters
 19646  b99a 60                                  rts
 19647                          
 19648                          ;[[function.rpen]]
 19649                          
 19650                          ; Return the color of a drawscreen's PEN      [910820]
 19651                          ;  RPEN (pen#) where pen# = 0,1,2
 19652                          
 19653  b99b 201caf             rpen             jsr CheckGraphicMode                     ; verify screen open
 19654  b99e 20e8b9                              jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820]
 19655                          
 19656  b9a1 206f5d                              jsr conint                               ; get 1 byte arg in .x (old style single arg function)
 19657  b9a4 e003                                cpx #3
 19658  b9a6 b006                                bcs l299_1                               ; illegal pen #?
 19659  b9a8 8e001f                              stx GKI__parm1
 19660                          
 19661  b9ab 223680                              jsr ($8036)                              ; convert to logical color# (palette index#)
 19662  b9ae b34e98             l299_1           +lbcs fcerr                              ; drawscreen not set or illegal quantity somewhere
 19663                          
 19664  b9b1 20d258                              jsr sngflt                               ; go float 1 byte arg in .Y
 19665                          
 19666  b9b4 20f9b9                              jsr PopParms                             ; restore graphics parameters
 19667  b9b7 60                                  rts
 19668                          
 19669                          
 19670                          ;[[function.rpalette]]
 19671                          ; Return the R,G, or B component of a color     [910820]
 19672                          ; RPALETTE (screen#, color#, rgb)
 19673                          
 19674                          rpalette
 19675  b9b8 201caf                              jsr CheckGraphicMode                     ; verify screen open
 19676  b9bb 20e8b9                              jsr PushParms                            ; Save graphics parameters
 19677                          
 19678  b9be 206f5d                              jsr conint                               ; get screen# in .x
 19679  b9c1 e004                                cpx #4
 19680  b9c3 b013                                bcs l300_1                               ; illegal screen#
 19681  b9c5 8e001f                              stx GKI__parm1
 19682                          
 19683  b9c8 20825d                              jsr combyt                               ; get color# in .x ????check for legal color#
 19684  b9cb 8e011f                              stx GKI__parm2
 19685                          
 19686  b9ce 223480                              jsr ($8034)                              ; get RGB components of color# in PARM3,4,5
 19687  b9d1 b005                                bcs l300_1                               ; something is wrong????
 19688                          
 19689  b9d3 20825d                              jsr combyt                               ; get r,g,b component#
 19690  b9d6 e003                                cpx #3
 19691  b9d8 b32498             l300_1           +lbcs fcerr                              ; illegal value
 19692                          
 19693  b9db bc021f                              ldy GKI__parm3,x                         ; get r,g,b value
 19694  b9de 20d258                              jsr sngflt                               ; float 1 byte arg in .y
 19695                          
 19696  b9e1 20554e                              jsr chkcls                               ; check for closing paren
 19697  b9e4 20f9b9                              jsr PopParms                             ; restore graphics parameters
 19698  b9e7 60                                  rts
 19699                          
 19700                          
 19701                          PushParms                                                 ; [910820]
 19702  b9e8 7a                                  ply                                      ; Grab return address
 19703  b9e9 fb                                  plz
 19704                          
 19705  b9ea fc1600                              phw linnum                               ; Save 'poker' value
 19706                          
 19707  b9ed a210                                ldx #17-1
 19708  b9ef bd001f             l301_1           lda GKI__parm1,x                         ; Save Graphics parameters
 19709  b9f2 48                                  pha                                      ; [eg: CHAR x,y,1,1,2,str$(PIXEL(x,y))]
 19710  b9f3 ca                                  dex
 19711  b9f4 10f9                                bpl l301_1
 19712                          
 19713  b9f6 db                                  phz                                      ; Restore return address
 19714  b9f7 5a                                  phy
 19715  b9f8 60                                  rts
 19716                          
 19717                          
 19718                          PopParms                                                  ; [910820]
 19719  b9f9 7a                                  ply                                      ; Grab return address
 19720  b9fa fb                                  plz
 19721                          
 19722  b9fb a200                                ldx #0
 19723  b9fd 68                 l302_1           pla                                      ; Restore Graphics parameters
 19724  b9fe 9d001f                              sta GKI__parm1,x
 19725  ba01 e8                                  inx
 19726  ba02 e011                                cpx #17
 19727  ba04 90f7                                bcc l302_1
 19728                          
 19729  ba06 68                                  pla                                      ; Restore 'poker' value
 19730  ba07 8517                                sta linnum+1
 19731  ba09 68                                  pla
 19732  ba0a 8516                                sta linnum
 19733                          
 19734  ba0c db                                  phz                                      ; Restore return address
 19735  ba0d 5a                                  phy
 19736  ba0e 60                                  rts
 19737                          
 19738                          ;.end
 19739                          ;[[function.rsprite]]
 19740                          
 19741                          
 19742                          
 19743                          ;******************************************************************
 19744                          ;* RSPRITE - Return sprite information
 19745                          ;*
 19746                          ;* Syntax : RSPRITE (sprite_number, argument)
 19747                          ;*
 19748                          ;* Where  : sprite_number = [0..7]
 19749                          ;*   argument = [0..5]
 19750                          ;*   0 : enabled?   (y(1)/n(0))
 19751                          ;*   1 : color?     (0-15)
 19752                          ;*   2 : priority over background? (y(1)/n(0))
 19753                          ;*   3 : expand in x direction? (y(1)/n(0))
 19754                          ;*   4 : expand in Y direction? (y(1)/n(0))
 19755                          ;*   5 : multicolor sprite?  (y(1)/n(0))
 19756                          ;******************************************************************
 19757                          
 19758  ba0f 206f5d             rsprite          jsr conint                               ; get first arg, sprite #, in .X
 19759                          ; dex  ;adjust [1..8] to [0..7]   [910220]
 19760  ba12 e008                                cpx #8  ; (318018-03 mod                 ; fab)
 19761  ba14 b00a                                bcs l303_1                               ; value error
 19762  ba16 8a                                  txa
 19763  ba17 48                                  pha                                      ; save sprite number
 19764                          
 19765                          ; jsr chkcom ;check for proper delimiter
 19766                          ; jsr getbyt ;do frmevl, get 1 byte arg (arg) in .X
 19767  ba18 20825d                              jsr combyt                               ; [910820]
 19768  ba1b 20554e                              jsr chkcls                               ; look for closing paren
 19769  ba1e e006                                cpx #6
 19770  ba20 b3dc97             l303_1           +lbcs fcerr                              ; value error
 19771                          
 19772  ba23 7a                                  ply                                      ; sprite number
 19773                          ; jsr put_io_in_map
 19774  ba24 b927d0                              lda vic+39,y                             ; assume 'color'
 19775  ba27 290f                                and #$0f                                 ; range 0-15
 19776                          ; inc a  ;adjust to 'keyboard' colors   [910724]
 19777  ba29 e001                                cpx #1
 19778  ba2b f00e                                beq l303_2                               ; it was color. set up for float
 19779                          
 19780  ba2d bd3fba                              lda rspmod,x                             ; get index for this function
 19781  ba30 aa                                  tax
 19782  ba31 b96579                              lda sbits,y                              ; get mask for this sprite number
 19783  ba34 3d00d0                              and vic,x
 19784  ba37 f002                                beq l303_2
 19785  ba39 a901                                lda #1                                   ; return all non-zeros as '1'
 19786                          
 19787  ba3b a8                 l303_2           tay
 19788  ba3c 83949e                              +lbra sngflt                             ; go float 1 byte arg in .Y
 19789                          
 19790                          
 19791  ba3f 15271b1d171c       rspmod           !text 21,39,27,29,23,28                  ; VIC registers associated with arg#
 19792                          
 19793                          ;.end
 19794                          
 19795                          
 19796                          
 19797                          ;******************************************************************
 19798                          ;* RSPCOLOR - return sprite multicolor reg's
 19799                          ;*
 19800                          ;* Syntax : RSPCOLOR (argument)
 19801                          ;*
 19802                          ;* Where  : argument = [1..2]
 19803                          ;*   1 : return multicolor #1
 19804                          ;*   2 : return multicolor #2
 19805                          ;******************************************************************
 19806                          
 19807                          rspcolor
 19808  ba45 20554e                              jsr chkcls                               ; check for closing paren
 19809  ba48 206f5d                              jsr conint                               ; get arg in .X
 19810  ba4b ca                                  dex                                      ; adjust [1..2] to [0..1
 19811  ba4c e002                                cpx #2
 19812  ba4e b3ae97                              +lbcs fcerr                              ; value error
 19813                          
 19814                          ; jsr put_io_in_map
 19815  ba51 bd25d0                              lda vic+37,x
 19816  ba54 290f                                and #$0f
 19817  ba56 a8                                  tay
 19818                          ; iny  ;range 0-15     [910724]
 19819  ba57 83799e                              +lbra sngflt                             ; float 1 byte arg in .Y
 19820                          
 19821                          ;.end
 19822                          ;[[function.rsppos]]
 19823                          
 19824                          
 19825                          
 19826                          ;******************************************************************
 19827                          ;* RSPPOS - Return sprite location / speed data
 19828                          ;*
 19829                          ;* Syntax:  RSPPOS (sprite_number, argument)
 19830                          ;*
 19831                          ;* Where:   sprite_number = [0..7]
 19832                          ;*    argument = [0..2]
 19833                          ;*   0 : return X position
 19834                          ;*   1 : return Y position
 19835                          ;*   2 : return current speed
 19836                          ;******************************************************************
 19837                          
 19838  ba5a 206f5d             rsppos           jsr conint                               ; get first arg, sprite #, in .X
 19839                          ; dex  ;adjust [1..8] to [0..7]   [910220]
 19840  ba5d e008                                cpx #8  ; (318018-03 mod                 ; fab)
 19841  ba5f b009                                bcs l304_1                               ; value error
 19842                          
 19843  ba61 da                                  phx                                      ; save sprite number
 19844                          ; jsr chkcom ;check for proper delimiter
 19845                          ; jsr getbyt ;do frmevl, get 1 byte arg (arg) in .X
 19846  ba62 20825d                              jsr combyt                               ; [910820]
 19847  ba65 20554e                              jsr chkcls                               ; look for closing paren
 19848  ba68 e003                                cpx #3
 19849  ba6a b39297             l304_1           +lbcs fcerr                              ; value error
 19850                          
 19851  ba6d 7a                                  ply                                      ; sprite number
 19852  ba6e e002                                cpx #2
 19853  ba70 d009                                bne l304_2                               ; branch if x or y position
 19854                          
 19855  ba72 befeb7                              ldx sproff,y                             ; get offset into speed data
 19856  ba75 bc0512                              ldy sprite_data,x                        ; get speed data
 19857  ba78 83589e                              +lbra sngflt                             ; go float 1 byte arg in .Y
 19858                          
 19859                          ; Get msb of sprite position (in case this is for x position)
 19860                          
 19861  ba7b 78                 l304_2           sei
 19862  ba7c b96579                              lda sbits,y                              ; get bit mask for this sprite
 19863  ba7f 2d10d0                              and vic+16                               ; ???vic_save
 19864  ba82 f002                                beq l304_3
 19865  ba84 a901                                lda #1                                   ; change any non-zero to a '1'
 19866  ba86 48                 l304_3           pha                                      ; save msb
 19867                          
 19868  ba87 98                                  tya                                      ; y = sprite# * 2
 19869  ba88 0a                                  asl
 19870  ba89 a8                                  tay
 19871  ba8a 8a                                  txa                                      ; see if this is y position
 19872  ba8b 4a                                  lsr                                      ; .C = 0 for x pos'n, 1 for y pos'n
 19873  ba8c 9005                                bcc l304_4                               ; branch if x pos'n
 19874                          
 19875  ba8e c8                                  iny                                      ; adjust pointer to point to y pos'n in register data
 19876  ba8f 68                                  pla
 19877  ba90 a900                                lda #0                                   ; ..and force 'msb' to be zero
 19878  ba92 48                                  pha
 19879                          
 19880  ba93 b900d0             l304_4           lda vic,y                                ; get correct location lsb   ???vic_save
 19881  ba96 58                                  cli
 19882  ba97 a8                                  tay
 19883  ba98 68                                  pla                                      ; ..and get msb,
 19884  ba99 832c9e                              +lbra nosflt                             ; ..and go float 2 byte value in y,a
 19885                          
 19886                          ;.end
 19887                          ;[[function.bump]]
 19888                          
 19889                          
 19890                          
 19891                          ;******************************************************************
 19892                          ;* BUMP - read sprite collision
 19893                          ;*
 19894                          ;* Syntax : BUMP (argument)
 19895                          ;*
 19896                          ;* Where  : argument = [1..2]
 19897                          ;*   1 : sprite/sprite collision
 19898                          ;*   2 : sprite/background collision
 19899                          ;******************************************************************
 19900                          
 19901  ba9c 20554e             bump             jsr chkcls
 19902  ba9f 206f5d                              jsr conint                               ; get arg in .X
 19903  baa2 ca                                  dex                                      ; adjust [1..2] to [0..1]
 19904  baa3 e002                                cpx #2
 19905  baa5 b35797                              +lbcs fcerr                              ; value error
 19906                          
 19907  baa8 78                                  sei
 19908  baa9 bce602                              ldy collisions,x                         ; get recorded collisions
 19909  baac a900                                lda #0                                   ; reset them
 19910  baae 9de602                              sta collisions,x
 19911  bab1 58                                  cli
 19912  bab2 831e9e                              +lbra sngflt                             ; float 1 byte arg in .Y
 19913                          
 19914                          ;.end
 19915                          
 19916                          
 19917                          
 19918                          ; GRAPHIC3.SRC
 19919                          ;****************************************************************
 19920                          ;  getang  -  set cosine & sine values
 19921                          ;             results in sinval & cosval based as a fraction
 19922                          ;             - over 65536
 19923                          ;             angsgn = angle phase (0-3)
 19924                          ;    on input vwork+y = 2 byte angle
 19925                          ;***************************************************************
 19926                          
 19927                          getang
 19928  bab5 2075bb                              jsr settwo                               ; move angle value into y/a
 19929                          
 19930  bab8 a200               gtang1           ldx #0                                   ; init count of phase
 19931                          
 19932  baba e8                 l305_1           inx
 19933  babb 38                                  sec
 19934  babc e95a                                sbc #90                                  ; subtract 90 until less than 0
 19935  babe b0fa                                bcs l305_1
 19936  bac0 88                                  dey
 19937  bac1 10f7                                bpl l305_1
 19938  bac3 8efa11                              stx angsgn                               ; save phase (here it is 1-4)
 19939  bac6 48                                  pha
 19940  bac7 695a                                adc #90                                  ; make positive
 19941  bac9 20d5ba                              jsr l305_2                               ; do division by 10
 19942  bacc 68                                  pla                                      ; get 2's comp of angle
 19943  bacd 18                                  clc
 19944  bace 49ff                                eor #$ff
 19945  bad0 6901                                adc #1                                   ; make positive
 19946  bad2 cefa11                              dec angsgn                               ; correct phase
 19947                          
 19948  bad5 a2ff               l305_2           ldx #$ff
 19949  bad7 e8                 l305_3           inx                                      ; do division by 10
 19950  bad8 38                                  sec
 19951  bad9 e90a                                sbc #10
 19952  badb b0fa                                bcs l305_3
 19953  badd 690a                                adc #10                                  ; make positive
 19954  badf 8df511                              sta vtemp1                               ; save remainder
 19955  bae2 8a                                  txa
 19956  bae3 0a                                  asl                                      ; get quotient*2 as index
 19957  bae4 aa                                  tax
 19958  bae5 bda2bc                              lda angval+1,x                           ; get low byte base
 19959  bae8 bca1bc                              ldy angval,x                             ; get high byte value
 19960                          
 19961  baeb 18                 l305_4           clc
 19962  baec cef511                              dec vtemp1
 19963  baef 300c                                bmi l305_5                               ; done - remainder = 0
 19964  baf1 7db6bc                              adc incval+1,x                           ; add low byte increment
 19965  baf4 48                                  pha
 19966  baf5 98                                  tya
 19967  baf6 7db5bc                              adc incval,x                             ; add high byte increment
 19968  baf9 a8                                  tay
 19969  bafa 68                                  pla
 19970  bafb 90ee                                bcc l305_4                               ; ...always
 19971                          
 19972  bafd 48                 l305_5           pha                                      ; save low byte of result
 19973  bafe a200                                ldx #0                                   ; point to sinval
 19974  bb00 adfa11                              lda angsgn
 19975  bb03 4a                                  lsr
 19976  bb04 b002                                bcs l305_6                               ; skip if sine value
 19977  bb06 a202                                ldx #2                                   ; point to cosval
 19978                          
 19979  bb08 68                 l305_6           pla
 19980  bb09 9dfb11                              sta sinval,x                             ; save low byte result
 19981  bb0c 98                                  tya
 19982  bb0d 9dfc11                              sta sinval+1,x                           ; save high byte result
 19983  bb10 60                                  rts
 19984                          
 19985                          
 19986                          ;*************************************************************
 19987                          ;  angmlt  -  multiple 2-byte integer times angle
 19988                          ;       carry set/reset = cosine/sine
 19989                          ;
 19990                          ;       vwork+x = 2-byte integer
 19991                          ;       result left in y/a
 19992                          ;*************************************************************
 19993                          
 19994                          angmlt
 19995  bb11 a00f                                ldy #sinval-vwork                        ; get offset to angle value
 19996  bb13 9002                                bcc l306_1                               ; get cosine/sine offset
 19997  bb15 a011                                ldy #cosval-vwork
 19998                          
 19999  bb17 adfa11             l306_1           lda angsgn
 20000  bb1a 6902                                adc #2                                   ; correct phase for cosine to look as sine
 20001  bb1c 4a                                  lsr
 20002  bb1d 4a                                  lsr
 20003  bb1e 08                                  php                                      ; save if carry - means negative angle value
 20004  bb1f 2075bb                              jsr settwo                               ; get angle fraction in y/a
 20005  bb22 c0ff                                cpy #$ff                                 ; test if value should be 1
 20006  bb24 9007                                bcc l306_2                               ; skip if not
 20007  bb26 8a                                  txa
 20008  bb27 a8                                  tay                                      ; get offset to integer
 20009  bb28 2075bb                              jsr settwo                               ; just get integer - multiplied by 1
 20010  bb2b b003                                bcs l306_3
 20011                          
 20012  bb2d 2094bb             l306_2           jsr twobyt                               ; multiply integer times angle value
 20013  bb30 28                 l306_3           plp                                      ; get sign of angle
 20014  bb31 9051                                bcc invert                               ; invert result if negative,do rts
 20015  bb33 60                                  rts
 20016                          
 20017                          
 20018                          ;*************************************************************
 20019                          ;  angdst  -  set up values for distance * angles
 20020                          ;       vwork+x = x & y distances
 20021                          ;       a = angles : ang1,ang2,ang3,ang4,0,0,0,0
 20022                          ;       get  xdist1 = xdist1 * angle-1
 20023                          ;     ydist1 = ydist1 * angle-2
 20024                          ;     xdist2 = xdist2 * angle-3
 20025                          ;     ydist2 = ydist2 * angle-4
 20026                          ;*************************************************************
 20027                          ;
 20028                          ;angdst
 20029                          ; sta angcnt      ;save angles
 20030                          ; ldx #xdist1-vwork
 20031                          ;angd10
 20032                          ; asl angcnt
 20033                          ; jsr angmlt      ;multiply angle * distance
 20034                          ; sta vwork,x
 20035                          ; tya  ;save results
 20036                          ; sta vwork+1,x
 20037                          ; inx  ;point to next distance
 20038                          ; inx
 20039                          ; cpx #disend-vwork
 20040                          ; bcc angd10 ;loop 4 times
 20041                          ;angd20 rts
 20042                          
 20043                          ;.end
 20044                          
 20045                          ; GRAPHIC8.SRC
 20046                          ;****************************************************************
 20047                          ;  docolr  --  set up color for 8x8 charcater cell
 20048                          ;   x = row number  --  y = column number
 20049                          ;****************************************************************
 20050                          ;
 20051                          ;docolr lda _ldtb2,x      ;put address of video ram into grapnt
 20052                          ; sta grapnt
 20053                          ; lda graphic_ldtb1,x ;point to bit mapped color area
 20054                          ; sta grapnt+1
 20055                          ;
 20056                          ; lda colsel  ;get current color source selected
 20057                          ;
 20058                          ; bne l306_1   ;branch if NOT background
 20059                          ; lda fg_bg
 20060                          ; bit _graphm  ;test if mode = hires
 20061                          ; bpl 25$   ;if so, go set up byte
 20062                          ; rts   ;else exit
 20063                          ;
 20064                          ;l306_1 cmp #2
 20065                          ; bne l306_3   ;branch if NOT multi-color 1
 20066                          ;
 20067                          ;l306_2 lda fg_mc1  ;get correct packed colors for multicolor mode.
 20068                          ;25$ and #$0f
 20069                          ; sta z_p_temp_1
 20070                          ; lda (grapnt),y
 20071                          ; and #$f0
 20072                          ; ora z_p_temp_1
 20073                          ; sta (grapnt),y
 20074                          ; rts
 20075                          ;
 20076                          ;l306_3 bcs 40$   ;branch if multicolor 2
 20077                          ;
 20078                          ; lda fg_bg  ;here for foreground. get packed colors.
 20079                          ; and #$f0
 20080                          ; sta z_p_temp_1
 20081                          ; lda (grapnt),y  ;do foreground
 20082                          ; and #$0f
 20083                          ; ora z_p_temp_1
 20084                          ; sta (grapnt),y
 20085                          ; rts
 20086                          ;
 20087                          ;40$ lda grapnt+1  ;do multicolor 2
 20088                          ; and #3
 20089                          ; ora #>color_ram_hi ;set up to point to high color area
 20090                          ; sta grapnt+1
 20091                          ;
 20092                          ; lda #0   ;put i/o in map
 20093                          ; sta mmu_config_reg
 20094                          ;
 20095                          ; sei
 20096                          ; lda _6510_data_reg
 20097                          ; pha
 20098                          ; and #%11111110  ;point cpu at correct nybble bank
 20099                          ; sta _6510_data_reg
 20100                          ; lda multicolor_2
 20101                          ; sta (grapnt),y
 20102                          ; pla
 20103                          ; sta _6510_data_reg
 20104                          ; cli
 20105                          ; rts
 20106                          ;
 20107                          ;
 20108                          ;
 20109                          ;graphic_ldtb1   ;_ldtb1 adjusted for an org at color_ram_lo
 20110                          ;99$=color_ram_lo
 20111                          ;1$=color_ram_lo+40*1
 20112                          ;2$=color_ram_lo+40*2
 20113                          ;3$=color_ram_lo+40*3
 20114                          ;4$=color_ram_lo+40*4
 20115                          ;5$=color_ram_lo+40*5
 20116                          ;6$=color_ram_lo+40*6
 20117                          ;7$=color_ram_lo+40*7
 20118                          ;8$=color_ram_lo+40*8
 20119                          ;9$=color_ram_lo+40*9
 20120                          ;l306_1=color_ram_lo+40*10
 20121                          ;11$=color_ram_lo+40*11
 20122                          ;12$=color_ram_lo+40*12
 20123                          ;13$=color_ram_lo+40*13
 20124                          ;14$=color_ram_lo+40*14
 20125                          ;15$=color_ram_lo+40*15
 20126                          ;16$=color_ram_lo+40*16
 20127                          ;17$=color_ram_lo+40*17
 20128                          ;18$=color_ram_lo+40*18
 20129                          ;19$=color_ram_lo+40*19
 20130                          ;l306_2=color_ram_lo+40*20
 20131                          ;21$=color_ram_lo+40*21
 20132                          ;22$=color_ram_lo+40*22
 20133                          ;23$=color_ram_lo+40*23
 20134                          ;24$=color_ram_lo+40*24
 20135                          ;
 20136                          ; .byte >99$,>1$,>2$,>3$,>4$,>5$,>6$,>7$,>8$,>9$,>l306_1
 20137                          ; .byte >11$,>12$,>13$,>14$,>15$,>16$,>17$,>18$,>19$
 20138                          ; .byte >l306_2,>21$,>22$,>23$,>24$
 20139                          
 20140                          
 20141                          ;******************************************************************
 20142                          ;  getpos - get address in graphic bit map into grapnt
 20143                          ;      x = bit offset into byte specified (0-7)
 20144                          ;      y = offset to byte within 8x8 character cell
 20145                          ;      a = bit mask to the bit (or bits if multicolor mode)
 20146                          ;******************************************************************
 20147                          ;
 20148                          ;getpos jsr divpos      ;get xpos/ypos to column/row position
 20149                          ; bcs grprts      ;abort if position too large
 20150                          ;
 20151                          ;getps1 tya  ;get addr for row (X) and col (Y) in grapnt
 20152                          ; clc
 20153                          ; adc _ldtb2,x ;add column position to low byte offset
 20154                          ; sta grapnt
 20155                          ; lda _ldtb1,x ;get high byte screen address
 20156                          ; adc #0  ;add any carry
 20157                          ; asl grapnt
 20158                          ; rol a
 20159                          ; asl grapnt ;mult by 8 to get offset into 8k area
 20160                          ; rol a
 20161                          ; asl grapnt
 20162                          ; rol a
 20163                          ; sta grapnt+1
 20164                          ;
 20165                          ; lda ypos
 20166                          ; and #07
 20167                          ; tay  ;get byte offset into 8x8 char cell
 20168                          ; lda xpos
 20169                          ; bit _graphm
 20170                          ; php
 20171                          ; bpl grpos3 ;skip if not multicolor mode
 20172                          ; asl a  ;shift x-pos for multicolor mode
 20173                          ;
 20174                          ;grpos3 and #07
 20175                          ; tax
 20176                          ; lda rbits,x ;get bit mask
 20177                          ; plp
 20178                          ; bpl grprts ;done if not multicolor mode
 20179                          ; inx
 20180                          ; ora rbits,x ;mask for 2 bits if multicolor mode
 20181                          ;grprts rts
 20182                          ;
 20183                          ;rbits .byte   $80,$40,$20,$10,$08,$04,$02,$01
 20184                          
 20185                          
 20186                          ;**************************************************************
 20187                          ;  divpos  --  convert xpos to column number
 20188                          ;  convert ypos to row number
 20189                          ;  return carry set if either above limits
 20190                          ;**************************************************************
 20191                          ;
 20192                          ;divpos lda xpos+1
 20193                          ; lsr a
 20194                          ; bne l306_2       ;out of bounds if greater than 1
 20195                          ; lda xpos
 20196                          ; ror a
 20197                          ; lsr a  ;get column position = xpos/8
 20198                          ; bit _graphm
 20199                          ; bmi l306_1  ;skip if multicolor mode
 20200                          ; lsr a  ;divide by 8 if a hires or text mode
 20201                          ;l306_1 tay
 20202                          ; cpy #llen
 20203                          ; bcs l306_2  ;error exit if out of bounds
 20204                          ; lda ypos+1
 20205                          ; bne l306_2  ;out of bounds error if not = 0
 20206                          ; lda ypos
 20207                          ; lsr a
 20208                          ; lsr a  ;get row number = ypos/8
 20209                          ; lsr a
 20210                          ; tax
 20211                          ; cmp #nlines ;compare to max number of rows
 20212                          ; rts  ;carry clr if okay
 20213                          ;l306_2 sec
 20214                          ; rts
 20215                          
 20216                          
 20217                          ;***************************************************************
 20218                          ;   SCALXY  - Scale the x & y coordinates found in vwork+x
 20219                          ;***************************************************************
 20220                          ;
 20221                          ;scalxy lda scalem
 20222                          ; beq sclrts      ;do nothing if scaling off
 20223                          ;
 20224                          ; lda scale_x
 20225                          ; ldy scale_x+1
 20226                          ; jsr doscal      ;scale in the x-direction
 20227                          ;
 20228                          ; lda scale_y
 20229                          ; ldy scale_y+1 ;scale in the y direction
 20230                          ;
 20231                          ;doscal jsr twobyt ;multiply * coordinate
 20232                          ; sta vwork,x
 20233                          ; tya
 20234                          ; inx  ;store back into original position
 20235                          ; sta vwork,x
 20236                          ; inx
 20237                          ;sclrts
 20238                          ; rts
 20239                          
 20240                          ;.end
 20241                          
 20242                          ;GRAPHICS9.SRC
 20243                          ;***************************************************************
 20244                          ;   DOTWO  - Add      two 2-byte values if carry clear
 20245                          ;  Subtract two 2-byte values if carry set
 20246                          ;***************************************************************
 20247                          
 20248                          dotwo2
 20249  bb34 9007                                bcc addtw2                               ; go do addition
 20250  bb36 b014                                bcs subtw2                               ; go do subtraction
 20251                          dotwo
 20252  bb38 b00f                                bcs subtwo                               ; go do subtraction
 20253                          
 20254                          ;***************************************************************
 20255                          ;  ADDTWO  - Add vwork+y and vwork+x  Result in y/a
 20256                          ;***************************************************************
 20257                          
 20258                          addtwo
 20259  bb3a 2075bb                              jsr settwo                               ; put vwrok+y into y/a
 20260                          
 20261                          addtw2                                                    ; enter here to add y/a to vwork+x
 20262  bb3d 18                                  clc
 20263  bb3e 7dec11                              adc vwork,x
 20264  bb41 48                                  pha
 20265  bb42 98                                  tya
 20266  bb43 7ded11                              adc vwork+1,x
 20267  bb46 a8                                  tay
 20268  bb47 68                                  pla
 20269  bb48 60                                  rts
 20270                          
 20271                          
 20272                          ;****************************************************************
 20273                          ;  SUBTWO  - Subtract vwork+y - vwork+x Result in y/a
 20274                          ;****************************************************************
 20275                          
 20276                          subtwo
 20277  bb49 2075bb                              jsr settwo                               ; move vwork+y into y/a
 20278                          
 20279                          subtw2                                                    ; enter here with 1st value in y/a
 20280  bb4c 38                                  sec
 20281  bb4d fdec11                              sbc vwork,x
 20282  bb50 8559                                sta tempf1
 20283  bb52 98                                  tya
 20284  bb53 fded11                              sbc vwork+1,x
 20285  bb56 a8                                  tay
 20286  bb57 08                                  php
 20287  bb58 a559                                lda tempf1
 20288  bb5a 28                                  plp
 20289  bb5b 60                                  rts
 20290                          
 20291                          
 20292                          subtwo_savram
 20293  bb5c b99111                              lda savram,y                             ; load value into y,a
 20294  bb5f 48                                  pha
 20295  bb60 b99211                              lda savram+1,y
 20296  bb63 a8                                  tay
 20297  bb64 68                                  pla
 20298  bb65 38                                  sec
 20299  bb66 fd9111                              sbc savram,x
 20300  bb69 8559                                sta tempf1
 20301  bb6b 98                                  tya
 20302  bb6c fd9211                              sbc savram+1,x
 20303  bb6f a8                                  tay
 20304  bb70 08                                  php
 20305  bb71 a559                                lda tempf1
 20306  bb73 28                                  plp
 20307  bb74 60                                  rts
 20308                          
 20309                          
 20310                          ;************************************************************
 20311                          ;  SETTWO  - Move value in vwork+y into y/a
 20312                          ;************************************************************
 20313                          
 20314                          settwo
 20315  bb75 b9ec11                              lda vwork,y
 20316  bb78 48                                  pha
 20317  bb79 b9ed11                              lda vwork+1,y
 20318  bb7c a8                                  tay
 20319  bb7d 68                                  pla
 20320  bb7e 60                                  rts
 20321                          
 20322                          ;******************************************************************
 20323                          ;  ABSTWO  - Get absolute value of vwork+y - vwork+x
 20324                          ;  Result in y/a  -  carry === vwork+y >= vwork+x
 20325                          ;******************************************************************
 20326                          
 20327                          abstwo                                                    ; movspr_to [910809]
 20328  bb7f 2049bb                              jsr subtwo                               ; subtract vwork+y - vwork+x
 20329                          abstw2                                                    ; entrance with vwork+y in y/a
 20330  bb82 100f                                bpl absrts                               ; done if result is positive
 20331  bb84 08                 invert           php
 20332  bb85 18                                  clc
 20333  bb86 49ff                                eor #$ff                                 ; invert low byte result and add 1
 20334  bb88 6901                                adc #1
 20335  bb8a 48                                  pha
 20336  bb8b 98                                  tya
 20337  bb8c 49ff                                eor #$ff                                 ; invert high byte result
 20338  bb8e 6900                                adc #0                                   ; add back any carry
 20339  bb90 a8                                  tay
 20340  bb91 68                                  pla
 20341  bb92 28                                  plp
 20342  bb93 60                 absrts           rts
 20343                          
 20344                          
 20345                          ;****************************************************************
 20346                          ;  TWOBYT  - Multiply 2 byte fraction in y/a times 2 bytes
 20347                          ;  Integer found in vwork+x-reg.  Result = y/a
 20348                          ;****************************************************************
 20349                          
 20350                          twobyt
 20351  bb94 8cf511                              sty vtemp1                               ; save fraction
 20352  bb97 8df611                              sta vtemp2
 20353  bb9a bdec11                              lda vwork,x
 20354  bb9d bced11                              ldy vwork+1,x
 20355  bba0 08                                  php                                      ; save sign of integer
 20356  bba1 2082bb                              jsr abstw2                               ; absolute value
 20357  bba4 9dec11                              sta vwork,x
 20358  bba7 98                                  tya
 20359  bba8 9ded11                              sta vwork+1,x
 20360  bbab a900                                lda #0
 20361  bbad 8df711                              sta vtemp3                               ; initialize result to zero
 20362                          
 20363  bbb0 a010                                ldy #16                                  ; initialize count
 20364  bbb2 4ef511             l307_1           lsr vtemp1
 20365  bbb5 6ef611                              ror vtemp2
 20366  bbb8 900f                                bcc l307_2                               ; skip if no bit set
 20367  bbba 18                                  clc
 20368  bbbb 7dec11                              adc vwork,x                              ; add integer low byte
 20369  bbbe 48                                  pha
 20370  bbbf adf711                              lda vtemp3
 20371  bbc2 7ded11                              adc vwork+1,x                            ; add integer high byte to total
 20372  bbc5 8df711                              sta vtemp3
 20373  bbc8 68                                  pla
 20374                          
 20375  bbc9 4ef711             l307_2           lsr vtemp3                               ; divide by 2
 20376  bbcc 6a                                  ror
 20377  bbcd 88                                  dey
 20378  bbce d0e2                                bne l307_1                               ; loop 16 times - test all bits in 2 bytes
 20379                          
 20380  bbd0 6900                                adc #0                                   ; add back round factor
 20381  bbd2 acf711                              ldy vtemp3
 20382  bbd5 9001                                bcc l307_3
 20383  bbd7 c8                                  iny
 20384  bbd8 28                 l307_3           plp                                      ; pop sign
 20385  bbd9 80a7                                bra abstw2                               ; return with signed product in y/a
 20386                          
 20387                          
 20388                          ;******************************************************************
 20389                          ;  dstpos  -  move xdest/ydest to xpos/ypos
 20390                          ;******************************************************************
 20391                          ;
 20392                          ;dstpos
 20393                          ; ldy #0
 20394                          ; jsr dstmov
 20395                          ; ldy #2
 20396                          ;dstmov
 20397                          ; lda xdest,y
 20398                          ; sta xpos,y
 20399                          ; lda xdest+1,y
 20400                          ; sta xpos+1,y
 20401                          ; rts
 20402                          
 20403                          ;.end
 20404                          
 20405                          ;GRAPHICS10.SRC
 20406                          ;************************************************************
 20407                          ;   incolr  --  get color selection parameter into colsel
 20408                          ;************************************************************
 20409                          ;
 20410                          ;incolr
 20411                          ; ldx #1   ;get an optional 1 byte val, def=fg(1)
 20412                          ; jsr chrgot
 20413                          ;incol1
 20414                          ; beq incol2       ;eol, use default
 20415                          ; cmp #','
 20416                          ; beq incol2       ;just ',', use default
 20417                          ; jsr getbyt
 20418                          ; cpx #4   ;must be 0-3
 20419                          ; bcs illval       ;..else illegal value
 20420                          ; cpx #2
 20421                          ; bit _graphm       ;if hires, must be 0 or 1
 20422                          ; bmi incol2
 20423                          ; bcs illval
 20424                          ;incol2
 20425                          ; stx colsel
 20426                          ; rts
 20427                          ;
 20428                          ;illval
 20429                          ; jmp fcerr  ;illegal value
 20430                          
 20431                          
 20432                          
 20433                          ;******************************************************************
 20434                          ;  INCORD  ---  Get X,Y coordinate from input stream into vwork+x
 20435                          ;
 20436                          ;  Coordinate may have any of the forms:
 20437                          ;    x,y  = absolute xpos & absolute ypos
 20438                          ; +/-x,y  = relative xpos & absolute ypos
 20439                          ;    x,+/-y = absolute xpos & relative ypos
 20440                          ; +/-x,+/-y = relative xpos & relative ypos
 20441                          ;    x;y  = x-distance at an angle y
 20442                          ;
 20443                          ;  Relative and angle distances are relative to current x,ypos.
 20444                          ;  Values are scaled to current mode parameters if required.
 20445                          ;******************************************************************
 20446                          
 20447                          
 20448                          incor2                                                    ; enter here for optional argument
 20449  bbdb 208522                              jsr chrgot                               ; end of line?
 20450  bbde f007                                beq l308_1                               ; yes, use defaults
 20451  bbe0 205b4e                              jsr chkcom
 20452  bbe3 c92c                                cmp #','                                 ; is there really an arg?
 20453  bbe5 d00f                                bne incord                               ; yes, let'er rip
 20454                          
 20455  bbe7 a000               l308_1           ldy #0                                   ; set default pos = current pos
 20456  bbe9 b9ec11             l308_2           lda xpos,y
 20457  bbec 9dec11                              sta vwork,x
 20458  bbef e8                                  inx
 20459  bbf0 c8                                  iny
 20460  bbf1 c004                                cpy #4
 20461  bbf3 90f4                                bcc l308_2
 20462  bbf5 60                                  rts
 20463                          
 20464                          
 20465                          ;incor3    ;enter here for non-optional arg preceded by a comma
 20466                          ; jsr chkcom
 20467                          incord
 20468  bbf6 8ef811                              stx vtemp4                               ; save offset to destination
 20469  bbf9 2081bc                              jsr cordsb                               ; get 2-byte x-parameter
 20470  bbfc 208522                              jsr chrgot
 20471  bbff c92c                                cmp #','
 20472  bc01 f051                                beq docord                               ; skip ahead if have comma
 20473                          
 20474  bc03 c93b                                cmp #';'                                 ; check for semi-colon
 20475  bc05 d34372                              +lbne snerr                              ; missing angle param- show syntax message
 20476  bc08 208322                              jsr chrget       ;skip over '            ; '
 20477  bc0b 208a5d                              jsr getwrd                               ; get 2-byte angle in a,y
 20478  bc0e 8576                                sta z_p_temp_1                           ; swap a,y
 20479  bc10 98                                  tya
 20480  bc11 a476                                ldy z_p_temp_1
 20481  bc13 20b8ba                              jsr gtang1                               ; get sine & cosine values for the angle
 20482  bc16 aef811                              ldx vtemp4
 20483  bc19 bdec11                              lda vwork,x
 20484  bc1c 9dee11                              sta vwork+2,x                            ; move length to y-parameter
 20485  bc1f bded11                              lda vwork+1,x
 20486  bc22 9def11                              sta vwork+3,x
 20487                          ; jsr scalxy       ;scale the values
 20488  bc25 a90e                                lda #$0e
 20489  bc27 8df911                              sta vtemp5
 20490  bc2a 18                                  clc
 20491  bc2b aef811                              ldx vtemp4
 20492                          
 20493  bc2e 2011bb             l309_1           jsr angmlt                               ; multiply length * angle
 20494  bc31 9dec11                              sta vwork,x                              ; save angle result
 20495  bc34 98                                  tya
 20496  bc35 9ded11                              sta vwork+1,x
 20497  bc38 a000                                ldy #xpos-vwork
 20498  bc3a 4ef911                              lsr vtemp5
 20499  bc3d 9002                                bcc l309_2
 20500  bc3f a002                                ldy #ypos-vwork
 20501                          
 20502  bc41 2038bb             l309_2           jsr dotwo                                ; add/subtract value to current position
 20503  bc44 9dec11                              sta vwork,x
 20504  bc47 98                                  tya                                      ; save result in destination
 20505  bc48 9ded11                              sta vwork+1,x
 20506  bc4b e8                                  inx
 20507  bc4c e8                                  inx
 20508  bc4d 4ef911                              lsr vtemp5
 20509  bc50 d0dc                                bne l309_1                               ; do y-coordinate
 20510  bc52 18                                  clc
 20511  bc53 60                                  rts
 20512                          
 20513                          
 20514  bc54 208322             docord           jsr chrget                               ; skip over comma
 20515  bc57 eef811                              inc vtemp4                               ; point to y-destination
 20516  bc5a eef811                              inc vtemp4
 20517  bc5d 2081bc                              jsr cordsb                               ; get y-paramter
 20518                          ; ldx vtemp4
 20519                          ; dex
 20520                          ; dex
 20521                          ; jsr scalxy       ;scale the values
 20522  bc60 a002                                ldy #ypos-vwork
 20523  bc62 aef811                              ldx vtemp4
 20524  bc65 e8                                  inx
 20525  bc66 e8                                  inx
 20526                          
 20527  bc67 ca                 docor1           dex
 20528  bc68 ca                                  dex
 20529  bc69 4ef911                              lsr vtemp5
 20530  bc6c 900a                                bcc docor2                               ; skip if not relative
 20531  bc6e 203abb                              jsr addtwo                               ; add to current position
 20532  bc71 9dec11                              sta vwork,x
 20533  bc74 98                                  tya
 20534  bc75 9ded11                              sta vwork+1,x
 20535                          
 20536  bc78 a000               docor2           ldy #xpos-vwork
 20537  bc7a ecf811                              cpx vtemp4
 20538  bc7d f0e8                                beq docor1                               ; loop to do x-coordinate
 20539  bc7f 18                                  clc
 20540  bc80 60                                  rts
 20541                          
 20542                          ;
 20543                          ; CORDSB -- Get the next 2-byte parameter
 20544                          ;
 20545                          
 20546  bc81 208522             cordsb           jsr chrgot                               ; read character
 20547  bc84 c9aa                                cmp #plus_token                          ; check if relative - plus sign
 20548  bc86 f005                                beq l310_1                               ; skip if yes
 20549  bc88 c9ab                                cmp #minus_token
 20550  bc8a f001                                beq l310_1                               ; skip if relative - minus sign
 20551  bc8c 18                                  clc                                      ; .c=1 if relative coord, .c=0 if absolute
 20552  bc8d 2ef911             l310_1           rol vtemp5                               ; save coord type for later
 20553  bc90 20d84c                              jsr frmnum
 20554  bc93 20925d                              jsr getsad                               ; get signed 2 byte coordinate (y,a), do rts
 20555  bc96 aef811                              ldx vtemp4
 20556  bc99 9ded11                              sta vwork+1,x                            ; save 2-byte parameter
 20557  bc9c 98                                  tya
 20558  bc9d 9dec11                              sta vwork,x
 20559  bca0 60                                  rts
 20560                          
 20561                          ;.end
 20562                          
 20563                          ;GRAPHICS11.SRC
 20564                          
 20565                          ;  ANGVAL  -- Table of angle values on 10 degree boundaries
 20566                          ;  Values based as fraction of 65536
 20567                          
 20568                          angval
 20569  bca1 0000                                !text $00,$00                            ; sine 00 degrees -  .0000
 20570  bca3 2c71                                !text $2c,$71                            ; sine 10 degrees -  .1736
 20571  bca5 578d                                !text $57,$8d                            ; sine 20 degrees -  .3420
 20572  bca7 8000                                !text $80,$00                            ; sine 30 degrees -  .5000
 20573  bca9 a48f                                !text $a4,$8f                            ; sine 40 degrees -  .6428
 20574  bcab c419                                !text $c4,$19                            ; sine 50 degrees -  .7660
 20575  bcad ddb2                                !text $dd,$b2                            ; sine 60 degrees -  .8660
 20576  bcaf f090                                !text $f0,$90                            ; sine 70 degrees -  .9397
 20577  bcb1 fc1c                                !text $fc,$1c                            ; sine 80 degrees -  .9848
 20578  bcb3 ffff                                !text $ff,$ff                            ; sine 90 degrees - 1.0000
 20579                          
 20580                          ;  INCVAL  -- Table of incremental values between 10 degrees
 20581                          ;  Values based on fraction of 65536
 20582                          
 20583                          incval
 20584  bcb5 0472                                !text $04,$72                            ; 01 - 09 degrees -  .01739
 20585  bcb7 0450                                !text $04,$50                            ; 11 - 19 degrees -  .01692
 20586  bcb9 040b                                !text $04,$0b                            ; 21 - 29 degrees -  .01592
 20587  bcbb 03a8                                !text $03,$a8                            ; 31 - 39 degrees -  .01443
 20588  bcbd 0328                                !text $03,$28                            ; 41 - 49 degrees -  .01252
 20589  bcbf 0290                                !text $02,$90                            ; 51 - 59 degrees -  .01023
 20590  bcc1 01e3                                !text $01,$e3                            ; 61 - 69 degrees -  .00762
 20591  bcc3 0128                                !text $01,$28                            ; 71 - 79 degrees -  .00477
 20592  bcc5 0063                                !text $00,$63                            ; 81 - 89 degrees -  .00179
 20593                          
 20594                          ;.end
 20595                          
 20596                          ;[[edit.mode]]
 20597                          
 20598                          
 20599                          ; Edit mode is simply a poor man's word processor.  Text is entered normally
 20600                          ; as if the user were typing in a program, but tokenization is turned off.
 20601                          ; This affects only that text which follows a line number.  CRUNCH and QPLOP
 20602                          ; test for this mode, and deal with the text accordingly.  RUN, GOTO, etc.
 20603                          ; test for this mode and error-out if it's enabled.  LOADing a text file
 20604                          ; will automatically add line numbers, SAVEing a text file will remove them.
 20605                          ;
 20606                          ; Syntax:  EDIT < ON | OFF >
 20607                          ;
 20608                          ; F. Bowen        [910620]
 20609                          
 20610  bcc7 20ed58             edit             jsr errind                               ; direct mode only command
 20611  bcca c991                                cmp #on_token
 20612  bccc d004                                bne l311_1
 20613  bcce a910                                lda #%00010000                           ; EDIT ON
 20614  bcd0 800a                                bra l311_3                               ; (this kills trace mode, too)
 20615                          
 20616  bcd2 2016b5             l311_1           jsr chkesc                               ; [910930]
 20617                          ; cmp #esc_command_token
 20618                          ; bne l311_2
 20619                          ; jsr chrget
 20620  bcd5 c924                                cmp #off_token
 20621  bcd7 d37171             l311_2           +lbne snerr
 20622  bcda a900                                lda #0                                   ; EDIT OFF
 20623  bcdc 857e               l311_3           sta runmod
 20624  bcde 4c8322                              jmp chrget                               ; exit
 20625                          
 20626                          
 20627                          edit_crunch                                               ; Edit mode only, find end of plain text in input buffer
 20628  bce1 fc3d00                              phw txtptr                               ; save current position in input buffer
 20629  bce4 205635                              jsr rem                                  ; find the end of the line
 20630  bce7 a63d                                ldx txtptr
 20631  bce9 68                                  pla                                      ; restore buffer pointer
 20632  bcea 853e                                sta txtptr+1
 20633  bcec 68                                  pla
 20634  bced 853d                                sta txtptr
 20635  bcef 38                                  sec                                      ; compute length of line
 20636  bcf0 8a                                  txa
 20637  bcf1 e53d                                sbc txtptr
 20638  bcf3 a8                                  tay
 20639  bcf4 c8                                  iny
 20640  bcf5 60                                  rts                                      ; done
 20641                          
 20642                          
 20643                          edit_p1line                                               ; Edit mode only, list a line of plain text
 20644  bcf6 207f64                              jsr linprt                               ; print line number in (a,x)
 20645  bcf9 a920                                lda #' '                                 ; print a space
 20646                          
 20647  bcfb a003                                ldy #3                                   ; start printing at text following line number
 20648  bcfd 203d68             l312_1           jsr outch                                ; print character
 20649  bd00 c8                                  iny
 20650  bd01 5f5503                              bbr5 helper,l312_2                       ; if called from FIND/CHANGE check for highlighting
 20651  bd04 20963c                              jsr helpsb
 20652  bd07 20ad22             l312_2           jsr indlow                               ; get next character
 20653  bd0a d0f1                                bne l312_1                               ; loop until eol
 20654  bd0c 60                                  rts                                      ; done
 20655                          
 20656                          
 20657                          ;.end
 20658                          
 20659                          ; EDIT LOAD/SAVE  Load or Save a plain text SEQ file in memory
 20660                          
 20661                          edit_load                                                 ; Called by DLOAD/DVERIFY when in EDIT mode
 20662  bd0d a301                                ldz #1
 20663  bd0f 20196f                              jsr open_SEQ_file                        ; Open the file just like TYPE: filename [,U#] [,D#]
 20664  bd12 200e78                              jsr Check_DS                             ; check current disk error message
 20665  bd15 a000                                ldy #0
 20666  bd17 a97a                                lda #dsdesc+1
 20667  bd19 20d722                              jsr lda_far_ram1                         ; lda (dsdesc+1),y peek at first character
 20668  bd1c c932                                cmp #'2'
 20669  bd1e b3bb00                              +lbcs l313_12                            ; exit if error
 20670  bd21 208278                              jsr Clear_DS                             ; else zap 'ok' message so user gets fresh one
 20671  bd24 ae8111                              ldx dosla
 20672  bd27 20c6ff                              jsr _chkin                               ; get input channel
 20673  bd2a b3af00                              +lbcs l313_12                            ; error
 20674                          
 20675  bd2d 8f0c0e                              bbs0 verck,l313_1
 20676  bd30 207dff                              jsr _primm
 20677  bd33 0d4c4f4144494e47...                 !text cr,"LOADING",0
 20678  bd3c 800e                                bra l313_2
 20679  bd3e 207dff             l313_1           jsr _primm
 20680  bd41 0d56455249465949...                 !text cr,"VERIFYING",0
 20681                          
 20682  bd4c a9e8               l313_2           lda #<1000                               ; default starting line #
 20683  bd4e a203                                ldx #>1000
 20684  bd50 8516                                sta linnum
 20685  bd52 8617                                stx linnum+1
 20686                          
 20687  bd54 a52d                                lda txttab                               ; load address
 20688  bd56 a62e                                ldx txttab+1
 20689  bd58 8524                                sta index
 20690  bd5a 8625                                stx index+1
 20691                          
 20692  bd5c a000               l313_3           ldy #0                                   ; Input one line of text
 20693  bd5e 20e1ff                              jsr _stop                                ; check stop key
 20694  bd61 f072                                beq l313_11                              ; exit if down
 20695  bd63 20b7ff                              jsr _readst                              ; check channel status
 20696  bd66 d06d                                bne l313_11                              ; exit if eof or error
 20697                          
 20698  bd68 0f0c04                              bbr0 verck,l313_4
 20699  bd6b a003                                ldy #3
 20700  bd6d 8020                                bra l313_5                               ; skip ahead if verify op
 20701                          
 20702  bd6f a901               l313_4           lda #1                                   ; install fake line links for this line
 20703  bd71 200623                              jsr sta_far_in1
 20704  bd74 c8                                  iny                                      ; 1
 20705  bd75 200623                              jsr sta_far_in1
 20706  bd78 c8                                  iny                                      ; 2
 20707  bd79 a516                                lda linnum                               ; install line number for this line
 20708  bd7b 200623                              jsr sta_far_in1
 20709  bd7e c8                                  iny                                      ; 3
 20710  bd7f a517                                lda linnum+1
 20711  bd81 200623                              jsr sta_far_in1
 20712  bd84 18                                  clc
 20713  bd85 a516                                lda linnum                               ; generate next line number
 20714  bd87 690a                                adc #10
 20715  bd89 8516                                sta linnum
 20716  bd8b 9002                                bcc l313_5
 20717  bd8d e617                                inc linnum+1
 20718                          
 20719                          
 20720  bd8f c8                 l313_5           iny                                      ; bump buffer pointer
 20721  bd90 c0a1                                cpy #buflen                              ; check buffer (160 max. input buffer size to edit)
 20722  bd92 f01e                                beq l313_8                               ; split long lines into two????
 20723  bd94 20cfff                              jsr _basin                               ; read file data
 20724  bd97 f019                                beq l313_8                               ; CR or null terminates line
 20725  bd99 c90d                                cmp #cr
 20726  bd9b f015                                beq l313_8
 20727                          ; cmp #$20  ;adjust invisible characters less than space
 20728                          ; bcc l313_6   ; ????make them appear in reverse field, but note
 20729                          ; ora #$80  ; that these lines can't be edited without losing them.
 20730                          
 20731  bd9d 0f0c0d             l313_6           bbr0 verck,l313_7
 20732  bda0 201723                              jsr indcmp_in1                           ; Compare to memory
 20733  bda3 f0ea                                beq l313_5                               ; ok
 20734  bda5 202033                              jsr list_exit
 20735  bda8 a21c                                ldx #ervfy                               ; verify error
 20736  bdaa 83a370                              +lbra error
 20737                          
 20738  bdad 200623             l313_7           jsr sta_far_in1                          ; Load into memory
 20739  bdb0 80dd                                bra l313_5                               ; loop until eol or error (kernel returns CR in case of error)
 20740                          
 20741  bdb2 8f0c05             l313_8           bbs0 verck,l313_9
 20742  bdb5 a900                                lda #0
 20743  bdb7 200623                              jsr sta_far_in1                          ; terminate line with null (replaces CR)
 20744  bdba c8                 l313_9           iny
 20745  bdbb 98                                  tya
 20746  bdbc 18                                  clc
 20747  bdbd 6524                                adc index
 20748  bdbf 8524                                sta index
 20749  bdc1 9002                                bcc l313_10
 20750  bdc3 e625                                inc index+1
 20751  bdc5 a525               l313_10          lda index+1
 20752  bdc7 cdd002                              cmp max_mem_0+1                          ; out of memory????
 20753  bdca 9090                                bcc l313_3                               ; no, continue until eof
 20754  bdcc 631000                              bsr edit_load_done                       ; yes, patch things up best we can
 20755  bdcf 202033                              jsr list_exit                            ; close disk
 20756  bdd2 836d70                              +lbra omerr                              ; report error & exit
 20757                          
 20758  bdd5 8f0c03             l313_11          bbs0 verck,l313_12
 20759  bdd8 20debd                              jsr edit_load_done                       ; EOF: terminate memory with a pair of nulls
 20760  bddb 834375             l313_12          +lbra list_exit                          ; release channel, close file, etc.
 20761                          
 20762                          ; bbr0 verck,40$
 20763                          ; jsr verify_ok  ;if Verify, report 'ok'
 20764                          ;40$ lda #0   ;exit directly to main????
 20765                          ; bra end
 20766                          
 20767                          edit_load_done
 20768  bdde a900                                lda #0                                   ; EOF: terminate memory with a pair of nulls
 20769  bde0 a8                                  tay
 20770  bde1 200623                              jsr sta_far_in1
 20771  bde4 c8                                  iny
 20772  bde5 200623                              jsr sta_far_in1
 20773  bde8 e324                                inw index
 20774  bdea e324                                inw index
 20775  bdec a624                                ldx index                                ; set top
 20776  bdee a425                                ldy index+1
 20777  bdf0 8682                                stx text_top
 20778  bdf2 8483                                sty text_top+1
 20779  bdf4 83c372                              +lbra link_program                       ; relink & RTS
 20780                          
 20781                          
 20782                          edit_save
 20783  bdf7 a9e6                                lda #$e6                                 ; parse:  filename [,U#] [,D#]
 20784  bdf9 202074                              jsr dosprs                               ; (like dopen:      0 0 0 *  * 0 0 1 )
 20785  bdfc 20dc77                              jsr chk1                                 ; check parameters
 20786  bdff 201d71                              jsr find_la                              ; find an available LA
 20787  be02 200d71                              jsr find_sa                              ; find an available SA
 20788  be05 a017                                ldy #fsavseq
 20789  be07 a208                                ldx #8
 20790  be09 20fd70                              jsr open_file                            ; open the file
 20791  be0c b31975                              +lbcs list_err                           ; exit if error
 20792  be0f ae8111                              ldx dosla
 20793  be12 20c9ff                              jsr _chkout                              ; get output channel
 20794  be15 b03b                                bcs l314_5                               ; error
 20795                          
 20796  be17 a52d                                lda txttab                               ; save address
 20797  be19 a62e                                ldx txttab+1
 20798  be1b 8524                                sta index
 20799  be1d 8625                                stx index+1
 20800                          
 20801  be1f 20e1ff             l314_1           jsr _stop                                ; check stop key
 20802  be22 f02e                                beq l314_5                               ; exit if down
 20803  be24 20b7ff                              jsr _readst                              ; check channel status
 20804  be27 d029                                bne l314_5                               ; exit if eof or error????
 20805                          
 20806  be29 a003                                ldy #3                                   ; save a line, starting past links & line#
 20807  be2b c8                 l314_2           iny                                      ; bump buffer pointer
 20808                          ; cpy #buflen  ;check buffer (160 max. input buffer size to edit)
 20809                          ; beq ??$   ; split long lines into two????
 20810  be2c 20c122                              jsr indin1
 20811  be2f aa                                  tax                                      ; save character for eol check
 20812  be30 d002                                bne l314_3
 20813  be32 a90d                                lda #cr                                  ; eol: substitute CR ???? allow some other terminator
 20814  be34 20d2ff             l314_3           jsr _bsout                               ; write file data
 20815  be37 8a                                  txa
 20816  be38 d0f1                                bne l314_2                               ; loop until eol
 20817                          
 20818  be3a c8                                  iny                                      ; advance text index to start of next line
 20819  be3b 98                                  tya
 20820  be3c 18                                  clc
 20821  be3d 6524                                adc index
 20822  be3f 8524                                sta index
 20823  be41 9002                                bcc l314_4
 20824  be43 e625                                inc index+1
 20825                          
 20826  be45 a000               l314_4           ldy #0                                   ; check for EOF: a pair of null links
 20827  be47 20c122                              jsr indin1
 20828  be4a d0d3                                bne l314_1
 20829  be4c c8                                  iny
 20830  be4d 20c122                              jsr indin1
 20831  be50 d0cd                                bne l314_1                               ; loop until end of text
 20832                          
 20833  be52 83cc74             l314_5           +lbra list_exit                          ; release channel, close file, exit
 20834                          
 20835                          ;.end
 20836                          
 20837                          
 20838                          Sound_CLR
 20839  be55 2022b5                              jsr chkeos                               ; eat CLR token, check eos   [910717] new
 20840                          Sound_CLR_1
 20841  be58 08                                  php
 20842  be59 78                                  sei
 20843                          ; jsr go_slow  ;      [910716] 4567R7A
 20844  be5a a900                                lda #0
 20845  be5c a217                                ldx #24-1
 20846  be5e 9d00d4             l315_1           sta sid1,x                               ; initialize SID chips
 20847  be61 9d20d4                              sta sid2,x
 20848  be64 ca                                  dex
 20849  be65 10f7                                bpl l315_1
 20850                          
 20851  be67 8d7a12                              sta filters1+2                           ; set filters off
 20852  be6a 8d7e12                              sta filters2+2
 20853                          
 20854  be6d a908                                lda #8                                   ; set default volume
 20855  be6f 8d7b12                              sta filters1+3
 20856  be72 8d7f12                              sta filters2+3                           ; [910612]
 20857                          ; sta filters+4  ;why?      [910612]
 20858  be75 8d18d4                              sta sid1+24
 20859  be78 8d38d4                              sta sid2+24
 20860                          
 20861                          ; jsr go_fast  ;      [910716] 4567R7A
 20862                          
 20863  be7b 2c0311                              bit _pal_ntsc                            ; determine if PAL or NTSC system  [910724]
 20864  be7e 3006                                bmi l315_2                               ; ...branch if PAL
 20865  be80 a928                                lda #(<beats_ntsc)/4                     ; set beat to quarter note (4/4 time = .5 sec)
 20866  be82 a001                                ldy #>beats_ntsc/4
 20867  be84 8004                                bra l315_3
 20868  be86 a92c               l315_2           lda #<beats_pal/4
 20869  be88 a001                                ldy #>beats_pal/4
 20870  be8a 8d7612             l315_3           sta ntime
 20871  be8d 8c7712                              sty ntime+1
 20872                          
 20873  be90 a904                                lda #4                                   ; set default octave
 20874  be92 8d7012                              sta octave
 20875  be95 a90c                                lda #12                                  ; set default tempo    [910220]
 20876  be97 8d7312                              sta tempo_rate                           ; 12 makes whole note in 4/4 time last 2 seconds
 20877                          
 20878  be9a a01d                                ldy #30-1                                ; initialize music tables
 20879  be9c b9d849             l315_4           lda atkmus,y
 20880  be9f 998912                              sta atktab,y
 20881  bea2 88                                  dey
 20882  bea3 10f7                                bpl l315_4
 20883                          
 20884  bea5 a209                                ldx #10-1                                ; initialize pulse widths
 20885  bea7 bdf649             l315_5           lda pwhmus,x
 20886  beaa 9db112                              sta pulshi,x
 20887  bead ca                                  dex
 20888  beae 10f7                                bpl l315_5
 20889                          
 20890  beb0 8a                                  txa                                      ; $ff
 20891  beb1 a205                                ldx #6-1                                 ; stereo SIDs   (save space) [911119]
 20892  beb3 a001                                ldy #1
 20893  beb5 9dc412             l315_6           sta sound_time_hi,x                      ; turn all SOUND counters off
 20894  beb8 995d12                              sta voices,y                             ; turn all PLAY counters off
 20895  bebb c8                                  iny
 20896  bebc c8                                  iny
 20897  bebd ca                                  dex
 20898  bebe 10f5                                bpl l315_6
 20899                          
 20900  bec0 a005                                ldy #6-1                                 ; set default envelope (piano) for all voices (6)
 20901  bec2 8c6f12                              sty voice
 20902  bec5 a200               l315_7           ldx #0
 20903  bec7 200748                              jsr set_envelope_1
 20904  beca ce6f12                              dec voice
 20905  becd 10f6                                bpl l315_7
 20906  becf ee6f12                              inc voice                                ; set default voice (0)
 20907                          
 20908  bed2 28                                  plp
 20909  bed3 60                                  rts
 20910                          
 20911                          ;[[initialise.sprites]]
 20912                          
 20913                          Sprite_CLR
 20914  bed4 2022b5                              jsr chkeos                               ; eat CLR token, check eos   [910717] new
 20915                          Sprite_CLR_1
 20916  bed7 08                                  php
 20917  bed8 78                                  sei
 20918  bed9 a900                                lda #0
 20919  bedb 8d15d0                              sta vic+21                               ; Turn off all sprites
 20920  bede 8d17d0                              sta vic+23                               ; Unexpand them     [910828]
 20921  bee1 8d1bd0                              sta vic+27                               ; Sprite priority
 20922  bee4 8d1cd0                              sta vic+28                               ; Hires sprites
 20923  bee7 8d1dd0                              sta vic+29
 20924                          
 20925  beea a257                                ldx #init_as_0                           ; Init sprite tables
 20926  beec 9d0512             l316_1           sta sprite_data,x
 20927  beef ca                                  dex
 20928  bef0 10fa                                bpl l316_1
 20929                          
 20930  bef2 a91f                                lda #sprite_base/64+7                    ; Set up sprite pointers
 20931  bef4 a007                                ldy #7
 20932  bef6 7fd705             l316_2           bbr7 _mode,l316_3
 20933  bef9 99f80b                              sta sprite_ptrs_40,y                     ; 40 col screen
 20934  befc 8003                                bra l316_4
 20935  befe 99f80f             l316_3           sta sprite_ptrs_80,y                     ; 80 col screen
 20936  bf01 3a                 l316_4           dec
 20937  bf02 88                                  dey
 20938  bf03 10f1                                bpl l316_2
 20939                          
 20940  bf05 28                                  plp
 20941                          ; rts
 20942                          
 20943                          ;.end
 20944                          ;[[handler.nmi]]
 20945                          
 20946                          
 20947                          
 20948                          basic_nmi                                                 ; removed [910826]
 20949                          ; lda nmi_wrap_flag ;filter out wrapped NMI calls   [910523] audio
 20950                          ; beq 1$   ; it's ok
 20951                          ; rts   ; exit- we're already handling one interrupt
 20952                          ;
 20953                          ;1$ inc nmi_wrap_flag ;shut the door to NMI
 20954                          ;
 20955                          ;basic_nmi_end
 20956                          ; dec nmi_wrap_flag ;open the door to NMI
 20957  bf06 60                                  rts
 20958                          
 20959                          
 20960                          
 20961                          
 20962                          ;.end
 20963                          ;[[jumptable]]
 20964                          
 20965                          
 20966                          
 20967                                           * = $7f00
 20968                          
 20969                          
 20970                          ; Format Conversions     [6]
 20971                          
 20972  7f00 83b2d9                              +lbra ayint                              ; convert floating point to integer
 20973  7f03 833acf                              +lbra givayf                             ; convert integer to floating point
 20974  7f06 8387e5                              +lbra fout                               ; convert floating point to PETSCII string
 20975  7f09 8341d6                              +lbra val_1                              ; convert PETSCII string to floating point
 20976  7f0c 837fde                              +lbra getadr                             ; convert floating point to an address
 20977  7f0f 83cee3                              +lbra floatc                             ; convert address to floating point
 20978                          
 20979                          ; Math Functions     [24]
 20980                          
 20981  7f12 8391de                              +lbra fsub                               ; MEM - FACC
 20982  7f15 8391de                              +lbra fsubt                              ; ARG - FACC
 20983  7f18 83a1de                              +lbra fadd                               ; MEM + FACC
 20984  7f1b 83ffe4                              +lbra faddt_c65                          ; ARG - FACC      [910402]
 20985  7f1e 834de1                              +lbra fmult                              ; MEM * FACC
 20986  7f21 8340e1                              +lbra fmultt_c65                         ; ARG * FACC      [910402]
 20987  7f24 835ce2                              +lbra fdiv                               ; MEM / FACC
 20988  7f27 834fe2                              +lbra fdivt_c65                          ; ARG / FACC      [910402]
 20989  7f2a 83e2e0                              +lbra log                                ; compute natural log of FACC
 20990  7f2d 8334e4                              +lbra int                                ; perform BASIC INT() on FACC
 20991  7f30 838ae6                              +lbra sqr                                ; compute square root of FACC
 20992  7f33 83c7e6                              +lbra negop                              ; negate FACC
 20993  7f36 838be6                              +lbra fpwr                               ; raise ARG to the MEM power
 20994  7f39 838be6                              +lbra fpwrt                              ; raise ARG to the FACC power
 20995  7f3c 83c9e6                              +lbra exp                                ; compute EXP of FACC
 20996  7f3f 835de7                              +lbra cos                                ; compute COS of FACC
 20997  7f42 8361e7                              +lbra sin                                ; compute SIN of FACC
 20998  7f45 83a7e7                              +lbra tan                                ; compute TAN of FACC
 20999  7f48 83d5e7                              +lbra atn                                ; compute ATN of FACC
 21000  7f4b 8365e3                              +lbra round                              ; round FACC
 21001  7f4e 839ee3                              +lbra abs                                ; absolute value of FACC
 21002  7f51 836ee3                              +lbra sign                               ; test sign of FACC
 21003  7f54 839be3                              +lbra fcomp                              ; compare FACC with MEM
 21004  7f57 83cdd8                              +lbra rnd_0                              ; generate random floating point number
 21005                          
 21006                          ; Movement      [22]
 21007                          
 21008  7f5a 839be1                              +lbra conupk                             ; move RAM MEM to ARG
 21009  7f5d 836de1                              +lbra romupk                             ; move ROM MEM to ARG
 21010  7f60 83f0cf                              +lbra movfrm                             ; move RAM MEM to FACC
 21011  7f63 83a9e2                              +lbra movfm                              ; move ROM MEM to FACC
 21012  7f66 83d2e2                              +lbra movmf                              ; move FACC to MEM
 21013  7f69 8328e3                              +lbra movfa                              ; move ARG to FACC
 21014  7f6c 8335e3                              +lbra movaf                              ; move FACC to ARG
 21015                          
 21016                          ; bra optab ;????not executable
 21017                          ; bra drawln
 21018                          ; bra gplot
 21019                          ; bra cirsub
 21020  7f6f 8343be                              +lbra run
 21021  7f72 832db5                              +lbra runc
 21022  7f75 8354b5                              +lbra clearc                             ; [910410]
 21023  7f78 83dbb4                              +lbra new
 21024  7f7b 833cb1                              +lbra link_program
 21025  7f7e 839fa3                              +lbra crunch
 21026  7f81 8377b2                              +lbra FindLine
 21027  7f84 8387ac                              +lbra newstt
 21028  7f87 8359ce                              +lbra eval
 21029  7f8a 8363cd                              +lbra frmevl
 21030  7f8d 8334be                              +lbra run_a_program
 21031  7f90 8309be                              +lbra setexc
 21032  7f93 8399b2                              +lbra linget
 21033  7f96 839bdc                              +lbra garba2
 21034  7f99 8376af                              +lbra execute_a_line
 21035                          
 21036                          ; Temporaries for C65 development (???? used by graphics) [12]
 21037                          
 21038  7f9c 83e5a2                              +lbra chrget
 21039  7f9f 83e4a2                              +lbra chrgot
 21040  7fa2 83b7ce                              +lbra chkcom
 21041  7fa5 8331cd                              +lbra frmnum
 21042  7fa8 83e3dd                              +lbra getadr
 21043  7fab 83cfdd                              +lbra getnum
 21044  7fae 83bcdd                              +lbra getbyt
 21045  7fb1 8372e9                              +lbra plsv
 21046                          
 21047  7fb4 8311a3                              +lbra lda_far_ram0                       ; lda (.x),y from BASIC text bank [910716]
 21048  7fb7 831ea3                              +lbra lda_far_ram1                       ; lda (.x),y from BASIC variable bank [910716]
 21049  7fba 8350a3                              +lbra sta_far_ram0                       ; sta (.x),y to   BASIC text bank [910716]
 21050  7fbd 8331a3                              +lbra sta_far_ram1                       ; sta (.x),y to   BASIC variable bank [910716]
 21051                          
 21052                          
 21053                          ; Graphic Kernel Call. (Temporary for C65 development ????)
 21054                          ;
 21055                          ;  syntax:  GRAPHIC command# [,args]
 21056                          ;
 21057                          ; Basically this is a modified C64-type SYS command, minus the address.
 21058                          ; In the final C65 system, this will represent the ML interface, not the
 21059                          ; BASIC 10.0 interface which is implemented here in the development system.
 21060                          
 21061                          
 21062                          graphic
 21063  7fc0 c99c                                cmp #clr_token                           ; GRAPHIC CLR (graphic system initialize)
 21064  7fc2 d006                                bne l317_1                               ; no
 21065  7fc4 208322                              jsr chrget                               ; yes advance past token
 21066  7fc7 6c0080                              jmp ($8000)                              ; go initialize graphic kernel
 21067                          
 21068                          l317_1
 21069                          ; tax
 21070                          ; bmi snerr  ;Syntax error if any other secondary token
 21071                          ;
 21072                          ;
 21073  7fca 6cfe02                              jmp (graphic_vector)                     ; Else, call the Graphics Kernel's Parser...
 21074                          ;
 21075                          ;
 21076                          graphic_kernel                                            ; ...via indirect
 21077  7fcd 6c0280                              jmp ($8002)
 21078                          
 21079                          
 21080                          ; C65 Graphic Kernel Jump Table      [910826]
 21081                          ;
 21082                          ; 8000 init   ;sets up graphic vars
 21083                          ; 8002 parser   ;GRAPHIC ML Parser????
 21084                          ;
 21085                          ; 8004 kg65.start-1  ;0 commands
 21086                          ; 8006 kg65.screendef-1 ;1
 21087                          ; 8008 kg65.screenopen-1 ;2
 21088                          ; 800a kg65.screenclose-1 ;3
 21089                          ; 800c kg65.screenclear-1 ;4
 21090                          ; 800e kg65.screen-1  ;5
 21091                          ; 8010 kg65.setpen-1  ;6
 21092                          ; 8012 kg65.setpalette-1 ;7
 21093                          ; 8014 kg65.setdmode-1  ;8
 21094                          ; 8016 kg65.setdpat-1  ;9
 21095                          ; 8018 kg65.line-1  ;10
 21096                          ; 801a kg65.box-1  ;11
 21097                          ; 801c kg65.circle-1  ;12
 21098                          ; 801e kg65.polygon-1  ;13
 21099                          ; 8020 kg65.ellipse-1  ;14
 21100                          ; 8022 kg65.viewpclr-1  ;15
 21101                          ; 8024 kg65.copy-1  ;16
 21102                          ; 8026 kg65.cut-1  ;17
 21103                          ; 8028 kg65.paste-1  ;18
 21104                          ; 802a kg65.load-1  ;19
 21105                          ; 802c kg65.char-1  ;20
 21106                          ; 802e kg65.paint-1  ;21
 21107                          ; 8030 kg65.viewpdef-1  ;22
 21108                          ; 8032 kg65.f.pixel-1  ;23
 21109                          ; 8034 kg65.f.rpalette-1 ;24
 21110                          ; 8036 kg65.f.index2color-1 ;25
 21111                          ; 8038 kg65.f.rgraphic  ;26
 21112                          
 21113                          
 21114                          
 21115                          
 21116                          
