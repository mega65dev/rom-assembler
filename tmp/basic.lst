
; ******** Source: basic.asm
     1                          ;
     2                          ;	THIS FILE IS AUTOMATICALLY GENERATED
     3                          ;

; ******** Source: system/header.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      header.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;  ***************************************************************************
    16                          ;  *                               //                                        *
    17                          ;  *              CCCCCCC         //    6666666     555555555                *
    18                          ;  *             CCC   CCC       //    666   666    555                      *
    19                          ;  *            CCC             //    666           555                      *
    20                          ;  *            CCC            //     666 6666      55555555                 *
    21                          ;  *            CCC           //      6666   666          555                *
    22                          ;  *            CCC          //       666     666          555               *
    23                          ;  *             CCC   CCC  //         666   666    555   555                *
    24                          ;  *              CCCCCCC  //           6666666      5555555                 *
    25                          ;  *                      //                                                 *
    26                          ;  *                                                                         *
    27                          ;  *          BBBBBBBBB      AAAA      SSSSSSSS   III    CCCCCCC             *
    28                          ;  *          BBB    BBB   AAA  AAA   SSS    SSS  III   CCC   CCC            *
    29                          ;  *          BBB    BBB  AAA    AAA  SSS         III  CCC                   *
    30                          ;  *          BBBBBBBBB   AAAAAAAAAA   SSSSSSSS   III  CCC                   *
    31                          ;  *          BBB    BBB  AAA    AAA         SSS  III  CCC                   *
    32                          ;  *          BBB    BBB  AAA    AAA  SSS    SSS  III   CCC   CCC            *
    33                          ;  *          BBBBBBBBB   AAA    AAA   SSSSSSSS   III    CCCCCCC             *
    34                          ;  *                                                                         *
    35                          ;  *                       V E R S I O N   1 0 . 0                           *
    36                          ;  *              *
    37                          ;  *        Copyright (C)1991  by   Commodore Business Machines, Inc.        *
    38                          ;  *              *
    39                          ;  *       All  Rights  Reserved        *
    40                          ;  *              *
    41                          ;  ***************************************************************************
    42                          
    43                          ;   ROM VERSION  911115  (ver 0.9B)
    44                          
    45                          ; ******************************************************************
    46                          ; *                                                                *
    47                          ; * This listing contains confidential and proprietary information *
    48                          ; * of CBM, Inc.  The reproduction, dissemination or disclosure to *
    49                          ; * others without express written permission is prohibited.  This *
    50                          ; * software is for use in prototype Commodore C/65 systems only.  *
    51                          ; *                                                                *
    52                          ; *  The information in this document will change without notice.  *
    53                          ; *                                                                *
    54                          ; *  No  responsibility  is  assumed  for the reliability of this  *
    55                          ; *                          software.                             *
    56                          ; *                                                                *
    57                          ; ******************************************************************
    58                          
    59                          
    60                          
    61                          ; This version written and assembled by Fred Bowen using BSO format.
    62                          
    63                          ; Adapted from the following C128 files, ROM part numbers 318018-04, 3180194-04:
    64                          ;
    65                          ; disclaim  resume   hexfunc
    66                          ; declare   doloop   rgr
    67                          ; entries   key   rclr
    68                          ; header   paint   joy
    69                          ; init   box   penpot
    70                          ; indjumps  sshape   pointer
    71                          ; crunch   gshape   rsprite
    72                          ; tokens1   circle   rspcolor
    73                          ; tokens2   draw   bump
    74                          ; disptable  char   rsppos
    75                          ; errmsgs   locate   xor
    76                          ; errprint  scale   rwindow
    77                          ; execute   color   rnd
    78                          ; functions  scnclr   code12
    79                          ; code0   graphic   stringfns
    80                          ; rtstack   bank   code17
    81                          ; findline  sleep   code18
    82                          ; lineget   wait   code19
    83                          ; list   sprite   code21
    84                          ; newclr   movspr   code22
    85                          ; return   play   code23
    86                          ; remdata   filter   code24
    87                          ; if   envelope  code26
    88                          ; ongoto   collision  grbcol
    89                          ; let   sprcolor  trig
    90                          ; print   width   using
    91                          ; input   volume   instring
    92                          ; next   sound   graphic3
    93                          ; dim   window   rdot
    94                          ; sys   boot   graphic7
    95                          ; trontroff  sprdef   graphic8
    96                          ; rreg   sprsav   graphic9
    97                          ; midequal  fast   graphic10
    98                          ; auto   slow   graphic11
    99                          ; help   checkval  sethires
   100                          ; gosubgoto  formeval  clrhires
   101                          ; go   variables  dos1
   102                          ; continue  getpointr  dos2
   103                          ; run   array   dos3
   104                          ; restore   patcheslo  dos4
   105                          ; renumber  fre   overflow
   106                          ; for   val   irq
   107                          ; delete   dec   stash
   108                          ; pudef   peekpoke  fetch
   109                          ; trap   errfunc   swap
   110                          ; patcheshi  jumptable  def
   111                          ; strings
   112                          
   113                          
   114                          
   115                          
   116                          
   117                          
   118                          
   119                          
   120                          
   121                          ; ********************************************************************************************
   122                          ;
   123                          ;	Date		Changes
   124                          ;	====		=======
   125                          ;
   126                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: data/constants.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      constants.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; General assignments and equates
    13                          
    14                          doslfn          = 0                                     ; DOS' private logical file number
    15                          dosffn          = 8                                     ; DOS' default drive number
    16                          
    17                          strsiz          = 3                                     ; string descriptor size in temps. and arrays
    18                          lengos          = 5                                     ; length of a GOSUB entry on the runtime stack
    19                          lenfor          = 18                                    ; length of a FOR entry in the runtime stack
    20                          
    21                          ; maxchr = 80  ;misc. command equates
    22                          ; llen  = 40
    23                          ; nlines = 25
    24                          column_width    = 10                                    ; print comma spacing
    25                          
    26                          beats_pal       = 1200                                  ; whole note (4/4 time = 2sec.)    [910724]
    27                          beats_ntsc      = 1440                                  ;
    28                          
    29                          lf              = $0a                                   ; line feed
    30                          cr              = $0d                                   ; carriage return
    31                          esc             = $1b                                   ; escape
    32                          pi              = $ff
    33                          
    34                          basbgn          = $2000                                 ; bottom of BASIC text bank
    35                          baswrk          = basbgn+1                              ; where BASIC text starts
    36                          varbgn          = $2000                                 ; bottom of BASIC data bank (C65: DOS RAM below $12000)
    37                          bank_0_top      = $8000                                 ; top of BASIC text bank ($FF00)    [910528]
    38                          bank_1_top      = $8000                                 ; top of BASIC data bank ($f800, VIC attributes)  [910528]
    39                          
    40                          ; graphic_base = $2000
    41                          ; color_ram_lo = $1c00
    42                          ; color_ram_hi = $d800
    43                          
    44                          vic             = $d000                                 ; Video controller
    45                          
    46                          fdc             = $d080                                 ; Built-in floppy disk controller
    47                          
    48                          sid1            = $d400                                 ; Audio processors (right)
    49                          sid2            = $d420                                 ; (left)
    50                          
    51                          d1_6526         = $dc00                                 ; Ports, peripheral control
    52                          d1pra           = d1_6526
    53                          d2_6526         = $dd00
    54                          d2pra           = d2_6526
    55                          
    56                          dma_ctlr        = $d700                                 ; DMA Controller
    57                          
    58                          
    59                          ;  BASIC base page storage
    60                          
    61                          ; ********************************************************************************************
    62                          ;
    63                          ;	Date		Changes
    64                          ;	====		=======
    65                          ;
    66                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: data/zeropage.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      zeropage.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                                          * = $0000
    14                          
    15  0000 0000                               !fill 2                                 ; '4510' registers (not used in C65 mode)
    16  0002 00                 srchtk          !fill 1                                 ; token 'search' looks for (run-time stack) / SYS 'bank#'
    17                          
    18                                          * = $000a                               ; skip over SYS address, status, a/x/y/z registers
    19                          
    20                          integr                                                  ; used by math routines (this & following location)
    21  000a 00                 charac          !fill 1
    22  000b 00                 endchr          !fill 1
    23  000c 00                 verck           !fill 1                                 ; LOAD/VERIFY flag
    24  000d 00                 count           !fill 1                                 ; temp used all over
    25  000e 00                 dimflg          !fill 1                                 ; DIM flag used by variable search
    26  000f 00                 valtyp          !fill 1                                 ; 0=numeric, $FF=string
    27  0010 00                 intflg          !fill 1                                 ; b7: (0=float,1=integer), b6: (1=get flag)
    28                          garbfl                                                  ; garbage collection temporary
    29  0011 00                 dores           !fill 1                                 ; b7: P1LINE quote flag
    30  0012 00                 subflg          !fill 1                                 ; b7: subscript flag (set to disallow subscripts() & integers%)
    31  0013 00                 input_flag      !fill 1                                 ; READ($98), GET($40), or INPUT($00)
    32                          domask
    33  0014 00                 tansgn          !fill 1
    34  0015 00                 channl          !fill 1                                 ; active I/O channel
    35                          poker                                                   ; temp used all over
    36  0016 0000               linnum          !fill 2                                 ; line number
    37                          
    38  0018 00                 temppt          !fill 1                                 ; pointer to next temporary descriptor in tempst
    39  0019 0000               lastpt          !fill 2                                 ; pointer to last used temporary string
    40  001b 0000000000000000...tempst          !fill 9                                 ; temporary descriptor pointers (3 at 3 bytes each)
    41                          
    42                          index
    43  0024 0000               index1          !fill 2
    44  0026 0000               index2          !fill 2
    45                          
    46                          multiplicand                                            ; 2 bytes wide, for unsigned integer multiply
    47  0028 00                 resho           !fill 1
    48  0029 00                 resmoh          !fill 1
    49                          product                                                 ; 3 bytes wide, for unsigned integer multiply
    50                          addend
    51  002a 00                 resmo           !fill 1
    52  002b 00                 reslo           !fill 1
    53  002c 00                                 !fill 1
    54  002d 0000               txttab          !fill 2                                 ; where BASIC program begins   (text_bank)
    55  002f 0000               vartab          !fill 2                                 ; where variable descriptors begin  (var_bank)
    56  0031 0000               arytab          !fill 2                                 ; where array table begins   (var_bank)
    57  0033 0000               strend          !fill 2                                 ; where arrays table ends   (var_bank)
    58  0035 0000               fretop          !fill 2                                 ; bottom of string storage   (var_bank)
    59  0037 0000               frespc          !fill 2                                 ; where temporary strings begin   (var_bank)
    60  0039 0000               max_mem_1       !fill 2                                 ; highest address available to BASIC in RAM 1 (var_bank)
    61  003b 0000               curlin          !fill 2
    62  003d 0000               txtptr          !fill 2                                 ; pointer to BASIC text used by CHRGET, etc.
    63                          form                                                    ; used by print using
    64  003f 0000               fndpnt          !fill 2                                 ; pointer to item found by search
    65  0041 0000               datlin          !fill 2
    66  0043 0000               datptr          !fill 2
    67  0045 0000               inpptr          !fill 2
    68  0047 0000               varnam          !fill 2
    69                          fdecpt
    70  0049 0000               varpnt          !fill 2
    71                          lstpnt
    72                          andmsk
    73  004b 0000               forpnt          !fill 2
    74                          eormsk          =forpnt+1
    75                          vartxt
    76  004d 0000               opptr           !fill 2
    77  004f 00                 opmask          !fill 1
    78                          grbpnt
    79                          tempf3
    80  0050 0000               defpnt          !fill 2
    81  0052 0000               dscpnt          !fill 2
    82                          token_saver                                             ; temp used by P1LINE/HELPSB (was spare????) [910628]
    83  0054 00                 trmpos          !fill 1                                 ; temp used by SPC(), TAB()   [910628]
    84                          
    85  0055 00                 helper          !fill 1                                 ; P1LINE flag b7: HELP vs. LIST
    86                          ;  b6: memory vs. file
    87                          ;  b5: FIND/CHANGE
    88                          ;  b4: highlight tokens
    89                          ;  b3: highlight REM
    90                          ;  b1: LINGET flag for AUTOSCROLL
    91                          ;  b0: token in progress
    92                          
    93  0056 00                 jmper           !fill 1                                 ; 3 locations used by Function handler
    94  0057 00                                 !fill 1                                 ;
    95  0058 00                 oldov           !fill 1                                 ;
    96                          
    97  0059 00                 tempf1          !fill 1                                 ; used by math routines
    98                          ptarg1          =tempf1                                 ; multiply defined for INSTR thru FACexp
    99                          ptarg2          =tempf1+2                               ; (also used by Monitor Utility, thru lowtr)
   100                          str1            =tempf1+4
   101                          str2            =tempf1+7
   102                          positn          =tempf1+10
   103                          match           =tempf1+11
   104                          
   105                          arypnt
   106  005a 0000               highds          !fill 2
   107  005c 0000               hightr          !fill 2
   108                          
   109  005e 00                 tempf2          !fill 1                                 ; used by math routines
   110  005f 0000               deccnt          !fill 2
   111                          tenexp          = deccnt+1
   112                          grbtop
   113                          dptflg
   114  0061 00                 lowtr           !fill 1
   115  0062 00                 expsgn          !fill 1
   116                          
   117                          fac                                                     ; Floating point accumulator (primary) FAC1
   118                          dsctmp
   119  0063 00                 facexp          !fill 1
   120  0064 00                 facho           !fill 1
   121  0065 00                 facmoh          !fill 1
   122                          indice
   123  0066 00                 facmo           !fill 1
   124  0067 00                 faclo           !fill 1
   125  0068 00                 facsgn          !fill 1
   126                          degree
   127  0069 00                 sgnflg          !fill 1
   128                          
   129  006a 00                 argexp          !fill 1                                 ; Floating point accumulator (secondary) FAC2
   130  006b 00                 argho           !fill 1
   131  006c 00                 argmoh          !fill 1
   132  006d 00                 argmo           !fill 1
   133  006e 00                 arglo           !fill 1
   134  006f 00                 argsgn          !fill 1
   135                          
   136                          strng1
   137  0070 00                 arisgn          !fill 1
   138  0071 00                 facov           !fill 1
   139                          
   140                          strng2
   141                          polypt
   142                          curtol
   143  0072 0000               fbufpt          !fill 2
   144                          
   145  0074 0000               autinc          !fill 2                                 ; incremental value for AUTO (0=off)
   146                          
   147  0076 00                 z_p_temp_1      !fill 1                                 ; USING's leading zero counter
   148                          ;GET, RENUMBER, KEY temporary
   149                          ;MOVSPR, SPRITE, PLAY, VOL temporary
   150                          ;MID$= temporary
   151                          
   152                          hulp                                                    ; counter
   153  0077 00                 keysiz          !fill 1
   154                          
   155  0078 00                 syntmp          !fill 1                                 ; used as temp all over the place
   156  0079 000000             dsdesc          !fill 3                                 ; descriptor for DS$
   157  007c 0000               tos             !fill 2                                 ; top of run time stack
   158  007e 00                 runmod          !fill 1                                 ; flags run/direct(b7), load(b6), trace(b5), edit(b4) modes
   159                          ; autoboot wedge (b0)
   160                          point                                                   ; USING's pointer to decimal point, 2 bytes used by AutoScroll
   161  007f 00                 parsts          !fill 1                                 ; DOS parser status word
   162  0080 00                 parstx          !fill 1                                 ; DOS parser status extensions
   163                          
   164  0081 00                 oldstk          !fill 1                                 ; BASIC saves uP stack pointer here
   165                          
   166  0082 0000               text_top        !fill 2                                 ; top of BASIC text pointer  (in text_bank)
   167  0084 00                 text_bank       !fill 1                                 ; where BASIC text lives   (RAM0 default)
   168  0085 00                 var_bank        !fill 1                                 ; where BASIC vars live   (RAM1 default)
   169                          sys_bank        = 0                                     ; where system space is  ???? (RAM0, make this a var?)
   170                          
   171  0086 00                 sid_speed_flag  !fill 1                                 ; saves system speed during SID ops (used during IRQ)
   172                          
   173                          time                                                    ; temporaries for TI, TI$, SLEEP (4 bytes)
   174                          grapnt                                                  ; used by SPRSAV, RMOUSE, RCOLOR
   175                          op
   176  0087 00                 column          !fill 1                                 ; temporaries for FIND/CHANGE, [L]INPUT, [L]READ, CURSOR
   177                          srow
   178  0088 000000             fstr1           !fill 3                                 ;
   179  008b 000000             fstr2           !fill 3                                 ;
   180                          
   181                          
   182                          
   183                          ; ********************************************************************************************
   184                          ;
   185                          ;	Date		Changes
   186                          ;	====		=======
   187                          ;
   188                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/stackdata.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      stackdata.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                                          * = $00ff
    14                          
    15  00ff 00                 lofbuf          !fill 1
    16  0100 0000000000000000...fbuffr          !fill 16                                ; MathPack builds numbers here, USING, RENUMBER
    17                          
    18                          ;  Kernel MAP configurations & DMA lists
    19                          
    20  0110 0000000000000000...                !fill 16+36                             ; (4 configs + 3 DMA lists)
    21                          
    22                          ;  BASIC DMA lists  (2 @ 12bytes each = 24 bytes)
    23                          
    24  0144 00                 dma1_cmd        !fill 1                                 ; This list is used by BASIC OS
    25  0145 00                 dma1_cnt_lo     !fill 1
    26  0146 00                 dma1_cnt_hi     !fill 1
    27  0147 00                 dma1_src_lo     !fill 1
    28  0148 00                 dma1_src_hi     !fill 1
    29  0149 00                 dma1_src_bank   !fill 1
    30  014a 00                 dma1_dest_lo    !fill 1
    31  014b 00                 dma1_dest_hi    !fill 1
    32  014c 00                 dma1_dest_bank  !fill 1
    33  014d 00                 dma1_subcmd     !fill 1                                 ; (from here on not supported until F018A) [910520] F018A
    34  014e 00                 dma1_mod_lo     !fill 1
    35  014f 00                 dma1_mod_hi     !fill 1
    36                          
    37  0150 00                 dma2_cmd        !fill 1                                 ; This list is used by DMA command & Graphics
    38  0151 00                 dma2_cnt_lo     !fill 1
    39  0152 00                 dma2_cnt_hi     !fill 1
    40  0153 00                 dma2_src_lo     !fill 1
    41  0154 00                 dma2_src_hi     !fill 1
    42  0155 00                 dma2_src_bank   !fill 1
    43  0156 00                 dma2_dest_lo    !fill 1
    44  0157 00                 dma2_dest_hi    !fill 1
    45  0158 00                 dma2_dest_bank  !fill 1
    46  0159 00                 dma2_subcmd     !fill 1                                 ; (from here on not supported until F018A) [910520] F018A
    47  015a 00                 dma2_mod_lo     !fill 1
    48  015b 00                 dma2_mod_hi     !fill 1
    49                          
    50  015c 00                                 !fill 1                                 ; Kernel's dma_byte
    51                          
    52                          sysstk                                                  ; bottom of system stack
    53                          stkend          = $1fb                                  ; top of system stack
    54                          
    55                          
    56                          ; ********************************************************************************************
    57                          ;
    58                          ;	Date		Changes
    59                          ;	====		=======
    60                          ;
    61                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: data/memory.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      memory.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                                          * = $0200
    15                          
    16                          buflen          = 161                                   ; input buffer size (2 80-column lines + 1)
    17  0200 0000000000000000...buf             !fill buflen                            ; BASIC/Monitor line input buffer
    18                          buf_txtptr      = buf-1
    19                          
    20                          
    21                                          * = $02c0
    22                          ; BASIC RAM code  (RAM code not needed- following moved to ROM)
    23                          ;
    24                          ; chrget *=*+42  ;get byte from text bank after incrementing TXTPTR
    25                          ; chrgot = chrget+2 ;get byte from text bank at TXTPTR
    26                          ; qnum  = chrget+27 ;evaluate byte as a number & set flags accordingly
    27                          
    28  02c0 0000               adray1          !fill 2                                 ; ptr to routine:  convert float -> integer ???? why keep
    29  02c2 0000               adray2          !fill 2                                 ; ptr to routine:  convert integer -> float ???? why keep
    30  02c4 000000             zero            !fill 3                                 ; numeric constant for BASIC, downloaded from ROM
    31                          
    32  02c7 00                 errnum          !fill 1                                 ; used by error trapping routine-last error number
    33  02c8 0000               errlin          !fill 2                                 ; line # of last error ($FFFF if no error)
    34  02ca 0000               trapno          !fill 2                                 ; line to go to on error ($FFxx if none set)
    35  02cc 00                 tmptrp          !fill 1                                 ; hold trap # temporary
    36  02cd 0000               errtxt          !fill 2                                 ; pointer to statement causing last error
    37  02cf 0000               max_mem_0       !fill 2                                 ; highest address available to BASIC in RAM 0 (text bank)
    38                          
    39  02d1 00                 current_bank    !fill 1                                 ; context for PEEK,POKE,BOOT,SYS,WAIT,BLOAD/SAVE set by BANK.
    40  02d2 00                 fin_bank        !fill 1                                 ; bank pointer for string->number conversion routine FIN
    41  02d3 00000000           tmpdes          !fill 4                                 ; pointers to temporary descriptors for INSTR
    42  02d7 00                 bits            !fill 1                                 ; flag for math bit/byte shifter
    43  02d8 00                 highlight_color !fill 1                                 ; color for highlighting text
    44  02d9 00                 highlight_save  !fill 1                                 ; saves normal color during highlighting, msb=flag
    45  02da 00                 find_count      !fill 1                                 ; count for LIST to highlight FIND text
    46                          
    47                          ; Interrupt stuff
    48                          
    49  02db 00                 irq_wrap_flag   !fill 1                                 ; used by BASIC_IRQ to block all but one IRQ call
    50  02dc 00                 intval          !fill 1                                 ; BASIC interrupts enabled (via collision command)
    51  02dd 000000             int_trip_flag   !fill 3                                 ; flags which interrupts occurred
    52  02e0 000000             int_adr_lo      !fill 3                                 ; where to go for each type of collision (line number)
    53  02e3 000000             int_adr_hi      !fill 3                                 ;
    54  02e6 0000               collisions      !fill 2                                 ; sprite collisions, s/s and s/bgnd, recorded during IRQ
    55  02e8 00                 lightpen_xpos   !fill 1                                 ; lightpen position recorded during IRQ
    56  02e9 00                 lightpen_ypos   !fill 1
    57                          
    58                          ; dejavu *=*+1  ;'cold' or 'warm' reset status (must be in page 5!)????
    59                          
    60                          ; nmi_wrap_flag *=*+1  ;used by BASIC_NMI to block all but one NMI call [910523]
    61                          ;    ; (removed)      [910826]
    62                          ;(leaving 12 bytes)
    63                          
    64                          ; BASIC indirect vectors
    65                          
    66                                          * = $02f7
    67                          
    68  02f7 000000             usrpok          !fill 3                                 ; USR vector (must be set by application)
    69                          
    70                          vectors_begin
    71  02fa 0000               iAutoScroll     !fill 2                                 ; AutoScroll vector
    72  02fc 0000               esc_fn_vec      !fill 2                                 ; Escape Function vector
    73  02fe 0000               graphic_vector  !fill 2                                 ; Graphic Kernel vector (was 'bnkvec')
    74  0300 0000               ierror          !fill 2                                 ; indirect error (output error in .x)
    75  0302 0000               imain           !fill 2                                 ; indirect main (system direct loop)
    76  0304 0000               icrnch          !fill 2                                 ; indirect crunch (tokenization routine)
    77  0306 0000               iqplop          !fill 2                                 ; indirect list (char list)
    78  0308 0000               igone           !fill 2                                 ; indirect gone (char dispatch)
    79  030a 0000               ieval           !fill 2                                 ; indirect eval (symbol evaluation)
    80  030c 0000               iesclk          !fill 2                                 ; escape token crunch
    81  030e 0000               iescpr          !fill 2                                 ; escape token list
    82  0310 0000               iescex          !fill 2                                 ; escape token execute
    83  0312 0000               itime           !fill 2                                 ; 60Hz interrupt vector (before jiffy)
    84  0314 0000               cinv            !fill 2                                 ; IRQ RAM vector
    85  0316 0000               cbinv           !fill 2                                 ; BRK RAM vector
    86                          
    87                          ; Remainder of this area reserved for Kernel indirects & Kernel RAM code
    88                          
    89                          
    90                                          * = $0400                               ; BASIC's run-time stack (2 pages)
    91                          stktop                                                  ; (also used by BOOT SYS and Monitor)
    92                          stkbot          = $05ff
    93                          
    94                          
    95                                          * = $0600                               ; Sprite definitions (2 pages, must be below $1000)
    96                          sprite_base
    97                          
    98                          
    99                                          * = $0800
   100                          screen_start                                            ; Text display screen
   101                                          * = *+2000
   102                          
   103                          sprite_ptrs_40  = screen_start+$3f8
   104                          sprite_ptrs_80  = screen_start+$7f8
   105                          
   106                          
   107                                          * = $1170                               ; previous to this used by Kernel
   108                          
   109  1170 0000               oldlin          !fill 2                                 ; BASIC storage
   110  1172 0000               oldtxt          !fill 2                                 ; BASIC storage
   111  1174 0000000000         rndx            !fill 5                                 ; Floating Point representation of last random #
   112                          
   113                          
   114                          ; Yet more temporaries shared by various routines
   115                          
   116                          window_temp                                             ; window  (4 bytes)
   117                          t3                                                      ; dcat  (1 byte)
   118                          renum_tmp_1                                             ; renumber (2 bytes)
   119  1179 0000               tmptxt          !fill 2                                 ; do/loop (2 bytes)
   120                          
   121                          t4                                                      ; dcat  (2 bytes)
   122                          renum_tmp_2                                             ; renumber (2 bytes)
   123  117b 0000               tmplin          !fill 2                                 ; do/loop (2 bytes)
   124                          
   125                          
   126                          ;  BASIC/DOS interface vars  (20 bytes)
   127                          
   128  117d 0000               dosofl          !fill 2                                 ; BLOAD/BSAVE starting addr
   129  117f 0000               dosofh          !fill 2                                 ; BSAVE ending addr
   130  1181 00                 dosla           !fill 1                                 ; DOS logical addr
   131  1182 00                 dosfa           !fill 1                                 ; DOS physical addr
   132  1183 00                 dossa           !fill 1                                 ; DOS secondary addr
   133                          
   134  1184 00                 xcnt            !fill 1                                 ; DOS loop counter------ this area zeroed-out each DOS call -----
   135  1185 00                 dosf1l          !fill 1                                 ; DOS filename 1 len
   136  1186 00                 dosds1          !fill 1                                 ; DOS disk drive 1
   137  1187 00                 dosf2l          !fill 1                                 ; DOS filename 2 len
   138  1188 00                 dosds2          !fill 1                                 ; DOS disk drive 2
   139  1189 0000               dosf2a          !fill 2                                 ; DOS filename 2 addr
   140  118b 00                 dosrcl          !fill 1                                 ; DOS record length
   141  118c 00                 dosbnk          !fill 1                                 ; DOS load/save bank
   142  118d 0000               dosdid          !fill 2                                 ; DOS ID identifier
   143  118f 00                 dosflags        !fill 1                                 ; DOS flags  7:ID,  6:recover
   144  1190 00                 dossa_temp      !fill 1                                 ; temp storage for file's sa during RECORD command
   145                          dosspc          = *-xcnt                                ; space used by DOS routines-------------------------------------
   146                          
   147  1191 0000000000000000...savram          !fill 67                                ; buffer used by MOVSPR, SPRDEF, SAVSPR, and DOS parser
   148                          
   149                          xabs            = savram                                ; movspr_line calculations   [910809]
   150                          yabs            = savram+2
   151                          xsgn            = savram+4
   152                          ysgn            = savram+6
   153                          fct             = savram+8
   154                          errval          = savram+12
   155                          
   156                          
   157                          ; PRINT USING definitions & storage  (24 bytes)
   158                          
   159                          puchrs                                                  ; Declarations for PRINT USING...
   160  11d4 00                 pufill          !fill 1                                 ; print using fill symbol
   161  11d5 00                 pucoma          !fill 1                                 ; print using comma symbol
   162  11d6 00                 pudot           !fill 1                                 ; print using decimal point symbol
   163  11d7 00                 pumony          !fill 1                                 ; print using monetary symbol
   164                          
   165  11d8 00                 bnr             !fill 1                                 ; pointer to begin #
   166  11d9 00                 enr             !fill 1                                 ; pointer to end #
   167  11da 00                 dolr            !fill 1                                 ; dollar flag
   168  11db 00                 flag            !fill 1                                 ; comma flag (also used by PLAY)????
   169  11dc 00                 swe             !fill 1                                 ; counter
   170  11dd 00                 usgn            !fill 1                                 ; sign exponent
   171  11de 00                 uexp            !fill 1                                 ; pointer to exponent
   172  11df 00                 vn              !fill 1                                 ; # of digits before decimal point
   173  11e0 00                 chsn            !fill 1                                 ; justify flag
   174  11e1 00                 vf              !fill 1                                 ; # of positions before decimal point (field)
   175  11e2 00                 nf              !fill 1                                 ; # of positions after decimal point (field)
   176  11e3 00                 posp            !fill 1                                 ; +/- flag (field)
   177  11e4 00                 fesp            !fill 1                                 ; exponent flag (field)
   178  11e5 00                 etof            !fill 1                                 ; switch
   179  11e6 00                 cform           !fill 1                                 ; char counter (field)
   180  11e7 00                 sno             !fill 1                                 ; sign no
   181  11e8 00                 blfd            !fill 1                                 ; blank/star flag
   182  11e9 00                 begfd           !fill 1                                 ; pointer to begin of field
   183  11ea 00                 lfor            !fill 1                                 ; length of format
   184  11eb 00                 endfd           !fill 1                                 ; pointer to end of field
   185                          
   186                          
   187                          ;  * = $1200 ;BASIC Graphic, Sprite, Music, & Sound storage
   188                          
   189                          ;  The following 24 bytes are multiply defined...
   190                          ;
   191                          ; params = *
   192                          
   193                          ;  Circle drawing variables  (multiply defined).
   194                          ;
   195                          ; xcircl *=*+2  ;circle center, x coordinate
   196                          ; ycircl *=*+2  ;circle center, y coordinate
   197                          ; xradus *=*+2  ;x radius
   198                          ; yradus *=*+2  ;y radius
   199                          ; rotang *=*+4  ;rotation angle
   200                          ; angbeg *=*+2  ;arc angle start
   201                          ; angend *=*+2  ;arc angle end
   202                          ; xrcos  *=*+2  ;x radius * cos(rotation angle)
   203                          ; yrsin  *=*+2  ;y radius * sin(rotation angle)
   204                          ; xrsin  *=*+2  ;x radius * sin(rotation angle)
   205                          ; yrcos  *=*+2  ;y radius * cos(rotation angle)
   206                          
   207                          ; parend = *
   208                          
   209                          ;  Box drawing variables  (multiply defined).
   210                          ;
   211                          ;  *=params
   212                          ; xcord1 *=*+2  ;point 1 x-coord.
   213                          ; ycord1 *=*+2  ;point 1 y-coord.
   214                          ; boxang *=*+2  ;rotation angle
   215                          ; xcount *=*+2
   216                          ; ycount *=*+2
   217                          ; bxleng *=*+2  ;length of a side
   218                          ; xcord2 *=*+2
   219                          ; ycord2 *=*+2
   220                          
   221                          
   222                          ;  Shape variables  (multiply defined).
   223                          ;
   224                          ;  *=params
   225                          ;  *=*+1  ;placeholder
   226                          ; keylen *=*+1
   227                          ; keynxt *=*+1
   228                          ; strsz  *=*+1  ;string len
   229                          ; gettyp *=*+1  ;replace shape mode
   230                          ; strptr *=*+1  ;string pos'n counter
   231                          ; oldbyt *=*+1  ;old bit map byte
   232                          ; newbyt *=*+1  ;new string or bit map byte
   233                          ;  *=*+1  ;placeholder
   234                          ; xsize  *=*+2  ;shape column length
   235                          ; ysize  *=*+2  ;shape row length
   236                          ; xsave  *=*+2  ;temp for column length
   237                          ; stradr *=*+2  ;save shape string descriptor
   238                          ; bitidx *=*+1  ;bit index into byte
   239                          
   240                          ;  General use parameters  (multiply defined).
   241                          ;
   242                          ;  *=params
   243                          ; xcentr *=*+2
   244                          ; ycentr *=*+2
   245                          ; xdist1 *=*+2
   246                          ; ydist1 *=*+2
   247                          ; xdist2 *=*+2
   248                          ; ydist2 *=*+2
   249                          ; disend
   250                          ;  *=*+2  ;placeholder
   251                          ; colcnt *=*+1  ;char's col. counter
   252                          ; rowcnt *=*+1
   253                          ; strcnt *=*+1
   254                          
   255                          
   256                          ;  General  graphic & sound  buffers & assignments
   257                          ;
   258                          ;  * = parend
   259                          
   260                          ;  General graphic storage (used by C128-type sprite routines in C65)
   261                          
   262                          vwork                                                   ; graphics & sprite vars
   263  11ec 0000               xpos            !fill 2                                 ; current x position
   264  11ee 0000               ypos            !fill 2                                 ; current y position
   265  11f0 0000               xdest           !fill 2                                 ; x-coordinate destination
   266  11f2 0000               ydest           !fill 2                                 ; y-coordinate destination
   267                          
   268  11f4 00                 numcnt          !fill 1                                 ; temp, usually coordinate type
   269  11f5 00                 vtemp1          !fill 1                                 ; used by sprite math stuff ????was base page
   270  11f6 00                 vtemp2          !fill 1                                 ; ????was base page
   271  11f7 00                 vtemp3          !fill 1                                 ; misc. graphic temp storage
   272  11f8 00                 vtemp4          !fill 1
   273  11f9 00                 vtemp5          !fill 1
   274                          
   275                          ; mvdflg *=*+1  ;flag if 10k hires allocated ???? this stuff was base page
   276                          ; colsel *=*+1  ;current color selected
   277                          ; multicolor_1 *=*+1
   278                          ; multicolor_2 *=*+1
   279                          ; foreground *=*+1
   280                          ; scalem *=*+1  ;scale mode flag
   281                          ; scale_x *=*+2  ;scale factor in x
   282                          ; scale_y *=*+2  ;scale factor in y
   283                          ; stopnb *=*+1  ;stop paint if not background/not same color
   284                          ; fg_bg  *=*+1  ;packed foreground/background color nybbles
   285                          ; fg_mc1 *=*+1  ;packed foreground/multicolor 1 color nybbles
   286                          
   287                          ; bitcnt *=*+1  ;temp for gshape
   288                          ; width  *=*+1  ;double width flag
   289                          ; filflg *=*+1  ;box fill flag
   290                          ; circle_segment *=*+1  ;degrees per circle segment
   291                          ; bitmsk *=*+1  ;temp for bit mask
   292                          
   293                          ; character_rom *=*+1  ;high byte of address of char rom for 'char' command
   294                          ; upper_lower *=*+1  ;pointer to upper/lower case for char command
   295                          ; upper_graphic *=*+1  ;   "       upper/graphic
   296                          
   297                          ;  DrawLine stuff
   298                          ;
   299                          ; xabs  *=*+2  ;16 bytes
   300                          ; yabs  *=*+2
   301                          ; xsgn  *=*+2
   302                          ; ysgn  *=*+2
   303                          ; fct  *=*+4
   304                          ; errval *=*+2
   305                          ; lesser *=*+1
   306                          ; greatr *=*+1
   307                          
   308                          ;  Angle stuff (used by sprites)
   309                          
   310  11fa 00                 angsgn          !fill 1                                 ; sign of angle
   311  11fb 0000               sinval          !fill 2                                 ; sine of value of angle
   312  11fd 0000               cosval          !fill 2                                 ; cosine of value of angle
   313                          ; angcnt *=*+2  ;temps for angle distance routines
   314                          
   315                          
   316                          ; Sprite stuff
   317                          
   318  11ff 00000000           savsiz          !fill 4                                 ; temp work locations for SSHAPE, SPRSAV, MOVSPR_TO
   319                          lesser
   320  1203 00                 sprtmp_1        !fill 1                                 ; temp for SPRSAV
   321                          greatr
   322  1204 00                 sprtmp_2        !fill 1
   323                          
   324  1205 0000000000000000...sprite_data     !fill 88                                ; speed/direction tables for 8 sprites, 11 bytes each
   325                          ;   move ang/dist move line
   326                          ; offset= 0 b7=0+speed b7=1+speed
   327                          ;  1 counter  counter lo
   328                          ;  2 angle sign         hi
   329                          ;  3,4 delta-X  dir+min/max
   330                          ;  5,6 delta-Y  fct1
   331                          ;  7,8 total-X  fct2
   332                          ;  9,10 total-Y  error
   333                          
   334                          init_as_0       = *-sprite_data-1
   335                          
   336                          ; vic_save *=*+21  ;copy of VIC reg's, used to update chip during retrace
   337                          
   338                          ; defmod *=*+1  ;for SPRDEF
   339                          ; lincnt *=*+1  ; "
   340                          ; sprite_number *=*+1  ; "
   341                          
   342                          
   343                          ; Music stuff driving stereo SIDs, 3 voices each
   344                          
   345  125d 0000000000000000...voices          !fill 12                                ; Voice counters (activity flags)  [910612] stereo
   346  1269 000000000000       waveform        !fill 6                                 ; Waveforms for each voice   [910612] stereo
   347                          
   348  126f 00                 voice           !fill 1                                 ; Play note parameters
   349  1270 00                 octave          !fill 1
   350  1271 00                 sharp           !fill 1
   351  1272 00                 dnote           !fill 1
   352  1273 00                 tempo_rate      !fill 1                                 ; duration of whole note 4/4 time = 24/rate
   353  1274 0000               pitch           !fill 2
   354  1276 0000               ntime           !fill 2
   355                          
   356  1278 00000000           filters1        !fill 4                                 ; Volume & Filter parameters   [910612] was 5
   357  127c 00000000           filters2        !fill 4                                 ; [910612] stereo
   358  1280 00000000           fltsav          !fill 4                                 ; temps
   359  1284 00                 fltflg          !fill 1                                 ; temp
   360                          
   361  1285 00                 tonnum          !fill 1                                 ; Tune Envelope stuff
   362  1286 000000             tonval          !fill 3
   363                          
   364  1289 0000000000000000...atktab          !fill 10                                ; Tune Envelopes
   365  1293 0000000000000000...sustab          !fill 10
   366  129d 0000000000000000...wavtab          !fill 10
   367  12a7 0000000000000000...pulslw          !fill 10
   368  12b1 0000000000000000...pulshi          !fill 10
   369                          
   370  12bb 00                 parcnt          !fill 1                                 ; temp: envelope
   371  12bc 00                 nibble          !fill 1                                 ; temp: envelope, filter
   372                          
   373                          
   374                          ; SOUND command stuff
   375                          
   376  12bd 00                 sound_voice     !fill 1
   377  12be 000000000000       sound_time_lo   !fill 3+3                               ; [910612] stereo
   378  12c4 000000000000       sound_time_hi   !fill 3+3                               ; [910612] stereo
   379  12ca 000000000000       sound_max_lo    !fill 3+3                               ; [910612] stereo
   380  12d0 000000000000       sound_max_hi    !fill 3+3                               ; [910612] stereo
   381  12d6 000000000000       sound_min_lo    !fill 3+3                               ; [910612] stereo
   382  12dc 000000000000       sound_min_hi    !fill 3+3                               ; [910612] stereo
   383  12e2 000000000000       sound_direction !fill 3+3                               ; [910612] stereo
   384  12e8 000000000000       sound_step_lo   !fill 3+3                               ; [910612] stereo
   385  12ee 000000000000       sound_step_hi   !fill 3+3                               ; [910612] stereo
   386  12f4 000000000000       sound_freq_lo   !fill 3+3                               ; [910612] stereo
   387  12fa 000000000000       sound_freq_hi   !fill 3+3                               ; [910612] stereo
   388                          
   389                          ;above must end before $1300
   390                                          * = $1160
   391                          ;below must end before $1170
   392                          
   393  1160 00                 temp_time_lo    !fill 1
   394  1161 00                 temp_time_hi    !fill 1
   395  1162 00                 temp_max_lo     !fill 1
   396  1163 00                 temp_max_hi     !fill 1
   397  1164 00                 temp_min_lo     !fill 1
   398  1165 00                 temp_min_hi     !fill 1
   399  1166 00                 temp_direction  !fill 1
   400  1167 00                 temp_step_lo    !fill 1
   401  1168 00                 temp_step_hi    !fill 1
   402  1169 00                 temp_freq_lo    !fill 1
   403  116a 00                 temp_freq_hi    !fill 1
   404  116b 00                 temp_pulse_lo   !fill 1
   405  116c 00                 temp_pulse_hi   !fill 1
   406  116d 00                 temp_waveform   !fill 1
   407                          
   408  116e 00                 pot_temp_1      !fill 1                                 ; temporaries for 'POT' function
   409  116f 00                 pot_temp_2      !fill 1
   410                          
   411                          
   412                                          * = $1300
   413                          
   414  1300 0000000000000000...dosstr          !fill 256                               ; DOS input/output string buffer
   415                          
   416                          
   417                                          * = $1f00                               ; Graphics Kernel Interface
   418                          
   419  1f00 00                 GKI__parm1      !fill 1                                 ; ml interface parm values
   420  1f01 00                 GKI__parm2      !fill 1
   421  1f02 00                 GKI__parm3      !fill 1
   422  1f03 00                 GKI__parm4      !fill 1
   423  1f04 00                 GKI__parm5      !fill 1
   424  1f05 00                 GKI__parm6      !fill 1
   425  1f06 00                 GKI__parm7      !fill 1
   426  1f07 00                 GKI__parm8      !fill 1
   427  1f08 00                 GKI__parm9      !fill 1
   428  1f09 00                 GKI__parm10     !fill 1
   429  1f0a 00                 GKI__parm11     !fill 1
   430  1f0b 00                 GKI__parm12     !fill 1
   431  1f0c 00                 GKI__parm13     !fill 1
   432  1f0d 00                 GKI__parm14     !fill 1
   433  1f0e 00                 GKI__parm15     !fill 1
   434  1f0f 00                 GKI__parm16     !fill 1
   435  1f10 00                 GKI__parm17     !fill 1
   436                          
   437  1f11 00                 GKI__subparm1   !fill 1                                 ; subroutine parm values
   438  1f12 00                 GKI__subparm2   !fill 1
   439  1f13 00                 GKI__subparm3   !fill 1
   440  1f14 00                 GKI__subparm4   !fill 1
   441  1f15 00                 GKI__subparm5   !fill 1
   442                          
   443  1f16 00                 GKI__temp1      !fill 1                                 ; local variables within subroutines
   444  1f17 00                 GKI__temp2      !fill 1
   445  1f18 00                 GKI__temp3      !fill 1
   446  1f19 00                 GKI__temp4      !fill 1
   447  1f1a 00                 GKI__temp5      !fill 1
   448  1f1b 00                 GKI__temp6      !fill 1
   449  1f1c 00                 GKI__temp7      !fill 1
   450  1f1d 00                 GKI__temp8      !fill 1
   451  1f1e 00                 GKI__temp9      !fill 1
   452  1f1f 00                 GKI__temp10     !fill 1
   453  1f20 00                 GKI__temp11     !fill 1
   454  1f21 00                 GKI__temp12     !fill 1
   455  1f22 00                 GKI__temp13     !fill 1
   456  1f23 00                 GKI__temp14     !fill 1
   457  1f24 00                 GKI__temp15     !fill 1
   458  1f25 00                 GKI__temp16     !fill 1
   459  1f26 00                 GKI__temp17     !fill 1
   460                          
   461                          ;.end
   462                          
   463                          
   464                          
   465                          ; ********************************************************************************************
   466                          ;
   467                          ;	Date		Changes
   468                          ;	====		=======
   469                          ;
   470                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: data/kernal.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      kernal.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; Addresses of OS parameters referenced by BASIC:
    13                          
    14                          _6510_data_reg  = $01
    15                          _bank           = $02                                   ; reg's for Kernel xxx_FAR routines (used by SYS)
    16                          _pchi           = $03
    17                          _pclo           = $04
    18                          _s_reg          = $05
    19                          _a_reg          = $06
    20                          _x_reg          = $07
    21                          _y_reg          = $08
    22                          _z_reg          = $09
    23                          
    24                          _vicIRQ         = $a0                                   ; VIC IRQ flag register at time of IRQ
    25                          _starting_addr  = $ac                                   ; address BLOAD loaded to
    26                          _sa             = $b9                                   ; I/O channel secondary address
    27                          _fa             = $ba                                   ; I/O channel device number
    28                          _ndx            = $d0                                   ; number of characters in keyboard buffer
    29                          _kyndx          = $d1                                   ; fkey active flag
    30                          _mode           = $d7                                   ; 40/80 mode
    31                          _graphm         = $d8                                   ; graphic mode switch (multi/hires/split)
    32                          _pnt            = $e0                                   ; Editor screen address at cursor
    33                          
    34                          _screen_bottom  = $e4                                   ; these describe the current window
    35                          _screen_top     = $e5
    36                          _screen_left    = $e6
    37                          _screen_right   = $e7
    38                          
    39                          _color          = $f1                                   ; text color      [910722]
    40                          _autoinsert     = $f6                                   ; enable/disable auto insert mode
    41                          _locks          = $f7                                   ; Editor keyboard locks     [910722]
    42                          
    43                          _keyd           = $02b0                                 ; keyboard buffer     [910710]
    44                          ;_split = $0a34  ;line to start split at
    45                          
    46                          number_fkeys    = 16                                    ; max of 14 prog. fn. keys
    47                          _pky_lengths    = $1000                                 ; table of prog. fn. key sizes
    48                          _pky_buffer     = _pky_lengths+number_fkeys             ; actual buffer
    49                          
    50                          _restart_vector = $1100                                 ; Kernel restart vector
    51                          _pal_ntsc       = $1103                                 ; PAL=$ff, NTSC=$00 indicator    [910107]
    52                          _init_status    = $1104                                 ; msb set tells Kernel to let BASIC have IRQs
    53                          _default_drive  = $1106                                 ; system default disk drive
    54                          _expansion      = $1107                                 ; expansion RAM (# banks????)    [910107]
    55                          _sleep_counter  = $110c                                 ; binary frame counter maintained by Kernel  [910730]
    56                          _mouse_enable   = $1135                                 ; port# used by mouse (b7=port2, b6=port1, or both) [910107]
    57                          _mouse_pointer  = $1136                                 ; sprite pointer (sprite*2) by Kernel mouse driver "
    58                          _mouse_top      = $113b                                 ; margins for mouse pointer    "
    59                          _mouse_bottom   = $113c                                 ; "
    60                          _mouse_left     = $113d                                 ; "
    61                          _mouse_right    = $113e                                 ; "
    62                          
    63                          ; Addresses of I/O areas referenced by BASIC:
    64                          
    65                          _red            = $d100                                 ; VIC palette (I/O block)
    66                          _green          = $d200
    67                          _blue           = $d300
    68                          
    69                          ; Addresses of Kernel entry points referenced by BASIC:
    70                          
    71                          _print          = $e00c
    72                          _mouse          = $e01b                                 ; [910122]
    73                          _set_window     = $e02d
    74                          _palette_init   = $e027
    75                          _cursor         = $e030                                 ; [910228]
    76                          ;_ldtb2 = $e033
    77                          ;_ldtb1 = $e04c
    78                          
    79                          _close_all      = $ff50                                 ; close all channels assigned to device .a
    80                          _go_64          = $ff53                                 ; C64 mode
    81                          _monitor        = $ff56                                 ; ML Monitor
    82                          _bootsys        = $ff59                                 ; Boot alternate OS     [910110]
    83                          _phoenix        = $ff5c                                 ; jump to 'post-BASIC initialize' routine
    84                          _lkupla         = $ff5f                                 ; find an available Logical Address
    85                          _lkupsa         = $ff62                                 ; find an available Secondary Address
    86                          _swapper        = $ff65                                 ; switch 80/40 column
    87                          _doakey         = $ff68                                 ; add/remove a definition from the p.f. key table
    88                          _setbank        = $ff6b                                 ; set bank for load/save/verify/open
    89                          _jsr_far        = $ff6e                                 ; call a subroutine in any bank
    90                          _jmp_far        = $ff71                                 ; jump to code in any bank
    91                          _lda_far        = $ff74                                 ; write a byte to any bank
    92                          _sta_far        = $ff77                                 ; read a byte from any bank
    93                          _cmp_far        = $ff7a                                 ; compare a byte to any bank
    94                          _primm          = $ff7d                                 ; print immediate
    95                          
    96                          _setmsg         = $ff90
    97                          _readst         = $ffb7
    98                          _setlfs         = $ffba
    99                          _setnam         = $ffbd
   100                          _open           = $ffc0
   101                          _close          = $ffc3
   102                          _chkin          = $ffc6
   103                          _chkout         = $ffc9
   104                          _clrch          = $ffcc
   105                          _basin          = $ffcf
   106                          _bsout          = $ffd2
   107                          _loadsp         = $ffd5
   108                          _savesp         = $ffd8
   109                          _SetTime        = $ffdb
   110                          _ReadTime       = $ffde
   111                          _stop           = $ffe1
   112                          _getin          = $ffe4
   113                          _clall          = $ffe7
   114                          _screen_org     = $ffed
   115                          _plot           = $fff0
   116                          
   117                          ;.end
   118                          
   119                          
   120                          
   121                          
   122                          ; ********************************************************************************************
   123                          ;
   124                          ;	Date		Changes
   125                          ;	====		=======
   126                          ;
   127                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: initialise/initialise.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      initialise.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; ***************************************************************************************************************
    13                          ; ***************************************************************************************************************
    14                          ;
    15                          ;      Name:       patch.asm
    16                          ;      Purpose:    Fixes
    17                          ;      Created:    4th January 2020
    18                          ;      Author:     Paul Robson (paul@robsons.org.uk)
    19                          ;
    20                          ; ***************************************************************************************************************
    21                          ; ***************************************************************************************************************
    22                          
    23                          ; ***************************************************************************************************************
    24                          ;
    25                          ;				At present ACME does not support BRA opcode $83. BRL replaces this.
    26                          ;
    27                          ; ***************************************************************************************************************
    28                          
    29                          !macro lbra addr {
    30                          	!byte $83
    31                          	!word (addr-*-1) & $FFFF
    32                          }
    33                          
    34                          !macro lbcc addr {
    35                          	!byte $93
    36                          	!word (addr-*-1) & $FFFF
    37                          }
    38                          
    39                          !macro lbcs addr {
    40                          	!byte $B3
    41                          	!word (addr-*-1) & $FFFF
    42                          }
    43                          
    44                          !macro lbne addr {
    45                          	!byte $D3
    46                          	!word (addr-*-1) & $FFFF
    47                          }
    48                          
    49                          !macro lbeq addr {
    50                          	!byte $F3
    51                          	!word (addr-*-1) & $FFFF
    52                          }
    53                          
    54                          !macro lbpl addr {
    55                          	!byte $13
    56                          	!word (addr-*-1) & $FFFF
    57                          }
    58                          
    59                          !macro lbmi addr {
    60                          	!byte $33
    61                          	!word (addr-*-1) & $FFFF
    62                          }
    63                          
    64                          !macro lbvs addr {
    65                          	!byte $73
    66                          	!word (addr-*-1) & $FFFF
    67                          }
    68                          
    69                          !macro lbvc addr {
    70                          	!byte $53
    71                          	!word (addr-*-1) & $FFFF
    72                          }
    73                                          * = $2000
    74                          
    75                          basic
    76  2000 4c2520                             jmp     hard_reset
    77  2003 4c0c20                             jmp     soft_reset
    78  2006 4c7579                             jmp     basic_irq
    79  2009 4c06bf                             jmp     basic_nmi                       ; (removed)    [910523] audio
    80                          
    81                          soft_reset                                              ; warm start BASIC...
    82  200c 20b438                             jsr     release_channels                ; restore default terminal I/O channels
    83  200f a900                               lda     #doslfn                         ; restore reserved disk channel
    84  2011 38                                 sec                                     ; not a real close
    85  2012 20c3ff                             jsr     _close
    86  2015 208278                             jsr     Clear_DS                        ; zap DS$ just in case
    87                          ; (might have been in Monitor or building DS$)
    88  2018 200d21                             jsr     init_sound_sprites              ; init interrupt & dma stuff   [910523]
    89  201b 200935                             jsr     init_stack                      ; restore stack
    90  201e a901                               lda     #1
    91  2020 0c0411                             tsb     _init_status                    ; tell Kernel to give BASIC a call at IRQ time
    92  2023 802e                               bra     go_ready                        ; enable IRQ, print READY, and go MAIN
    93                          
    94                          
    95                          hard_reset
    96  2025 205f22                             jsr     init_vectors                    ; init vectors
    97  2028 205720                             jsr     init_storage                    ; init variables, voices,  & download RAM code
    98  202b 203321                             jsr     signon_message                  ; print initialization message
    99                          
   100  202e a900                               lda     #0                              ; init bank pointers   [900509]
   101  2030 8584                               sta     text_bank
   102  2032 8555                               sta     helper                          ; reset all LIST flags
   103  2034 a901                               lda     #1
   104  2036 8585                               sta     var_bank
   105  2038 a902                               lda     #2
   106  203a 8dd802                             sta     highlight_color                 ; set highlight color (2=red)
   107  203d a203                               ldx     #<basic+3
   108  203f 8e0011                             stx     _restart_vector                 ; point system restart vector at warm start entry
   109  2042 200935                             jsr     init_stack                      ; initialize system stack pointer
   110  2045 a901                               lda     #1
   111  2047 0c0411                             tsb     _init_status                    ; tell Kernel to give BASIC a call at IRQ time
   112  204a 220080                             jsr     ($8000)                         ; initialize graphics
   113  204d 205cff                             jsr     _phoenix                        ; call cartridges, check out expansion card
   114  2050 20a467                             jsr     autobootCSG                     ; attempt to boot program from disk
   115                          
   116                          go_ready
   117  2053 58                                 cli                                     ; enable IRQ
   118  2054 83f70d                             +lbra   ready
   119                          
   120                          
   121                          init_storage
   122  2057 a94c                               lda     #76                             ; 'jmp' opcode
   123  2059 8556                               sta     jmper
   124  205b 8df702                             sta     usrpok
   125                          
   126  205e a9e8                               lda     #<errguf                        ; init USR vector to 'undef'd function'  [910226] FAB
   127  2060 a058                               ldy     #>errguf
   128  2062 8df802                             sta     usrpok+1
   129  2065 8cf902                             sty     usrpok+2
   130                          
   131  2068 a99f                               lda     #<flpint                        ; ???? why keep
   132  206a a058                               ldy     #>flpint
   133  206c 8dc002                             sta     adray1
   134  206f 8cc102                             sty     adray1+1
   135                          
   136  2072 a93f                               lda     #<givayf                        ; ???? why keep
   137  2074 a04e                               ldy     #>givayf
   138  2076 8dc202                             sta     adray2
   139  2079 8cc302                             sty     adray2+1
   140                          
   141                          ; Download CHRGET (and INDSUB code????) to RAM
   142                          ;
   143                          ; ldx #endmov-chrget_pattern
   144                          ;1$ lda chrget_pattern-1,x
   145                          ; sta chrget-1,x
   146                          ; dex
   147                          ; bne 1$
   148                          
   149  207c a200                               ldx     #0
   150  207e 8ec402                             stx     zero                            ; zero constant
   151  2081 8ec502                             stx     zero+1
   152  2084 8ec602                             stx     zero+2
   153  2087 8ed702                             stx     bits                            ; reset bit/byte shifter
   154  208a 8615                               stx     channl                          ; default channels
   155  208c 867e                               stx     runmod                          ; direct mode
   156  208e 861a                               stx     lastpt+1
   157  2090 8674                               stx     autinc                          ; turn off auto increment
   158  2092 8675                               stx     autinc+1
   159  2094 8e7411                             stx     rndx                            ; zero-ing MSB will guarantee a legal value
   160                          ; stx dosfa  ;zero device number     [910429]
   161                          
   162  2097 8edc02                             stx     intval                          ; reset all BASIC IRQ stuff
   163  209a 8edd02                             stx     int_trip_flag                   ; (BASIC IRQ enabled in init_voices)
   164  209d 8ede02                             stx     int_trip_flag+1
   165  20a0 8edf02                             stx     int_trip_flag+2
   166  20a3 8ee802                             stx     lightpen_xpos
   167  20a6 8ee902                             stx     lightpen_ypos
   168                          
   169                          ; stx mvdflg  ;flag '8k graphics screen not allocated'
   170                          ; stx width  ;init to single-width lines
   171                          ; stx scalem  ;turn off scaleing
   172                          ; stx filflg
   173                          
   174                          ; inx   ;.x=1 ???? why init stack with $0101 ????
   175                          ; stx buf-3
   176                          ; stx buf-4
   177                          
   178                          ; ldy #88   ;zero out sprite information area
   179                          ;2$ sta sprite_data,y ;???? this is done later at init_as_0
   180                          ; dey
   181                          ; bpl 2$
   182                          
   183                          ; ldx #13
   184                          ; stx foreground  ;init bit map's fg color to light green
   185                          ; ldx #1
   186                          ; stx multicolor_1 ;init mc1 to white
   187                          ; ldx #2
   188                          ; stx multicolor_2 ;init mc2 to red
   189                          ; jsr set_packed_color ;set up packed fg/bg and fg/mc1 bytes
   190                          
   191  20a9 ae0611                             ldx     _default_drive
   192  20ac 8e8211                             stx     dosfa                           ; init device number to system default   [910429]
   193                          
   194  20af a280                               ldx     #$80                            ; bank 0 with I/O????
   195  20b1 8ed102                             stx     current_bank                    ; set default bank for PEEK,POKE,BOOT,SYS,WAIT,BLOAD/SAVE
   196                          
   197  20b4 a21b                               ldx     #tempst
   198  20b6 8618                               stx     temppt                          ; init temp descriptor pointer
   199                          
   200  20b8 a201                               ldx     #<baswrk                        ; set up bottom of bank 0 (text area)
   201  20ba a020                               ldy     #>baswrk
   202  20bc 862d                               stx     txttab
   203  20be 842e                               sty     txttab+1
   204                          
   205  20c0 a900                               lda     #<varbgn                        ; set up bottom of bank 1 (storage area)
   206  20c2 a020                               ldy     #>varbgn
   207  20c4 852f                               sta     vartab
   208  20c6 8430                               sty     vartab+1
   209                          
   210  20c8 a900                               lda     #<bank_0_top                    ; set up top of bank 0
   211  20ca a080                               ldy     #>bank_0_top
   212  20cc 8dcf02                             sta     max_mem_0
   213  20cf 8cd002                             sty     max_mem_0+1
   214                          
   215  20d2 a900                               lda     #<bank_1_top                    ; set up  top of bank 1
   216  20d4 a080                               ldy     #>bank_1_top
   217  20d6 8539                               sta     max_mem_1
   218  20d8 843a                               sty     max_mem_1+1
   219                          
   220  20da a900                               lda     #0                              ; init text input buffer  (these are for autoboot)
   221  20dc 8d0002                             sta     buf
   222  20df 3a                                 dec
   223  20e0 853c                               sta     curlin+1                        ; init line pointer
   224  20e2 a2ff                               ldx     #<buf_txtptr                    ; init txtptr
   225  20e4 a001                               ldy     #>buf_txtptr
   226  20e6 863d                               stx     txtptr
   227  20e8 843e                               sty     txtptr+1
   228                          
   229                          ; Set up sprite pointers
   230                          
   231  20ea a91f                               lda     #sprite_base/64+7
   232  20ec a007                               ldy     #7
   233  20ee 7fd705             l1_1            bbr7    _mode,l1_2
   234  20f1 99f80b                             sta     sprite_ptrs_40,y                ; 40 col screen
   235  20f4 8003                               bra     l1_3
   236  20f6 99f80f             l1_2            sta     sprite_ptrs_80,y                ; 80 col screen
   237  20f9 3a                 l1_3            dec
   238  20fa 88                                 dey
   239  20fb 10f1                               bpl     l1_1
   240                          
   241                          ; Zero out sprite movement stuff and some VIC stuff too
   242                          
   243  20fd a900                               lda     #0
   244  20ff a257                               ldx     #init_as_0
   245  2101 9d0512             l1_4            sta     sprite_data,x
   246  2104 ca                                 dex
   247  2105 10fa                               bpl     l1_4
   248                          
   249  2107 200d21                             jsr     init_sound_sprites              ; init misc. interrupt & dma stuff
   250                          
   251                          ; lda #$d0  ;initialize pointers to character ROM
   252                          ; sta upper_graphic
   253                          ; lda #$d8
   254                          ; sta upper_lower
   255                          
   256  210a 836c13                             +lbra   init_text                       ; go to 'new'
   257                          
   258                          
   259                          init_sound_sprites                                        ; [910523]
   260                          ;; init_voices   ;Initialize music stuff
   261                          ; bit _pal_ntsc  ;determine if PAL or NTSC system  [910724]
   262                          ; bmi 1$   ;...branch if PAL
   263                          ; lda #<beats_ntsc/4 ;set beat to quarter note (4/4 time = .5 sec)
   264                          ; ldy #>beats_ntsc/4
   265                          ; bra 2$
   266                          ;1$ lda #<beats_pal/4
   267                          ; ldy #>beats_pal/4
   268                          ;2$ sta ntime
   269                          ; sty ntime+1
   270                          ;
   271                          ; lda #4   ;set default octave
   272                          ; sta octave
   273                          ;
   274                          ; lda #12   ;set default tempo    [910220]
   275                          ; sta tempo_rate  ; 12 makes whole note in 4/4 time last 2 seconds
   276                          ;----
   277                          ;; jsr go_slow  ;      [910716] 4567R7A
   278                          ; lda #0   ;make sure all gates are off
   279                          ; sta sid1+4
   280                          ; sta sid1+11
   281                          ; sta sid1+18
   282                          ; sta sid2+4
   283                          ; sta sid2+11
   284                          ; sta sid2+18
   285                          ; sta filters1+2  ;set filters off, volume to max????  [910612]
   286                          ; sta filters2+2
   287                          ;
   288                          ; lda #8
   289                          ; sta sid1+24
   290                          ; sta sid2+24
   291                          ; sta filters1+3
   292                          ; sta filters2+3  ;      [910612]
   293                          ;; sta filters+4  ;why?      [910612]
   294                          ;; jsr go_fast  ;      [910716] 4567R7A
   295                          ;----
   296                          ; ldy #29   ;initialize music tables
   297                          ;10$ lda atkmus,y
   298                          ; sta atktab,y
   299                          ; dey
   300                          ; bpl 10$
   301                          ;
   302                          ; ldx #9   ;initialize pulse widths
   303                          ;20$ lda pwhmus,x
   304                          ; sta pulshi,x
   305                          ; dex
   306                          ; bpl 20$
   307                          ;
   308                          ; stx sound_time_hi ;turn all SOUND counters off (.X = $ff)
   309                          ; stx sound_time_hi+1
   310                          ; stx sound_time_hi+2
   311                          ; stx sound_time_hi+3 ;stereo SIDs     [910612]
   312                          ; stx sound_time_hi+4
   313                          ; stx sound_time_hi+5
   314                          ; stx voices+1  ;turn all PLAY counters off
   315                          ; stx voices+3
   316                          ; stx voices+5
   317                          ; stx voices+7  ;stereo SIDs     [910612]
   318                          ; stx voices+9
   319                          ; stx voices+11
   320                          ;
   321                          ; ldy #6-1  ;set default envelope (piano) for all voices (6)
   322                          ; sty voice
   323                          ;30$ ldx #0
   324                          ; jsr set_envelope_1
   325                          ; dec voice
   326                          ; bpl 30$
   327                          ; inc voice  ;set default voice (0)
   328                          ;-----
   329  210d 2058be                             jsr     Sound_CLR_1                     ; [910724]
   330                          
   331  2110 a9e7                               lda     #%11100111                      ; [910626]
   332  2112 1455                               trb     helper                          ; reset LIST/HELP/FIND flags
   333  2114 0cd902                             tsb     highlight_save                  ; mark saved color as invalid
   334                          
   335  2117 a900                               lda     #0                              ; [910523] F018A
   336  2119 a217                               ldx     #12+12-1                        ; init DMA lists
   337  211b 9d4401             l2_1            sta     dma1_cmd,x
   338  211e ca                                 dex
   339  211f 10fa                               bpl     l2_1
   340                          
   341                          ; stop_sprites   ;Stop all moving sprites (a=0)   [910523]
   342  2121 a007                               ldy     #7                              ; for sprites 0...7
   343  2123 befeb7             l2_2            ldx     sproff,y                        ; get table offset
   344  2126 9d0512                             sta     sprite_data,x                   ; reset speed for this sprite
   345  2129 88                                 dey
   346  212a 10f7                               bpl     l2_2                            ; loop until done
   347                          
   348  212c 8d15d0                             sta     vic+21                          ; Turn off all sprites    [910717]
   349                          
   350  212f 8ddb02                             sta     irq_wrap_flag                   ; enable BASIC IRQ handler
   351                          ; sta nmi_wrap_flag ;enable BASIC NMI handler   [910523]
   352  2132 60                                 rts                                     ; (removed)    [910826]
   353                          
   354                          
   355                          signon_message
   356  2133 207dff             l3_1            jsr     _primm
   357  2136 93121c2020202020...                !text 147,18,028,"                     ",146,169
   358  2150 0509202020202020...                !text 5,9,"       THE COMMODORE C65 DEVELOPMENT SYSTEM",cr
   359  217e 1296202020202020...                !text 18,150,"                  ",146,169,cr
   360  2195 129e202020202020...                !text 18,158,"               ",146,169
   361  21a8 0509202020434f50...                !text 5,9,"   COPYRIGHT  1991  COMMODORE ELECTRONICS, LTD.",cr
   362  21da 121e202020202020...                !text 18,030,"            ",146,169
   363  21ea 0509090920202020...                !text 5,9,9,9,"    COPYRIGHT  1977  MICROSOFT",cr
   364  220d 129a202020202020...                !text 18,154,"          ",146,169,cr
   365  221c 129c202020202020...                !text 18,156,"        ",146,169
   366  2228 0509092042415349...                !text 5,9,9," BASIC 10.0   V0.9B.911119    ALL RIGHTS RESERVED",cr,0
   367                          
   368  225e 60                                 rts
   369                          
   370                          
   371                          init_vectors
   372  225f a217                               ldx     #l4_3-l4_2-1
   373  2261 bd6b22             l4_1            lda     l4_2,x
   374  2264 9dfa02                             sta     vectors_begin,x
   375  2267 ca                                 dex
   376  2268 10f7                               bpl     l4_1
   377                          
   378  226a 60                                 rts
   379                          
   380                          
   381  226b c37d               l4_2            !word AutoScroll                        ; autoscroll vector
   382  226d 8f2d                               !word n_esc_fn_vec                      ; escape function vector
   383  226f cd7f                               !word graphic_kernel                    ; graphic extension vector
   384  2271 522e0a2f2223be33...                !word nerror,nmain,ncrnch,nqplop,ngone,neval; traditional vectors
   385  227d 32234e34c02c                       !word nesclk,nescpr,nescex              ; escape command vectors
   386                          l4_3
   387                          
   388                          
   389                          ;; CHRGET/CHRGOT code.  It is downloaded to RAM.
   390                          ;;
   391                          ;chrget_pattern
   392                          ; inw txtptr ;CHRGET entry
   393                          ; phz  ;CHRGOT entry (chrget+2)
   394                          ; phx
   395                          ; lda #0
   396                          ; ldx #$f0
   397                          ; ldy #0
   398                          ; ldz #$f0
   399                          ; map
   400                          ; ldy #0
   401                          ; lda (txtptr),y
   402                          ; phy
   403                          ; pha
   404                          ; jsr _restore_sys
   405                          ; nop  ;unmap
   406                          ; pla
   407                          ; ply
   408                          ; plx
   409                          ; plz
   410                          ;
   411                          ; cmp #':' ;QNUM entry (chrget+27)
   412                          ; bcs l4_2
   413                          ; cmp #' '
   414                          ; beq chrget_pattern
   415                          ; sec
   416                          ; sbc #'0'
   417                          ; sec
   418                          ; sbc #$d0
   419                          ;l4_2 rts  ;(42 bytes to here)
   420                          ;
   421                          ;
   422                          ;
   423                          ;; Constants which must be moved to RAM
   424                          ;
   425                          ; .byte   0,0,0 ;zero, of course!
   426                          ;
   427                          ;endmov   ;(45 bytes to here)
   428                          
   429                          
   430                          ; CHRGET/CHRGOT code.
   431                          ;
   432                          
   433  2283 e33d               chrget          inw     txtptr                          ; get next character from text
   434  2285 a000               chrgot          ldy     #0                              ; re-get current character from text
   435  2287 20c522                             jsr     indtxt                          ; lda (txtptr),y from RAM0
   436  228a c920               qnum            cmp     #' '
   437  228c f0f5                               beq     chrget                          ; skip spaces
   438  228e c93a               chrtst          cmp     #':'                            ; [910513]
   439  2290 b006                               bcs     l5_1                            ; eol
   440  2292 38                                 sec
   441  2293 e930                               sbc     #'0'                            ; alpha or numeric?
   442  2295 38                                 sec
   443  2296 e9d0                               sbc     #$d0
   444  2298 60                 l5_1            rts
   445                          
   446                          
   447                          ;.end
   448                          
   449                          ; ********************************************************************************************
   450                          ;
   451                          ;	Date		Changes
   452                          ;	====		=======
   453                          ;
   454                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/indirection.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      indirection.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; C65 BASIC Indirect Load Subroutines
    14                          
    15                          
    16                          inddef
    17  2299 a950                               lda     #defpnt
    18  229b 803a                               bra     lda_far_ram1
    19                          
    20                          indfrm
    21  229d a93f                               lda     #form
    22  229f 8036                               bra     lda_far_ram1
    23                          
    24                          inddpt
    25  22a1 a952                               lda     #dscpnt
    26  22a3 8032                               bra     lda_far_ram1
    27                          
    28                          ;indhtr
    29                          ; lda #hightr
    30                          ; bra lda_far_ram0
    31                          
    32                          indhtr_ram1
    33  22a5 a95c                               lda     #hightr
    34  22a7 802e                               bra     lda_far_ram1
    35                          
    36                          indfmo
    37  22a9 a966                               lda     #facmo
    38  22ab 802a                               bra     lda_far_ram1
    39                          
    40                          indlow
    41  22ad a961                               lda     #lowtr
    42  22af 8016                               bra     lda_far_ram0
    43                          
    44                          indst1
    45  22b1 a970                               lda     #strng1
    46  22b3 8012                               bra     lda_far_ram0
    47                          
    48                          indst1_ram1
    49  22b5 a970                               lda     #strng1
    50  22b7 801e                               bra     lda_far_ram1
    51                          
    52                          indgrb
    53  22b9 a950                               lda     #grbpnt
    54  22bb 801a                               bra     lda_far_ram1
    55                          
    56                          indlow_ram1
    57  22bd a961                               lda     #lowtr
    58  22bf 8016                               bra     lda_far_ram1
    59                          
    60                          indin1
    61  22c1 a924                               lda     #index1
    62  22c3 8002                               bra     lda_far_ram0
    63                          
    64                          ;indin2
    65                          ; lda #index2
    66                          ; bra lda_far_ram0
    67                          
    68                          indtxt
    69  22c5 a93d                               lda     #txtptr
    70                          ; bra lda_far_ram0
    71                          
    72                          
    73                          ; C65 BASIC Indirect Load Subroutines
    74                          
    75                          lda_far_ram0
    76  22c7 db                                 phz                                     ; save registers
    77  22c8 da                                 phx
    78  22c9 aa                                 tax                                     ; pointer
    79  22ca ab8400                             ldz     text_bank                       ; RAM0
    80  22cd 2074ff                             jsr     _lda_far                        ; LDA (.x),Y from bank .z
    81  22d0 fa                                 plx
    82  22d1 fb                                 plz
    83  22d2 29ff                               and     #$ff                            ; set processor status per byte fetched
    84  22d4 60                                 rts
    85                          
    86                          
    87                          
    88                          indin1_ram1
    89  22d5 a924                               lda     #index1
    90                          ; bra lda_far_ram1
    91                          
    92                          lda_far_ram1
    93  22d7 08                                 php                                     ; save .c
    94  22d8 db                                 phz                                     ; save registers
    95  22d9 da                                 phx
    96  22da aa                                 tax                                     ; pointer
    97  22db ab8500                             ldz     var_bank                        ; RAM1
    98  22de b501                               lda     1,x                             ; check to see if pointer points to "common"
    99  22e0 c920                               cmp     #$20
   100  22e2 b003                               bcs     l6_1                            ; branch if not
   101  22e4 ab8400                             ldz     text_bank                       ; else select RAM0
   102                          
   103  22e7 2074ff             l6_1            jsr     _lda_far                        ; LDA (.x),Y from bank .z
   104  22ea fa                                 plx
   105  22eb fb                                 plz
   106  22ec 28                                 plp                                     ; restore .c
   107  22ed 29ff                               and     #$ff                            ; set processor status per byte fetched
   108  22ef 60                                 rts
   109                          
   110                          
   111                          ; C65 BASIC Indirect Save Subroutines
   112                          
   113                          sta_far_ram1
   114  22f0 08                                 php                                     ; save registers
   115  22f1 db                                 phz
   116  22f2 48                                 pha
   117  22f3 ab8500                             ldz     var_bank                        ; RAM1
   118  22f6 b501                               lda     1,x                             ; check to see if pointer points to "common"
   119  22f8 c920                               cmp     #$20
   120  22fa b003                               bcs     l7_1                            ; branch if not
   121  22fc ab8400                             ldz     text_bank                       ; else select RAM0
   122                          
   123  22ff 68                 l7_1            pla
   124  2300 2077ff                             jsr     _sta_far                        ; STA (.x),Y to bank .z
   125  2303 fb                                 plz
   126  2304 28                                 plp
   127  2305 60                                 rts
   128                          
   129                          
   130                          sta_far_in1                                             ; [910624]
   131  2306 a224                               ldx     #index1
   132  2308 8002                               bra     sta_far_ram0
   133                          
   134                          sta_far_txt
   135  230a a23d                               ldx     #txtptr
   136                          
   137                          sta_far_ram0
   138  230c 08                                 php                                     ; save registers
   139  230d db                                 phz
   140  230e ab8400                             ldz     text_bank                       ; RAM0
   141  2311 2077ff                             jsr     _sta_far                        ; STA (.x),Y to bank .z
   142  2314 fb                                 plz
   143  2315 28                                 plp
   144  2316 60                                 rts
   145                          
   146                          
   147                          indcmp_in1                                              ; [910620]
   148  2317 a224                               ldx     #index1
   149  2319 ab8400                             ldz     text_bank                       ; RAM0
   150  231c 4c7aff                             jmp     _cmp_far                        ; STA (.x),Y to bank .z
   151                          
   152                          ;.end
   153                          
   154                          
   155                          
   156                          
   157                          ; ********************************************************************************************
   158                          ;
   159                          ;	Date		Changes
   160                          ;	====		=======
   161                          ;
   162                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/tokeniser.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      tokeniser.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ;        CRUNCH
    13                          ;
    14                          ;  Entry:  TXTPTR points to start of text to crunch
    15                          ;  Exit:   TXTPTR points to start of crunched text
    16                          ;
    17                          ;  Calls:  CHRGET
    18                          ;          CHRGOT
    19                          ;          RESER
    20                          ;          KLOOP
    21                          ;          REM
    22                          ;          DATA
    23                          ;
    24                          ;  CRUNCH collapses all reserved words into tokens.  It removes all graphic
    25                          ;  characters (characters with msb set) not in quoted strings, DATA or REM
    26                          ;  statements.
    27                          ;
    28                          ;  An escape token is implemented as follows:
    29                          ;
    30                          ; As each character on a line of text to be crunched is scanned, an
    31                          ; indirect jump is performed.  Anyone wishing to scan for their own
    32                          ; commands should grab off this vector, saving the return vector.
    33                          ; On entry, if the carry flag is set, it is still up for grabs.
    34                          ; The current text pointer is at TXTPTR.  If the escape routine
    35                          ; recognizes the command, it should:
    36                          ;
    37                          ;  ) put the length of the reserved word in .y
    38                          ;  ) put the desired 'second' token in .a
    39                          ;  ) clear the carry flag
    40                          ;  ) put type of token in x: 0==>command, ff==>function
    41                          ;
    42                          ; If it is not your command, leave .a and the carry flag intact.
    43                          ; NOTE:  The reserved word must be >= 2 characters long.  Exit through
    44                          ; the old vector (for daisy chaining).  If the carry flag is clear on
    45                          ; entry it means someone else before you recognized this command.  In
    46                          ; this case, just pass control through the old vector.
    47                          
    48                          
    49  231f 6c0403             crunch          jmp     (icrnch)
    50                          
    51                          
    52  2322 fc3d00             ncrnch          phw     txtptr                          ; save old text pointer
    53                          
    54  2325 208522             crun05          jsr     chrgot
    55  2328 8003                               bra     crun20
    56                          
    57  232a 208322             crun10          jsr     chrget
    58                          
    59                          
    60  232d 90fb               crun20          bcc     crun10                          ; don't crunch numbers
    61  232f 6c0c03                             jmp     (iesclk)                        ; give others a chance at this.  (carry is set)
    62                          
    63                          nesclk
    64  2332 938e00                             +lbcc   l8_12                           ; carry clear if someone wanted it
    65  2335 c900                               cmp     #0                              ; end of line?
    66  2337 f078                               beq     l8_10                           ; yes
    67  2339 c93a                               cmp     #':'                            ; multi-stmt char?
    68  233b f0ed                               beq     crun10                          ; yes
    69  233d c93f                               cmp     #'?'                            ; print ('?') abreviation?
    70  233f d004                               bne     l8_1                            ; no
    71  2341 a999                               lda     #print_token                    ; yes- substitute print token
    72  2343 8050                               bra     l8_8
    73                          
    74  2345 c980               l8_1            cmp     #$80                            ; graphics?
    75  2347 900b                               bcc     l8_2                            ; no
    76  2349 c9ff                               cmp     #pi                             ; pi? (special case)
    77  234b f0dd                               beq     crun10                          ; yes, leave alone
    78  234d a001                               ldy     #1
    79  234f 20de23                             jsr     kloop                           ; crunch out graphics
    80  2352 80d1                               bra     crun05
    81                          
    82                          
    83  2354 c922               l8_2            cmp     #'"'                            ; quote string?
    84  2356 d00d                               bne     l8_4                            ; no- try escape token
    85                          
    86  2358 208322             l8_3            jsr     chrget
    87  235b c900                               cmp     #0                              ; end of line?
    88  235d f052                               beq     l8_10                           ; yes
    89  235f c922                               cmp     #'"'                            ; close quote?
    90  2361 f0c7                               beq     crun10                          ; yes
    91  2363 80f3                               bra     l8_3                            ; no, continue skipping characters
    92                          
    93                          
    94                          ; Crunch escape token
    95                          
    96  2365 a926               l8_4            lda     #>esc_command_list              ; look for token in escape-command list
    97  2367 a029                               ldy     #<esc_command_list
    98  2369 20f423                             jsr     reser
    99  236c 9006                               bcc     l8_5                            ; not found
   100  236e a981                               lda     #first_esc_command_token+$80-1  ; set up for common escape routine
   101  2370 a200                               ldx     #0                              ; ..flag 'cmd' type escape
   102  2372 804c                               bra     l8_11                           ; ..and go to it.
   103                          
   104  2374 a927               l8_5            lda     #>esc_function_list             ; look for token in escape-function list
   105  2376 a09a                               ldy     #<esc_function_list
   106  2378 20f423                             jsr     reser
   107  237b 9006                               bcc     l8_6                            ; not found
   108  237d a981                               lda     #first_esc_function_token+$80-1 ; set up for common escape routine
   109  237f a2ff                               ldx     #$ff                            ; ..flag 'function' type escape
   110  2381 803d                               bra     l8_11                           ; ..and go to it
   111                          
   112  2383 a924               l8_6            lda     #>keyword_list                  ; look for token in normal list
   113  2385 a03a                               ldy     #<keyword_list
   114  2387 20f423                             jsr     reser
   115  238a 909e                               bcc     crun10                          ; not found
   116  238c c000                               cpy     #0                              ; anything to move?
   117  238e f003                               beq     l8_7                            ; no
   118  2390 20de23                             jsr     kloop                           ; crunch it out
   119  2393 a50d               l8_7            lda     count
   120                          
   121  2395 a000               l8_8            ldy     #0
   122  2397 200a23                             jsr     sta_far_txt                     ; put token into text  (bleed-thru)
   123  239a c98f                               cmp     #rem_token
   124  239c f00d                               beq     l8_9
   125  239e c983                               cmp     #data_token
   126  23a0 d088                               bne     crun10
   127  23a2 208322                             jsr     chrget
   128  23a5 204835                             jsr     data
   129  23a8 837bff                             +lbra   crun05
   130                          
   131  23ab 208322             l8_9            jsr     chrget
   132  23ae 205635                             jsr     rem
   133                          
   134                          
   135                          ;  No other statements can follow a REM
   136                          
   137  23b1 a63d               l8_10           ldx     txtptr
   138  23b3 68                                 pla
   139  23b4 853e                               sta     txtptr+1
   140  23b6 68                                 pla
   141  23b7 853d                               sta     txtptr
   142  23b9 38                                 sec                                     ; compute length of line
   143  23ba 8a                                 txa
   144  23bb e53d                               sbc     txtptr
   145  23bd a8                                 tay
   146  23be c8                                 iny
   147  23bf 60                                 rts
   148                          
   149                          
   150                          ; Crunch out old text, install an escape token
   151                          
   152  23c0 650d               l8_11           adc     count                           ; make pointer into a token
   153  23c2 48                 l8_12           pha                                     ; save second token
   154  23c3 88                                 dey                                     ; waste (# of chars) - 1
   155  23c4 20de23                             jsr     kloop
   156                          
   157                          ; See if this is function (x=ff) or command (x=0)
   158                          
   159  23c7 a9fe                               lda     #esc_command_token              ; assume command
   160  23c9 e8                                 inx
   161  23ca d002                               bne     l8_13                           ; branch if command
   162  23cc a9ce                               lda     #esc_function_token             ; ..else get correct token
   163                          
   164  23ce a000               l8_13           ldy     #0
   165  23d0 200a23                             jsr     sta_far_txt                     ; install escape token... (bleed-thru)
   166  23d3 c8                                 iny
   167  23d4 68                                 pla
   168  23d5 200a23                             jsr     sta_far_txt                     ; ..and second token  (bleed-thru)
   169  23d8 208322                             jsr     chrget                          ; skip over token,
   170  23db 834dff                             +lbra   crun10                          ; ..and continue with line.
   171                          
   172                          
   173                          ;      KLOOP
   174                          ;
   175                          ;  Crunch loop.  Moves offset .y characters from txtptr to end of line.
   176                          ;  .x is preserved
   177                          
   178  23de 18                 kloop           clc                                     ; compute source address
   179  23df 98                                 tya
   180  23e0 653d                               adc     txtptr
   181  23e2 8524                               sta     index1
   182  23e4 a53e                               lda     txtptr+1
   183  23e6 6900                               adc     #0
   184  23e8 8525                               sta     index1+1
   185  23ea a0ff                               ldy     #$ff
   186                          
   187  23ec c8                 l9_1            iny
   188  23ed b124                               lda     (index1),y                      ; move source..  ????assumes text in common area
   189  23ef 913d                               sta     (txtptr),y                      ; to destination offset ????assumes text in common area
   190  23f1 d0f9                               bne     l9_1                            ; not end of line
   191  23f3 60                                 rts
   192                          
   193                          
   194                          ;      RESER
   195                          ;
   196                          ;  Search reserved word list for a match
   197                          ;
   198                          ;  Entry:  (txtptr) is first char of word to match
   199                          ;    (y,a) is start of table to check
   200                          ;
   201                          ;  Exit:   .y  length of word matched
   202                          ;    .c  success/fail (set/clear) flag
   203                          ;    count token value
   204                          
   205  23f4 8525               reser           sta     index1+1
   206  23f6 8424                               sty     index1
   207  23f8 a000                               ldy     #0
   208  23fa 840d                               sty     count
   209  23fc 88                                 dey
   210  23fd c8                 l10_1           iny
   211  23fe b13d               l10_2           lda     (txtptr),y                      ; assumes common memory
   212  2400 3029                               bmi     l10_7                           ; abrieviation    [900510]
   213  2402 38                                 sec
   214  2403 f124                               sbc     (index1),y                      ; does letter match? (ind.ok)
   215  2405 f0f6                               beq     l10_1                           ; yes...continue
   216  2407 c980                               cmp     #$80                            ; end of word?
   217  2409 f01b                               beq     l10_6                           ; yes...c set...done
   218                          
   219                          
   220                          ;  find next word
   221                          
   222  240b b124               l10_3           lda     (index1),y                      ; ind.ok
   223  240d 3003                               bmi     l10_4                           ; found end of current
   224  240f c8                                 iny
   225  2410 d0f9                               bne     l10_3
   226  2412 c8                 l10_4           iny                                     ; start of next
   227  2413 e60d                               inc     count                           ; value of token
   228  2415 18                                 clc
   229  2416 98                                 tya
   230  2417 6524                               adc     index1
   231  2419 8524                               sta     index1
   232  241b 9002                               bcc     l10_5
   233  241d e625                               inc     index1+1
   234  241f 18                 l10_5           clc
   235  2420 a000                               ldy     #0
   236  2422 b124                               lda     (index1),y                      ; end of list? ind.ok
   237  2424 d0d8                               bne     l10_2                           ; no
   238                          
   239                          
   240                          ;  yes...carry clear...fail
   241                          
   242  2426 050d               l10_6           ora     count                           ; .a=$80 if match
   243  2428 850d                               sta     count                           ; token is formed
   244  242a 60                                 rts
   245                          
   246                          
   247                          ; special case- last character is shifted (necessary for 'diR' compatibility)
   248                          
   249  242b 38                 l10_7           sec                                     ; allow last chr to be shifted   [900510]
   250  242c f124                               sbc     (index1),y                      ; does letter match? (ind.ok)
   251  242e f006                               beq     l10_8                           ; yes- end of word
   252  2430 c980                               cmp     #$80                            ; end of word?
   253  2432 f0f2                               beq     l10_6                           ; yes
   254  2434 d0d5                               bne     l10_3                           ; no- next word
   255                          
   256  2436 a980               l10_8           lda     #$80                            ; last chr is shifted & so is end of current word
   257  2438 80ec                               bra     l10_6
   258                          
   259                          ;.end
   260                          
   261                          
   262                          
   263                          
   264                          ; ********************************************************************************************
   265                          ;
   266                          ;	Date		Changes
   267                          ;	====		=======
   268                          ;
   269                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: tokeniser/keywords.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      keywords.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          keyword_list
    14  243a 454ec4                             !text "EN",'D'+$80                      ; $80
    15  243d 464fd2                             !text "FO",'R'+$80                      ; $81
    16  2440 4e4558d4                           !text "NEX",'T'+$80                     ; $82
    17  2444 444154c1                           !text "DAT",'A'+$80                     ; $83
    18  2448 494e505554a3                       !text "INPUT",'#'+$80                   ; $84
    19  244e 494e5055d4                         !text "INPU",'T'+$80                    ; $85
    20  2453 4449cd                             !text "DI",'M'+$80                      ; $86
    21  2456 524541c4                           !text "REA",'D'+$80                     ; $87
    22  245a 4c45d4                             !text "LE",'T'+$80                      ; $88
    23  245d 474f54cf                           !text "GOT",'O'+$80                     ; $89
    24  2461 5255ce                             !text "RU",'N'+$80                      ; $8A
    25  2464 49c6                               !text "I",'F'+$80                       ; $8B
    26  2466 524553544f52c5                     !text "RESTOR",'E'+$80                  ; $8C
    27  246d 474f5355c2                         !text "GOSU",'B'+$80                    ; $8D
    28  2472 5245545552ce                       !text "RETUR",'N'+$80                   ; $8E
    29  2478 5245cd                             !text "RE",'M'+$80                      ; $8F
    30  247b 53544fd0                           !text "STO",'P'+$80                     ; $90
    31  247f 4fce                               !text "O",'N'+$80                       ; $91
    32  2481 574149d4                           !text "WAI",'T'+$80                     ; $92
    33  2485 4c4f41c4                           !text "LOA",'D'+$80                     ; $93
    34  2489 534156c5                           !text "SAV",'E'+$80                     ; $94
    35  248d 5645524946d9                       !text "VERIF",'Y'+$80                   ; $95
    36  2493 4445c6                             !text "DE",'F'+$80                      ; $96
    37  2496 504f4bc5                           !text "POK",'E'+$80                     ; $97
    38  249a 5052494e54a3                       !text "PRINT",'#'+$80                   ; $98
    39  24a0 5052494ed4                         !text "PRIN",'T'+$80                    ; $99
    40  24a5 434f4ed4                           !text "CON",'T'+$80                     ; $9A
    41  24a9 4c4953d4                           !text "LIS",'T'+$80                     ; $9B
    42  24ad 434cd2                             !text "CL",'R'+$80                      ; $9C
    43  24b0 434dc4                             !text "CM",'D'+$80                      ; $9D
    44  24b3 5359d3                             !text "SY",'S'+$80                      ; $9E
    45  24b6 4f5045ce                           !text "OPE",'N'+$80                     ; $9F
    46  24ba 434c4f53c5                         !text "CLOS",'E'+$80                    ; $A0
    47  24bf 4745d4                             !text "GE",'T'+$80                      ; $A1
    48  24c2 4e45d7                             !text "NE",'W'+$80                      ; $A2
    49  24c5 544142a8                           !text "TAB",'('+$80                     ; $A3
    50  24c9 54cf                               !text "T",'O'+$80                       ; $A4
    51  24cb 46ce                               !text "F",'N'+$80                       ; $A5
    52  24cd 535043a8                           !text "SPC",'('+$80                     ; $A6
    53  24d1 544845ce                           !text "THE",'N'+$80                     ; $A7
    54  24d5 4e4fd4                             !text "NO",'T'+$80                      ; $A8
    55  24d8 535445d0                           !text "STE",'P'+$80                     ; $A9
    56  24dc ab                                 !text '+'+$80                           ; $AA operators
    57  24dd ad                                 !text '-'+$80                           ; $AB
    58  24de aa                                 !text '*'+$80                           ; $AC
    59  24df af                                 !text '/'+$80                           ; $AD
    60  24e0 de                                 !text '^'+$80                           ; $AE
    61  24e1 414ec4                             !text "AN",'D'+$80                      ; $AF
    62  24e4 4fd2                               !text "O",'R'+$80                       ; $B0
    63  24e6 be                                 !text '>'+$80                           ; $B1
    64  24e7 bd                                 !text '='+$80                           ; $B2
    65  24e8 bc                                 !text '<'+$80                           ; $B3
    66  24e9 5347ce                             !text "SG",'N'+$80                      ; $B4 first numeric function
    67  24ec 494ed4                             !text "IN",'T'+$80                      ; $B5
    68  24ef 4142d3                             !text "AB",'S'+$80                      ; $B6
    69  24f2 5553d2                             !text "US",'R'+$80                      ; $B7
    70  24f5 4652c5                             !text "FR",'E'+$80                      ; $B8
    71  24f8 504fd3                             !text "PO",'S'+$80                      ; $B9
    72  24fb 5351d2                             !text "SQ",'R'+$80                      ; $BA
    73  24fe 524ec4                             !text "RN",'D'+$80                      ; $BB
    74  2501 4c4fc7                             !text "LO",'G'+$80                      ; $BC
    75  2504 4558d0                             !text "EX",'P'+$80                      ; $BD
    76  2507 434fd3                             !text "CO",'S'+$80                      ; $BE
    77  250a 5349ce                             !text "SI",'N'+$80                      ; $BF
    78  250d 5441ce                             !text "TA",'N'+$80                      ; $C0
    79  2510 4154ce                             !text "AT",'N'+$80                      ; $C1
    80  2513 504545cb                           !text "PEE",'K'+$80                     ; $C2
    81  2517 4c45ce                             !text "LE",'N'+$80                      ; $C3
    82  251a 535452a4                           !text "STR",'$'+$80                     ; $C4
    83  251e 5641cc                             !text "VA",'L'+$80                      ; $C5
    84  2521 4153c3                             !text "AS",'C'+$80                      ; $C6 last numeric function
    85  2524 434852a4                           !text "CHR",'$'+$80                     ; $C7 last single-arg function
    86  2528 4c454654a4                         !text "LEFT",'$'+$80                    ; $C8
    87  252d 5249474854a4                       !text "RIGHT",'$'+$80                   ; $C9
    88  2533 4d4944a4                           !text "MID",'$'+$80                     ; $CA
    89  2537 47cf                               !text "G",'O'+$80                       ; $CB
    90                          ; beginning of new C128 keywords------------
    91  2539 52475241504849c3                   !text "RGRAPHI",'C'+$80                 ; $CC was 'rgr'   [910701]
    92  2541 52434f4c4fd2                       !text "RCOLO",'R'+$80                   ; $CD was 'rclr'   [910701]
    93  2547 80                                 !text $80                               ; $CE null to skip over escape_function token
    94  2548 4a4fd9                             !text "JO",'Y'+$80                      ; $CF
    95  254b 525045ce                           !text "RPE",'N'+$80                     ; $D0 (was rdot in c128)
    96  254f 4445c3                             !text "DE",'C'+$80                      ; $D1
    97  2552 484558a4                           !text "HEX",'$'+$80                     ; $D2
    98  2556 455252a4                           !text "ERR",'$'+$80                     ; $D3
    99  255a 494e5354d2                         !text "INST",'R'+$80                    ; $D4 last function
   100                          
   101  255f 454c53c5                           !text "ELS",'E'+$80                     ; $D5
   102  2563 524553554dc5                       !text "RESUM",'E'+$80                   ; $D6
   103  2569 545241d0                           !text "TRA",'P'+$80                     ; $D7
   104  256d 54524fce                           !text "TRO",'N'+$80                     ; $D8
   105  2571 54524f46c6                         !text "TROF",'F'+$80                    ; $D9
   106  2576 534f554ec4                         !text "SOUN",'D'+$80                    ; $DA
   107  257b 564fcc                             !text "VO",'L'+$80                      ; $DB
   108  257e 415554cf                           !text "AUT",'O'+$80                     ; $DC
   109  2582 50554445c6                         !text "PUDE",'F'+$80                    ; $DD
   110  2587 475241504849c3                     !text "GRAPHI",'C'+$80                  ; $DE
   111  258e 5041494ed4                         !text "PAIN",'T'+$80                    ; $DF
   112  2593 434841d2                           !text "CHA",'R'+$80                     ; $E0
   113  2597 424fd8                             !text "BO",'X'+$80                      ; $E1
   114  259a 434952434cc5                       !text "CIRCL",'E'+$80                   ; $E2
   115  25a0 50415354c5                         !text "PAST",'E'+$80                    ; $E3 (was gshape in C128)
   116  25a5 4355d4                             !text "CU",'T'+$80                      ; $E4 (was sshape in C128)
   117  25a8 4c494ec5                           !text "LIN",'E'+$80                     ; $E5 (was draw in C128)
   118  25ac 4c4f434154c5                       !text "LOCAT",'E'+$80                   ; $E6
   119  25b2 434f4c4fd2                         !text "COLO",'R'+$80                    ; $E7
   120  25b7 53434e434cd2                       !text "SCNCL",'R'+$80                   ; $E8
   121  25bd 5343414cc5                         !text "SCAL",'E'+$80                    ; $E9
   122  25c2 48454cd0                           !text "HEL",'P'+$80                     ; $EA
   123  25c6 44cf                               !text "D",'O'+$80                       ; $EB
   124  25c8 4c4f4fd0                           !text "LOO",'P'+$80                     ; $EC
   125  25cc 455849d4                           !text "EXI",'T'+$80                     ; $ED
   126  25d0 4449d2                             !text "DI",'R'+$80                      ; $EE
   127  25d3 44534156c5                         !text "DSAV",'E'+$80                    ; $EF
   128  25d8 444c4f41c4                         !text "DLOA",'D'+$80                    ; $F0
   129  25dd 4845414445d2                       !text "HEADE",'R'+$80                   ; $F1
   130  25e3 534352415443c8                     !text "SCRATC",'H'+$80                  ; $F2
   131  25ea 434f4c4c4543d4                     !text "COLLEC",'T'+$80                  ; $F3
   132  25f1 434f50d9                           !text "COP",'Y'+$80                     ; $F4
   133  25f5 52454e414dc5                       !text "RENAM",'E'+$80                   ; $F5
   134  25fb 4241434b55d0                       !text "BACKU",'P'+$80                   ; $F6
   135  2601 44454c4554c5                       !text "DELET",'E'+$80                   ; $F7
   136  2607 52454e554d4245d2                   !text "RENUMBE",'R'+$80                 ; $F8
   137  260f 4b45d9                             !text "KE",'Y'+$80                      ; $F9
   138  2612 4d4f4e49544fd2                     !text "MONITO",'R'+$80                  ; $FA
   139  2619 5553494ec7                         !text "USIN",'G'+$80                    ; $FB
   140  261e 554e5449cc                         !text "UNTI",'L'+$80                    ; $FC
   141  2623 5748494cc5                         !text "WHIL",'E'+$80                    ; $FD
   142  2628 00                                 !text 0                                 ; $FE skip over the escape_command token
   143                          
   144                          ;.end
   145                          
   146                          
   147                          
   148                          
   149                          
   150                          ; ********************************************************************************************
   151                          ;
   152                          ;	Date		Changes
   153                          ;	====		=======
   154                          ;
   155                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: tokeniser/keyword/esc.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      esc.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; Escape Command Tokens
    13                          
    14                          esc_command_list
    15  2629 42414ecb                           !text "BAN",'K'+$80                     ; $02: set bank number
    16  262d 46494c5445d2                       !text "FILTE",'R'+$80                   ; $03: set up filter
    17  2633 504c41d9                           !text "PLA",'Y'+$80                     ; $04: play a tune
    18  2637 54454d50cf                         !text "TEMP",'O'+$80                    ; $05: set rate for playing
    19  263c 4d4f565350d2                       !text "MOVSP",'R'+$80                   ; $06: sprite position/movement
    20  2642 5350524954c5                       !text "SPRIT",'E'+$80                   ; $07: turn on/set up sprite
    21  2648 535052434f4c4fd2                   !text "SPRCOLO",'R'+$80                 ; $08: set sprite multicolor registers
    22  2650 525245c7                           !text "RRE",'G'+$80                     ; $09: retreive register values after 'SYS'
    23  2654 454e56454c4f50c5                   !text "ENVELOP",'E'+$80                 ; $0A: set up SID envelopes
    24  265c 534c4545d0                         !text "SLEE",'P'+$80                    ; $0B: delay
    25  2661 434154414c4fc7                     !text "CATALO",'G'+$80                  ; $0C: disk directory
    26  2668 444f5045ce                         !text "DOPE",'N'+$80                    ; $0D: open a disk file
    27  266d 415050454ec4                       !text "APPEN",'D'+$80                   ; $0E: open a disk file for appending
    28  2673 44434c4f53c5                       !text "DCLOS",'E'+$80                   ; $0F: close a file opened w/ DOPEN
    29  2679 42534156c5                         !text "BSAV",'E'+$80                    ; $10: binary (non-program) save
    30  267e 424c4f41c4                         !text "BLOA",'D'+$80                    ; $11: binary load
    31  2683 5245434f52c4                       !text "RECOR",'D'+$80                   ; $12:
    32  2689 434f4e4341d4                       !text "CONCA",'T'+$80                   ; $13: concatenate 2 files
    33  268f 445645524946d9                     !text "DVERIF",'Y'+$80                  ; $14: verify a saved program
    34  2696 44434c4541d2                       !text "DCLEA",'R'+$80                   ; $15: re-initialize a drive
    35  269c 5350525341d6                       !text "SPRSA",'V'+$80                   ; $16: sprite/string to sprite/string
    36  26a2 434f4c4c4953494f...                !text "COLLISIO",'N'+$80                ; $17: set traps for sprite & light pen collisions
    37  26ab 42454749ce                         !text "BEGI",'N'+$80                    ; $18: mark start of a b-block
    38  26b0 42454ec4                           !text "BEN",'D'+$80                     ; $19: ..and its end, too!
    39  26b4 57494e444fd7                       !text "WINDO",'W'+$80                   ; $1A: set screen window
    40  26ba 424f4fd4                           !text "BOO",'T'+$80                     ; $1B: load&run ML or autoboot a disk
    41  26be 57494454c8                         !text "WIDT",'H'+$80                    ; $1C: single/double width drawing
    42  26c3 5350524445c6                       !text "SPRDE",'F'+$80                   ; $1D: define a sprite
    43  26c9 515549d4                           !text "QUI",'T'+$80                     ; $1E: (UNIMPLEMENTED)
    44  26cd 444dc1                             !text "DM",'A'+$80                      ; $1F: access memory
    45  26d0 a0                                 !text ' '+$80                           ; $20: POISON - space character
    46  26d1 444dc1                             !text "DM",'A'+$80                      ; $21: access memory
    47  26d4 a0                                 !text ' '+$80                           ; $22: POISON - quote character
    48  26d5 444dc1                             !text "DM",'A'+$80                      ; $23: access memory
    49  26d8 4f46c6                             !text "OF",'F'+$80                      ; $24: KEY OFF
    50  26db 464153d4                           !text "FAS",'T'+$80                     ; $25: go to 2 MHz. mode
    51  26df 534c4fd7                           !text "SLO",'W'+$80                     ; $26: go to 1 MHz. mode
    52  26e3 545950c5                           !text "TYP",'E'+$80                     ; $27: type SEQ file
    53  26e7 425645524946d9                     !text "BVERIF",'Y'+$80                  ; $28: verify a saved program
    54  26ee 4543544f52d9                       !text "ECTOR",'Y'+$80                   ; $29: dirECTORY
    55  26f4 45524153c5                         !text "ERAS",'E'+$80                    ; $2A: alias for scratch
    56  26f9 46494ec4                           !text "FIN",'D'+$80                     ; $2B: find string
    57  26fd 4348414e47c5                       !text "CHANG",'E'+$80                   ; $2C: change string
    58  2703 5345d4                             !text "SE",'T'+$80                      ; $2D:
    59  2706 5343524545ce                       !text "SCREE",'N'+$80                   ; $2E:
    60  270c 504f4c59474fce                     !text "POLYGO",'N'+$80                  ; $2F:
    61  2713 454c4c495053c5                     !text "ELLIPS",'E'+$80                  ; $30:
    62  271a 56494557504f52d4                   !text "VIEWPOR",'T'+$80                 ; $31:
    63  2722 47434f50d9                         !text "GCOP",'Y'+$80                    ; $32:
    64  2727 5045ce                             !text "PE",'N'+$80                      ; $33:
    65  272a 50414c455454c5                     !text "PALETT",'E'+$80                  ; $34:
    66  2731 444d4f44c5                         !text "DMOD",'E'+$80                    ; $35:
    67  2736 445041d4                           !text "DPA",'T'+$80                     ; $36:
    68  273a 464f524d41d4                       !text "FORMA",'T'+$80                   ; $37: alias for HEADER command  [911017]
    69  2740 47454e4c4f43cb                     !text "GENLOC",'K'+$80                  ; $38:     [910108]
    70  2747 464f524547524f55...                !text "FOREGROUN",'D'+$80               ; $39:     [910109]
    71  2751 a0                                 !text ' '+$80                           ; $3A: POISON - colon character  "
    72  2752 4241434b47524f55...                !text "BACKGROUN",'D'+$80               ; $3B:     "
    73  275c 424f524445d2                       !text "BORDE",'R'+$80                   ; $3C:     "
    74  2762 484947484c494748...                !text "HIGHLIGH",'T'+$80                ; $3D:     "
    75  276b 4d4f5553c5                         !text "MOUS",'E'+$80                    ; $3E:     [910122]
    76  2770 524d4f5553c5                       !text "RMOUS",'E'+$80                   ; $3F: return coordinates of mouse [910123]
    77  2776 444953cb                           !text "DIS",'K'+$80                     ; $40:     [910123]
    78  277a 435552534fd2                       !text "CURSO",'R'+$80                   ; $41:     [910228]
    79  2780 52435552534fd2                     !text "RCURSO",'R'+$80                  ; $42: return cursor position  [910228]
    80  2787 4c4f41444946c6                     !text "LOADIF",'F'+$80                  ; $43: load IFF picture from disk [910402]
    81  278e 534156454946c6                     !text "SAVEIF",'F'+$80                  ; $44: save IFF picture to   disk [910402]
    82  2795 454449d4                           !text "EDI",'T'+$80                     ; $45: Edit mode on/off   [910620]
    83                          
    84  2799 00                                 !text 0                                 ; End marker
    85                          ;(don't forget to change last_command_token!)
    86                          
    87                          ; Escape Function Tokens
    88                          
    89                          esc_function_list
    90  279a 504fd4                             !text "PO",'T'+$80                      ; $02: return paddle value
    91  279d 42554dd0                           !text "BUM",'P'+$80                     ; $03: read sprite collision
    92  27a1 4c5045ce                           !text "LPE",'N'+$80                     ; $04: read light pen value
    93  27a5 525350504fd3                       !text "RSPPO",'S'+$80                   ; $05: read sprite position
    94  27ab 525350524954c5                     !text "RSPRIT",'E'+$80                  ; $06: read sprite value
    95  27b2 525350434f4c4fd2                   !text "RSPCOLO",'R'+$80                 ; $07: read sprite multicolor value
    96  27ba 584fd2                             !text "XO",'R'+$80                      ; $08: exclusive or
    97  27bd 5257494e444fd7                     !text "RWINDO",'W'+$80                  ; $09: read window size
    98  27c4 504f494e5445d2                     !text "POINTE",'R'+$80                  ; $0a: return address of descriptor
    99  27cb 4d4fc4                             !text "MO",'D'+$80                      ; $0b: modulus    [910402]
   100  27ce 50495845cc                         !text "PIXE",'L'+$80                    ; $0c: return BP data at pixel  [910820]
   101  27d3 5250414c455454c5                   !text "RPALETT",'E'+$80                 ; $0d: return RGB component of color [910820]
   102  27db 00                                 !text 0
   103                          
   104                          ;.end
   105                          
   106                          ; ********************************************************************************************
   107                          ;
   108                          ;	Date		Changes
   109                          ;	====		=======
   110                          ;
   111                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: tokeniser/vectors.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      vectors.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          stmdsp
    15  27dc dc2c                               !word end-1
    16  27de 5c41                               !word for-1
    17  27e0 743a                               !word next-1
    18  27e2 4735                               !word data-1
    19  27e4 a138                               !word inputn-1
    20  27e6 bf38                               !word input-1
    21  27e8 f33a                               !word dim-1
    22  27ea 0f39                               !word read-1
    23  27ec 7536                               !word let-1
    24  27ee fa3c                               !word goto-1
    25  27f0 b33d                               !word run-1
    26  27f2 7d35                               !word if-1
    27  27f4 e63d                               !word restor-1
    28  27f6 eb3c                               !word gosub-1
    29  27f8 2c35                               !word return-1
    30  27fa 5535                               !word rem-1
    31  27fc da2c                               !word stop-1
    32  27fe 5436                               !word ongoto-1
    33  2800 e654                               !word wait-1
    34  2802 8968                               !word load-1
    35  2804 6168                               !word save-1
    36  2806 8668                               !word verify-1
    37  2808 f458                               !word def-1
    38  280a ed55                               !word poke-1
    39  280c a737                               !word printn-1
    40  280e c837                               !word print-1
    41  2810 793d                               !word cont-1
    42  2812 8932                               !word list-1
    43  2814 a534                               !word clear-1
    44  2816 ad37                               !word cmd-1
    45  2818 fd3a                               !word sys-1
    46  281a 0069                               !word open-1
    47  281c 0869                               !word close-1
    48  281e 6638                               !word get-1
    49  2820 5434                               !word new-1
    50                          
    51  2822 4236                               !word else-1
    52  2824 6744                               !word resume-1
    53  2826 5544                               !word trap-1
    54  2828 993b                               !word tron-1
    55  282a 9c3b                               !word troff-1
    56  282c 7c4b                               !word sound-1
    57  282e 454b                               !word volume-1
    58  2830 593c                               !word auto-1
    59  2832 4144                               !word puctrl-1
    60  2834 bf7f                               !word graphic-1
    61                          
    62  2836 5ab3                               !word C65__paint-1
    63  2838 efb2                               !word C65__char-1
    64  283a 06b1                               !word C65__box-1
    65  283c 5ab1                               !word C65__circle-1
    66  283e 4fb4                               !word C65__paste-1                      ; gshape
    67  2840 4fb4                               !word C65__cut-1                        ; sshape
    68  2842 b1b0                               !word C65__line-1                       ; draw
    69                          
    70  2844 3a2e                               !word bad_command-1                     ; escape - SYSTEM - unimplemented command
    71                          ; .word  locate-1
    72                          
    73  2846 99b4                               !word color-1
    74  2848 34af                               !word scnclr-1
    75                          
    76  284a 3a2e                               !word bad_command-1                     ; escape - SYSTEM - unimplemented command
    77                          ; .word  scale-1
    78                          
    79  284c 683c                               !word help-1
    80  284e ec44                               !word do-1
    81  2850 8e45                               !word loop-1
    82  2852 4145                               !word exit-1
    83  2854 9f6f                               !word directory-1
    84  2856 4671                               !word dsave-1
    85  2858 6871                               !word dload-1
    86  285a 4a72                               !word header-1
    87  285c d372                               !word scratch-1
    88  285e 6473                               !word collect-1
    89  2860 7b73                               !word dcopy-1
    90  2862 c773                               !word rename-1
    91  2864 d973                               !word backup-1
    92  2866 e741                               !word delete-1
    93  2868 123e                               !word renumber-1
    94  286a d445                               !word key-1
    95  286c 55ff                               !word _monitor-1
    96  286e 4647                               !word bank-1                            ; escape
    97  2870 154a                               !word filter-1                          ; escape
    98  2872 4d47                               !word play-1                            ; escape
    99  2874 8449                               !word tempo-1                           ; escape
   100                          
   101  2876 bfb5                               !word movspr-1                          ; escape
   102  2878 28b5                               !word sprite-1                          ; escape
   103  287a 05b8                               !word sprcolor-1                        ; escape
   104                          
   105  287c 9f3b                               !word rreg-1                            ; escape
   106  287e a34a                               !word envelope-1                        ; escape
   107  2880 c054                               !word sleep-1                           ; escape
   108  2882 9f6f                               !word directory-1                       ; escape
   109  2884 d170                               !word dopen-1                           ; escape
   110  2886 e770                               !word append-1                          ; escape
   111  2888 2f71                               !word dclose-1                          ; escape
   112  288a 9071                               !word bsave-1                           ; escape
   113  288c e171                               !word bload-1                           ; escape
   114  288e 0a73                               !word record-1                          ; escape
   115  2890 b773                               !word concat-1                          ; escape
   116  2892 6571                               !word dverify-1                         ; escape
   117  2894 5473                               !word dclear-1                          ; escape
   118                          
   119  2896 1bb8                               !word sprsav-1                          ; escape
   120  2898 dbb8                               !word collision-1                       ; escape
   121                          
   122  289a 4735                               !word data-1                            ; escape - BEGIN
   123  289c 4735                               !word data-1                            ; escape - BEND
   124  289e 5f4c                               !word window-1                          ; escape
   125  28a0 4e67                               !word boot-1                            ; escape
   126                          
   127  28a2 3a2e                               !word bad_command-1
   128                          ; .word  set_width-1 ;escape - WIDTH
   129                          
   130  28a4 3a2e                               !word bad_command-1
   131                          ; .word  sprdef-1  ;escape - Sprite Definition mode
   132                          
   133  28a6 3a2e                               !word bad_command-1                     ; escape - QUIT - unimplemented command
   134  28a8 333b                               !word dma-1                             ; escape
   135  28aa 0000                               !word 0                                 ; placeholder to skip over the space character
   136  28ac 333b                               !word dma-1                             ; escape
   137  28ae 0000                               !word 0                                 ; placeholder to skip over the quote character
   138  28b0 333b                               !word dma-1                             ; escape
   139  28b2 3a2e                               !word bad_command-1                     ; escape - OFF - unimplemented command
   140  28b4 c54c                               !word fast-1                            ; escape
   141  28b6 ce4c                               !word slow-1                            ; escape
   142  28b8 166f                               !word type-1                            ; escape (C65: type SEQ file)
   143  28ba de71                               !word bverify-1                         ; escape (C65: verify BINary file)
   144  28bc 492e                               !word snerr-1                           ; escape (C65: kludge- dirECTORY)
   145  28be d372                               !word scratch-1                         ; escape (C65: erase alias for scratch)
   146  28c0 8842                               !word find-1                            ; escape (C65: find BASIC text)
   147  28c2 8b42                               !word change-1                          ; escape (C65: change BASIC text)
   148                          
   149  28c4 1ab2                               !word C65__set-1                        ; escape (C65: multi-purpose command)
   150  28c6 ffae                               !word Screen-1                          ; escape (C65: SCREEN)
   151  28c8 bbb1                               !word C65__polygon-1                    ; escape (C65: POLYGON)
   152  28ca 86b1                               !word C65__ellipse-1                    ; escape (C65: ELLIPSE)
   153  28cc 14b4                               !word C65__Viewport-1                   ; escape (C65: VIEWPORT)
   154  28ce 4fb4                               !word C65__copy-1                       ; escape (C65: GCOPY)
   155  28d0 b7af                               !word C65__setpen-1                     ; escape (C65: PEN)
   156  28d2 45b0                               !word C65__setpalette-1                 ; escape (C65: PALETTE)
   157  28d4 cbaf                               !word C65__setdmode-1                   ; escape (C65: DMODE)
   158  28d6 01b0                               !word C65__setdpat-1                    ; escape (C65: DPAT)
   159  28d8 4a72                               !word header-1                          ; format alias for header command [911017]
   160  28da 52b4                               !word genlock-1                         ; [910108]
   161                          
   162                          stmdsp2
   163  28dc dab4                               !word foreground-1                      ; this is the 128th command!  [910109]
   164  28de 0000                               !word 0                                 ; placeholder to skip over the colon character
   165  28e0 fbb4                               !word background-1
   166  28e2 02b5                               !word border-1
   167  28e4 e0b4                               !word highlight-1
   168  28e6 ef7b                               !word mouse-1                           ; [910122]
   169  28e8 8c7c                               !word rmouse-1                          ; [910123]
   170  28ea 796f                               !word disk-1                            ; [910123]
   171  28ec 277d                               !word cursor-1                          ; [910228]
   172  28ee 807d                               !word rcursor-1                         ; [910228]
   173  28f0 aeb3                               !word loadiff-1                         ; [910402]
   174  28f2 eab3                               !word saveiff-1                         ; [910930]
   175  28f4 c6bc                               !word edit-1                            ; [910620]
   176                          
   177                          
   178                          fundsp
   179  28f6 cf62                               !word sgn
   180  28f8 6363                               !word int
   181  28fa ee62                               !word abs
   182  28fc f702                               !word usrpok
   183  28fe 1355                               !word fre
   184  2900 ce58                               !word pos
   185  2902 bc65                               !word sqr
   186  2904 2358                               !word rnd
   187  2906 0e60                               !word log
   188  2908 0766                               !word exp
   189  290a 9e66                               !word cos
   190  290c a566                               !word sin
   191  290e ee66                               !word tan
   192  2910 1f67                               !word atn
   193  2912 c755                               !word peek
   194  2914 565a                               !word len
   195  2916 a559                               !word strd
   196  2918 4655                               !word val
   197  291a 655a                               !word asc
   198  291c b659                               !word chrd
   199  291e cc59                               !word leftd
   200  2920 ff59                               !word rightd
   201  2922 105a                               !word midd
   202  2924 26b9                               !word rgraphic                          ; [910701]
   203  2926 ffb8                               !word rcolor                            ; [910701]
   204  2928 0000                               !word 0                                 ; placeholder for escape function token
   205  292a ae56                               !word joy
   206  292c 9bb9                               !word rpen                              ; was rdot     [910820]
   207  292e 7855                               !word dcml                              ; dec
   208  2930 6f56                               !word hexd
   209  2932 1856                               !word errd
   210  2934 f356                               !word pot                               ; escape
   211  2936 9cba                               !word bump                              ; escape
   212  2938 5257                               !word lpen                              ; escape
   213  293a 5aba                               !word rsppos                            ; escape
   214  293c 0fba                               !word rsprite                           ; escape
   215  293e 45ba                               !word rspcolor                          ; escape
   216  2940 9557                               !word xor                               ; escape
   217  2942 fa57                               !word rwindow                           ; escape
   218  2944 7457                               !word pointer                           ; escape
   219  2946 b757                               !word mod                               ; escape c65     [910402]
   220  2948 76b9                               !word pixel                             ; escape c65     [910820]
   221  294a b8b9                               !word rpalette                          ; escape c65     [910820]
   222                          
   223                          
   224  294c 79                 optab           !text 121
   225  294d bd5d                               !word faddt-1
   226  294f 79                                 !text 121
   227  2950 a75d                               !word fsubt-1
   228  2952 7b                                 !text 123
   229  2953 6f60                               !word fmultt-1
   230  2955 7b                                 !text 123
   231  2956 8461                               !word fdivt-1
   232  2958 7f                                 !text 127
   233  2959 c565                               !word fpwrt-1
   234  295b 50                                 !text 80
   235  295c 9a2d                               !word andop-1
   236  295e 46                                 !text 70
   237  295f 972d                               !word orop-1
   238  2961 7d                 negtab          !text 125
   239  2962 fb65                               !word negop-1
   240  2964 5a                                 !text 90
   241  2965 324e                               !word notop-1
   242  2967 64                 ptdorl          !text 100
   243  2968 c72d                               !word dorel-1
   244                          
   245                          ;.end
   246                          
   247                          
   248                          ; ********************************************************************************************
   249                          ;
   250                          ;	Date		Changes
   251                          ;	====		=======
   252                          ;
   253                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: tokeniser/const.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      const.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          end_token       = $80                                   ; v2 commands
    15                          for_token       = $81
    16                          next_token      = $82
    17                          data_token      = $83
    18                          input_token     = $84
    19                          goto_token      = $89
    20                          run_token       = $8a
    21                          restore_token   = $8c
    22                          gosub_token     = $8d
    23                          rem_token       = $8f
    24                          on_token        = $91
    25                          load_token      = $93
    26                          save_token      = $94
    27                          verify_token    = $95
    28                          def_token       = $96
    29                          print_token     = $99
    30                          clr_token       = $9c
    31                          sys_token       = $9e
    32                          open_token      = $9f
    33                          close_token     = $a0
    34                          new_token       = $a2
    35                          tab_token       = $a3
    36                          to_token        = $a4
    37                          fn_token        = $a5
    38                          spc_token       = $a6
    39                          then_token      = $a7
    40                          not_token       = $a8
    41                          step_token      = $a9
    42                          plus_token      = $aa                                   ; operators
    43                          minus_token     = $ab
    44                          greater_token   = $b1
    45                          equal_token     = $b2
    46                          less_token      = $b3
    47                          first_function_token= $b4                                   ; v2 functions
    48                          left_token      = $c8
    49                          mid_token       = $ca
    50                          go_token        = $cb                                   ; kludges
    51                          rgraphic_token  = $cc                                   ; first new v7 token
    52                          esc_function_token= $ce
    53                          err_token       = $d3
    54                          instr_token     = $d4
    55                          last_function_token= $d4
    56                          else_token      = $d5
    57                          resume_token    = $d6
    58                          trap_token      = $d7
    59                          color_token     = $e7
    60                          do_token        = $eb
    61                          loop_token      = $ec
    62                          key_token       = $f9
    63                          monitor_token   = $fa
    64                          using_token     = $fb
    65                          until_token     = $fc
    66                          while_token     = $fd
    67                          esc_command_token= $fe
    68                          
    69                          first_esc_command_token= $02
    70                          collision_token = $17
    71                          begin_token     = $18
    72                          bend_token      = $19
    73                          off_token       = $24
    74                          ectory_token    = $29
    75                          set_token       = $2d
    76                          pic_token       = $37
    77                          disk_token      = $40
    78                          last_esc_command_token= $45                                   ; <<<< last_command_token
    79                          
    80                          first_esc_function_token= $02
    81                          pointer_token   = $0a
    82                          last_esc_function_token= $0d                                   ; [910820]
    83                          
    84                          
    85                          
    86                          ; ********************************************************************************************
    87                          ;
    88                          ;	Date		Changes
    89                          ;	====		=======
    90                          ;
    91                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: error/messages.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      messages.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ok_error_message
    15  296a 4fcb                               !text "O",'K'+$80                       ; 0 for ERR$ [910911]
    16                          error_message_list
    17  296c 544f4f204d414e59...                !text "TOO MANY FILE",'S'+$80           ; 1
    18  297a 46494c45204f5045...                !text "FILE OPE",'N'+$80                ; 2
    19  2983 46494c45204e4f54...                !text "FILE NOT OPE",'N'+$80            ; 3
    20  2990 46494c45204e4f54...                !text "FILE NOT FOUN",'D'+$80           ; 4
    21  299e 444556494345204e...                !text "DEVICE NOT PRESEN",'T'+$80       ; 5
    22  29b0 4e4f5420494e5055...                !text "NOT INPUT FIL",'E'+$80           ; 6
    23  29be 4e4f54204f555450...                !text "NOT OUTPUT FIL",'E'+$80          ; 7
    24  29cd 4d495353494e4720...                !text "MISSING FILE NAM",'E'+$80        ; 8
    25  29de 494c4c4547414c20...                !text "ILLEGAL DEVICE NUMBE",'R'+$80    ; 9
    26  29f3 4e45585420574954...                !text "NEXT WITHOUT FO",'R'+$80         ; 10
    27  2a03 53594e5441d8                       !text "SYNTA",'X'+$80                   ; 11
    28  2a09 52455455524e2057...                !text "RETURN WITHOUT GOSU",'B'+$80     ; 12
    29  2a1d 4f5554204f462044...                !text "OUT OF DAT",'A'+$80              ; 13
    30  2a28 494c4c4547414c20...                !text "ILLEGAL QUANTIT",'Y'+$80         ; 14
    31  2a38 4f564552464c4fd7                   !text "OVERFLO",'W'+$80                 ; 15
    32  2a40 4f5554204f46204d...                !text "OUT OF MEMOR",'Y'+$80            ; 16
    33  2a4d 554e444546274420...                !text "UNDEF",$27,"D STATEMEN",'T'+$80  ; 17
    34  2a5e 4241442053554253...                !text "BAD SUBSCRIP",'T'+$80            ; 18
    35  2a6b 524544494d274420...                !text "REDIM",$27,"D ARRA",'Y'+$80      ; 19
    36  2a78 4449564953494f4e...                !text "DIVISION BY ZER",'O'+$80         ; 20
    37  2a88 494c4c4547414c20...                !text "ILLEGAL DIREC",'T'+$80           ; 21
    38  2a96 54595045204d4953...                !text "TYPE MISMATC",'H'+$80            ; 22
    39  2aa3 535452494e472054...                !text "STRING TOO LON",'G'+$80          ; 23
    40  2ab2 46494c4520444154...                !text "FILE DAT",'A'+$80                ; 24
    41  2abb 464f524d554c4120...                !text "FORMULA TOO COMPLE",'X'+$80      ; 25
    42  2ace 43414e275420434f...                !text "CAN",$27,"T CONTINU",'E'+$80     ; 26
    43  2adc 554e444546274420...                !text "UNDEF'D FUNCTIO",'N'+$80         ; 27
    44  2aec 5645524946d9                       !text "VERIF",'Y'+$80                   ; 28
    45  2af2 4c4f41c4                           !text "LOA",'D'+$80                     ; 29
    46  2af6 42524541cb                         !text "BREA",'K'+$80                    ; 30 ???? null & space [910925]
    47  2afb 43414e2754205245...                !text "CAN'T RESUM",'E'+$80             ; 31
    48  2b07 4c4f4f50204e4f54...                !text "LOOP NOT FOUN",'D'+$80           ; 32
    49  2b15 4c4f4f5020574954...                !text "LOOP WITHOUT D",'O'+$80          ; 33
    50  2b24 444952454354204d...                !text "DIRECT MODE ONL",'Y'+$80         ; 34
    51                          ; .byte 'NO GRAPHICS ARE','A'+$80   ;35
    52  2b34 53435245454e204e...                !text "SCREEN NOT OPE",'N'+$80          ; 35    [911001]
    53  2b43 42414420444953cb                   !text "BAD DIS",'K'+$80                 ; 36 ???? used for failed bootsys
    54  2b4b 42454e44204e4f54...                !text "BEND NOT FOUN",'D'+$80           ; 37
    55  2b59 4c494e45204e554d...                !text "LINE NUMBER TOO LARG",'E'+$80    ; 38
    56  2b6e 554e5245534f4c56...                !text "UNRESOLVED REFERENC",'E'+$80     ; 39
    57  2b82 554e494d504c454d...                !text "UNIMPLEMENTED COMMAN",'D'+$80    ; 40
    58  2b97 46494c4520524541...                !text "FILE REA",'D'+$80                ; 41
    59  2ba0 45444954204d4f44...                !text "EDIT MOD",'E'+$80                ; 42    [910620]
    60                          
    61                          
    62                          
    63                          
    64                          ; ********************************************************************************************
    65                          ;
    66                          ;	Date		Changes
    67                          ;	====		=======
    68                          ;
    69                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: error/constants.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      constants.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          errtmf          = 1
    14                          errfno          = 3
    15                          errfnf          = 4
    16                          err_missing_fname= 8
    17                          err_illegal_device= 9
    18                          errnf           = 10
    19                          errsn           = 11
    20                          errrg           = 12
    21                          errod           = 13
    22                          errfc           = 14
    23                          errov           = 15
    24                          errom           = 16
    25                          errus           = 17
    26                          errbs           = 18
    27                          errdd           = 19
    28                          errdvo          = 20
    29                          errid           = 21
    30                          errtm           = 22
    31                          errls           = 23
    32                          errbd           = 24
    33                          errst           = 25
    34                          errcn           = 26
    35                          erruf           = 27
    36                          ervfy           = 28
    37                          erload          = 29
    38                          erbrk           = 30
    39                          errcr           = 31
    40                          errlnf          = 32
    41                          errlwd          = 33
    42                          erroid          = 34
    43                          errng           = 35
    44                          errbdk          = 36
    45                          err_no_bend     = 37
    46                          err_too_large   = 38
    47                          err_ref         = 39
    48                          err_bad_command = 40
    49                          err_file_read   = 41
    50                          edit_mode_error = 42                                    ; [910620]
    51                          last_error_message= 42                                    ; # of last error msg
    52                          
    53                          ;.end
    54                          
    55                          
    56                          ; ********************************************************************************************
    57                          ;
    58                          ;	Date		Changes
    59                          ;	====		=======
    60                          ;
    61                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: error/message.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      message.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ; Routine to translate error message # in .a
    15                          ; into address of string containing message in index2
    16                          
    17  2ba9 aa                 erstup          tax                                     ; error set up
    18  2baa a000                               ldy     #0                              ; start with address of first error message
    19  2bac a96c                               lda     #<error_message_list
    20  2bae 8526                               sta     index2
    21  2bb0 a929                               lda     #>error_message_list
    22  2bb2 8527                               sta     index2+1
    23                          
    24  2bb4 ca                 l11_1           dex
    25  2bb5 300a                               bmi     l11_3                           ; finished when .x decrements out
    26                          
    27  2bb7 b126               l11_2           lda     (index2),y                      ; look at msg, and find end (msb set) (ind.ok)
    28  2bb9 e326                               inw     index2
    29  2bbb 29ff                               and     #$ff                            ; was msb set?
    30  2bbd 10f8                               bpl     l11_2                           ; no, not end of message
    31  2bbf 80f3                               bra     l11_1                           ; yes, tick off another msg
    32                          
    33  2bc1 60                 l11_3           rts
    34                          
    35                          ;.end
    36                          
    37                          ; ********************************************************************************************
    38                          ;
    39                          ;	Date		Changes
    40                          ;	====		=======
    41                          ;
    42                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/dispatcher.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      dispatcher.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Here for new statement. Character -> by txtptr is ':' or eol. The adr of
    16                          ; this loc is left on the stack when a statement is executed so that it can
    17                          ; merely do a rts when it is done.
    18                          ; Get char, exit via xeqcm3, and return to newstt.
    19                          
    20  2bc2 6c0803             xeqcm           jmp     (igone)
    21                          
    22                          ; Check if there is an interrupt from VIC that needs to be serviced
    23                          
    24  2bc5 7f7e3f             ngone           bbr7    runmod,l12_3                    ; get off here if we are in direct mode
    25  2bc8 addc02                             lda     intval                          ; check if there is an interrupt already in progress
    26  2bcb 303a                               bmi     l12_3                           ; yes, don't go any further
    27                          
    28  2bcd a202                               ldx     #2                              ; check for 3 types of interrupts: s/s, s/b, & lp
    29  2bcf bddd02             l12_1           lda     int_trip_flag,x
    30  2bd2 f030                               beq     l12_2                           ; this wasn't set, go check next
    31                          
    32  2bd4 a900                               lda     #0
    33  2bd6 9ddd02                             sta     int_trip_flag,x                 ; reset this flag to show 'serviced'
    34  2bd9 bde002                             lda     int_adr_lo,x                    ; install the trap address as linnum
    35  2bdc 8516                               sta     linnum
    36  2bde bde302                             lda     int_adr_hi,x
    37  2be1 8517                               sta     linnum+1
    38  2be3 da                                 phx                                     ; save counter & text pointer
    39  2be4 fc3d00                             phw     txtptr
    40  2be7 a980                               lda     #$80                            ; flag 'no other interrupt traps, please'
    41  2be9 0cdc02                             tsb     intval
    42                          
    43  2bec 208322                             jsr     chrget                          ; skip over 2nd byte of line number
    44  2bef 20393d                             jsr     gosub_sub                       ; fake a 'gosub' from here, so trap rx can do a RETURN
    45  2bf2 20063d                             jsr     goto_1
    46  2bf5 200d2c                             jsr     newstt
    47                          
    48  2bf8 a980                               lda     #$80
    49  2bfa 1cdc02                             trb     intval
    50  2bfd 68                                 pla
    51  2bfe 853e                               sta     txtptr+1
    52  2c00 68                                 pla
    53  2c01 853d                               sta     txtptr
    54  2c03 fa                                 plx
    55                          
    56  2c04 ca                 l12_2           dex
    57  2c05 10c8                               bpl     l12_1
    58                          
    59                          
    60  2c07 208322             l12_3           jsr     chrget                          ; get statement type
    61  2c0a 20522c             xeqdir          jsr     xeqcm3
    62                          
    63  2c0d 20cc2c             newstt          jsr     is_stop_key_down
    64  2c10 7f7e06                             bbr7    runmod,l13_1                    ; branch if direct mode
    65                          
    66                          ; In run mode...save txtptr for CONTinue command
    67                          
    68  2c13 20472c                             jsr     tto                             ; transfer txtptr to oldtxt
    69  2c16 ba                                 tsx
    70  2c17 8681                               stx     oldstk
    71                          
    72  2c19 a000               l13_1           ldy     #0
    73  2c1b 20c522                             jsr     indtxt                          ; end of the line?
    74  2c1e d3a500                             +lbne   morsts                          ; no...out of statement
    75                          
    76  2c21 247e               l13_2           bit     runmod                          ; in direct mode?
    77  2c23 132802                             +lbpl   ready                           ; yes, go to ready
    78  2c26 a002                               ldy     #2
    79  2c28 20c522                             jsr     indtxt                          ; end of text?
    80  2c2b f32002                             +lbeq   ready                           ; yes...finished
    81  2c2e c8                                 iny                                     ; y=3
    82  2c2f 20c522                             jsr     indtxt                          ; extract line# lo byte
    83  2c32 853b                               sta     curlin
    84  2c34 c8                                 iny
    85  2c35 20c522                             jsr     indtxt                          ; extract line # hi byte
    86  2c38 853c                               sta     curlin+1
    87  2c3a 98                                 tya                                     ; y=4
    88  2c3b 18                                 clc
    89  2c3c 653d                               adc     txtptr                          ; point @ character before line start
    90  2c3e 853d                               sta     txtptr
    91  2c40 9002                               bcc     l13_3
    92  2c42 e63e                               inc     txtptr+1
    93  2c44 837cff             l13_3           +lbra   xeqcm                           ; execute new line
    94                          
    95                          
    96                          
    97  2c47 a53d               tto             lda     txtptr
    98  2c49 a43e                               ldy     txtptr+1
    99  2c4b 8d7211                             sta     oldtxt
   100  2c4e 8c7311                             sty     oldtxt+1
   101  2c51 60                 xeqrts          rts
   102                          
   103                          
   104                          ; Set up for command processing and set processor address on stack.
   105                          ; Exit via jmp to CHRGET
   106                          
   107  2c52 f0fd               xeqcm3          beq     xeqrts                          ; nothing here...null statement
   108  2c54 5f7e12                             bbr5    runmod,xeqcm2                   ; trcflg. branch if trace not enabled
   109  2c57 7f7e0f                             bbr7    runmod,xeqcm2                   ; branch if direct mode- can't trace
   110                          
   111  2c5a 48                                 pha                                     ; save token
   112  2c5b a95b                               lda     #'['                            ; print '[line-number]'
   113  2c5d 203d68                             jsr     outch                           ; outdo
   114  2c60 207b64                             jsr     curprt                          ; print curlin
   115  2c63 a95d                               lda     #']'
   116  2c65 203d68                             jsr     outch                           ; outdo
   117  2c68 68                                 pla                                     ; restore token
   118                          
   119                          
   120  2c69 c9fe               xeqcm2          cmp     #esc_command_token              ; special case: escape token
   121  2c6b f03e                               beq     xeqesc
   122  2c6d c9cb                               cmp     #go_token                       ; special case: go to
   123  2c6f f3ed10                             +lbeq   go_without_to
   124  2c72 c9ca                               cmp     #mid_token                      ; special case: mid$()=
   125  2c74 f02c                               beq     xeqmid
   126                          
   127                          ; Command can be in the range END...NEW (old BASIC) & ELSE...MONITOR
   128                          ; (new extensions).  Although there is a gap between these two blocks,
   129                          ; it will be quickest & easiest to collapse them into one continuous block.
   130                          
   131  2c76 c9fb                               cmp     #monitor_token+1
   132  2c78 b048                               bcs     snerr1
   133  2c7a c9a3                               cmp     #new_token+1
   134  2c7c 9006                               bcc     xeqcm4                          ; no need to collapse
   135  2c7e c9d5                               cmp     #else_token
   136  2c80 9040                               bcc     snerr1
   137  2c82 e932                               sbc     #else_token-new_token-1
   138                          
   139  2c84 38                 xeqcm4          sec                                     ; convert adjusted token into an index into a jump table.
   140  2c85 e980                               sbc     #end_token
   141  2c87 93ed09                             +lbcc   let                             ; it wasn't a token after all!  assume an assignment
   142                          
   143  2c8a 0a                 xeqcm5          asl                                     ; *2 to convert into word pointer
   144  2c8b a8                                 tay
   145  2c8c b009                               bcs     l14_1                           ; dispatch table 1 or 2?     [901212]
   146  2c8e b9dd27                             lda     stmdsp+1,y                      ; one
   147  2c91 48                                 pha
   148  2c92 b9dc27                             lda     stmdsp,y
   149  2c95 8007                               bra     l14_2
   150                          
   151  2c97 b9dd28             l14_1           lda     stmdsp2+1,y                     ; two      [901212]
   152  2c9a 48                                 pha
   153  2c9b b9dc28                             lda     stmdsp2,y
   154                          
   155  2c9e 48                 l14_2           pha
   156  2c9f 4c8322                             jmp     chrget                          ; execution will commence after chrget's RTS
   157                          
   158                          
   159                          
   160                          xeqmid                                                  ; handle special case of MID$= (what we call a kludge)
   161  2ca2 a93b                               lda     #>midwrk                        ; midd2-1
   162  2ca4 48                                 pha
   163  2ca5 a9e1                               lda     #<midwrk
   164  2ca7 48                                 pha
   165                          xeqchr
   166  2ca8 4c8322                             jmp     chrget
   167                          
   168                          
   169                          
   170                          
   171                          xeqesc                                                  ; execute escape token
   172  2cab 208322                             jsr     chrget                          ; let's have us a look at the second char
   173  2cae f012                               beq     snerr1                          ; oops, there wasn't any!
   174  2cb0 c902                               cmp     #first_esc_command_token        ; is it one of our esc tokens?
   175  2cb2 9008                               bcc     l15_1                           ; no, foreign.
   176  2cb4 c946                               cmp     #last_esc_command_token+1
   177  2cb6 b004                               bcs     l15_1                           ; foreign
   178                          
   179                          ; It's one of our own.  Convert to index into command dispatch table
   180                          
   181  2cb8 6947                               adc     #monitor_token-else_token+new_token-end_token-first_esc_command_token+2
   182  2cba 80ce                               bra     xeqcm5                          ; always
   183                          
   184  2cbc 38                 l15_1           sec                                     ; set up flag for a trip into the users code
   185  2cbd 6c1003                             jmp     (iescex)
   186                          
   187  2cc0 90e6               nescex          bcc     xeqchr                          ; jmp chrget
   188                          
   189  2cc2 838601             snerr1          +lbra   snerr
   190                          
   191  2cc5 c93a               morsts          cmp     #':'
   192  2cc7 f3f9fe                             +lbeq   xeqcm                           ; if ':', continue statement
   193  2cca 80f6                               bra     snerr1
   194                          
   195                          
   196                          
   197                          ; ********************************************************************************************
   198                          ;
   199                          ;	Date		Changes
   200                          ;	====		=======
   201                          ;
   202                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/set1.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      set1.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; STOP, STOP KEY, and END handlers
    13                          ;
    14                          
    15                          is_stop_key_down
    16  2ccc 20e1ff                             jsr     _stop                           ; test stop key
    17  2ccf d03b                               bne     do_rts                          ; not down, exit
    18                          
    19                          ; ldy trapno+1  ;test if trap on????   removed [910925]
    20                          ; iny
    21                          ; beq stop_1  ;no, do a normal stop
    22                          
    23                          
    24                          break_exit                                              ; STOP KEY:     [910104]
    25  2cd1 20e1ff             l16_1           jsr     _stop                           ; wait for the user to release the key
    26  2cd4 f0fb                               beq     l16_1
    27  2cd6 a21e                               ldx     #erbrk                          ; take the vector thru error to ready
    28  2cd8 837501                             +lbra   error
    29                          
    30                          
    31                          
    32  2cdb b001               stop            bcs     stopc                           ; STOP: .c=1
    33                          
    34  2cdd 18                 end             clc                                     ; END: .c=0
    35  2cde d36a01             stopc           +lbne   snerr                           ; error if args present   [910410]
    36                          
    37  2ce1 7f7e0d             stop_1          bbr7    runmod,l17_1                    ; branch if direct mode
    38  2ce4 20472c                             jsr     tto                             ; transfer txtptr to oldtxt
    39  2ce7 a53b                               lda     curlin
    40  2ce9 a43c                               ldy     curlin+1
    41  2ceb 8d7011                             sta     oldlin
    42  2cee 8c7111                             sty     oldlin+1
    43  2cf1 68                 l17_1           pla                                     ; .diris
    44  2cf2 68                                 pla
    45  2cf3 935801                             +lbcc   ready                           ; say 'ready' if END, say 'break' if STOP
    46                          
    47                          
    48  2cf6 20b438             break           jsr     release_channels                ; make sure we're in text mode????  [910909]
    49  2cf9 2027af                             jsr     RestoreTextScreen
    50  2cfc 20dc3c                             jsr     highlight_text                  ; ????      [910624]
    51  2cff 207dff                             jsr     _primm
    52  2d02 0d425245414b00                     !text cr,"BREAK",0
    53  2d09 83ce01                             +lbra   errfin                          ; exit via 'in line #'
    54                          
    55  2d0c 60                 do_rts          rts
    56                          
    57                          ;.end
    58                          
    59                          ; ********************************************************************************************
    60                          ;
    61                          ;	Date		Changes
    62                          ;	====		=======
    63                          ;
    64                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/dispatch.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      dispatch.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; At this point, eval has determined that the token in a has to be a
    16                          ; function.  It must therefor be in the range SGN...MID$ (old BASIC),
    17                          ; or RGR...INSTR (new extensions).  We will collapse these two disjoint
    18                          ; blocks into one continuous range.
    19                          ;
    20                          ; On entry, we can assume the token is >= 'sgn'
    21                          
    22  2d0d c9ce               isfun           cmp     #esc_function_token             ; is this an escape function?
    23  2d0f f059                               beq     do_esc_fn                       ; yes
    24  2d11 c9d5                               cmp     #last_function_token+1
    25  2d13 b0ad                               bcs     snerr1                          ; no- must be syntax error
    26  2d15 c9cb                               cmp     #mid_token+1
    27  2d17 9002                               bcc     l18_1                           ; no need to adjust
    28  2d19 e901                               sbc     #rgraphic_token-mid_token-1
    29                          
    30  2d1b 48                 l18_1           pha                                     ; save token
    31  2d1c aa                                 tax
    32  2d1d 208322                             jsr     chrget                          ; set up for synchk.
    33  2d20 e0d3                               cpx     #instr_token-1                  ; look for (adjusted) instr token
    34  2d22 f00d                               beq     l18_2                           ; yes
    35  2d24 e0cb                               cpx     #rgraphic_token-1               ; look for rgraphic which now takes 2 args [910801]
    36  2d26 f3fe8b                             +lbeq   rgraphic                        ; yes
    37                          
    38  2d29 e0cb                               cpx     #mid_token+1
    39  2d2b b024                               bcs     oknorm                          ; LEFT$,RIGHT$,MID$ require multiple args
    40  2d2d e0c8                               cpx     #left_token                     ; is it past last single-arg function?
    41  2d2f 9020                               bcc     oknorm                          ; no, must be normal function
    42                          
    43                          
    44                          ; Most functions take a single argument.  The return address of these functions
    45                          ; is CHKNUM, which ascertains that VALTYP=0 (numeric).  Normal functions which
    46                          ; return string results (eg. CHR$) must pop off that return address and return
    47                          ; directly to FRMEVL.
    48                          ;
    49                          ; The so called "funny" functions can take more than one argument, the first
    50                          ; of which must be string and the second of which must be a number between 0
    51                          ; and 255.  The closed parenthesis must be checked and return is directly to
    52                          ; FRMEVL with the text pointer pointing beyond the ")".  The pointer to the
    53                          ; description of the string argument is stored on the stack underneath the
    54                          ; value of the integer argument.
    55                          
    56  2d31 20584e             l18_2           jsr     chkopn                          ; check for an open parenthesis
    57  2d34 20ef4c                             jsr     frmevl                          ; eat open paren and first argument
    58  2d37 205b4e                             jsr     chkcom                          ; two args so comma must delimit
    59  2d3a 20dd4c                             jsr     chkstr                          ; make sure first was string
    60                          
    61  2d3d 68                                 pla                                     ; check token
    62  2d3e c9d3                               cmp     #instr_token-1                  ; special case: INSTR() bails out here
    63  2d40 f32b41                             +lbeq   instr
    64  2d43 a667                               ldx     facmo+1                         ; push address of string arg1
    65  2d45 da                                 phx
    66  2d46 a666                               ldx     facmo
    67  2d48 da                                 phx
    68  2d49 48                                 pha                                     ; push token
    69  2d4a 206c5d                             jsr     getbyt                          ; get arg2
    70  2d4d 68                                 pla                                     ; retrieve token
    71  2d4e da                                 phx                                     ; push value of arg2
    72  2d4f 8004                               bra     fingo                           ; go set up to evaluate fn
    73                          
    74                          
    75                          
    76                          oknorm
    77  2d51 204f4e                             jsr     parchk                          ; check for open parens, evaluate argument
    78  2d54 68                                 pla                                     ; restore token
    79                          
    80                          fingo
    81  2d55 38                                 sec                                     ; convert token to index into jump table
    82  2d56 e9b4                               sbc     #first_function_token
    83  2d58 0a                                 asl
    84  2d59 a8                                 tay
    85  2d5a b9f728                             lda     fundsp+1,y
    86  2d5d 8558                               sta     jmper+2
    87  2d5f b9f628                             lda     fundsp,y
    88  2d62 8557                               sta     jmper+1
    89  2d64 205600                             jsr     jmper                           ; dispatch
    90                          ;string functions remove this ret addr
    91  2d67 83721f                             +lbra   chknum                          ; check for "numeric-ness" and return
    92                          
    93                          
    94                          ; Escape Function handler
    95                          
    96                          do_esc_fn
    97  2d6a 208322                             jsr     chrget                          ; get second token
    98  2d6d f3db00                             +lbeq   snerr                           ; error if no second token
    99  2d70 c90a                               cmp     #pointer_token
   100  2d72 f00b                               beq     l19_1                           ; skip pre-parse if 'POINTER()'
   101  2d74 48                                 pha
   102  2d75 208322                             jsr     chrget                          ; should be '('
   103  2d78 20584e                             jsr     chkopn
   104  2d7b 20ef4c                             jsr     frmevl                          ; evaluate first argument
   105  2d7e 68                                 pla
   106  2d7f c902               l19_1           cmp     #first_esc_function_token       ; see if this esc fn is one of ours
   107  2d81 9008                               bcc     foreign_esc_fn                  ; nope.
   108  2d83 c90e                               cmp     #last_esc_function_token+1
   109  2d85 b004                               bcs     foreign_esc_fn                  ; nope
   110                          
   111                          ; Convert to index into the function dispatch table
   112                          
   113  2d87 69d1                               adc     #last_function_token-first_esc_function_token-1
   114  2d89 80ca                               bra     fingo                           ; always
   115                          
   116                          
   117                          foreign_esc_fn
   118  2d8b 38                                 sec                                     ; flag 'up for grabs'
   119  2d8c 20952d                             jsr     go_foreign_esc_fn
   120                          n_esc_fn_vec
   121  2d8f b3b900                             +lbcs   snerr                           ; it's unwanted. off to the refuse pile
   122  2d92 83471f                             +lbra   chknum
   123                          
   124                          go_foreign_esc_fn
   125  2d95 6cfc02                             jmp     (esc_fn_vec)
   126                          
   127                          
   128  2d98 a0ff               orop            ldy     #255                            ; must always complement
   129  2d9a 2c                                 !text $2c
   130                          
   131  2d9b a000               andop           ldy     #0
   132  2d9d 840d                               sty     count                           ; operator
   133  2d9f 20b458                             jsr     ayint                           ; (facmo&lo)=int value and check size
   134  2da2 a566                               lda     facmo                           ; use Demorgan's Law on high
   135  2da4 450d                               eor     count
   136  2da6 850a                               sta     integr
   137  2da8 a567                               lda     faclo                           ; and low
   138  2daa 450d                               eor     count
   139  2dac 850b                               sta     integr+1
   140  2dae 209362                             jsr     movfa
   141  2db1 20b458                             jsr     ayint                           ; (facmo&lo)=int of arg
   142  2db4 a567                               lda     faclo
   143  2db6 450d                               eor     count
   144  2db8 250b                               and     integr+1
   145  2dba 450d                               eor     count                           ; finish out Demorgan
   146  2dbc a8                                 tay                                     ; save high
   147  2dbd a566                               lda     facmo
   148  2dbf 450d                               eor     count
   149  2dc1 250a                               and     integr
   150  2dc3 450d                               eor     count
   151  2dc5 837820                             +lbra   givayf                          ; float (a,y) and return to user
   152                          
   153                          
   154                          
   155                          ; ********************************************************************************************
   156                          ;
   157                          ;	Date		Changes
   158                          ;	====		=======
   159                          ;
   160                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: operator/relational.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      relational.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; Time to perform a relational operator.
    14                          ; (domask) contains the bits as to which relational operator it was.
    15                          ; Carry bit on = string compare.
    16                          
    17                          
    18  2dc8 20de4c             dorel           jsr     chkval                          ; check for match
    19  2dcb b012                               bcs     strcmp                          ; is it a string?
    20  2dcd a56f                               lda     argsgn                          ; pack argument for fcomp
    21  2dcf 097f                               ora     #$7f
    22  2dd1 256b                               and     argho
    23  2dd3 856b                               sta     argho
    24  2dd5 a96a                               lda     #<argexp
    25  2dd7 a000                               ldy     #>argexp
    26  2dd9 20f162                             jsr     fcomp
    27  2ddc aa                                 tax
    28  2ddd 8033                               bra     qcomp
    29                          
    30                          
    31  2ddf a900               strcmp          lda     #0
    32  2de1 850f                               sta     valtyp
    33  2de3 c64f                               dec     opmask
    34  2de5 206d5b                             jsr     frefac                          ; free the faclo string
    35  2de8 8563                               sta     dsctmp                          ; save it for later
    36  2dea 8664                               stx     dsctmp+1
    37  2dec 8465                               sty     dsctmp+2
    38  2dee a56d                               lda     argmo                           ; get pointer to other string
    39  2df0 a46e                               ldy     argmo+1
    40  2df2 20715b                             jsr     fretmp                          ; frees first desc pointer
    41  2df5 866d                               stx     argmo
    42  2df7 846e                               sty     argmo+1
    43  2df9 aa                                 tax                                     ; copy count into x
    44  2dfa 38                                 sec
    45  2dfb e563                               sbc     dsctmp                          ; which is greater. if 0, all set up
    46  2dfd f008                               beq     stasgn                          ; just put sign of difference away
    47  2dff a901                               lda     #1
    48  2e01 9004                               bcc     stasgn                          ; sign is positive
    49  2e03 a663                               ldx     dsctmp                          ; length of fac is shorter
    50  2e05 a9ff                               lda     #$ff                            ; get a minus one for negatives
    51  2e07 8568               stasgn          sta     facsgn                          ; keep for later
    52  2e09 a0ff                               ldy     #255                            ; set pointer to first string. (arg)
    53  2e0b e8                                 inx                                     ; to loop properly
    54  2e0c c8                 nxtcmp          iny
    55  2e0d ca                                 dex                                     ; any characters left to compare?
    56  2e0e d007                               bne     getcmp                          ; not done yet
    57  2e10 a668                               ldx     facsgn                          ; use sign of length difference
    58                          ;since all characters are the same
    59  2e12 301b               qcomp           bmi     docmp                           ; c is always set then
    60  2e14 18                                 clc
    61  2e15 8018                               bra     docmp                           ; always branch
    62                          
    63                          
    64  2e17 a96d               getcmp          lda     #argmo
    65  2e19 20d722                             jsr     lda_far_ram1                    ; lda (argmo),y from RAM1
    66  2e1c 48                                 pha
    67  2e1d a964                               lda     #dsctmp+1
    68  2e1f 20d722                             jsr     lda_far_ram1                    ; lda (dsctmp+1),y from RAM1
    69  2e22 8578                               sta     syntmp
    70  2e24 68                                 pla
    71  2e25 c578                               cmp     syntmp
    72  2e27 f0e3                               beq     nxtcmp
    73  2e29 a2ff                               ldx     #$ff
    74  2e2b b002                               bcs     docmp
    75  2e2d a201                               ldx     #1
    76                          
    77                          
    78                          
    79                          docmp
    80  2e2f e8                                 inx                                     ; -1 to 1, 0 to 2, 1 to 4
    81  2e30 8a                                 txa
    82  2e31 2a                                 rol
    83  2e32 2514                               and     domask
    84  2e34 f002                               beq     l20_1
    85  2e36 a9ff                               lda     #$ff                            ; map 0 to 0, map all others to -1
    86  2e38 839834             l20_1           +lbra   float                           ; float the one-byte result into FAC
    87                          
    88                          
    89                          ;.end
    90                          
    91                          
    92                          ; ********************************************************************************************
    93                          ;
    94                          ;	Date		Changes
    95                          ;	====		=======
    96                          ;
    97                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/readyerror.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      readyerror.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          bad_command
    15  2e3b a228                               ldx     #err_bad_command                ; unimplemented command
    16  2e3d 2c                                 !text $2c
    17                          
    18  2e3e a211               userr           ldx     #errus                          ; undefined statement
    19  2e40 2c                                 !text $2c
    20                          
    21  2e41 a210               omerr           ldx     #errom                          ; out of memory
    22  2e43 2c                                 !text $2c
    23                          
    24  2e44 a214               doverr          ldx     #errdvo                         ; division by zero
    25  2e46 2c                                 !text $2c
    26                          
    27  2e47 a20f               overr           ldx     #errov                          ; overflow
    28  2e49 2c                                 !text $2c
    29                          
    30  2e4a a20b               snerr           ldx     #errsn                          ; syntax error
    31  2e4c 2c                                 !text $2c
    32                          
    33  2e4d a280               ready           ldx     #$80                            ; no error
    34                          
    35  2e4f 6c0003             error           jmp     (ierror)
    36                          
    37  2e52 8a                 nerror          txa
    38  2e53 338f00                             +lbmi   ready_1                         ; ...branch if no error (from 'ready')
    39  2e56 8ec702                             stx     errnum                          ; save error # for 'er'
    40  2e59 7f7e3c                             bbr7    runmod,errisd                   ; branch if direct mode- always display error
    41                          
    42  2e5c a001                               ldy     #1                              ; copy curlin to errlin, oldtxt to errtxt
    43  2e5e b93b00             l21_1           lda     curlin,y
    44  2e61 99c802                             sta     errlin,y                        ; line# where error occurred
    45  2e64 b97211                             lda     oldtxt,y
    46  2e67 99cd02                             sta     errtxt,y                        ; statement where error occured
    47  2e6a 88                                 dey
    48  2e6b 10f1                               bpl     l21_1
    49  2e6d eecd02                             inc     errtxt                          ; point to a token, not ':' for HELP
    50  2e70 d003                               bne     l21_2
    51  2e72 eece02                             inc     errtxt+1
    52                          
    53  2e75 accb02             l21_2           ldy     trapno+1                        ; is trap set?
    54  2e78 c0ff                               cpy     #$ff
    55  2e7a f01c                               beq     errisd                          ; no
    56  2e7c 8417                               sty     linnum+1
    57  2e7e 8ccc02                             sty     tmptrp                          ; save until a resume is executed
    58  2e81 acca02                             ldy     trapno
    59  2e84 8416                               sty     linnum
    60                          
    61  2e86 a2ff                               ldx     #$ff
    62  2e88 8ecb02                             stx     trapno+1                        ; flag no more traps
    63  2e8b a21b                               ldx     #tempst                         ; clear any accumulated string temps
    64  2e8d 8618                               stx     temppt
    65  2e8f a681                               ldx     oldstk
    66  2e91 9a                                 txs
    67  2e92 201f3d                             jsr     luk4it
    68  2e95 8376fd                             +lbra   newstt
    69                          
    70                          
    71                          
    72                          ; ********************************************************************************************
    73                          ;
    74                          ;	Date		Changes
    75                          ;	====		=======
    76                          ;
    77                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: error/handler.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      handler.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12  2e98 ca                 errisd          dex
    13  2e99 8a                                 txa
    14  2e9a 20a92b                             jsr     erstup                          ; set up address of error msg in .a in index2
    15                          
    16  2e9d ff7e08                             bbs7    runmod,l22_1                    ; reset error line if direct mode error
    17  2ea0 a9ff                               lda     #$ff
    18  2ea2 8dc802                             sta     errlin                          ;
    19  2ea5 8dc902                             sta     errlin+1
    20                          
    21  2ea8 20b438             l22_1           jsr     release_channels                ; restore output to screen    [910909]
    22  2eab 2027af                             jsr     RestoreTextScreen               ; make sure we're in text mode    [910404]
    23  2eae 200935                             jsr     init_stack
    24                          
    25  2eb1 20f737             l22_2           jsr     crdo                            ; Print error message- start a new line with '?'
    26  2eb4 20dc3c                             jsr     highlight_text                  ; use highlight color????    [910624]
    27  2eb7 206238                             jsr     outqst
    28  2eba a000                               ldy     #0
    29  2ebc b126               l22_3           lda     (index2),y                      ; Read error msg from ROM  (ind.ok????)
    30  2ebe 48                                 pha
    31  2ebf 297f                               and     #$7f
    32  2ec1 203d68                             jsr     outch                           ; Print it
    33  2ec4 c8                                 iny
    34  2ec5 68                                 pla
    35  2ec6 10f4                               bpl     l22_3
    36  2ec8 aec702                             ldx     errnum                          ; retrieve error #     [910925]
    37  2ecb e01e                               cpx     #erbrk
    38  2ecd f00a                               beq     errfin                          ; skip 'error' crap if 'break'
    39  2ecf 207dff                             jsr     _primm
    40  2ed2 204552524f5200                     !text " ERROR",0
    41                          
    42  2ed9 a43c               errfin          ldy     curlin+1                        ; direct mode?
    43  2edb c8                                 iny
    44  2edc f003                               beq     l23_1                           ; yes...no line #
    45  2ede 207364                             jsr     inprt
    46  2ee1 20cb3c             l23_1           jsr     highlight_done                  ; restore normal text color????    [910624]
    47                          
    48                          
    49                          ; ********************************************************************************************
    50                          ;
    51                          ;	Date		Changes
    52                          ;	====		=======
    53                          ;
    54                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/interface.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      interface.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ready_1
    15  2ee4 a980                               lda     #%10000000
    16  2ee6 2090ff                             jsr     _setmsg                         ; turn Kernel messages on
    17  2ee9 a9c0                               lda     #%11000000
    18  2eeb 147e                               trb     runmod                          ; turn run modes off, leave trace mode on????
    19                          
    20                          ready_2
    21  2eed cf7e0e                             bbs4    runmod,l24_1                    ; print appropriate system prompt
    22  2ef0 207dff                             jsr     _primm                          ; Program mode: print 'ready.'
    23  2ef3 0d52454144592e0d...                !text cr,"READY.",cr,0
    24  2efc 8009                               bra     main
    25                          
    26  2efe 207dff             l24_1           jsr     _primm                          ; Edit mode: print 'ok.'
    27  2f01 0d4f4b2e0d00                       !text cr,"OK.",cr,0
    28                          
    29                          
    30  2f07 6c0203             main            jmp     (imain)                         ; MAIN INPUT LOOP
    31                          
    32  2f0a a2ff               nmain           ldx     #$ff                            ; set direct mode flag
    33  2f0c 863c                               stx     curlin+1
    34  2f0e 201c31                             jsr     InputLine                       ; get a line of input & buffer it
    35                          
    36                          
    37                          ; ********************************************************************************************
    38                          ;
    39                          ;	Date		Changes
    40                          ;	====		=======
    41                          ;
    42                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/execute.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      execute.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          execute_a_line                                          ; EXECUTE PLAIN TEXT IN BUFFER
    14  2f11 863d                               stx     txtptr                          ; init buffer pointer
    15  2f13 843e                               sty     txtptr+1
    16  2f15 208322                             jsr     chrget                          ; get first character of null-terminated string
    17  2f18 aa                                 tax
    18  2f19 f0ec                               beq     main                            ; got null input
    19  2f1b 9009                               bcc     l25_1                           ; got line number
    20  2f1d 201f23                             jsr     crunch                          ; got text- tokenize buffer,
    21  2f20 208522                             jsr     chrgot                          ; get first command (token),
    22  2f23 83e5fc                             +lbra   xeqdir                          ; and execute it
    23                          
    24                          
    25                          ;ADD or DELETE NEW LINE
    26  2f26 202e32             l25_1           jsr     linget                          ; evaluate line number, put into into linnum
    27  2f29 4f7e05                             bbr4    runmod,l25_2
    28  2f2c 20e1bc                             jsr     edit_crunch                     ; if edit mode, find end of input   [910620]
    29  2f2f 8003                               bra     l25_3
    30                          
    31  2f31 201f23             l25_2           jsr     crunch                          ; tokenize rest of input if not edit mode
    32  2f34 840d               l25_3           sty     count                           ; save length
    33  2f36 20fa31                             jsr     FindLine                        ; locate line in program
    34  2f39 938300                             +lbcc   nodel                           ; not found, go insert line into program
    35                          ; else delete current line and insert this one
    36                          
    37                          ; ********************************************************************************************
    38                          ;
    39                          ;	Date		Changes
    40                          ;	====		=======
    41                          ;
    42                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: edit/shift.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      shift.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; Test: IF new line is longer than the line it replaces,
    14                          ;  THEN IF there isn't enough room in memory to add this new line,
    15                          ;   THEN out-of-memory error
    16                          ;
    17                          ; Before this fix, the old line was deleted BEFORE testing if the new line fit.
    18                          ;
    19                          ; N.B.: I am assuming that lines cannot be greater than 255 chars, as is the
    20                          ; case where the line was entered "normally", that is, using LINGET.  The only
    21                          ; consequence of this assumption is that lines > 255 will fall prey to the
    22                          ; pre-fix problem mentioned above.
    23                          
    24  2f3c a000                               ldy     #0
    25  2f3e 20ad22                             jsr     indlow                          ; get lsb of the next line's starting address
    26  2f41 38                                 sec
    27  2f42 e561                               sbc     lowtr                           ; subtract lsb of this line's starting address
    28  2f44 38                                 sec                                     ; ignore borrow (gives abs. value)
    29  2f45 e904                               sbc     #4                              ; allow for link & line number
    30  2f47 e50d                               sbc     count                           ; compare with new length
    31  2f49 b016                               bcs     l25_5                           ; new line is shorter, no problem
    32  2f4b 42                                 neg                                     ; convert to positive delta
    33                          
    34  2f4c a483                               ldy     text_top+1                      ; get msb of end of text (.c=0)
    35  2f4e 6582                               adc     text_top                        ; add our calculated delta to end of text
    36  2f50 9001                               bcc     l25_4
    37  2f52 c8                                 iny
    38  2f53 ccd002             l25_4           cpy     max_mem_0+1
    39  2f56 9009                               bcc     l25_5                           ; result is less than top-of-memory: ok
    40  2f58 d3e7fe                             +lbne   omerr                           ; msb >  top, overflow
    41  2f5b cdcf02                             cmp     max_mem_0                       ; msb's the same, test lsb's
    42  2f5e b3e1fe                             +lbcs   omerr                           ; lsb >= top, overflow
    43                          
    44                          ; Using DMA device to move text downwards (to delete or replace a line)...
    45                          ;
    46                          ; lowtr     = destination
    47                          ; (lowtr)    = pointer to source (via link bytes of line to be removed)
    48                          ; text_top-(lowtr) = number of bytes to move (text_top points to old top of text)
    49                          ; new text_top     = text_top -( (lowtr)-lowtr )
    50                          
    51  2f61 a561               l25_5           lda     lowtr                           ; set up DMA destination
    52  2f63 8d4a01                             sta     dma1_dest_lo
    53  2f66 a562                               lda     lowtr+1
    54  2f68 8d4b01                             sta     dma1_dest_hi
    55  2f6b a000                               ldy     #0
    56  2f6d 20ad22                             jsr     indlow                          ; set up DMA source (& delta)
    57  2f70 8d4701                             sta     dma1_src_lo
    58  2f73 38                                 sec
    59  2f74 e561                               sbc     lowtr
    60  2f76 8524                               sta     index1                          ; (delta lo)
    61  2f78 c8                                 iny
    62  2f79 20ad22                             jsr     indlow
    63  2f7c 8d4801                             sta     dma1_src_hi
    64  2f7f e562                               sbc     lowtr+1
    65  2f81 8525                               sta     index1+1                        ; (delta hi)
    66  2f83 38                                 sec
    67  2f84 a582                               lda     text_top                        ; set up DMA count
    68  2f86 ed4701                             sbc     dma1_src_lo
    69  2f89 8d4501                             sta     dma1_cnt_lo
    70  2f8c a583                               lda     text_top+1
    71  2f8e ed4801                             sbc     dma1_src_hi
    72  2f91 8d4601                             sta     dma1_cnt_hi
    73                          
    74  2f94 a584                               lda     text_bank
    75                          ; and #%00001111  ;      [910102]
    76                          ; and #%01111111  ;      [910520] F018A
    77  2f96 8d4901                             sta     dma1_src_bank
    78  2f99 8d4c01                             sta     dma1_dest_bank
    79                          
    80  2f9c a900                               lda     #0
    81  2f9e 8d4401                             sta     dma1_cmd                        ; dma command (copy, source=start)
    82  2fa1 8d4d01                             sta     dma1_subcmd                     ; [910520] F018A
    83  2fa4 8d02d7                             sta     dma_ctlr+2                      ; dma_list bank
    84                          
    85  2fa7 a201                               ldx     #>dma1_cmd                      ; dma_list
    86  2fa9 a944                               lda     #<dma1_cmd
    87  2fab 8e01d7                             stx     dma_ctlr+1                      ; dma_list hi
    88  2fae 8d00d7                             sta     dma_ctlr                        ; dma_list lo & trigger
    89                          
    90  2fb1 38                                 sec                                     ; calculate & set new text_top
    91  2fb2 a582                               lda     text_top
    92  2fb4 e524                               sbc     index1
    93  2fb6 8582                               sta     text_top                        ; lo
    94  2fb8 a583                               lda     text_top+1
    95  2fba e525                               sbc     index1+1
    96  2fbc 8583                               sta     text_top+1                      ; hi
    97                          ;fall into routine to insert new line (if any)
    98                          
    99                          
   100  2fbe 200935             nodel           jsr     init_stack                      ; 'clearc' removed since text changes don't require trashing variables
   101  2fc1 20b930                             jsr     link_program                    ; fix links
   102  2fc4 20dc44                             jsr     error_clear                     ; clear HELP/error flag, assuming he fixed whatever caused current error, if any
   103                          
   104  2fc7 a000                               ldy     #0
   105  2fc9 b13d                               lda     (txtptr),y                      ; delete line? ("common")
   106  2fcb f33aff                             +lbeq   main                            ; yes
   107                          
   108  2fce 18                 l26_1           clc                                     ; no...something to insert
   109  2fcf a483                               ldy     text_top+1
   110  2fd1 a582                               lda     text_top
   111  2fd3 845d                               sty     hightr+1                        ; top of block to move (old text_top)
   112  2fd5 855c                               sta     hightr
   113  2fd7 650d                               adc     count                           ; number of characters in line to be inserted
   114  2fd9 9001                               bcc     l26_2
   115  2fdb c8                                 iny
   116  2fdc 18                 l26_2           clc
   117  2fdd 6904                               adc     #4                              ; plus link and line #
   118  2fdf 9001                               bcc     l26_3                           ; gives us destination of move (new text_top)
   119  2fe1 c8                                 iny
   120                          
   121  2fe2 855a               l26_3           sta     highds                          ; destination of top
   122  2fe4 845b                               sty     highds+1
   123  2fe6 ccd002                             cpy     max_mem_0+1                     ; make sure new top doesn't crash into top of available ram
   124  2fe9 9009                               bcc     l26_4                           ; ok
   125  2feb d354fe                             +lbne   omerr                           ; out of memory, don't insert
   126  2fee cdcf02                             cmp     max_mem_0
   127  2ff1 b34efe                             +lbcs   omerr                           ; out of memory, don't insert
   128                          
   129  2ff4 8582               l26_4           sta     text_top                        ; set new top of text
   130  2ff6 8483                               sty     text_top+1
   131  2ff8 38                                 sec                                     ; compute number of things to move up
   132  2ff9 a55c                               lda     hightr
   133  2ffb e561                               sbc     lowtr                           ; (old top) - (adr where new line goes)
   134  2ffd a8                                 tay                                     ; lowtr was setup previously by FindLine call
   135  2ffe a55d                               lda     hightr+1
   136  3000 e562                               sbc     lowtr+1
   137  3002 aa                                 tax
   138                          
   139                          ; Using DMA device to copy data upwards...
   140                          ;
   141                          ; (hightr)   = source  (old top)
   142                          ; (highds)   = destination (new top)
   143                          ; .y, .x     = number of bytes to move
   144                          ; (lowtr)    = where to insert new line (starting with link bytes)
   145                          
   146  3003 c35c                               dew     hightr                          ; (text_top-1) points to actual last byte
   147  3005 c35a                               dew     highds
   148                          
   149                          ; lda dma_ctlr+3  ;dma controller version    [910520] F018A
   150                          ; and #1
   151                          ; beq l26_5   ; F018    removed [910808] F018B
   152  3007 a930                               lda     #%00110000                      ; F018A, B
   153  3009 8d4401             l26_5           sta     dma1_cmd                        ; command=copy, source=endpt   [910102]
   154  300c 8c4501                             sty     dma1_cnt_lo                     ; count
   155  300f 8e4601                             stx     dma1_cnt_hi
   156  3012 98                                 tya
   157  3013 0d4601                             ora     dma1_cnt_hi
   158  3016 f02e                               beq     l26_7                           ; special case= nothing to move???? should not happen
   159                          
   160  3018 a55c                               lda     hightr
   161  301a a45d                               ldy     hightr+1
   162  301c 8d4701                             sta     dma1_src_lo                     ; source
   163  301f 8c4801                             sty     dma1_src_hi
   164  3022 a55a                               lda     highds
   165  3024 a45b                               ldy     highds+1
   166  3026 8d4a01                             sta     dma1_dest_lo                    ; destination
   167  3029 8c4b01                             sty     dma1_dest_hi
   168  302c a584                               lda     text_bank                       ; [910520] F018A
   169                          ; ldx dma1_cmd  ;version?    removed [910808] F018B
   170                          ; bne l26_6   ; F018A
   171                          ; and #%00001111  ;      [910102]
   172                          ; ora #%01000000  ;(copy source=endpoint)    [910102]
   173  302e 8d4901             l26_6           sta     dma1_src_bank                   ; banks
   174  3031 8d4c01                             sta     dma1_dest_bank
   175  3034 a900                               lda     #0
   176  3036 8d4d01                             sta     dma1_subcmd                     ; [910520] F018A
   177  3039 8d02d7                             sta     dma_ctlr+2                      ; dma_list bank
   178  303c a201                               ldx     #>dma1_cmd                      ; dma_list
   179  303e a944                               lda     #<dma1_cmd
   180  3040 8e01d7                             stx     dma_ctlr+1                      ; dma_list hi
   181  3043 8d00d7                             sta     dma_ctlr                        ; dma_list lo & trigger
   182                          
   183                          ; Make links non-null to fool 'chead'
   184                          
   185  3046 a000               l26_7           ldy     #0
   186  3048 a901                               lda     #1
   187  304a a261                               ldx     #lowtr
   188  304c 200c23                             jsr     sta_far_ram0                    ; sta (lowtr),y  y=0 (bleed-thru)
   189  304f c8                                 iny
   190  3050 200c23                             jsr     sta_far_ram0                    ; sta (lowtr),y  y=1 (bleed-thru)
   191                          
   192                          ; Put line number in text
   193                          
   194  3053 c8                                 iny
   195  3054 a516                               lda     linnum
   196  3056 200c23                             jsr     sta_far_ram0                    ; sta (lowtr),y  y=2 (bleed-thru)
   197  3059 c8                                 iny
   198  305a a517                               lda     linnum+1
   199  305c 200c23                             jsr     sta_far_ram0                    ; sta (lowtr),y  y=3 (bleed-thru)
   200                          
   201                          ; Advance 'lowtr' to start of line (past link bytes & line #)
   202                          
   203  305f 18                                 clc
   204  3060 a561                               lda     lowtr
   205  3062 6904                               adc     #4
   206  3064 8561                               sta     lowtr
   207  3066 9002                               bcc     l26_8
   208  3068 e662                               inc     lowtr+1
   209                          
   210                          
   211                          ; Block move line to text
   212                          
   213  306a a40d               l26_8           ldy     count                           ; use dma ???? [910925]
   214  306c 88                                 dey
   215                          
   216  306d b13d               l26_9           lda     (txtptr),y                      ; (from common area)
   217  306f 200c23                             jsr     sta_far_ram0                    ; sta (lowtr),y   (bleed-thru)
   218  3072 88                                 dey
   219  3073 c0ff                               cpy     #$ff
   220  3075 d0f6                               bne     l26_9
   221                          
   222                          ; beq l26_9   ;special case= nothing to move???? should not happen
   223                          ; lda #0   ; F018A, B
   224                          ; sta dma1_cmd  ;command=copy, source=start
   225                          ; sty dma1_cnt_lo  ;count
   226                          ; sta dma1_cnt_hi
   227                          ;
   228                          ; lda txtptr
   229                          ; ldy txtptr+1
   230                          ; sta dma1_src_lo  ;source
   231                          ; sty dma1_src_hi
   232                          ; lda lowtr
   233                          ; ldy lowtr+1
   234                          ; sta dma1_dest_lo ;destination
   235                          ; sty dma1_dest_hi
   236                          ; lda text_bank  ;banks
   237                          ; sta dma1_dest_bank
   238                          ; lda #sys_bank  ;????
   239                          ; sta dma1_src_bank
   240                          ; sta dma1_subcmd  ;      [910520] F018A
   241                          ; sta dma_ctlr+2  ;dma_list bank
   242                          ; ldx #>dma1_cmd  ;dma_list
   243                          ; lda #<dma1_cmd
   244                          ; stx dma_ctlr+1  ;dma_list hi
   245                          ; sta dma_ctlr  ;dma_list lo & trigger
   246                          ;l26_9
   247  3077 20b930                             jsr     link_program
   248  307a 201f35                             jsr     reset_txtptr                    ; set up txtptr (was jsr runc)
   249                          
   250                          ; Test if AUTO in effect
   251                          
   252  307d a574                               lda     autinc                          ; if in auto mode, increment val <> 0
   253  307f 0575                               ora     autinc+1
   254  3081 f033                               beq     l26_12                          ; not in
   255                          
   256  3083 a516                               lda     linnum                          ; yes, construct new line number
   257  3085 18                                 clc
   258  3086 6574                               adc     autinc
   259  3088 8565                               sta     facho+1
   260  308a a517                               lda     linnum+1
   261  308c 6575                               adc     autinc+1
   262  308e b026                               bcs     l26_12                          ; no auto if wrapped
   263  3090 c9fa                               cmp     #$fa                            ; test if # >= 64000
   264  3092 b022                               bcs     l26_12                          ; no auto if so.
   265  3094 8564                               sta     facho
   266  3096 a290                               ldx     #$90
   267  3098 38                                 sec
   268  3099 20df62                             jsr     floatc                          ; float it
   269  309c 208f64                             jsr     fout                            ; make it into a string
   270                          
   271  309f 78                                 sei                                     ; [910710]
   272  30a0 a200                               ldx     #0                              ; move string into kbd buffer
   273  30a2 bd0101             l26_10          lda     fbuffr+1,x                      ; copy number formed into buffer, ignoring leading space
   274  30a5 f006                               beq     l26_11                          ; a null marks end
   275  30a7 9db002                             sta     _keyd,x
   276  30aa e8                                 inx
   277  30ab d0f5                               bne     l26_10                          ; always
   278                          
   279  30ad a91d               l26_11          lda     #29                             ; cursor right
   280  30af 9db002                             sta     _keyd,x
   281  30b2 e8                                 inx
   282  30b3 86d0                               stx     _ndx
   283  30b5 58                                 cli                                     ; [910710]
   284                          
   285  30b6 834ffe             l26_12          +lbra   main
   286                          
   287                          
   288                          ; ********************************************************************************************
   289                          ;
   290                          ;	Date		Changes
   291                          ;	====		=======
   292                          ;
   293                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/linkprogram.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      linkprogram.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          link_program
    15  30b9 a52d                               lda     txttab
    16  30bb a42e                               ldy     txttab+1
    17  30bd 8524                               sta     index
    18  30bf 8425                               sty     index+1
    19  30c1 18                                 clc
    20                          
    21  30c2 a000               chead           ldy     #0
    22  30c4 20c122                             jsr     indin1                          ; lda (index),y .. check for null link
    23  30c7 d006                               bne     l27_1
    24  30c9 c8                                 iny
    25  30ca 20c122                             jsr     indin1                          ; lda (index),y
    26  30cd f042                               beq     lnkrts
    27                          
    28  30cf a003               l27_1           ldy     #3                              ; [900524]
    29  30d1 c8                 l27_2           iny                                     ; ???? very expensive loop ????
    30  30d2 c0fe                               cpy     #254
    31  30d4 b01f                               bcs     link_error                      ; failsafe- program is mangled  [910103]
    32  30d6 20c122                             jsr     indin1                          ; lda (index),y
    33  30d9 d0f6                               bne     l27_2
    34  30db c8                                 iny
    35  30dc 98                                 tya
    36  30dd 6524                               adc     index
    37  30df 48                                 pha
    38  30e0 a000                               ldy     #0
    39  30e2 a224                               ldx     #index
    40  30e4 200c23                             jsr     sta_far_ram0                    ; sta (index),y   (bleed-thru)
    41  30e7 98                                 tya
    42  30e8 6525                               adc     index+1
    43  30ea c8                                 iny
    44  30eb 200c23                             jsr     sta_far_ram0                    ; sta (index),y   (bleed-thru)
    45  30ee fa                                 plx
    46  30ef 8624                               stx     index
    47  30f1 8525                               sta     index+1
    48  30f3 80cd                               bra     chead                           ; always
    49                          
    50                          
    51                          link_error                                              ; [910103]
    52  30f5 20dc3c                             jsr     highlight_text                  ; [911119]
    53  30f8 207dff                             jsr     _primm
    54  30fb 0d3f50524f475241...                !text cr,"?PROGRAM MANGLED",cr,0
    55  310e 20cb3c                             jsr     highlight_done                  ; [911119]
    56                          
    57                          
    58  3111 60                 lnkrts          rts
    59                          
    60                          
    61                          ; ********************************************************************************************
    62                          ;
    63                          ;	Date		Changes
    64                          ;	====		=======
    65                          ;
    66                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/input/handler.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      handler.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ; Function to get a line one character at a time from the input
    15                          ; channel and build it in the input buffer.
    16                          ;
    17                          
    18                          PromptedInput                                           ; qinlin.
    19  3112 a515                               lda     channl                          ; entry for things line INPUT, wanting a prompt
    20  3114 d006                               bne     InputLine                       ; prompt only if terminal
    21  3116 206238                             jsr     outqst                          ; yes- print '? '
    22  3119 205f38                             jsr     realsp
    23                          
    24                          
    25                          InputLine                                               ; inlin.
    26  311c a200                               ldx     #0                              ; read & buffer data until 'return' or buffer full
    27  311e 204368             l28_1           jsr     inchr                           ; get a character
    28  3121 c900                               cmp     #0
    29  3123 f00f                               beq     l28_2
    30  3125 c90d                               cmp     #cr                             ; a carriage return?
    31  3127 f00b                               beq     l28_2                           ; yes...done build
    32                          
    33  3129 9d0002                             sta     buf,x                           ; no...buffer it
    34  312c e8                                 inx
    35  312d e0a1                               cpx     #buflen                         ; buffer full?
    36  312f 90ed                               bcc     l28_1                           ; no...continue
    37  3131 833d45                             +lbra   errlen                          ; yes...string too long error
    38                          
    39                          
    40  3134 a900               l28_2           lda     #0                              ; fininl.  terminate input with a null
    41  3136 9d0002                             sta     buf,x
    42  3139 a2ff                               ldx     #<buf_txtptr                    ; set up pointer to start of buffer-1 (for chrget)
    43  313b a001                               ldy     #>buf_txtptr
    44  313d a515                               lda     channl                          ; print 'return' only if terminal
    45  313f f3b606                             +lbeq   crdo
    46  3142 60                                 rts
    47                          
    48                          ;.end
    49                          
    50                          
    51                          ; ********************************************************************************************
    52                          ;
    53                          ;	Date		Changes
    54                          ;	====		=======
    55                          ;
    56                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/stack.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      stack.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Find a specific token in the run-time stack. token to be found is in srchtk.
    16                          ;
    17                          ; If called by 'for' or 'next', scan entries in stack, looking for a specific
    18                          ; 'for-variable' (in (forpnt)).  If found, (fndpnt) will point to it, and z is
    19                          ; set.  Otherwise, (fndpnt) will point to either:
    20                          ;  1) the non-for token
    21                          ;  2) bottom-of-stack
    22                          ;
    23                          ; Special case: 'next' with no argument will match first 'for' entry on stack
    24                          ; found, if any.  This case is signaled by a (forpnt) with a msb of $ff (an
    25                          ; impossible value).
    26                          ;
    27                          ; All other calls to search will result in either:
    28                          ;  1) (success) z = 1, (fndpnt) = address
    29                          ;  2) (failure) z = 0
    30                          
    31                          
    32                          ; Set up temporary pointer with current top of stack
    33                          
    34  3143 8502               search          sta     srchtk                          ; save token to search for
    35  3145 20dd31                             jsr     movtos                          ; tos => fndpnt
    36                          
    37                          
    38                          ; Test if pointer is at bottom of stack.  If so, the item was not found.
    39                          
    40  3148 a53f               l29_1           lda     fndpnt
    41  314a c9ff                               cmp     #<stkbot
    42  314c d006                               bne     l29_2                           ; (fndpnt) <> bottom, ok
    43  314e a540                               lda     fndpnt+1                        ; lsb's the same, test msb's
    44  3150 c905                               cmp     #>stkbot
    45  3152 f03d                               beq     l29_6                           ; stack empty, rts
    46                          
    47  3154 a000               l29_2           ldy     #0
    48  3156 a502                               lda     srchtk                          ; what are we looking for?
    49  3158 c981                               cmp     #for_token                      ; 'for' tokens are special cases
    50  315a d01b                               bne     l29_4
    51                          
    52                          ; Looking for a 'for' token.  If next token examined is not a 'for' token,
    53                          ; return with z = 0.  Otherwise, check the pointer to its 'for' variable.
    54                          ; If the variable pointer = (forpnt) or if (forpnt) = $FFxx, return with z=1.
    55                          ; Otherwise, set up x with length of a 'for' entry, and use the usual
    56                          ; mechanisim for examining the next entry.
    57                          
    58  315c d13f                               cmp     (fndpnt),y                      ; indirect ok- looking at runtime stack????
    59  315e d033                               bne     l29_7                           ; not 'for', do rts with z = 0
    60  3160 a002                               ldy     #2                              ; point to msb of 'for' variable
    61  3162 a54c                               lda     forpnt+1
    62  3164 c9ff                               cmp     #$ff
    63  3166 f02b                               beq     l29_7                           ; do rts with z = 1
    64  3168 d13f                               cmp     (fndpnt),y
    65  316a d007                               bne     l29_3                           ; not right variable, keep looking.
    66  316c 88                                 dey
    67  316d a54b                               lda     forpnt                          ; test lsb
    68  316f d13f                               cmp     (fndpnt),y
    69  3171 f020                               beq     l29_7                           ; a hit! rts with z = 1
    70                          
    71  3173 a212               l29_3           ldx     #lenfor
    72  3175 800e                               bra     l29_5                           ; keep looking
    73                          
    74  3177 b13f               l29_4           lda     (fndpnt),y
    75  3179 c502                               cmp     srchtk                          ; is this the correct type of entry?
    76  317b f016                               beq     l29_7                           ; rts with z = 1
    77                          
    78                          ; The entry on top of the run-time stack is not the entry we are looking for.
    79                          ; Find out what is there, and advance temp. pointer past it.
    80                          
    81  317d a212                               ldx     #lenfor                         ; is it a 'for' entry?
    82  317f c981                               cmp     #for_token
    83  3181 f002                               beq     l29_5
    84  3183 a205                               ldx     #5                              ; must be gosub or do by default
    85                          
    86  3185 8a                 l29_5           txa
    87  3186 18                                 clc
    88  3187 653f                               adc     fndpnt
    89  3189 853f                               sta     fndpnt
    90  318b 90bb                               bcc     l29_1
    91  318d e640                               inc     fndpnt+1
    92  318f 80b7                               bra     l29_1                           ; always
    93                          
    94  3191 a001               l29_6           ldy     #1                              ; clear z flag
    95  3193 60                 l29_7           rts
    96                          
    97                          
    98                          ; GETSTK
    99                          ;
   100                          ; Add (.A) elements to top of run-time stack.  Error if result exceeds tos.
   101                          
   102  3194 49ff               getstk          eor     #$ff                            ; make value 2's comp.
   103  3196 38                                 sec
   104  3197 657c                               adc     tos
   105  3199 857c                               sta     tos
   106  319b a47d                               ldy     tos+1
   107  319d b001                               bcs     l30_1
   108  319f 88                                 dey
   109  31a0 847d               l30_1           sty     tos+1
   110  31a2 c004                               cpy     #>stktop
   111  31a4 939bfc                             +lbcc   omerr
   112  31a7 d005                               bne     l30_2
   113  31a9 c57c                               cmp     tos
   114  31ab 9394fc                             +lbcc   omerr
   115  31ae 60                 l30_2           rts
   116                          
   117                          
   118                          ; (a,y) is a certain address.  REASON makes sure it is less than (fretop).
   119                          
   120  31af c436               reason          cpy     fretop+1
   121  31b1 9029                               bcc     l31_4
   122  31b3 d004                               bne     l31_1                           ; go garbage collect
   123  31b5 c535                               cmp     fretop
   124  31b7 9023                               bcc     l31_4
   125                          
   126  31b9 48                 l31_1           pha
   127  31ba a209                               ldx     #9                              ; if tempf2 has zero in between
   128  31bc 98                                 tya
   129                          
   130  31bd 48                 l31_2           pha
   131  31be b559                               lda     highds-1,x                      ; save highds on stack
   132  31c0 ca                                 dex
   133  31c1 10fa                               bpl     l31_2                           ; put 8 of them on stack
   134  31c3 20335c                             jsr     garba2                          ; go garbage collect
   135  31c6 a2f7                               ldx     #$f7
   136                          
   137  31c8 68                 l31_3           pla
   138  31c9 9563                               sta     highds+9,x                      ; restore after garbage collect
   139  31cb e8                                 inx
   140  31cc 30fa                               bmi     l31_3
   141  31ce 7a                                 ply
   142  31cf 68                                 pla                                     ; restore .a and .y
   143  31d0 c436                               cpy     fretop+1                        ; compare highs
   144  31d2 9008                               bcc     l31_4
   145  31d4 d36bfc                             +lbne   omerr                           ; higher is bad
   146  31d7 c535                               cmp     fretop                          ; compare the lows
   147  31d9 b366fc                             +lbcs   omerr
   148  31dc 60                 l31_4           rts
   149                          
   150                          
   151                          
   152                          ;  Utilities involved in the operation of the BASIC run-time stack.
   153                          
   154                          
   155                          ; Move top-of-stack pointer to (fndpnt)
   156                          
   157  31dd a57c               movtos          lda     tos
   158  31df 853f                               sta     fndpnt
   159  31e1 a57d                               lda     tos+1
   160  31e3 8540                               sta     fndpnt+1
   161  31e5 60                                 rts
   162                          
   163                          
   164                          
   165                          ; move (fndpnt) to (tos)
   166                          
   167  31e6 a53f               movfnd          lda     fndpnt
   168  31e8 857c                               sta     tos
   169  31ea a540                               lda     fndpnt+1
   170  31ec 857d                               sta     tos+1
   171  31ee 60                                 rts
   172                          
   173                          ; Reduce size of run-time stack by (y).  No error checking performed!
   174                          
   175  31ef 98                 rlsstk          tya
   176  31f0 18                                 clc
   177  31f1 657c                               adc     tos
   178  31f3 857c                               sta     tos
   179  31f5 9002                               bcc     l32_1
   180  31f7 e67d                               inc     tos+1
   181  31f9 60                 l32_1           rts
   182                          
   183                          ;.end
   184                          
   185                          ; ********************************************************************************************
   186                          ;
   187                          ;	Date		Changes
   188                          ;	====		=======
   189                          ;
   190                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/linesearch.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      linesearch.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          
    16                          ; FindLine
    17                          ; Searches the program text for the line whose number is passed in "linnum".
    18                          ; There are two possible returns:
    19                          ;
    20                          ; 1) carry set.
    21                          ;  Line found.  (lowtr) points to the link bytes of line sought.
    22                          ;
    23                          ; 2) carry clear.
    24                          ;  Line not found.  (lowtr) points to the link bytes of the next
    25                          ;  line greater than the one sought.
    26                          
    27                          FindLine
    28  31fa a52d                               lda     txttab                          ; init pointer to beginning of program
    29  31fc a62e                               ldx     txttab+1
    30                          
    31                          FindLink
    32  31fe 8561                               sta     lowtr                           ; current position in program
    33  3200 8662                               stx     lowtr+1
    34  3202 a001                               ldy     #1
    35  3204 20ad22                             jsr     indlow                          ; end of program (null link)?
    36  3207 f023                               beq     l33_3                           ; yes, exit with .c=0 (not found)
    37  3209 c8                                 iny
    38  320a c8                                 iny
    39  320b 20ad22                             jsr     indlow                          ; get line number of this line (high byte first)
    40                          ; sta syntmp
    41                          ; lda linnum+1 ;is this the line we're looking for?
    42                          ; cmp syntmp
    43                          ; bcc l33_4  ; no- too high, so the line does not exist, exit
    44                          ; beq l33_1
    45                          ; dey  ; no- too low, so get link to next line
    46                          ; bra l33_2
    47  320e c517                               cmp     linnum+1                        ; is this the line we're looking for?   [910925]
    48  3210 f005                               beq     l33_1                           ; maybe
    49  3212 b018                               bcs     l33_3                           ; no- too high, so the line does not exist, exit with .c=0
    50  3214 88                                 dey                                     ; no- too low, so get link to next line
    51  3215 800a                               bra     l33_2
    52                          
    53  3217 88                 l33_1           dey                                     ; maybe- have to check low byte
    54  3218 20ad22                             jsr     indlow
    55                          ; sta syntmp
    56                          ; lda linnum
    57                          ; cmp syntmp
    58                          ; bcc l33_4  ; no- too high, exit
    59                          ; beq l33_4  ; yes- got it, exit
    60  321b c516                               cmp     linnum                          ; is this the line we're looking for?   [910925]
    61  321d f00e                               beq     l33_4                           ; yes- got it, exit with .c=1
    62  321f b00b                               bcs     l33_3                           ; no- too high, so the line does not exist, exit with .c=0
    63                          
    64  3221 88                 l33_2           dey                                     ; get link to next line
    65  3222 20ad22                             jsr     indlow
    66  3225 aa                                 tax
    67  3226 88                                 dey
    68  3227 20ad22                             jsr     indlow
    69  322a 80d2                               bra     FindLink                        ; continue looking
    70                          
    71                          
    72  322c 18                 l33_3           clc                                     ; exit, line not found (.c=0)
    73  322d 60                 l33_4           rts                                     ; exit, line found (.c=1)
    74                          
    75                          ;.end
    76                          
    77                          ; ********************************************************************************************
    78                          ;
    79                          ;	Date		Changes
    80                          ;	====		=======
    81                          ;
    82                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/text/get.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      get.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          
    16                          ; LINGET  Reads a line # from the current txtptr position
    17                          ;   and stores it in linnum  (valid range is 0-63999).
    18                          ;
    19                          ;   On exit txtptr is pointing to the terminating char
    20                          ;   which is in .a with condition codes set.
    21                          ;   Endchr will be =0 if no digit input, else >0.  Use it
    22                          ;   to distinguish between line # 0 & null input.
    23                          
    24  322e a200               linget          ldx     #0                              ; enter with CHRGET flags set
    25  3230 860b                               stx     endchr                          ; flags line # input
    26  3232 8616                               stx     linnum                          ; init line # to 0
    27  3234 8617                               stx     linnum+1
    28                          
    29  3236 b04b               l34_1           bcs     l34_5                           ; it's not a digit, do rts
    30  3238 e60b               l34_2           inc     endchr                          ; indicate line # input
    31  323a e92f                               sbc     #$2f                            ; '0'-1 since .c=0
    32  323c 850a                               sta     charac                          ; save for later
    33  323e a517                               lda     linnum+1
    34  3240 8524                               sta     index
    35  3242 c919                               cmp     #25                             ; line number will be < 64000?
    36  3244 9006                               bcc     l34_3                           ; yes, continue
    37  3246 9f553a                             bbs1    helper,l34_5                    ; no, if called by AutoScroll it's okay
    38  3249 83fffb                             +lbra   snerr                           ; else syntax error
    39                          
    40  324c a516               l34_3           lda     linnum
    41  324e 0a                                 asl                                     ; multiply by 10
    42  324f 2624                               rol     index
    43  3251 0a                                 asl
    44  3252 2624                               rol     index
    45  3254 6516                               adc     linnum
    46  3256 8516                               sta     linnum
    47  3258 a524                               lda     index
    48  325a 6517                               adc     linnum+1
    49  325c 8517                               sta     linnum+1
    50  325e 0616                               asl     linnum
    51  3260 2617                               rol     linnum+1
    52  3262 a516                               lda     linnum
    53  3264 650a                               adc     charac                          ; add in digit
    54  3266 8516                               sta     linnum
    55  3268 9002                               bcc     l34_4
    56  326a e617                               inc     linnum+1
    57                          l34_4
    58                          ; jsr chrget  ;ALLOW SPACES to terminate number  [910620]
    59                          ; bra l34_1
    60  326c e33d                               inw     txtptr                          ; get next character from text
    61  326e a000                               ldy     #0                              ; re-get current character from text
    62  3270 20c522                             jsr     indtxt                          ; lda (txtptr),y from RAM0
    63  3273 c920                               cmp     #' '                            ; space=eol    [910708]
    64  3275 f00d                               beq     l34_6
    65  3277 c93a                               cmp     #':'                            ;
    66  3279 b008                               bcs     l34_5                           ; eol
    67  327b 38                                 sec
    68  327c e930                               sbc     #'0'                            ; alpha or numeric?
    69  327e 38                                 sec
    70  327f e9d0                               sbc     #$d0
    71  3281 90b5                               bcc     l34_2                           ; numeric
    72  3283 60                 l34_5           rts                                     ; exit
    73                          
    74  3284 20a540             l34_6           jsr     chargt                          ; terminating character is a space, eat it just this once
    75  3287 8305f0                             +lbra   chrtst                          ; return with flags set appropriately (esp. for 'range')
    76                          
    77                          ;.end
    78                          
    79                          
    80                          ; ********************************************************************************************
    81                          ;
    82                          ;	Date		Changes
    83                          ;	====		=======
    84                          ;
    85                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/list.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      list.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15  328a 7755               list            rmb7    helper                          ; clear 'help' flag for p1line
    16                          
    17                          ; Determine which form of LIST we have...
    18                          
    19  328c f3aa00                             +lbeq   list_memory                     ; branch if terminator (no parameter)
    20  328f 93a700                             +lbcc   list_memory                     ; branch if a number (assume range parameter)
    21  3292 c9ab                               cmp     #minus_token
    22  3294 f3a200                             +lbeq   list_memory                     ; branch if a dash (assume range parameter)
    23                          
    24                          
    25                          ; LIST command is of the form  LIST filename [,U#] [,D#]
    26                          
    27                          list_file
    28  3297 a9e6                               lda     #$e6                            ; parse:  filename [,U#] [,D#]
    29  3299 202074                             jsr     dosprs                          ; (like dopen:  0 0 0 *  * 0 0 1 )
    30  329c 20dc77                             jsr     chk1                            ; check parameters
    31  329f a900                               lda     #0
    32  32a1 8d8311                             sta     dossa                           ; setup as dload would (0 = load channel)
    33  32a4 201d71                             jsr     find_la                         ; find an available la to use (cannot use reserved one)
    34  32a7 a009                               ldy     #fopn
    35  32a9 a204                               ldx     #4
    36  32ab 20fd70                             jsr     open_file                       ; open the file
    37  32ae b077                               bcs     list_err                        ; exit if error
    38                          
    39  32b0 ae8111                             ldx     dosla
    40  32b3 20c6ff                             jsr     _chkin                          ; get input channel
    41  32b6 b06f                               bcs     list_err                        ; exit if bad??
    42  32b8 20cfff                             jsr     _basin                          ; waste 'load address'
    43  32bb 20cfff                             jsr     _basin
    44                          
    45  32be 20cfff             l35_1           jsr     _basin                          ; get link bytes
    46  32c1 8d0013                             sta     dosstr
    47  32c4 20cfff                             jsr     _basin
    48  32c7 8d0113                             sta     dosstr+1
    49  32ca 0d0013                             ora     dosstr
    50  32cd f051                               beq     list_exit                       ; done if null pointer
    51  32cf 20b7ff                             jsr     _readst
    52  32d2 d04c                               bne     list_exit                       ; done if eof or bad status
    53                          ; ???? assumes serial bus
    54  32d4 a913                               lda     #>dosstr                        ; point p1line's pointer at our line buffer
    55  32d6 a200                               ldx     #<dosstr
    56  32d8 8562                               sta     lowtr+1
    57  32da 8661                               stx     lowtr
    58                          
    59  32dc a202                               ldx     #2
    60  32de 20cfff                             jsr     _basin                          ; read line into buffer
    61  32e1 9d0013                             sta     dosstr,x
    62  32e4 e8                                 inx
    63  32e5 20cfff                             jsr     _basin                          ; 2-byte line #
    64  32e8 9d0013                             sta     dosstr,x
    65  32eb e8                                 inx
    66  32ec e0ff               l35_2           cpx     #255                            ; check buffer (buflen????)
    67  32ee b38043                             +lbcs   errlen                          ; 'too long' error
    68  32f1 20cfff                             jsr     _basin
    69  32f4 9d0013                             sta     dosstr,x
    70  32f7 e8                                 inx
    71  32f8 a8                                 tay                                     ; save char
    72  32f9 20b7ff                             jsr     _readst                         ; check channel status (serial bus????)
    73  32fc d022                               bne     list_exit                       ; exit if eof or error
    74  32fe 20e1ff                             jsr     _stop
    75  3301 f01d                               beq     list_exit                       ; exit if stop key down
    76  3303 98                                 tya
    77  3304 d0e6                               bne     l35_2                           ; loop until eol
    78                          
    79  3306 20c770                             jsr     dcato                           ; get output channel
    80  3309 20f737                             jsr     crdo                            ; start new line
    81  330c ae0213                             ldx     dosstr+2                        ; get line #
    82  330f ad0313                             lda     dosstr+3
    83  3312 207733                             jsr     p1line                          ; print line #, space, and the line of code
    84  3315 20ccff                             jsr     _clrch
    85  3318 ae8111                             ldx     dosla
    86  331b 20c6ff                             jsr     _chkin                          ; get input channel
    87  331e 909e                               bcc     l35_1                           ; [900730]
    88                          
    89                          list_exit
    90  3320 20c770                             jsr     dcato                           ; flush last line with a <cr>
    91  3323 20f737                             jsr     crdo                            ; flush current line
    92  3326 18                                 clc                                     ; no errors    [910404]
    93                          list_err
    94  3327 08                                 php                                     ; save error status   [910404]
    95  3328 48                                 pha
    96  3329 20b438                             jsr     release_channels                ; release cmd channel, restore terminal
    97  332c ad8111                             lda     dosla
    98                          ; bra close_out  ;    removed [900725]
    99  332f 18                                 clc                                     ; a real close   new [910404]
   100  3330 20c3ff                             jsr     _close
   101  3333 68                                 pla                                     ; pop error status, if any
   102  3334 28                                 plp
   103  3335 833735                             +lbra   exit_disk_op
   104                          
   105                          
   106                          ; LIST command is of the form  LIST [range]
   107                          
   108                          list_memory
   109  3338 205042                             jsr     range                           ; set up line range
   110                          
   111  333b a001               l36_1           ldy     #1
   112  333d 20ad22                             jsr     indlow                          ; get ms byte of line to list's pointer
   113  3340 d007                               bne     l36_2                           ; ok if not zero, but..
   114  3342 88                                 dey
   115  3343 20ad22                             jsr     indlow
   116  3346 f3af04                             +lbeq   crdo                            ; ..if ls byte is also zero, we're done
   117                          
   118  3349 20cc2c             l36_2           jsr     is_stop_key_down
   119  334c 20f737                             jsr     crdo                            ; new line
   120  334f a002                               ldy     #2
   121  3351 20ad22                             jsr     indlow                          ; get ms byte of line number
   122  3354 aa                                 tax
   123  3355 c8                                 iny
   124  3356 20ad22                             jsr     indlow                          ; get ls byte
   125                          
   126  3359 c517                               cmp     linnum+1                        ; test if we are past the last line requested
   127  335b d004                               bne     l36_3
   128  335d e416                               cpx     linnum
   129  335f f003                               beq     l36_4
   130  3361 b39404             l36_3           +lbcs   crdo                            ; next line is > last line requested, exit
   131  3364 207733             l36_4           jsr     p1line                          ; print line #, space, and the line of code
   132  3367 a000                               ldy     #0                              ; move 'pointer to next line' into (lowtr)
   133  3369 20ad22                             jsr     indlow
   134  336c aa                                 tax
   135  336d c8                                 iny
   136  336e 20ad22                             jsr     indlow
   137  3371 8661                               stx     lowtr
   138  3373 8562                               sta     lowtr+1
   139  3375 80c4                               bra     l36_1
   140                          
   141                          
   142                          ; ********************************************************************************************
   143                          ;
   144                          ;	Date		Changes
   145                          ;	====		=======
   146                          ;
   147                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/list/basic.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      basic.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;******************************************************
    15                          ; P1LINE Print 1 line of BASIC text
    16                          ;
    17                          ; Entry: (a,x) contains line number low,high
    18                          ;  (lowtr) points to beginning of line
    19                          ;
    20                          ; next-line   line-num  BASIC text......  null
    21                          ; lo    hi    lo    hi  byte byte...byte   00
    22                          ;        ^           ^     ^
    23                          ;    (lowtr)        .A    .X
    24                          ;******************************************************
    25                          
    26  3377 4f7e03             p1line          bbr4    runmod,l37_1                    ; [910620]
    27  337a 837a89                             +lbra   edit_p1line                     ; handle things differently for plain text
    28                          
    29  337d a003               l37_1           ldy     #3
    30  337f 844b                               sty     lstpnt
    31  3381 8411                               sty     dores                           ; reset quote-switch
    32  3383 207f64                             jsr     linprt                          ; print line number
    33  3386 a920                               lda     #' '                            ; print a space
    34                          
    35  3388 a44b               p1l010          ldy     lstpnt
    36  338a 297f                               and     #$7f
    37                          
    38  338c c93a               p1l015          cmp     #':'                            ; end-of-stmt?     [900516]
    39  338e d00b                               bne     l38_1                           ; no
    40  3390 7f5508                             bbr7    helper,l38_1                    ; yes, but skip e-o-s check if not HELP...
    41  3393 ff1105                             bbs7    dores,l38_1                     ; or ':' is inside quotes
    42  3396 20cb3c                             jsr     highlight_done                  ; yes, restore normal text color
    43  3399 a93a                               lda     #':'
    44                          
    45  339b 203d68             l38_1           jsr     outch                           ; outdo
    46  339e c922                               cmp     #'"'                            ; if quote character, toggle quote-switch
    47  33a0 d006                               bne     l38_2
    48  33a2 a511                               lda     dores
    49  33a4 49ff                               eor     #$ff
    50  33a6 8511                               sta     dores
    51                          
    52  33a8 c8                 l38_2           iny                                     ; point to next character (should never wrap)
    53  33a9 8f5506                             bbs0    helper,l38_3                    ; branch if highlighting tokens
    54  33ac df5503                             bbs5    helper,l38_3                    ; branch if called by FIND/CHANGE
    55  33af 7f5503                             bbr7    helper,l38_4                    ; branch if called by LIST or HELP satisfied
    56  33b2 20963c             l38_3           jsr     helpsb
    57                          
    58  33b5 20ad22             l38_4           jsr     indlow
    59  33b8 f31109                             +lbeq   highlight_done                  ; finished when trailing null is found
    60  33bb 6c0603                             jmp     (iqplop)                        ; usually points to nqplop
    61                          
    62                          
    63                          nqplop                                                  ; <<<<<<< vector entry
    64  33be 10cc                               bpl     p1l015                          ; not a token, just print character
    65  33c0 ff11c9                             bbs7    dores,p1l015                    ; branch if inside quotes, print chr as is
    66                          
    67                          ;  At this point, we know we're talking token.  Scan the token text
    68                          ;  list until the correct text is found, and print that text.
    69                          
    70  33c3 8554                               sta     token_saver                     ; save token for REM check   [910626]
    71  33c5 c9fe                               cmp     #esc_command_token              ; is this an escape token?
    72  33c7 f042                               beq     print_esc_cmd                   ; yes- escape command
    73  33c9 c9ce                               cmp     #esc_function_token
    74  33cb f059                               beq     print_esc_fn                    ; yes- escape function
    75  33cd c9ff                               cmp     #pi
    76  33cf f0bb                               beq     p1l015                          ; no- pi is >$80, but should be printed 'as is'
    77  33d1 aa                                 tax
    78  33d2 844b                               sty     lstpnt                          ; no- use the token as index into ROM keyword list
    79  33d4 a924                               lda     #>keyword_list
    80  33d6 a03a                               ldy     #<keyword_list
    81                          
    82                          ; Scan list pointed to by (y,a) for token in (x), and print token's text
    83                          
    84  33d8 8525               p1l026          sta     index1+1                        ; index1 points to token text list in ROM
    85  33da 8424                               sty     index1
    86  33dc a000                               ldy     #0                              ; begin scanning lists for this token's text
    87  33de ca                                 dex
    88  33df 1014                               bpl     p1l070                          ; what luck! it's the first one
    89                          
    90  33e1 e324               l39_1           inw     index1                          ; scan text until next command found
    91  33e3 b124                               lda     (index1),y                      ; ind.ok (ROM)
    92  33e5 10fa                               bpl     l39_1                           ; loop until terminal char (msb=1)
    93  33e7 ca                                 dex                                     ; is next text the one we want?
    94  33e8 30f7                               bmi     l39_1                           ; no, keep scanning
    95  33ea e324                               inw     index1                          ; yes, point to first character
    96                          
    97  33ec 3f5506                             bbr3    helper,p1l070                   ; found text for this token, is it REM?  [910626]
    98  33ef a554                               lda     token_saver                     ; [910628]
    99  33f1 c98f                               cmp     #rem_token
   100  33f3 f009                               beq     p1l071                          ; yes, and REM highlighting is enabled
   101                          
   102                          p1l070                                                  ; found text for this token
   103  33f5 4f5509                             bbr4    helper,p1l072                   ; branch if not highlighting tokens
   104  33f8 b124                               lda     (index1),y                      ; peek at first character
   105  33fa 308c                               bmi     p1l010                          ; branch if operator (1-byte, msb=1)
   106  33fc 8755                               smb0    helper                          ; else begin highlight
   107  33fe 20dc3c             p1l071          jsr     highlight_text
   108                          
   109  3401 b124               p1l072          lda     (index1),y                      ; get char from ROM table
   110  3403 3083                               bmi     p1l010                          ; msb=1=last char this token, contine line
   111  3405 203d68                             jsr     outch                           ; else print it
   112  3408 c8                                 iny
   113  3409 80f6                               bra     p1l072
   114                          
   115                          
   116                          ; Print Escape Command
   117                          
   118                          print_esc_cmd
   119  340b aa                                 tax                                     ; save type (cmd) in case it is a foreign esc token
   120  340c c8                                 iny
   121  340d 20ad22                             jsr     indlow                          ; look at second token
   122  3410 f37aff                             +lbeq   p1l015                          ; none?  print funny character
   123  3413 844b                               sty     lstpnt
   124  3415 c902                               cmp     #first_esc_command_token        ; is this one of ours?
   125  3417 9028                               bcc     print_foreign_esc               ; nope
   126  3419 c946                               cmp     #last_esc_command_token+1
   127  341b b024                               bcs     print_foreign_esc               ; nope
   128  341d 697e                               adc     #$80-first_esc_command_token    ; yes- make a pointer p1l will be proud of
   129  341f aa                                 tax
   130  3420 a029                               ldy     #<esc_command_list
   131  3422 a926                               lda     #>esc_command_list
   132  3424 80b2                               bra     p1l026                          ; go scan list and print it
   133                          
   134                          
   135                          
   136                          ; Print Escape Function
   137                          
   138                          print_esc_fn
   139  3426 aa                                 tax                                     ; save type (function) in case it's a foreign esc token
   140  3427 c8                                 iny
   141  3428 20ad22                             jsr     indlow                          ; look at second token
   142  342b f35fff                             +lbeq   p1l015                          ; none?  print funny character
   143  342e 844b                               sty     lstpnt
   144  3430 c902                               cmp     #first_esc_function_token       ; is this one of ours?
   145  3432 900d                               bcc     print_foreign_esc               ; nope
   146  3434 c90e                               cmp     #last_esc_function_token+1
   147  3436 b009                               bcs     print_foreign_esc               ; nope
   148  3438 697e                               adc     #$80-first_esc_function_token   ; yes- make a pointer p1l will be proud of
   149  343a aa                                 tax
   150  343b a09a                               ldy     #<esc_function_list
   151  343d a927                               lda     #>esc_function_list
   152  343f 8097                               bra     p1l026                          ; go scan list and print it
   153                          
   154                          
   155                          ; The token to be printed is an escape token which is NOT recognized by BASIC.
   156                          ; We will jump through the indirect chain and see if anyone claims this token.
   157                          ;
   158                          ; At this point:
   159                          ; .C = 1 to signal 'unclaimed'
   160                          ; .X = type (0==>command, ff==>function)
   161                          ; .A = second token character
   162                          ;
   163                          ; If anyone claims this token, they should:
   164                          ;
   165                          ; > Clear .C to flag 'taken'
   166                          ; > Point (INDEX1) at the string to be printed (with msb of last char set)
   167                          ; > Note: string to print MUST be in RAM-0!
   168                          
   169                          print_foreign_esc
   170  3441 e0fe                               cpx     #esc_command_token
   171  3443 d003                               bne     l40_1
   172  3445 a200                               ldx     #0
   173  3447 2c                                 !text $2c
   174                          
   175  3448 a2ff               l40_1           ldx     #$ff
   176  344a 38                                 sec
   177  344b 6c0e03                             jmp     (iescpr)
   178                          
   179  344e b33cff             nescpr          +lbcs   p1l015                          ; no takers, print a funny graphic character
   180  3451 a000                               ldy     #0
   181  3453 80a0                               bra     p1l070
   182                          
   183                          
   184                          ;.end
   185                          
   186                          ; ********************************************************************************************
   187                          ;
   188                          ;	Date		Changes
   189                          ;	====		=======
   190                          ;
   191                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/newclr.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      newclr.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;
    16                          ; The NEW command clears the program text as well as variable space.
    17                          ;
    18                          
    19  3455 f021               new             beq     init_text                       ; Erase program in memory
    20  3457 c98c                               cmp     #restore_token                  ; Restore an erased program?    [910103]
    21  3459 d3eff9                             +lbne   snerr                           ; no- syntax error    [910410]
    22  345c 2022b5                             jsr     chkeos                          ; yes- eat token, error if not eos  [910429]
    23  345f a52d                               lda     txttab                          ; "seed" first link to fool 'chead'
    24  3461 a62e                               ldx     txttab+1
    25  3463 8524                               sta     index
    26  3465 8625                               stx     index+1
    27  3467 a900                               lda     #0
    28  3469 a001                               ldy     #1
    29  346b a224                               ldx     #index
    30  346d 200c23                             jsr     sta_far_ram0                    ; clear msb  (bleed-thru)
    31  3470 88                                 dey
    32  3471 1a                                 inc
    33  3472 200c23                             jsr     sta_far_ram0                    ; set lsb   (bleed-thru)
    34  3475 839c09                             +lbra   renumber                        ; make renumber check it for us (not 100%) & relink
    35                          
    36                          
    37                          init_text
    38  3478 a52d                               lda     txttab                          ; find the bottom of basic text
    39  347a a62e                               ldx     txttab+1
    40  347c 8524                               sta     index
    41  347e 8625                               stx     index+1
    42  3480 c324                               dew     index                           ; (the absolute bottom)
    43                          
    44  3482 a900                               lda     #0
    45  3484 a8                                 tay
    46  3485 a224                               ldx     #index
    47  3487 200c23                             jsr     sta_far_ram0                    ; clear bottom     (bleed-thru)
    48  348a c8                                 iny
    49  348b 200c23                             jsr     sta_far_ram0                    ; clear first link bytes    (bleed-thru)
    50  348e c8                                 iny
    51  348f 200c23                             jsr     sta_far_ram0                    ; (bleed-thru)
    52  3492 18                                 clc
    53  3493 a52d                               lda     txttab
    54  3495 6902                               adc     #2
    55  3497 8582                               sta     text_top                        ; set up (text_top), the end of text
    56  3499 a52e                               lda     txttab+1
    57  349b 6900                               adc     #0
    58  349d 8583                               sta     text_top+1
    59                          
    60  349f 577e                               rmb5    runmod                          ; trcflg. reset trace flag
    61                          
    62                          
    63  34a1 201f35             runc            jsr     reset_txtptr                    ; load (txtptr) with (txttab)-1
    64  34a4 8025                               bra     clearc                          ; "CLR" to clear vars    [910410]
    65                          
    66                          
    67                          ; CLeaR Routines
    68                          ;
    69                          
    70                          ; Special forms of CLR command:
    71                          ;
    72                          ; CLR ERR$ Clears program error status, useful in TRAP handlers which
    73                          ;   have resolved an error & wish to RESUME with a clean status.
    74                          ;
    75                          ; CLR DS$  Clears the currently buffered DS,DS$ messages.  The next
    76                          ;   use of DS or DS$ will make BASIC re a new message from DOS.
    77                          
    78  34a6 f023               clear           beq     clearc                          ; branch if no args    [910410]
    79                          
    80  34a8 c9d3                               cmp     #err_token                      ; CLR ERR$
    81  34aa d006                               bne     l41_1                           ; no
    82  34ac 2022b5                             jsr     chkeos                          ; yes- eat token & error if not eos
    83  34af 832b10                             +lbra   error_clear                     ; and go clear ERR$
    84                          
    85  34b2 c944               l41_1           cmp     #'D'                            ; CLR DS$     [910717]
    86  34b4 d00c                               bne     l41_2                           ; no- error
    87  34b6 208322                             jsr     chrget
    88  34b9 c953                               cmp     #'S'
    89  34bb d005                               bne     l41_2
    90  34bd 208322                             jsr     chrget
    91  34c0 c924                               cmp     #'$'
    92  34c2 d386f9             l41_2           +lbne   snerr                           ; no- error
    93  34c5 2022b5                             jsr     chkeos
    94  34c8 83b843                             +lbra   Clear_DS                        ; yes- clear current DS$
    95                          
    96                          
    97                          ; Clearc is a subroutine which initializes the variable and array space by
    98                          ; resetting STREND (the end of array storage).  It falls into INIT_STACK,
    99                          ; which resets the stack.
   100                          
   101  34cb 20e7ff             clearc          jsr     _clall                          ; close all files
   102  34ce a000                               ldy     #0
   103  34d0 8479                               sty     dsdesc                          ; flag 'no DS$ string'
   104  34d2 88                                 dey                                     ; (y=$ff)
   105  34d3 8ccb02                             sty     trapno+1                        ; flag no current trap line
   106  34d6 8cc802                             sty     errlin                          ; reset last error pointers
   107  34d9 8cc902                             sty     errlin+1
   108  34dc 8cc702                             sty     errnum
   109                          
   110  34df a539                               lda     max_mem_1                       ; clear string space
   111  34e1 a43a                               ldy     max_mem_1+1
   112  34e3 8535                               sta     fretop
   113  34e5 8436                               sty     fretop+1
   114                          
   115  34e7 a9ff                               lda     #<stkbot                        ; empty run-time stack
   116  34e9 a005                               ldy     #>stkbot
   117  34eb 857c                               sta     tos
   118  34ed 847d                               sty     tos+1
   119                          
   120  34ef a52f                               lda     vartab
   121  34f1 a430                               ldy     vartab+1
   122  34f3 8531                               sta     arytab                          ; this will delete all variables,
   123  34f5 8432                               sty     arytab+1
   124  34f7 8533                               sta     strend                          ; ..and arrays
   125  34f9 8434                               sty     strend+1
   126                          
   127  34fb a203                               ldx     #pumony-puchrs                  ; reset print using chars
   128  34fd bddb69             l42_1           lda     pudefs,x
   129  3500 9dd411                             sta     puchrs,x
   130  3503 ca                                 dex
   131  3504 10f7                               bpl     l42_1
   132                          
   133  3506 20fc3d             fload           jsr     restore__1                      ; reset pointer for DATA statements
   134                          
   135                          
   136                          
   137                          ; ********************************************************************************************
   138                          ;
   139                          ;	Date		Changes
   140                          ;	====		=======
   141                          ;
   142                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: stack/init.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      init.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; INIT_STACK Routine (formerly STKINI)
    14                          ;
    15                          ;   Init_Stack resets the stack pointer.  String temporaries are freed up,
    16                          ;   SUBFLG is reset, continuing is prohibited.
    17                          
    18                          init_stack
    19  3509 7a                                 ply                                     ; pop return address
    20  350a 68                                 pla
    21  350b a2fa                               ldx     #stkend-257                     ; reset system stack pointer
    22  350d 9a                                 txs
    23  350e 48                                 pha                                     ; push return address
    24  350f 5a                                 phy
    25  3510 a21b                               ldx     #tempst                         ; reset string temporaries
    26  3512 8618                               stx     temppt
    27  3514 a900                               lda     #0
    28  3516 8512                               sta     subflg                          ; allow subscripted & integer vars
    29  3518 8d7311                             sta     oldtxt+1                        ; disallow continuing
    30  351b 8dd702                             sta     bits                            ; reset math bit/byte flag
    31                          
    32  351e 60                 stkrts          rts
    33                          
    34                          
    35                          
    36                          reset_txtptr
    37  351f 18                                 clc                                     ; load (txtptr) with (txttab)-1
    38  3520 a52d                               lda     txttab
    39  3522 69ff                               adc     #$ff
    40  3524 853d                               sta     txtptr
    41  3526 a52e                               lda     txttab+1
    42  3528 69ff                               adc     #$ff
    43  352a 853e                               sta     txtptr+1                        ; set up text pointers
    44  352c 60                                 rts
    45                          
    46                          ;.end
    47                          
    48                          ; ********************************************************************************************
    49                          ;
    50                          ;	Date		Changes
    51                          ;	====		=======
    52                          ;
    53                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/return.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      return.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*********************************************************************
    16                          ; RETURN Routine
    17                          ;
    18                          ; Restores the line number and text pointer from the stack, and
    19                          ; eliminates all the FOR entries in front of the GOSUB entry.
    20                          ;
    21                          ;*********************************************************************
    22                          
    23                          return
    24                          
    25                          ; Ok, pay attention: we got here by a pseudo-jsr which left a return to NEWSTT
    26                          ; on the stack for us to return to.  There is also a return to NEWSTT left on
    27                          ; the stack from the GOSUB we are returning from.  This is true UNLESS we got
    28                          ; here on a sprite collision, in which case we still have the NEWSUB return
    29                          ; recently left by our current call, but the second return goes back to the
    30                          ; trapping mechanism.  The bottom line is: we have an extra return address on
    31                          ; the stack, which we have to get rid of before leaving.
    32                          
    33  352d 68                                 pla                                     ; mea culpa, mea culpa, mea culpa
    34  352e 68                                 pla
    35  352f a98d                               lda     #gosub_token
    36  3531 204331                             jsr     search                          ; look for GOSUB on runtime stack
    37  3534 f005                               beq     ret010                          ; found
    38  3536 a20c                               ldx     #errrg                          ; else error
    39  3538 8315f9                             +lbra   error
    40                          
    41  353b 20e631             ret010          jsr     movfnd                          ; (fndpnt) => (tos)
    42  353e a005                               ldy     #lengos
    43  3540 20ef31                             jsr     rlsstk                          ; effectivly pop GOSUB off run-time stack
    44                          ; dey
    45                          ; lda (fndpnt),y
    46                          ; sta txtptr+1
    47                          ; dey
    48                          ; lda (fndpnt),y
    49                          ; sta txtptr
    50                          ; dey
    51                          ; lda (fndpnt),y
    52  3543 204279                             jsr     retpat                          ; 01/18/84 patch: correct RETURN to GOSUB from direct mode
    53                          ; lda (fndpnt),y
    54                          ; sta curlin ;jump to DATA to waste rest of stmt (in case of ON..GOSUB)
    55  3546 8000                               bra     data
    56                          
    57                          ;.end
    58                          
    59                          ; ********************************************************************************************
    60                          ;
    61                          ;	Date		Changes
    62                          ;	====		=======
    63                          ;
    64                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/data.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      data.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          
    16                          data
    17  3548 205b35                             jsr     datan                           ; skip to end of statement- offset in .y
    18  354b 98                 addon           tya
    19  354c 18                                 clc
    20  354d 653d                               adc     txtptr                          ; add offset to end to txtptr
    21  354f 853d                               sta     txtptr
    22  3551 9002                               bcc     remrts
    23  3553 e63e                               inc     txtptr+1
    24  3555 60                 remrts          rts                                     ; NEWSTT rts addr is still there
    25                          
    26                          
    27                          
    28  3556 205e35             rem             jsr     remn                            ; skip rest of statement
    29  3559 80f0                               bra     addon                           ; will always branch
    30                          
    31                          
    32  355b a23a               datan           ldx     #':'                            ; DATA terminates on ":" and null
    33  355d 2c                                 !text $2c
    34                          
    35  355e a200               remn            ldx     #0                              ; REM terminates on null only
    36  3560 860a                               stx     charac                          ; preserve terminator
    37  3562 a000                               ldy     #0                              ; this makes charac=0 after swap
    38  3564 840b                               sty     endchr
    39                          
    40  3566 a50b               l43_1           lda     endchr
    41  3568 a60a                               ldx     charac
    42  356a 850a                               sta     charac
    43  356c 860b                               stx     endchr
    44  356e 20c522             l43_2           jsr     indtxt
    45  3571 f0e2                               beq     remrts                          ; null always terminates
    46  3573 c50b                               cmp     endchr                          ; is it some another terminator?
    47  3575 f0de                               beq     remrts                          ; yes, it's finished
    48  3577 c8                                 iny                                     ; progress to next character
    49  3578 c922                               cmp     #'"'                            ; is it a quote?
    50  357a d0f2                               bne     l43_2                           ; no, just continue
    51  357c f0e8                               beq     l43_1                           ; yes, time to change
    52                          
    53                          ;.end
    54                          
    55                          ; ********************************************************************************************
    56                          ;
    57                          ;	Date		Changes
    58                          ;	====		=======
    59                          ;
    60                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/ifthenelse.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      ifthenelse.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;****************************************************************
    16                          ;*
    17                          ;* IF Statment
    18                          ;*
    19                          ;* IF exp {GOTO line#  | THEN {line# | statements | b-block} }
    20                          ;*  [:ELSE {line# | statements | b-block} ]
    21                          ;*
    22                          ;* B-block
    23                          ;*
    24                          ;* BEGIN : [statement(s) on one or more lines] : BEND
    25                          ;*
    26                          ;****************************************************************
    27                          
    28  357e 20ef4c             if              jsr     frmevl                          ; evaluate the conditional expression
    29  3581 208522                             jsr     chrgot                          ; re-get current character
    30  3584 c989                               cmp     #goto_token                     ; is terminating character a GOTO?
    31  3586 f005                               beq     l44_1                           ; yes
    32  3588 a9a7                               lda     #then_token                     ; no, it must be THEN
    33  358a 205d4e                             jsr     synchr
    34                          
    35  358d a563               l44_1           lda     facexp                          ; test truth value of argument
    36  358f d026                               bne     if_true                         ; branch if true
    37                          
    38                          if_false
    39  3591 208522                             jsr     chrgot                          ; is there a b-block?
    40  3594 c9fe                               cmp     #esc_command_token
    41  3596 d00b                               bne     l45_1                           ; no, must be an escape command
    42  3598 c8                                 iny                                     ; might be, look at escape token
    43  3599 20c522                             jsr     indtxt
    44  359c c918                               cmp     #begin_token
    45  359e d003                               bne     l45_1                           ; branch if not
    46  35a0 20d935                             jsr     find_bend                       ; skip to end of b-block
    47                          
    48  35a3 204835             l45_1           jsr     data                            ; may be 'else' clause. first skip over 'then' clause..
    49  35a6 a000                               ldy     #0
    50  35a8 20c522                             jsr     indtxt                          ; ..and see if end of stmt or end of line
    51  35ab f0a9                               beq     rem                             ; end of line, no 'else'. go to next line
    52  35ad 208322                             jsr     chrget                          ; another statement on this line.. is it 'else'?
    53  35b0 c9d5                               cmp     #else_token
    54  35b2 d0ef                               bne     l45_1                           ; no, keep looking on this line
    55  35b4 208322                             jsr     chrget                          ; yes! skip over token and execute clause (below)
    56                          
    57  35b7 208522             if_true         jsr     chrgot
    58  35ba f017                               beq     l46_2                           ; branch if end of statement
    59  35bc b003                               bcs     l46_1                           ; branch if not a number
    60  35be 833b07                             +lbra   goto                            ; here if of the form 'THEN line#'
    61                          
    62  35c1 c9fe               l46_1           cmp     #esc_command_token              ; is this the beginning of a b-block?
    63  35c3 d00e                               bne     l46_2                           ; no, must be an escape command
    64  35c5 c8                                 iny                                     ; might be, look at escape token
    65  35c6 20c522                             jsr     indtxt
    66  35c9 c918                               cmp     #begin_token
    67  35cb d006                               bne     l46_2
    68  35cd 208322                             jsr     chrget                          ; skip over 'BEGIN' if so...
    69  35d0 208322                             jsr     chrget                          ; ..and the second token, as well.
    70                          
    71  35d3 208522             l46_2           jsr     chrgot                          ; get back original character, & set up flags
    72  35d6 837af6                             +lbra   xeqcm3                          ; ..and go execute whatever it is
    73                          
    74                          
    75                          find_bend                                               ; ... subroutine to find end of current b-block
    76  35d9 208322                             jsr     chrget
    77  35dc d026                               bne     l47_3
    78                          
    79                          ; End of statement.. set up next
    80                          
    81  35de c93a               l47_1           cmp     #':'                            ; is this EOL?
    82  35e0 f0f7                               beq     find_bend                       ; no, keep looking
    83                          
    84  35e2 7f7e48             l47_2           bbr7    runmod,l47_7                    ; EOL: branch if direct mode, 'block terminator not found' error
    85                          
    86  35e5 a002                               ldy     #2
    87  35e7 20c522                             jsr     indtxt                          ; end of text?
    88  35ea f041                               beq     l47_7                           ; yes, msb of next stmt pointer = 0. error
    89                          
    90  35ec c8                                 iny
    91  35ed 20c522                             jsr     indtxt
    92  35f0 853b                               sta     curlin                          ; set up next line of text
    93  35f2 c8                                 iny
    94  35f3 20c522                             jsr     indtxt
    95  35f6 853c                               sta     curlin+1
    96  35f8 98                                 tya
    97  35f9 18                                 clc
    98  35fa 653d                               adc     txtptr
    99  35fc 853d                               sta     txtptr
   100  35fe 90d9                               bcc     find_bend
   101  3600 e63e                               inc     txtptr+1
   102  3602 80d5                               bra     find_bend                       ; always
   103                          
   104  3604 c922               l47_3           cmp     #'"'
   105  3606 d007                               bne     l47_4
   106  3608 203236                             jsr     un_quote                        ; look for terminating quote, or EOL
   107  360b f0d1                               beq     l47_1                           ; EOL or ':' after closing quote
   108  360d d0ca                               bne     find_bend                       ; ..else normal char, keep looking
   109                          
   110  360f c98f               l47_4           cmp     #rem_token                      ; REM?
   111  3611 d005                               bne     l47_5                           ; no
   112  3613 205635                             jsr     rem                             ; yes, trash this line
   113  3616 80ca                               bra     l47_2                           ; and go test for end of text
   114                          
   115  3618 c9fe               l47_5           cmp     #esc_command_token              ; is this a BEND?
   116  361a d0bd                               bne     find_bend                       ; can't be, has to be an escape
   117                          
   118  361c 208322                             jsr     chrget                          ; skip over esc token
   119  361f c919                               cmp     #bend_token
   120  3621 f009                               beq     l47_6                           ; this is what we came for, bye!
   121                          
   122  3623 c918                               cmp     #begin_token                    ; not a BEND. is it a BEGIN?
   123  3625 d0b2                               bne     find_bend                       ; it's just a normal, stick-in-the-mud char. keep looking.
   124                          
   125  3627 20d935                             jsr     find_bend                       ; oh-oh, recursion. Dr. Ja-Ja warned me about this.
   126  362a 80ad                               bra     find_bend
   127                          
   128  362c 60                 l47_6           rts
   129                          
   130  362d a225               l47_7           ldx     #err_no_bend
   131  362f 831ef8                             +lbra   error
   132                          
   133                          un_quote                                                ; txtptr points to a '"'. look for closing '"', or EOL
   134  3632 a000                               ldy     #0
   135  3634 e33d               l48_1           inw     txtptr
   136  3636 20c522                             jsr     indtxt
   137  3639 f007                               beq     l48_2                           ; EOL, get out here with .z set and a '00' in .a
   138  363b c922                               cmp     #'"'
   139  363d d0f5                               bne     l48_1                           ; keep looking until quote
   140  363f 4c8322                             jmp     chrget                          ; got closing quote, get byte after quote, set flags
   141                          
   142  3642 60                 l48_2           rts
   143                          
   144                          
   145                          
   146  3643 c9fe               else            cmp     #esc_command_token              ; is this of the form "ELSE b-block"?
   147  3645 d00b                               bne     l49_1                           ; no, must be an escape command
   148  3647 c8                                 iny                                     ; might be, look at escape token
   149  3648 20c522                             jsr     indtxt
   150  364b c918                               cmp     #begin_token
   151  364d d003                               bne     l49_1                           ; no, justa plain-old "ELSE statement"
   152  364f 20d935                             jsr     find_bend                       ; yes, it is a b-block. skip over the b-block.
   153  3652 8302ff             l49_1           +lbra   rem
   154                          
   155                          
   156                          ;.end
   157                          
   158                          ; ********************************************************************************************
   159                          ;
   160                          ;	Date		Changes
   161                          ;	====		=======
   162                          ;
   163                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/on.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      on.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*********************************************************
    16                          ;* ON expression {GOTO | GOSUB} line_number
    17                          ;*********************************************************
    18                          ongoto
    19  3655 206c5d                             jsr     getbyt                          ; get & save GOTO/GOSUB
    20  3658 48                                 pha
    21  3659 c989                               cmp     #goto_token                     ; GOTO?
    22  365b f005                               beq     l50_1                           ; yes
    23  365d c98d                               cmp     #gosub_token                    ; GOSUB?
    24  365f d3e9f7                             +lbne   snerr                           ; no, syntax error
    25                          
    26  3662 c667               l50_1           dec     faclo
    27  3664 d004                               bne     l50_2                           ; skip another line number
    28  3666 68                                 pla                                     ; get dispatch character
    29  3667 8300f6                             +lbra   xeqcm2
    30                          
    31  366a 208322             l50_2           jsr     chrget                          ; advance and set codes
    32  366d 202e32                             jsr     linget                          ; read next line
    33  3670 c92c                               cmp     #','                            ; is it a "comma"?
    34  3672 f0ee                               beq     l50_1
    35  3674 68                                 pla                                     ; remove stack entry (token)
    36  3675 60                                 rts                                     ; either end of line or syntax error
    37                          
    38                          ;.end
    39                          
    40                          ; ********************************************************************************************
    41                          ;
    42                          ;	Date		Changes
    43                          ;	====		=======
    44                          ;
    45                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/let/standard.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      standard.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;****************************************************************
    16                          ;*
    17                          ;*  [LET] variable = expression
    18                          ;*
    19                          ;****************************************************************
    20                          
    21  3676 207c4f             let             jsr     ptrget                          ; get pntr to variable into "varpnt"
    22  3679 854b                               sta     forpnt                          ; preserve pointer
    23  367b 844c                               sty     forpnt+1
    24  367d a9b2                               lda     #equal_token
    25  367f 205d4e                             jsr     synchr                          ; "=" is necessary
    26                          
    27  3682 a510                               lda     intflg                          ; save type for later
    28  3684 48                                 pha
    29  3685 a50f                               lda     valtyp                          ; retain the variable's value type too
    30  3687 48                                 pha
    31                          
    32  3688 20ef4c                             jsr     frmevl                          ; get value of formula into FAC
    33  368b 68                                 pla
    34  368c 2a                                 rol                                     ; carry set for string, off for numeric
    35  368d 20de4c                             jsr     chkval                          ; make sure VALTYP matches carry
    36                          ;and set zero flag for numeric
    37  3690 d022                               bne     copstr                          ; if numeric, copy it
    38  3692 68                                 pla                                     ; get number type
    39                          
    40  3693 1018               qintgr          bpl     copflt                          ; store a floating point number
    41  3695 20b262                             jsr     round                           ; round integer
    42  3698 20b458                             jsr     ayint                           ; make two-byte number
    43  369b a000                               ldy     #0
    44  369d a566                               lda     facmo                           ; get high
    45  369f da                                 phx
    46  36a0 a24b                               ldx     #forpnt
    47  36a2 20f022                             jsr     sta_far_ram1 ;sta (forpnt),y    ; store it
    48  36a5 c8                                 iny
    49  36a6 a567                               lda     faclo                           ; get low
    50  36a8 20f022                             jsr     sta_far_ram1                    ; sta (forpnt),y
    51  36ab fa                                 plx
    52  36ac 60                                 rts
    53                          
    54                          
    55                          
    56  36ad a64b               copflt          ldx     forpnt
    57  36af a44c                               ldy     forpnt+1
    58  36b1 83af2b                             +lbra   movmf_ram1                      ; put number @forpnt in var bank
    59                          
    60                          
    61                          
    62  36b4 68                 copstr          pla                                     ; if string, no INTFLG
    63                          
    64  36b5 a44c               inpcom          ldy     forpnt+1                        ; TI$?
    65  36b7 c002                               cpy     #>zero                          ; (only TI$ can be this on assign)
    66  36b9 f3c21c                             +lbeq   Set_TI_String                   ; yes
    67  36bc 8024                               bra     getspt                          ; no
    68                          
    69                          
    70  36be 68                 dskx1           pla
    71  36bf c8                                 iny
    72                          
    73  36c0 c536               dskx2           cmp     fretop+1
    74  36c2 9018                               bcc     l51_2
    75  36c4 d008                               bne     l51_1
    76  36c6 88                                 dey
    77  36c7 20a922                             jsr     indfmo
    78  36ca c535                               cmp     fretop
    79  36cc 900e                               bcc     l51_2
    80                          
    81  36ce a467               l51_1           ldy     faclo                           ; qvaria
    82  36d0 c430                               cpy     vartab+1                        ; if (vartab) > (facmo), don't copy
    83  36d2 9008                               bcc     l51_2
    84  36d4 d023                               bne     copy                            ; it is less
    85  36d6 a566                               lda     facmo
    86  36d8 c52f                               cmp     vartab                          ; compare low orders
    87  36da b01d                               bcs     copy
    88                          
    89  36dc a566               l51_2           lda     facmo                           ; dntcpy
    90  36de a467                               ldy     facmo+1
    91  36e0 8035                               bra     copyc
    92                          
    93                          
    94  36e2 a002               getspt          ldy     #2                              ; get pntr to descriptor
    95  36e4 20a922                             jsr     indfmo
    96  36e7 c57b                               cmp     dsdesc+2                        ; check for DS$ hi
    97  36e9 d0d5                               bne     dskx2                           ; nope
    98  36eb 48                                 pha
    99  36ec 88                                 dey
   100  36ed 20a922                             jsr     indfmo
   101  36f0 c57a                               cmp     dsdesc+1                        ; check for DS$ lo
   102  36f2 d0ca                               bne     dskx1                           ; nope
   103  36f4 a579                               lda     dsdesc                          ; check if len=0
   104  36f6 f0c6                               beq     dskx1                           ; yup
   105  36f8 68                                 pla                                     ; fall through to copy
   106                          
   107                          
   108  36f9 a000               copy            ldy     #0
   109  36fb 20a922                             jsr     indfmo
   110  36fe 20735a                             jsr     strini                          ; get room to copy string into
   111  3701 a552                               lda     dscpnt                          ; get pointer to old descriptor, so
   112  3703 a453                               ldy     dscpnt+1
   113  3705 8570                               sta     strng1                          ; movins can find string
   114  3707 8471                               sty     strng1+1
   115  3709 20355b                             jsr     movins                          ; copy it
   116                          
   117  370c a570                               lda     strng1                          ; fix to free get strings
   118  370e a471                               ldy     strng1+1
   119  3710 20cc5b                             jsr     fretms                          ; free the string, if it is a temp
   120                          
   121  3713 a963                               lda     #<dsctmp
   122  3715 a000                               ldy     #>dsctmp
   123                          
   124  3717 8552               copyc           sta     dscpnt
   125  3719 8453                               sty     dscpnt+1
   126  371b 8524                               sta     index                           ; index points to new descriptor
   127  371d 8425                               sty     index+1
   128  371f 20cc5b                             jsr     fretms
   129                          
   130                          
   131                          ;   Fix the strings by flagging the old string as garbage and the new
   132                          ;   string by pointing it to its new descriptor.
   133                          
   134  3722 206737                             jsr     stradj                          ; set up new string
   135  3725 9011                               bcc     l52_1                           ; leave it alone
   136  3727 a000                               ldy     #0
   137  3729 a54b                               lda     forpnt                          ; put in backwards link
   138  372b da                                 phx
   139  372c a224                               ldx     #index
   140  372e 20f022                             jsr     sta_far_ram1
   141  3731 c8                                 iny
   142  3732 a54c                               lda     forpnt+1
   143  3734 20f022                             jsr     sta_far_ram1
   144  3737 fa                                 plx
   145                          
   146  3738 a54b               l52_1           lda     forpnt                          ; fix old string
   147  373a 8524                               sta     index
   148  373c a54c                               lda     forpnt+1
   149  373e 8525                               sta     index+1
   150  3740 206737                             jsr     stradj                          ; point to old string
   151  3743 9010                               bcc     l52_2                           ; in text do not fix
   152  3745 88                                 dey                                     ; restore y
   153  3746 da                                 phx
   154  3747 a224                               ldx     #index
   155  3749 a9ff                               lda     #$ff                            ; garbage flag
   156  374b 20f022                             jsr     sta_far_ram1
   157  374e 88                                 dey
   158  374f 68                                 pla                                     ; (was txa)
   159  3750 48                                 pha
   160  3751 20f022                             jsr     sta_far_ram1                    ; store length
   161  3754 fa                                 plx
   162                          
   163  3755 a002               l52_2           ldy     #2                              ; set the descriptor
   164  3757 da                                 phx
   165  3758 a24b                               ldx     #forpnt
   166  375a a952               l52_3           lda     #dscpnt
   167  375c 20d722                             jsr     lda_far_ram1                    ; lda (dscpnt),y from RAM1
   168  375f 20f022                             jsr     sta_far_ram1                    ; sta (forpnt),y to   RAM1
   169  3762 88                                 dey
   170  3763 10f5                               bpl     l52_3
   171  3765 fa                                 plx
   172  3766 60                                 rts
   173                          
   174                          
   175                          ;   STRADJ takes the pointer index which points to a descriptor and
   176                          ;   indexes to the desciptor's string data.  If the string is not in
   177                          ;   string space (no action to take) we return with carry clear, else
   178                          ;   we return with the pointer set to the link bytes in the string, the
   179                          ;   length in .a and the carry set.
   180                          
   181  3767 a000               stradj          ldy     #0
   182  3769 20d522                             jsr     indin1_ram1                     ; push length on stack
   183  376c 48                                 pha
   184  376d f036                               beq     l53_5                           ; if length=0 do nothing
   185  376f c8                                 iny
   186  3770 20d522                             jsr     indin1_ram1                     ; get low byte (into .x)
   187  3773 aa                                 tax
   188  3774 c8                                 iny
   189  3775 20d522                             jsr     indin1_ram1                     ; get high byte
   190  3778 c53a                               cmp     max_mem_1+1
   191  377a 9006                               bcc     l53_1                           ; ok
   192  377c d027                               bne     l53_5                           ; if above top of memory
   193  377e e439                               cpx     max_mem_1                       ; msb the same, test lsb
   194  3780 b023                               bcs     l53_5                           ; if above top of memory
   195                          
   196  3782 c536               l53_1           cmp     fretop+1
   197  3784 901f                               bcc     l53_5                           ; if below fretop
   198  3786 d004                               bne     l53_2
   199  3788 e435                               cpx     fretop
   200  378a 9019                               bcc     l53_5                           ; if below fretop
   201                          
   202  378c c57b               l53_2           cmp     dsdesc+2
   203  378e d004                               bne     l53_3                           ; fix
   204  3790 e47a                               cpx     dsdesc+1
   205  3792 f011                               beq     l53_5
   206                          
   207  3794 8624               l53_3           stx     index                           ; ok set pointer
   208  3796 8525                               sta     index+1
   209  3798 68                                 pla                                     ; get back length
   210  3799 aa                                 tax                                     ; into x also
   211  379a 18                                 clc
   212  379b 6524                               adc     index
   213  379d 8524                               sta     index
   214  379f 9002                               bcc     l53_4
   215  37a1 e625                               inc     index+1
   216  37a3 38                 l53_4           sec                                     ; carry set
   217  37a4 60                                 rts
   218                          
   219  37a5 68                 l53_5           pla                                     ; clean up stack
   220  37a6 18                                 clc
   221  37a7 60                                 rts
   222                          
   223                          ;.end
   224                          
   225                          ; ********************************************************************************************
   226                          ;
   227                          ;	Date		Changes
   228                          ;	====		=======
   229                          ;
   230                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/text,print.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      text,print.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;***********************************************************
    16                          ;*
    17                          ;* PRINT   PRINT#   CMD
    18                          ;*
    19                          ;**********************************************************
    20                          
    21  37a8 20ae37             printn          jsr     cmd                             ; docmd
    22  37ab 830701                             +lbra   release_channels                ; restore terminal
    23                          
    24                          
    25  37ae 206c5d             cmd             jsr     getbyt
    26  37b1 f005                               beq     l54_1
    27  37b3 a92c                               lda     #','                            ; comma?
    28  37b5 205d4e                             jsr     synchr
    29                          
    30  37b8 08                 l54_1           php                                     ; save stat (beq=eof)
    31  37b9 48                                 pha                                     ; save char
    32  37ba 8615                               stx     channl                          ; channel to output on
    33  37bc 204968                             jsr     coout
    34  37bf 68                                 pla                                     ; get char back
    35  37c0 28                                 plp                                     ; get stat back
    36  37c1 8006                               bra     print
    37                          
    38                          
    39  37c3 203e38             strdon          jsr     strprt
    40                          
    41  37c6 208522             newchr          jsr     chrgot                          ; reget last character
    42                          
    43  37c9 f02c               print           beq     crdo                            ; terminator only, so print crlf
    44  37cb c9fb                               cmp     #using_token
    45  37cd f31032                             +lbeq   using
    46                          
    47                          
    48                          
    49  37d0 f032               printc          beq     prtrts  ;here after seeing TAB(x) or "," or "; " in which case
    50                          ;a terminator does not mean a crlf but just RTS
    51  37d2 c9a3                               cmp     #tab_token                      ; TAB function?
    52  37d4 f03f                               beq     taber                           ; yes (c=1)
    53  37d6 c9a6                               cmp     #spc_token                      ; space function?
    54  37d8 18                                 clc                                     ; clear carry
    55  37d9 f03a                               beq     taber                           ; yes (c=0)
    56  37db c92c                               cmp     #','                            ; comma?
    57  37dd f026                               beq     comprt                          ; yes
    58  37df c93b                               cmp     #';'                            ; a semicolon?
    59  37e1 f04e                               beq     notabr                          ; yes
    60                          
    61  37e3 20ef4c                             jsr     frmevl                          ; evaluate the formula
    62  37e6 ff0fda                             bbs7    valtyp,strdon                   ; branch if a string
    63  37e9 208f64                             jsr     fout
    64  37ec 20855a                             jsr     strlit                          ; build descriptor
    65  37ef 203e38                             jsr     strprt                          ; print the number
    66  37f2 205838                             jsr     outspc                          ; print a space
    67  37f5 80cf                               bra     newchr                          ; always goes
    68                          
    69                          
    70                          
    71  37f7 a90d               crdo            lda     #cr
    72  37f9 203d68                             jsr     outch                           ; outdo
    73                          
    74  37fc 7f1505             crfin           bbr7    channl,prtrts
    75  37ff a90a                               lda     #lf
    76  3801 203d68                             jsr     outch                           ; outdo
    77                          ; eor #$ff  ;????
    78                          
    79  3804 60                 prtrts          rts
    80                          
    81                          
    82                          
    83  3805 38                 comprt          sec
    84  3806 20f0ff                             jsr     _plot                           ; get tab position in x
    85  3809 98                                 tya
    86  380a 38                                 sec
    87  380b e90a               morco1          sbc     #column_width
    88  380d b0fc                               bcs     morco1
    89  380f 49ff                               eor     #$ff
    90  3811 6901                               adc     #1
    91  3813 d017                               bne     aspac
    92                          
    93  3815 08                 taber           php                                     ; remember if SPC(c=0) or TAB(c=1) function
    94  3816 38                                 sec
    95  3817 20f0ff                             jsr     _plot                           ; read tab position
    96  381a 8454                               sty     trmpos
    97  381c 20695d                             jsr     gtbytc                          ; get value into accx
    98  381f c929                               cmp     #')'
    99  3821 d327f6                             +lbne   snerr
   100  3824 28                                 plp
   101  3825 9006                               bcc     xspac
   102  3827 8a                                 txa
   103  3828 e554                               sbc     trmpos
   104  382a 9005                               bcc     notabr                          ; negative, don't print any
   105  382c aa                 aspac           tax
   106  382d e8                 xspac           inx
   107  382e ca                 xspac2          dex
   108  382f d005                               bne     xspac1
   109                          
   110                          
   111  3831 208322             notabr          jsr     chrget                          ; reget last character
   112  3834 809a                               bra     printc                          ; don't call crdo
   113                          
   114                          
   115  3836 205838             xspac1          jsr     outspc
   116  3839 d0f3                               bne     xspac2
   117                          
   118                          
   119                          ; STROUT Routine
   120                          ;
   121                          ; Print the string pointed to by .x.  It must end with a null byte.
   122                          
   123  383b 20855a             strout          jsr     strlit                          ; get a string literal
   124                          
   125  383e 206d5b             strprt          jsr     frefac                          ; return temp pointer
   126  3841 aa                                 tax                                     ; put count into counter
   127  3842 a000                               ldy     #0
   128  3844 e8                                 inx                                     ; move one ahead
   129  3845 ca                 strpr2          dex
   130  3846 f0bc                               beq     prtrts                          ; all done
   131  3848 20d522                             jsr     indin1_ram1                     ; lda (index),y
   132  384b 203d68                             jsr     outch                           ; outdo
   133  384e c8                                 iny
   134  384f c90d                               cmp     #cr
   135  3851 d0f2                               bne     strpr2
   136  3853 20fc37                             jsr     crfin                           ; type rest of carriage return
   137  3856 80ed                               bra     strpr2                          ; and on and on
   138                          
   139  3858 a515               outspc          lda     channl                          ; if terminal print skip chr., else print space
   140  385a d003                               bne     realsp
   141  385c a91d                               lda     #29                             ; CBM cursor right (non-destructive skip char)
   142  385e 2c                                 !text $2c
   143                          
   144  385f a920               realsp          lda     #' '                            ; space
   145  3861 2c                                 !text $2c
   146                          
   147  3862 a93f               outqst          lda     #'?'
   148                          
   149                          ;outdo
   150  3864 4c3d68                             jmp     outch                           ; output char in .a
   151                          ; and #$ff ;????
   152                          ; rts
   153                          
   154                          ;.end
   155                          
   156                          
   157                          ; ********************************************************************************************
   158                          ;
   159                          ;	Date		Changes
   160                          ;	====		=======
   161                          ;
   162                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/text/input.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      input.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14  3867 20e258             get             jsr     errdir                          ; direct mode illegal
    15  386a 8576                               sta     z_p_temp_1                      ; flag to distinguish between GET and GETKEY
    16                          
    17  386c c923                               cmp     #'#'                            ; is it GET# ?
    18  386e f009                               beq     getn                            ; yes
    19  3870 c9f9                               cmp     #key_token                      ; is it GETKEY ?
    20  3872 d015                               bne     gettty                          ; no, must be plain GET
    21  3874 208322                             jsr     chrget                          ; yes, skip over KEY token
    22  3877 8010                               bra     gettty
    23                          
    24                          
    25  3879 208322             getn            jsr     chrget                          ; GET# move up to next byte
    26  387c 206c5d                             jsr     getbyt                          ; get channel into x
    27  387f a92c                               lda     #','                            ; comma?
    28  3881 205d4e                             jsr     synchr
    29  3884 8615                               stx     channl
    30  3886 205268                             jsr     coin                            ; chkin
    31                          
    32                          
    33                          gettty                                                  ; GET
    34  3889 a201                               ldx     #<buf+1                         ; point to 0
    35  388b a002                               ldy     #>buf
    36  388d a900                               lda     #0                              ; to stuff and to point
    37  388f 8d0102                             sta     buf+1                           ; zero it
    38  3892 a940                               lda     #$40                            ; turn on v-bit
    39  3894 201b39                             jsr     inpco1                          ; do the get
    40  3897 a615                               ldx     channl
    41  3899 d019                               bne     release_channels                ; restore terminal channels
    42  389b 60                                 rts
    43                          
    44                          
    45                          linputn                                                 ; input line from channel into a string var
    46  389c 208322                             jsr     chrget                          ; (eat input# token)
    47  389f f787                               smb7    op
    48  38a1 2c                                 !text $2c
    49                          
    50  38a2 7787               inputn          rmb7    op                              ; flag INPUT# vs. LINPUT#
    51  38a4 206c5d                             jsr     getbyt                          ; get channel number
    52  38a7 a92c                               lda     #','                            ; a comma?
    53  38a9 205d4e                             jsr     synchr
    54  38ac 8615                               stx     channl
    55  38ae 205268                             jsr     coin                            ; chkin
    56  38b1 20e938                             jsr     notqti                          ; do input to variables
    57                          
    58                          
    59                          release_channels                                        ; iodone, iorele.
    60  38b4 20ccff                             jsr     _clrch                          ; clear I/O channels
    61                          ; ldx #0   ;restore normal terminal channels
    62  38b7 8515                               sta     channl                          ; (was stx)     [910909]
    63  38b9 60                                 rts
    64                          
    65                          
    66                          linput                                                  ; input line from console into a string var
    67  38ba 208322                             jsr     chrget                          ; (eat input token)
    68  38bd f787                               smb7    op
    69  38bf 2c                                 !text $2c
    70                          
    71  38c0 7787               input           rmb7    op                              ; flag INPUT vs. LINPUT
    72  38c2 c922                               cmp     #'"'                            ; a quote?
    73  38c4 d023                               bne     notqti                          ; no message
    74  38c6 20164e                             jsr     strtxt                          ; literalize the string in text
    75                          
    76  38c9 208522                             jsr     chrgot                          ; looking for prompt string terminator  [910219]
    77  38cc c92c                               cmp     #','
    78  38ce d011                               bne     l55_1
    79  38d0 8dff01                             sta     buf_txtptr                      ; is comma- supress '?' after prompt  [910219]
    80  38d3 208322                             jsr     chrget                          ; eat comma
    81  38d6 203e38                             jsr     strprt                          ; print prompt
    82  38d9 20e258                             jsr     errdir                          ; error if direct mode
    83  38dc 201c31                             jsr     InputLine                       ; get first item
    84  38df 8013                               bra     getagn1                         ; see if there's more to do
    85                          
    86  38e1 a93b               l55_1           lda     #';'                            ; must end in semicolon
    87  38e3 205d4e                             jsr     synchr
    88  38e6 203e38                             jsr     strprt                          ; print prompt
    89                          
    90  38e9 20e258             notqti          jsr     errdir                          ; use common routine since def direct
    91  38ec a92c                               lda     #','                            ; get comma
    92  38ee 8dff01                             sta     buf_txtptr                      ; (data reader expects buffer to start with terminator)
    93                          
    94  38f1 201231             getagn          jsr     PromptedInput                   ; type "?" and input a line of text
    95  38f4 a515               getagn1         lda     channl
    96  38f6 f00d                               beq     l56_1
    97  38f8 20b7ff                             jsr     _readst                         ; get status byte
    98                          ; and #2   ; (assumes serial bus????)  [910618] eoi ok
    99  38fb 2987                               and     #%10000111                      ; serial: err if dnp, r/w timeout errors
   100  38fd f006                               beq     l56_1                           ; a-ok rs232: err if brk, ovr, frm, par errors
   101  38ff 20b438                             jsr     release_channels                ; bad, close channel
   102  3902 8344fc                             +lbra   data                            ; skip rest of input
   103                          
   104  3905 ad0002             l56_1           lda     buf                             ; bufful. get anything?
   105  3908 d00f                               bne     inpcon                          ; yes- process input
   106                          ; lda channl  ;didn't get anything.  is this keyboard? [901212]
   107                          ; bne getagn  ; no- keep looking for data ????
   108  390a 205b35                             jsr     datan                           ; skip to end of statement
   109  390d 833cfc                             +lbra   addon
   110                          
   111                          
   112  3910 7787               read            rmb7    op                              ; flag READ vs. LREAD    [910102]
   113  3912 a643                               ldx     datptr                          ; get last data location
   114  3914 a444                               ldy     datptr+1
   115  3916 a998                               lda     #$98                            ; initiator= read
   116  3918 2c                                 !text $2c
   117                          
   118  3919 a900               inpcon          lda     #0                              ; initiator= input
   119  391b 8513               inpco1          sta     input_flag                      ; $98=read, $40=get, $00=input
   120                          
   121                          ; In the processing of DATA and READ statements, one pointer points to the data
   122                          ; (i.e., the numbers being fetched) and another points to the list of variables.
   123                          ;
   124                          ; The pointer into the data always starts pointing to a terminator- a ",", ":", or EOL.
   125                          ; At this point TXTPTR points to list of variables and (x,y) points to data or input line.
   126                          
   127  391d 8645                               stx     inpptr                          ; pointer to data
   128  391f 8446                               sty     inpptr+1
   129                          
   130  3921 207c4f             inloop          jsr     ptrget                          ; get a pointer to the variable
   131  3924 854b                               sta     forpnt                          ; store its address
   132  3926 844c                               sty     forpnt+1
   133                          
   134  3928 a201                               ldx     #1
   135  392a b53d               l57_1           lda     txtptr,x                        ; move variable list pointer to 'vartxt'
   136  392c 954d                               sta     vartxt,x
   137  392e b545                               lda     inpptr,x                        ; move data line pointer to 'txtptr'
   138  3930 953d                               sta     txtptr,x
   139  3932 ca                                 dex
   140  3933 10f5                               bpl     l57_1
   141                          
   142  3935 208522                             jsr     chrgot                          ; get first data byte
   143  3938 d02f                               bne     datbk1                          ; not null, so we got something
   144  393a 2413                               bit     input_flag                      ; READ($98), GET($40), or INPUT($00)?
   145  393c 501a                               bvc     qdata                           ; branch if READ or INPUT
   146  393e a576                               lda     z_p_temp_1                      ; GET or GETKEY?
   147  3940 c9f9                               cmp     #key_token
   148  3942 d008                               bne     l57_3                           ; branch if GET
   149                          
   150  3944 205b68             l57_2           jsr     cgetl                           ; GETKEY
   151  3947 aa                                 tax                                     ; test if null
   152  3948 f0fa                               beq     l57_2                           ; it is null, keep scanning
   153  394a d003                               bne     l57_4                           ; got a key, go put it in var
   154                          
   155  394c 205b68             l57_3           jsr     cgetl                           ; get a key if pressed, otherwise gets a zero
   156  394f 8d0002             l57_4           sta     buf
   157  3952 a2ff                               ldx     #<buf_txtptr
   158  3954 a001                               ldy     #>buf_txtptr
   159  3956 800d                               bra     datbk
   160                          
   161                          
   162  3958 33f000             qdata           +lbmi   datlop                          ; branch if READ
   163  395b a515                               lda     channl                          ; else it's INPUT
   164  395d d003                               bne     l58_1
   165  395f 206238                             jsr     outqst                          ; console input, so display '? ' prompt
   166                          
   167  3962 201231             l58_1           jsr     PromptedInput                   ; get another line
   168                          
   169  3965 863d               datbk           stx     txtptr                          ; set for CHRGET
   170  3967 843e                               sty     txtptr+1
   171                          
   172  3969 7f8708             datbk1          bbr7    op,l59_1                        ; no chrgot if LINPUT (want leading spaces) [910513]
   173  396c 20a540                             jsr     chargt
   174  396f 208e22                             jsr     chrtst
   175  3972 8003                               bra     l59_2
   176                          
   177  3974 208322             l59_1           jsr     chrget                          ; get next data byte
   178  3977 7f0f32             l59_2           bbr7    valtyp,l59_8                    ; get value type, input a number if numeric
   179  397a 6f1309                             bbr6    input_flag,l59_4                ; branch if not get, set quote
   180  397d e8                                 inx
   181  397e 863d                               stx     txtptr
   182  3980 a900               l59_3           lda     #0                              ; [901212]
   183  3982 850a                               sta     charac
   184  3984 800f                               bra     l59_5
   185                          
   186  3986 ff87f7             l59_4           bbs7    op,l59_3                        ; no terminators if LINPUT or LREAD  [901212]
   187  3989 850a                               sta     charac                          ; setqut.  assume quoted string
   188  398b c922                               cmp     #'"'                            ; terminators ok?
   189  398d f007                               beq     l59_6                           ; yes (sets .c)
   190  398f a93a                               lda     #':'                            ; set terminators to ":" and...
   191  3991 850a                               sta     charac
   192  3993 a92c                               lda     #','                            ; ...comma
   193                          
   194  3995 18                 l59_5           clc                                     ; resetc
   195  3996 850b               l59_6           sta     endchr                          ; nowget
   196  3998 a53d                               lda     txtptr
   197  399a a43e                               ldy     txtptr+1
   198  399c 6900                               adc     #0                              ; .c is set properly above
   199  399e 9001                               bcc     l59_7
   200  39a0 c8                                 iny
   201  39a1 208b5a             l59_7           jsr     strlt2                          ; make a string descriptor for the value & copy if needed
   202  39a4 20224e                             jsr     st2txt                          ; copy strng2 to txtptr (st-2-txt... get it?)
   203  39a7 20b536                             jsr     inpcom                          ; do assignment
   204  39aa 800d                               bra     l59_9
   205                          
   206  39ac ff871d             l59_8           bbs7    op,l59_10                       ; error if LINPUT (string input only)  [901212]
   207  39af a200                               ldx     #0                              ; numins. flag 'text bank' (0)
   208  39b1 208d63                             jsr     fin
   209  39b4 a510                               lda     intflg                          ; set codes on flags
   210  39b6 209336                             jsr     qintgr                          ; go decide on float
   211                          
   212  39b9 208522             l59_9           jsr     chrgot                          ; strdn2. read last character
   213  39bc f041                               beq     trmok                           ; ":" or EOL is ok
   214  39be c92c                               cmp     #','                            ; a comma?
   215  39c0 f03d                               beq     trmok
   216                          
   217  39c2 a513                               lda     input_flag                      ; is this get, read, or input?
   218  39c4 f00a                               beq     l59_11                          ; input
   219  39c6 3004                               bmi     l59_10                          ; read
   220  39c8 a615                               ldx     channl                          ; get. if not kbd, go use 'bad file data error'
   221  39ca d008                               bne     l59_12
   222                          
   223  39cc a216               l59_10          ldx     #errtm                          ; tmerr. 'get from kbd' or 'read' saw a bad type
   224  39ce 8006                               bra     l59_13                          ; always
   225                          
   226  39d0 a515               l59_11          lda     channl
   227  39d2 f005                               beq     l59_14                          ; do again if keybd input
   228  39d4 a218               l59_12          ldx     #errbd                          ; input saw bad file data
   229  39d6 8377f4             l59_13          +lbra   error
   230                          
   231                          
   232  39d9 20dc3c             l59_14          jsr     highlight_text                  ; [911119]
   233  39dc 207dff                             jsr     _primm
   234  39df 3f5245444f204652...                !text "?REDO FROM START",cr,0
   235  39f1 20cb3c                             jsr     highlight_done                  ; [911119]
   236                          
   237  39f4 ad7211             ott             lda     oldtxt
   238  39f7 ac7311                             ldy     oldtxt+1
   239  39fa 853d                               sta     txtptr                          ; put user back to beginning of input
   240  39fc 843e                               sty     txtptr+1
   241  39fe 60                                 rts
   242                          
   243                          
   244                          
   245  39ff a201               trmok           ldx     #1
   246  3a01 b53d               l60_1           lda     txtptr,x
   247  3a03 9545                               sta     inpptr,x                        ; save for more reads
   248  3a05 b54d                               lda     vartxt,x
   249  3a07 953d                               sta     txtptr,x                        ; point to variable list
   250  3a09 ca                                 dex
   251  3a0a 10f5                               bpl     l60_1
   252                          
   253  3a0c 208522                             jsr     chrgot                          ; look at last vartab character
   254  3a0f f006                               beq     l60_2                           ; that's the end of the list
   255  3a11 205b4e                             jsr     chkcom                          ; not end. check for comma
   256  3a14 830bff                             +lbra   inloop
   257                          
   258  3a17 a545               l60_2           lda     inpptr                          ; put away a new data pntr name
   259  3a19 a446                               ldy     inpptr+1
   260  3a1b 7f1305                             bbr7    input_flag,l60_3
   261  3a1e 8543                               sta     datptr
   262  3a20 8444                               sty     datptr+1
   263  3a22 60                                 rts
   264                          
   265  3a23 a000               l60_3           ldy     #0                              ; last data chr could have been ',' or ':' but should be null
   266  3a25 a945                               lda     #inpptr
   267  3a27 20c722                             jsr     lda_far_ram0
   268  3a2a f01d                               beq     l60_4                           ; it is null
   269  3a2c a515                               lda     channl                          ; if not terminal, no type
   270  3a2e d019                               bne     l60_4
   271                          
   272  3a30 20dc3c                             jsr     highlight_text                  ; [911119]
   273  3a33 207dff                             jsr     _primm
   274  3a36 3f45585452412049...                !text "?EXTRA IGNORED", cr,0
   275  3a46 20cb3c                             jsr     highlight_done                  ; [911119]
   276                          
   277  3a49 60                 l60_4           rts                                     ; do next statement
   278                          
   279                          
   280                          ; DATLOP Routine Subroutine to find data.
   281                          ;
   282                          ; The search is made by using the execution code for data to skip over
   283                          ; statements, the start word of each statement is compared with "data_token".
   284                          ; Each new line number is stored in "datlin" so that if any error occurs while
   285                          ; reading data the error message can give the line number of the bad data.
   286                          
   287  3a4a 205b35             datlop          jsr     datan                           ; skip some text
   288  3a4d c8                                 iny
   289  3a4e aa                                 tax                                     ; end of line?
   290  3a4f d016                               bne     l61_1                           ; no
   291  3a51 a20d                               ldx     #errod                          ; yes, "no data" error
   292  3a53 c8                                 iny
   293  3a54 20c522                             jsr     indtxt
   294  3a57 f3f6f3                             +lbeq   error
   295                          
   296  3a5a c8                                 iny
   297  3a5b 20c522                             jsr     indtxt                          ; get high byte of line number
   298  3a5e 8541                               sta     datlin
   299  3a60 c8                                 iny
   300  3a61 20c522                             jsr     indtxt                          ; get low byte
   301  3a64 c8                                 iny
   302  3a65 8542                               sta     datlin+1
   303                          
   304  3a67 204b35             l61_1           jsr     addon                           ; nowlin.  txtptr+.y
   305  3a6a 208522                             jsr     chrgot                          ; span blanks
   306  3a6d aa                                 tax                                     ; used later
   307  3a6e e083                               cpx     #data_token                     ; is it a DATA statement?
   308  3a70 d0d8                               bne     datlop                          ; not quite right, keep looking
   309  3a72 83f5fe                             +lbra   datbk1                          ; this is the one
   310                          
   311                          
   312                          ;.end
   313                          
   314                          ; ********************************************************************************************
   315                          ;
   316                          ;	Date		Changes
   317                          ;	====		=======
   318                          ;
   319                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/next.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      next.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Next routine
    16                          ;
    17                          ; 'FOR' entry on the stack has the following format:
    18                          ;
    19                          ; Low address
    20                          ;  token (for_token) 1 byte
    21                          ;  a pointer to the loop variable 2 bytes
    22                          ;  the step 5 bytes
    23                          ;  a byte reflecting the sign of the incr. 2 bytes
    24                          ;  the upper value (packed) 5 bytes
    25                          ;  the line number of the FOR statement 2 bytes
    26                          ;  a text pointer into the FOR statement 2 bytes
    27                          ; High address
    28                          ;
    29                          ; (total 16 bytes)
    30                          
    31  3a75 d013               next            bne     l62_2                           ; hop if 'next' variable given
    32  3a77 a0ff                               ldy     #$ff                            ; flag no specific 'for' variable
    33  3a79 8014                               bra     l62_3                           ; always
    34                          
    35  3a7b a012               l62_1           ldy     #lenfor                         ; done, clean up stack
    36  3a7d 20ef31                             jsr     rlsstk                          ; release (y) items from stack
    37  3a80 208522                             jsr     chrgot
    38  3a83 c92c                               cmp     #','                            ; ie., NEXT j,k
    39  3a85 d069                               bne     l62_7
    40  3a87 208322                             jsr     chrget
    41                          
    42  3a8a 207c4f             l62_2           jsr     ptrget                          ; get pointer to variable in (a,y)
    43  3a8d 854b                               sta     forpnt
    44                          
    45  3a8f 844c               l62_3           sty     forpnt+1
    46  3a91 a981                               lda     #for_token
    47  3a93 204331                             jsr     search                          ; look for FOR entry in run-time stack
    48  3a96 f005                               beq     l62_4                           ; branch if found
    49  3a98 a20a                               ldx     #errnf                          ; otherwise 'error, not found'
    50  3a9a 83b3f3                             +lbra   error
    51                          
    52                          
    53                          ; Set up to move STEP value to FAC
    54                          
    55  3a9d 20e631             l62_4           jsr     movfnd                          ; (fndpnt) => (tos)
    56  3aa0 a53f                               lda     fndpnt
    57  3aa2 18                                 clc
    58  3aa3 6903                               adc     #3                              ; offset to step value
    59  3aa5 a440                               ldy     fndpnt+1
    60  3aa7 9001                               bcc     l62_5
    61  3aa9 c8                                 iny
    62                          
    63  3aaa 200e62             l62_5           jsr     movfm                           ; actually "move from ROM", but sys stack is in "common"
    64  3aad a008                               ldy     #8                              ; MOVFM doesn't move sign.  Get it
    65  3aaf b13f                               lda     (fndpnt),y
    66  3ab1 8568                               sta     facsgn
    67                          
    68                          ; Get pointer to FOR variable
    69                          
    70  3ab3 a001                               ldy     #1
    71  3ab5 b13f                               lda     (fndpnt),y                      ; get lsb
    72  3ab7 48                                 pha
    73  3ab8 aa                                 tax
    74  3ab9 c8                                 iny
    75  3aba b13f                               lda     (fndpnt),y                      ; get msb
    76  3abc 48                                 pha
    77  3abd a8                                 tay                                     ; msb in y
    78  3abe 8a                                 txa                                     ; lsb in a
    79  3abf 20bb5d                             jsr     fadd                            ; add STEP value to FOR variable (fadd gets from bank 1)
    80  3ac2 7a                                 ply                                     ; msb in y
    81  3ac3 fa                                 plx                                     ; lsb in x
    82  3ac4 206262                             jsr     movmf_ram1                      ; put result back into FOR variable in var bank
    83                          
    84                          ; Make (a,y) point at TO value in stack
    85                          
    86  3ac7 a53f                               lda     fndpnt
    87  3ac9 18                                 clc
    88  3aca 6909                               adc     #9
    89  3acc a440                               ldy     fndpnt+1
    90  3ace 9001                               bcc     l62_6
    91  3ad0 c8                                 iny
    92                          
    93                          ; Test if loop done
    94                          
    95                          l62_6
    96                          ; sta sw_rom_ram0 ;????
    97  3ad1 20f162                             jsr     fcomp                           ; compare FAC to value pointed to by (a,y)
    98  3ad4 a008                               ldy     #8
    99  3ad6 38                                 sec
   100  3ad7 f13f                               sbc     (fndpnt),y                      ; (common area????)
   101  3ad9 f0a0                               beq     l62_1                           ; branch taken if done
   102                          
   103  3adb a011                               ldy     #17                             ; not done, set pointers to re-execute loop
   104  3add b13f                               lda     (fndpnt),y                      ; (common area????)
   105  3adf 853d                               sta     txtptr
   106  3ae1 88                                 dey
   107  3ae2 b13f                               lda     (fndpnt),y
   108  3ae4 853e                               sta     txtptr+1
   109  3ae6 88                                 dey
   110  3ae7 b13f                               lda     (fndpnt),y
   111  3ae9 853c                               sta     curlin+1
   112  3aeb 88                                 dey
   113  3aec b13f                               lda     (fndpnt),y
   114  3aee 853b                               sta     curlin
   115  3af0 60                 l62_7           rts
   116                          
   117                          ;.end
   118                          
   119                          ; ********************************************************************************************
   120                          ;
   121                          ;	Date		Changes
   122                          ;	====		=======
   123                          ;
   124                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/dim.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      dim.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; The DIMension code sets DIMFLG and then falls into the variable search
    16                          ; routine, which looks at DIMFLG at 3 different points:
    17                          ;
    18                          ; 1) If an entry is found, DIMFLG being on indicates a
    19                          ;    doubly-defined variable.
    20                          ; 2) When a new entry is being built, DIMFLG being on indicates
    21                          ;    the indices should be used for the size of each index.
    22                          ;    Otherwise the default of ten is used.
    23                          ; 3) When the build entry code finishes, indexing will be done
    24                          ;    only if DIMFLG is off.
    25                          
    26                          
    27  3af1 205b4e             dim3            jsr     chkcom                          ; must be a comma
    28                          
    29  3af4 aa                 dim             tax                                     ; make .x non-zero (.a must be non-zero to work correctly)
    30  3af5 20814f                             jsr     ptrgt1
    31  3af8 208522                             jsr     chrgot                          ; get last character
    32  3afb d0f4                               bne     dim3
    33  3afd 60                                 rts
    34                          
    35                          ;.end
    36                          
    37                          ; ********************************************************************************************
    38                          ;
    39                          ;	Date		Changes
    40                          ;	====		=======
    41                          ;
    42                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/sys.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      sys.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15  3afe 208a5d             sys             jsr     getwrd                          ; convert arg to integer value
    16  3b01 a516                               lda     linnum                          ; set up arg's for call to 'long jsr'
    17  3b03 8504                               sta     _pclo
    18  3b05 a517                               lda     linnum+1
    19  3b07 8503                               sta     _pchi
    20  3b09 add102                             lda     current_bank
    21  3b0c 8502                               sta     _bank
    22                          
    23  3b0e 202679                             jsr     optbyt                          ; (optional) .A reg arg
    24  3b11 9002                               bcc     l63_1
    25  3b13 8606                               stx     _a_reg
    26                          
    27  3b15 202679             l63_1           jsr     optbyt                          ; (optional) .X reg arg
    28  3b18 9002                               bcc     l63_2
    29  3b1a 8607                               stx     _x_reg
    30                          
    31  3b1c 202679             l63_2           jsr     optbyt                          ; (optional) .Y reg arg
    32  3b1f 9009                               bcc     l63_4
    33  3b21 8608                               stx     _y_reg
    34                          
    35  3b23 202679             l63_3           jsr     optbyt                          ; (optional) .Z reg arg
    36  3b26 9002                               bcc     l63_4
    37  3b28 8609                               stx     _z_reg
    38                          
    39  3b2a 202679             l63_4           jsr     optbyt                          ; (optional) .S reg arg
    40  3b2d 9002                               bcc     l63_5
    41  3b2f 8605                               stx     _s_reg
    42                          
    43  3b31 4c6eff             l63_5           jmp     _jsr_far                        ; far, far away
    44                          ;If returns, Kernel will update _reg's for us
    45                          
    46                          ;.end
    47                          
    48                          ; ********************************************************************************************
    49                          ;
    50                          ;	Date		Changes
    51                          ;	====		=======
    52                          ;
    53                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/dma.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      dma.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; DMA - Set up for DMA operation (FETCH/STASH/SWAP)
    16                          ;
    17                          ;  Syntax:  DMA  command,length,source(l/h/b),destination(l/h/b)[,subcmd,mod(l/h)] [,...]
    18                          
    19                          
    20                          dma                                                     ; params are not longer optional-  [910520] F018A
    21  3b34 206c5d                             jsr     getbyt                          ; get command
    22  3b37 9009               l64_1           bcc     l64_2
    23  3b39 8a                                 txa                                     ; [910102]
    24  3b3a 2904                               and     #%00000100                      ;
    25  3b3c d3c016                             +lbne   fcerr                           ; (disallow chained DMA lists)
    26  3b3f 8e5001                             stx     dma2_cmd
    27                          
    28  3b42 20875d             l64_2           jsr     comwrd                          ; get length
    29                          ; bcc l64_3
    30  3b45 8c5101                             sty     dma2_cnt_lo
    31  3b48 8d5201                             sta     dma2_cnt_hi
    32                          
    33  3b4b 20875d             l64_3           jsr     comwrd                          ; get source address & bank
    34                          ; bcc l64_4
    35  3b4e 8c5301                             sty     dma2_src_lo
    36  3b51 8d5401                             sta     dma2_src_hi
    37  3b54 20825d             l64_4           jsr     combyt
    38                          ; bcc l64_5
    39  3b57 8e5501                             stx     dma2_src_bank
    40                          
    41  3b5a 20875d             l64_5           jsr     comwrd                          ; get destination address & bank
    42                          ; bcc l64_6
    43  3b5d 8c5601                             sty     dma2_dest_lo
    44  3b60 8d5701                             sta     dma2_dest_hi
    45  3b63 20825d             l64_6           jsr     combyt
    46                          ; bcc l64_7
    47  3b66 8e5801                             stx     dma2_dest_bank
    48                          
    49  3b69 202479             l64_7           jsr     optzer                          ; get subcmd, default=0    [910520] F018A
    50                          ; bcc l64_8
    51  3b6c 8e5901                             stx     dma2_subcmd
    52                          
    53  3b6f 202479             l64_8           jsr     optzer                          ; get mod lo/hi, default=0   [910102]
    54                          ; bcc l64_9
    55  3b72 8e5a01                             stx     dma2_mod_lo
    56  3b75 202479             l64_9           jsr     optzer
    57                          ; bcc l64_10
    58  3b78 8e5b01                             stx     dma2_mod_hi
    59                          
    60  3b7b a000               l64_10          ldy     #0                              ; dma_list (bank 0)
    61  3b7d a201                               ldx     #>dma2_cmd
    62  3b7f a950                               lda     #<dma2_cmd
    63  3b81 8c02d7                             sty     dma_ctlr+2                      ; dma_list bank
    64  3b84 8e01d7                             stx     dma_ctlr+1                      ; dma_list hi
    65  3b87 8d00d7                             sta     dma_ctlr                        ; dma_list lo & trigger
    66  3b8a 2c03d7             l64_11          bit     dma_ctlr+3                      ; check status (in case IRQ enabled)  [910103]
    67  3b8d 30fb                               bmi     l64_11                          ; busy
    68                          
    69  3b8f 208522                             jsr     chrgot                          ; eol?
    70  3b92 f005                               beq     l64_12                          ; yes
    71  3b94 202679                             jsr     optbyt                          ; no- continue after getting comma & next cmd byte
    72  3b97 809e                               bra     l64_1
    73                          
    74  3b99 60                 l64_12          rts
    75                          
    76                          ;.end
    77                          
    78                          ; ********************************************************************************************
    79                          ;
    80                          ;	Date		Changes
    81                          ;	====		=======
    82                          ;
    83                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/trace.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      trace.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          
    16                          tron                                                    ; trace mode on
    17  3b9a d77e                               smb5    runmod                          ; trcflg
    18  3b9c 60                                 rts
    19                          
    20                          
    21                          troff                                                   ; trace mode off
    22  3b9d 577e                               rmb5    runmod                          ; trcflg
    23  3b9f 60                                 rts
    24                          
    25                          
    26                          ;.end
    27                          
    28                          ; ********************************************************************************************
    29                          ;
    30                          ;	Date		Changes
    31                          ;	====		=======
    32                          ;
    33                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/sys/returnreg.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      returnreg.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; RREG - Return values of 6502 registers following a SYS call.
    16                          ;
    17                          ; Syntax : RREG [.A variable [,[.X[...Z] variable] [,[.S variable] ]]]
    18                          
    19  3ba0 a900               rreg            lda     #0
    20  3ba2 850d                               sta     count
    21                          
    22  3ba4 208522             l65_1           jsr     chrgot
    23  3ba7 f038                               beq     l65_4                           ; reached end of statement- done
    24  3ba9 c92c                               cmp     #','                            ; skip this arg?
    25  3bab f022                               beq     l65_3                           ; branch if so
    26  3bad 207c4f                             jsr     ptrget                          ; get pointer to target variable
    27  3bb0 854b                               sta     forpnt                          ; a little bit of set up so we can share LET code
    28  3bb2 844c                               sty     forpnt+1
    29  3bb4 a50f                               lda     valtyp                          ; what kind of variable name did ptrget find?
    30  3bb6 d32f11                             +lbne   chkerr                          ; type mismatch error if string
    31                          
    32  3bb9 a40d                               ldy     count                           ; which register's value are we looking for?
    33  3bbb b90600                             lda     _a_reg,y                        ; .A, .X, .Y, & .Z are contiguious
    34  3bbe c004                               cpy     #4
    35  3bc0 d002                               bne     l65_2
    36  3bc2 a505                               lda     _s_reg                          ; but .S isn't
    37                          
    38  3bc4 a8                 l65_2           tay                                     ; low byte in .Y
    39  3bc5 a900                               lda     #0                              ; high byte of zero
    40  3bc7 203f4e                             jsr     givayf                          ; go float it
    41  3bca a510                               lda     intflg                          ; set conditions for type of var (int/float)
    42  3bcc 209336                             jsr     qintgr                          ; ..and use part of LET to do the work
    43                          
    44  3bcf e60d               l65_3           inc     count                           ; 5 registers to do
    45  3bd1 a50d                               lda     count
    46  3bd3 c905                               cmp     #5
    47  3bd5 b00a                               bcs     l65_4
    48  3bd7 208522                             jsr     chrgot                          ; was this e-o-statement?
    49  3bda f005                               beq     l65_4
    50  3bdc 208322                             jsr     chrget                          ; not e-o-s, skip over comma,
    51  3bdf d0c3                               bne     l65_1                           ; ..and go do next
    52                          
    53  3be1 60                 l65_4           rts
    54                          
    55                          ;.end
    56                          
    57                          ; ********************************************************************************************
    58                          ;
    59                          ;	Date		Changes
    60                          ;	====		=======
    61                          ;
    62                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/let/midstring.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      midstring.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Alternate use of the MID$ function, as the target of an assignment.
    16                          ;
    17                          ; MID$(string_var,starting_position [,length]) = string_expression
    18                          
    19                          midd2
    20                          midwrk          =midd2-1
    21                          
    22  3be2 20584e                             jsr     chkopn                          ; check for '('
    23  3be5 207c4f                             jsr     ptrget                          ; get pointer to descriptor of string-var
    24  3be8 854b                               sta     forpnt                          ; store for later use
    25  3bea 844c                               sty     forpnt+1
    26  3bec 20dd4c                             jsr     chkstr                          ; check if string
    27                          
    28  3bef 20825d                             jsr     combyt                          ; look for comma, followed by 1 byte starting address
    29  3bf2 ca                                 dex                                     ; adjust starting addr
    30  3bf3 8677                               stx     hulp                            ; store    " "
    31                          
    32  3bf5 c929                               cmp     #')'                            ; finished?
    33  3bf7 f004                               beq     l66_1                           ; branch if so (use default length)
    34  3bf9 20825d                             jsr     combyt                          ; ..else get length
    35  3bfc 2c                                 !text $2c
    36                          
    37  3bfd a2ff               l66_1           ldx     #$ff                            ; default length
    38  3bff 8676                               stx     z_p_temp_1
    39  3c01 20554e                             jsr     chkcls                          ; look for ')'
    40  3c04 a9b2                               lda     #equal_token                    ; look for '='
    41  3c06 205d4e                             jsr     synchr
    42  3c09 20ef4c                             jsr     frmevl                          ; bring on the source!
    43  3c0c 20dd4c                             jsr     chkstr                          ; nothing funny
    44                          
    45  3c0f a002                               ldy     #2                              ; get string descriptors
    46  3c11 a94b               l66_2           lda     #forpnt                         ; target
    47  3c13 20d722                             jsr     lda_far_ram1                    ; lda (forpnt),y
    48  3c16 995d00                             sta     str1,y
    49  3c19 20a922                             jsr     indfmo                          ; source
    50  3c1c 996000                             sta     str2,y
    51  3c1f 88                                 dey
    52  3c20 10ef                               bpl     l66_2
    53                          
    54                          ; Test for target string in text was removed-  all strings are copied to
    55                          ; string RAM when they are created.
    56                          
    57  3c22 38                                 sec                                     ; adjust pointer to source string so that the same
    58  3c23 a561                               lda     str2+1                          ; ..index can load & save
    59  3c25 e577                               sbc     hulp
    60  3c27 8561                               sta     str2+1
    61  3c29 b002                               bcs     l66_3
    62  3c2b c662                               dec     str2+2
    63                          
    64  3c2d a576               l66_3           lda     z_p_temp_1                      ; get specified length (or default)
    65  3c2f c560                               cmp     str2                            ; compare with length of source
    66  3c31 9002                               bcc     l66_4                           ; ok if less,
    67  3c33 a560                               lda     str2                            ; ..else use length of source
    68  3c35 aa                 l66_4           tax
    69  3c36 f01f                               beq     l66_7                           ; done if length=0
    70  3c38 18                                 clc
    71  3c39 6577                               adc     hulp                            ; add length to starting posn.
    72  3c3b b3c115                             +lbcs   fcerr                           ; illegal quantity error if > 256
    73  3c3e c55d                               cmp     str1
    74  3c40 9003                               bcc     l66_5
    75  3c42 d3ba15                             +lbne   fcerr                           ; ...or if > target length
    76                          
    77  3c45 a477               l66_5           ldy     hulp                            ; get adjusted starting address
    78  3c47 da                 l66_6           phx
    79  3c48 a25e                               ldx     #str1+1
    80  3c4a a961                               lda     #str2+1
    81  3c4c 20d722                             jsr     lda_far_ram1                    ; fetch from string bank
    82  3c4f 20f022                             jsr     sta_far_ram1                    ; this is what it's all about
    83  3c52 c8                                 iny
    84  3c53 fa                                 plx
    85  3c54 ca                                 dex
    86  3c55 d0f0                               bne     l66_6                           ; keep going for specified length
    87                          
    88  3c57 83141f             l66_7           +lbra   frefac                          ; free up temp. string, rts
    89                          
    90                          ;.end
    91                          
    92                          ; ********************************************************************************************
    93                          ;
    94                          ;	Date		Changes
    95                          ;	====		=======
    96                          ;
    97                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/auto.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      auto.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; AUTO Increment
    16                          ;   Syntax :    auto {line-number} (line-number = 0 means turn off)
    17                          
    18                          auto
    19  3c5a 20ed58                             jsr     errind
    20  3c5d 202e32                             jsr     linget
    21  3c60 a516                               lda     linnum
    22  3c62 8574                               sta     autinc
    23  3c64 a517                               lda     linnum+1
    24  3c66 8575                               sta     autinc+1
    25  3c68 60                                 rts
    26                          
    27                          ;.end
    28                          
    29                          
    30                          
    31  3c69 aec702             help            ldx     errnum                          ; check for error status
    32  3c6c e8                                 inx
    33  3c6d f022                               beq     l67_1                           ; exit if there is no current error
    34  3c6f adc802                             lda     errlin
    35  3c72 acc902                             ldy     errlin+1
    36  3c75 8516                               sta     linnum
    37  3c77 8417                               sty     linnum+1
    38  3c79 20fa31                             jsr     FindLine                        ; find the beginning of line with error
    39  3c7c 9013                               bcc     l67_1                           ; exit if line not found?
    40                          
    41  3c7e 20f737                             jsr     crdo                            ; begin a new line
    42  3c81 a616                               ldx     linnum
    43  3c83 a517                               lda     linnum+1
    44  3c85 ab5500                             ldz     helper
    45  3c88 4755                               rmb4    helper                          ; temporarily disable token highlighting
    46  3c8a f755                               smb7    helper                          ; set 'help' flag for P1LINE
    47  3c8c 207733                             jsr     p1line                          ; display line & highlight error
    48  3c8f 6455                               stz     helper
    49  3c91 7755               l67_1           rmb7    helper                          ; reset 'help' flag
    50  3c93 8362fb                             +lbra   crdo                            ; and return to caller
    51                          
    52                          
    53                          
    54                          helpsb                                                  ; logic to highlight error or find string
    55  3c96 cf5532                             bbs4    helper,highlight_done           ; branch if highlighting tokens
    56  3c99 df5514                             bbs5    helper,l68_3                    ; branch if FIND
    57                          
    58  3c9c a662                               ldx     lowtr+1                         ; has P1LINE reached code in error?
    59  3c9e 98                                 tya
    60  3c9f 18                                 clc
    61  3ca0 6561                               adc     lowtr                           ; add character pointer to line pointer...
    62  3ca2 9001                               bcc     l68_1
    63  3ca4 e8                                 inx
    64  3ca5 ecce02             l68_1           cpx     errtxt+1                        ; and compare to error pointer
    65  3ca8 d005                               bne     l68_2                           ; not there
    66  3caa cdcd02                             cmp     errtxt
    67  3cad b02d                               bcs     highlight_text                  ; we're there- begin highlighting
    68  3caf 60                 l68_2           rts
    69                          
    70                          
    71  3cb0 c43f               l68_3           cpy     fndpnt                          ; at first character of find string?
    72  3cb2 9013                               bcc     l68_5                           ; before it
    73  3cb4 adda02                             lda     find_count
    74  3cb7 f00e                               beq     l68_5                           ; past it
    75  3cb9 300d                               bmi     l68_6                           ; at last character
    76  3cbb c58a                               cmp     fstr1+2
    77  3cbd 9003                               bcc     l68_4                           ; in middle of string
    78  3cbf 20dc3c                             jsr     highlight_text                  ; at first char- start highlight
    79  3cc2 ceda02             l68_4           dec     find_count                      ; one less character to highlight
    80  3cc5 f0fb                               beq     l68_4                           ; special case-
    81                          ;make it negative for next time around
    82  3cc7 60                 l68_5           rts
    83                          
    84  3cc8 eeda02             l68_6           inc     find_count                      ; make it zero
    85                          
    86                          
    87                          highlight_done                                          ; nasty kludge to colorize error or found text
    88  3ccb add902                             lda     highlight_save
    89  3cce 300b                               bmi     l69_1                           ; (unless it's already normal)
    90  3cd0 85f1                               sta     _color                          ; restore normal color
    91  3cd2 0980                               ora     #$80
    92  3cd4 8dd902                             sta     highlight_save                  ; mark highlight_save invalid
    93  3cd7 7755                               rmb7    helper                          ; remove HELP flag
    94  3cd9 1755                               rmb1    helper                          ; remove token flag
    95  3cdb 60                 l69_1           rts
    96                          
    97                          
    98                          highlight_text                                          ; nasty kludge to colorize error or found text
    99  3cdc 2cd902                             bit     highlight_save
   100  3cdf 100a                               bpl     l70_1                           ; (unless it's already highlighted)
   101  3ce1 a5f1                               lda     _color                          ; save current (normal) color
   102  3ce3 8dd902                             sta     highlight_save                  ; msb=0 to mark highlight_save valid
   103  3ce6 add802                             lda     highlight_color
   104  3ce9 85f1                               sta     _color                          ; change color to highlight
   105  3ceb 60                 l70_1           rts
   106                          
   107                          ;.end
   108                          
   109                          ; ********************************************************************************************
   110                          ;
   111                          ;	Date		Changes
   112                          ;	====		=======
   113                          ;
   114                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/gotosub.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      gotosub.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; GOSUB-  Push text pointer, line #, & gosub token on stack:
    16                          ;
    17                          ;  (bottom) highest memory
    18                          ;===========================================================
    19                          ;  txtptr+1 address of next statement
    20                          ;  txtptr
    21                          ;  ========
    22                          ;  curlin+1 current line number
    23                          ;  curlin
    24                          ;  ========
    25                          ;  'gosub' token <== (tos) top of stack pointer
    26                          ;===========================================================
    27                          ;  (top of stack) lowest memory
    28                          
    29                          
    30  3cec cf7e6a             gosub           bbs4    runmod,edit_err                 ; [910620]
    31  3cef 20393d                             jsr     gosub_sub
    32  3cf2 208522                             jsr     chrgot                          ; get character and set carry for linget
    33  3cf5 20fb3c                             jsr     goto
    34  3cf8 8313ef                             +lbra   newstt
    35                          
    36                          
    37  3cfb cf7e5b             goto            bbs4    runmod,edit_err                 ; [910620]
    38  3cfe 202e32                             jsr     linget                          ; pick up the line number in LINNUM
    39  3d01 a50b                               lda     endchr                          ; test if linget found any number
    40  3d03 f345f1                             +lbeq   snerr                           ; no number error
    41                          
    42  3d06 205e35             goto_1          jsr     remn                            ; jump to end of line (entry for interrupt code)
    43  3d09 38                                 sec
    44  3d0a a53b                               lda     curlin
    45  3d0c e516                               sbc     linnum
    46  3d0e a53c                               lda     curlin+1
    47  3d10 e517                               sbc     linnum+1
    48  3d12 b00b                               bcs     luk4it
    49  3d14 98                                 tya
    50  3d15 38                                 sec
    51  3d16 653d                               adc     txtptr
    52  3d18 a63e                               ldx     txtptr+1
    53  3d1a 9007                               bcc     lukall
    54  3d1c e8                                 inx
    55  3d1d 8004                               bra     lukall                          ; always goes
    56                          
    57                          
    58  3d1f a52d               luk4it          lda     txttab
    59  3d21 a62e                               ldx     txttab+1
    60                          
    61  3d23 20fe31             lukall          jsr     FindLink                        ; (a,x) are all set up
    62  3d26 9316f1                             +lbcc   userr                           ; undefined statement error
    63  3d29 a561                               lda     lowtr
    64  3d2b e901                               sbc     #1
    65  3d2d 853d                               sta     txtptr
    66  3d2f a562                               lda     lowtr+1
    67  3d31 e900                               sbc     #0
    68  3d33 853e                               sta     txtptr+1
    69  3d35 7f7e63                             bbr7    runmod,setexc                   ; branch if in direct mode
    70  3d38 60                                 rts
    71                          
    72                          
    73                          
    74                          gosub_sub
    75  3d39 a905                               lda     #lengos                         ; free up necessary space on stack
    76  3d3b 209431                             jsr     getstk                          ; make sure there is room
    77  3d3e a004                               ldy     #lengos-1
    78  3d40 a53e                               lda     txtptr+1                        ; push on the text pointer
    79  3d42 917c                               sta     (tos),y                         ; (common area)
    80  3d44 88                                 dey
    81  3d45 a53d                               lda     txtptr
    82  3d47 917c                               sta     (tos),y                         ; (common area)
    83  3d49 88                                 dey
    84  3d4a a53c                               lda     curlin+1                        ; push on the current line number
    85  3d4c 917c                               sta     (tos),y                         ; (common area)
    86  3d4e 88                                 dey
    87  3d4f a53b                               lda     curlin
    88  3d51 917c                               sta     (tos),y                         ; (common area)
    89  3d53 88                                 dey
    90  3d54 a98d                               lda     #gosub_token                    ; (a) was smashed by GETSTK
    91  3d56 917c                               sta     (tos),y                         ; (common area)
    92  3d58 60                                 rts
    93                          
    94                          
    95                          edit_err
    96  3d59 a22a                               ldx     #edit_mode_error                ; [910620]
    97  3d5b 83f2f0                             +lbra   error
    98                          
    99                          ;.end
   100                          
   101                          
   102                          
   103                          go_without_to
   104  3d5e 208322                             jsr     chrget                          ; what is next character?
   105  3d61 c9a4                               cmp     #to_token                       ; ..is it GO TO?
   106  3d63 d005                               bne     l71_1
   107  3d65 208322                             jsr     chrget                          ; ..yes, set up for goto
   108  3d68 8091                               bra     goto                            ; ..bye!
   109                          
   110  3d6a 206c5d             l71_1           jsr     getbyt                          ; is it GO 64?
   111  3d6d e040                               cpx     #64
   112  3d6f d3d9f0                             +lbne   snerr                           ; ...no, error
   113                          
   114                          ; The user wants to go to C64 mode.
   115                          
   116  3d72 20c378             l71_2           jsr     are_you_sure
   117  3d75 d03c                               bne     cont_rts                        ; must have had second thoughts. never mind
   118                          ; jsr put_io_in_map
   119  3d77 4c53ff                             jmp     _go_64
   120                          
   121                          
   122                          ;.end
   123                          
   124                          ; ********************************************************************************************
   125                          ;
   126                          ;	Date		Changes
   127                          ;	====		=======
   128                          ;
   129                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/continue.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      continue.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;**********************************************************
    15                          ;*
    16                          ;* CONTINUE Execution after STOP/END
    17                          ;*
    18                          ;**********************************************************
    19                          
    20  3d7a d037               cont            bne     cont_rts                        ; make sure there is a terminator
    21  3d7c cf7eda                             bbs4    runmod,edit_err                 ; [910620]
    22  3d7f ff7e31                             bbs7    runmod,cont_rts                 ; if in run-mode just rts
    23                          
    24  3d82 a21a                               ldx     #errcn                          ; continue error.
    25  3d84 ac7311                             ldy     oldtxt+1                        ; a stored txtptr of zero set up by INIT_STACK
    26  3d87 f3c6f0                             +lbeq   error                           ; indicates there is nothing to continue
    27                          
    28  3d8a ad7211                             lda     oldtxt                          ; STOP, END, typing crlf to INPUT, and STOP key
    29  3d8d 853d                               sta     txtptr
    30  3d8f 843e                               sty     txtptr+1
    31  3d91 ad7011                             lda     oldlin
    32  3d94 ac7111                             ldy     oldlin+1
    33  3d97 853b                               sta     curlin
    34  3d99 843c                               sty     curlin+1
    35                          
    36  3d9b f77e               setexc          smb7    runmod                          ; set up run mode
    37  3d9d a900                               lda     #0
    38  3d9f 8574                               sta     autinc                          ; turn auto increment off
    39  3da1 8575                               sta     autinc+1
    40  3da3 8ddc02                             sta     intval                          ; enable & reset collision-trapping mechanism
    41  3da6 85f6                               sta     _autoinsert                     ; disable auto-insert mode ?????
    42                          
    43  3da8 a202                               ldx     #2                              ; turn off all interrupt trip flags
    44  3daa 9ddd02             l72_1           sta     int_trip_flag,x
    45  3dad ca                                 dex
    46  3dae 10fa                               bpl     l72_1
    47                          
    48  3db0 2090ff                             jsr     _setmsg                         ; turn kernel messages off & rts
    49                          
    50                          cont_rts
    51  3db3 60                                 rts
    52                          
    53                          ;.end
    54                          
    55                          ; ********************************************************************************************
    56                          ;
    57                          ;	Date		Changes
    58                          ;	====		=======
    59                          ;
    60                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/run.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      run.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;***********************************************************
    15                          ;*
    16                          ;* RUN Command
    17                          ;*
    18                          ;* RUN [line_number]
    19                          ;* RUN filename [[ON] Ddrive_number[,Uunit_number]]
    20                          ;*
    21                          ;* Entry:  RUN_A_PROGRAM sets up, links, and executes
    22                          ;*  a program previously loaded into RAM.
    23                          ;*
    24                          ;***********************************************************
    25                          
    26  3db4 cf7ea2             run             bbs4    runmod,edit_err                 ; [910620]
    27  3db7 f019                               beq     run__10                         ; branch if no arguments
    28  3db9 901d                               bcc     run__20                         ; branch if number (i.e., RUN line_number)
    29                          
    30                          
    31                          ; Here if of the form "RUN file_name"
    32                          
    33  3dbb e77e                               smb6    runmod                          ; set flag for load not to go to ready
    34  3dbd 206971                             jsr     dload                           ; use DLOAD's parser, and load the program
    35  3dc0 b3742a                             +lbcs   erexit                          ; if problem loading   [900801]
    36                          
    37                          run_a_program
    38  3dc3 20f737                             jsr     crdo                            ; [911010]
    39  3dc6 203e42                             jsr     fix_links                       ; re-link the program
    40  3dc9 209b3d                             jsr     setexc                          ; set various run modes
    41  3dcc 20a134                             jsr     runc
    42  3dcf 833cee                             +lbra   newstt                          ; start executing
    43                          
    44                          
    45                          ; Here if of the form "RUN"
    46                          
    47  3dd2 209b3d             run__10         jsr     setexc                          ; set various run codes
    48  3dd5 83caf6                             +lbra   runc                            ; ..and start executing
    49                          
    50                          
    51                          ; Here if of the form "RUN line_number"
    52                          
    53  3dd8 20cb34             run__20         jsr     clearc                          ; first trash all variables
    54  3ddb 208522                             jsr     chrgot
    55  3dde 20fb3c                             jsr     goto                            ; set up to execute from new line number
    56  3de1 209b3d                             jsr     setexc                          ; ..and do a little housekeeping,
    57  3de4 8327ee                             +lbra   newstt                          ; ..otherwise it's business as usual
    58                          
    59                          ;.end
    60                          
    61                          ; ********************************************************************************************
    62                          ;
    63                          ;	Date		Changes
    64                          ;	====		=======
    65                          ;
    66                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/restore.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      restore.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;*********************************************************************
    15                          ;*
    16                          ;* RESTORE Command
    17                          ;*
    18                          ;* Reset pointers to next DATA statement.  Allows optional argument
    19                          ;* specifying a specific line number, otherwise the default is the
    20                          ;* beginning of text area.
    21                          ;*
    22                          ;*********************************************************************
    23                          
    24                          restor
    25  3de7 f013                               beq     restore__1                      ; branch if no argument...use default
    26  3de9 208a5d                             jsr     getwrd                          ; get 2 byte argument (???? no check for real number means a var legal)
    27  3dec 8416                               sty     linnum
    28  3dee 8517                               sta     linnum+1
    29  3df0 20fa31                             jsr     FindLine                        ; get pointer to specified line
    30  3df3 9349f0                             +lbcc   userr                           ; error if not found
    31                          
    32  3df6 a561                               lda     lowtr                           ; decrement 2 byte pointer, and save it
    33  3df8 a462                               ldy     lowtr+1
    34  3dfa 8005                               bra     restore__2                      ; always
    35                          
    36                          
    37                          restore__1                                              ; entry from FLOAD
    38  3dfc 38                                 sec
    39  3dfd a52d                               lda     txttab
    40  3dff a42e                               ldy     txttab+1
    41                          
    42                          restore__2
    43  3e01 e901                               sbc     #1
    44  3e03 b001                               bcs     l73_1
    45  3e05 88                                 dey
    46  3e06 8543               l73_1           sta     datptr
    47  3e08 8444                               sty     datptr+1
    48  3e0a 60                                 rts
    49                          
    50                          ;.end
    51                          
    52                          ; ********************************************************************************************
    53                          ;
    54                          ;	Date		Changes
    55                          ;	====		=======
    56                          ;
    57                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/renumber.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      renumber.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;***********************************************************************
    15                          ;
    16                          ; RENUMBER Command
    17                          ;
    18                          ; Syntax:  RENUMBER [n1 [,[n2] ,n3]]
    19                          ;
    20                          ;  n1 = new start line number, default 10
    21                          ;  n2 = line increment, default 10
    22                          ;  n3 = start line, default first
    23                          ;
    24                          ; - Syntax error may occur for missing commas or bad line numbers.
    25                          ; - Illegal quantity error for line increment of 0 or for bad range.
    26                          ; - Overflow error if increment wraps line number during renumber,
    27                          ;  line number too large error if renumbering would force line
    28                          ;  numbers greater than 63999.
    29                          ; - Out of memory error if the renumbered program would be too large.
    30                          ; - Unresolved reference error if an imbedded line number references
    31                          ;  a line which does not exist.
    32                          ;
    33                          ; Otherwise returns to "ready" mode upon completion.
    34                          ;
    35                          ;***********************************************************************
    36                          
    37                          
    38                          ; Before any data is changed in any way, two preliminary passes are
    39                          ; made to insure no errors would occur during the actual renumbering
    40                          ; process (as detailed below).
    41                          ;
    42                          ; Pass 1 makes sure that the renumbered program would have no line
    43                          ; numbers greater than 63999 (nothing is actually renumbered; the
    44                          ; statement table is not modified).
    45                          ;
    46                          ; Pass 2 checks if the renumbered program would be too long and also
    47                          ; checks for non-existant line number destinations.
    48                          ;
    49                          ; Pass 3 examines the entire statement table first for imbedded line
    50                          ; numbers (branches) to fix. This is done by looking for keywords (GOTO,
    51                          ; GOSUB, THEN, RUN) which are usually followed by line numbers. The old
    52                          ; line number is mapped to a new value and the string representing the
    53                          ; new branch label replaces the original text.
    54                          ;
    55                          ; Pass 4 then replaces the statement number bytes by their final values.
    56                          ; and the table is relinked.
    57                          
    58                          
    59                          testwd
    60  3e0b 898a8da7                           !text goto_token,run_token,gosub_token,then_token
    61  3e0f 8cd6d7d5                           !text restore_token,resume_token,trap_token,else_token
    62                          
    63                          renumber
    64  3e13 20ed58                             jsr     errind                          ; allowed only in direct mode
    65                          
    66                          ; Set up default values for n1, n2, and n3
    67                          
    68  3e16 a900                               lda     #0                              ; line #10...
    69  3e18 a20a                               ldx     #10
    70  3e1a 8e7911                             stx     renum_tmp_1                     ; default renum origin (n1)
    71  3e1d 8d7a11                             sta     renum_tmp_1+1
    72  3e20 8e7b11                             stx     renum_tmp_2                     ; default increment (n2)
    73  3e23 8d7c11                             sta     renum_tmp_2+1
    74  3e26 855c                               sta     hightr                          ; default start line # (n3)
    75  3e28 855d                               sta     hightr+1
    76                          
    77  3e2a 208522                             jsr     chrgot                          ; any parameters?
    78  3e2d f053                               beq     ren_pass_1                      ; no...
    79                          
    80                          
    81                          ; Check for new starting line number (n1)
    82                          
    83  3e2f 202e32                             jsr     linget                          ; check for a number
    84  3e32 a50b                               lda     endchr                          ; was there one?
    85  3e34 f00a                               beq     renum_10                        ; no...use default
    86  3e36 a516                               lda     linnum
    87  3e38 a617                               ldx     linnum+1
    88  3e3a 8d7911                             sta     renum_tmp_1
    89  3e3d 8e7a11                             stx     renum_tmp_1+1
    90                          
    91                          ; Check for new increment
    92                          
    93                          renum_10
    94  3e40 20f278                             jsr     optwrd                          ; an increment given?
    95  3e43 900c                               bcc     renum_30                        ; no...use default
    96                          
    97  3e45 8c7b11                             sty     renum_tmp_2
    98  3e48 8d7c11                             sta     renum_tmp_2+1
    99  3e4b 0d7b11                             ora     renum_tmp_2                     ; increment must be >0
   100  3e4e f3ae13                             +lbeq   fcerr                           ; illegal quantity error
   101                          
   102                          ; Check for starting line number
   103                          
   104                          renum_30
   105  3e51 20f278                             jsr     optwrd                          ; starting line number given?
   106  3e54 902c                               bcc     ren_pass_1                      ; no...
   107                          
   108  3e56 845c                               sty     hightr
   109  3e58 8416                               sty     linnum
   110  3e5a 855d                               sta     hightr+1
   111  3e5c 8517                               sta     linnum+1
   112  3e5e 20fa31                             jsr     FindLine                        ; test for illegal renumber range
   113  3e61 a561                               lda     lowtr                           ; (n1 must be >= n3)
   114  3e63 a662                               ldx     lowtr+1
   115  3e65 855a                               sta     highds                          ; pointer to first statement to renumber
   116  3e67 865b                               stx     highds+1
   117  3e69 ad7911                             lda     renum_tmp_1
   118  3e6c ae7a11                             ldx     renum_tmp_1+1
   119  3e6f 8516                               sta     linnum
   120  3e71 8617                               stx     linnum+1
   121  3e73 20fa31                             jsr     FindLine                        ; lowtr = ptr to 1st stmt to be overlapped
   122  3e76 38                                 sec
   123  3e77 a561                               lda     lowtr                           ; can't be smaller
   124  3e79 e55a                               sbc     highds
   125  3e7b a562                               lda     lowtr+1
   126  3e7d e55b                               sbc     highds+1
   127  3e7f 937d13                             +lbcc   fcerr                           ; bad...
   128                          
   129                          
   130                          ;***********************************************************************
   131                          ;**************  R E N U M B E R    P A S S    O N E  ******************
   132                          ;***********************************************************************
   133                          
   134                          ; Pass 1 makes sure that the renumbered program will not have any line numbers
   135                          ; greater than 63999 (however, nothing is actually renumbered in this pass).
   136                          
   137                          ren_pass_1
   138  3e82 20472c                             jsr     tto                             ; save txtptr for restoration when done
   139  3e85 207240                             jsr     n1_reset                        ; put n1 in FAC, reset txtptr
   140  3e88 20a540                             jsr     chargt                          ; skip low link
   141  3e8b c8                                 iny                                     ; (.y=1)
   142  3e8c 20c522                             jsr     indtxt                          ; skip high link
   143  3e8f f03a                               beq     ren_pass_2                      ; end of program => begin pass 2 (assumes txttab > 0)
   144                          
   145                          r_pass1_10
   146  3e91 c8                                 iny                                     ; (.y=2)
   147  3e92 20c522                             jsr     indtxt                          ; line number low
   148  3e95 38                                 sec
   149  3e96 e55c                               sbc     hightr                          ; in line range which is to be renumbered?
   150  3e98 c8                                 iny                                     ; (.y=3)
   151  3e99 20c522                             jsr     indtxt                          ; line number high
   152  3e9c e55d                               sbc     hightr+1
   153  3e9e b007                               bcs     r_pass1_20                      ; yes => fake renumbering
   154  3ea0 20ba3e                             jsr     set_next                        ; goto next line
   155  3ea3 d0ec                               bne     r_pass1_10                      ; if z=0 then not end-of-text => keep going
   156  3ea5 f024                               beq     ren_pass_2                      ; else end
   157                          
   158                          r_pass1_20
   159  3ea7 20ba3e                             jsr     set_next                        ; goto next line
   160  3eaa f01f                               beq     ren_pass_2                      ; if z=1 then end-of-text => exit
   161  3eac 209340                             jsr     new_num                         ; create next line number
   162  3eaf b004                               bcs     r_pass1_30                      ; if c=1 then it wrapped => error
   163  3eb1 c9f9                               cmp     #>63999                         ; can't have lines > 63999
   164  3eb3 90f2                               bcc     r_pass1_20                      ; if c=0 then ok
   165                          
   166                          r_pass1_30                                              ; renumbering will generate an illegal line #
   167  3eb5 a226                               ldx     #err_too_large                  ; 'line number too large' error
   168  3eb7 8396ef                             +lbra   error
   169                          
   170                          set_next
   171  3eba a000                               ldy     #0                              ; set for next BASIC line
   172  3ebc 20c522                             jsr     indtxt                          ; low link
   173  3ebf aa                                 tax
   174  3ec0 c8                                 iny                                     ; (.y=1)
   175  3ec1 20c522                             jsr     indtxt                          ; high link
   176  3ec4 f004                               beq     set_end                         ; if z=1 then end of program => exit
   177  3ec6 863d                               stx     txtptr
   178  3ec8 853e                               sta     txtptr+1
   179  3eca 60                 set_end         rts
   180                          
   181                          
   182                          ;***********************************************************************
   183                          ;**************  R E N U M B E R    P A S S    T W O  ******************
   184                          ;***********************************************************************
   185                          
   186                          ; Pass 2 checks if the renumbered program will be too long and also
   187                          ; checks for non-existant line number destinations.
   188                          
   189                          ren_pass_2
   190  3ecb 4f7e05                             bbr4    runmod,l74_1                    ; skip pass two and three if plain text (edit mode) [910620]
   191  3ece 207240                             jsr     n1_reset                        ; yes- just setup up starting line # and reset txtptr
   192  3ed1 8014                               bra     ren_pass_4                      ; then renumber just the text's line numbers
   193                          
   194  3ed3 a901               l74_1           lda     #$01                            ; set flag for 'pass 2'
   195  3ed5 8576                               sta     z_p_temp_1
   196  3ed7 a582                               lda     text_top                        ; copy top-of-text pointer for later use
   197  3ed9 a683                               ldx     text_top+1                      ; (we don't want to change original here)
   198  3edb 853f                               sta     fndpnt
   199  3edd 8640                               stx     fndpnt+1
   200  3edf 20293f                             jsr     imbed_lines                     ; search for imbedded lines (but don't change)
   201                          
   202                          
   203                          
   204                          ;***********************************************************************
   205                          ;************  R E N U M B E R    P A S S    T H R E E  ****************
   206                          ;***********************************************************************
   207                          
   208                          ; Pass 3 actually renumbers the imbedded destination line numbers
   209                          ; which follow goto, gosub, trap, etc.
   210                          
   211                          ren_pass_3
   212  3ee2 c676                               dec     z_p_temp_1                      ; z_p_temp_1 = 0 (for pass 3)
   213  3ee4 20293f                             jsr     imbed_lines                     ; search for and update imbedded line #'s
   214                          
   215                          
   216                          ;***********************************************************************
   217                          ;*************  R E N U M B E R    P A S S    F O U R  *****************
   218                          ;***********************************************************************
   219                          
   220                          ; Pass 4 actually renumbers the program line numbers & exits
   221                          
   222                          ren_pass_4
   223  3ee7 20a340                             jsr     chargt_x2                       ; skip link
   224  3eea f031                               beq     renumber_exit                   ; null link=> end-of-text, exit (assumes txttab > 0)
   225  3eec 20a540                             jsr     chargt                          ; not null...
   226  3eef 8516                               sta     linnum                          ; if line# >= start#, replace with facho
   227  3ef1 c8                                 iny
   228  3ef2 20c522                             jsr     indtxt
   229  3ef5 38                                 sec
   230  3ef6 e55d                               sbc     hightr+1
   231  3ef8 901b                               bcc     r_pass4_20                      ; no, let alone
   232  3efa d006                               bne     r_pass4_10                      ; yes, replace
   233  3efc a516                               lda     linnum
   234  3efe e55c                               sbc     hightr
   235  3f00 9013                               bcc     r_pass4_20                      ; no, let alone
   236                          
   237                          r_pass4_10
   238  3f02 a564                               lda     facho
   239                          ; phx
   240  3f04 200a23                             jsr     sta_far_txt                     ; sta (txtptr),y  hi  (bleed-thru)
   241  3f07 88                                 dey
   242  3f08 a565                               lda     facho+1
   243  3f0a 200a23                             jsr     sta_far_txt                     ; sta (txtptr),y  lo (bleed-thru)
   244                          ; plx
   245  3f0d 20a540                             jsr     chargt                          ; skip past 2nd byte of line#
   246  3f10 208a40                             jsr     line_inc                        ; incr line# and scan to eol
   247  3f13 80d2                               bra     ren_pass_4                      ; always...
   248                          
   249                          r_pass4_20
   250  3f15 20a540                             jsr     chargt                          ; skip past line#
   251  3f18 208d40                             jsr     scan_thru                       ; scan to eol
   252  3f1b 80ca                               bra     ren_pass_4                      ; always...
   253                          
   254                          
   255                          renumber_exit
   256  3f1d 203e42                             jsr     fix_links                       ; patch things up: relink & set eot
   257                          
   258                          direct_mode_exit
   259  3f20 20f439                             jsr     ott                             ; restore txtptr for next command in buffer
   260  3f23 a900                               lda     #0                              ; but disallow continuing
   261  3f25 8d7311                             sta     oldtxt+1
   262  3f28 60                                 rts
   263                          
   264                          
   265                          ;***********************************************************************
   266                          ;*************  R E N U M B E R   S U B R O U T I N E S  ***************
   267                          ;***********************************************************************
   268                          
   269                          ; Look for imbedded line #'s (after GOTO, GOSUB, etc.)
   270                          ; but only change them in pass 3 (ie. z_p_temp_1 = 0)
   271                          
   272                          imbed_lines
   273  3f29 201f35                             jsr     reset_txtptr                    ; start at first line: load (txtptr) with (txttab)-1
   274                          
   275                          next_line
   276  3f2c 20a340                             jsr     chargt_x2                       ; skip link (assumes txttab > 0)
   277  3f2f f34101                             +lbeq   n1_reset                        ; null link: put current line # in fac, reset txtptr, exit
   278  3f32 20a540                             jsr     chargt                          ; line number
   279  3f35 854b                               sta     forpnt                          ; save in case there is an error
   280  3f37 20a540                             jsr     chargt
   281  3f3a 854c                               sta     forpnt+1
   282                          
   283                          next_char
   284  3f3c 20a540                             jsr     chargt                          ; first character in the line
   285                          
   286                          chk_quote
   287  3f3f c922                               cmp     #'"'                            ; opening double quote?
   288  3f41 d00b                               bne     not_quote                       ; no...
   289  3f43 20a540             l75_1           jsr     chargt                          ; scan line
   290  3f46 f0e4                               beq     next_line                       ; end...
   291  3f48 c922                               cmp     #'"'                            ; close double quote
   292  3f4a d0f7                               bne     l75_1                           ; no... continue
   293  3f4c 80ee                               bra     next_char                       ; yes... resume renumber
   294                          
   295                          not_quote
   296  3f4e aa                                 tax                                     ; end of line?
   297  3f4f f0db                               beq     next_line                       ; yes...
   298  3f51 10e9                               bpl     next_char                       ; not a token...
   299                          
   300  3f53 a208                               ldx     #8                              ; check special token list
   301  3f55 dd0a3e             l76_1           cmp     testwd-1,x
   302  3f58 f028                               beq     iline_10                        ; a match...
   303  3f5a ca                                 dex
   304  3f5b d0f8                               bne     l76_1                           ; continue until zero
   305                          
   306  3f5d c9cb                               cmp     #go_token                       ; wasn't in the token list. check for 'go to'
   307  3f5f d00b                               bne     chk_escape                      ; not 'go', go check for 'collision' *c128 fix*
   308  3f61 208322             hop_1           jsr     chrget                          ; got a 'go', look for 'to'
   309  3f64 f0c6                               beq     next_line                       ; end of line, abort
   310  3f66 c9a4                               cmp     #to_token
   311  3f68 f018                               beq     iline_10                        ; got it! go to fix number routine
   312  3f6a 80d0                               bra     next_char                       ; no 'to', keep looking
   313                          
   314                          ; Look for 'COLLISION'.  This is an escape command. *c128 fix* ?????????
   315                          
   316                          chk_escape
   317  3f6c c9fe                               cmp     #esc_command_token
   318  3f6e d0cc                               bne     next_char
   319  3f70 208322                             jsr     chrget
   320  3f73 f0ec                               beq     hop_1                           ; end of line ,abort
   321  3f75 c917                               cmp     #collision_token
   322  3f77 d0c3                               bne     next_char
   323  3f79 208322             l77_1           jsr     chrget                          ; got it! skip over first argument
   324  3f7c f0e3                               beq     hop_1                           ; end of line, abort
   325  3f7e c92c                               cmp     #','
   326  3f80 d0f7                               bne     l77_1                           ; not there yet
   327                          
   328                          
   329                          iline_10
   330  3f82 a53d                               lda     txtptr                          ; save current txtptr
   331  3f84 8d7011                             sta     oldlin
   332  3f87 a53e                               lda     txtptr+1
   333  3f89 8d7111                             sta     oldlin+1
   334  3f8c 208322                             jsr     chrget
   335  3f8f b0ae                               bcs     chk_quote                       ; not a #...
   336  3f91 202e32                             jsr     linget                          ; get line # from text
   337  3f94 202340                             jsr     form_line                       ; replace if this line # > n3
   338  3f97 ad7011                             lda     oldlin                          ; restore old txtptr
   339  3f9a 853d                               sta     txtptr
   340  3f9c ad7111                             lda     oldlin+1
   341  3f9f 853e                               sta     txtptr+1
   342                          
   343  3fa1 208322                             jsr     chrget                          ; skip over leading spaces
   344  3fa4 c33d                               dew     txtptr                          ; then backup (txtptr) by 1
   345  3fa6 a2ff                               ldx     #$ff
   346  3fa8 a576                               lda     z_p_temp_1                      ; if this is pass2 then don't actually change
   347  3faa f037                               beq     p3code                          ; if z=1 then pass3 => ok to change
   348  3fac 20b83f                             jsr     p2code                          ; renumber 'pass two': trial run to see if enough room
   349  3faf 208522                             jsr     chrgot                          ; re-get last character from BASIC text & rts
   350                          
   351                          iline_20
   352  3fb2 c92c                               cmp     #','                            ; comma from 'on'?
   353  3fb4 f0cc                               beq     iline_10                        ; it is...
   354  3fb6 8087                               bra     chk_quote                       ; no...
   355                          
   356                          
   357                          ;*********** This part of imbed_lines executed in pass 2 only **********
   358                          
   359                          p2code                                                  ; updates text_top without actually changing lines
   360  3fb8 e8                                 inx
   361  3fb9 bd0101                             lda     fbuffr+1,x                      ; get character from number
   362  3fbc f01c                               beq     l78_3                           ; end of number
   363  3fbe 208322                             jsr     chrget                          ; get digit from old number
   364  3fc1 90f5                               bcc     p2code                          ; digit...move on
   365                          
   366  3fc3 e33f               l78_1           inw     fndpnt
   367  3fc5 38                                 sec                                     ; have we run out of memory (theoretically)?
   368  3fc6 a53f                               lda     fndpnt                          ; (compare with limit-of-memory pointer)
   369  3fc8 edcf02                             sbc     max_mem_0
   370  3fcb a540                               lda     fndpnt+1
   371  3fcd edd002                             sbc     max_mem_0+1
   372  3fd0 b36fee                             +lbcs   omerr                           ; yes- out of memory error
   373  3fd3 e8                                 inx                                     ; no - next...
   374  3fd4 bd0101                             lda     fbuffr+1,x
   375  3fd7 d0ea                               bne     l78_1
   376  3fd9 60                 l78_2           rts                                     ; no more
   377                          
   378  3fda 208322             l78_3           jsr     chrget
   379  3fdd b0fa                               bcs     l78_2                           ; old stuff after # is other char
   380  3fdf c33f                               dew     fndpnt                          ; digit...move down
   381  3fe1 80f7                               bra     l78_3                           ; still digits...
   382                          
   383                          
   384                          ;*********** This part of imbed_lines executed in pass 3 only **********
   385                          
   386                          p3code
   387  3fe3 e8                                 inx
   388  3fe4 bd0101                             lda     fbuffr+1,x                      ; get character from number
   389  3fe7 f026                               beq     l79_3                           ; end of number
   390                          
   391  3fe9 48                                 pha                                     ; save digit from new number
   392  3fea 20a540                             jsr     chargt                          ; get digit from old number
   393  3fed c93a                               cmp     #':'                            ; command terminator or letter?
   394  3fef b00c                               bcs     l79_1
   395  3ff1 c920                               cmp     #' '                            ; space? (fix for goto10 :rem)
   396  3ff3 f008                               beq     l79_1
   397  3ff5 38                                 sec
   398  3ff6 e930                               sbc     #'0'                            ; number?
   399  3ff8 38                                 sec
   400  3ff9 e9d0                               sbc     #$d0
   401  3ffb 9008                               bcc     l79_2                           ; digit...move on
   402                          
   403  3ffd 20ac40             l79_1           jsr     move_init                       ; other char...move up
   404  4000 201741                             jsr     moveup
   405  4003 e382                               inw     text_top
   406                          
   407  4005 68                 l79_2           pla
   408  4006 da                                 phx
   409  4007 a000                               ldy     #0
   410  4009 200a23                             jsr     sta_far_txt                     ; put new digit in new number (bleed-thru)
   411  400c fa                                 plx
   412  400d 80d4                               bra     p3code
   413                          
   414                          
   415  400f 208322             l79_3           jsr     chrget
   416  4012 b09e                               bcs     iline_20                        ; old stuff after # is other char
   417                          
   418  4014 20ac40             l79_4           jsr     move_init                       ; digit...move down
   419  4017 20c440                             jsr     movedown
   420  401a c382                               dew     text_top
   421  401c 208522                             jsr     chrgot
   422  401f 90f3                               bcc     l79_4                           ; still digits...
   423                          
   424  4021 808f                               bra     iline_20                        ; branch always
   425                          
   426                          
   427                          ;*************************** FORM_LINE *********************************
   428                          
   429                          ; Remaps the destination line if it is greater than n3
   430                          
   431                          form_line
   432  4023 207240                             jsr     n1_reset
   433                          find_it
   434  4026 20a340                             jsr     chargt_x2                       ; new line, skip over link
   435  4029 d00d                               bne     l80_1                           ; if we get to end-of-text without finding the
   436  402b a227                               ldx     #err_ref                        ; line # then 'unresolved reference' error
   437  402d a54b                               lda     forpnt
   438  402f 853b                               sta     curlin                          ; fake error routine into saying 'in line xxxxx'
   439  4031 a54c                               lda     forpnt+1
   440  4033 853c                               sta     curlin+1
   441  4035 8318ee                             +lbra   error
   442                          
   443  4038 20a540             l80_1           jsr     chargt                          ; get line number low
   444  403b 855a                               sta     highds                          ; highds = current line# in loop
   445  403d c516                               cmp     linnum
   446  403f d027                               bne     l80_4
   447  4041 20a540                             jsr     chargt                          ; get line number high
   448  4044 855b                               sta     highds+1
   449  4046 c517                               cmp     linnum+1
   450  4048 d023                               bne     l80_5
   451  404a 38                                 sec                                     ; if linnum < start#, no remapping
   452  404b e55d                               sbc     hightr+1
   453  404d 9008                               bcc     l80_2
   454  404f d00e                               bne     l80_3
   455  4051 a516                               lda     linnum
   456  4053 e55c                               sbc     hightr
   457  4055 b008                               bcs     l80_3
   458                          
   459  4057 a516               l80_2           lda     linnum                          ; use same line#
   460  4059 8565                               sta     facho+1
   461  405b a517                               lda     linnum+1
   462  405d 8564                               sta     facho
   463                          
   464  405f a290               l80_3           ldx     #$90                            ; make replacement string
   465  4061 38                                 sec
   466  4062 20df62                             jsr     floatc
   467  4065 832824                             +lbra   fout
   468                          
   469                          
   470  4068 20a540             l80_4           jsr     chargt
   471  406b 855b                               sta     highds+1                        ; (** 01/27/84 fix)
   472                          
   473  406d 207f40             l80_5           jsr     line_add                        ; scan to end of line
   474  4070 80b4                               bra     find_it                         ; always
   475                          
   476                          
   477                          ;*************************** N1_RESET **********************************
   478                          
   479                          ; Copies n1 (new renumber origin) into facho & sets (txtptr) = (txttab)-1
   480                          
   481                          n1_reset
   482  4072 ad7911                             lda     renum_tmp_1
   483  4075 8565                               sta     facho+1
   484  4077 ad7a11                             lda     renum_tmp_1+1
   485  407a 8564                               sta     facho
   486  407c 83a1f4                             +lbra   reset_txtptr
   487                          
   488                          
   489                          ;*************************** LINE_ADD **********************************
   490                          
   491                          ; Adds n2 (new line increment) to line number stored in facho if the
   492                          ; current line number (highds) >= n3 (line to start renumbering with).
   493                          ; The line is then scanned.
   494                          
   495                          line_add
   496  407f a55a                               lda     highds                          ; if line# >= start# then incr new#
   497  4081 38                                 sec
   498  4082 e55c                               sbc     hightr
   499  4084 a55b                               lda     highds+1
   500  4086 e55d                               sbc     hightr+1
   501  4088 9003                               bcc     scan_thru
   502                          
   503                          line_inc
   504  408a 209340                             jsr     new_num
   505                          
   506                          scan_thru
   507  408d 20a540                             jsr     chargt                          ; scan to end of line
   508  4090 d0fb                               bne     scan_thru
   509  4092 60                                 rts
   510                          
   511                          
   512                          ;**************************** NEW_NUM **********************************
   513                          
   514                          ; Adds n2 (the new line increment) to the line number stored in facho.
   515                          
   516                          new_num
   517  4093 a565                               lda     facho+1                         ; increment new line#
   518  4095 18                                 clc
   519  4096 6d7b11                             adc     renum_tmp_2
   520  4099 8565                               sta     facho+1
   521  409b a564                               lda     facho
   522  409d 6d7c11                             adc     renum_tmp_2+1
   523  40a0 8564                               sta     facho
   524  40a2 60                                 rts
   525                          
   526                          
   527                          ;********************** CHARGT & CHARGT_X2 *****************************
   528                          
   529                          ; Chargt simulates chrget but doesn't ignore spaces & carry has no
   530                          ; significance.  Chargt_x2 executes chargt twice.
   531                          ; Used by Renumber, Find/Change, etc.
   532                          
   533                          chargt_x2
   534  40a3 e33d                               inw     txtptr                          ; jsr chargt
   535                          chargt
   536  40a5 a000                               ldy     #0                              ; increment txtptr
   537  40a7 e33d                               inw     txtptr
   538  40a9 831ae2                             +lbra   indtxt
   539                          
   540                          
   541                          ;***********************************************************************
   542                          ;************************* MEMORY MOVE ROUTINES ************************
   543                          ;***********************************************************************
   544                          
   545                          ;****************************** MOVEINIT *******************************
   546                          
   547                          ; Setup for Renumber memory move.
   548                          
   549                          move_init
   550  40ac a53d                               lda     txtptr                          ; index1 = txtptr
   551  40ae 8524                               sta     index1
   552  40b0 a53e                               lda     txtptr+1
   553  40b2 8525                               sta     index1+1
   554                          
   555  40b4 a582                               lda     text_top                        ; index2 = text_top
   556  40b6 8526                               sta     index2
   557  40b8 a583                               lda     text_top+1
   558  40ba 8527                               sta     index2+1
   559                          
   560  40bc a901                               lda     #1                              ; move 1 character
   561  40be 850d                               sta     count                           ; lo
   562  40c0 3a                                 dec
   563  40c1 856d                               sta     argmo                           ; hi
   564                          
   565  40c3 60                                 rts
   566                          
   567                          
   568                          ;****************************** MOVEDOWN *******************************
   569                          
   570                          ; Move block of BASIC text from INDEX1+COUNT to INDEX2 down to INDEX1.
   571                          ; Used by commands Renumber, Find/Change.
   572                          
   573                          movedown
   574  40c4 38                                 sec                                     ; set up DMA list:   [900524]
   575  40c5 a526                               lda     index2
   576  40c7 e524                               sbc     index1
   577  40c9 8d4501                             sta     dma1_cnt_lo                     ; cnt = index2-index1-count
   578  40cc a527                               lda     index2+1
   579  40ce e525                               sbc     index1+1
   580  40d0 8d4601                             sta     dma1_cnt_hi
   581  40d3 38                                 sec
   582  40d4 ad4501                             lda     dma1_cnt_lo
   583  40d7 e50d                               sbc     count                           ; lo
   584  40d9 8d4501                             sta     dma1_cnt_lo
   585  40dc ad4601                             lda     dma1_cnt_hi
   586  40df e56d                               sbc     argmo                           ; hi
   587  40e1 8d4601                             sta     dma1_cnt_hi
   588                          
   589  40e4 18                                 clc
   590  40e5 a524                               lda     index1
   591  40e7 8d4a01                             sta     dma1_dest_lo                    ; dest = index1
   592  40ea 650d                               adc     count
   593  40ec 8d4701                             sta     dma1_src_lo                     ; src = index1+count
   594  40ef a525                               lda     index1+1
   595  40f1 8d4b01                             sta     dma1_dest_hi
   596  40f4 656d                               adc     argmo
   597  40f6 8d4801                             sta     dma1_src_hi
   598                          
   599  40f9 a584                               lda     text_bank                       ; bank = BASIC text bank
   600                          ; and #%00001111  ;      [910520] F018A
   601  40fb 8d4901                             sta     dma1_src_bank
   602  40fe 8d4c01                             sta     dma1_dest_bank
   603                          
   604                          execute_DMA1                                            ; [910620] Edit
   605  4101 a900                               lda     #0
   606  4103 8d4401                             sta     dma1_cmd                        ; command = copy from startpoint
   607  4106 8d4d01                             sta     dma1_subcmd                     ; [910520] F018A
   608                          
   609  4109 8d02d7                             sta     dma_ctlr+2                      ; dma_list bank
   610  410c a901                               lda     #>dma1_cmd
   611  410e 8d01d7                             sta     dma_ctlr+1                      ; dma_list hi
   612  4111 a944                               lda     #<dma1_cmd
   613  4113 8d00d7                             sta     dma_ctlr                        ; dma_list lo & trigger
   614  4116 60                                 rts
   615                          
   616                          
   617                          ;******************************* MOVEUP ********************************
   618                          
   619                          ; Move block of BASIC text from INDEX1 to INDEX2 up to INDEX2+COUNT.
   620                          ; Used by commands Renumber, Find/Change.
   621                          
   622                          moveup
   623  4117 38                                 sec                                     ; set up DMA list:   [900524]
   624  4118 a526                               lda     index2
   625  411a e524                               sbc     index1
   626  411c 8d4501                             sta     dma1_cnt_lo                     ; cnt = index2-index1
   627  411f a527                               lda     index2+1
   628  4121 e525                               sbc     index1+1
   629  4123 8d4601                             sta     dma1_cnt_hi
   630                          
   631  4126 c326                               dew     index2                          ; (index2 = text_top = end+1)
   632  4128 18                                 clc
   633  4129 a526                               lda     index2
   634  412b 8d4701                             sta     dma1_src_lo                     ; src = index2
   635  412e 650d                               adc     count
   636  4130 8d4a01                             sta     dma1_dest_lo                    ; dest = index2+count
   637  4133 a527                               lda     index2+1
   638  4135 8d4801                             sta     dma1_src_hi
   639  4138 656d                               adc     argmo
   640  413a 8d4b01                             sta     dma1_dest_hi
   641                          
   642                          ; lda dma_ctlr+3  ;dma controller version    [910520] F018A
   643                          ; and #1
   644                          ; beq l81_1   ; F018    removed [910808] F018B
   645  413d a930                               lda     #%00110000                      ; F018A,B
   646  413f 8d4401             l81_1           sta     dma1_cmd                        ; command=copy, source=start   [910102]
   647                          ; php
   648  4142 a584                               lda     text_bank                       ; bank = BASIC text bank   [910520] F018A
   649                          ; plp   ;version?    removed [910808] F018B
   650                          ; bne l81_2   ; F018A
   651                          ; and #%00001111  ; F018     [910102]
   652                          ; ora #%01000000  ;(copy source=endpoint)    [910102]
   653  4144 8d4901             l81_2           sta     dma1_src_bank                   ; banks
   654  4147 8d4c01                             sta     dma1_dest_bank
   655                          
   656  414a a900                               lda     #0                              ; [910219]
   657                          ; sta dma1_cmd  ; command = copy, source=endpoint
   658  414c 8d4d01                             sta     dma1_subcmd                     ; [910520] F018A
   659                          ; dec a   ;      [910219]
   660  414f 8d02d7                             sta     dma_ctlr+2                      ; dma_list bank
   661  4152 a001                               ldy     #>dma1_cmd                      ; dma_list
   662  4154 a944                               lda     #<dma1_cmd
   663  4156 8c01d7                             sty     dma_ctlr+1                      ; dma_list hi
   664  4159 8d00d7                             sta     dma_ctlr                        ; dma_list lo & trigger
   665  415c 60                                 rts
   666                          
   667                          ;.end
   668                          
   669                          
   670                          ; ********************************************************************************************
   671                          ;
   672                          ;	Date		Changes
   673                          ;	====		=======
   674                          ;
   675                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/for.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      for.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; FOR
    14                          ;
    15                          ; Push the following information on the run-time stack:
    16                          ;
    17                          ; (bottom)   highest memory
    18                          ; =========================
    19                          ;  txtptr    address of next statement
    20                          ;  txtptr+1
    21                          ;  ========
    22                          ;  curlin+1  current line number
    23                          ;  curlin
    24                          ;  ========
    25                          ;  to lo
    26                          ;  to mo
    27                          ;  to moh    'to' value
    28                          ;  to ho
    29                          ;  to exp
    30                          ;  ========
    31                          ;  step sign
    32                          ;  step lo
    33                          ;  step mo
    34                          ;  step moh  'step' value
    35                          ;  step ho
    36                          ;  step exp
    37                          ;  ========
    38                          ;  forpnt+1  'for' variable pointer
    39                          ;  forpnt
    40                          ;  ========
    41                          ;  'for' token       <== (tos) top of stack pointer
    42                          ; ============================
    43                          ; (top of stack)  lowest memory
    44                          
    45                          
    46  415d a980               for             lda     #$80
    47  415f 8512                               sta     subflg                          ; no arrays(), no integers%
    48  4161 207636                             jsr     let                             ; get & set FOR variables
    49  4164 a981                               lda     #for_token                      ; set up for call to see if
    50  4166 204331                             jsr     search                          ; ..this 'for' variable is unique
    51  4169 f008                               beq     l82_1                           ; branch if not
    52                          
    53                          ; If the variable is not unique, (fndpnt) will point to last occurance
    54                          ; in stack, and we will reset the stack to that point.  Otherwise we
    55                          ; will adjust the pointer by 'lenfor' and start from that point.
    56                          
    57  416b a912                               lda     #lenfor
    58  416d 209431                             jsr     getstk                          ; updates stack pointer, error if overflow
    59  4170 20dd31                             jsr     movtos                          ; (tos) => (fndpnt)
    60                          
    61  4173 20e631             l82_1           jsr     movfnd                          ; (fndpnt) => (tos)   (redundant for new entries)
    62  4176 205b35                             jsr     datan                           ; find address of next statement
    63  4179 98                                 tya                                     ; offset from (txtptr) in y
    64  417a a011                               ldy     #lenfor-1
    65                          
    66  417c 18                                 clc                                     ; Push address of next statement on stack
    67  417d 653d                               adc     txtptr
    68  417f 917c                               sta     (tos),y                         ; (common area)
    69  4181 a53e                               lda     txtptr+1
    70  4183 6900                               adc     #0
    71  4185 88                                 dey
    72  4186 917c                               sta     (tos),y                         ; (common area)
    73                          
    74  4188 a53c                               lda     curlin+1                        ; Push current line number on stack
    75  418a 88                                 dey
    76  418b 917c                               sta     (tos),y                         ; (common area)
    77  418d a53b                               lda     curlin
    78  418f 88                                 dey
    79  4190 917c                               sta     (tos),y                         ; (common area)
    80                          
    81  4192 a9a4                               lda     #to_token                       ; Look for TO, must appear
    82  4194 205d4e                             jsr     synchr
    83  4197 20db4c                             jsr     chknum                          ; get TO value
    84  419a 20d84c                             jsr     frmnum
    85  419d a568                               lda     facsgn
    86  419f 097f                               ora     #$7f
    87  41a1 2564                               and     facho
    88  41a3 8564                               sta     facho
    89                          
    90  41a5 a204                               ldx     #4
    91  41a7 a00d                               ldy     #lenfor-5
    92  41a9 b563               l82_2           lda     facexp,x                        ; Push faclo,mo,moh,ho,exp
    93  41ab 917c                               sta     (tos),y                         ; (common area)
    94  41ad ca                                 dex
    95  41ae 88                                 dey
    96  41af 10f8                               bpl     l82_2
    97                          
    98  41b1 a999                               lda     #<fone                          ; Push STEP value
    99  41b3 a05f                               ldy     #>fone                          ; (point to default 'one' in ROM)
   100  41b5 200e62                             jsr     movfm
   101  41b8 208522                             jsr     chrgot
   102  41bb c9a9                               cmp     #step_token
   103  41bd d006                               bne     l82_3                           ; branch if no step given
   104  41bf 208322                             jsr     chrget
   105  41c2 20d84c                             jsr     frmnum
   106                          
   107  41c5 20c162             l82_3           jsr     sign
   108  41c8 48                                 pha                                     ; save sign for a moment
   109  41c9 20b262                             jsr     round
   110  41cc 68                                 pla
   111                          
   112  41cd a008                               ldy     #lenfor-10
   113  41cf a205                               ldx     #5
   114  41d1 917c               l82_4           sta     (tos),y                         ; (common area)
   115  41d3 b562                               lda     facexp-1,x
   116  41d5 88                                 dey
   117  41d6 ca                                 dex
   118  41d7 10f8                               bpl     l82_4
   119                          
   120  41d9 a54c                               lda     forpnt+1                        ; Finally push pointer to 'for' variable, & 'for' token
   121  41db 917c                               sta     (tos),y                         ; (common area)
   122  41dd a54b                               lda     forpnt
   123  41df 88                                 dey
   124  41e0 917c                               sta     (tos),y                         ; (common area)
   125  41e2 a981                               lda     #for_token
   126  41e4 88                                 dey
   127  41e5 917c                               sta     (tos),y                         ; (common area)
   128  41e7 60                                 rts
   129                          
   130                          ;.end
   131                          
   132                          ; ********************************************************************************************
   133                          ;
   134                          ;	Date		Changes
   135                          ;	====		=======
   136                          ;
   137                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/delete.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      delete.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Delete a range of source   -or-   Delete a disk file
    16                          ;
    17                          ; Syntax: DELETE from# - to# (same range parameters as LIST)
    18                          ;  DELETE "filename" (same parameters as SCRATCH)
    19                          
    20                          ; Determine which form of DELETE we have...
    21                          
    22  41e8 9007               delete          bcc     delete_line                     ; branch if a number (assume range parameter)
    23  41ea c9ab                               cmp     #minus_token
    24  41ec f003                               beq     delete_line                     ; branch if a dash (assume range parameter)
    25  41ee 83e430                             +lbra   scratch                         ; branch if string (assume filename or U#)
    26                          
    27                          delete_line
    28  41f1 20ed58                             jsr     errind                          ; direct mode only command
    29  41f4 208522                             jsr     chrgot                          ; requires line# or range, no default
    30  41f7 f351ec                             +lbeq   snerr                           ; error, none given
    31                          
    32  41fa 205042                             jsr     range                           ; parse range, find starting line, ptr to ending line
    33  41fd a561                               lda     lowtr
    34  41ff a662                               ldx     lowtr+1
    35  4201 8524                               sta     index1                          ; (destination)
    36  4203 8625                               stx     index1+1
    37                          
    38  4205 20fa31                             jsr     FindLine                        ; find ending line
    39  4208 9015                               bcc     l83_2                           ; branch if not found
    40  420a a001                               ldy     #1
    41  420c 20ad22                             jsr     indlow                          ; if eot, use this ptr.  else, need ptr to next
    42  420f 88                                 dey
    43  4210 aa                                 tax                                     ; save it in case of swap
    44  4211 d005                               bne     l83_1                           ; branch if not eot (end-of-text)
    45  4213 20ad22                             jsr     indlow
    46  4216 f007                               beq     l83_2                           ; branch if eot (null link bytes)
    47                          
    48  4218 20ad22             l83_1           jsr     indlow
    49  421b 8561                               sta     lowtr                           ; (source)
    50  421d 8662                               stx     lowtr+1
    51                          
    52  421f a561               l83_2           lda     lowtr                           ; check that start <= end
    53  4221 38                                 sec
    54  4222 e524                               sbc     index1                          ; calculate delta
    55  4224 850d                               sta     count                           ; (count)
    56  4226 a562                               lda     lowtr+1                         ; (does not catch case where
    57  4228 e525                               sbc     index1+1                        ; start>end when end=start+1,
    58  422a 856d                               sta     argmo                           ; but it does no harm)
    59  422c 050d                               ora     count
    60  422e f00e                               beq     fix_links                       ; all done- nothing to move!?
    61  4230 9318ec                             +lbcc   snerr                           ; error- bad range (start > end)
    62                          
    63  4233 a582                               lda     text_top                        ; setup for common DMA move routine: [900530]
    64  4235 a683                               ldx     text_top+1
    65  4237 8526                               sta     index2                          ; index2 = top
    66  4239 8627                               stx     index2+1                        ; index1 = destination
    67                          ; count  = delta
    68                          
    69  423b 20c440                             jsr     movedown                        ; delete the text, then relink & exit
    70                          
    71                          
    72                          
    73                          fix_links                                               ; <<<<<<<<<<<<<<<<<<<<<<<<<<< entry from renumber
    74                          
    75  423e 20b930                             jsr     link_program                    ; relink program
    76  4241 a524                               lda     index1
    77  4243 a625                               ldx     index1+1
    78  4245 18                                 clc
    79  4246 6902                               adc     #2
    80  4248 9001                               bcc     l84_1
    81  424a e8                                 inx
    82  424b 8582               l84_1           sta     text_top                        ; set eot pointer
    83  424d 8683                               stx     text_top+1
    84  424f 60                                 rts                                     ; C128-04 fix: was 'jmp ready' (FAB)
    85                          
    86                          
    87                          ;********************************
    88                          ;*
    89                          ;*    Input Range Parameters
    90                          ;*
    91                          ;********************************
    92                          
    93  4250 f012               range           beq     l85_1                           ; a terminator from chrgot?
    94  4252 9010                               bcc     l85_1                           ; a number?
    95  4254 c9ab                               cmp     #minus_token                    ; a dash?
    96  4256 d02e                               bne     l85_4   ;if it's not a dash, error (C128-03 fix; FAB)
    97  4258 a001                               ldy     #1
    98  425a 20c522                             jsr     indtxt                          ; let's peek, and see what follows the dash!
    99  425d f027                               beq     l85_4                           ; uh-oh! it's of the form 'delete -' - error
   100  425f c93a                               cmp     #':'                            ; the other terminator
   101  4261 f023                               beq     l85_4                           ; ..still bad
   102  4263 38                                 sec                                     ; set up for linget
   103                          
   104  4264 202e32             l85_1           jsr     linget                          ; get first #
   105  4267 20fa31                             jsr     FindLine                        ; find it & set ptrs
   106  426a 208522                             jsr     chrgot                          ; get last char
   107  426d f00c                               beq     l85_2                           ; skip done
   108  426f c9ab                               cmp     #minus_token                    ; a dash?
   109  4271 d013                               bne     l85_4                           ; no- syntax error
   110  4273 208322                             jsr     chrget                          ; yes- skip dash
   111  4276 202e32                             jsr     linget                          ; get second #
   112  4279 d00b                               bne     l85_4                           ; error- wasn't a number
   113                          
   114  427b a50b               l85_2           lda     endchr                          ; was a # input?
   115  427d d006                               bne     l85_3                           ; yes
   116  427f a9ff                               lda     #$ff                            ; no - make max
   117  4281 8516                               sta     linnum
   118  4283 8517                               sta     linnum+1
   119  4285 60                 l85_3           rts
   120                          
   121                          
   122  4286 83c2eb             l85_4           +lbra   snerr                           ; syntax error
   123                          
   124                          ;.end
   125                          
   126                          ; ********************************************************************************************
   127                          ;
   128                          ;	Date		Changes
   129                          ;	====		=======
   130                          ;
   131                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/findchange.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      findchange.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; FIND   "string"                    [,line_range]
    16                          ; CHANGE "oldstring" TO "newstring"  [,line_range]
    17                          ;
    18                          ; where <"> delimiter can be any character, but only
    19                          ; double-quotes will prevent tokenization of strings.
    20                          ;
    21                          ; N.B.: I am assuming that lines cannot be greater than 255 chars, as is
    22                          ; the case where the line was entered "normally", that is, using LINGET.
    23                          
    24                          find
    25  4289 7787                               rmb7    op                              ; FIND flag
    26  428b 2c                                 !text $2c
    27                          
    28                          change
    29  428c f787                               smb7    op                              ; CHANGE flag
    30  428e 6787                               rmb6    op                              ; reset change-all mode
    31  4290 20ed58                             jsr     errind                          ; report error if not in direct mode
    32                          
    33  4293 208522                             jsr     chrgot                          ; get delimeter
    34  4296 a200                               ldx     #0                              ; evaluate string args
    35  4298 202644                             jsr     delimit_string                  ; string1
    36  429b a58a                               lda     fstr1+2
    37  429d f35f0f                             +lbeq   fcerr                           ; error if string1 null
    38  42a0 7f8713                             bbr7    op,l86_1                        ; branch if no string2
    39  42a3 208322                             jsr     chrget                          ; pick up required 'to' token
    40  42a6 c9a4                               cmp     #to_token
    41  42a8 d3a0eb                             +lbne   snerr                           ; error if missing
    42  42ab 208322                             jsr     chrget
    43  42ae f39aeb                             +lbeq   snerr                           ; error if eol
    44  42b1 a203                               ldx     #3
    45  42b3 202644                             jsr     delimit_string                  ; string2
    46                          
    47  42b6 208322             l86_1           jsr     chrget                          ; line number range given?
    48  42b9 f003                               beq     l86_2                           ; no, eol
    49  42bb 205b4e                             jsr     chkcom                          ; yes, pick up required comma
    50  42be 205042             l86_2           jsr     range                           ; set up line number range (lowtr,linnum)
    51  42c1 20472c                             jsr     tto                             ; save txtptr for restoration when done
    52  42c4 7755                               rmb7    helper                          ; clear 'help' flag for 'p1line'
    53  42c6 a555                               lda     helper
    54  42c8 48                                 pha
    55  42c9 4755                               rmb4    helper                          ; temporarily disable token highlighting
    56  42cb d755                               smb5    helper                          ; set   'find' flag for 'p1line'
    57  42cd 800e                               bra     find_loop_1                     ; begin
    58                          
    59                          
    60                          find_loop
    61  42cf a000                               ldy     #0                              ; move to next line (copy link bytes to lowtr)
    62  42d1 20ad22                             jsr     indlow
    63  42d4 aa                                 tax
    64  42d5 c8                                 iny
    65  42d6 20ad22                             jsr     indlow
    66  42d9 8661                               stx     lowtr
    67  42db 8562                               sta     lowtr+1
    68                          
    69                          find_loop_1
    70  42dd a001                               ldy     #1
    71  42df 20ad22                             jsr     indlow                          ; check link
    72  42e2 d007                               bne     l87_1                           ; not null- continue
    73  42e4 88                                 dey
    74  42e5 20ad22                             jsr     indlow
    75  42e8 f31e01                             +lbeq   find_exit                       ; null- exit
    76                          
    77  42eb a002               l87_1           ldy     #2
    78  42ed 20ad22                             jsr     indlow                          ; check line number
    79  42f0 aa                                 tax
    80  42f1 c8                                 iny
    81  42f2 20ad22                             jsr     indlow
    82  42f5 c517                               cmp     linnum+1
    83  42f7 d004                               bne     l87_2
    84  42f9 e416                               cpx     linnum
    85  42fb f003                               beq     l87_3                           ; line is <= last line requested, continue
    86  42fd b30901             l87_2           +lbcs   find_exit                       ; line is >  last line requested, exit
    87                          
    88  4300 a203               l87_3           ldx     #3                              ; set initial position - 1 (past link & line#)
    89  4302 863f                               stx     fndpnt
    90                          
    91                          
    92                          find_loop_2
    93  4304 20e1ff                             jsr     _stop                           ; check stop key
    94  4307 f31101                             +lbeq   find_break                      ; exit if down
    95                          
    96  430a a63f                               ldx     fndpnt                          ; duh, where are we?
    97  430c 18                                 clc
    98  430d 8a                                 txa                                     ; program:
    99  430e 6561                               adc     lowtr                           ; txtptr = line start + position in line
   100  4310 853d                               sta     txtptr
   101  4312 a900                               lda     #0
   102  4314 6562                               adc     lowtr+1
   103  4316 853e                               sta     txtptr+1                        ; search string:
   104  4318 a300                               ldz     #0                              ; at the beginning
   105                          
   106  431a 20a540             l88_1           jsr     chargt                          ; get next character from text
   107  431d f0b0                               beq     find_loop                       ; eol (no match this line)
   108  431f e8                                 inx                                     ; bump pointer to next character
   109  4320 d288                               cmp     (fstr1),z                       ; character match?  ind okay- buffer
   110  4322 d0f6                               bne     l88_1                           ; no
   111  4324 863f                               stx     fndpnt                          ; yes- save next position
   112                          
   113  4326 1b                 l88_2           inz                                     ; bump position in search string
   114  4327 d48a                               cpz     fstr1+2                         ; string match?
   115  4329 b00b                               bcs     print_line                      ; yes
   116  432b 20a540                             jsr     chargt
   117  432e f09f                               beq     find_loop                       ; no- eol
   118  4330 d288                               cmp     (fstr1),z                       ; ind okay- buffer
   119  4332 d0d0                               bne     find_loop_2                     ; no- rewind to beginning of search string
   120  4334 f0f0                               beq     l88_2                           ; maybe- still more chars to compare
   121                          
   122                          
   123                          ; Print the line of text at LOWTR, highlighting the section of code
   124                          ; beginning at LOWTR+FNDPNT and running for FIND_COUNT characters.
   125                          
   126                          print_line
   127  4336 20f737                             jsr     crdo                            ; get a new display line
   128  4339 a58a                               lda     fstr1+2                         ; length of string to highlight
   129  433b 8dda02                             sta     find_count
   130  433e a002                               ldy     #2
   131  4340 20ad22                             jsr     indlow                          ; get ms byte of line number
   132  4343 aa                                 tax
   133  4344 c8                                 iny
   134  4345 20ad22                             jsr     indlow                          ; get ls byte
   135  4348 207733                             jsr     p1line                          ; print #, space, and the line of code
   136  434b 7f87b6                             bbr7    op,find_loop_2                  ; Find op? branch if so and continue search
   137                          
   138                          
   139                          ; Change operation
   140                          ; Query the user and replace string1 with string2 if he wants to.
   141                          ; Options are  'Y' (yes),  '*' (do all),  'CR' (quit),  anything else means no.
   142                          
   143                          change_line
   144  434e ef8720                             bbs6    op,l89_1                        ; branch if change-all mode set
   145  4351 207dff                             jsr     _primm                          ; prompt & get response
   146  4354 0d204348414e4745...                !text cr," CHANGE? ",0
   147  435f 20d878                             jsr     response_get
   148  4362 c959                               cmp     #'Y'
   149  4364 f00b                               beq     l89_1                           ; yes, change it
   150  4366 c90d                               cmp     #cr
   151  4368 f39e00                             +lbeq   find_exit                       ; cr only, abort entire operation
   152  436b c92a                               cmp     #'*'
   153  436d d095                               bne     find_loop_2                     ; *, change all.  else don't change
   154  436f e787                               smb6    op
   155                          
   156                          ; Replace string1 with string2.  Requires moving text up/down beginning at
   157                          ; LOWTR+FNDPNT+(LEN(string1)-LEN(string2)) through TEXT_TOP and copying
   158                          ; string1 into text beginning at LOWTR+FNDPNT for LEN(string2) characters.
   159                          
   160  4371 a582               l89_1           lda     text_top                        ; setup upper address of text to move (index2)
   161  4373 8526                               sta     index2
   162  4375 a583                               lda     text_top+1                      ; TEXT_TOP
   163  4377 8527                               sta     index2+1
   164                          
   165  4379 18                                 clc                                     ; setup lower address of text to move (index1)
   166  437a a53f                               lda     fndpnt
   167  437c 6561                               adc     lowtr
   168  437e 8524                               sta     index1                          ; LOWTR+FNDPNT
   169  4380 a900                               lda     #0
   170  4382 856d                               sta     argmo                           ; count hi
   171  4384 6562                               adc     lowtr+1
   172  4386 8525                               sta     index1+1
   173                          
   174  4388 38                                 sec                                     ; calc number of chars to insert/delete
   175  4389 a58a                               lda     fstr1+2                         ; LEN(string1)-LEN(string2)
   176  438b e58d                               sbc     fstr2+2
   177  438d f052                               beq     l89_6                           ; branch if string1 = string2 (no move)
   178  438f 103d                               bpl     l89_4                           ; branch if string1 > string2 (delete)
   179                          ; else      string1 < string2 (insert)
   180                          
   181  4391 42                                 neg                                     ; Move memory up to make room for larger string2
   182  4392 850d                               sta     count
   183  4394 a000                               ldy     #0                              ; first check for line too long
   184  4396 20ad22                             jsr     indlow
   185  4399 650d                               adc     count
   186  439b 4b                                 taz
   187  439c c8                                 iny
   188  439d 20ad22                             jsr     indlow                          ; (link+#chr)-line_sa must be <256
   189  43a0 6900                               adc     #0
   190  43a2 a8                                 tay
   191  43a3 38                                 sec
   192  43a4 6b                                 tza
   193  43a5 e561                               sbc     lowtr
   194  43a7 98                                 tya
   195  43a8 e562                               sbc     lowtr+1
   196  43aa d3c432                             +lbne   errlen                          ; error, line > 255 characters
   197                          
   198  43ad 18                                 clc                                     ; now check for sufficient memory
   199  43ae a483                               ldy     text_top+1
   200  43b0 a50d                               lda     count
   201  43b2 6582                               adc     text_top
   202  43b4 9001                               bcc     l89_2
   203  43b6 c8                                 iny
   204  43b7 ccd002             l89_2           cpy     max_mem_0+1
   205  43ba 9009                               bcc     l89_3                           ; result is less than top-of-memory: ok
   206  43bc d383ea                             +lbne   omerr                           ; msb >  top, overflow
   207  43bf cdcf02                             cmp     max_mem_0                       ; msb's the same, test lsb's
   208  43c2 b37dea                             +lbcs   omerr                           ; lsb >= top, overflow
   209  43c5 8582               l89_3           sta     text_top
   210  43c7 8483                               sty     text_top+1                      ; set new top of text pointer
   211  43c9 201741                             jsr     moveup                          ; make room
   212  43cc 8013                               bra     l89_6                           ; go copy string2 into area
   213                          
   214  43ce 850d               l89_4           sta     count                           ; Move memory down for smaller string2
   215  43d0 a483                               ldy     text_top+1
   216  43d2 a582                               lda     text_top
   217  43d4 38                                 sec
   218  43d5 e50d                               sbc     count
   219  43d7 b001                               bcs     l89_5
   220  43d9 88                                 dey
   221  43da 8582               l89_5           sta     text_top
   222  43dc 8483                               sty     text_top+1                      ; set new top of text pointer
   223  43de 20c440                             jsr     movedown                        ; squish out excess space
   224                          
   225  43e1 a58d               l89_6           lda     fstr2+2                         ; Copy string2 into text
   226  43e3 f015                               beq     l89_8                           ; branch if null, nothing to copy
   227  43e5 8dda02                             sta     find_count                      ; how many characters to copy
   228  43e8 a261                               ldx     #lowtr
   229  43ea a43f                               ldy     fndpnt                          ; index into text
   230  43ec a300                               ldz     #0                              ; index into string2
   231  43ee b28b               l89_7           lda     (fstr2),z                       ; ind okay- buffer
   232  43f0 200c23                             jsr     sta_far_ram0                    ; do the copy
   233  43f3 c8                                 iny
   234  43f4 1b                                 inz
   235  43f5 ceda02                             dec     find_count
   236  43f8 d0f4                               bne     l89_7
   237                          
   238  43fa 20b930             l89_8           jsr     link_program                    ; relink program
   239  43fd 18                                 clc
   240  43fe a53f                               lda     fndpnt                          ; place find position after new text
   241  4400 658d                               adc     fstr2+2
   242  4402 3a                                 dec
   243  4403 853f                               sta     fndpnt
   244  4405 83fdfe                             +lbra   find_loop_2                     ; and resume searching
   245                          
   246                          
   247                          find_exit
   248  4408 20f737                             jsr     crdo                            ; normal exit
   249  440b 68                                 pla
   250  440c 8555                               sta     helper                          ; restore token highlight status
   251  440e 5755                               rmb5    helper                          ; remove 'find' flag
   252  4410 830efb                             +lbra   direct_mode_exit                ; done
   253                          
   254                          
   255                          
   256                          find_omerr                                              ; out of memory
   257  4413 a210                               ldx     #errom
   258  4415 2c                                 !text $2c
   259                          find_errlen                                             ; string too long
   260  4416 a217                               ldx     #errls
   261  4418 38                                 sec
   262  4419 89                                 !text $89
   263                          find_break                                              ; stop key break
   264  441a 18                                 clc
   265  441b 68                                 pla
   266  441c 8555                               sta     helper                          ; restore token highlight status
   267  441e 5755                               rmb5    helper                          ; remove 'find' flag
   268  4420 93afe8                             +lbcc   break_exit                      ; [910925]
   269  4423 832aea                             +lbra   error
   270                          
   271                          
   272                          delimit_string                                          ; command is in buffer, .x = ptr to strptr
   273  4426 8564                               sta     match                           ; delimiter character
   274  4428 a53d                               lda     txtptr                          ; point to first character in string
   275  442a 1a                                 inc                                     ; (never wraps- string in input buffer)
   276  442b 9588                               sta     fstr1,x                         ; set pointer to string data
   277  442d a53e                               lda     txtptr+1
   278  442f 9589                               sta     fstr1+1,x
   279  4431 a9ff                               lda     #$ff                            ; set string length
   280  4433 958a                               sta     fstr1+2,x
   281                          
   282  4435 f68a               l90_1           inc     fstr1+2,x
   283  4437 20a540                             jsr     chargt                          ; build string
   284  443a f30eea                             +lbeq   snerr                           ; error if eol encountered inside string
   285  443d c564                               cmp     match
   286  443f d0f4                               bne     l90_1                           ; continue until matching delimiter found
   287  4441 60                                 rts
   288                          
   289                          ;.end
   290                          
   291                          
   292                          
   293  4442 20675b             puctrl          jsr     frmstr                          ; do frmevl,frestr. return with a=len, index=~string
   294  4445 a8                                 tay
   295  4446 88                                 dey
   296  4447 c004                               cpy     #4
   297  4449 b3b30d                             +lbcs   fcerr                           ; len > 4 is illegal value error
   298                          
   299  444c 20d522             l91_1           jsr     indin1_ram1                     ; lda (index),y
   300  444f 99d411                             sta     puchrs,y
   301  4452 88                                 dey
   302  4453 10f7                               bpl     l91_1
   303  4455 60                                 rts
   304                          
   305                          ;.end
   306                          
   307                          
   308                          ; ********************************************************************************************
   309                          ;
   310                          ;	Date		Changes
   311                          ;	====		=======
   312                          ;
   313                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/trap.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      trap.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          trap
    15                          ; jsr errdir ;why not????      [910925]
    16  4456 208522                             jsr     chrgot                          ; if no #, means 'turn off trap'
    17  4459 f007                               beq     l92_1
    18  445b 208a5d                             jsr     getwrd
    19  445e 8cca02                             sty     trapno
    20  4461 2c                                 !text $2c
    21                          
    22  4462 a9ff               l92_1           lda     #$ff                            ; flag no trap
    23  4464 8dcb02                             sta     trapno+1
    24  4467 60                                 rts
    25                          
    26                          ;.end
    27                          
    28                          ; ********************************************************************************************
    29                          ;
    30                          ;	Date		Changes
    31                          ;	====		=======
    32                          ;
    33                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/resume.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      resume.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          
    16                          ; RESUME command
    17                          ;
    18                          ; Used to resume execution following a TRAPped error.
    19                          ;
    20                          ; Syntax: RESUME [line_number | NEXT]
    21                          ;
    22                          ; Can take the following forms:
    23                          ;
    24                          ; RESUME   :resume executing at the statement which caused
    25                          ;     the error.
    26                          ; RESUME NEXT  :resume execution at the statement FOLLOWING
    27                          ;     the statement which caused the error.
    28                          ; RESUME line_number :resume at the specified line number.
    29                          
    30                          
    31  4468 20e258             resume          jsr     errdir                          ; no direct mode
    32  446b aec902                             ldx     errlin+1                        ; is there an error to resume from?
    33  446e e8                                 inx
    34  446f f077                               beq     rescnt                          ; can't resume!
    35  4471 208522                             jsr     chrgot                          ; look for arguments
    36  4474 f046                               beq     resswp                          ; no arg's...restart err'd line
    37  4476 9039                               bcc     l93_3                           ; numeric argument
    38  4478 c982                               cmp     #next_token                     ; only other choice is 'next'
    39  447a d3cee9                             +lbne   snerr                           ; if not, syntax error
    40                          
    41  447d 20bc44                             jsr     resswp                          ; resume execution with next stm't
    42  4480 a000                               ldy     #0
    43  4482 20c522                             jsr     indtxt
    44  4485 d024                               bne     l93_2                           ; must be a ':'
    45  4487 c8                                 iny                                     ; must be a null,get next line
    46  4488 20c522                             jsr     indtxt                          ; make sure its not end-of-text
    47  448b d007                               bne     l93_1
    48  448d c8                                 iny
    49  448e 20c522                             jsr     indtxt
    50  4491 f3bae9                             +lbeq   ready                           ; 2 nulls, eot. bye!
    51                          
    52  4494 a003               l93_1           ldy     #3                              ; new line, update pointers
    53  4496 20c522                             jsr     indtxt
    54  4499 853b                               sta     curlin
    55  449b c8                                 iny
    56  449c 20c522                             jsr     indtxt
    57  449f 853c                               sta     curlin+1
    58  44a1 98                                 tya
    59  44a2 18                                 clc
    60  44a3 653d                               adc     txtptr
    61  44a5 853d                               sta     txtptr
    62  44a7 9002                               bcc     l93_2
    63  44a9 e63e                               inc     txtptr+1
    64  44ab 208322             l93_2           jsr     chrget                          ; skip over this character, into body of statement
    65  44ae 8398f0                             +lbra   data                            ; advance until null or ':', then rts
    66                          
    67                          
    68  44b1 208a5d             l93_3           jsr     getwrd                          ; resnum. numeric argument
    69  44b4 8517                               sta     linnum+1
    70  44b6 20d644                             jsr     resend
    71  44b9 8364f8                             +lbra   luk4it
    72                          
    73                          
    74  44bc adcd02             resswp          lda     errtxt                          ; backup one so chrget will work
    75  44bf d003                               bne     l94_1
    76  44c1 cece02                             dec     errtxt+1
    77  44c4 cecd02             l94_1           dec     errtxt
    78                          
    79  44c7 a201                               ldx     #1
    80  44c9 bdc802             l94_2           lda     errlin,x                        ; restore line#
    81  44cc 953b                               sta     curlin,x
    82  44ce bdcd02                             lda     errtxt,x                        ; restore text pointer to statement
    83  44d1 953d                               sta     txtptr,x
    84  44d3 ca                                 dex
    85  44d4 10f3                               bpl     l94_2
    86                          
    87                          
    88  44d6 aecc02             resend          ldx     tmptrp                          ; restore trap line to allow traps again
    89  44d9 8ecb02                             stx     trapno+1
    90                          error_clear
    91  44dc a2ff                               ldx     #$ff
    92  44de 8ec702                             stx     errnum                          ; reset error status- he's saying he's fixed it
    93  44e1 8ec802                             stx     errlin
    94  44e4 8ec902                             stx     errlin+1                        ; flag 'no further resumes until next error'
    95  44e7 60                                 rts
    96                          
    97                          
    98  44e8 a21f               rescnt          ldx     #errcr
    99  44ea 8363e9                             +lbra   error
   100                          
   101                          ;.end
   102                          
   103                          
   104                          ; ********************************************************************************************
   105                          ;
   106                          ;	Date		Changes
   107                          ;	====		=======
   108                          ;
   109                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/loops.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      loops.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14  44ed a001               do              ldy     #1
    15  44ef b93d00             l95_1           lda     txtptr,y                        ; save current pointers for stack entry
    16  44f2 997911                             sta     tmptxt,y
    17  44f5 b93b00                             lda     curlin,y
    18  44f8 997b11                             sta     tmplin,y
    19  44fb 88                                 dey
    20  44fc 10f1                               bpl     l95_1
    21                          
    22  44fe 208522                             jsr     chrgot                          ; look for 'while' or 'until'
    23  4501 f01b                               beq     doyes                           ; unconditional
    24  4503 c9fc                               cmp     #until_token
    25  4505 f010                               beq     do10
    26  4507 c9fd                               cmp     #while_token
    27  4509 d03f                               bne     snrjmp
    28                          
    29                          
    30                          ;  Here for WHILE
    31                          
    32  450b 20cf45                             jsr     frmjmp
    33  450e a563                               lda     facexp
    34  4510 d00c                               bne     doyes                           ; conditional evaluated true
    35                          
    36  4512 208522             dono            jsr     chrgot
    37  4515 8039                               bra     fnd010                          ; advance to end of block, do rts
    38                          
    39                          
    40                          ;  Here for UNTIL
    41                          
    42  4517 20cf45             do10            jsr     frmjmp
    43  451a a563                               lda     facexp
    44  451c d0f4                               bne     dono
    45                          
    46  451e a905               doyes           lda     #5                              ; 'do' needs 5 bytes on the run-time stack
    47  4520 209431                             jsr     getstk
    48  4523 a004                               ldy     #4                              ; ..now stuff those 5 bytes!
    49  4525 ad7a11                             lda     tmptxt+1
    50  4528 917c                               sta     (tos),y                         ; (common area)
    51  452a 88                                 dey
    52  452b ad7911                             lda     tmptxt
    53  452e 917c                               sta     (tos),y                         ; (common area)
    54  4530 88                                 dey
    55  4531 ad7c11                             lda     tmplin+1
    56  4534 917c                               sta     (tos),y                         ; (common area)
    57  4536 88                                 dey
    58  4537 ad7b11                             lda     tmplin
    59  453a 917c                               sta     (tos),y                         ; (common area)
    60  453c 88                                 dey
    61  453d a9eb                               lda     #do_token
    62  453f 917c                               sta     (tos),y                         ; (common area)
    63  4541 60                                 rts
    64                          
    65                          
    66                          ;  Here for EXIT
    67                          
    68  4542 20a045             exit            jsr     popdgo                          ; pop do entry off stack
    69  4545 208522                             jsr     chrgot
    70  4548 f006                               beq     fnd010
    71  454a 83fee8             snrjmp          +lbra   snerr
    72                          
    73                          
    74                          
    75                          ;  Find end of current block
    76                          
    77  454d 208322             fndend          jsr     chrget
    78                          
    79  4550 f017               fnd010          beq     l96_2                           ; end of statement
    80  4552 c9ec                               cmp     #loop_token
    81  4554 f3f2ef                             +lbeq   data                            ; a hit!  read to end of statement, rts
    82  4557 c922                               cmp     #'"'                            ; quote
    83  4559 f009                               beq     l96_1
    84  455b c9eb                               cmp     #do_token
    85  455d d0ee                               bne     fndend                          ; keep looking
    86  455f 204d45                             jsr     fndend                          ; recursivly
    87  4562 80ae                               bra     dono                            ; do a chrgot, go to fnd010
    88                          
    89                          
    90  4564 203236             l96_1           jsr     un_quote                        ; look for terminating quote, or end of statement
    91  4567 d0e4                               bne     fndend                          ; character after quote wasn't terminator, keep going
    92                          
    93  4569 c93a               l96_2           cmp     #':'                            ; end of line or end of stmt?
    94  456b f0e0                               beq     fndend                          ; just stmt, keep going
    95  456d 7f7e3f                             bbr7    runmod,fnderr                   ; if direct mode, not found error
    96  4570 a002                               ldy     #2
    97  4572 20c522                             jsr     indtxt                          ; end of text?
    98  4575 f038                               beq     fnderr                          ; 'fraid so
    99  4577 c8                                 iny                                     ; y=3
   100  4578 20c522                             jsr     indtxt                          ; update pointers
   101  457b 853b                               sta     curlin
   102  457d c8                                 iny
   103  457e 20c522                             jsr     indtxt
   104  4581 853c                               sta     curlin+1
   105  4583 98                                 tya
   106  4584 18                                 clc
   107  4585 653d                               adc     txtptr
   108  4587 853d                               sta     txtptr
   109  4589 90c2                               bcc     fndend
   110  458b e63e                               inc     txtptr+1
   111  458d 80be                               bra     fndend
   112                          
   113                          
   114  458f f035               loop            beq     popngo                          ; no conditionals, just do it
   115  4591 c9fd                               cmp     #while_token
   116  4593 f02c                               beq     loop10
   117  4595 c9fc                               cmp     #until_token
   118  4597 d0b1                               bne     snrjmp
   119                          
   120                          ;  Here for UNTIL
   121                          
   122  4599 20cf45                             jsr     frmjmp
   123  459c a563                               lda     facexp
   124  459e f026                               beq     popngo                          ; false, do it again!
   125                          
   126  45a0 a9eb               popdgo          lda     #do_token                       ; pop, but don't go
   127  45a2 204331                             jsr     search
   128  45a5 d015                               bne     poperr                          ; branch if not found
   129  45a7 20e631                             jsr     movfnd
   130  45aa a005                               ldy     #5
   131  45ac 8341ec                             +lbra   rlsstk
   132                          
   133                          
   134                          fnderr
   135  45af ad7b11                             lda     tmplin                          ; loop not found error: must make curlin match oldtxt
   136  45b2 ae7c11                             ldx     tmplin+1
   137  45b5 853b                               sta     curlin
   138  45b7 863c                               stx     curlin+1
   139                          
   140  45b9 a220                               ldx     #errlnf
   141  45bb 2c                                 !text $2c
   142                          poperr
   143  45bc a221                               ldx     #errlwd                         ; loop without do
   144  45be 838fe8                             +lbra   error
   145                          
   146                          
   147                          
   148                          ;  Here for WHILE
   149                          
   150                          loop10
   151  45c1 20cf45                             jsr     frmjmp
   152  45c4 f0da                               beq     popdgo                          ; false, exit
   153                          popngo
   154  45c6 63d8ff                             bsr     popdgo
   155                          ; dey
   156                          ; lda (fndpnt),y ;restore pointers
   157                          ; sta txtptr+1
   158                          ; dey
   159                          ; lda (fndpnt),y
   160                          ; sta txtptr
   161                          ; dey
   162                          ; lda (fndpnt),y
   163  45c9 204279                             jsr     retpat                          ; (** 01/18/84 fixes 'loop' to a direct mode 'do')
   164                          ; lda (fndpnt),y
   165                          ; sta curlin
   166  45cc 831fff                             +lbra   do
   167                          
   168                          frmjmp
   169  45cf 208322                             jsr     chrget
   170  45d2 831b07                             +lbra   frmevl
   171                          
   172                          ;.end
   173                          
   174                          ; ********************************************************************************************
   175                          ;
   176                          ;	Date		Changes
   177                          ;	====		=======
   178                          ;
   179                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/key.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      key.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;**************************************************************
    16                          ;
    17                          ;   KEY  Programmable Key Functions    [900725]
    18                          ;
    19                          ;**************************************************************
    20                          
    21  45d5 f033               key             beq     Key_List                        ; KEY ? yes- no args
    22                          
    23  45d7 a6d1               l97_1           ldx     _kyndx                          ; is function key buffered?
    24  45d9 d0fc                               bne     l97_1                           ; yes- hang until IRQ finishes processing it ????
    25                          
    26  45db c991                               cmp     #on_token                       ; KEY ON ?
    27  45dd d004                               bne     l97_2
    28  45df 57f7                               rmb5    _locks                          ; yes- reset Editor's lock bit
    29  45e1 8024                               bra     l97_4                           ; exit
    30                          
    31  45e3 c993               l97_2           cmp     #load_token                     ; KEY LOAD <filename>[,D#,U#]
    32  45e5 f3d500                             +lbeq   Key_load
    33                          
    34  45e8 c994                               cmp     #save_token                     ; KEY SAVE <filename>[,D#,U#]
    35  45ea f33001                             +lbeq   Key_Save
    36                          
    37  45ed c98c                               cmp     #restore_token                  ; KEY RESTORE ?      [910925]
    38  45ef d007                               bne     l97_3                           ; no
    39  45f1 57f7                               rmb5    _locks                          ; yes- reset Editor's lock bit (enable keys)
    40  45f3 20b546                             jsr     key_restore                     ; init key definitions
    41  45f6 800f                               bra     l97_4                           ; exit
    42                          
    43  45f8 c9fe               l97_3           cmp     #esc_command_token              ; KEY OFF ?
    44  45fa d39f00                             +lbne   Key_Change                      ; no- must be new key definition
    45  45fd 208322                             jsr     chrget
    46  4600 c924                               cmp     #off_token
    47  4602 d346e8                             +lbne   snerr                           ; no- bad syntax
    48  4605 d7f7                               smb5    _locks                          ; yes- set Editor's lock bit
    49  4607 837adc             l97_4           +lbra   chrget                          ; exit
    50                          
    51                          
    52                          ;**************************************************************
    53                          ;
    54                          ;   Key_List  List all function key definitions
    55                          ;
    56                          ;**************************************************************
    57                          
    58                          Key_List
    59  460a a200                               ldx     #0                              ; display all key definitions
    60  460c a000                               ldy     #0
    61                          
    62  460e e8                 lstky1          inx                                     ; get key number = 1-16
    63  460f bdff0f                             lda     _pky_lengths-1,x                ; get key size
    64  4612 f05a                               beq     lstest                          ; skip if key not defined
    65  4614 8577                               sta     keysiz                          ; save size
    66  4616 8676                               stx     z_p_temp_1                      ; save key number
    67                          
    68  4618 5a                                 phy
    69  4619 a203                               ldx     #3
    70  461b bd8c46             l98_1           lda     preamb,x                        ; print key preamble:
    71  461e 20d2ff                             jsr     _bsout
    72  4621 ca                                 dex                                     ; 'KEY '
    73  4622 10f7                               bpl     l98_1
    74  4624 a676                               ldx     z_p_temp_1                      ; key number
    75  4626 a900                               lda     #0
    76  4628 207f64                             jsr     linprt
    77  462b a92c                               lda     #','
    78  462d 20d2ff                             jsr     _bsout                          ; comma
    79                          
    80  4630 7a                                 ply
    81  4631 a207                               ldx     #7                              ; (length of 'keydat' string)
    82  4633 b91010             lsloop          lda     _pky_buffer,y                   ; print key definition
    83  4636 c8                                 iny
    84  4637 48                                 pha                                     ; save character
    85  4638 da                                 phx                                     ; save position in output string
    86                          
    87  4639 a204                               ldx     #4                              ; check for special (non-printable) characters
    88  463b dd9646             l99_1           cmp     keychr-1,x
    89  463e f033                               beq     list_special                    ; yes, display it as 'CHR$(...)'
    90  4640 ca                                 dex
    91  4641 d0f8                               bne     l99_1
    92                          
    93  4643 fa                                 plx                                     ; restore position
    94  4644 e008                               cpx     #8
    95  4646 9007                               bcc     l99_2                           ; 1st time thru- display leading quote
    96  4648 d00a                               bne     l99_3                           ; previous was a character- no additions needed
    97  464a a92b                               lda     #'+'                            ; add since previous was quote or return
    98  464c 20d2ff                             jsr     _bsout
    99  464f a922               l99_2           lda     #'"'
   100  4651 20d2ff                             jsr     _bsout                          ; add leading quote
   101  4654 68                 l99_3           pla                                     ; restore character
   102  4655 20d2ff                             jsr     _bsout                          ; display it
   103  4658 a209                               ldx     #9                              ; mark normal character
   104                          
   105  465a c677               lstnd           dec     keysiz
   106  465c d0d5                               bne     lsloop                          ; loop to end of definition
   107  465e e009                               cpx     #9
   108  4660 9005                               bcc     l100_1                          ; skip if previous not normal character
   109  4662 a922                               lda     #'"'
   110  4664 20d2ff                             jsr     _bsout                          ; add ending quote
   111                          
   112  4667 a98d               l100_1          lda     #$8d
   113  4669 20d2ff                             jsr     _bsout                          ; add ending return (shifted)
   114                          
   115  466c a676                               ldx     z_p_temp_1                      ; key number
   116  466e e010               lstest          cpx     #number_fkeys
   117  4670 d09c                               bne     lstky1                          ; ...loop until done all keys
   118  4672 60                                 rts
   119                          
   120                          
   121                          list_special
   122  4673 fa                                 plx                                     ; restore .x
   123  4674 bd8d46             l101_1          lda     keydat-3,x                      ; display something like  ' "+CHR$( '
   124  4677 20d2ff                             jsr     _bsout
   125  467a ca                                 dex
   126  467b e003                               cpx     #3
   127  467d b0f5                               bcs     l101_1
   128  467f 68                                 pla                                     ; restore character
   129  4680 203779                             jsr     prtdec                          ; display decimal value of chr in .a
   130  4683 a929                               lda     #')'                            ; finish off with closing paren.
   131  4685 20d2ff                             jsr     _bsout
   132  4688 a208                               ldx     #8                              ; mark end of special
   133  468a 80ce                               bra     lstnd                           ; ..always
   134                          
   135                          
   136  468c 2059454b           preamb          !text " YEK"                            ; key preamble
   137                          
   138  4690 28245248432b22     keydat          !text "($RHC+",$22                      ; chr$( string
   139                          
   140  4697 0d8d221b           keychr          !text cr,$8d,$22,esc                    ; special KEY chars- return, sft-return, quote, esc
   141                          
   142                          
   143                          ;************************************************************************
   144                          ;
   145                          ;   Key_Change  Add, Delete or Change function key definition
   146                          ;
   147                          ;************************************************************************
   148                          
   149                          Key_Change
   150  469b 206c5d                             jsr     getbyt                          ; get key number (1-16)
   151  469e 8676                               stx     z_p_temp_1                      ; save key number     [910925]
   152  46a0 ca                                 dex
   153  46a1 e010                               cpx     #number_fkeys
   154  46a3 b3590b                             +lbcs   fcerr                           ; exit - key number invalid
   155                          
   156                          ; stx z_p_temp_1 ;save key number
   157  46a6 205b4e                             jsr     chkcom                          ; look for comma
   158  46a9 20675b                             jsr     frmstr                          ; do frmevl, frestr. returns len in .a, addr in 'index'
   159  46ac a8                                 tay                                     ; set up for call to do-a-key
   160  46ad a901                               lda     #1                              ; tell do-a-key that string is in bank 1
   161  46af 8526                               sta     index+2
   162  46b1 a924                               lda     #index                          ; now .A points to (adr lo, adr hi, bank #)
   163  46b3 a676                               ldx     z_p_temp_1
   164                          ; inx         [910925]
   165                          key_restore
   166                          ; jsr put_io_in_map
   167  46b5 2068ff                             jsr     _doakey                         ; re-define the key
   168  46b8 b387e7                             +lbcs   omerr                           ; bad return (.c=1)
   169  46bb 60                                 rts                                     ; ok return  (.c=0)
   170                          
   171                          
   172                          ;************************************************************************
   173                          ;   Key_Load  Load function key definitions (from disk)   [900725]
   174                          ;************************************************************************
   175                          
   176                          Key_load
   177  46bc 20c946                             jsr     GetLoadChannel                  ; get a channel      [911001]
   178  46bf a010                               ldy     #>_pky_lengths
   179  46c1 a900                               lda     #<_pky_lengths
   180  46c3 20fa46                             jsr     LoadBlock                       ; load it
   181  46c6 835fec                             +lbra   list_err                        ; release channel, close file, return to main
   182                          
   183                          
   184                          GetLoadChannel                                          ; Used by KeyLoad and SpriteLoad    [911001]
   185  46c9 208322                             jsr     chrget                          ; eat LOAD token
   186  46cc a9e6                               lda     #$e6                            ; parse:  filename [,U#] [,D#]
   187  46ce 202074                             jsr     dosprs                          ; (like dopen:  0 0 0 *  * 0 0 1 )
   188  46d1 20dc77                             jsr     chk1                            ; check parameters
   189  46d4 a900                               lda     #0
   190  46d6 8d8311                             sta     dossa                           ; setup as dload would (0 = load channel)
   191  46d9 201d71                             jsr     find_la                         ; find an unused LA to use (cannot use reserved one)
   192  46dc a009                               ldy     #fopn
   193  46de a204                               ldx     #4
   194  46e0 20fd70                             jsr     open_file                       ; open the file
   195  46e3 b033                               bcs     LoadEOF                         ; exit if problem
   196  46e5 ae8111                             ldx     dosla
   197  46e8 20c6ff                             jsr     _chkin                          ; get input channel
   198  46eb b02b                               bcs     LoadEOF                         ; exit if bad??
   199  46ed 20cfff                             jsr     _basin                          ; waste dummy load address
   200  46f0 20cfff                             jsr     _basin
   201  46f3 20b7ff                             jsr     _readst                         ; prevent corruption if there's a problem
   202  46f6 d01c                               bne     LoadERR                         ; exit if problem
   203  46f8 18                                 clc
   204  46f9 60                                 rts
   205                          
   206                          
   207                          LoadBlock
   208  46fa 855a                               sta     highds                          ; where to put data
   209  46fc 845b                               sty     highds+1
   210                          LoadBlockNext
   211  46fe a000                               ldy     #0
   212  4700 20cfff             l102_1          jsr     _basin                          ; read definitions
   213  4703 915a                               sta     (highds),y
   214  4705 20b7ff                             jsr     _readst                         ; check channel status
   215  4708 d00e                               bne     LoadEOF                         ; exit if eof or error
   216  470a 20e1ff                             jsr     _stop
   217  470d f009                               beq     LoadEOF                         ; exit if stop key down
   218  470f c8                                 iny
   219  4710 d0ee                               bne     l102_1                          ; continue up to 1 page maximum
   220  4712 18                                 clc                                     ; indicate "more"
   221  4713 60                                 rts
   222                          
   223                          
   224                          LoadERR
   225  4714 a21d                               ldx     #erload                         ; Load Error
   226  4716 38                                 sec
   227  4717 89                                 !text $89
   228                          
   229                          LoadEOF
   230  4718 18                                 clc
   231  4719 830cec                             +lbra   list_err                        ; release channel, close file, return to main
   232                          
   233                          
   234                          ;************************************************************************
   235                          ;   Key_Save  Save function key definitions (from disk)   [900725]
   236                          ;************************************************************************
   237                          
   238                          Key_Save
   239  471c 202e47                             jsr     GetSaveChannel                  ; [910930]
   240  471f a95a                               lda     #highds                         ; set starting & ending addresses
   241  4721 a010                               ldy     #>_pky_lengths                  ; start address & pointer to it
   242  4723 a200                               ldx     #<_pky_lengths
   243  4725 845b                               sty     highds+1
   244  4727 865a                               stx     highds
   245  4729 c8                                 iny                                     ; end address = start address + 256 + 1
   246  472a e8                                 inx
   247  472b 833e21                             +lbra   savenb                          ; [910925]
   248                          ; jsr _savesp  ;save it
   249                          ;; clc   ; return no error  ????why not  [910404]
   250                          ; bra exit_disk_op ; but if direct mode print DOS error  [910404]
   251                          
   252                          
   253                          
   254                          GetSaveChannel                                          ; Used by KeySave and SpriteSave    [910930]
   255  472e 208322                             jsr     chrget                          ; eat SAVE token
   256  4731 a966                               lda     #$66                            ; parse:  filename [,U#] [,D#]
   257  4733 202074                             jsr     dosprs                          ; parse options
   258  4736 20e177                             jsr     chk2                            ; check required parameters
   259                          
   260  4739 a009                               ldy     #fopn                           ; DOS table offset
   261  473b a904                               lda     #4                              ; length
   262  473d 20f276                             jsr     sendp
   263  4740 a900                               lda     #sys_bank                       ; set banks ???? buffer in system bank ????
   264  4742 a200                               ldx     #sys_bank
   265  4744 4c6bff                             jmp     _setbank
   266                          
   267                          ;.end
   268                          
   269                          
   270                          ; ********************************************************************************************
   271                          ;
   272                          ;	Date		Changes
   273                          ;	====		=======
   274                          ;
   275                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/bank.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      bank.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;************************************************************************
    15                          ;*  Set Memory Bank for PEEK,POKE,WAIT,BLOAD,BSAVE and SYS,BOOT Commands
    16                          ;*
    17                          ;*  Syntax: BANK DATA  n  for PEEK,POKE,WAIT,BLOAD,BSAVE
    18                          ;*  BANK SYS  [a,x,y,z] for SYS,BOOT Commands
    19                          ;*
    20                          ;* where   n=  %11111111  to access I/O area (System MAP)
    21                          ;*      %0xxxxxxx to use physical bank n
    22                          ;*
    23                          ;* or      a,x,y,z  describe precise configuration for MAPper
    24                          ;*    if omitted, the System MAP is to be used.
    25                          ;*
    26                          ;* The DATA option is to access data,  i.e., LDA/STA_far
    27                          ;* The SYS  option is to execute code, i.e., JMP/JSR_far
    28                          ;*
    29                          ;*  Idea: BANK SCREEN n  when REC is finalized????
    30                          ;************************************************************************
    31                          
    32  4747 206c5d             bank            jsr     getbyt                          ; get bank number in .x
    33  474a 8ed102                             stx     current_bank
    34  474d 60                                 rts
    35                          
    36                          
    37                          ;.end
    38                          
    39                          ; ********************************************************************************************
    40                          ;
    41                          ;	Date		Changes
    42                          ;	====		=======
    43                          ;
    44                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/sound/play.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      play.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; C65 Music Interpreter
    16                          ;
    17                          ; Syntax : PLAY "music_string"
    18                          ;
    19                          ; Where : music_string is a string of characters composed of:
    20                          ;
    21                          ; A..G   : notes
    22                          ; W,H,Q,I,S : set note lengths to whole,half,quarter,eighth,sixteenth
    23                          ; U   : set volume level   (0-9)
    24                          ; O   : set octave    (0-6)
    25                          ; T   : set current envelope  (0-9)
    26                          ; V   : select voice to play  (1-6: 1-3 right, 4-6 left)
    27                          ; X   : filter    (0-1: 0=off, 1=on)
    28                          ; M   : measure
    29                          ; R   : rest
    30                          ; .   : dot
    31                          ; #   : sharp
    32                          ; $   : flat
    33                          
    34                          
    35  474e 20675b             play            jsr     frmstr                          ; frmevl,frestr,return w/ .A=len, (index)=>string
    36                          ; sta sw_rom_ram0  ;????
    37  4751 8576                               sta     z_p_temp_1                      ; save number of characters
    38  4753 207b49                             jsr     clear_play_flags                ; set 'dot' and 'sharp' to 0. return with Acc=0
    39  4756 8577                               sta     hulp                            ; zero counter
    40                          
    41  4758 a477               l103_1          ldy     hulp
    42  475a c476                               cpy     z_p_temp_1
    43  475c f00a                               beq     play_rts                        ; done!
    44  475e 20d522                             jsr     indin1_ram1
    45  4761 206947                             jsr     play_one_character
    46  4764 e677                               inc     hulp
    47  4766 d0f0                               bne     l103_1                          ; always
    48                          play_rts
    49  4768 60                                 rts
    50                          
    51                          
    52                          play_one_character
    53  4769 c920                               cmp     #' '                            ; spaces are a 'no-op'
    54  476b f0fb                               beq     play_rts
    55                          
    56  476d c941               l104_1          cmp     #'A'                            ; note name a-g?
    57  476f 9005                               bcc     l104_2
    58  4771 c948                               cmp     #'H'
    59  4773 934601                             +lbcc   play_note                       ; yes...play it
    60                          
    61  4776 a204               l104_2          ldx     #4                              ; test for notes,'w,h,q,i,s'
    62  4778 dd9649             l104_3          cmp     notes,x
    63  477b f31d01                             +lbeq   set_note_length
    64  477e ca                                 dex
    65  477f 10f7                               bpl     l104_3
    66                          
    67  4781 c952                               cmp     #'R'                            ; rest?
    68  4783 f3a101                             +lbeq   play_rest
    69  4786 c92e                               cmp     #'.'                            ; dotted note?
    70  4788 f30c01                             +lbeq   play_dot
    71                          
    72  478b a205                               ldx     #5                              ; test for v,o,t,x,u,m commands
    73  478d dd9b49             l104_4          cmp     mutabl,x
    74  4790 f36c01                             +lbeq   play_command
    75  4793 ca                                 dex
    76  4794 10f7                               bpl     l104_4                          ; test all 5 characters in table
    77                          
    78  4796 c923                               cmp     #'#'                            ; sharp?
    79  4798 f37d01                             +lbeq   play_sharp
    80  479b c924                               cmp     #'$'                            ; flat?
    81  479d f37b01                             +lbeq   play_flat
    82                          
    83                          
    84                          ; Must be a digit here for Octave, Voice, envelope (T), filter (X), or volume (U)
    85                          
    86  47a0 38                                 sec
    87  47a1 e930                               sbc     #'0'                            ; mask nybble
    88  47a3 c90a                               cmp     #10                             ; must be in range 0..9
    89  47a5 b3e900                             +lbcs   play_bad_value
    90                          
    91  47a8 0edb11                             asl     flag                            ; octave, voice, envelope, filter, or volume?
    92  47ab b041                               bcs     set_voice
    93  47ad 0edb11                             asl     flag                            ; octave, envelope, filter, or volume?
    94  47b0 b047                               bcs     set_octave
    95  47b2 0edb11                             asl     flag                            ; envelope, filter, or volume?
    96  47b5 b04c                               bcs     set_envelope
    97  47b7 0edb11                             asl     flag                            ; filter or volume?
    98  47ba 9072                               bcc     set_volume
    99                          
   100                          set_filter
   101  47bc 207648                             jsr     wait_for_all_quiet              ; [910722]
   102  47bf c902                               cmp     #2
   103  47c1 b3cd00                             +lbcs   play_bad_value                  ; value too large
   104  47c4 4a                                 lsr                                     ; .c=on/off
   105  47c5 ac6f12                             ldy     voice                           ; 0-5
   106  47c8 be064a                             ldx     filter_offset,y                 ; 0 0 0 4 4 4
   107  47cb bd7a12                             lda     filters1+2,x                    ; get current filter data for this SID  [910612]
   108  47ce 195f79                             ora     vbits,y                         ; update filter voice bit
   109  47d1 b003                               bcs     l105_1                          ; branch to turn filter on
   110  47d3 595f79                             eor     vbits,y                         ; else, turn filter off   [910612]
   111                          
   112  47d6 9d7a12             l105_1          sta     filters1+2,x
   113                          ; lda filters1+3,x ;why????     [910612]
   114                          ; sta filters1+4,x ;save new filter-type/volume
   115                          
   116                          ; jsr put_io_in_map
   117  47d9 b9004a                             lda     SID_offset,y                    ; get hardware offset for current voice
   118  47dc 29f0                               and     #$f0                            ; $00 or $20
   119  47de a8                                 tay
   120                          ; jsr go_slow  ;      [910716] 4567R7A
   121  47df a303                               ldz     #3
   122  47e1 bd7812             l105_2          lda     filters1,x                      ; update the hardware
   123  47e4 9915d4                             sta     sid1+21,y
   124  47e7 e8                                 inx
   125  47e8 c8                                 iny
   126  47e9 3b                                 dez
   127  47ea 10f5                               bpl     l105_2
   128                          ; jsr go_fast  ;      [910716] 4567R7A
   129  47ec 8063                               bra     clear_flag                      ; always
   130                          
   131                          
   132                          set_voice
   133  47ee 3a                                 dec
   134  47ef c906                               cmp     #6                              ; stereo SIDs: 0-2=right, 3-5=left  [910612]
   135  47f1 b39d00                             +lbcs   play_bad_value
   136  47f4 8d6f12                             sta     voice                           ; 0-5
   137  47f7 8058                               bra     clear_flag                      ; always
   138                          
   139                          
   140                          set_octave
   141  47f9 c907                               cmp     #7
   142  47fb b39300                             +lbcs   play_bad_value                  ; too big octave
   143  47fe 8d7012                             sta     octave                          ; set octave
   144  4801 804e                               bra     clear_flag                      ; always
   145                          
   146                          
   147                          set_envelope
   148  4803 206a48                             jsr     wait_for_quiet                  ; [910626]
   149  4806 aa                                 tax
   150                          set_envelope_1                                          ; entry for initialization code
   151                          ; jsr put_io_in_map
   152  4807 ac6f12                             ldy     voice
   153  480a bd9d12                             lda     wavtab,x
   154  480d 996912                             sta     waveform,y                      ; set waveform
   155  4810 b9004a                             lda     SID_offset,y                    ; get hardware offset for this voice
   156  4813 a8                                 tay
   157                          ; jsr go_slow  ;      [910716] 4567R7A
   158  4814 bd8912                             lda     atktab,x
   159  4817 9905d4                             sta     sid1+5,y                        ; set attack/decay
   160  481a bd9312                             lda     sustab,x
   161  481d 9906d4                             sta     sid1+6,y                        ; set sustain/release
   162  4820 bda712                             lda     pulslw,x
   163  4823 9902d4                             sta     sid1+2,y                        ; set pulse width - low byte
   164  4826 bdb112                             lda     pulshi,x
   165  4829 9903d4                             sta     sid1+3,y                        ; set pulse width - high byte
   166                          ; jsr go_fast  ;      [910716] 4567R7A
   167  482c 8023                               bra     clear_flag
   168                          
   169                          
   170                          set_volume
   171  482e 207648                             jsr     wait_for_all_quiet              ; [910626]
   172  4831 aa                                 tax
   173  4832 ac6f12                             ldy     voice                           ; [910612]
   174  4835 b9064a                             lda     filter_offset,y                 ; get filter offset for this voice
   175  4838 a8                                 tay
   176  4839 b97b12                             lda     filters1+3,y                    ; get mode/volume for this SID
   177  483c 29f0                               and     #$f0                            ; mask out old volume
   178  483e 1d0c4a                             ora     voltab,x                        ; add new volume
   179  4841 997b12                             sta     filters1+3,y                    ; save for filter change
   180                          ; lda filters1+4,y ;get current filter-type/volume ????why  [910612]
   181                          ; and #$f0
   182                          ; ora voltab,x
   183  4844 aa                                 tax
   184  4845 ac6f12                             ldy     voice
   185  4848 b9004a                             lda     SID_offset,y                    ; get hardware offset for current voice
   186  484b 29f0                               and     #$f0                            ; $00 or $20
   187  484d a8                                 tay
   188                          ; jsr go_slow  ;      [910716] 4567R7A
   189  484e 9b18d4                             stx     sid1+24,y                       ; set new volume
   190                          ; jsr go_fast  ;      [910716] 4567R7A
   191                          ;fall into clear_flag
   192                          
   193                          clear_flag
   194  4851 a900                               lda     #0
   195  4853 8ddb11                             sta     flag
   196  4856 60                                 rts
   197                          
   198                          
   199                          go_fast
   200  4857 a586                               lda     sid_speed_flag
   201  4859 0c31d0                             tsb     vic+49
   202  485c 60                                 rts
   203                          
   204                          
   205                          go_slow
   206  485d 48                                 pha
   207  485e a940                               lda     #$40
   208  4860 2d31d0                             and     vic+49
   209  4863 1c31d0                             trb     vic+49
   210  4866 8586                               sta     sid_speed_flag
   211  4868 68                                 pla
   212  4869 60                                 rts
   213                          
   214                          
   215                          wait_for_quiet                                          ; Wait for current voice to be quiet  [910626]
   216  486a ac6f12                             ldy     voice
   217  486d be9049                             ldx     times2,y                        ; voice*2
   218  4870 3c5e12             l106_1          bit     voices+1,x                      ; test if voice is active   [910617]
   219  4873 10fb                               bpl     l106_1                          ; loop until inactive (IRQ)
   220  4875 60                                 rts
   221                          
   222                          
   223                          wait_for_all_quiet                                        ; Wait for all voices on this SID to be quiet [910626]
   224  4876 a003                               ldy     #3
   225  4878 ae6f12                             ldx     voice
   226  487b e003                               cpx     #3                              ; determine left/right SID
   227  487d b002                               bcs     l107_1
   228  487f a000                               ldy     #0
   229  4881 a303               l107_1          ldz     #3                              ; for each of 3 voices
   230  4883 be9049             l107_2          ldx     times2,y
   231  4886 3c5e12             l107_3          bit     voices+1,x                      ; wait for voice to be inactive (IRQ)
   232  4889 10fb                               bpl     l107_3
   233  488b c8                                 iny                                     ; next voice
   234  488c 3b                                 dez
   235  488d d0f4                               bne     l107_2                          ; until done 3 voices
   236  488f 60                                 rts
   237                          
   238                          
   239                          play_bad_value
   240  4890 205148                             jsr     clear_flag
   241  4893 836909                             +lbra   fcerr                           ; illegal quantity
   242                          
   243                          play_dot
   244  4896 8d7212                             sta     dnote
   245  4899 60                                 rts
   246                          
   247                          
   248                          
   249                          set_note_length
   250                          ; ldy #<beats  ;found note (.x), divide beats accordingly
   251                          ; sty ntime
   252                          ; ldy #>beats
   253                          ; sty ntime+1
   254                          
   255  489a 2c0311                             bit     _pal_ntsc                       ; determine if PAL or NTSC system  [910724]
   256  489d 3006                               bmi     l108_1                          ; ...branch if PAL
   257  489f a3a0                               ldz     #<beats_ntsc                    ; (whole note 4/4 time = 2 sec)
   258  48a1 a005                               ldy     #>beats_ntsc
   259  48a3 8004                               bra     l108_2
   260  48a5 a3b0               l108_1          ldz     #<beats_pal
   261  48a7 a004                               ldy     #>beats_pal
   262  48a9 9c7612             l108_2          stz     ntime
   263  48ac 8c7712                             sty     ntime+1
   264                          
   265  48af ca                 l108_3          dex
   266  48b0 3008                               bmi     l108_4                          ; finished dividing, exit
   267  48b2 4e7712                             lsr     ntime+1
   268  48b5 6e7612                             ror     ntime
   269  48b8 80f5                               bra     l108_3
   270                          
   271  48ba 60                 l108_4          rts
   272                          
   273                          
   274                          play_note
   275  48bb 38                                 sec
   276  48bc e941                               sbc     #'A'
   277  48be aa                                 tax
   278  48bf bda149                             lda     scalen,x                        ; note #0-11
   279  48c2 aa                                 tax
   280  48c3 a906                               lda     #6
   281  48c5 38                                 sec
   282  48c6 ed7012                             sbc     octave
   283  48c9 a8                                 tay
   284  48ca 8a                                 txa
   285  48cb 18                                 clc
   286  48cc 6d7112                             adc     sharp
   287  48cf 1003                               bpl     l109_1                          ; added sharp or nat
   288  48d1 a90b                               lda     #11                             ; underflow
   289  48d3 c8                                 iny                                     ; bump octave down
   290  48d4 c90c               l109_1          cmp     #12                             ; overflow?
   291  48d6 9003                               bcc     l109_2                          ; no...
   292  48d8 a900                               lda     #0
   293  48da 88                                 dey                                     ; bump octave up
   294  48db aa                 l109_2          tax
   295  48dc bda849                             lda     scalel,x
   296  48df 8d7412                             sta     pitch
   297                          
   298  48e2 2c0311                             bit     _pal_ntsc                       ; determine if PAL or NTSC system
   299  48e5 3005                               bmi     l109_3                          ; ...branch if PAL
   300  48e7 bdb449                             lda     scaleh,x                        ; continue as before patch
   301  48ea 8009                               bra     l109_4
   302                          
   303  48ec bdc049             l109_3          lda     scalelp,x                       ; load from PAL tables
   304  48ef 8d7412                             sta     pitch
   305  48f2 bdcc49                             lda     scalehp,x
   306                          
   307  48f5 88                 l109_4          dey
   308  48f6 3028                               bmi     play_note_1                     ; go play note
   309  48f8 4a                                 lsr
   310  48f9 6e7412                             ror     pitch
   311  48fc 80f7                               bra     l109_4
   312                          
   313                          
   314                          play_command
   315  48fe c94d                               cmp     #'M'                            ; measure?
   316  4900 f007                               beq     l110_1
   317                          
   318  4902 bd6d79                             lda     rbits,x                         ; all others, set flag for next number
   319  4905 8ddb11                             sta     flag
   320  4908 60                                 rts
   321                          
   322                          ; Wait for msb of all 3 voice counters to underflow
   323                          
   324                          ;l110_1 ldy #5
   325                          ;l110_2 lda voices,y
   326                          ; bpl l110_2
   327                          ; dey
   328                          ; dey
   329                          ; bpl l110_2
   330                          ; rts
   331                          
   332  4909 a005               l110_1          ldy     #5                              ; [910626]
   333  490b be9049             l110_2          ldx     times2,y
   334  490e 3c5e12             l110_3          bit     voices+1,x                      ; wait for voice to be inactive (IRQ)
   335  4911 10fb                               bpl     l110_3
   336  4913 88                                 dey                                     ; next voice
   337  4914 10f5                               bpl     l110_2                          ; until done 6 voices
   338  4916 60                                 rts
   339                          
   340                          
   341                          
   342                          play_sharp
   343  4917 a901                               lda     #1
   344  4919 2c                                 !text $2c
   345                          play_flat
   346  491a a9ff                               lda     #$ff
   347  491c 8d7112                             sta     sharp
   348  491f 60                                 rts
   349                          
   350                          
   351                          play_note_1                                             ; play a note
   352  4920 8d7512                             sta     pitch+1
   353  4923 a900                               lda     #0                              ; flag 'not rest'
   354  4925 2c                                 !text $2c                               ; hop
   355                          play_rest
   356  4926 a9ff                               lda     #$ff                            ; flag 'rest'
   357  4928 48                                 pha                                     ; save flag
   358  4929 ae6f12                             ldx     voice
   359  492c bc9049                             ldy     times2,x                        ; y=x*2
   360  492f b95e12             l111_1          lda     voices+1,y                      ; test if there is a note playing
   361  4932 10fb                               bpl     l111_1                          ; and loop if so
   362                          
   363  4934 78                                 sei
   364  4935 ad7612                             lda     ntime                           ; load counter for current length
   365  4938 995d12                             sta     voices,y
   366  493b ad7712                             lda     ntime+1
   367  493e 995e12                             sta     voices+1,y
   368  4941 ad7212                             lda     dnote                           ; test if this is a dotted note
   369  4944 f017                               beq     l111_2                          ; no
   370  4946 ad7712                             lda     ntime+1
   371  4949 4a                                 lsr                                     ; duration is 1.5 x current length
   372  494a 48                                 pha
   373  494b ad7612                             lda     ntime
   374  494e 6a                                 ror
   375  494f 18                                 clc
   376  4950 795d12                             adc     voices,y
   377  4953 995d12                             sta     voices,y
   378  4956 68                                 pla
   379  4957 795e12                             adc     voices+1,y
   380  495a 995e12                             sta     voices+1,y
   381                          
   382  495d 68                 l111_2          pla                                     ; test if this is a rest
   383  495e 301a                               bmi     l111_3                          ; and branch if so- clear play flags and exit [910722]
   384                          
   385                          ; jsr put_io_in_map
   386                          ; jsr go_slow  ;      [910716] 4567R7A
   387  4960 bc004a                             ldy     SID_offset,x                    ; get offset to voice hardware
   388  4963 ad7412                             lda     pitch
   389  4966 9900d4                             sta     sid1,y
   390  4969 ad7512                             lda     pitch+1
   391  496c 9901d4                             sta     sid1+1,y
   392  496f a908                               lda     #$08                            ; reset this voice
   393  4971 9904d4                             sta     sid1+4,y
   394  4974 bd6912                             lda     waveform,x                      ; and finally, turn on gate
   395  4977 9904d4                             sta     sid1+4,y
   396                          ; jsr go_fast  ;      [910716] 4567R7A
   397  497a 58                 l111_3          cli
   398                          
   399                          
   400                          clear_play_flags
   401  497b a900                               lda     #0
   402  497d 8d7112                             sta     sharp                           ; clear flags
   403  4980 8d7212                             sta     dnote
   404  4983 58                                 cli
   405  4984 60                                 rts
   406                          
   407                          
   408  4985 206c5d             tempo           jsr     getbyt                          ; duration of whole note 4/4 time = 24/rate
   409  4988 8a                                 txa
   410  4989 f37308                             +lbeq   fcerr                           ; can't be zero- illegal quantity error
   411  498c 8e7312                             stx     tempo_rate
   412  498f 60                                 rts
   413                          
   414                          
   415  4990 00020406080a       times2          !text 0,2,4,6,8,10                      ; [910612] stereo
   416                          
   417  4996 5748514953         notes           !text "WHQIS"                           ; sixteenth,eigth,quarter,half,and whole notes
   418                          
   419  499b 564f5458554d       mutabl          !text "VOTXUM"                          ; voice,octave,envelope,filter,volume,& measure
   420                          
   421  49a1 090b0002040507     scalen          !text 9,11,0,2,4,5,7                    ; a,b,c,d,e,f,g
   422                          
   423  49a8 0f0c46bf7d83       scalel          !text $0f,$0c,$46,$bf,$7d,$83           ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (NTSC, octave 6)
   424  49ae d67a73c87c97                       !text $d6,$7a,$73,$c8,$7c,$97           ; [910729]
   425                          
   426  49b4 43474b4f5459       scaleh          !text $43,$47,$4b,$4f,$54,$59           ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (NTSC, octave 6)
   427  49ba 5e646a70777e                       !text $5e,$64,$6a,$70,$77,$7e           ; [910729]
   428                          
   429  49c0 878bcc4e1424       scalelp         !text $87,$8b,$cc,$4e,$14,$24           ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (PAL,  octave 6)
   430  49c6 802d3291527a                       !text $80,$2d,$32,$91,$52,$7a           ; [910729]
   431                          
   432  49cc 43474b50555a       scalehp         !text $43,$47,$4b,$50,$55,$5a           ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (PAL,  octave 6)
   433  49d2 5f656b71787f                       !text $5f,$65,$6b,$71,$78,$7f           ; [910729]
   434                          
   435                          ;  Music envelope tables, default values downloaded to RAM:
   436                          ;
   437                          ; 0: piano   1: accordion    2: calliope  3: drum     4: flute
   438                          ; 5: guitar  6: harpsichord  7: organ     8: trumpet  9: xylophone
   439                          
   440                          ;  Attack/decay rates
   441                          
   442  49d8 09c0000594090909...atkmus          !text $09,$c0,$00,$05,$94,$09,$09,$09,$89,$09
   443                          
   444                          ;  Sustain/release rates
   445                          
   446  49e2 00c0f05040210090...susmus          !text $00,$c0,$f0,$50,$40,$21,$00,$90,$41,$00
   447                          
   448                          ;  Waveform table
   449                          
   450  49ec 4121118111214141...wavmus          !text $41,$21,$11,$81,$11,$21,$41,$41,$41,$11
   451                          
   452                          ;  Pulse width hi table
   453                          
   454  49f6 0600000000000208...pwhmus          !text $06,$00,$00,$00,$00,$00,$02,$08,$02,$00
   455                          
   456                          ;  Offset tables
   457                          
   458                          SID_offset
   459  4a00 00070e20272e                       !text $00,$07,$0e,$20,$27,$2e           ; [910612] stereo
   460                          filter_offset
   461  4a06 000000040404                       !text 0,0,0,4,4,4
   462                          
   463                          ;  Volume levels
   464                          
   465  4a0c 0001030507080a0c...voltab          !text 0,1,3,5,7,8,10,12,14,15
   466                          
   467                          ;.end
   468                          
   469                          ; ********************************************************************************************
   470                          ;
   471                          ;	Date		Changes
   472                          ;	====		=======
   473                          ;
   474                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/sound/filter.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      filter.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;******************************************************************
    16                          ;
    17                          ;  FILTER  sid, freq, lp, bp, hp, res   --  set values for filter
    18                          ;
    19                          ;     sid =  right (1), left (2)
    20                          ;          freq =  filter frequency (0-1023)
    21                          ;            lp =  low pass filter on (1) or off (0)
    22                          ;            bp =  band pass filter on (1) or off (0)
    23                          ;            hp =  high pass filter on (1) or off (0)
    24                          ;           res =  resonance (0-15)
    25                          ;
    26                          ;******************************************************************
    27                          
    28  4a16 206c5d             filter          jsr     getbyt                          ; get left/right SID    [910612]
    29  4a19 ca                                 dex
    30  4a1a e002                               cpx     #2
    31  4a1c b3e007                             +lbcs   fcerr
    32  4a1f bd084a                             lda     filter_offset+2,x               ; get filter offset for specified SID
    33  4a22 8576                               sta     z_p_temp_1
    34  4a24 aa                                 tax
    35                          
    36  4a25 a000                               ldy     #0
    37  4a27 bd7812             l112_1          lda     filters1,x                      ; save current voice's filter params
    38  4a2a 998012                             sta     fltsav,y
    39  4a2d e8                                 inx
    40  4a2e c8                                 iny
    41  4a2f c004                               cpy     #4
    42  4a31 90f4                               bcc     l112_1
    43                          
    44  4a33 20f278                             jsr     optwrd                          ; get filter frequency
    45  4a36 9017                               bcc     l112_2                          ; skip if no value given
    46  4a38 c908                               cmp     #8                              ; test m.s. byte
    47  4a3a b3c207                             +lbcs   fcerr                           ; error if > 2047
    48  4a3d 8c8012                             sty     fltsav                          ; save lower byte
    49                          
    50                          ; Idea: shift lower 3 bits of upper byte into lower byte, forming bits 10-3
    51                          
    52  4a40 8c8112                             sty     fltsav+1
    53  4a43 4a                                 lsr
    54  4a44 6e8112                             ror     fltsav+1
    55  4a47 4a                                 lsr
    56  4a48 6e8112                             ror     fltsav+1                        ; save upper 7 bits (10-3)
    57  4a4b 4a                                 lsr
    58  4a4c 6e8112                             ror     fltsav+1
    59                          
    60  4a4f a910               l112_2          lda     #$10                            ; start at type=LP
    61  4a51 8d8412                             sta     fltflg
    62  4a54 ad8012                             lda     fltsav
    63                          
    64  4a57 202679             l112_3          jsr     optbyt                          ; get filter types (LP,BP,HP)
    65  4a5a 9017                               bcc     l112_6                          ; skip if no value input
    66  4a5c e001                               cpx     #1                              ; (set .c: 0=0, 1=1)
    67  4a5e 9005                               bcc     l112_4
    68  4a60 f003                               beq     l112_4
    69  4a62 839a07                             +lbra   fcerr                           ; error if >1
    70                          
    71  4a65 ad8312             l112_4          lda     fltsav+3                        ; get filter flags byte
    72  4a68 0d8412                             ora     fltflg                          ; set filter on
    73  4a6b b003                               bcs     l112_5                          ; skip if it should be on
    74  4a6d 4d8412                             eor     fltflg                          ; turn filter off
    75  4a70 8d8312             l112_5          sta     fltsav+3                        ; save value
    76                          
    77  4a73 0e8412             l112_6          asl     fltflg                          ; shift for next filter
    78  4a76 10df                               bpl     l112_3                          ; loop 3 times
    79                          
    80  4a78 202679                             jsr     optbyt                          ; get resonance value
    81  4a7b 9016                               bcc     l112_7                          ; skip if no value given
    82                          ; cpx #16
    83                          ; bcs fcerr  ;error if >15
    84  4a7d 2010b5                             jsr     chknyb                          ; [910930]
    85  4a80 8a                                 txa
    86  4a81 0a                                 asl                                     ; shift to upper nibble
    87  4a82 0a                                 asl
    88  4a83 0a                                 asl
    89  4a84 0a                                 asl
    90  4a85 8dbc12                             sta     nibble
    91  4a88 ad8212                             lda     fltsav+2                        ; get current value
    92  4a8b 290f                               and     #$0f                            ; mask it out
    93  4a8d 0dbc12                             ora     nibble                          ; add new value
    94  4a90 8d8212                             sta     fltsav+2                        ; save it
    95                          
    96  4a93 a676               l112_7          ldx     z_p_temp_1                      ; hardware offset for this voice's filter [910612]
    97  4a95 a000                               ldy     #0
    98  4a97 b98012             l112_8          lda     fltsav,y                        ; copy new filter params to hardware
    99  4a9a 9d7812                             sta     filters1,x
   100  4a9d e8                                 inx
   101  4a9e c8                                 iny
   102  4a9f c004                               cpy     #4
   103  4aa1 90f4                               bcc     l112_8
   104  4aa3 60                                 rts
   105                          
   106                          ;.end
   107                          
   108                          
   109                          ; ********************************************************************************************
   110                          ;
   111                          ;	Date		Changes
   112                          ;	====		=======
   113                          ;
   114                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/sound/envelope.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      envelope.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;****************************************************************
    15                          ;
    16                          ;  ENVELOPE n, attack, decay, sustain, release, waveform, pulse width
    17                          ;        set music envelope
    18                          ;                n = envelope number (0-9)
    19                          ;            wave  =   0 : triangle waveform
    20                          ;                      1 : sawtooth waveform
    21                          ;                      2 : pulse waveform
    22                          ;                      3 : noise waveform
    23                          ;                      4 : ring modulation
    24                          ;            pulse = pulse width if pulse waveform is selected (0-4095)
    25                          ;
    26                          ;******************************************************************
    27                          
    28                          envelope
    29  4aa4 206c5d                             jsr     getbyt                          ; get envelope number
    30  4aa7 e00a                               cpx     #10
    31  4aa9 b35307                             +lbcs   fcerr                           ; exit - invalid tone number
    32  4aac 8e8512                             stx     tonnum                          ; save number
    33  4aaf bd8912                             lda     atktab,x                        ; get attack/decay rates
    34  4ab2 8d8612                             sta     tonval
    35  4ab5 bd9312                             lda     sustab,x                        ; get sustain/release rates
    36  4ab8 8d8712                             sta     tonval+1
    37  4abb bd9d12                             lda     wavtab,x                        ; get waveform and filter
    38  4abe 8d8812                             sta     tonval+2
    39                          
    40  4ac1 a200                               ldx     #0
    41  4ac3 8ebb12             l113_1          stx     parcnt
    42  4ac6 202679                             jsr     optbyt                          ; get parameter - attack or sustain
    43  4ac9 9016                               bcc     l113_2                          ; skip if no input
    44  4acb 8a                                 txa
    45  4acc 0a                                 asl
    46  4acd 0a                                 asl                                     ; shift to upper nibble
    47  4ace 0a                                 asl
    48  4acf 0a                                 asl
    49  4ad0 8dbc12                             sta     nibble                          ; save it
    50  4ad3 aebb12                             ldx     parcnt
    51  4ad6 bd8612                             lda     tonval,x                        ; get current value
    52  4ad9 290f                               and     #$0f                            ; mask it out
    53  4adb 0dbc12                             ora     nibble                          ; add new value
    54  4ade 9d8612                             sta     tonval,x                        ; save it
    55                          
    56  4ae1 202679             l113_2          jsr     optbyt                          ; get decay or release rate
    57  4ae4 9014                               bcc     l113_3                          ; skip if no input
    58  4ae6 8a                                 txa
    59  4ae7 290f                               and     #$0f                            ; use only lower nibble
    60  4ae9 8dbc12                             sta     nibble                          ; save it
    61  4aec aebb12                             ldx     parcnt
    62  4aef bd8612                             lda     tonval,x                        ; get current value
    63  4af2 29f0                               and     #$f0                            ; mask it out
    64  4af4 0dbc12                             ora     nibble                          ; add new value
    65  4af7 9d8612                             sta     tonval,x                        ; save it
    66                          
    67  4afa aebb12             l113_3          ldx     parcnt
    68  4afd e8                                 inx
    69  4afe e001                               cpx     #1
    70  4b00 f0c1                               beq     l113_1                          ; loop to do sustain/release rates
    71  4b02 202679                             jsr     optbyt                          ; get waveform
    72  4b05 9011                               bcc     l113_5                          ; skip if no value
    73  4b07 a915                               lda     #$15                            ; assume ring modulation
    74  4b09 e004                               cpx     #4
    75  4b0b f008                               beq     l113_4                          ; skip if correct
    76  4b0d b3ef06                             +lbcs   fcerr                           ; error if >4
    77  4b10 bd6979                             lda     sbits+4,x                       ; get waveform bit
    78  4b13 0901                               ora     #1                              ; set gate bit
    79                          
    80  4b15 8d8812             l113_4          sta     tonval+2                        ; save waveform
    81                          
    82  4b18 20f278             l113_5          jsr     optwrd                          ; is there a pulse width arg?
    83  4b1b 9013                               bcc     l113_6                          ; nope, done
    84                          
    85  4b1d aa                                 tax                                     ; save msb
    86  4b1e ad8812                             lda     tonval+2                        ; get waveform
    87  4b21 2940                               and     #$40
    88  4b23 f00b                               beq     l113_6                          ; skip if not pulse waveform
    89  4b25 8a                                 txa
    90  4b26 ae8512                             ldx     tonnum                          ; get envelope number
    91  4b29 9db112                             sta     pulshi,x                        ; save high byte of pulse width
    92  4b2c 98                                 tya
    93  4b2d 9da712                             sta     pulslw,x                        ; save low byte
    94                          
    95  4b30 ae8512             l113_6          ldx     tonnum
    96  4b33 ad8612                             lda     tonval                          ; set inputted values
    97  4b36 9d8912                             sta     atktab,x
    98  4b39 ad8712                             lda     tonval+1
    99  4b3c 9d9312                             sta     sustab,x
   100  4b3f ad8812                             lda     tonval+2
   101  4b42 9d9d12                             sta     wavtab,x
   102                          volrts
   103  4b45 60                                 rts
   104                          
   105                          ;.end
   106                          
   107                          
   108                          ; ********************************************************************************************
   109                          ;
   110                          ;	Date		Changes
   111                          ;	====		=======
   112                          ;
   113                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/sound/volume.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      volume.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;***************************************************************
    15                          ;*
    16                          ;*  VOLUME - set volume of SID chips
    17                          ;*
    18                          ;* Syntax : VOLUME [right] [,left]
    19                          ;*
    20                          ;* Where  : vol in 0..15
    21                          ;*
    22                          ;***************************************************************
    23                          
    24  4b46 f302e3             volume          +lbeq   snerr                           ; stereo parameters    [910612]
    25  4b49 c92c                               cmp     #','
    26  4b4b f017                               beq     l114_1                          ; left volume only
    27                          ; jsr getbyt  ;right volume in .x
    28                          ; cpx #16
    29                          ; bcs fcerr  ;too large
    30  4b4d 200db5                             jsr     getnyb                          ; [910930]
    31  4b50 8676                               stx     z_p_temp_1                      ; a temp (sorry fred)
    32                          
    33                          ; The way this is done must work with 'PLAY' without too much conflict.
    34                          ; So, along with setting the SID 'volume' reg, we'll also set up PLAY's
    35                          ; record of current volume as well.
    36                          
    37  4b52 ad7b12                             lda     filters1+3
    38  4b55 29f0                               and     #$f0
    39  4b57 0576                               ora     z_p_temp_1
    40  4b59 8d7b12                             sta     filters1+3
    41                          
    42                          ; lda filters1+4  ;???? why     [910612]
    43                          ; and #$f0
    44                          ; ora z_p_temp_1
    45                          ; sta filters1+4
    46                          
    47                          ; jsr put_io_in_map
    48                          ; jsr go_slow  ;      [910716] 4567R7A
    49  4b5c 8d18d4                             sta     sid1+24
    50                          ; jsr go_fast  ;      [910716] 4567R7A
    51  4b5f 208522                             jsr     chrgot
    52  4b62 f0e1                               beq     volrts
    53                          
    54  4b64 202679             l114_1          jsr     optbyt                          ; get optional left parameter   [910612]
    55  4b67 93e1e2                             +lbcc   snerr                           ; comma but no value not given??
    56  4b6a 2010b5                             jsr     chknyb                          ; [910930]
    57                          ; cpx #16
    58                          ; bcs fcerr  ;too large
    59  4b6d 8676                               stx     z_p_temp_1                      ; a temp (sorry fred)
    60                          
    61  4b6f ad7f12                             lda     filters2+3
    62  4b72 29f0                               and     #$f0
    63  4b74 0576                               ora     z_p_temp_1
    64  4b76 8d7f12                             sta     filters2+3
    65                          
    66                          ; lda filters2+4  ;???? why     [910612]
    67                          ; and #$f0
    68                          ; ora z_p_temp_1
    69                          ; sta filters2+4
    70                          
    71                          ; jsr put_io_in_map
    72                          ; jsr go_slow  ;      [910716] 4567R7A
    73  4b79 8d38d4                             sta     sid2+24
    74                          ; jsr go_fast  ;      [910716] 4567R7A
    75  4b7c 60                                 rts
    76                          
    77                          ;.end
    78                          
    79                          ; ********************************************************************************************
    80                          ;
    81                          ;	Date		Changes
    82                          ;	====		=======
    83                          ;
    84                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/sound/sound.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      sound.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*****************************************************************************
    16                          ;*
    17                          ;*  SOUND - Produce sound effects
    18                          ;*
    19                          ;* Syntax : SOUND v, f, d [,[dir] [,[m] [,[s] [,[w] [,p] ]]]]
    20                          ;*
    21                          ;* Where : v   = voice    (1..6)
    22                          ;*  f   = frequency    (0..65535)
    23                          ;*  d   = duration    (0..32767 jiffys)
    24                          ;*  dir = step direction  (0(up) ,1(down) or 2(oscillate)) default=0
    25                          ;*  m   = minimum frequency  (if sweep is used) (0..65535) default=0
    26                          ;*  s   = step value for effects  (0..32767) default=0
    27                          ;*  w   = waveform  (0=triangle,1=saw,2=square,3=noise) default=2
    28                          ;*  p   = pulse width  (0..4095) default=2048 (50% duty cycle)
    29                          ;*
    30                          ;*****************************************************************************
    31                          
    32  4b7d c99c               sound           cmp     #clr_token                      ; SOUND CLR: init sound/music environment [910717]
    33  4b7f f3d472                             +lbeq   Sound_CLR                       ; yes
    34                          
    35  4b82 206c5d                             jsr     getbyt                          ; get voice number in .X
    36  4b85 ca                                 dex                                     ; adjust 1..3 to 0..2
    37  4b86 e006                               cpx     #6                              ; [910612]
    38  4b88 b37406             l115_1          +lbcs   fcerr                           ; illegal value
    39                          
    40  4b8b 8ebd12             l115_2          stx     sound_voice
    41                          
    42                          ; Get frequency
    43                          
    44  4b8e 20875d                             jsr     comwrd                          ; eat comma, get frequency in y,a
    45  4b91 8c6211                             sty     temp_max_lo                     ; save our copy of max, also set up as current
    46  4b94 8d6311                             sta     temp_max_hi
    47  4b97 8c6911                             sty     temp_freq_lo
    48  4b9a 8d6a11                             sta     temp_freq_hi
    49                          
    50                          ; Get duration
    51                          
    52  4b9d 20875d                             jsr     comwrd                          ; eat comma, get number of jiffys to play
    53  4ba0 c980                               cmp     #$80
    54  4ba2 b0e4                               bcs     l115_1
    55  4ba4 8c6011                             sty     temp_time_lo
    56  4ba7 8d6111                             sta     temp_time_hi
    57                          
    58                          ; Get sweep direction
    59                          
    60  4baa 202479                             jsr     optzer                          ; get optional sweep (default = 0, up)
    61  4bad e003                               cpx     #3
    62  4baf b0d7                               bcs     l115_1
    63  4bb1 8a                                 txa
    64  4bb2 8d6611                             sta     temp_direction
    65  4bb5 2901                               and     #1                              ; set .Z if sweep up or oscillate
    66  4bb7 08                                 php                                     ; save .Z for step (below)
    67                          
    68                          ; Get minimum frequency value (sweep lo)
    69                          
    70  4bb8 20f278                             jsr     optwrd
    71  4bbb 8c6411                             sty     temp_min_lo
    72  4bbe 8d6511                             sta     temp_min_hi
    73                          
    74                          ; Get step value for sweep
    75                          
    76  4bc1 20f278                             jsr     optwrd                          ; get optional step, default is zero
    77  4bc4 28                                 plp                                     ; get flags from direction
    78  4bc5 f00d                               beq     l115_3                          ; branch if 'up' or oscillate
    79  4bc7 48                                 pha                                     ; if 'down', make step 2's complement
    80  4bc8 98                                 tya
    81  4bc9 49ff                               eor     #$ff
    82  4bcb 18                                 clc
    83  4bcc 6901                               adc     #1
    84  4bce a8                                 tay
    85  4bcf 68                                 pla
    86  4bd0 49ff                               eor     #$ff
    87  4bd2 6900                               adc     #0
    88  4bd4 8d6811             l115_3          sta     temp_step_hi
    89  4bd7 98                                 tya
    90  4bd8 8d6711                             sta     temp_step_lo
    91                          
    92                          ; Get waveform
    93                          
    94  4bdb a202                               ldx     #2                              ; get waveform. default is square (2)
    95  4bdd 202679                             jsr     optbyt
    96  4be0 e004                               cpx     #4
    97  4be2 b0a4                               bcs     l115_1                          ; illegal value
    98  4be4 bd6979                             lda     sbits+4,x                       ; get bit pattern for selected waveform
    99  4be7 0901                               ora     #1                              ; add in the gate bit
   100  4be9 8d6d11                             sta     temp_waveform
   101                          
   102                          ; Get pulse width
   103                          
   104  4bec 20f278                             jsr     optwrd                          ; get optional pulse width in y,a
   105  4bef b004                               bcs     l115_4
   106  4bf1 a908                               lda     #8                              ; no arg's given, use default pulse width
   107  4bf3 a000                               ldy     #0
   108  4bf5 c910               l115_4          cmp     #16
   109  4bf7 b08f                               bcs     l115_1
   110  4bf9 8c6b11                             sty     temp_pulse_lo
   111  4bfc 8d6c11                             sta     temp_pulse_hi
   112                          
   113                          ; All arg's in, time to get to work
   114                          
   115  4bff ad6011                             lda     temp_time_lo
   116  4c02 0d6111                             ora     temp_time_hi
   117  4c05 f046                               beq     l115_9                          ; special case: time=0 means 'kill it NOW'
   118                          
   119                          ; Wait for all current uses of this voice to time out
   120                          
   121  4c07 aebd12                             ldx     sound_voice                     ; first test 'PLAY'
   122  4c0a 8a                                 txa                                     ; make an index into PLAY's tables
   123  4c0b 0a                                 asl
   124  4c0c a8                                 tay
   125  4c0d b95e12             l115_5          lda     voices+1,y
   126  4c10 10fb                               bpl     l115_5
   127                          
   128  4c12 bdc412             l115_6          lda     sound_time_hi,x                 ; now test 'SOUND'
   129  4c15 10fb                               bpl     l115_6
   130                          
   131                          ; All clear, now set up for current effect
   132                          
   133  4c17 a000                               ldy     #0                              ; download max freq l&h, min freq l&h,
   134  4c19 b96211             l115_7          lda     temp_max_lo,y                   ; ..sweep direction, step value l&h, & freq l&h
   135  4c1c 9dca12                             sta     sound_max_lo,x
   136  4c1f e8                                 inx
   137  4c20 e8                                 inx
   138  4c21 e8                                 inx
   139  4c22 e8                                 inx                                     ; [910612] stereo
   140  4c23 e8                                 inx
   141  4c24 e8                                 inx
   142  4c25 c8                                 iny
   143  4c26 c009                               cpy     #9
   144  4c28 90ef                               bcc     l115_7
   145                          
   146                          ; Now set up SID
   147                          
   148  4c2a aebd12                             ldx     sound_voice
   149  4c2d bc004a                             ldy     SID_offset,x                    ; get index to SID voices
   150                          ; jsr put_io_in_map
   151                          ; jsr go_slow  ;      [910716] 4567R7A
   152                          
   153  4c30 a908                               lda     #$08                            ; turn off SID gate
   154  4c32 9904d4                             sta     sid1+4,y
   155                          
   156  4c35 a900                               lda     #0                              ; set up attack & decay,
   157  4c37 9905d4                             sta     sid1+5,y
   158  4c3a a9f0                               lda     #$f0                            ; ..and sustain & release
   159  4c3c 9906d4                             sta     sid1+6,y
   160                          
   161  4c3f a200                               ldx     #0                              ; set up freq (l&h), pulse width (l&h), & waveform
   162  4c41 bd6911             l115_8          lda     temp_freq_lo,x
   163  4c44 9900d4                             sta     sid1,y
   164  4c47 c8                                 iny
   165  4c48 e8                                 inx
   166  4c49 e005                               cpx     #5
   167  4c4b d0f4                               bne     l115_8
   168                          ; jsr go_fast  ;      [910716] 4567R7A
   169                          
   170                          ; Now set up time to play
   171                          
   172  4c4d aebd12             l115_9          ldx     sound_voice
   173  4c50 ac6011                             ldy     temp_time_lo
   174  4c53 ad6111                             lda     temp_time_hi
   175                          
   176  4c56 78                                 sei
   177  4c57 9dc412                             sta     sound_time_hi,x
   178  4c5a 98                                 tya
   179  4c5b 9dbe12                             sta     sound_time_lo,x
   180  4c5e 58                                 cli
   181                          
   182  4c5f 60                                 rts
   183                          
   184                          ;.end
   185                          
   186                          ; ********************************************************************************************
   187                          ;
   188                          ;	Date		Changes
   189                          ;	====		=======
   190                          ;
   191                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/text/window.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      window.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;****************************************************************
    16                          ;*
    17                          ;*  WINDOW Command
    18                          ;*
    19                          ;*  Syntax : WINDOW upper-left col, upper-left row,
    20                          ;*      lower-left col, lower-right row [,clear]
    21                          ;*
    22                          ;*  Where  :  0 <= row <= 24
    23                          ;*       0 <= column <= (80/40)
    24                          ;*       clear : 0 (no) or 1 (yes)
    25                          ;*
    26                          ;****************************************************************
    27                          
    28  4c60 206c5d             window          jsr     getbyt                          ; get u.l. col
    29  4c63 e050                               cpx     #80
    30  4c65 7fd702                             bbr7    _mode,l116_1
    31  4c68 e028                               cpx     #40
    32  4c6a b057               l116_1          bcs     l116_4
    33  4c6c 8e7911                             stx     window_temp
    34                          
    35  4c6f 20825d                             jsr     combyt                          ; get u.l. row
    36  4c72 e019                               cpx     #25
    37  4c74 b04d                               bcs     l116_4
    38  4c76 8e7a11                             stx     window_temp+1
    39                          
    40  4c79 20825d                             jsr     combyt                          ; get l.r. column
    41  4c7c e050                               cpx     #80
    42  4c7e 7fd702                             bbr7    _mode,l116_2
    43  4c81 e028                               cpx     #40
    44  4c83 b03e               l116_2          bcs     l116_4
    45  4c85 8e7b11                             stx     window_temp+2
    46  4c88 ec7911                             cpx     window_temp                     ; can't be less than u.l. column
    47  4c8b 9036                               bcc     l116_4
    48                          
    49  4c8d 20825d                             jsr     combyt                          ; get l.r. row
    50  4c90 e019                               cpx     #25
    51  4c92 b02f                               bcs     l116_4
    52  4c94 8e7c11                             stx     window_temp+3
    53  4c97 ec7a11                             cpx     window_temp+1                   ; can't be less than u.l. row
    54  4c9a 9027                               bcc     l116_4
    55                          
    56  4c9c 202479                             jsr     optzer                          ; get optional clear flag
    57  4c9f e002                               cpx     #2
    58  4ca1 b020                               bcs     l116_4
    59  4ca3 da                                 phx
    60                          
    61  4ca4 ae7911                             ldx     window_temp
    62  4ca7 ad7a11                             lda     window_temp+1
    63  4caa 18                                 clc
    64  4cab 202de0                             jsr     _set_window
    65                          
    66  4cae ae7b11                             ldx     window_temp+2
    67  4cb1 ad7c11                             lda     window_temp+3
    68  4cb4 38                                 sec
    69  4cb5 202de0                             jsr     _set_window
    70                          
    71  4cb8 a213                               ldx     #19                             ; assume 'home', not 'cls'
    72  4cba 68                                 pla
    73  4cbb f002                               beq     l116_3
    74  4cbd a293                               ldx     #147
    75  4cbf 8a                 l116_3          txa
    76  4cc0 4cd2ff                             jmp     _bsout
    77                          
    78  4cc3 833905             l116_4          +lbra   fcerr                           ; illegal value error
    79                          
    80                          ;.end
    81                          
    82                          ; ********************************************************************************************
    83                          ;
    84                          ;	Date		Changes
    85                          ;	====		=======
    86                          ;
    87                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/fastslow.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      fastslow.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;***********************************************************************
    16                          ;
    17                          ;    FAST - put the system in FAST (4 MHz?) mode.
    18                          ;
    19                          ;***********************************************************************
    20                          
    21                          fast
    22  4cc6 d382e1                             +lbne   snerr                           ; no args      [910410]
    23                          ; jsr put_io_in_map
    24  4cc9 a940                               lda     #%01000000
    25  4ccb 0c31d0                             tsb     vic+49                          ; set FAST (4MHz?) mode
    26  4cce 60                                 rts
    27                          
    28                          
    29                          
    30                          ;***********************************************************************
    31                          ;
    32                          ;    SLOW - put the system in SLOW (1 MHz) mode.
    33                          ;
    34                          ;***********************************************************************
    35                          
    36                          slow
    37  4ccf d379e1                             +lbne   snerr                           ; no args      [910410]
    38                          ; jsr put_io_in_map
    39  4cd2 a940                               lda     #%01000000
    40  4cd4 1c31d0                             trb     vic+49
    41  4cd7 60                                 rts
    42                          
    43                          ;.end
    44                          
    45                          
    46                          
    47                          ; These routines check for certain VALTYP.   (c) is not preserved.
    48                          
    49                          
    50                          
    51  4cd8 20ef4c             frmnum          jsr     frmevl
    52                          
    53  4cdb 18                 chknum          clc
    54  4cdc 89                                 !text $89
    55                          
    56  4cdd 38                 chkstr          sec
    57                          
    58                          chkval
    59                          ; bbs7 valtyp,docstr ;cannot do this- return status +/-/= needed!
    60  4cde 240f                               bit     valtyp
    61  4ce0 3003                               bmi     docstr
    62  4ce2 b003                               bcs     chkerr
    63  4ce4 60                 chkok           rts
    64                          
    65  4ce5 b0fd               docstr          bcs     chkok
    66                          
    67  4ce7 a216               chkerr          ldx     #errtm
    68  4ce9 2c                                 !text $2c
    69                          
    70  4cea a219               sterr           ldx     #errst
    71  4cec 8361e1                             +lbra   error
    72                          
    73                          ;.end
    74                          
    75                          
    76                          ; ********************************************************************************************
    77                          ;
    78                          ;	Date		Changes
    79                          ;	====		=======
    80                          ;
    81                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/evaluate.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      evaluate.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ; Formula Evaluator Routine
    15                          ;
    16                          ; The formula evaluator starts with (txtptr) pointing to the first character
    17                          ; in the formula.  At the end (txtptr) points to the terminator.
    18                          ; The result is left in the FAC.  On return (a) does not reflect the terminator.
    19                          ;
    20                          ; The formula evaluator uses the operator (optab) to determine precedence and
    21                          ; dispatch addresses for each operator.
    22                          ; A temporary result on the stack has the following format:
    23                          ;
    24                          ;     * The address of the operator routine.
    25                          ;     * The floating point temporary result.
    26                          ;     * The precedence of the operator.
    27                          
    28                          
    29  4cef c33d               frmevl          dew     txtptr                          ; txtptr points to 1st char. in formula
    30  4cf1 a200                               ldx     #0                              ; dummy precedence = 0
    31  4cf3 89                                 !text $89
    32                          
    33  4cf4 48                 lpoper          pha                                     ; save precedence
    34  4cf5 da                                 phx
    35  4cf6 ba                                 tsx                                     ; confirm enough system stack available (recursive calls)
    36  4cf7 e089                               cpx     #<sysstk+44                     ; bottom of stack + room for error handling
    37  4cf9 90ef                               bcc     sterr                           ; formula too complex
    38  4cfb 20e24d                             jsr     eval
    39  4cfe a900                               lda     #0
    40  4d00 854f                               sta     opmask
    41                          
    42  4d02 208522             tstop           jsr     chrgot                          ; last char
    43  4d05 38                 loprel          sec                                     ; prepare to subtract
    44  4d06 e9b1                               sbc     #greater_token                  ; is current character a relation?
    45  4d08 9017                               bcc     endrel                          ; no, relations all through
    46  4d0a c903                               cmp     #less_token-greater_token+1
    47  4d0c b013                               bcs     endrel                          ; really relational?  no, just big
    48  4d0e c901                               cmp     #1                              ; reset carry for zero only
    49  4d10 2a                                 rol                                     ; 0 to 1, 1 to 2, 2 to 4
    50  4d11 4901                               eor     #1
    51  4d13 454f                               eor     opmask                          ; bring in the old bits
    52  4d15 c54f                               cmp     opmask                          ; make sure that the new mask is bigger
    53  4d17 9331e1                             +lbcc   snerr                           ; syntax error, because two of the same
    54  4d1a 854f                               sta     opmask                          ; save mask
    55  4d1c 208322                             jsr     chrget
    56  4d1f 80e4                               bra     loprel                          ; get the next candidate
    57                          
    58                          
    59  4d21 a64f               endrel          ldx     opmask                          ; were there any?
    60  4d23 d02c                               bne     finrel                          ; yes, handle as special op
    61  4d25 b39000                             +lbcs   qop                             ; not an operator
    62  4d28 6907                               adc     #greater_token-plus_token
    63  4d2a 938b00                             +lbcc   qop                             ; not an operator
    64  4d2d 650f                               adc     valtyp                          ; (c)=1
    65  4d2f f3c50d                             +lbeq   cat                             ; only if (a)=0 and VALTYP=$FF (a string)
    66                          
    67  4d32 69ff                               adc     #$ff                            ; get back original (a)
    68  4d34 8524                               sta     index1
    69  4d36 0a                                 asl                                     ; multiply by two
    70  4d37 6524                               adc     index1                          ; by three
    71  4d39 a8                                 tay                                     ; set up for later
    72                          
    73  4d3a 68                 qprec           pla                                     ; get previous precedence
    74  4d3b d94c29                             cmp     optab,y                         ; is old precedence greater or equal?
    75  4d3e b07c                               bcs     qchnum                          ; yes, go operate
    76  4d40 20db4c                             jsr     chknum                          ; can't be string here
    77                          
    78  4d43 48                 doprec          pha                                     ; save old precedence
    79                          
    80  4d44 20644d             negprc          jsr     dopre1                          ; save a return for op
    81  4d47 68                                 pla                                     ; pull off previous precedence
    82  4d48 a44d                               ldy     opptr                           ; get pointer to op
    83  4d4a 1011                               bpl     qprec1                          ; that's a real operator
    84  4d4c aa                                 tax                                     ; done?
    85  4d4d f06b                               beq     qopgo                           ; done!
    86  4d4f 8074                               bra     pulstk
    87                          
    88                          
    89  4d51 460f               finrel          lsr     valtyp                          ; get value type into (c)
    90  4d53 8a                                 txa
    91  4d54 2a                                 rol                                     ; put VALTYP into low order bit of mask
    92  4d55 c33d                               dew     txtptr                          ; decrement text pointer
    93  4d57 a01b                               ldy     #ptdorl-optab                   ; make (y) point at operator entry
    94  4d59 854f                               sta     opmask                          ; save the operation mask
    95  4d5b 80dd                               bra     qprec                           ; branch always
    96                          
    97                          
    98                          qprec1                                                  ; note b7(VALTYP)=0 so CHKNUM call is ok
    99  4d5d d94c29                             cmp     optab,y                         ; last precedence is greater?
   100  4d60 b063                               bcs     pulstk                          ; yes, go operate
   101  4d62 90df                               bcc     doprec                          ; no, save argument and get other operand
   102                          
   103                          
   104  4d64 b94e29             dopre1          lda     optab+2,y
   105  4d67 48                                 pha                                     ; disp addr goes on stack
   106  4d68 b94d29                             lda     optab+1,y
   107  4d6b 48                                 pha
   108  4d6c 20734d                             jsr     pushf1                          ; save FAC on stack unpacked, precedence in (x)
   109  4d6f a54f                               lda     opmask                          ; (a) may be mask for rel
   110  4d71 8081                               bra     lpoper
   111                          
   112                          
   113                          pushf1                                                  ; save FAC on stack unpacked
   114  4d73 68                                 pla                                     ; first grab return address off stack
   115  4d74 8524                               sta     index1
   116  4d76 68                                 pla
   117  4d77 8525                               sta     index1+1
   118  4d79 e324                               inw     index1
   119                          
   120  4d7b be4c29                             ldx     optab,y                         ; precedence
   121  4d7e a468                               ldy     facsgn
   122  4d80 5a                                 phy
   123  4d81 20b262                             jsr     round                           ; put rounded FAC on stack
   124  4d84 a567                               lda     faclo
   125  4d86 48                                 pha
   126  4d87 a566                               lda     facmo
   127  4d89 48                                 pha
   128  4d8a a565                               lda     facmoh
   129  4d8c 48                                 pha
   130  4d8d a564                               lda     facho
   131  4d8f 48                                 pha
   132  4d90 a563                               lda     facexp
   133  4d92 48                                 pha
   134  4d93 6c2400                             jmp     (index1)                        ; return
   135                          
   136                          
   137                          pullf1                                                  ; retrieve FAC from stack unpacked  [910402]
   138  4d96 68                                 pla                                     ; first grab return address off stack
   139  4d97 8524                               sta     index1
   140  4d99 68                                 pla
   141  4d9a 8525                               sta     index1+1
   142  4d9c e324                               inw     index1
   143                          
   144  4d9e a900                               lda     #0                              ; it's been rounded
   145  4da0 8571                               sta     facov
   146  4da2 68                                 pla
   147  4da3 8563                               sta     facexp
   148  4da5 68                                 pla
   149  4da6 8564                               sta     facho
   150  4da8 68                                 pla
   151  4da9 8565                               sta     facmoh
   152  4dab 68                                 pla
   153  4dac 8566                               sta     facmo
   154  4dae 68                                 pla
   155  4daf 8567                               sta     faclo
   156  4db1 68                                 pla
   157  4db2 8568                               sta     facsgn
   158  4db4 6c2400                             jmp     (index1)                        ; return
   159                          
   160                          
   161  4db7 a0ff               qop             ldy     #255
   162  4db9 68                                 pla                                     ; get high precedence of last op
   163  4dba f023               qopgo           beq     qoprts                          ; done!
   164                          
   165  4dbc c964               qchnum          cmp     #100                            ; relational operator?
   166  4dbe f003                               beq     unpstk                          ; yes, don't check operand
   167  4dc0 20db4c                             jsr     chknum                          ; must be number
   168                          
   169  4dc3 844d               unpstk          sty     opptr                           ; save operator's pointer for next time
   170  4dc5 68                 pulstk          pla                                     ; get mask for rel op if it is one
   171  4dc6 4a                                 lsr                                     ; setup .c for dorel's chkval
   172  4dc7 8514                               sta     domask                          ; save for "docmp"
   173  4dc9 68                                 pla                                     ; unpack stack into arg
   174  4dca 856a                               sta     argexp
   175  4dcc 68                                 pla
   176  4dcd 856b                               sta     argho
   177  4dcf 68                                 pla
   178  4dd0 856c                               sta     argmoh
   179  4dd2 68                                 pla
   180  4dd3 856d                               sta     argmo
   181  4dd5 68                                 pla
   182  4dd6 856e                               sta     arglo
   183  4dd8 68                                 pla
   184  4dd9 856f                               sta     argsgn
   185  4ddb 4568                               eor     facsgn                          ; get probable result sign
   186  4ddd 8570                               sta     arisgn                          ; sign used by add, sub, mul, div
   187                          
   188  4ddf a563               qoprts          lda     facexp                          ; get it and set codes
   189  4de1 60                                 rts                                     ; return
   190                          
   191  4de2 6c0a03             eval            jmp     (ieval)
   192                          
   193  4de5 a900               neval           lda     #0                              ; assume numeric
   194  4de7 850f                               sta     valtyp
   195                          
   196  4de9 208322             eval0           jsr     chrget                          ; get a character
   197  4dec b005                               bcs     eval2
   198  4dee a200               eval1           ldx     #0                              ; flag 'bank 0' (text bank)
   199  4df0 839b15                             +lbra   fin                             ; it is a number
   200                          
   201  4df3 200250             eval2           jsr     isletc                          ; variable name?
   202  4df6 b07b                               bcs     is_variable                     ; yes.
   203  4df8 c9ff                               cmp     #pi                             ; pi?
   204  4dfa d00a                               bne     qdot
   205  4dfc a91e                               lda     #<pival
   206  4dfe a05f                               ldy     #>pival
   207  4e00 200e62                             jsr     movfm                           ; put value in for p1.
   208  4e03 4c8322                             jmp     chrget
   209                          
   210                          
   211  4e06 c92e               qdot            cmp     #'.'                            ; constant?
   212  4e08 f0e4                               beq     eval1
   213  4e0a c9ab                               cmp     #minus_token                    ; negation?
   214  4e0c f05e                               beq     domin                           ; yes.
   215  4e0e c9aa                               cmp     #plus_token
   216  4e10 f0d7                               beq     eval0
   217  4e12 c922                               cmp     #'"'                            ; string?
   218  4e14 d015                               bne     eval3
   219                          
   220  4e16 a53d               strtxt          lda     txtptr
   221  4e18 a43e                               ldy     txtptr+1
   222  4e1a 6900                               adc     #0                              ; c=1
   223  4e1c 9001                               bcc     strtx2
   224  4e1e c8                                 iny
   225  4e1f 20855a             strtx2          jsr     strlit                          ; process string
   226                          
   227  4e22 a672               st2txt          ldx     strng2
   228  4e24 a473                               ldy     strng2+1
   229  4e26 863d                               stx     txtptr
   230  4e28 843e                               sty     txtptr+1
   231  4e2a 60                                 rts
   232                          
   233                          
   234  4e2b c9a8               eval3           cmp     #not_token                      ; not?
   235  4e2d d016                               bne     eval4
   236  4e2f a018                               ldy     #24
   237  4e31 d03b                               bne     gonprc                          ; branch always
   238                          
   239                          
   240  4e33 20b458             notop           jsr     ayint                           ; integerize
   241  4e36 a567                               lda     faclo                           ; get argument
   242  4e38 49ff                               eor     #$ff
   243  4e3a a8                                 tay
   244  4e3b a566                               lda     facmo
   245  4e3d 49ff                               eor     #$ff
   246                          
   247  4e3f 20d758             givayf          jsr     stoint                          ; integer to float routine
   248  4e42 839614                             +lbra   floats
   249                          
   250                          
   251  4e45 c9a5               eval4           cmp     #fn_token                       ; user defined function?
   252  4e47 f3ec0a                             +lbeq   fndoer                          ; yes
   253  4e4a c9b4                               cmp     #first_function_token           ; function name?
   254  4e4c b3bfde                             +lbcs   isfun                           ; yes
   255                          ; (functions are the highest numbered
   256                          ; tokens so no need to check further)
   257                          
   258  4e4f 20584e             parchk          jsr     chkopn                          ; only thing left is formula in parens
   259  4e52 20ef4c                             jsr     frmevl                          ; a formula in parens
   260                          
   261  4e55 a929               chkcls          lda     #')'                            ; close paren?
   262  4e57 2c                                 !text $2c
   263                          
   264  4e58 a928               chkopn          lda     #'('                            ; open paren?
   265  4e5a 2c                                 !text $2c
   266                          
   267  4e5b a92c               chkcom          lda     #','                            ; comma?
   268                          
   269                          
   270                          ; SYNCHR looks at the current character to make sure it is the specific
   271                          ; thing loaded into (a) just before the call to SYNCHR.  If not, it calls
   272                          ; the "syntax error" routine.  Otherwise it gobbles the next char and returns.
   273                          ;
   274                          ; (a)=new char and TXTPTR is advanced by CHRGET.
   275                          
   276                          
   277  4e5d a000               synchr          ldy     #0
   278  4e5f 8578                               sta     syntmp
   279  4e61 20c522                             jsr     indtxt
   280  4e64 c578                               cmp     syntmp
   281  4e66 d3e2df                             +lbne   snerr
   282  4e69 4c8322                             jmp     chrget                          ; ok
   283                          
   284                          
   285                          
   286                          domin
   287                          l117_1          =negtab-optab                           ; negoff
   288  4e6c a015                               ldy     #l117_1                         ; precedence below '-'
   289                          
   290  4e6e 68                 gonprc          pla                                     ; get rid of rts addr.
   291  4e6f 68                                 pla
   292  4e70 83d2fe                             +lbra   negprc                          ; do negation
   293                          
   294                          ;.end
   295                          
   296                          
   297                          
   298                          is_variable
   299  4e73 207c4f                             jsr     ptrget                          ; parse variable name, put name in varnam
   300                          
   301  4e76 8566               isvret          sta     facmo                           ; save pointer to variable
   302  4e78 8467                               sty     facmo+1
   303  4e7a a647                               ldx     varnam
   304  4e7c a448                               ldy     varnam+1
   305  4e7e a50f                               lda     valtyp
   306  4e80 f050                               beq     is_numeric                      ; branch if numeric
   307                          
   308  4e82 a900                               lda     #0
   309  4e84 8571                               sta     facov
   310  4e86 e054                               cpx     #'T'                            ; TI$ is a special case. look for it
   311  4e88 d013                               bne     isvds                           ; no- go test for DS$
   312  4e8a c0c9                               cpy     #'I'+$80                        ; shifted I?
   313  4e8c d043                               bne     ds_rts                          ; no- and it's not DS$ either
   314                          
   315                          ; Variable name is TI$.  To see if this is 'the' TI$ and not an
   316                          ; array TI$(), test to see if it has a pointer to the zero in "ROM".
   317                          ; If it is an array item, its pointer will be to a real value, or
   318                          ; a real zero.  If it isn't an array item, its pointer will point
   319                          ; to a dummy zero in "ROM".
   320                          
   321  4e8e a567                               lda     facmo+1
   322  4e90 c902                               cmp     #>zero
   323  4e92 d03d                               bne     ds_rts                          ; not TI$, not DS$
   324  4e94 a566                               lda     facmo
   325  4e96 c9c4                               cmp     #<zero
   326  4e98 d037                               bne     ds_rts
   327  4e9a 835905                             +lbra   Get_TI_String                   ; the one and only TI$
   328                          
   329                          
   330  4e9d e044               isvds           cpx     #'D'                            ; is this DS$?
   331  4e9f d030                               bne     ds_rts                          ; no
   332  4ea1 c0d3                               cpy     #'S'+$80                        ; shifted S?
   333  4ea3 d02c                               bne     ds_rts                          ; no
   334                          
   335  4ea5 200e78                             jsr     Check_DS                        ; yes- check DS$ allocation,
   336                          ;  and get it if not in memory
   337  4ea8 a0ff                               ldy     #$ff
   338  4eaa c8                 l118_1          iny                                     ; copy DS$ to a temp.
   339  4eab a97a                               lda     #dsdesc+1                       ; must first determine how big it is
   340  4ead 20d722                             jsr     lda_far_ram1                    ; lda (dsdesc+1),y
   341  4eb0 d0f8                               bne     l118_1                          ; loop until terminating null found
   342                          
   343  4eb2 98                                 tya                                     ; length of string required
   344  4eb3 20735a                             jsr     strini                          ; get temp. string space & descriptor
   345  4eb6 a8                                 tay
   346  4eb7 f015                               beq     l118_3                          ; (don't bother copying if length is 0)
   347                          
   348  4eb9 da                                 phx
   349                          
   350  4eba a264                               ldx     #dsctmp+1                       ; ???? was ldx #frespc
   351  4ebc a97a               l118_2          lda     #dsdesc+1                       ; copy DS$ into temp
   352  4ebe 88                                 dey
   353  4ebf 20d722                             jsr     lda_far_ram1                    ; lda (dsdesc+1),y
   354  4ec2 20f022                             jsr     sta_far_ram1                    ; sta (dsctmp+1),y
   355  4ec5 98                                 tya
   356  4ec6 d0f4                               bne     l118_2
   357  4ec8 fa                                 plx
   358  4ec9 a579                               lda     dsdesc                          ; a=length     [901014] FAB
   359  4ecb 205d5b                             jsr     mvdone                          ; ???? (does nothing on C128 - bug or oversight?)
   360                          
   361  4ece 83000c             l118_3          +lbra   putnew
   362                          
   363  4ed1 60                 ds_rts          rts
   364                          
   365                          
   366                          is_numeric
   367  4ed2 7f100f                             bbr7    intflg,is_floating              ; branch if not an integer
   368  4ed5 a000                               ldy     #0
   369  4ed7 20a922                             jsr     indfmo                          ; fetch high
   370  4eda aa                                 tax
   371  4edb c8                                 iny
   372  4edc 20a922                             jsr     indfmo                          ; fetch low
   373  4edf a8                                 tay                                     ; put low in y
   374  4ee0 8a                                 txa                                     ; get high in a
   375  4ee1 835cff                             +lbra   givayf                          ; float and return
   376                          
   377                          
   378                          ; Screen out TI, ST, ER, and EL, and assign values to them.  First test
   379                          ; if the pointer points to "ROM" zero.  If not, it can't be any of the above.
   380                          
   381                          is_floating
   382  4ee4 a567                               lda     facmo+1
   383  4ee6 c902                               cmp     #>zero
   384  4ee8 d064                               bne     gomovf                          ; not TI, etc.
   385  4eea a566                               lda     facmo
   386  4eec c9c4                               cmp     #<zero
   387  4eee d05e                               bne     gomovf                          ; not TI, etc.
   388                          
   389                          
   390                          ; The pointer does point to the ROM zero.  Now it is necessary to
   391                          ; examine the actual variable name case by case.
   392                          
   393  4ef0 e054                               cpx     #'T'                            ; TI?
   394  4ef2 d007                               bne     qstatv                          ; no
   395  4ef4 c049                               cpy     #'I'
   396  4ef6 d056                               bne     gomovf                          ; no, and it can't be ST either
   397  4ef8 f34805                             +lbeq   Get_TI
   398                          
   399                          
   400  4efb e053               qstatv          cpx     #'S'                            ; ST?
   401  4efd d00a                               bne     qdsav                           ; no, go test DS
   402  4eff c054                               cpy     #'T'
   403  4f01 d04b                               bne     gomovf
   404  4f03 20b7ff                             jsr     _readst                         ; (???? system bank for rs232 st)
   405  4f06 83ca13                             +lbra   float
   406                          
   407                          
   408  4f09 e044               qdsav           cpx     #'D'                            ; DS?
   409  4f0b d026                               bne     qerlin                          ; no, go test ER & EL
   410  4f0d c053                               cpy     #'S'
   411  4f0f d03d                               bne     gomovf
   412                          
   413                          ; Get disk status - make the first two characters of DS$ string into a number.
   414                          
   415  4f11 200e78                             jsr     Check_DS                        ; get a DS$ string if one doesn't exist already
   416  4f14 a000                               ldy     #0
   417  4f16 a97a                               lda     #dsdesc+1
   418  4f18 20d722                             jsr     lda_far_ram1                    ; lda (dsdesc+1),y
   419  4f1b 290f                               and     #$0f
   420  4f1d 0a                                 asl
   421  4f1e 8511                               sta     garbfl
   422  4f20 0a                                 asl
   423  4f21 0a                                 asl
   424  4f22 6511                               adc     garbfl
   425  4f24 8511                               sta     garbfl
   426  4f26 c8                                 iny
   427  4f27 a97a                               lda     #dsdesc+1
   428  4f29 20d722                             jsr     lda_far_ram1                    ; lda (dsdesc+1),y
   429  4f2c 290f                               and     #$0f
   430  4f2e 6511                               adc     garbfl
   431  4f30 83a013                             +lbra   float
   432                          
   433                          
   434  4f33 e045               qerlin          cpx     #'E'                            ; ER or EL?
   435  4f35 d017                               bne     gomovf
   436  4f37 c052                               cpy     #'R'
   437  4f39 f00d                               beq     qnumer
   438  4f3b c04c                               cpy     #'L'
   439  4f3d d00f                               bne     gomovf
   440                          
   441  4f3f adc902                             lda     errlin+1                        ; want EL (last error line #)
   442  4f42 acc802                             ldy     errlin
   443  4f45 838009                             +lbra   nosflt
   444                          
   445  4f48 adc702             qnumer          lda     errnum                          ; want ER (number of last error)
   446  4f4b 838513                             +lbra   float
   447                          
   448                          
   449  4f4e a566               gomovf          lda     facmo
   450  4f50 a467                               ldy     facmo+1
   451                          
   452  4f52 8524               movfrm          sta     index1                          ; move value from RAM
   453  4f54 8425                               sty     index1+1
   454                          
   455  4f56 a000                               ldy     #0
   456  4f58 20d522                             jsr     indin1_ram1
   457  4f5b 8563                               sta     facexp
   458  4f5d 8471                               sty     facov
   459                          
   460  4f5f c8                                 iny                                     ; (1)
   461  4f60 20d522                             jsr     indin1_ram1
   462  4f63 8568                               sta     facsgn
   463  4f65 0980                               ora     #$80
   464  4f67 8564                               sta     facho
   465                          
   466  4f69 c8                                 iny                                     ; (2)
   467  4f6a 20d522                             jsr     indin1_ram1
   468  4f6d 8565                               sta     facmoh
   469                          
   470  4f6f c8                                 iny                                     ; (3)
   471  4f70 20d522                             jsr     indin1_ram1
   472  4f73 8566                               sta     facmo
   473                          
   474  4f75 c8                                 iny                                     ; (4)
   475  4f76 20d522                             jsr     indin1_ram1
   476  4f79 8567                               sta     faclo
   477  4f7b 60                                 rts
   478                          
   479                          ;.end
   480                          
   481                          
   482                          
   483                          ;  Read the variable name at the current text position and put a pointer
   484                          ;  to its value in VARPNT.   TXTPTR points to the terminating character.
   485                          ;  Note that evaluating subscripts in a variable name can cause recursive
   486                          ;  calls to PTRGET, so all values must be stored on the stack.
   487                          
   488  4f7c a200               ptrget          ldx     #0
   489  4f7e 208522                             jsr     chrgot
   490  4f81 860e               ptrgt1          stx     dimflg                          ; store flag away
   491  4f83 8547               ptrgt2          sta     varnam
   492  4f85 208522                             jsr     chrgot                          ; get current character
   493  4f88 200250                             jsr     isletc                          ; check for a letter
   494  4f8b 93bdde                             +lbcc   snerr                           ; not a letter
   495                          
   496  4f8e a200                               ldx     #0                              ; assume no second character
   497  4f90 860f                               stx     valtyp                          ; default is numeric
   498  4f92 8610                               stx     intflg                          ; assume floating
   499  4f94 208322                             jsr     chrget                          ; get following character
   500  4f97 9005                               bcc     l119_1                          ; branch if numeric
   501  4f99 200250                             jsr     isletc                          ; is it alpha?
   502  4f9c 900b                               bcc     l119_3                          ; no, no second character. branch
   503  4f9e aa                 l119_1          tax                                     ; issec. save second character of name
   504                          
   505  4f9f 208322             l119_2          jsr     chrget                          ; skip over remainder of name. we only care about 2 chars.
   506  4fa2 90fb                               bcc     l119_2                          ; ..eat numbers,
   507  4fa4 200250                             jsr     isletc
   508  4fa7 b0f6                               bcs     l119_2                          ; ..and alphas, too!
   509                          
   510  4fa9 c924               l119_3          cmp     #'$'                            ; nosec. is this a string?
   511  4fab d006                               bne     l119_4                          ; if not, VALTYP = 0
   512  4fad a9ff                               lda     #$ff
   513  4faf 850f                               sta     valtyp                          ; ..else, flag 'string'
   514  4fb1 800f                               bra     l119_5
   515                          
   516  4fb3 c925               l119_4          cmp     #'%'                            ; notstr. isn't string. is it integer?
   517  4fb5 d012                               bne     l119_6                          ; branch if not
   518  4fb7 a512                               lda     subflg
   519                          ; bne snerr ; syntax error if integers disabled
   520  4fb9 d32cfd                             +lbne   chkerr                          ; integers disallowed- type mismatch error  [910114]
   521  4fbc a980                               lda     #$80                            ; flag integer by turning on both high bits
   522  4fbe 8510                               sta     intflg
   523  4fc0 0447                               tsb     varnam
   524                          
   525  4fc2 8a                 l119_5          txa                                     ; turnon. turn on msb of second character
   526  4fc3 0980                               ora     #$80
   527  4fc5 aa                                 tax
   528  4fc6 208322                             jsr     chrget                          ; get character after $ or %
   529                          
   530  4fc9 8648               l119_6          stx     varnam+1                        ; strnam. store away second character
   531  4fcb 38                                 sec
   532  4fcc 0512                               ora     subflg                          ; add flag whether to allow arrays
   533  4fce e928                               sbc     #'('
   534  4fd0 f3b101                             +lbeq   is_array                        ; note: won't match if SUBFLG set
   535                          
   536  4fd3 a000                               ldy     #0
   537  4fd5 8412                               sty     subflg                          ; allow subscripts again
   538  4fd7 a52f                               lda     vartab                          ; place to start search
   539  4fd9 a630                               ldx     vartab+1
   540                          
   541  4fdb 8662               l119_7          stx     lowtr+1                         ; stxfnd.
   542  4fdd 8561               l119_8          sta     lowtr
   543  4fdf e432                               cpx     arytab+1                        ; at end of table yet?
   544  4fe1 d004                               bne     l119_9
   545  4fe3 c531                               cmp     arytab
   546  4fe5 f025                               beq     notfns                          ; yes, we couldn't find it
   547                          
   548  4fe7 20bd22             l119_9          jsr     indlow_ram1                     ; lda (lowtr),y
   549  4fea c547                               cmp     varnam                          ; compare high orders
   550  4fec d00a                               bne     l119_10
   551  4fee c8                                 iny
   552  4fef 20bd22                             jsr     indlow_ram1
   553  4ff2 c548                               cmp     varnam+1                        ; and the low part?
   554  4ff4 f32f01                             +lbeq   finptr                          ; !!that's it!!
   555                          
   556  4ff7 88                                 dey
   557  4ff8 18                 l119_10         clc
   558  4ff9 a561                               lda     lowtr
   559  4ffb 6907                               adc     #7                              ; makes no difference among types
   560  4ffd 90de                               bcc     l119_8
   561  4fff e8                                 inx
   562  5000 80d9                               bra     l119_7                          ; branch always
   563                          
   564                          
   565                          
   566                          
   567                          ; Test for a letter: (c)=0 not a letter
   568                          ;   (c)=1 a letter
   569                          
   570  5002 c941               isletc          cmp     #'A'
   571  5004 9005                               bcc     l120_1                          ; if less than "a", return
   572  5006 e95b                               sbc     #'Z'+1                          ; $5a + 1
   573  5008 38                                 sec
   574  5009 e9a5                               sbc     #$a5                            ; reset carry if (a) .gt. "z".
   575  500b 60                 l120_1          rts
   576                          
   577                          
   578  500c ba                 notfns          tsx                                     ; check who's calling????
   579  500d bd0201                             lda     $102,x                          ; sniff processor stack
   580  5010 c957                               cmp     #>pointer_ret
   581  5012 f004                               beq     ldzr                            ; special case if called by pointer function
   582                          
   583                          l121_1          = isvret-1
   584  5014 c94e                               cmp     #>l121_1                        ; is eval calling????
   585  5016 d02a                               bne     notevl                          ; no, carry on
   586                          
   587  5018 a9c4               ldzr            lda     #<zero                          ; set up pointer to simulated zero
   588  501a a002                               ldy     #>zero
   589  501c 60                                 rts                                     ; for strings or numeric
   590                          
   591                          
   592  501d c0c9               qst001          cpy     #'I'+$80                        ; we know first is T, is second <shift>I (TI$)?
   593  501f f0f7                               beq     ldzr
   594  5021 c049                               cpy     #'I'                            ; or I (TI)?
   595  5023 d031                               bne     varok
   596  5025 f018                               beq     gobadv
   597                          
   598                          
   599  5027 c0d3               qst004          cpy     #'S'+$80                        ; check for DS$
   600  5029 f014                               beq     gobadv
   601  502b c053                               cpy     #'S'                            ; check for DS
   602  502d d027                               bne     varok
   603  502f f00e                               beq     gobadv
   604                          
   605                          
   606  5031 c054               qst002          cpy     #'T'                            ; check for ST
   607  5033 d021                               bne     varok
   608  5035 f008                               beq     gobadv
   609                          
   610                          
   611  5037 c052               qst003          cpy     #'R'                            ; check for ER
   612  5039 f004                               beq     gobadv
   613  503b c04c                               cpy     #'L'                            ; check for EL
   614  503d d017                               bne     varok
   615                          
   616                          
   617  503f 8309de             gobadv          +lbra   snerr
   618                          
   619                          
   620                          
   621  5042 a547               notevl          lda     varnam
   622  5044 a448                               ldy     varnam+1
   623  5046 c954                               cmp     #'T'                            ; screen out TI
   624  5048 f0d3                               beq     qst001
   625  504a c953                               cmp     #'S'                            ; ...and ST
   626  504c f0e3                               beq     qst002
   627  504e c945                               cmp     #'E'                            ; ...and ER and EL
   628  5050 f0e5                               beq     qst003
   629  5052 c944                               cmp     #'D'                            ; ...and DS
   630  5054 f0d1                               beq     qst004
   631                          
   632                          
   633  5056 a531               varok           lda     arytab
   634  5058 a432                               ldy     arytab+1
   635  505a 8561                               sta     lowtr
   636  505c 8462                               sty     lowtr+1
   637  505e a533                               lda     strend
   638  5060 a434                               ldy     strend+1
   639  5062 855c                               sta     hightr
   640  5064 845d                               sty     hightr+1
   641  5066 18                                 clc
   642  5067 6907                               adc     #7
   643  5069 9001                               bcc     l122_1                          ; not even
   644  506b c8                                 iny
   645                          
   646  506c 855a               l122_1          sta     highds
   647  506e 845b                               sty     highds+1
   648  5070 203451                             jsr     bltu
   649  5073 a55a                               lda     highds
   650  5075 a45b                               ldy     highds+1
   651  5077 c8                                 iny
   652  5078 8531                               sta     arytab
   653  507a 8432                               sty     arytab+1
   654                          
   655                          
   656                          ; Scan thru array entries for string arrays.  If any are found it will be
   657                          ; necessary to adjust the back-links of the strings in that array, since
   658                          ; the array descriptor block itself was moved.
   659                          
   660  507c 855a                               sta     arypnt                          ; set pointer to arrays
   661  507e 845b                               sty     arypnt+1
   662                          
   663  5080 a55a               aryva2          lda     arypnt
   664  5082 a65b                               ldx     arypnt+1
   665                          
   666  5084 e434               aryva3          cpx     strend+1                        ; end of arrays?
   667  5086 d004                               bne     aryvgo
   668  5088 c533                               cmp     strend
   669  508a f07e                               beq     arydon                          ; ...finished
   670                          
   671                          
   672  508c 8524               aryvgo          sta     index1
   673  508e 8625                               stx     index1+1
   674  5090 a000                               ldy     #0
   675  5092 20d522                             jsr     indin1_ram1                     ; look at array name
   676  5095 aa                                 tax
   677  5096 c8                                 iny
   678  5097 20d522                             jsr     indin1_ram1                     ; name 2nd char
   679  509a 08                                 php                                     ; save status reg
   680  509b c8                                 iny
   681  509c 20d522                             jsr     indin1_ram1                     ; point to offset to next array
   682  509f 655a                               adc     arypnt
   683  50a1 855a                               sta     arypnt                          ; save start of next array in arypnt
   684  50a3 c8                                 iny
   685  50a4 20d522                             jsr     indin1_ram1
   686  50a7 655b                               adc     arypnt+1
   687  50a9 855b                               sta     arypnt+1
   688  50ab 28                                 plp                                     ; restore status
   689  50ac 10d2                               bpl     aryva2                          ; not a string type
   690  50ae 8a                                 txa
   691  50af 30cf                               bmi     aryva2                          ; not a string array
   692  50b1 c8                                 iny                                     ; ok we have a string array
   693  50b2 20d522                             jsr     indin1_ram1                     ; get number of dimensions
   694  50b5 a000                               ldy     #0
   695  50b7 0a                                 asl                                     ; move index to ptr to 1st string (add 2*number of dims + 5)
   696  50b8 6905                               adc     #5
   697  50ba 6524                               adc     index1
   698  50bc 8524                               sta     index1
   699  50be 9002                               bcc     aryget
   700  50c0 e625                               inc     index1+1
   701                          
   702  50c2 a625               aryget          ldx     index1+1
   703  50c4 e45b                               cpx     arypnt+1                        ; done with this array?
   704  50c6 d004                               bne     l123_1
   705  50c8 c55a                               cmp     arypnt
   706  50ca f0b8                               beq     aryva3                          ; yes
   707                          
   708  50cc a000               l123_1          ldy     #0                              ; process string pointer
   709  50ce 20d522                             jsr     indin1_ram1                     ; get length of string
   710  50d1 f02a                               beq     dvarts                          ; skip if null string
   711  50d3 8578                               sta     syntmp
   712  50d5 c8                                 iny
   713  50d6 20d522                             jsr     indin1_ram1                     ; get lo byte of string ptr
   714  50d9 18                                 clc
   715  50da 6578                               adc     syntmp                          ; and add string length
   716  50dc 855c                               sta     hightr
   717  50de c8                                 iny
   718  50df 20d522                             jsr     indin1_ram1                     ; get hi byte of string ptr
   719  50e2 6900                               adc     #0                              ; adjust high byte
   720  50e4 855d                               sta     hightr+1
   721                          
   722                          ; Fix backwards pointer by adding move length to it.
   723                          
   724  50e6 da                                 phx
   725  50e7 a25c                               ldx     #hightr
   726  50e9 a000                               ldy     #0
   727  50eb 20a522                             jsr     indhtr_ram1                     ; lda (hightr),y
   728  50ee 6907                               adc     #7                              ; carry clear (careful!)
   729  50f0 20f022                             jsr     sta_far_ram1                    ; sta (hightr),y
   730  50f3 c8                                 iny
   731  50f4 20a522                             jsr     indhtr_ram1                     ; lda (hightr),y
   732  50f7 6900                               adc     #0
   733  50f9 20f022                             jsr     sta_far_ram1                    ; sta (hightr),y
   734  50fc fa                                 plx                                     ; done with this string
   735                          
   736                          ; Fix the next string in the array
   737                          
   738  50fd a903               dvarts          lda     #strsiz
   739  50ff 18                                 clc
   740  5100 6524                               adc     index1
   741  5102 8524                               sta     index1
   742  5104 90bc                               bcc     aryget
   743  5106 e625                               inc     index1+1
   744  5108 80b8                               bra     aryget                          ; branch always
   745                          
   746                          
   747  510a da                 arydon          phx
   748  510b a261                               ldx     #lowtr
   749  510d a000                               ldy     #0
   750  510f a547                               lda     varnam
   751  5111 20f022                             jsr     sta_far_ram1                    ; sta (lowtr),y
   752  5114 c8                                 iny                                     ; .y=1
   753  5115 a548                               lda     varnam+1
   754  5117 20f022                             jsr     sta_far_ram1                    ; sta (lowtr),y
   755  511a a900                               lda     #0
   756  511c c8                 l124_1          iny
   757  511d 20f022                             jsr     sta_far_ram1                    ; sta (lowtr),y
   758  5120 c006                               cpy     #6
   759  5122 d0f8                               bne     l124_1
   760  5124 fa                                 plx
   761                          
   762  5125 a561               finptr          lda     lowtr
   763  5127 18                                 clc
   764  5128 6902                               adc     #2
   765  512a a462                               ldy     lowtr+1
   766  512c 9001                               bcc     l125_1
   767  512e c8                                 iny
   768  512f 8549               l125_1          sta     varpnt
   769  5131 844a                               sty     varpnt+1
   770  5133 60                                 rts
   771                          
   772                          
   773                          
   774                          
   775  5134 20af31             bltu            jsr     reason
   776  5137 8533                               sta     strend
   777  5139 8434                               sty     strend+1
   778  513b 38                                 sec
   779  513c a55c                               lda     hightr
   780  513e e561                               sbc     lowtr
   781  5140 8524                               sta     index
   782  5142 a8                                 tay
   783  5143 a55d                               lda     hightr+1
   784  5145 e562                               sbc     lowtr+1
   785  5147 aa                                 tax
   786  5148 e8                                 inx
   787  5149 98                                 tya
   788  514a f02f                               beq     decblt
   789  514c a55c                               lda     hightr
   790  514e 38                                 sec
   791  514f e524                               sbc     index
   792  5151 855c                               sta     hightr
   793  5153 b003                               bcs     l126_1
   794  5155 c65d                               dec     hightr+1
   795  5157 38                                 sec
   796  5158 a55a               l126_1          lda     highds
   797  515a e524                               sbc     index
   798  515c 855a                               sta     highds
   799  515e b00e                               bcs     moren1
   800  5160 c65b                               dec     highds+1
   801  5162 900a                               bcc     moren1
   802                          
   803  5164 20a522             bltlp           jsr     indhtr_ram1                     ; lda (hightr),y
   804  5167 da                                 phx
   805  5168 a25a                               ldx     #highds
   806  516a 20f022                             jsr     sta_far_ram1                    ; sta (highds),y
   807  516d fa                                 plx
   808                          
   809  516e 88                 moren1          dey
   810  516f d0f3                               bne     bltlp
   811  5171 20a522                             jsr     indhtr_ram1                     ; lda (hightr),y
   812  5174 da                                 phx
   813  5175 a25a                               ldx     #highds
   814  5177 20f022                             jsr     sta_far_ram1                    ; sta (highds),y
   815  517a fa                                 plx
   816                          
   817  517b c65d               decblt          dec     hightr+1
   818  517d c65b                               dec     highds+1
   819  517f ca                                 dex
   820  5180 d0ec                               bne     moren1
   821  5182 60                                 rts
   822                          
   823                          ;.end
   824                          
   825                          ; ********************************************************************************************
   826                          ;
   827                          ;	Date		Changes
   828                          ;	====		=======
   829                          ;
   830                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/arrays.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      arrays.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; The format of arrays in core:
    16                          ;
    17                          ; Descriptor: low  byte = first character
    18                          ;   high byte = second character (msb is string flag)
    19                          ; Length of array in memory in bytes (includes everything).
    20                          ; Number of dimensions.
    21                          ; For each dimension starting with the first a list (2 bytes each)
    22                          ; of the max indice+1.
    23                          ; The values.
    24                          
    25                          
    26                          is_array
    27  5183 a50e                               lda     dimflg
    28  5185 0510                               ora     intflg
    29  5187 48                                 pha                                     ; save DIMFLG for recursion
    30  5188 a50f                               lda     valtyp
    31  518a 48                                 pha                                     ; save VALTYP for recursion
    32  518b a000                               ldy     #0                              ; set number of dimensions to zero
    33                          
    34  518d 5a                 l127_1          phy                                     ; save number of dims
    35  518e a548                               lda     varnam+1
    36  5190 48                                 pha
    37  5191 a547                               lda     varnam
    38  5193 48                                 pha                                     ; save looks
    39  5194 20a758                             jsr     intidx                          ; evaluate indice into facmo&lo
    40  5197 68                                 pla
    41  5198 8547                               sta     varnam
    42  519a 68                                 pla
    43  519b 8548                               sta     varnam+1                        ; get back all...we're home
    44  519d 7a                                 ply                                     ; (# of units)
    45  519e ba                                 tsx
    46  519f bd0201                             lda     258,x
    47  51a2 48                                 pha                                     ; push DIMFLG and VALTYP further
    48  51a3 bd0101                             lda     257,x
    49  51a6 48                                 pha
    50  51a7 a566                               lda     indice                          ; put indice onto stack
    51  51a9 9d0201                             sta     258,x                           ; under DIMFLG and VALTYP
    52  51ac a567                               lda     indice+1
    53  51ae 9d0101                             sta     257,x
    54  51b1 c8                                 iny                                     ; y counts # of subscripts
    55  51b2 840d                               sty     count                           ; protect y from chrget
    56  51b4 208522                             jsr     chrgot                          ; get terminating character
    57  51b7 a40d                               ldy     count
    58  51b9 c92c                               cmp     #','                            ; more subscripts?
    59  51bb f0d0                               beq     l127_1                          ; yes
    60                          
    61                          
    62  51bd 20554e                             jsr     chkcls                          ; must be closed paren
    63  51c0 68                                 pla
    64  51c1 850f                               sta     valtyp                          ; get VALTYP and
    65  51c3 68                                 pla
    66  51c4 8510                               sta     intflg
    67  51c6 297f                               and     #$7f
    68  51c8 850e                               sta     dimflg                          ; DIMFLG off stack
    69  51ca a631                               ldx     arytab                          ; place to start search
    70  51cc a532                               lda     arytab+1
    71                          
    72                          
    73  51ce 8661               l127_2          stx     lowtr
    74  51d0 8562                               sta     lowtr+1
    75  51d2 c534                               cmp     strend+1                        ; end of arrays?
    76  51d4 d004                               bne     l127_3
    77  51d6 e433                               cpx     strend
    78  51d8 f043                               beq     notfdd                          ; a fine thing! no array!
    79                          
    80  51da a000               l127_3          ldy     #0
    81  51dc 20bd22                             jsr     indlow_ram1                     ; get high of name from array bank (ram1)
    82  51df c8                                 iny
    83  51e0 c547                               cmp     varnam                          ; compare high orders.
    84  51e2 d007                               bne     l127_4                          ; no way is it this. get the bite outta here
    85  51e4 20bd22                             jsr     indlow_ram1
    86  51e7 c548                               cmp     varnam+1                        ; low orders?
    87  51e9 f018                               beq     gotary                          ; well here it is
    88                          
    89  51eb c8                 l127_4          iny
    90  51ec 20bd22                             jsr     indlow_ram1                     ; get length
    91  51ef 18                                 clc
    92  51f0 6561                               adc     lowtr
    93  51f2 aa                                 tax
    94  51f3 c8                                 iny
    95  51f4 20bd22                             jsr     indlow_ram1
    96  51f7 6562                               adc     lowtr+1
    97  51f9 90d3                               bcc     l127_2                          ; always branches
    98                          
    99                          
   100  51fb a212               bserr           ldx     #errbs                          ; get bad sub error number
   101  51fd 2c                                 !text $2c
   102                          
   103  51fe a20e               fcerr           ldx     #errfc                          ; too big. Illegal Quantity error
   104  5200 834ddc                             +lbra   error
   105                          
   106                          
   107                          
   108  5203 a213               gotary          ldx     #errdd                          ; perhaps a "re-dimension" error
   109  5205 a50e                               lda     dimflg                          ; test the DIMFLG
   110  5207 d346dc                             +lbne   error
   111  520a 206c53                             jsr     fmaptr
   112  520d a004                               ldy     #4
   113  520f 20bd22                             jsr     indlow_ram1
   114  5212 8578                               sta     syntmp
   115  5214 a50d                               lda     count                           ; get number of dims input.
   116  5216 c578                               cmp     syntmp                          ; # of dims the same?
   117  5218 d0e1                               bne     bserr                           ; same so get definition.
   118  521a 83b300                             +lbra   getdef
   119                          
   120                          
   121                          ; Come here when variable is not found in the array table to build an entry.
   122                          ;
   123                          ; Put down the descriptor.
   124                          ; Setup number of dimensions.
   125                          ; Make sure there is room for the new entry.
   126                          ; Remember VARPNT.
   127                          ; Tally=4.
   128                          ; Skip two locs for later fill in of size.
   129                          ; LOOP: Get an indice.
   130                          ;  Put down number+1 and increment VARPTR.
   131                          ;  Tally=tally*number+1
   132                          ;  Decrement number of dims.
   133                          ;  Bne LOOP
   134                          ; Call REASON with (a,b) reflecting last loc of variable.
   135                          ; Update STREND
   136                          ; Zero all.
   137                          ; Make tally include maxdims and descriptor.
   138                          ; Put down tally
   139                          ; If called by dimension, return.
   140                          ;  Else index into the variable as if it were found on the initial search.
   141                          
   142                          notfdd
   143  521d 206c53                             jsr     fmaptr                          ; form ARYPNT
   144  5220 20af31                             jsr     reason
   145  5223 a000                               ldy     #0
   146  5225 8473                               sty     curtol+1
   147  5227 a205                               ldx     #5
   148  5229 a547                               lda     varnam
   149  522b 08                                 php
   150  522c da                                 phx
   151  522d a261                               ldx     #lowtr                          ; point to string/array bank
   152  522f 20f022                             jsr     sta_far_ram1                    ; sta (lowtr),y
   153  5232 fa                                 plx
   154  5233 28                                 plp
   155  5234 1001                               bpl     l128_1
   156  5236 ca                                 dex
   157                          
   158  5237 c8                 l128_1          iny                                     ; notflt.
   159  5238 a548                               lda     varnam+1
   160  523a 08                                 php
   161  523b da                                 phx
   162  523c a261                               ldx     #lowtr                          ; point to string/array bank
   163  523e 20f022                             jsr     sta_far_ram1                    ; sta (lowtr),y
   164  5241 fa                                 plx
   165  5242 28                                 plp
   166  5243 1002                               bpl     l128_2
   167  5245 ca                                 dex
   168  5246 ca                                 dex
   169                          
   170  5247 8672               l128_2          stx     curtol
   171  5249 a50d                               lda     count                           ; save number of dimensions
   172  524b c8                                 iny
   173  524c c8                                 iny
   174  524d c8                                 iny
   175  524e a261                               ldx     #lowtr                          ; point to string/array bank
   176  5250 20f022                             jsr     sta_far_ram1                    ; sta (lowtr),y
   177                          
   178  5253 a20b               l128_3          ldx     #11                             ; loppta. default size
   179  5255 a900                               lda     #0
   180  5257 6f0e08                             bbr6    dimflg,l128_4                   ; not in a dim statement
   181  525a 68                                 pla                                     ; get low order of indice
   182  525b 18                                 clc
   183  525c 6901                               adc     #1
   184  525e aa                                 tax
   185  525f 68                                 pla                                     ; get high order of indice
   186  5260 6900                               adc     #0
   187                          
   188  5262 c8                 l128_4          iny                                     ; notdim.
   189  5263 da                                 phx
   190  5264 a261                               ldx     #lowtr
   191  5266 20f022                             jsr     sta_far_ram1 ;sta (lowtr),y     ; store high part of indice
   192  5269 fa                                 plx
   193  526a c8                                 iny
   194  526b 8a                                 txa
   195  526c da                                 phx
   196  526d a261                               ldx     #lowtr
   197  526f 20f022                             jsr     sta_far_ram1 ;sta (lowtr),y     ; store low part of indice
   198  5272 fa                                 plx
   199  5273 203753                             jsr     umult                           ; (a,x)+(curtol)*(lowtr,y)
   200  5276 8672                               stx     curtol                          ; save new tally
   201  5278 8573                               sta     curtol+1
   202  527a a424                               ldy     index
   203  527c c60d                               dec     count                           ; any more indices left?
   204  527e d0d3                               bne     l128_3                          ; yes
   205  5280 655b                               adc     arypnt+1
   206  5282 b3bddb                             +lbcs   omerr                           ; overflow
   207  5285 855b                               sta     arypnt+1                        ; compute where to zero
   208  5287 a8                                 tay
   209  5288 8a                                 txa
   210  5289 655a                               adc     arypnt
   211  528b 9004                               bcc     l128_5
   212  528d c8                                 iny
   213  528e f3b1db                             +lbeq   omerr
   214                          
   215  5291 20af31             l128_5          jsr     reason                          ; grease.  get room
   216  5294 8533                               sta     strend
   217  5296 8434                               sty     strend+1                        ; new end of storage
   218  5298 a900                               lda     #0                              ; storing (a) is faster than clear
   219  529a e673                               inc     curtol+1
   220  529c a472                               ldy     curtol
   221  529e f00c                               beq     l128_7
   222                          
   223  52a0 88                 l128_6          dey                                     ; zero out new entry
   224  52a1 08                                 php
   225  52a2 da                                 phx
   226  52a3 a25a                               ldx     #arypnt
   227  52a5 20f022                             jsr     sta_far_ram1                    ; sta (arypnt),y
   228  52a8 fa                                 plx
   229  52a9 28                                 plp
   230  52aa d0f4                               bne     l128_6                          ; no. continue
   231                          
   232  52ac c65b               l128_7          dec     arypnt+1                        ; deccur.
   233  52ae c673                               dec     curtol+1
   234  52b0 d0ee                               bne     l128_6                          ; do another block
   235  52b2 e65b                               inc     arypnt+1                        ; bump back up. will use later
   236  52b4 38                                 sec
   237  52b5 a533                               lda     strend                          ; restore (a)
   238  52b7 e561                               sbc     lowtr                           ; determine length
   239  52b9 a002                               ldy     #2
   240  52bb da                                 phx
   241  52bc a261                               ldx     #lowtr
   242  52be 20f022                             jsr     sta_far_ram1 ;sta (lowtr),y     ; low
   243  52c1 a534                               lda     strend+1
   244  52c3 c8                                 iny
   245  52c4 e562                               sbc     lowtr+1
   246  52c6 20f022                             jsr     sta_far_ram1 ;sta (lowtr),y     ; high
   247  52c9 fa                                 plx
   248  52ca a50e                               lda     dimflg                          ; quit here if this is a DIM statement
   249  52cc d068                               bne     dimrts                          ; bye!
   250  52ce c8                                 iny
   251                          
   252                          
   253                          ; At this point (LOWTR,y) points beyond the size to the number of dimensions.
   254                          ; Strategy:
   255                          ;  NUMDIM = number of dimensions
   256                          ;  curtol = 0
   257                          ;  INLPNM: Get a new indice
   258                          ;   Make sure indice is not too big
   259                          ;   Multiply CURTOL by CURMAX
   260                          ;   Add indice to CURTOL
   261                          ;   NUMDIM=NUMDIM-1
   262                          ;   bne INLPNM
   263                          ;  Use (CURTOL)*4 as offset
   264                          
   265                          
   266  52cf 20bd22             getdef          jsr     indlow_ram1                     ; get # of dim's from string bank
   267  52d2 850d                               sta     count                           ; save a counter
   268  52d4 a900                               lda     #0                              ; zero (curtol)
   269  52d6 8572                               sta     curtol
   270                          
   271  52d8 8573               inlpnm          sta     curtol+1
   272  52da fa                                 plx                                     ; get low indice
   273  52db 8666                               stx     indice
   274  52dd c8                                 iny
   275  52de 20bd22                             jsr     indlow_ram1
   276  52e1 8578                               sta     syntmp
   277  52e3 68                                 pla                                     ; and the high part
   278  52e4 8567                               sta     indice+1
   279  52e6 c578                               cmp     syntmp                          ; compare with max indice
   280  52e8 900f                               bcc     inlpn2
   281  52ea d00a                               bne     bserr7                          ; if greater, "bad subscript" error
   282  52ec c8                                 iny
   283  52ed 20bd22                             jsr     indlow_ram1
   284  52f0 8578                               sta     syntmp
   285  52f2 e478                               cpx     syntmp
   286  52f4 9004                               bcc     inlpn1
   287                          
   288  52f6 8303ff             bserr7          +lbra   bserr
   289                          
   290                          
   291  52f9 c8                 inlpn2          iny
   292  52fa a573               inlpn1          lda     curtol+1                        ; don't multiply if curtol=0
   293  52fc 0572                               ora     curtol
   294  52fe 18                                 clc                                     ; prepare to get indice back
   295  52ff f00a                               beq     l129_1                          ; get high part of indice back
   296  5301 203753                             jsr     umult                           ; multiply (curtol) by (5&6,lowtr)
   297  5304 8a                                 txa
   298  5305 6566                               adc     indice                          ; add in (indice)
   299  5307 aa                                 tax
   300  5308 98                                 tya
   301  5309 a424                               ldy     index1
   302                          
   303  530b 6567               l129_1          adc     indice+1
   304  530d 8672                               stx     curtol
   305  530f c60d                               dec     count                           ; any more?
   306  5311 d0c5                               bne     inlpnm                          ; yes
   307  5313 8573                               sta     curtol+1
   308  5315 a205                               ldx     #5
   309  5317 a547                               lda     varnam
   310  5319 1001                               bpl     l129_2
   311  531b ca                                 dex
   312  531c a548               l129_2          lda     varnam+1
   313  531e 1002                               bpl     l129_3
   314  5320 ca                                 dex
   315  5321 ca                                 dex
   316  5322 862a               l129_3          stx     addend
   317  5324 a900                               lda     #0
   318  5326 204253                             jsr     umultd                          ; on rts, a & y = hi. x = lo.
   319  5329 8a                                 txa
   320  532a 655a                               adc     arypnt
   321  532c 8549                               sta     varpnt
   322  532e 98                                 tya
   323  532f 655b                               adc     arypnt+1
   324  5331 854a                               sta     varpnt+1
   325  5333 a8                                 tay
   326  5334 a549                               lda     varpnt
   327  5336 60                 dimrts          rts
   328                          
   329                          
   330                          ; Integer arithmetic routines.
   331                          ;
   332                          ; Two byte unsigned integer multiply.
   333                          ; This is for multiply dimensioned arrays.
   334                          ; (a,b)=(curtol)*(5&6,x).
   335                          
   336                          umult
   337  5337 8424                               sty     index
   338  5339 20bd22                             jsr     indlow_ram1
   339  533c 852a                               sta     addend                          ; low, then high
   340  533e 88                                 dey
   341  533f 20bd22                             jsr     indlow_ram1                     ; put (5&6,lowtr) in faster memory
   342                          
   343  5342 852b               umultd          sta     addend+1
   344  5344 a910                               lda     #16
   345  5346 855f                               sta     deccnt
   346  5348 a200                               ldx     #0                              ; clear the accs
   347  534a a000                               ldy     #0                              ; result initially zero
   348                          
   349  534c 8a                 umultc          txa
   350  534d 0a                                 asl                                     ; multiply by two
   351  534e aa                                 tax
   352  534f 98                                 tya
   353  5350 2a                                 rol
   354  5351 a8                                 tay
   355  5352 b3edda                             +lbcs   omerr                           ; to much!
   356  5355 0672                               asl     curtol
   357  5357 2673                               rol     curtol+1
   358  5359 900c                               bcc     umlcnt                          ; nothing in this position to multiply
   359  535b 18                                 clc
   360  535c 8a                                 txa
   361  535d 652a                               adc     addend
   362  535f aa                                 tax
   363  5360 98                                 tya
   364  5361 652b                               adc     addend+1
   365  5363 a8                                 tay
   366  5364 b3dbda                             +lbcs   omerr                           ; man, just too much!
   367                          
   368  5367 c65f               umlcnt          dec     deccnt                          ; done?
   369  5369 d0e1                               bne     umultc                          ; keep it up
   370  536b 60                                 rts                                     ; yes, all done
   371                          
   372                          
   373  536c a50d               fmaptr          lda     count
   374  536e 0a                                 asl
   375  536f 6905                               adc     #5                              ; point to entries. ((c) cleared by asl)
   376  5371 6561                               adc     lowtr
   377  5373 a462                               ldy     lowtr+1
   378  5375 9001                               bcc     l130_1
   379  5377 c8                                 iny
   380  5378 855a               l130_1          sta     arypnt
   381  537a 845b                               sty     arypnt+1
   382  537c 60                                 rts
   383                          
   384                          ;.end
   385                          
   386                          ; ********************************************************************************************
   387                          ;
   388                          ;	Date		Changes
   389                          ;	====		=======
   390                          ;
   391                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/time.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      time.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; TI$="hh:mm:ss.t" Allows optional colons to delimit parameters and
    16                          ;   allows input to be abbrieviated (eg., TI$="h:mm" or
    17                          ;   even TI$=""), defaulting to "00" for unspecified
    18                          ;   parameters.  24-hour clock (00:00:00.0 to 23:59:59.9).
    19                          ;   901010 F.Bowen
    20                          
    21                          Set_TI_String
    22  537d 206d5b                             jsr     frefac                          ; we won't need it
    23  5380 850d                               sta     count                           ; save length
    24                          
    25  5382 a000                               ldy     #0                              ; our pointer into TI$ assignment
    26  5384 8487                               sty     time                            ; default time to zero, in case it's not fully specified
    27  5386 8488                               sty     time+1
    28  5388 8489                               sty     time+2
    29  538a 848a                               sty     time+3
    30                          
    31  538c a203                               ldx     #3                              ; parameter pointer (3=hr,2=min,1=sec,0=tenths)
    32  538e 20d453             l131_1          jsr     GetTimeDigit                    ; get first digit, convert to BCD
    33  5391 b013                               bcs     l131_2                          ; colon or eos
    34  5393 9587                               sta     time,x
    35  5395 20d453                             jsr     GetTimeDigit                    ; get second digit, convert to BCD
    36  5398 b00c                               bcs     l131_2                          ; colon or eos
    37                          
    38  539a 1687                               asl     time,x                          ; move first digit to msd
    39  539c 1687                               asl     time,x
    40  539e 1687                               asl     time,x
    41  53a0 1687                               asl     time,x
    42  53a2 1587                               ora     time,x                          ; combine with second digit
    43  53a4 9587                               sta     time,x                          ; now we have a time element of packed BCD
    44                          
    45  53a6 b587               l131_2          lda     time,x
    46  53a8 ddf153                             cmp     MaxTimeValues,x                 ; check for parameter too big
    47  53ab b351fe                             +lbcs   fcerr                           ; hr>23, min>59, sec>59, tenths>9
    48                          
    49  53ae ca                                 dex                                     ; check if done
    50  53af 3012                               bmi     l131_4                          ; yes- all parameters accounted for
    51  53b1 c40d                               cpy     count
    52  53b3 b013                               bcs     l131_5                          ; yes- end of string
    53                          
    54  53b5 20d522                             jsr     indin1_ram1                     ; check for optional colon (or period)   [910103]
    55  53b8 c93a                               cmp     #':'
    56  53ba f004                               beq     l131_3
    57  53bc c92e                               cmp     #'.'
    58  53be d0ce                               bne     l131_1                          ; not there
    59  53c0 c8                 l131_3          iny                                     ; it's there- skip over it
    60                          
    61  53c1 80cb                               bra     l131_1                          ; loop until done
    62                          
    63                          
    64  53c3 c40d               l131_4          cpy     count                           ; done
    65  53c5 93a922                             +lbcc   errlen                          ; error if string too long
    66                          
    67  53c8 ab8700             l131_5          ldz     time                            ; tenths  0-9
    68  53cb a588                               lda     time+1                          ; seconds 0-59
    69  53cd a689                               ldx     time+2                          ; minutes 0-59
    70  53cf a48a                               ldy     time+3                          ; hours  0-23
    71  53d1 4cdbff                             jmp     _SetTime                        ; Go set time & exit
    72                          
    73                          
    74                          ; Get an ASCII digit, make sure it's in range 0-9 or a colon.
    75                          ; if no digit to get, default to '0'
    76                          ;
    77                          ; exit with .c=0 if okay  (.A contains BCD)
    78                          ;    .c=1 if colon or eos (.A invalid)
    79                          
    80                          GetTimeDigit
    81  53d4 a900                               lda     #0                              ; default to '0'
    82  53d6 c40d                               cpy     count
    83  53d8 b014                               bcs     l132_1                          ; exit if at end of string (carry set)
    84                          
    85  53da 20d522                             jsr     indin1_ram1                     ; else get a character from string
    86  53dd c8                                 iny                                     ; point to next character
    87  53de c92e                               cmp     #'.'                            ; [910103]
    88  53e0 f00c                               beq     l132_1                          ; terminator (period) (carry set)
    89  53e2 c930                               cmp     #'0'                            ; check character, only 0-9 allowed
    90  53e4 9318fe                             +lbcc   fcerr                           ; too small
    91  53e7 c93a                               cmp     #':'
    92  53e9 9003                               bcc     l132_1                          ; just right  (carry clear)
    93  53eb d311fe                             +lbne   fcerr                           ; too big
    94                          ; falls through if colon (carry set)
    95                          
    96  53ee 290f               l132_1          and     #$0f                            ; make BCD
    97  53f0 60                                 rts
    98                          
    99                          
   100                          
   101                          MaxTimeValues
   102  53f1 10606024                           !text $10,$60,$60,$24                   ; t,s,m,h in packed BCD
   103                          
   104                          
   105                          ; x$=TI$  Return a string of the form "hh:mm:ss.t", including colons.
   106                          
   107                          Get_TI_String
   108  53f5 207054                             jsr     ReadSystemClock                 ; get time as packed BCD
   109                          
   110  53f8 a90a                               lda     #10                             ; get string space for 10 characters
   111  53fa 207b5a                             jsr     strspa
   112  53fd a8                                 tay                                     ; length
   113  53fe 88                                 dey                                     ; index
   114                          
   115  53ff a587                               lda     time                            ; build TI$ string in 'fbuffr'
   116  5401 0930                               ora     #'0'                            ; (build string backwards, from last chr to first)
   117  5403 a264                               ldx     #dsctmp+1
   118  5405 20f022                             jsr     sta_far_ram1                    ; put tenths (special case- only 1 digit)
   119  5408 88                                 dey
   120  5409 a92e                               lda     #'.'
   121  540b 20f022                             jsr     sta_far_ram1                    ; put period (special case)   [910103]
   122  540e 88                                 dey
   123  540f a201                               ldx     #1
   124  5411 800a                               bra     l133_2
   125                          
   126  5413 da                 l133_1          phx                                     ; element pointer (1=secs, 2=mins, 3=hrs)
   127  5414 a264                               ldx     #dsctmp+1
   128  5416 a93a                               lda     #':'
   129  5418 20f022                             jsr     sta_far_ram1                    ; put colon
   130  541b 88                                 dey
   131  541c fa                                 plx
   132                          
   133  541d b587               l133_2          lda     time,x
   134  541f 4b                                 taz
   135  5420 290f                               and     #$0f                            ; do lsd first, since we're working backwards
   136  5422 0930                               ora     #'0'
   137  5424 da                                 phx
   138  5425 a264                               ldx     #dsctmp+1
   139  5427 20f022                             jsr     sta_far_ram1                    ; put lsd
   140  542a 88                                 dey
   141  542b 6b                                 tza                                     ; then do msd
   142  542c 4a                                 lsr
   143  542d 4a                                 lsr
   144  542e 4a                                 lsr
   145  542f 4a                                 lsr
   146  5430 0930                               ora     #'0'
   147  5432 20f022                             jsr     sta_far_ram1                    ; put msd
   148  5435 fa                                 plx
   149  5436 e8                                 inx                                     ; next packed element
   150  5437 88                                 dey
   151  5438 10d9                               bpl     l133_1                          ; loop until done
   152                          
   153  543a a90a                               lda     #10                             ; length
   154  543c 205d5b                             jsr     mvdone                          ; update frespc ????
   155  543f 838f06                             +lbra   putnew                          ; make descriptor in dsctmp real
   156                          
   157                          
   158                          
   159                          ; ********************************************************************************************
   160                          ;
   161                          ;	Date		Changes
   162                          ;	====		=======
   163                          ;
   164                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/time.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      time.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; TI. Convert 24-hour TOD into tenths of seconds.  901010 F.Bowen
    13                          
    14                          Get_TI
    15  5442 207054                             jsr     ReadSystemClock                 ; glance at the clock, get time as h:m:s:t
    16  5445 6467                               stz     faclo                           ; init accumulator with tenths (0-9, so nothing to convert)
    17  5447 a300                               ldz     #0
    18  5449 6466                               stz     facmo
    19  544b 6465                               stz     facmoh
    20                          
    21  544d a203                               ldx     #3                              ; convert time (BCD) to tenths of seconds (binary) since midnight
    22  544f 207c54             l134_1          jsr     TimeMultiply
    23  5452 18                                 clc
    24  5453 6567                               adc     faclo
    25  5455 8567                               sta     faclo
    26  5457 a52b                               lda     product+1
    27  5459 6566                               adc     facmo
    28  545b 8566                               sta     facmo
    29  545d a52c                               lda     product+2
    30  545f 6565                               adc     facmoh
    31  5461 8565                               sta     facmoh                          ; (can't overflow since 23:59:59:9 -> 863999 ($0D2EFF)
    32  5463 ca                                 dex
    33  5464 d0e9                               bne     l134_1                          ; next factor
    34                          
    35  5466 a900                               lda     #0                              ; float value in FAC
    36  5468 8564                               sta     facho                           ; zero msb, facov, facsgn
    37  546a a2a0                               ldx     #160                            ; set facov for time
    38  546c 38                                 sec                                     ; normal fac
    39  546d 83760e                             +lbra   floatb                          ; do it
    40                          
    41                          
    42                          
    43                          ReadSystemClock
    44  5470 20deff                             jsr     _ReadTime                       ; get packed BCD, y=hrs, x=min, a=sec, z=tenths
    45                          ; (assumes system clock was set properly!)
    46  5473 6487                               stz     time                            ; tenths  0-9
    47  5475 8588                               sta     time+1                          ; seconds  0-59
    48  5477 8689                               stx     time+2                          ; minutes  0-59
    49  5479 848a                               sty     time+3                          ; hours  0-59
    50  547b 60                                 rts
    51                          
    52                          
    53                          ; Unsigned Integer Multiply: Time * Factor  -> Tenths_of_Seconds
    54                          ;     A   *  (B,C)  ->      (D,E,F)
    55                          
    56                          TimeMultiply
    57  547c b587                               lda     time,x                          ; convert packed BCD to binary
    58  547e 290f                               and     #$0f
    59  5480 8564                               sta     facho
    60  5482 b587                               lda     time,x                          ; 10x = 8x + 2x
    61  5484 29f0                               and     #$f0
    62  5486 4a                                 lsr                                     ; msd x 8
    63  5487 9587                               sta     time,x
    64  5489 4a                                 lsr
    65  548a 4a                                 lsr                                     ; msd x 2
    66  548b 18                                 clc
    67  548c 6564                               adc     facho                           ; lsd
    68  548e 7587                               adc     time,x
    69  5490 9587                               sta     time,x                          ; can't overflow ($99->153)
    70                          
    71  5492 8a                                 txa                                     ; make a word pointer from byte pointer
    72  5493 0a                                 asl
    73  5494 a8                                 tay
    74  5495 b9b954                             lda     TimeFactor-2,y                  ; multiplicand = TimeFactor,y  (2 bytes)
    75  5498 8528                               sta     multiplicand                    ; multiplier = Time,x x (1 byte)
    76  549a b9ba54                             lda     TimeFactor-1,y                  ; -----------
    77  549d 8529                               sta     multiplicand+1
    78  549f a900                               lda     #0                              ; product lo   (3 bytes)
    79  54a1 852b                               sta     product+1                       ; mid
    80  54a3 852c                               sta     product+2                       ; hi
    81                          
    82  54a5 a010                               ldy     #16                             ; 16-bit multiplicand
    83  54a7 0a                 l135_1          asl
    84  54a8 eb2b00                             row     product+1
    85  54ab eb2800                             row     multiplicand                    ; multiplier * multiplicand -> product
    86  54ae 9007                               bcc     l135_2
    87  54b0 18                                 clc
    88  54b1 7587                               adc     time,x
    89  54b3 9002                               bcc     l135_2
    90  54b5 e32b                               inw     product+1                       ; (does no error check, since using time factors
    91  54b7 88                 l135_2          dey                                     ; in ROM and maximum time multiplier of 59 there
    92  54b8 d0ed                               bne     l135_1                          ; is no danger of overflow)
    93                          
    94                          ; sta product
    95  54ba 60                                 rts                                     ; (.X is preserved)
    96                          
    97                          
    98                          TimeFactor
    99  54bb 0a00                               !word 10                                ; tenths per second  (max    59*10 =    590 ($0024E)
   100  54bd 5802                               !word 600                               ; per minute  (max   59*600 =  35400 ($08A48)
   101  54bf a08c                               !word 36000                             ; per hour    (max 23*36000 = 828000 ($CA260)
   102                          
   103                          
   104                          ; ********************************************************************************************
   105                          ;
   106                          ;	Date		Changes
   107                          ;	====		=======
   108                          ;
   109                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/sleep.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      sleep.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*******************************************************************************
    16                          ;*
    17                          ;* SLEEP Command - Postpone all activity for a specified number of seconds
    18                          ;*
    19                          ;* Syntax:  SLEEP n
    20                          ;*
    21                          ;* Where n is the number of seconds to remain inactive,
    22                          ;* expressed as a positive value < 65536.
    23                          ;*
    24                          ;*******************************************************************************
    25                          
    26  54c1 208a5d             sleep           jsr     getwrd                          ; get argument in (y,a)
    27                          
    28                          ; Multiply # of seconds to sleep by 60.  This will be the number of 'jiffies'
    29                          ; to hibernate.  Store this value in 3 consecutive locations the kernel will
    30                          ; decrement as a 24-bit binary value, and wait for an underflow.
    31                          ;
    32                          ; ldx #0   ;THIS CODE REPLACED    [910730]
    33                          ; php
    34                          ; sei   ;silence, please!
    35                          ; sty _sleep_counter
    36                          ; sta _sleep_counter+1
    37                          ; stx _sleep_counter+2 ;sleep_counter = n
    38                          ;
    39                          ; jsr sleep_times_2 ;sleep_counter = 2n
    40                          ; jsr add_xay_to_sleep ;sleep_counter = 3n
    41                          ; jsr sleep_times_4 ;sleep_counter = 12n
    42                          ;
    43                          ; ldy _sleep_counter
    44                          ; lda _sleep_counter+1
    45                          ; ldx _sleep_counter+2 ;(xay) = 12n
    46                          ;
    47                          ; jsr sleep_times_4 ;sleep_counter = 48n
    48                          ; jsr add_xay_to_sleep ;sleep_counter = 60n !!!!!
    49                          ;
    50                          ; plp
    51                          ;
    52                          ;1$ jsr is_stop_key_down
    53                          ; ldx _sleep_counter+2
    54                          ; inx   ;underflow?
    55                          ; bne 1$   ;no, loop
    56                          ; rts
    57                          ;
    58                          ;
    59                          ;sleep_times_4
    60                          ; jsr sleep_times_2
    61                          ;sleep_times_2
    62                          ; asl _sleep_counter
    63                          ; rol _sleep_counter+1
    64                          ; rol _sleep_counter+2
    65                          ; rts
    66                          ;
    67                          ;add_xay_to_sleep
    68                          ; pha
    69                          ; tya
    70                          ; adc _sleep_counter
    71                          ; sta _sleep_counter
    72                          ; pla
    73                          ; adc _sleep_counter+1
    74                          ; sta _sleep_counter+1
    75                          ; txa
    76                          ; adc _sleep_counter+2
    77                          ; sta _sleep_counter+2
    78                          ; rts
    79                          
    80                          
    81                          ; SLEEP is now based upon the system hardware TOD clock (same one used by TI$).  This
    82                          ; makes it accurate, something it was not when it was based upon the frame rate.
    83                          
    84  54c4 8487                               sty     time                            ; Number of seconds to "sleep"   [910730] new
    85  54c6 8588                               sta     time+1
    86                          
    87  54c8 20deff             l136_1          jsr     _ReadTime                       ; Get current time
    88  54cb 6489                               stz     time+2                          ; tenths
    89  54cd 858a                               sta     time+3                          ; seconds
    90                          
    91  54cf 20cc2c             l136_2          jsr     is_stop_key_down                ; Allow user to abort
    92  54d2 20deff                             jsr     _ReadTime                       ; Wait for seconds to increment
    93  54d5 c58a                               cmp     time+3
    94  54d7 f0f6                               beq     l136_2
    95  54d9 858a                               sta     time+3
    96                          
    97  54db 20deff             l136_3          jsr     _ReadTime                       ; Wait for tenths to increment
    98  54de d489                               cpz     time+2
    99  54e0 d0f9                               bne     l136_3
   100                          
   101  54e2 c387                               dew     time                            ; Decrement sleep period 1 second
   102  54e4 d0e9                               bne     l136_2                          ; Loop until sleep period over
   103                          
   104  54e6 60                                 rts
   105                          
   106                          ;.end
   107                          
   108                          ; ********************************************************************************************
   109                          ;
   110                          ;	Date		Changes
   111                          ;	====		=======
   112                          ;
   113                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/wait.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      wait.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; WAIT<location>,<mask1>[,<mask2>] statement waits until the contents of
    16                          ; <location> is nonzero when XORed with mask2 and then ANDed with mask1.
    17                          ; If mask2 is not present, it is assumed to be zero.
    18                          
    19  54e7 207c5d             wait            jsr     getnum                          ; get required mask1
    20  54ea 864b                               stx     andmsk
    21  54ec a200                               ldx     #0
    22  54ee 208522                             jsr     chrgot
    23  54f1 f003                               beq     l137_1
    24  54f3 20825d                             jsr     combyt                          ; get optional mask2
    25  54f6 864c               l137_1          stx     eormsk
    26                          
    27  54f8 db                                 phz
    28  54f9 abd102                             ldz     current_bank                    ; set up bank number for fetch
    29  54fc a216                               ldx     #poker                          ; ..and address
    30  54fe a000                               ldy     #0                              ; ..and index
    31                          
    32  5500 2cd102             l137_2          bit     current_bank
    33  5503 3004                               bmi     l137_3                          ; NOMAP?
    34  5505 2074ff                             jsr     _lda_far                        ; lda (poker),y
    35  5508 2c                                 !text $2c
    36                          
    37  5509 b116               l137_3          lda     (poker),y
    38  550b 454c                               eor     eormsk
    39  550d 254b                               and     andmsk
    40  550f f0ef                               beq     l137_2
    41  5511 fb                                 plz
    42  5512 60                                 rts                                     ; got a nonzero
    43                          
    44                          ;.end
    45                          
    46                          ; ********************************************************************************************
    47                          ;
    48                          ;	Date		Changes
    49                          ;	====		=======
    50                          ;
    51                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/fre.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      fre.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*****************************************************************************
    16                          ; FRE(n) Function
    17                          ;
    18                          ; Where: n=0 returns amount of free RAM in bank 0. This is the area
    19                          ;  between top of text (TEXT_TOP) and top of RAM (MAX_MEM_0).
    20                          ;
    21                          ;  n=1 returns amount of free ram in bank 1. This is the area
    22                          ;  between top of arrays (STREND) and bottom of strings (FRETOP).
    23                          ;
    24                          ;  n=2 returns the amount (???? presence) of expansion RAM.
    25                          ;
    26                          ;*****************************************************************************
    27                          
    28  5513 206f5d             fre             jsr     conint                          ; get integer argument in .x
    29  5516 e001                               cpx     #1                              ; which bank?
    30  5518 f015                               beq     l138_1                          ; go do bank one
    31  551a e002                               cpx     #2                              ; go do expansion banks   [910107]
    32  551c f020                               beq     l138_2                          ; else it must be bank zero
    33  551e b3defc                             +lbcs   fcerr                           ; any other is unpleasant to talk about
    34                          
    35  5521 38                                 sec                                     ; FRE(text_bank)
    36  5522 adcf02                             lda     max_mem_0
    37  5525 e582                               sbc     text_top
    38  5527 a8                                 tay                                     ; set up result for nosflt
    39  5528 add002                             lda     max_mem_0+1
    40  552b e583                               sbc     text_top+1
    41  552d 8014                               bra     l138_3                          ; assumes text_top < max_mem
    42                          
    43                          
    44  552f 20335c             l138_1          jsr     garba2                          ; FRE(var_bank) do garbage collect first
    45  5532 38                                 sec
    46  5533 a535                               lda     fretop
    47  5535 e533                               sbc     strend
    48  5537 a8                                 tay
    49  5538 a536                               lda     fretop+1
    50  553a e534                               sbc     strend+1
    51  553c 8005                               bra     l138_3
    52                          
    53  553e ac0711             l138_2          ldy     _expansion                      ; FRE(expansion banks)    [910107]
    54  5541 a900                               lda     #0
    55                          
    56  5543 838203             l138_3          +lbra   nosflt                          ; go float the number (y,a)=(lo,hi)
    57                          
    58                          ;.end
    59                          
    60                          ; ********************************************************************************************
    61                          ;
    62                          ;	Date		Changes
    63                          ;	====		=======
    64                          ;
    65                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/val.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      val.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; The VAL function takes a string and turns it into a number by interpreting
    16                          ; the PETSCII digits etc.  Except for the problem that a terminator must be
    17                          ; supplied by replacing the character beyond the string, VAL is merely a call
    18                          ; to floating point input (FIN).
    19                          
    20  5546 205c5a             val             jsr     len1                            ; get length
    21  5549 f3fe08                             +lbeq   zerofc                          ; return 0 if len=0
    22                          
    23                          ; Use text to fp number code by faking a new text poiner
    24                          
    25  554c 18                 val_1           clc                                     ; ///jump table entry.  convert PETSCII to floating point
    26  554d 6524                               adc     index1
    27  554f 8572                               sta     strng2                          ; add length to index1 and put in strng2
    28  5551 a525                               lda     index1+1
    29  5553 6900                               adc     #0
    30  5555 8573                               sta     strng2+1
    31                          
    32  5557 a000                               ldy     #0
    33  5559 a972                               lda     #strng2
    34  555b 20d722                             jsr     lda_far_ram1                    ; replace character after string with $00 (fake EOL)
    35  555e 48                                 pha                                     ; save old character
    36  555f 98                                 tya                                     ; (.A=0)
    37  5560 a272                               ldx     #strng2
    38  5562 20f022                             jsr     sta_far_ram1 ;sta (strng2),y    ; ..and put in null
    39  5565 205f64                             jsr     fin_chrget_2                    ; get character pointed to and set flags.(sorta like chrgot)
    40  5568 a201                               ldx     #1                              ; flag 'bank 1'
    41  556a 208d63                             jsr     fin                             ; go do evaluation
    42  556d 68                                 pla                                     ; get saved character
    43  556e da                                 phx
    44  556f a272                               ldx     #strng2
    45  5571 a000                               ldy     #0
    46  5573 20f022                             jsr     sta_far_ram1 ;sta (strng2),y    ; restore zeroed-out character
    47  5576 fa                                 plx
    48  5577 60                                 rts
    49                          
    50                          ;.end
    51                          
    52                          ; ********************************************************************************************
    53                          ;
    54                          ;	Date		Changes
    55                          ;	====		=======
    56                          ;
    57                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/dec.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      dec.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; DEC convert a hex string representing a 2-byte integer into decimal.
    16                          
    17  5578 205c5a             dcml            jsr     len1                            ; find length of string
    18  557b 8526                               sta     index2                          ; len ret. in a
    19  557d a000                               ldy     #0
    20  557f 8427                               sty     index2+1                        ; zero char counter
    21  5581 8473                               sty     strng2+1                        ; zero out value
    22  5583 8472                               sty     strng2
    23                          
    24  5585 c426               l139_1          cpy     index2                          ; evaluated all characters?
    25  5587 f034                               beq     l139_4                          ; branch if so
    26  5589 20d522                             jsr     indin1_ram1                     ; get next character from string
    27  558c c8                                 iny
    28  558d c920                               cmp     #' '                            ; ignore spaces
    29  558f f0f4                               beq     l139_1
    30  5591 e627                               inc     index2+1
    31  5593 a627                               ldx     index2+1
    32  5595 e005                               cpx     #5
    33  5597 b02b                               bcs     decbad                          ; can't have more than 4 characters
    34                          
    35  5599 c930                               cmp     #'0'
    36  559b 9027                               bcc     decbad                          ; bad if < 0
    37  559d c93a                               cmp     #':'                            ; '9'+1
    38  559f 900a                               bcc     l139_2                          ; ok if  = 0-9
    39  55a1 c941                               cmp     #'A'
    40  55a3 901f                               bcc     decbad                          ; bad if > 9  and < A
    41  55a5 c947                               cmp     #'G'
    42  55a7 b01b                               bcs     decbad                          ; bad if > F
    43                          
    44  55a9 e907                               sbc     #7                              ; adjust if A-F  (.c is clr)
    45  55ab e92f               l139_2          sbc     #$2f                            ; adjust to $00..$0f (.c is set)
    46  55ad 0a                                 asl                                     ; shift low nibble to high
    47  55ae 0a                                 asl
    48  55af 0a                                 asl
    49  55b0 0a                                 asl
    50                          
    51  55b1 a204                               ldx     #4                              ; mult. old val. by 16, add new
    52  55b3 0a                 l139_3          asl
    53  55b4 2672                               rol     strng2
    54  55b6 2673                               rol     strng2+1
    55  55b8 ca                                 dex
    56  55b9 d0f8                               bne     l139_3
    57  55bb 80c8                               bra     l139_1
    58                          
    59  55bd a472               l139_4          ldy     strng2                          ; get lsb of value,
    60  55bf a573                               lda     strng2+1                        ; & msb,
    61  55c1 830403                             +lbra   nosflt                          ; go float 2 byte unsigned integer
    62                          
    63                          
    64                          decbad
    65  55c4 8338fc                             +lbra   fcerr                           ; illegal qty error
    66                          
    67                          ;.end
    68                          
    69                          
    70                          ; ********************************************************************************************
    71                          ;
    72                          ;	Date		Changes
    73                          ;	====		=======
    74                          ;
    75                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/peekpoke.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      peekpoke.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15  55c7 fc1600             peek            phw     poker                           ; ..also happens to be LINNUM!   [910911]
    16  55ca 20db4c                             jsr     chknum
    17  55cd 208d5d                             jsr     getadr
    18  55d0 a000                               ldy     #0                              ; index
    19  55d2 2cd102                             bit     current_bank
    20  55d5 300b                               bmi     l140_1                          ; NOMAP?
    21                          
    22  55d7 db                                 phz
    23  55d8 abd102                             ldz     current_bank                    ; set up bank number for Kernel's fetch
    24  55db a216                               ldx     #poker                          ; ..and address
    25  55dd 2074ff                             jsr     _lda_far                        ; lda (poker),y
    26  55e0 fb                                 plz
    27  55e1 2c                                 !text $2c
    28                          
    29  55e2 b116               l140_1          lda     (poker),y
    30  55e4 a8                                 tay                                     ; get byte into .y
    31  55e5 68                                 pla
    32  55e6 8517                               sta     poker+1                         ; restore linnum
    33  55e8 68                                 pla
    34  55e9 8516                               sta     poker
    35  55eb 83e502                             +lbra   sngflt                          ; float it
    36                          
    37                          
    38  55ee 207c5d             poke            jsr     getnum
    39  55f1 8a                 l141_1          txa                                     ; set up value to store for Kernel 'stash' routine
    40  55f2 a000                               ldy     #0                              ; ..and index
    41  55f4 78                                 sei                                     ; to allow poking IRQ vector, etc.  [910612]
    42  55f5 2cd102                             bit     current_bank
    43  55f8 300b                               bmi     l141_2                          ; (anything >1Meg means NOMAP)
    44                          
    45  55fa db                                 phz
    46  55fb a216                               ldx     #poker                          ; ..and address
    47  55fd abd102                             ldz     current_bank                    ; ..finally, get the bank number
    48  5600 2077ff                             jsr     _sta_far                        ; sta (poker),y
    49  5603 fb                                 plz
    50  5604 2c                                 !text $2c
    51                          
    52  5605 9116               l141_2          sta     (poker),y                       ; NoMap
    53                          
    54  5607 208522             l141_3          jsr     chrgot                          ; eol?
    55  560a f00a                               beq     l141_4                          ; yes
    56  560c e316                               inw     poker                           ; no- increment address
    57                          ; lda poker  ; check for segment wrap (FFFF->0000) [910911]
    58                          ; ora poker+1
    59  560e f331d8                             +lbeq   omerr                           ; [910916]
    60  5611 202679                             jsr     optbyt                          ; & get next [,byte]
    61  5614 b0db                               bcs     l141_1
    62                          
    63  5616 58                 l141_4          cli                                     ; [910612]
    64  5617 60                                 rts
    65                          
    66                          
    67                          ;.end
    68                          
    69                          
    70                          ; ********************************************************************************************
    71                          ;
    72                          ;	Date		Changes
    73                          ;	====		=======
    74                          ;
    75                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/errstr.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      errstr.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14  5618 20c162             errd            jsr     sign                            ; get sign
    15  561b 300c                               bmi     l142_1                          ; (allow err$(er) when er=-1)
    16  561d 206f5d                             jsr     conint                          ; get integer arg in x
    17  5620 ca                                 dex
    18  5621 8a                                 txa                                     ; error # (0 to max-1)
    19  5622 c92a                               cmp     #last_error_message             ; check range
    20  5624 900f                               bcc     l142_2                          ; ok
    21  5626 a200                               ldx     #0                              ; too high, return null
    22  5628 2c                                 !text $2c
    23                          
    24  5629 a202               l142_1          ldx     #2                              ; no error, return "ok"    [910911]
    25  562b a96a                               lda     #<ok_error_message
    26  562d a029                               ldy     #>ok_error_message
    27  562f 8526                               sta     index2
    28  5631 8427                               sty     index2+1
    29  5633 8013                               bra     l142_5                          ; pass it
    30                          
    31  5635 20a92b             l142_2          jsr     erstup                          ; look up the error, set up a pointer to it
    32  5638 a0ff                               ldy     #$ff                            ; determine how long it is
    33  563a a200                               ldx     #0
    34  563c e8                 l142_3          inx                                     ; count printing characters
    35  563d c8                 l142_4          iny
    36  563e b126                               lda     (index2),y                      ; (rom: ind.ok)
    37  5640 3006                               bmi     l142_5                          ; msb set means last
    38  5642 c920                               cmp     #' '
    39  5644 90f7                               bcc     l142_4                          ; don't count non-printers
    40  5646 80f4                               bra     l142_3                          ; count all others
    41                          
    42  5648 8a                 l142_5          txa                                     ; message length
    43  5649 207b5a                             jsr     strspa                          ; get space
    44  564c aa                                 tax
    45  564d f01d                               beq     l142_7                          ; null
    46                          
    47                          ; sta sw_rom_ram1  ;set up string bank????
    48  564f a200                               ldx     #0
    49  5651 a0ff                               ldy     #$ff
    50  5653 c8                 l142_6          iny                                     ; copy message into memory
    51  5654 b126                               lda     (index2),y                      ; (rom: ind.ok)
    52  5656 c920                               cmp     #' '
    53  5658 90f9                               bcc     l142_6                          ; skip non-printers
    54                          
    55  565a 48                                 pha
    56  565b 297f                               and     #$7f
    57  565d 5a                                 phy                                     ; swap x&y
    58  565e da                                 phx
    59  565f 7a                                 ply
    60  5660 a264                               ldx     #dsctmp+1
    61  5662 20f022                             jsr     sta_far_ram1                    ; sta (dsctmp+1),y to RAM1
    62  5665 5a                                 phy                                     ; swap x&y
    63  5666 fa                                 plx
    64  5667 7a                                 ply
    65  5668 e8                                 inx
    66  5669 68                                 pla                                     ; test if msb was set
    67  566a 10e7                               bpl     l142_6
    68                          
    69  566c 835903             l142_7          +lbra   chrd1                           ; pla,pla,jmp putnew
    70                          
    71                          
    72                          ;.end
    73                          
    74                          ; ********************************************************************************************
    75                          ;
    76                          ;	Date		Changes
    77                          ;	====		=======
    78                          ;
    79                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/hexstr.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      hexstr.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15  566f 20db4c             hexd            jsr     chknum
    16  5672 fc1600                             phw     poker                           ; save linnum    [910911]
    17  5675 208d5d                             jsr     getadr                          ; 2 byte val in (poker)
    18  5678 a904                               lda     #4
    19  567a 207b5a                             jsr     strspa
    20  567d a000                               ldy     #0
    21  567f a517                               lda     poker+1
    22  5681 209256                             jsr     hexit
    23  5684 a516                               lda     poker
    24  5686 209256                             jsr     hexit
    25  5689 68                                 pla                                     ; restore linnum
    26  568a 8517                               sta     poker+1
    27  568c 68                                 pla
    28  568d 8516                               sta     poker
    29  568f 833603                             +lbra   chrd1                           ; pla,pla,jmp putnew
    30                          
    31  5692 48                 hexit           pha
    32  5693 4a                                 lsr
    33  5694 4a                                 lsr
    34  5695 4a                                 lsr
    35  5696 4a                                 lsr
    36  5697 209b56                             jsr     dohex
    37  569a 68                                 pla
    38                          
    39  569b 290f               dohex           and     #$0f
    40  569d c90a                               cmp     #$0a
    41  569f 9002                               bcc     l143_1
    42  56a1 6906                               adc     #6
    43  56a3 6930               l143_1          adc     #'0'
    44  56a5 da                                 phx
    45  56a6 a264                               ldx     #dsctmp+1
    46  56a8 20f022                             jsr     sta_far_ram1                    ; sta (dsctmp+1),y
    47  56ab fa                                 plx
    48  56ac c8                                 iny
    49  56ad 60                                 rts
    50                          
    51                          ;.end
    52                          
    53                          ; ********************************************************************************************
    54                          ;
    55                          ;	Date		Changes
    56                          ;	====		=======
    57                          ;
    58                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/joy.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      joy.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*************************************************************
    16                          ; JOY (n)  -- Return joystick status
    17                          ;
    18                          ; where: n =  1  return position of joystick-1
    19                          ;       2  return position of joystick-2
    20                          ;
    21                          ; result:      0  no direction, no button
    22                          ;       1-8    direction (see below), no button
    23                          ;       128 no direction, button
    24                          ;       129-136 direction & button  128 + [1...8]
    25                          ;
    26                          ; button--->  128        1
    27                          ;       8     2
    28                          ; stick--->  7           3
    29                          ;       6     4
    30                          ;          5
    31                          ;
    32                          ;*************************************************************
    33                          
    34  56ae 206f5d             joy             jsr     conint                          ; get 1 byte arg in x
    35  56b1 ca                                 dex
    36  56b2 e002                               cpx     #2                              ; make sure arg. is valid
    37  56b4 b348fb                             +lbcs   fcerr                           ; >1, error
    38                          
    39  56b7 8a                                 txa
    40  56b8 4901                               eor     #1                              ; invert to match legends on case
    41  56ba aa                                 tax
    42  56bb 08                                 php                                     ; save status
    43                          
    44                          ; jsr put_io_in_map
    45  56bc 78                                 sei                                     ; disable IRQ to inhibit kybd
    46  56bd ad00dc                             lda     d1pra
    47  56c0 48                                 pha                                     ; save kybd output lines
    48  56c1 a0ff                               ldy     #$ff
    49  56c3 8c00dc                             sty     d1pra                           ; set to not read any kybd inputs
    50                          
    51  56c6 bd00dc             l144_1          lda     d1pra,x                         ; read joystick values
    52  56c9 dd00dc                             cmp     d1pra,x                         ; debounce
    53  56cc d0f8                               bne     l144_1
    54                          
    55  56ce aa                                 tax                                     ; save joystick values
    56  56cf 68                                 pla
    57  56d0 8d00dc                             sta     d1pra                           ; reset kybd output lines
    58  56d3 8a                                 txa                                     ; restore joystick values
    59  56d4 28                                 plp                                     ; restore status
    60  56d5 290f                               and     #$0f                            ; test which direction
    61  56d7 a8                                 tay
    62  56d8 b9e356                             lda     joytab-5,y                      ; get direction indicator
    63  56db a8                                 tay                                     ; save direction : 0-8
    64  56dc 8a                                 txa                                     ; restore joystick value
    65  56dd 2910                               and     #$10                            ; test if button triggered
    66  56df d004                               bne     l144_2                          ; skip if not
    67  56e1 98                                 tya
    68  56e2 0980                               ora     #$80                            ; show trigger depressed
    69  56e4 a8                                 tay
    70  56e5 83eb01             l144_2          +lbra   sngflt                          ; float 1 byte arg in y.
    71                          
    72  56e8 0402030006080700...joytab          !text 4,2,3,0,6,8,7,0,5,1,0
    73                          
    74                          ;.end
    75                          
    76                          
    77                          ; ********************************************************************************************
    78                          ;
    79                          ;	Date		Changes
    80                          ;	====		=======
    81                          ;
    82                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/potpen.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      potpen.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;***********************************************************
    15                          ; POT(n)  --  Read paddles
    16                          ;
    17                          ;    n = 1 : paddle-1 - X-position
    18                          ;  2 : paddle-1 - Y-position
    19                          ;  3 : paddle-2 - X-position
    20                          ;  4 : paddle-2 - Y-position
    21                          ;
    22                          ;     result >= 256 --  trigger set
    23                          ;***********************************************************
    24                          
    25  56f3 20554e             pot             jsr     chkcls                          ; look for closing paren
    26  56f6 206f5d                             jsr     conint                          ; get 1-byte arg in .x
    27  56f9 ca                                 dex
    28  56fa e004                               cpx     #4
    29  56fc b300fb                             +lbcs   fcerr                           ; value error
    30                          
    31                          ; jsr put_io_in_map
    32  56ff 8a                                 txa                                     ; convert arg (0-3) into paddle enables
    33  5700 4a                                 lsr                                     ; .c= X/Y   .a= port 1/2
    34  5701 aa                                 tax
    35  5702 bd6b79                             lda     sbits+6,x
    36  5705 aa                                 tax                                     ; (CIA paddle port, $40/$80)
    37  5706 a900                               lda     #0
    38  5708 2a                                 rol
    39  5709 a8                                 tay                                     ; (SID x/y offset,  $00/$01)
    40                          
    41  570a 8e6e11                             stx     pot_temp_1                      ; save which port
    42  570d 08                                 php                                     ; save IRQ enable while we
    43  570e 78                                 sei                                     ; disable IRQ to inhibit keyboard scan
    44  570f ad00dc                             lda     d1pra
    45  5712 48                                 pha                                     ; save kybd output lines
    46  5713 8e00dc                             stx     d1pra                           ; turn on correct paddle
    47                          
    48  5716 205d48                             jsr     go_slow
    49  5719 a200                               ldx     #0
    50  571b e8                 l145_1          inx                                     ; delay to let pot be read by SID
    51  571c d0fd                               bne     l145_1
    52                          
    53  571e b919d4             l145_2          lda     sid1+25,y                       ; read pot
    54  5721 d919d4                             cmp     sid1+25,y                       ; debounce
    55  5724 d0f8                               bne     l145_2
    56  5726 8d6f11                             sta     pot_temp_2                      ; save pot value
    57  5729 205748                             jsr     go_fast
    58                          
    59  572c a200                               ldx     #0                              ; set index to d1pra
    60  572e 2c6e11                             bit     pot_temp_1                      ; test if pot-0,1 or pot-2,3
    61  5731 3001                               bmi     l145_3                          ; skip if pot 2,3
    62  5733 e8                                 inx                                     ; index to d1prb
    63  5734 a904               l145_3          lda     #04                             ; use joy line-2
    64  5736 88                                 dey                                     ; test if pot-x or pot-y
    65  5737 3001                               bmi     l145_4                          ; skip if pot-x
    66  5739 0a                                 asl                                     ; use joy line-3
    67  573a a0ff               l145_4          ldy     #$ff
    68  573c 8c00dc                             sty     d1pra                           ; disable keybd inputs
    69  573f c8                                 iny                                     ; set to zero for no trigger
    70  5740 3d00dc                             and     d1pra,x                         ; test if trigger set
    71  5743 d001                               bne     l145_5                          ; skip if not trigger
    72  5745 c8                                 iny                                     ; return value >255 for trigger
    73  5746 68                 l145_5          pla
    74  5747 8d00dc                             sta     d1pra                           ; restore keybd lines
    75  574a 98                                 tya
    76  574b ac6f11                             ldy     pot_temp_2                      ; restore pot value
    77  574e 28                                 plp                                     ; restore status
    78  574f 837601                             +lbra   nosflt                          ; output 2-byte result
    79                          
    80                          
    81                          ;*************************************************************
    82                          ;  LPEN(n)  --  Read light pen
    83                          ;
    84                          ; n = 0 x position
    85                          ;     1 y position
    86                          ;*************************************************************
    87                          
    88  5752 20554e             lpen            jsr     chkcls                          ; look for closing parens
    89  5755 206f5d                             jsr     conint                          ; get 1 byte arg in .X
    90                          ; dex   ;convert [1-2] to [0-1]
    91  5758 e002                               cpx     #2
    92  575a b3a2fa                             +lbcs   fcerr                           ; bad value
    93                          
    94  575d a900                               lda     #0
    95  575f 78                                 sei
    96  5760 bce802                             ldy     lightpen_xpos,x                 ; get latched light pen value (a=msb, y=lsb)
    97  5763 9de802                             sta     lightpen_xpos,x                 ; reset to zero (????preserve last latched position)
    98  5766 58                                 cli
    99  5767 e000                               cpx     #0
   100  5769 d006                               bne     l146_1                          ; done if y position
   101  576b 98                                 tya
   102  576c 0a                                 asl                                     ; else multiply *2 to get correct x position
   103  576d a8                                 tay                                     ; lsb
   104  576e a900                               lda     #0
   105  5770 2a                                 rol                                     ; msb
   106  5771 835401             l146_1          +lbra   nosflt                          ; float it (y,a)
   107                          
   108                          
   109                          ;.end
   110                          
   111                          ; ********************************************************************************************
   112                          ;
   113                          ;	Date		Changes
   114                          ;	====		=======
   115                          ;
   116                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/pointer.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      pointer.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;******************************************************************
    16                          ;
    17                          ; POINTER(var_name) - Return address of descriptor for var_name
    18                          ;
    19                          ;******************************************************************
    20                          
    21  5774 208322             pointer         jsr     chrget                          ; skip over escape token
    22  5777 20584e                             jsr     chkopn                          ; test for open paren
    23  577a 200250                             jsr     isletc                          ; test if character follows parens
    24  577d 93cbd6                             +lbcc   snerr                           ; ...syntax error if not.
    25  5780 207c4f                             jsr     ptrget                          ; look for this varname in table
    26                          
    27                          pointer_ret     =*-1
    28  5783 aa                                 tax
    29  5784 5a                                 phy
    30  5785 20554e                             jsr     chkcls                          ; look for closing paren
    31  5788 8a                                 txa
    32  5789 a8                                 tay
    33  578a 68                                 pla
    34  578b c902                               cmp     #>zero                          ; is this a dummy pointer?
    35  578d d003                               bne     l147_1
    36  578f a900                               lda     #0                              ; if so, return 0
    37  5791 a8                                 tay
    38  5792 833301             l147_1          +lbra   nosflt
    39                          
    40                          ;.end
    41                          
    42                          ; ********************************************************************************************
    43                          ;
    44                          ;	Date		Changes
    45                          ;	====		=======
    46                          ;
    47                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: operator/xor.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      xor.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;**************************************************************
    16                          ;*
    17                          ;*   XOR - Exclusive-or two 16 bit arguments
    18                          ;*
    19                          ;* Syntax : XOR (arg1, arg2)
    20                          ;*
    21                          ;**************************************************************
    22                          
    23  5795 fc1600             xor             phw     poker                           ; protect the poker value (could be in use)  [910911]
    24  5798 20db4c                             jsr     chknum
    25  579b 208d5d                             jsr     getadr                          ; get first arg
    26  579e 48                                 pha                                     ; save MSB
    27  579f 5a                                 phy                                     ; save LSB
    28                          
    29  57a0 20875d                             jsr     comwrd                          ; check for comma, get word
    30  57a3 20554e                             jsr     chkcls                          ; check for closing parens
    31                          
    32  57a6 68                                 pla
    33  57a7 4516                               eor     poker                           ; xor LSB (comwrd left a copy of its arg in POKER)
    34  57a9 a8                                 tay
    35  57aa 68                                 pla
    36  57ab 4517                               eor     poker+1                         ; ..and MSB
    37  57ad 20c758                             jsr     nosflt                          ; ..and go float 'em
    38                          
    39  57b0 68                                 pla
    40  57b1 8517                               sta     poker+1
    41  57b3 68                                 pla
    42  57b4 8516                               sta     poker
    43  57b6 60                                 rts
    44                          
    45                          ;.end
    46                          
    47                          ; ********************************************************************************************
    48                          ;
    49                          ;	Date		Changes
    50                          ;	====		=======
    51                          ;
    52                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: operator/mod.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      mod.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;**************************************************************
    16                          ;*
    17                          ;* MOD  -  Modulus of a number
    18                          ;*
    19                          ;* Syntax : MOD (number, range)
    20                          ;*      910402 FAB
    21                          ;**************************************************************
    22                          
    23                          ; Calculate   MOD = NUMBER-RANGE*INT(NUMBER/RANGE)
    24                          
    25  57b7 20db4c             mod             jsr     chknum                          ; 1st arg in FAC1 (number)
    26  57ba 20734d                             jsr     pushf1                          ; save two copies of it for later
    27  57bd 20734d                             jsr     pushf1
    28  57c0 205b4e                             jsr     chkcom                          ; check for comma
    29  57c3 20d84c                             jsr     frmnum                          ; 2nd arg in FAC1 (range)
    30  57c6 20554e                             jsr     chkcls                          ; check for closing paren
    31                          
    32  57c9 20a362                             jsr     movaf                           ; save range in FAC2
    33  57cc 20964d                             jsr     pullf1                          ; get back number in FAC1
    34  57cf a205                               ldx     #5                              ; swap FAC1 and FAC2
    35  57d1 b563               l148_1          lda     facexp,x
    36  57d3 b46a                               ldy     argexp,x
    37  57d5 956a                               sta     argexp,x
    38  57d7 9463                               sty     facexp,x
    39  57d9 ca                                 dex
    40  57da 10f5                               bpl     l148_1
    41  57dc 20734d                             jsr     pushf1                          ; save one copy of range for later
    42                          
    43  57df 207861                             jsr     fdivt_c65                       ; number/range
    44  57e2 206363                             jsr     int                             ; INT(number/range)
    45  57e5 20a362                             jsr     movaf                           ; round & move to FAC2
    46  57e8 20964d                             jsr     pullf1                          ; retrieve arg2 (range)
    47  57eb 206360                             jsr     fmultt_c65                      ; range*INT(number/range)
    48  57ee 20fc65                             jsr     negop                           ; -range*INT(number/range)
    49  57f1 20a362                             jsr     movaf                           ; move to FAC2
    50  57f4 20964d                             jsr     pullf1                          ; retrieve arg1 (number)
    51  57f7 83230c                             +lbra   faddt_c65                       ; number-range*INT(number/range)
    52                          
    53                          
    54                          ;.end
    55                          
    56                          
    57                          ; ********************************************************************************************
    58                          ;
    59                          ;	Date		Changes
    60                          ;	====		=======
    61                          ;
    62                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/rwindow.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rwindow.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;******************************************************************************
    15                          ;
    16                          ; RWINDOW  - Returns information about the current console display environment.
    17                          ;
    18                          ;   Syntax : RWINDOW (n)
    19                          ;
    20                          ;   Where: n=0 : number of lines in the current window
    21                          ;   =1 : number of rows in the current window
    22                          ;   =2 : returns either 40 or 80, depending on the
    23                          ;   current console device
    24                          ;
    25                          ;******************************************************************************
    26                          
    27  57fa 20554e             rwindow         jsr     chkcls
    28  57fd 206f5d                             jsr     conint
    29  5800 e002                               cpx     #2
    30  5802 f015                               beq     l149_2                          ; return current console
    31  5804 b3f8f9                             +lbcs   fcerr
    32                          
    33  5807 e000                               cpx     #0
    34  5809 d007                               bne     l149_1
    35                          
    36  580b a5e4                               lda     _screen_bottom
    37  580d 38                                 sec
    38  580e e5e5                               sbc     _screen_top
    39  5810 800d                               bra     l149_3                          ; always
    40                          
    41  5812 a5e7               l149_1          lda     _screen_right
    42  5814 38                                 sec
    43  5815 e5e6                               sbc     _screen_left
    44  5817 8006                               bra     l149_3                          ; always
    45                          
    46                          
    47  5819 a950               l149_2          lda     #80                             ; assume 80 col
    48  581b 7fd701                             bbr7    _mode,l149_3
    49  581e 4a                                 lsr
    50  581f a8                 l149_3          tay
    51  5820 83b000                             +lbra   sngflt                          ; float 1 byte arg in .Y
    52                          
    53                          ;.end
    54                          
    55                          ; ********************************************************************************************
    56                          ;
    57                          ;	Date		Changes
    58                          ;	====		=======
    59                          ;
    60                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/rnd.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rnd.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;    Random Number Function  RND(x)
    16                          ;
    17                          ;  x=0 ==> generate a random number based on hardware clock & noisy POT lines
    18                          ;  x<0 ==> seed a reproducable, pseudo-random number generator
    19                          ;  x>0 ==> generate a reproducable pseudo-random # based upon seed value above
    20                          
    21                          
    22  5823 20c162             rnd             jsr     sign                            ; get sign into .a
    23                          
    24  5826 3042               rnd_0           bmi     l150_2                          ; /// entry from jump table
    25  5828 d02b                               bne     l150_1
    26                          
    27                          
    28                          ; Get value from hardware
    29                          
    30  582a 205d48                             jsr     go_slow                         ; Use CIA#1 timer B & SID#2 pot X & Y for seeds  [910314]
    31  582d ad39d4                             lda     sid2+25                         ; go slow to read POT-X
    32  5830 0a                                 asl
    33  5831 0a                                 asl
    34  5832 0a                                 asl
    35  5833 0a                                 asl
    36  5834 0d3ad4                             ora     sid2+26                         ; and POT-Y
    37  5837 4d12d0                             eor     vic+18                          ; ???? should be okay- we're in Slow mode
    38  583a 8565                               sta     facmoh
    39  583c 205748                             jsr     go_fast                         ; restore speed
    40  583f ad06dc                             lda     d1pra+6                         ; timer B is free-running
    41  5842 8566                               sta     facmo
    42  5844 ad07dc                             lda     d1pra+7
    43  5847 8567                               sta     faclo
    44  5849 4564                               eor     facho
    45  584b 6565                               adc     facmoh
    46  584d 4566                               eor     facmo
    47  584f 6567                               adc     faclo
    48  5851 8564                               sta     facho
    49  5853 8025                               bra     l150_3
    50                          
    51                          
    52  5855 a974               l150_1          lda     #<rndx                          ; get last one into FAC
    53  5857 a011                               ldy     #>rndx
    54  5859 200e62                             jsr     movfm
    55  585c a990                               lda     #<rmulc
    56  585e a058                               ldy     #>rmulc                         ; FAC was zero.  restore last one
    57  5860 204860                             jsr     rommlt                          ; multiply by random constant
    58  5863 a995                               lda     #<raddc
    59  5865 a058                               ldy     #>raddc
    60  5867 205160                             jsr     romadd                          ; add random constant
    61                          
    62  586a a667               l150_2          ldx     faclo
    63  586c a564                               lda     facho
    64  586e 8567                               sta     faclo
    65  5870 8664                               stx     facho                           ; reverse hi and lo
    66  5872 a665                               ldx     facmoh
    67  5874 a566                               lda     facmo
    68  5876 8565                               sta     facmoh
    69  5878 8666                               stx     facmo
    70                          
    71  587a a900               l150_3          lda     #0                              ; strnex.  make number positive
    72  587c 8568                               sta     facsgn
    73  587e a563                               lda     facexp                          ; put exp where it will
    74  5880 8571                               sta     facov                           ; be shifted in by normal
    75  5882 a980                               lda     #$80
    76  5884 8563                               sta     facexp                          ; make result between 0 and 1
    77  5886 20295e                             jsr     normal                          ; normalize
    78  5889 a274                               ldx     #<rndx
    79  588b a011                               ldy     #>rndx
    80  588d 83ab09                             +lbra   movmf                           ; put new one into memory
    81                          
    82  5890 9835447a00         rmulc           !text 152,53,68,122,0
    83  5895 6828b14600         raddc           !text 104,40,177,70,0
    84                          
    85                          ;.end
    86                          
    87                          
    88                          ; ********************************************************************************************
    89                          ;
    90                          ;	Date		Changes
    91                          ;	====		=======
    92                          ;
    93                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/utils.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      utils.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14  589a 9080000000         n32768          !text $90,$80,0,0,0
    15                          
    16                          
    17  589f 20b458             flpint          jsr     ayint
    18  58a2 a566                               lda     facmo
    19  58a4 a467                               ldy     faclo
    20  58a6 60                                 rts
    21                          
    22                          
    23  58a7 208322             intidx          jsr     chrget
    24  58aa 20ef4c                             jsr     frmevl                          ; get a number
    25                          
    26                          
    27  58ad 20db4c             posint          jsr     chknum
    28  58b0 a568                               lda     facsgn
    29  58b2 300d                               bmi     nonono                          ; if negative, blow him out
    30                          
    31                          
    32  58b4 a563               ayint           lda     facexp
    33  58b6 c990                               cmp     #$90                            ; FAC > 32767?
    34  58b8 900a                               bcc     qintgo
    35  58ba a99a                               lda     #<n32768                        ; get address of -32768
    36  58bc a058                               ldy     #>n32768
    37  58be 20f162                             jsr     fcomp                           ; see if FAC=((x))
    38                          
    39  58c1 d33bf9             nonono          +lbne   fcerr                           ; no, FAC is too big
    40  58c4 836a0a             qintgo          +lbra   qint                            ; go shove it
    41                          
    42                          
    43                          ; Float an unsigned double byte integer
    44                          ; Entry:  MSB in (a), LSB in (y)
    45                          
    46  58c7 20d758             nosflt          jsr     stoint
    47  58ca 38                                 sec                                     ; sign is positive
    48  58cb 83120a                             +lbra   floatc
    49                          
    50                          
    51                          
    52  58ce 38                 pos             sec
    53  58cf 20f0ff                             jsr     _plot                           ; get tab pos in .y
    54                          
    55  58d2 a900               sngflt          lda     #0
    56  58d4 8369f5                             +lbra   givayf                          ; float it
    57                          
    58                          
    59                          
    60  58d7 a200               stoint          ldx     #0                              ; move int to fac & compute proper exponents
    61  58d9 860f                               stx     valtyp
    62  58db 8564                               sta     facho
    63  58dd 8465                               sty     facho+1
    64  58df a290                               ldx     #$90
    65  58e1 60                 storts          rts
    66                          
    67                          
    68                          
    69                          ; See if we are in direct mode, and complain if so.
    70                          
    71  58e2 ff7efc             errdir          bbs7    runmod,storts                   ; goto error if not in run mode
    72                          
    73  58e5 a215                               ldx     #errid                          ; input direct error code
    74  58e7 2c                                 !text $2c
    75                          
    76  58e8 a21b               errguf          ldx     #erruf
    77  58ea 8363d5                             +lbra   error
    78                          
    79                          
    80  58ed 7f7ef1             errind          bbr7    runmod,storts                   ; goto error if not in direct mode
    81  58f0 a222                               ldx     #erroid
    82  58f2 835bd5                             +lbra   error
    83                          
    84                          ;.end
    85                          
    86                          
    87                          ; ********************************************************************************************
    88                          ;
    89                          ;	Date		Changes
    90                          ;	====		=======
    91                          ;
    92                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/userdef.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      userdef.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ; User Defined Function Code
    15                          ;
    16                          ; Note only single arguments are allowed to functions, and functions must
    17                          ; be of the single line form:
    18                          ;
    19                          ;  DEF FNA(x)=x~2 + x-2
    20                          ;
    21                          ; No strings may be involved with these functions.
    22                          ;
    23                          ; Idea: create a simple variable entry whose first character has the MSB set.
    24                          ; The value will be:
    25                          ;
    26                          ;  A text pointer to the formula
    27                          ;  A pointer to the argument variable
    28                          
    29  58f5 202259             def             jsr     getfnm                          ; get a pointer to the function
    30  58f8 20e258                             jsr     errdir
    31  58fb 20584e                             jsr     chkopn                          ; must have a (
    32  58fe a980                               lda     #$80
    33  5900 8512                               sta     subflg                          ; prohibit subscripted & integer variables
    34  5902 207c4f                             jsr     ptrget                          ; get pointer to argument
    35  5905 20db4c                             jsr     chknum                          ; is it a number?
    36  5908 20554e                             jsr     chkcls                          ; must have )
    37  590b a9b2                               lda     #equal_token                    ; followed by =
    38  590d 205d4e                             jsr     synchr
    39  5910 48                                 pha
    40  5911 a54a                               lda     varpnt+1
    41  5913 48                                 pha
    42  5914 a549                               lda     varpnt
    43  5916 48                                 pha
    44  5917 a53e                               lda     txtptr+1
    45  5919 48                                 pha
    46  591a a53d                               lda     txtptr
    47  591c 48                                 pha
    48  591d 204835                             jsr     data
    49  5920 8073                               bra     deffin
    50                          
    51                          
    52                          ; Subroutine to get a pointer to a function name
    53                          
    54  5922 a9a5               getfnm          lda     #fn_token                       ; must start with fn
    55  5924 205d4e                             jsr     synchr
    56  5927 0980                               ora     #$80                            ; put function bit on
    57  5929 8512                               sta     subflg                          ; (disallows array & integer variables)
    58  592b 20834f                             jsr     ptrgt2                          ; get pointer to function or create anew
    59  592e 8550                               sta     defpnt
    60  5930 8451                               sty     defpnt+1
    61  5932 83a7f3                             +lbra   chknum                          ; make sure it's not a string, and return
    62                          
    63                          
    64  5935 202259             fndoer          jsr     getfnm                          ; get the function's name
    65  5938 a551                               lda     defpnt+1
    66  593a 48                                 pha
    67  593b a550                               lda     defpnt
    68  593d 48                                 pha
    69  593e 204f4e                             jsr     parchk                          ; evaluate parameter
    70  5941 20db4c                             jsr     chknum
    71  5944 68                                 pla
    72  5945 8550                               sta     defpnt
    73  5947 68                                 pla
    74  5948 8551                               sta     defpnt+1
    75  594a a002                               ldy     #2
    76  594c 209922                             jsr     inddef                          ; get pointer to the variable
    77  594f 8549                               sta     varpnt                          ; save variable pointer
    78  5951 aa                                 tax
    79  5952 c8                                 iny
    80  5953 209922                             jsr     inddef
    81  5956 f090                               beq     errguf
    82  5958 854a                               sta     varpnt+1
    83  595a c8                                 iny                                     ; since def uses only 4
    84                          
    85                          
    86  595b a949               defstf          lda     #varpnt
    87  595d 20d722                             jsr     lda_far_ram1
    88  5960 48                                 pha                                     ; push it all on the stack, since we might be recursing
    89  5961 88                                 dey
    90  5962 10f7                               bpl     defstf
    91  5964 a44a                               ldy     varpnt+1
    92                          
    93  5966 206262                             jsr     movmf_ram1                      ; put current FAC into our argument variable
    94  5969 a53e                               lda     txtptr+1                        ; save variable pointer
    95  596b 48                                 pha
    96  596c a53d                               lda     txtptr
    97  596e 48                                 pha
    98  596f 209922                             jsr     inddef                          ; get pointer to function
    99  5972 853d                               sta     txtptr
   100  5974 c8                                 iny
   101  5975 209922                             jsr     inddef
   102  5978 853e                               sta     txtptr+1
   103  597a a54a                               lda     varpnt+1                        ; save variable pointer
   104  597c 48                                 pha
   105  597d a549                               lda     varpnt
   106  597f 48                                 pha
   107  5980 20d84c                             jsr     frmnum                          ; evaluate variable, and check numeric
   108  5983 68                                 pla
   109  5984 8550                               sta     defpnt
   110  5986 68                                 pla
   111  5987 8551                               sta     defpnt+1
   112  5989 208522                             jsr     chrgot
   113  598c d3bcd4                             +lbne   snerr                           ; it didn't terminate, syntax error
   114                          
   115  598f 68                                 pla                                     ; restore text pointer
   116  5990 853d                               sta     txtptr
   117  5992 68                                 pla
   118  5993 853e                               sta     txtptr+1
   119                          
   120  5995 a000               deffin          ldy     #0
   121  5997 68                 l151_1          pla                                     ; get old arg value off stack,
   122  5998 da                                 phx
   123  5999 a250                               ldx     #defpnt
   124  599b 20f022                             jsr     sta_far_ram1 ;sta (defpnt),y    ; and put it back in variable
   125  599e fa                                 plx
   126  599f c8                                 iny
   127  59a0 c005                               cpy     #5
   128  59a2 d0f3                               bne     l151_1
   129  59a4 60                                 rts
   130                          
   131                          ;.end
   132                          
   133                          ; ********************************************************************************************
   134                          ;
   135                          ;	Date		Changes
   136                          ;	====		=======
   137                          ;
   138                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/stringmisc.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      stringmisc.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          
    16                          ; The STR$() function takes a number and gives a string with
    17                          ; the characters the output of the number would have given.
    18                          
    19  59a5 20db4c             strd            jsr     chknum                          ; arg has to be numeric
    20  59a8 a000                               ldy     #0
    21  59aa 209164                             jsr     foutc                           ; do its output
    22  59ad 68                                 pla
    23  59ae 68                                 pla
    24                          
    25  59af a9ff               timstr          lda     #<lofbuf
    26  59b1 a000                               ldy     #>lofbuf
    27  59b3 83d000                             +lbra   strlit
    28                          
    29                          
    30                          ; CHR$() creates a string which contains as its only character the PETSCII
    31                          ; equivalent of the integer argument (#) which must be < 256.
    32                          
    33  59b6 206f5d             chrd            jsr     conint                          ; get integer in range
    34  59b9 da                                 phx
    35  59ba a901                               lda     #1                              ; one-character string
    36  59bc 207b5a                             jsr     strspa                          ; get space for string
    37  59bf a000                               ldy     #0
    38  59c1 68                                 pla
    39                          ; phx   ;set up string bank
    40  59c2 a264                               ldx     #dsctmp+1
    41  59c4 20f022                             jsr     sta_far_ram1                    ; sta (dsctmp+1),y
    42                          ; plx
    43                          
    44  59c7 68                 chrd1           pla                                     ; get rid of "chknum" return address
    45  59c8 68                                 pla
    46  59c9 830501                             +lbra   putnew                          ; setup FAC to point to desc
    47                          
    48                          
    49                          ; The following is the LEFT$($,#) function.  It takes the leftmost # characters
    50                          ; of the string.  If # > len of the string, it returns the whole string.
    51                          
    52  59cc 203e5a             leftd           jsr     pream                           ; test parameters
    53  59cf 48                                 pha                                     ; # arg
    54  59d0 20a122                             jsr     inddpt                          ; string len
    55  59d3 8578                               sta     syntmp
    56  59d5 68                                 pla
    57  59d6 c578                               cmp     syntmp
    58  59d8 98                                 tya                                     ; that's all there is to LEFT$
    59                          
    60  59d9 9005               rleft           bcc     l152_1
    61  59db 20a122                             jsr     inddpt
    62  59de aa                                 tax                                     ; put length into x
    63  59df 98                                 tya                                     ; zero (a), the offset
    64  59e0 48                 l152_1          pha                                     ; save offset
    65  59e1 8a                 rleft2          txa
    66  59e2 48                 rleft3          pha                                     ; save length
    67  59e3 207b5a                             jsr     strspa                          ; get space
    68  59e6 a552                               lda     dscpnt
    69  59e8 a453                               ldy     dscpnt+1
    70  59ea 20715b                             jsr     fretmp
    71  59ed 7a                                 ply
    72  59ee 68                                 pla
    73  59ef 18                                 clc
    74  59f0 6524                               adc     index                           ; compute where to copy
    75  59f2 8524                               sta     index
    76  59f4 9002                               bcc     l153_1
    77  59f6 e625                               inc     index+1
    78  59f8 98                 l153_1          tya
    79  59f9 204a5b                             jsr     movdo                           ; go move it
    80  59fc 83d200                             +lbra   putnew
    81                          
    82                          
    83                          
    84  59ff 203e5a             rightd          jsr     pream
    85  5a02 48                                 pha
    86  5a03 20a122                             jsr     inddpt
    87  5a06 8578                               sta     syntmp
    88  5a08 68                                 pla
    89  5a09 18                                 clc                                     ; (length des'd)-(length)-1
    90  5a0a e578                               sbc     syntmp
    91  5a0c 49ff                               eor     #$ff                            ; negate
    92  5a0e 80c9                               bra     rleft
    93                          
    94                          
    95                          ; MID$($,#) returns string with chars from # position onward. If # > LEN($)
    96                          ; then return null string.  MID($,#,#) returns string with characters from
    97                          ; # position for #2 characters.  If #2 goes past end of string return as much
    98                          ; as possible.
    99                          
   100  5a10 a9ff               midd            lda     #255                            ; default
   101  5a12 8567                               sta     faclo                           ; save for later compare
   102  5a14 208522                             jsr     chrgot                          ; get current character
   103  5a17 c929                               cmp     #')'                            ; is it a right paren )?
   104  5a19 f003                               beq     l154_1                          ; no third paren.
   105                          ; jsr chkcom  ;must have comma
   106                          ; jsr getbyt  ;get the length into "faclo"
   107  5a1b 20825d                             jsr     combyt                          ; [910820]
   108                          
   109  5a1e 203e5a             l154_1          jsr     pream                           ; check it out
   110  5a21 f3dbf7                             +lbeq   fcerr                           ; illegal qty error
   111  5a24 ca                                 dex                                     ; compute offset
   112  5a25 da                                 phx
   113  5a26 da                                 phx                                     ; preserve a while (2 copies)
   114  5a27 a200                               ldx     #0
   115  5a29 20a122                             jsr     inddpt                          ; get length of what's left
   116  5a2c 8578                               sta     syntmp
   117  5a2e 68                                 pla
   118  5a2f 18                                 clc
   119  5a30 e578                               sbc     syntmp
   120  5a32 b0ad                               bcs     rleft2                          ; give null string
   121  5a34 49ff                               eor     #$ff                            ; in sub c was 0 so just complement
   122  5a36 c567                               cmp     faclo                           ; greater than what's desired
   123  5a38 90a8                               bcc     rleft3                          ; no, just copy that much
   124  5a3a a567                               lda     faclo                           ; get length of what's desired
   125  5a3c b0a4                               bcs     rleft3                          ; copy it
   126                          
   127                          
   128                          
   129                          
   130                          ; Common routine used by RIGHT$, LEFT$, MID$, for parameter chk and setup.
   131                          
   132  5a3e 20554e             pream           jsr     chkcls                          ; param list should end
   133  5a41 7a                                 ply
   134  5a42 68                                 pla
   135  5a43 8557                               sta     jmper+1                         ; get return address
   136  5a45 68                                 pla                                     ; get rid of fingo's jsr ret addr
   137  5a46 68                                 pla
   138  5a47 fa                                 plx                                     ; get length
   139  5a48 68                                 pla
   140  5a49 8552                               sta     dscpnt
   141  5a4b 68                                 pla
   142  5a4c 8553                               sta     dscpnt+1
   143  5a4e a557                               lda     jmper+1
   144  5a50 48                                 pha
   145  5a51 5a                                 phy
   146  5a52 a000                               ldy     #0
   147  5a54 8a                                 txa
   148  5a55 60                                 rts
   149                          
   150                          
   151                          
   152                          ; The function LEN$() returns the length of the string passed as an argument.
   153                          
   154  5a56 630400             len             bsr     len1
   155  5a59 8377fe                             +lbra   sngflt
   156                          
   157  5a5c 206a5b             len1            jsr     frestr                          ; free up string
   158  5a5f a200                               ldx     #0
   159  5a61 860f                               stx     valtyp                          ; force numeric
   160  5a63 a8                                 tay                                     ; set condition codes
   161  5a64 60                                 rts                                     ; done
   162                          
   163                          
   164                          
   165                          
   166                          
   167                          ; The following is the ASC$() function.  It returns an integer which is the
   168                          ; decimal equivalent of the PETSCII string argument.
   169                          
   170  5a65 205c5a             asc             jsr     len1
   171  5a68 f006                               beq     l155_1                          ; it was null (zero length)
   172  5a6a a000                               ldy     #0
   173  5a6c 20d522                             jsr     indin1_ram1                     ; get 1st character
   174  5a6f a8                                 tay
   175  5a70 8360fe             l155_1          +lbra   sngflt
   176                          
   177                          ;.end
   178                          
   179                          
   180                          
   181                          
   182                          
   183                          ; STRINI gets string space for the creation of a string and creates
   184                          ; a descriptor for it in DSCTMP.
   185                          
   186                          strini
   187  5a73 a666                               ldx     facmo                           ; get facmo to store in dscpnt
   188  5a75 a467                               ldy     facmo+1
   189  5a77 8652                               stx     dscpnt                          ; retain the descriptor pointer
   190  5a79 8453                               sty     dscpnt+1
   191                          
   192  5a7b 20dd5b             strspa          jsr     getspa                          ; get string space
   193  5a7e 8664                               stx     dsctmp+1                        ; save location
   194  5a80 8465                               sty     dsctmp+2
   195  5a82 8563                               sta     dsctmp                          ; save length
   196  5a84 60                                 rts                                     ; done
   197                          
   198                          
   199                          ; STRLT2 takes the string literal whose first character is pointed to by
   200                          ; (xreg)+1 and builds a descriptor for it.  The descriptor is initially
   201                          ; built in DSCTMP, but PUTNEW transfers it into a temporary and leaves a
   202                          ; pointer to the temporary in FACMO & FACLO.  The characters other than the
   203                          ; zero that terminates the string should be set up in CHARAC and ENDCHR.
   204                          ; If the terminator is a quote, the quote is skipped over.  Leading quotes
   205                          ; should be skipped before call.  On return, the character after the string
   206                          ; literal is pointed to by (strng2).
   207                          
   208                          
   209  5a85 a222               strlit          ldx     #'"'                            ; assume string ends on quote
   210  5a87 860a                               stx     charac
   211  5a89 860b                               stx     endchr
   212                          
   213  5a8b 8570               strlt2          sta     strng1                          ; save pointer to string
   214  5a8d 8471                               sty     strng1+1
   215  5a8f 8564                               sta     dsctmp+1                        ; in case no strcpy
   216  5a91 8465                               sty     dsctmp+2
   217                          
   218  5a93 a0ff                               ldy     #255                            ; initialize character count
   219  5a95 c8                 strget          iny
   220  5a96 20b122                             jsr     indst1                          ; get character
   221  5a99 f00c                               beq     l156_2                          ; if zero
   222  5a9b c50a                               cmp     charac                          ; this terminator?
   223  5a9d f004                               beq     l156_1                          ; yes
   224  5a9f c50b                               cmp     endchr
   225  5aa1 d0f2                               bne     strget                          ; look further
   226                          
   227  5aa3 c922               l156_1          cmp     #'"'                            ; strfin.  quote?
   228  5aa5 f001                               beq     l156_3
   229                          
   230  5aa7 18                 l156_2          clc
   231  5aa8 8463               l156_3          sty     dsctmp                          ; no, back up. retain count
   232  5aaa 98                                 tya
   233  5aab 6570                               adc     strng1                          ; wishing to set (txtptr)
   234  5aad 8572                               sta     strng2
   235  5aaf a671                               ldx     strng1+1
   236  5ab1 9001                               bcc     l156_4
   237  5ab3 e8                                 inx
   238  5ab4 8673               l156_4          stx     strng2+1
   239  5ab6 98                                 tya
   240                          
   241                          
   242                          strlit_1                                                ; //// entry from SPRSAV
   243  5ab7 20735a                             jsr     strini
   244  5aba a8                                 tay
   245  5abb f013                               beq     putnew                          ; length=0, don't bother copying
   246  5abd 48                                 pha                                     ; save length
   247  5abe da                                 phx
   248  5abf a237                               ldx     #frespc
   249  5ac1 88                 l157_1          dey
   250  5ac2 20b122                             jsr     indst1                          ; lda (strng1),y in bank 0
   251  5ac5 20f022                             jsr     sta_far_ram1                    ; sta (frespc),y in bank 1
   252  5ac8 98                                 tya
   253  5ac9 d0f6                               bne     l157_1
   254  5acb fa                                 plx
   255  5acc 68                                 pla                                     ; restore length
   256  5acd 205d5b                             jsr     mvdone                          ; finish up by updating frespc
   257                          
   258                          
   259                          ; Some string function is returning a result in DSCTMP.  Set up a temp
   260                          ; descriptor with DSCTMP in it.  Put a pointer to the descriptor in FACMO&LO
   261                          ; and flag the result as a string type.
   262                          
   263  5ad0 a618               putnew          ldx     temppt                          ; pointer to first free temp
   264  5ad2 e024                               cpx     #tempst+strsiz+strsiz+strsiz
   265  5ad4 f314f2                             +lbeq   sterr                           ; string temporary error
   266                          
   267  5ad7 a563                               lda     dsctmp                          ; length
   268  5ad9 9500                               sta     0,x
   269  5adb a564                               lda     dsctmp+1                        ; pointer to string lo
   270  5add 9501                               sta     1,x
   271  5adf a565                               lda     dsctmp+2                        ; hi
   272  5ae1 9502                               sta     2,x
   273                          
   274  5ae3 a000                               ldy     #0                              ; pointer to temp. descriptor
   275  5ae5 8666                               stx     facmo                           ; lo
   276  5ae7 8467                               sty     facmo+1                         ; hi
   277  5ae9 8471                               sty     facov
   278  5aeb 88                                 dey                                     ; ($ff)
   279  5aec 840f                               sty     valtyp                          ; type is string
   280  5aee 8619                               stx     lastpt                          ; set pointer to last-used temp
   281                          
   282  5af0 e8                                 inx
   283  5af1 e8                                 inx
   284  5af2 e8                                 inx                                     ; point further
   285  5af3 8618                               stx     temppt                          ; save pointer to next temp, if any
   286  5af5 60                                 rts                                     ; all done
   287                          
   288                          
   289                          ; The following routine concatenates two strings.  At this point, the FAC
   290                          ; contains the first one and (txtptr) points to the + sign.
   291                          
   292  5af6 a567               cat             lda     faclo                           ; push high order onto stack
   293  5af8 48                                 pha
   294  5af9 a566                               lda     facmo                           ; and the low
   295  5afb 48                                 pha
   296  5afc 20e24d                             jsr     eval                            ; can come back here since operator is known
   297  5aff 20dd4c                             jsr     chkstr                          ; must be string
   298  5b02 68                                 pla
   299  5b03 8570                               sta     strng1                          ; get high order of old descriptor
   300  5b05 68                                 pla
   301  5b06 8571                               sta     strng1+1
   302  5b08 a000                               ldy     #0
   303  5b0a 20b522                             jsr     indst1_ram1                     ; get length of old string
   304  5b0d 8578                               sta     syntmp
   305  5b0f 20a922                             jsr     indfmo
   306  5b12 18                                 clc
   307  5b13 6578                               adc     syntmp
   308  5b15 b3591b                             +lbcs   errlen                          ; result >255, error "long string"
   309                          
   310  5b18 20735a                             jsr     strini                          ; sizeok.  initialize string
   311  5b1b 20355b                             jsr     movins                          ; move it
   312  5b1e a552                               lda     dscpnt                          ; get pointer to second
   313  5b20 a453                               ldy     dscpnt+1
   314  5b22 20715b                             jsr     fretmp                          ; free it
   315  5b25 204a5b                             jsr     movdo                           ; move second string
   316  5b28 a570                               lda     strng1
   317  5b2a a471                               ldy     strng1+1
   318  5b2c 20715b                             jsr     fretmp
   319  5b2f 20d05a                             jsr     putnew
   320  5b32 83cef1                             +lbra   tstop                           ; "cat" reenters frmevl from tstop
   321                          
   322                          
   323  5b35 a000               movins          ldy     #0                              ; get address of string
   324  5b37 20b522                             jsr     indst1_ram1
   325  5b3a 48                                 pha
   326  5b3b c8                                 iny
   327  5b3c 20b522                             jsr     indst1_ram1
   328  5b3f aa                                 tax
   329  5b40 c8                                 iny
   330  5b41 20b522                             jsr     indst1_ram1
   331  5b44 a8                                 tay
   332  5b45 68                                 pla
   333                          
   334  5b46 8624               movstr          stx     index                           ; adr in (x,y), len in a
   335  5b48 8425                               sty     index+1
   336                          
   337  5b4a a8                 movdo           tay
   338  5b4b f010                               beq     mvdone
   339                          
   340  5b4d 48                                 pha
   341  5b4e da                                 phx
   342  5b4f a237                               ldx     #frespc
   343  5b51 88                 l158_1          dey
   344  5b52 20d522                             jsr     indin1_ram1
   345  5b55 20f022                             jsr     sta_far_ram1                    ; sta (frespc),y
   346  5b58 98                                 tya
   347  5b59 d0f6                               bne     l158_1
   348  5b5b fa                                 plx
   349  5b5c 68                                 pla
   350                          
   351  5b5d 18                 mvdone          clc                                     ; update frespc pointer
   352  5b5e 6537                               adc     frespc
   353  5b60 8537                               sta     frespc
   354  5b62 9002                               bcc     l159_1
   355  5b64 e638                               inc     frespc+1
   356  5b66 60                 l159_1          rts
   357                          
   358                          
   359                          
   360                          ; ********************************************************************************************
   361                          ;
   362                          ;	Date		Changes
   363                          ;	====		=======
   364                          ;
   365                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: string/manager.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      manager.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; FRETMP is passed a string descriptor pntr in (a,y).  A check is made to see
    13                          ; if the string descriptor points to the last temporary descriptor allocated by
    14                          ; putnew.  If so, the temporary is freed up by the updating of (temppt).  If a
    15                          ; string is freed up, a further check sees if it was the last one created and if
    16                          ; so, (fretop) is updated to reflect the fact that the space is no longer in use.
    17                          ; The address of the actual string is returned in (x,y) and its length in (a).
    18                          
    19  5b67 20ef4c             frmstr          jsr     frmevl
    20                          
    21  5b6a 20dd4c             frestr          jsr     chkstr                          ; make sure it's a string
    22  5b6d a566               frefac          lda     facmo                           ; free up string pointed to by FAC
    23  5b6f a467                               ldy     facmo+1
    24  5b71 8524               fretmp          sta     index                           ; get length for later
    25  5b73 8425                               sty     index+1
    26  5b75 20cc5b                             jsr     fretms                          ; check desc. if last
    27  5b78 d03c                               bne     l160_3                          ; one then scratch it
    28  5b7a 206737                             jsr     stradj                          ; index points to link
    29  5b7d 9037                               bcc     l160_3                          ; literal no fix
    30                          
    31  5b7f da                                 phx                                     ; .x=length
    32  5b80 88                                 dey                                     ; .y=1
    33  5b81 a224                               ldx     #index
    34  5b83 a9ff                               lda     #$ff                            ; flag string as garbage
    35  5b85 20f022                             jsr     sta_far_ram1                    ; sta (index),y
    36  5b88 68                                 pla
    37  5b89 48                                 pha                                     ; get length, but leave copy on stack
    38  5b8a 88                                 dey
    39  5b8b a224                               ldx     #index
    40  5b8d 20f022                             jsr     sta_far_ram1 ;sta (index),y     ; put in length
    41                          
    42  5b90 49ff                               eor     #$ff                            ; put index back
    43  5b92 38                                 sec                                     ; to first byte
    44  5b93 6524                               adc     index
    45  5b95 a425                               ldy     index+1
    46  5b97 b001                               bcs     l160_1
    47  5b99 88                                 dey
    48  5b9a 8524               l160_1          sta     index
    49  5b9c 8425                               sty     index+1
    50                          
    51  5b9e aa                                 tax                                     ; lo into x
    52  5b9f 68                                 pla                                     ; pull length from stack
    53  5ba0 c436                               cpy     fretop+1                        ; = to fretop?
    54  5ba2 d038                               bne     frerts
    55  5ba4 e435                               cpx     fretop
    56  5ba6 d034                               bne     frerts
    57                          
    58                          
    59                          ; The string was the last one put into string space.  Save garbage
    60                          ; collection some time by freeing up. (length + 2)
    61                          
    62  5ba8 48                                 pha                                     ; save length on stack
    63  5ba9 38                                 sec                                     ; plus one
    64  5baa 6535                               adc     fretop
    65  5bac 8535                               sta     fretop
    66  5bae 9002                               bcc     l160_2
    67  5bb0 e636                               inc     fretop+1
    68  5bb2 e335               l160_2          inw     fretop                          ; + one more
    69  5bb4 68                                 pla                                     ; pull length off stack
    70  5bb5 60                                 rts
    71                          
    72                          
    73  5bb6 a000               l160_3          ldy     #0                              ; set up x,y,a and index
    74  5bb8 20d522                             jsr     indin1_ram1                     ; length
    75  5bbb 48                                 pha                                     ; on stack
    76  5bbc c8                                 iny
    77  5bbd 20d522                             jsr     indin1_ram1                     ; pointer lo
    78  5bc0 aa                                 tax
    79  5bc1 c8                                 iny
    80  5bc2 20d522                             jsr     indin1_ram1                     ; pointer hi
    81  5bc5 a8                                 tay
    82  5bc6 8624                               stx     index
    83  5bc8 8425                               sty     index+1
    84  5bca 68                                 pla                                     ; get back length
    85  5bcb 60                                 rts
    86                          
    87                          
    88                          
    89  5bcc c41a               fretms          cpy     lastpt+1                        ; last entry to temp?
    90  5bce d00c                               bne     frerts
    91  5bd0 c519                               cmp     lastpt
    92  5bd2 d008                               bne     frerts
    93  5bd4 8518                               sta     temppt
    94  5bd6 e903                               sbc     #strsiz                         ; point to lst one
    95  5bd8 8519                               sta     lastpt                          ; update temp pointer
    96  5bda a000                               ldy     #0                              ; also clears zflg so we do rest of fretmp
    97  5bdc 60                 frerts          rts                                     ; all done
    98                          
    99                          ;.end
   100                          
   101                          ; ********************************************************************************************
   102                          ;
   103                          ;	Date		Changes
   104                          ;	====		=======
   105                          ;
   106                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: string/garbage.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      garbage.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;  Get space for a string, perhaps forcing garbage collection.
    16                          ;
    17                          ;  Entry:  a = # of chars
    18                          ;  Exit:   (x,y) pointer to space, otherwise
    19                          ;          blows off to 'out of string space' error
    20                          ;          (also preserves .a and sets frespc= y,x = -> at space.)
    21                          
    22                          
    23  5bdd 4611               getspa          lsr     garbfl                          ; signal no garbage collection yet
    24                          
    25  5bdf aa                 tryag2          tax                                     ; save in x also
    26  5be0 f042                               beq     getrts                          ; length of 0 no go...
    27  5be2 48                                 pha                                     ; save a (length) on stack
    28  5be3 a535                               lda     fretop                          ; lo byte
    29  5be5 38                                 sec                                     ; for subtract
    30  5be6 e902                               sbc     #2                              ; minus 2 (link bytes)
    31  5be8 a436                               ldy     fretop+1
    32  5bea b001                               bcs     l161_1
    33  5bec 88                                 dey
    34  5bed 8524               l161_1          sta     index1                          ; save for later
    35  5bef 8425                               sty     index1+1
    36  5bf1 8a                                 txa
    37  5bf2 49ff                               eor     #$ff
    38  5bf4 38                                 sec
    39  5bf5 6524                               adc     index1
    40  5bf7 b001                               bcs     l161_2
    41  5bf9 88                                 dey
    42  5bfa c434               l161_2          cpy     strend+1
    43  5bfc 9027                               bcc     garbag
    44  5bfe d004                               bne     strfre
    45  5c00 c533                               cmp     strend
    46  5c02 9021                               bcc     garbag                          ; clean up
    47                          
    48                          
    49  5c04 8537               strfre          sta     frespc
    50  5c06 8438                               sty     frespc+1
    51  5c08 a001                               ldy     #1                              ; flag string as garbage
    52  5c0a a9ff                               lda     #$ff
    53  5c0c da                                 phx                                     ; set up string bank
    54  5c0d a224                               ldx     #index1
    55  5c0f 20f022                             jsr     sta_far_ram1 ;sta (index1),y    ; flag
    56  5c12 fa                                 plx
    57  5c13 88                                 dey
    58  5c14 68                                 pla                                     ; length
    59  5c15 da                                 phx                                     ; set up string bank
    60  5c16 a224                               ldx     #index1
    61  5c18 20f022                             jsr     sta_far_ram1 ;sta (index1),y    ; length
    62  5c1b fa                                 plx
    63  5c1c a637                               ldx     frespc
    64  5c1e a438                               ldy     frespc+1
    65  5c20 8635                               stx     fretop
    66  5c22 8436                               sty     fretop+1                        ; save new (fretop)
    67  5c24 60                 getrts          rts
    68                          
    69                          
    70  5c25 a511               garbag          lda     garbfl
    71  5c27 3318d2                             +lbmi   omerr                           ; if out of memory
    72  5c2a 20335c                             jsr     garba2
    73  5c2d 38                                 sec
    74  5c2e 6611                               ror     garbfl
    75  5c30 68                                 pla                                     ; get back string length
    76  5c31 80ac                               bra     tryag2                          ; always branches
    77                          
    78                          
    79                          
    80                          ; Routine looks for and squashes out any unused string space it finds, thus
    81                          ; returning the space for future use by the string routines.  GARBA2 is called
    82                          ; only when BASIC needs space or the FRE() function is used.
    83                          
    84                          
    85  5c33 a618               garba2          ldx     temppt                          ; ptr to temp. strings
    86  5c35 e01b               l162_1          cpx     #tempst                         ; any out there?
    87  5c37 f016                               beq     l162_2                          ; none
    88  5c39 20505d                             jsr     slr1                            ; setup ptr (tempf2) to temp. string's bkptr
    89  5c3c f0f7                               beq     l162_1                          ; (skip if null string!)
    90  5c3e 8a                                 txa                                     ; .x = lsb of ptr to descriptor
    91  5c3f da                                 phx                                     ; set up string bank
    92  5c40 a25e                               ldx     #tempf2
    93  5c42 a000                               ldy     #0
    94  5c44 20f022                             jsr     sta_far_ram1 ;(tempf2),y        ; place backpointer on string to temp. descr
    95  5c47 98                                 tya                                     ; .a = msb of ptr (0)
    96  5c48 c8                                 iny
    97  5c49 20f022                             jsr     sta_far_ram1                    ; (tempf2),y
    98  5c4c fa                                 plx
    99  5c4d 80e6                               bra     l162_1                          ; always
   100                          
   101                          
   102  5c4f a000               l162_2          ldy     #0                              ; set up flag
   103  5c51 845a                               sty     highds
   104  5c53 a639                               ldx     max_mem_1
   105  5c55 a43a                               ldy     max_mem_1+1
   106  5c57 8661                               stx     grbtop                          ; set both pointers
   107  5c59 8650                               stx     grbpnt
   108  5c5b 8637                               stx     frespc
   109  5c5d 8462                               sty     grbtop+1
   110  5c5f 8451                               sty     grbpnt+1
   111  5c61 8438                               sty     frespc+1
   112  5c63 8a                                 txa
   113                          
   114                          
   115                          ; do while (grbpnt <= fretop)
   116                          
   117  5c64 20de5c             gloop           jsr     chkgrb                          ; check garbage string
   118  5c67 d00c                               bne     l163_2                          ; if not garbage
   119                          
   120  5c69 88                 l163_1          dey                                     ; back up to length
   121  5c6a 20b922                             jsr     indgrb
   122  5c6d 20325d                             jsr     movpnt                          ; move grbpnt to next
   123  5c70 38                                 sec
   124  5c71 665a                               ror     highds                          ; indicate garbage string found
   125  5c73 80ef                               bra     gloop                           ; always
   126                          
   127  5c75 245a               l163_2          bit     highds
   128  5c77 1052                               bpl     l163_6                          ; if garbage string not found
   129  5c79 a200                               ldx     #0
   130  5c7b 865a                               stx     highds                          ; clear indicator
   131                          
   132  5c7d a902                               lda     #2                              ; skip pointers past
   133                          
   134                          ; Move a string over garbage
   135                          
   136  5c7f da                 l163_3          phx
   137  5c80 a261                               ldx     #grbtop
   138  5c82 a001                               ldy     #1                              ; move the link bytes
   139  5c84 20b922                             jsr     indgrb
   140  5c87 20f022                             jsr     sta_far_ram1                    ; sta (grbtop),y
   141  5c8a 88                                 dey
   142  5c8b 20b922                             jsr     indgrb
   143  5c8e 20f022                             jsr     sta_far_ram1                    ; sta (grbtop),y
   144  5c91 fa                                 plx
   145                          
   146  5c92 20d522                             jsr     indin1_ram1
   147  5c95 aa                                 tax
   148  5c96 20415d                             jsr     movtop                          ; move top pointer
   149  5c99 8537                               sta     frespc                          ; save in frespc
   150  5c9b 8438                               sty     frespc+1
   151  5c9d 8a                                 txa
   152  5c9e 20325d                             jsr     movpnt                          ; move grbpnt
   153  5ca1 8a                                 txa                                     ; put length-1 in .y
   154  5ca2 a8                                 tay
   155                          
   156  5ca3 88                 l163_4          dey
   157  5ca4 20b922                             jsr     indgrb
   158  5ca7 da                                 phx
   159  5ca8 a261                               ldx     #grbtop
   160  5caa 20f022                             jsr     sta_far_ram1                    ; sta (grbtop),y
   161  5cad fa                                 plx
   162  5cae ca                                 dex
   163  5caf d0f2                               bne     l163_4
   164                          
   165  5cb1 a002                               ldy     #2                              ; fix the descriptor
   166  5cb3 da                                 phx
   167  5cb4 a224                               ldx     #index1
   168  5cb6 b96000             l163_5          lda     grbtop-1,y
   169  5cb9 20f022                             jsr     sta_far_ram1                    ; sta (index1),y
   170  5cbc 88                                 dey
   171  5cbd d0f7                               bne     l163_5
   172  5cbf fa                                 plx
   173                          
   174  5cc0 a550                               lda     grbpnt                          ; check pointer
   175  5cc2 a451                               ldy     grbpnt+1
   176  5cc4 20de5c                             jsr     chkgrb                          ; check garbage string
   177  5cc7 f0a0                               beq     l163_1                          ; if garbage found
   178  5cc9 d0b4                               bne     l163_3                          ; always
   179                          
   180  5ccb a000               l163_6          ldy     #0                              ; skip over good strings
   181  5ccd 20d522                             jsr     indin1_ram1
   182  5cd0 aa                                 tax
   183  5cd1 20415d                             jsr     movtop
   184  5cd4 8537                               sta     frespc
   185  5cd6 8438                               sty     frespc+1
   186  5cd8 8a                                 txa
   187  5cd9 20325d                             jsr     movpnt
   188  5cdc 8086                               bra     gloop
   189                          
   190                          
   191                          ; ********************************************************************************************
   192                          ;
   193                          ;	Date		Changes
   194                          ;	====		=======
   195                          ;
   196                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: string/garbage/utils.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      utils.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; Subroutines used for garbage collection.
    14                          ;
    15                          ;  Compare for (y,a) = fretop.
    16                          ; Entry  (y,a) = address of current string descriptor.
    17                          ; Exits to caller if (y,a) = fretop, else z flag set if garbage string.
    18                          ;      z flag clear if not garbage string.
    19                          ; In either case pointers are setup for next loop and string movement.
    20                          ; If carry clear (y,a) <= fretop
    21                          
    22                          
    23  5cde c436               chkgrb          cpy     fretop+1                        ; end of strings?
    24  5ce0 9029                               bcc     l164_5
    25  5ce2 d006                               bne     l164_1                          ; if not equal
    26  5ce4 c535                               cmp     fretop
    27  5ce6 f023                               beq     l164_5
    28  5ce8 9021                               bcc     l164_5
    29                          
    30  5cea 245a               l164_1          bit     highds                          ; check flag
    31  5cec 3005                               bmi     l164_2                          ; if empty string found
    32  5cee a902                               lda     #2                              ; skip pointers past
    33  5cf0 20415d                             jsr     movtop                          ; move top pointer
    34                          
    35  5cf3 a902               l164_2          lda     #2                              ; skip pointers past
    36  5cf5 20325d                             jsr     movpnt                          ; move pointers
    37  5cf8 a001                               ldy     #1
    38  5cfa 20b922                             jsr     indgrb                          ; garbage?
    39  5cfd c9ff                               cmp     #$ff
    40  5cff f009                               beq     l164_4                          ; yes
    41                          
    42  5d01 20b922             l164_3          jsr     indgrb                          ; to link bytes
    43  5d04 992400                             sta     index1,y
    44  5d07 88                                 dey
    45  5d08 10f7                               bpl     l164_3                          ; if two bytes not moved
    46  5d0a 60                 l164_4          rts
    47                          
    48                          
    49  5d0b a618               l164_5          ldx     temppt                          ; ptr to temp. strings
    50                          
    51  5d0d e01b               l164_6          cpx     #tempst                         ; any out there?
    52  5d0f f016                               beq     l164_7                          ; no
    53  5d11 20505d                             jsr     slr1                            ; setup ptr (tempf2) to temp. string's bkptr.
    54  5d14 f0f7                               beq     l164_6                          ; (skip if null string!)
    55  5d16 da                                 phx
    56  5d17 a25e                               ldx     #tempf2
    57  5d19 a000                               ldy     #0                              ; .a = string length
    58  5d1b 20f022                             jsr     sta_far_ram1 ;sta (tempf2),y    ; remove backpointer built at garba2
    59  5d1e c8                                 iny
    60  5d1f a9ff                               lda     #$ff
    61  5d21 20f022                             jsr     sta_far_ram1 ;sta (tempf2),y    ; and mark as garbage
    62  5d24 fa                                 plx
    63  5d25 80e6                               bra     l164_6                          ; always
    64                          
    65  5d27 68                 l164_7          pla                                     ; throw away return address
    66  5d28 68                                 pla
    67  5d29 a537                               lda     frespc                          ; fix fretop and frespc
    68  5d2b a438                               ldy     frespc+1
    69  5d2d 8535                               sta     fretop
    70  5d2f 8436                               sty     fretop+1
    71  5d31 60                                 rts
    72                          
    73                          
    74  5d32 49ff               movpnt          eor     #$ff                            ; comp and add
    75  5d34 38                                 sec
    76  5d35 6550                               adc     grbpnt
    77  5d37 a451                               ldy     grbpnt+1
    78  5d39 b001                               bcs     l165_1
    79  5d3b 88                                 dey
    80  5d3c 8550               l165_1          sta     grbpnt
    81  5d3e 8451                               sty     grbpnt+1
    82  5d40 60                                 rts
    83                          
    84                          
    85                          
    86  5d41 49ff               movtop          eor     #$ff                            ; comp and add
    87  5d43 38                                 sec
    88  5d44 6561                               adc     grbtop
    89  5d46 a462                               ldy     grbtop+1
    90  5d48 b001                               bcs     l166_1
    91  5d4a 88                                 dey
    92  5d4b 8561               l166_1          sta     grbtop
    93  5d4d 8462                               sty     grbtop+1
    94  5d4f 60                                 rts
    95                          
    96                          
    97                          
    98  5d50 ca                 slr1            dex                                     ; .x = ptr to temp. string descriptor
    99  5d51 b500                               lda     0,x                             ; msb of ptr to string
   100  5d53 855f                               sta     tempf2+1
   101  5d55 ca                                 dex
   102  5d56 b500                               lda     0,x                             ; lsb of ptr to string
   103  5d58 855e                               sta     tempf2
   104  5d5a ca                                 dex
   105  5d5b b500                               lda     0,x                             ; string length
   106  5d5d 48                                 pha                                     ; save for later test
   107  5d5e 18                                 clc
   108  5d5f 655e                               adc     tempf2                          ; want ptr to string's backpointer
   109  5d61 855e                               sta     tempf2
   110  5d63 9002                               bcc     l167_1
   111  5d65 e65f                               inc     tempf2+1
   112  5d67 68                 l167_1          pla     ;.a=len & set z flag            ; .x=next desc. ptr
   113  5d68 60                                 rts
   114                          
   115                          ;.end
   116                          
   117                          ; ********************************************************************************************
   118                          ;
   119                          ;	Date		Changes
   120                          ;	====		=======
   121                          ;
   122                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/parameters.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      parameters.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15  5d69 208322             gtbytc          jsr     chrget
    16                          
    17  5d6c 20d84c             getbyt          jsr     frmnum                          ; read formula into FAC
    18                          
    19  5d6f 20ad58             conint          jsr     posint                          ; convert the FAC to a single byte int
    20  5d72 a666                               ldx     facmo
    21  5d74 d388f4                             +lbne   fcerr                           ; result must be <= 255
    22  5d77 a667                               ldx     faclo
    23  5d79 4c8522                             jmp     chrgot                          ; set condition codes on terminator
    24                          
    25                          
    26                          getnum                                                  ; get 2-byte value in y,a: check for a comma, get 1 byte val in x
    27  5d7c 20d84c                             jsr     frmnum                          ; get address
    28  5d7f 208d5d                             jsr     getadr                          ; get that location
    29                          
    30                          combyt                                                  ; check for a comma, get a 1 byte value in x
    31  5d82 205b4e                             jsr     chkcom                          ; check for comma
    32  5d85 80e5                               bra     getbyt                          ; get something to store and return
    33                          
    34                          
    35  5d87 205b4e             comwrd          jsr     chkcom
    36                          
    37  5d8a 20d84c             getwrd          jsr     frmnum                          ; get an unsigned 2-byte value in y,a
    38                          
    39  5d8d a568               getadr          lda     facsgn                          ; for this entry, value can't be < 0
    40  5d8f 336df4                             +lbmi   fcerr                           ; function call error
    41                          
    42                          getsad                                                  ; get a signed 2-byte value in (y,a), ///entry from sprcor
    43  5d92 a563                               lda     facexp                          ; examine exponent
    44  5d94 c991                               cmp     #145
    45  5d96 b366f4                             +lbcs   fcerr                           ; function call error
    46  5d99 203063                             jsr     qint                            ; integerize it
    47  5d9c a566                               lda     facmo
    48  5d9e a467                               ldy     facmo+1
    49  5da0 8416                               sty     poker
    50  5da2 8517                               sta     poker+1
    51  5da4 60                                 rts                                     ; it's all done
    52                          
    53                          ;.end
    54                          
    55                          ; ********************************************************************************************
    56                          ;
    57                          ;	Date		Changes
    58                          ;	====		=======
    59                          ;
    60                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/addsub.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      addsub.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Floating Point Math Package configuration:
    16                          ;
    17                          ; Throughout the math package the floating point format is as follows:
    18                          ;
    19                          ; the sign of the first bit of the mantissa.
    20                          ; the mantissa is 24 bits long.
    21                          ; the binary point is to the left of the msb.
    22                          ; number = mantissa * 2 ~ exponent.
    23                          ; the mantissa is positive with a 1 assumed to be where the sign bit is.
    24                          ; the sign of the exponent is the first bit of the exponent.
    25                          ; the exponent is stored in excess $80, i.e., with a bias of +$80.
    26                          ; so, the exponent is a signed 8 bit number with $80 added to it.
    27                          ; an exponent of zero means the number is zero.
    28                          ; the other bytes may not be assumed to be zero.
    29                          ; to keep the same number in the fac while shifting,
    30                          ; to shift right, exp:=exp+1.
    31                          ; to shift left,  exp:=exp-1.
    32                          ;
    33                          ; In memory the number looks like this:
    34                          ; the exponent as a signed number +$80.
    35                          ; the sign bit in 7, bits 2-8 of mantissa are bits 6-0.
    36                          ;  remember bit 1 of mantissa is always a one.
    37                          ; bits 9-16 of the mantissa.
    38                          ; bits 17-24 of the mantisa.
    39                          ;
    40                          ; Arithmetic routine calling conventions:
    41                          ;
    42                          ;   For one-argument functions:
    43                          ; the argument is in the fac.
    44                          ; the result is left in the fac.
    45                          ;   For two-argument operations:
    46                          ; the first argument is in arg (argexp,ho,mo,lo and argsgn).
    47                          ;       the second argument is in the fac.
    48                          ; the result is left in the fac.
    49                          ;
    50                          ; The "t" entry points to the two argument operations have both arguments setup
    51                          ; in the respective registers. Before calling arg may have been popped off the
    52                          ; stack and into arg, for example. The other entry point assumes (xreg) points
    53                          ; to the argument somewhere in memory. it is unpacked into arg by "conupk".
    54                          ;
    55                          ; On the stack, the sgn is pushed on first, the lo,mo,ho, and finally exp.
    56                          ; Note all things are kept unpacked in arg, fac and on the stack.
    57                          ;
    58                          ; It is only when something is stored away that it is packed to four bytes,
    59                          ; the unpacked format has a sn byte reflecting the sign of the ho turned on.
    60                          ; The exp is the same as stored format. This is done for speed of operation.
    61                          
    62                          
    63  5da5 20f760             fsub            jsr     conupk
    64                          
    65  5da8 a568               fsubt           lda     facsgn
    66  5daa 49ff                               eor     #$ff                            ; complement it
    67  5dac 8568                               sta     facsgn
    68  5dae 456f                               eor     argsgn                          ; complement arisgn
    69  5db0 8570                               sta     arisgn
    70  5db2 a563                               lda     facexp                          ; set codes on facexp
    71  5db4 8008                               bra     faddt                           ; (y)=argexp
    72                          
    73  5db6 20e75e             fadd5           jsr     shiftr                          ; do a long shift
    74  5db9 903b                               bcc     fadd4                           ; continue with addition
    75                          
    76  5dbb 20f760             fadd            jsr     conupk
    77  5dbe f3d304             faddt           +lbeq   movfa                           ; if fac=0, result is in arg
    78  5dc1 a671                               ldx     facov
    79  5dc3 8658                               stx     oldov
    80  5dc5 a26a                               ldx     #argexp                         ; default is shift argument
    81  5dc7 a56a                               lda     argexp                          ; if arg=0, fac is result
    82                          
    83  5dc9 a8                 faddc           tay                                     ; also copy (a) into (y)
    84  5dca f38300                             +lbeq   zerrts                          ; return
    85  5dcd 38                                 sec
    86  5dce e563                               sbc     facexp
    87  5dd0 f024                               beq     fadd4                           ; no shifting
    88  5dd2 9012                               bcc     fadda                           ; branch if argexp < facexp
    89  5dd4 8463                               sty     facexp                          ; resulting exponent
    90  5dd6 a46f                               ldy     argsgn                          ; since arg is bigger, its
    91  5dd8 8468                               sty     facsgn                          ; sign is sign of result
    92  5dda 49ff                               eor     #$ff                            ; shift a negative number of palces
    93  5ddc 6900                               adc     #0                              ; complete negation, w/ c=1
    94  5dde a000                               ldy     #0                              ; zero oldov
    95  5de0 8458                               sty     oldov
    96  5de2 a263                               ldx     #fac                            ; shift the FAC instead
    97  5de4 8004                               bra     fadd1
    98                          
    99  5de6 a000               fadda           ldy     #0
   100  5de8 8471                               sty     facov
   101                          
   102  5dea c9f9               fadd1           cmp     #$f9                            ; for speed and necessity.  gets most likely case to
   103                          ;SHIFTR fastest and allows shifting of neg nums by QUINT
   104  5dec 30c8                               bmi     fadd5                           ; shift big
   105  5dee a8                                 tay
   106  5def a571                               lda     facov                           ; set facov
   107  5df1 5601                               lsr     1,x                             ; gets 0 in the MSB
   108  5df3 20fe5e                             jsr     rolshf                          ; do the rolling
   109                          
   110  5df6 7f7057             fadd4           bbr7    arisgn,fadd2                    ; get resulting sign and if positive, add. carry is clear
   111  5df9 a063                               ldy     #facexp
   112  5dfb e06a                               cpx     #argexp                         ; fac is bigger
   113  5dfd f002                               beq     l168_1
   114  5dff a06a                               ldy     #argexp                         ; arg is bigger
   115                          
   116  5e01 38                 l168_1          sec                                     ; subit.
   117  5e02 49ff                               eor     #$ff
   118  5e04 6558                               adc     oldov
   119  5e06 8571                               sta     facov
   120  5e08 b90400                             lda     4,y
   121  5e0b f504                               sbc     4,x
   122  5e0d 8567                               sta     faclo
   123  5e0f b90300                             lda     3,y
   124  5e12 f503                               sbc     3,x
   125  5e14 8566                               sta     facmo
   126  5e16 b90200                             lda     2,y
   127  5e19 f502                               sbc     2,x
   128  5e1b 8565                               sta     facmoh
   129  5e1d b90100                             lda     1,y
   130  5e20 f501                               sbc     1,x
   131  5e22 8564                               sta     facho
   132                          
   133  5e24 b003               fadflt          bcs     normal                          ; here if signs differ. if carry, FAC is set ok
   134  5e26 20995e                             jsr     negfac                          ; negate (FAC)
   135                          
   136  5e29 a000               normal          ldy     #0
   137  5e2b 98                                 tya
   138  5e2c 18                                 clc
   139                          
   140  5e2d a664               l169_1          ldx     facho
   141  5e2f d049                               bne     norm1
   142  5e31 a665                               ldx     facho+1                         ; shift 8 bits at a time for speed
   143  5e33 8664                               stx     facho
   144  5e35 a666                               ldx     facmoh+1
   145  5e37 8665                               stx     facmoh
   146  5e39 a667                               ldx     facmo+1
   147  5e3b 8666                               stx     facmo
   148  5e3d a671                               ldx     facov
   149  5e3f 8667                               stx     faclo
   150  5e41 8471                               sty     facov
   151  5e43 6908                               adc     #8
   152  5e45 c920                               cmp     #32
   153  5e47 d0e4                               bne     l169_1
   154                          
   155  5e49 a900               zerofc          lda     #0                              ; not needed by NORMAL, but by others
   156  5e4b 8563               zerof1          sta     facexp                          ; number must be zero
   157  5e4d 8568               zeroml          sta     facsgn                          ; make sign positive
   158  5e4f 60                 zerrts          rts                                     ; all done
   159                          
   160                          
   161  5e50 6558               fadd2           adc     oldov
   162  5e52 8571                               sta     facov
   163  5e54 a567                               lda     faclo
   164  5e56 656e                               adc     arglo
   165  5e58 8567                               sta     faclo
   166  5e5a a566                               lda     facmo
   167  5e5c 656d                               adc     argmo
   168  5e5e 8566                               sta     facmo
   169  5e60 a565                               lda     facmoh
   170  5e62 656c                               adc     argmoh
   171  5e64 8565                               sta     facmoh
   172  5e66 a564                               lda     facho
   173  5e68 656b                               adc     argho
   174  5e6a 8564                               sta     facho
   175  5e6c 8019                               bra     squeez                          ; go round if signs same
   176                          
   177                          
   178  5e6e 6901               norm2           adc     #1                              ; decrement shift counter
   179  5e70 0671                               asl     facov                           ; shift all left one bit
   180  5e72 2667                               rol     faclo
   181  5e74 2666                               rol     facmo
   182  5e76 2665                               rol     facmoh
   183  5e78 2664                               rol     facho
   184                          
   185  5e7a 10f2               norm1           bpl     norm2                           ; if msb=0 shift again
   186  5e7c 38                                 sec
   187  5e7d e563                               sbc     facexp
   188  5e7f b0c8                               bcs     zerofc
   189  5e81 49ff                               eor     #$ff
   190  5e83 6901                               adc     #1                              ; complement
   191  5e85 8563                               sta     facexp
   192                          
   193  5e87 900f               squeez          bcc     rndrts                          ; bits to shift?
   194  5e89 e663               rndshf          inc     facexp
   195  5e8b f3bacf                             +lbeq   overr
   196  5e8e 6664                               ror     facho
   197  5e90 6665                               ror     facmoh
   198  5e92 6666                               ror     facmo
   199  5e94 6667                               ror     faclo
   200  5e96 6671                               ror     facov
   201  5e98 60                 rndrts          rts                                     ; all done adding
   202                          
   203                          
   204  5e99 a568               negfac          lda     facsgn
   205  5e9b 49ff                               eor     #$ff                            ; complement FAC entirely
   206  5e9d 8568                               sta     facsgn
   207                          
   208  5e9f a564               negfch          lda     facho
   209  5ea1 49ff                               eor     #$ff                            ; complement just the number
   210  5ea3 8564                               sta     facho
   211  5ea5 a565                               lda     facmoh
   212  5ea7 49ff                               eor     #$ff
   213  5ea9 8565                               sta     facmoh
   214  5eab a566                               lda     facmo
   215  5ead 49ff                               eor     #$ff
   216  5eaf 8566                               sta     facmo
   217  5eb1 a567                               lda     faclo
   218  5eb3 49ff                               eor     #$ff
   219  5eb5 8567                               sta     faclo
   220  5eb7 a571                               lda     facov
   221  5eb9 49ff                               eor     #$ff
   222  5ebb 8571                               sta     facov
   223  5ebd e671                               inc     facov
   224  5ebf d00e                               bne     incfrt
   225                          
   226  5ec1 e667               incfac          inc     faclo
   227  5ec3 d00a                               bne     incfrt
   228  5ec5 e666                               inc     facmo
   229  5ec7 d006                               bne     incfrt                          ; if no carry, return
   230  5ec9 e665                               inc     facmoh
   231  5ecb d002                               bne     incfrt
   232  5ecd e664                               inc     facho                           ; carry complement
   233  5ecf 60                 incfrt          rts
   234                          
   235                          
   236                          ; SHIFTR shifts (x+1:x+3) (-a) bits right.  Shifts bits to start with
   237                          ; if possible.
   238                          
   239  5ed0 a227               mulshf          ldx     #resho-1                        ; entry point for multiplier
   240  5ed2 b404               shftr2          ldy     4,x                             ; shift bits first
   241  5ed4 8471                               sty     facov
   242  5ed6 b403                               ldy     3,x
   243  5ed8 9404                               sty     4,x
   244  5eda b402                               ldy     2,x                             ; get mo
   245  5edc 9403                               sty     3,x                             ; store lo
   246  5ede b401                               ldy     1,x                             ; get ho
   247  5ee0 9402                               sty     2,x                             ; store mo
   248  5ee2 acd702                             ldy     bits
   249  5ee5 9401                               sty     1,x                             ; store ho
   250                          
   251  5ee7 6908               shiftr          adc     #8
   252  5ee9 30e7                               bmi     shftr2
   253  5eeb f0e5                               beq     shftr2
   254  5eed e908                               sbc     #8                              ; c can be either 1,0 and it works!
   255  5eef a8                                 tay
   256  5ef0 a571                               lda     facov
   257  5ef2 b014                               bcs     shftrt                          ; equiv to beq here
   258                          
   259  5ef4 1601               shftr3          asl     1,x
   260  5ef6 9002                               bcc     l170_1
   261  5ef8 f601                               inc     1,x
   262  5efa 7601               l170_1          ror     1,x
   263  5efc 7601                               ror     1,x                             ; yes, two of them
   264                          
   265  5efe 7602               rolshf          ror     2,x
   266  5f00 7603                               ror     3,x
   267  5f02 7604                               ror     4,x                             ; one more time
   268  5f04 6a                                 ror
   269  5f05 c8                                 iny
   270  5f06 d0ec                               bne     shftr3                          ; $$$ (most expensive!!!)
   271                          
   272  5f08 18                 shftrt          clc                                     ; clear output of FACOV
   273  5f09 60                                 rts
   274                          
   275                          ;.end
   276                          
   277                          ; ********************************************************************************************
   278                          ;
   279                          ;	Date		Changes
   280                          ;	====		=======
   281                          ;
   282                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/const.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      const.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Constants used by LOG, EXP, TRIG, and others.
    16                          
    17  5f0a 7f00000000         fr4             !text 127,0,0,0,0                       ; 1/4
    18  5f0f 8080000000         neghlf          !text 128,128,0,0,0                     ; -0.5
    19  5f14 8000000000         fhalf           !text 128,0,0,0,0                       ; 0.5
    20  5f19 8420000000         tenc            !text 132,32,0,0,0                      ; 10.0
    21  5f1e 82490fdaa1         pival           !text 130,73,15,218,161                 ; pi
    22  5f23 81490fdaa2         pi2             !text 129,73,15,218,162                 ; pi/2
    23  5f28 83490fdaa2         twopi           !text 131,73,15,218,162                 ; pi*2
    24                          
    25  5f2d 9b3ebc1ffd         n0999           !text $9b,$3e,$bc,$1f,$fd
    26  5f32 9e6e6b27fd         n9999           !text $9e,$6e,$6b,$27,$fd
    27  5f37 9e6e6b2800         nmil            !text $9e,$6e,$6b,$28,$00
    28                          
    29                          foutbl                                                  ; powers of 10
    30  5f3c fa0a1f00                           !text 250,10,31,0                       ; -100,000,000
    31  5f40 00989680                           !text 0,152,150,128                     ; 10,000,000
    32  5f44 fff0bdc0                           !text 255,240,189,192                   ; -1,000,000
    33  5f48 000186a0                           !text 0,1,134,160                       ; 100,000
    34  5f4c ffffd8f0                           !text 255,255,216,240                   ; -10,000
    35  5f50 000003e8                           !text 0,0,3,232                         ; 1,000
    36  5f54 ffffff9c                           !text 255,255,255,156                   ; -100
    37  5f58 0000000a                           !text 0,0,0,10                          ; 10
    38  5f5c ffffffff                           !text 255,255,255,255                   ; -1
    39                          fdcend
    40                          
    41                          ; .byte @377,@337,@012,@200 ;-2,160,000 for time converter removed [901014]
    42                          ; .byte @000,@003,@113,@300 ;   216,000
    43                          ; .byte @377,@377,@163,@140 ;   -36,000
    44                          ; .byte @000,@000,@016,@020 ;     3,600
    45                          ; .byte @377,@377,@375,@250 ;      -600
    46                          ; .byte @000,@000,@000,@074 ;        60
    47                          ;timend
    48                          
    49  5f60 03                 logcn2          !text 3                                 ; degree-1
    50  5f61 7f5e56cb79                         !text 127,94,86,203,121                 ; 0.43425594188
    51  5f66 80139b0b64                         !text 128,19,155,11,100                 ; 0.57658454134
    52  5f6b 8076389316                         !text 128,118,56,147,22                 ; 0.96180075921
    53  5f70 8238aa3b20                         !text 130,56,170,59,32                  ; 2.8853900728
    54                          
    55  5f75 07                 expcon          !text 7                                 ; degree-1
    56  5f76 7134583e56                         !text 113,52,88,62,86                   ; 0.000021498763697
    57  5f7b 74167eb31b                         !text 116,22,126,179,27                 ; 0.00014352314036
    58  5f80 772feee385                         !text 119,47,238,227,133                ; 0.0013422634824
    59  5f85 7a1d841c2a                         !text 122,29,132,28,42                  ; 0.0096140170199
    60  5f8a 7c6359580a                         !text 124,99,89,88,10                   ; 0.055505126860
    61  5f8f 7e75fde7c6                         !text 126,117,253,231,198               ; 0.24022638462
    62  5f94 8031721810                         !text 128,49,114,24,16                  ; 0.69314718600
    63  5f99 8100000000         fone            !text 129,0,0,0,0                       ; 1.0
    64                          
    65  5f9e 8138aa3b29         logeb2          !text 129,56,170,59,41                  ; log(e) base 2
    66  5fa3 803504f334         sqr05           !text 128,53,4,243,52                   ; 0.707106781 sqr(0.5)
    67  5fa8 813504f334         sqr20           !text 129,53,4,243,52                   ; 1.41421356 sqr(2.0)
    68  5fad 80317217f8         log2            !text 128,49,114,23,248                 ; 0.693147181 ln(2)
    69                          
    70                          
    71  5fb2 05                 sincon          !text 5                                 ; degree-1 trig
    72  5fb3 84e61a2d1b                         !text 132,230,26,45,27
    73  5fb8 862807fbf8                         !text 134,40,7,251,248
    74  5fbd 8799688901                         !text 135,153,104,137,1
    75  5fc2 872335dfe1                         !text 135,35,53,223,225
    76  5fc7 86a55de728                         !text 134,165,93,231,40
    77  5fcc 83490fdaa2                         !text 131,73,15,218,162
    78                          
    79  5fd1 0b                 atncon          !text 11                                ; degree-1
    80  5fd2 76b383bdd3                         !text 118,179,131,189,211
    81  5fd7 791ef4a6f5                         !text 121,30,244,166,245
    82  5fdc 7b83fcb010                         !text 123,131,252,176,16
    83  5fe1 7c0c1f67ca                         !text 124,12,31,103,202
    84  5fe6 7cde53cbc1                         !text 124,222,83,203,193
    85  5feb 7d1464704c                         !text 125,20,100,112,76
    86  5ff0 7db7ea517a                         !text 125,183,234,81,122
    87  5ff5 7d6330887e                         !text 125,99,48,136,126
    88  5ffa 7e9244993a                         !text 126,146,68,153,58
    89  5fff 7e4ccc91c7                         !text 126,76,204,145,199
    90  6004 7faaaaaa13                         !text 127,170,170,170,19
    91  6009 8100000000                         !text 129,0,0,0,0
    92                          
    93                          
    94                          ; ********************************************************************************************
    95                          ;
    96                          ;	Date		Changes
    97                          ;	====		=======
    98                          ;
    99                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/log.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      log.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; Natural Log Function
    14                          ;
    15                          ; Calculation is by   LN(f*2^n) = (n+LOG2(f))*LN(2)
    16                          ; An approximation polynomial is used to calculate LOG2(f).
    17                          
    18                          
    19  600e 20c162             log             jsr     sign                            ; is it positive?
    20  6011 f3ebf1                             +lbeq   fcerr                           ; can't tolerate neg or zero
    21                          
    22  6014 a563                               lda     facexp                          ; get exponent into (a)
    23  6016 e97f                               sbc     #$7f                            ; remove bias (carry is off)
    24  6018 48                                 pha                                     ; save exponent a while
    25  6019 a980                               lda     #$80
    26  601b 8563                               sta     facexp                          ; result is FAC in range (0.5,1)
    27  601d a9a3                               lda     #<sqr05                         ; get pointer to sqr(0.5)
    28  601f a05f                               ldy     #>sqr05
    29  6021 205160                             jsr     romadd
    30  6024 a9a8                               lda     #<sqr20
    31  6026 a05f                               ldy     #>sqr20
    32  6028 205d60                             jsr     romdiv
    33  602b a999                               lda     #<fone
    34  602d a05f                               ldy     #>fone
    35  602f 205760                             jsr     romsub
    36  6032 a960                               lda     #<logcn2
    37  6034 a05f                               ldy     #>logcn2
    38  6036 205a66                             jsr     polyx                           ; evaluate approximation polynomial
    39  6039 a90f                               lda     #<neghlf                        ; add in last constant
    40  603b a05f                               ldy     #>neghlf
    41  603d 205160                             jsr     romadd
    42  6040 68                                 pla                                     ; get exponent back
    43  6041 201464                             jsr     finlog
    44  6044 a9ad                               lda     #<log2                          ; multiply result by ln(2)
    45  6046 a05f                               ldy     #>log2
    46                          
    47                          
    48  6048 20cc60             rommlt          jsr     romupk
    49  604b 8023                               bra     fmultt                          ; multiply together
    50                          
    51                          
    52  604d a914               faddh           lda     #<fhalf
    53  604f a05f                               ldy     #>fhalf
    54                          
    55  6051 20cc60             romadd          jsr     romupk
    56  6054 8368fd                             +lbra   faddt
    57                          
    58                          
    59  6057 20cc60             romsub          jsr     romupk
    60  605a 834cfd                             +lbra   fsubt
    61                          
    62                          
    63  605d 20cc60             romdiv          jsr     romupk
    64  6060 832301                             +lbra   fdivt
    65                          
    66                          
    67                          ; ********************************************************************************************
    68                          ;
    69                          ;	Date		Changes
    70                          ;	====		=======
    71                          ;
    72                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/multiply.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      multiply.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; Multiplication        FAC = ARG*FAC
    14                          
    15                          fmultt_c65                                              ; [910402]
    16  6063 a56f                               lda     argsgn
    17  6065 4568                               eor     facsgn
    18  6067 8570                               sta     arisgn                          ; resultant sign
    19  6069 a663                               ldx     facexp                          ; set signs on thing to multiply
    20  606b 8003                               bra     fmultt                          ; go multiply
    21                          
    22  606d 20f760             fmult           jsr     conupk                          ; unpack the constant into arg for use
    23                          
    24  6070 f059               fmultt          beq     multrt                          ; if FAC=0, return.  FAC is set
    25  6072 202761                             jsr     muldiv                          ; fix up the exponents
    26  6075 a900                               lda     #0                              ; to clear result
    27  6077 8528                               sta     resho
    28  6079 8529                               sta     resmoh
    29  607b 852a                               sta     resmo
    30  607d 852b                               sta     reslo
    31  607f a571                               lda     facov
    32  6081 209e60                             jsr     mltpl1                          ; *** THIS fixes the DBL-0 bug without causing other grief!  C128-04 FAB
    33  6084 a567                               lda     faclo                           ; multiply arg by faclo
    34  6086 209b60                             jsr     mltply
    35  6089 a566                               lda     facmo                           ; multiply arg by facmo
    36  608b 209b60                             jsr     mltply
    37  608e a565                               lda     facmoh
    38  6090 209e60                             jsr     mltpl1                          ; *** THIS fixes the DBL-0 bug without causing other grief!  C128-04 FAB
    39  6093 a564                               lda     facho                           ; multiply arg by facho
    40  6095 209e60                             jsr     mltpl1
    41  6098 836101                             +lbra   movfr                           ; move result into FAC
    42                          
    43                          
    44  609b f333fe             mltply          +lbeq   mulshf                          ; normalize result and return. shift result right 1 byte.  exits with .c=0
    45  609e 4a                 mltpl1          lsr
    46  609f 0980                               ora     #$80                            ; will flag end of shifting
    47                          
    48  60a1 a8                 l171_1          tay
    49  60a2 9019                               bcc     l171_2                          ; if mult bit=0, just shift
    50  60a4 18                                 clc
    51  60a5 a52b                               lda     reslo
    52  60a7 656e                               adc     arglo
    53  60a9 852b                               sta     reslo
    54  60ab a52a                               lda     resmo
    55  60ad 656d                               adc     argmo
    56  60af 852a                               sta     resmo
    57  60b1 a529                               lda     resmoh
    58  60b3 656c                               adc     argmoh
    59  60b5 8529                               sta     resmoh
    60  60b7 a528                               lda     resho
    61  60b9 656b                               adc     argho
    62  60bb 8528                               sta     resho
    63                          
    64  60bd 6628               l171_2          ror     resho
    65  60bf 6629                               ror     resmoh
    66  60c1 662a                               ror     resmo
    67  60c3 662b                               ror     reslo
    68  60c5 6671                               ror     facov                           ; save for rounding
    69  60c7 98                                 tya
    70  60c8 4a                                 lsr                                     ; clear msb so we get a closer to 0
    71  60c9 d0d6                               bne     l171_1                          ; slow as a turtle
    72                          
    73  60cb 60                 multrt          rts
    74                          
    75                          
    76                          
    77                          ; ********************************************************************************************
    78                          ;
    79                          ;	Date		Changes
    80                          ;	====		=======
    81                          ;
    82                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/unpack.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      unpack.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; Unpack a ROM constant into the FAC
    13                          
    14  60cc 8524               romupk          sta     index1
    15  60ce 8425                               sty     index1+1
    16  60d0 a004                               ldy     #4
    17  60d2 b124                               lda     (index1),y                      ; it's in ROM, so ok to use ind
    18  60d4 856e                               sta     arglo
    19  60d6 88                                 dey
    20  60d7 b124                               lda     (index1),y
    21  60d9 856d                               sta     argmo
    22  60db 88                                 dey
    23  60dc b124                               lda     (index1),y
    24  60de 856c                               sta     argmoh
    25  60e0 88                                 dey
    26  60e1 b124                               lda     (index1),y
    27  60e3 856f                               sta     argsgn
    28  60e5 4568                               eor     facsgn
    29  60e7 8570                               sta     arisgn
    30  60e9 a56f                               lda     argsgn
    31  60eb 0980                               ora     #$80
    32  60ed 856b                               sta     argho
    33  60ef 88                                 dey
    34  60f0 b124                               lda     (index1),y
    35  60f2 856a                               sta     argexp
    36  60f4 a563                               lda     facexp                          ; sets code of facexp
    37  60f6 60                                 rts
    38                          
    39                          
    40                          ; Unpack a RAM constant into the FAC
    41                          
    42  60f7 8524               conupk          sta     index1
    43  60f9 8425                               sty     index1+1
    44                          
    45                          ; lda mmu_config_reg
    46                          ; pha   ;preserve caller's memory config????
    47                          
    48  60fb a004                               ldy     #4
    49  60fd 20d522                             jsr     indin1_ram1
    50  6100 856e                               sta     arglo
    51  6102 88                                 dey
    52  6103 20d522                             jsr     indin1_ram1
    53  6106 856d                               sta     argmo
    54  6108 88                                 dey
    55  6109 20d522                             jsr     indin1_ram1
    56  610c 856c                               sta     argmoh
    57  610e 88                                 dey
    58  610f 20d522                             jsr     indin1_ram1
    59  6112 856f                               sta     argsgn
    60  6114 4568                               eor     facsgn
    61  6116 8570                               sta     arisgn
    62  6118 a56f                               lda     argsgn
    63  611a 0980                               ora     #$80
    64  611c 856b                               sta     argho
    65  611e 88                                 dey
    66  611f 20d522                             jsr     indin1_ram1
    67  6122 856a                               sta     argexp
    68                          
    69                          ; pla
    70                          ; sta mmu_config_reg ;restore caller's memory config????
    71                          
    72  6124 a563                               lda     facexp                          ; set codes of facexp
    73  6126 60                                 rts
    74                          
    75                          
    76                          ; Check special cases and add exponents for FMULT, FDIV
    77                          
    78                          muldiv
    79  6127 a56a                               lda     argexp                          ; exp of arg=0?
    80  6129 f01f               mldexp          beq     zeremv                          ; so we get zero exponent
    81  612b 18                                 clc
    82  612c 6563                               adc     facexp                          ; result is in (a)
    83  612e 9005                               bcc     l172_1                          ; find (c) xor (n)
    84  6130 3315cd                             +lbmi   overr                           ; overflow if bits match
    85  6133 18                                 clc
    86  6134 2c                                 !text $2c
    87                          
    88  6135 1013               l172_1          bpl     zeremv                          ; underflow
    89  6137 6980                               adc     #$80                            ; add bias
    90  6139 8563                               sta     facexp
    91  613b f310fd                             +lbeq   zeroml                          ; zero the rest of it
    92  613e a570                               lda     arisgn
    93  6140 8568                               sta     facsgn                          ; arisgn is result's sign
    94  6142 60                                 rts                                     ; done
    95                          
    96                          
    97  6143 a568               mldvex          lda     facsgn                          ; get sign
    98  6145 49ff                               eor     #$ff                            ; complement it
    99  6147 33fecc                             +lbmi   overr
   100                          
   101  614a 68                 zeremv          pla                                     ; get addr off stack
   102  614b 68                                 pla
   103  614c 83fbfc                             +lbra   zerofc                          ; underflow
   104                          
   105                          
   106                          ; Multiply FAC by 10
   107                          
   108  614f 20a362             mul10           jsr     movaf                           ; copy FAC into ARG
   109  6152 aa                                 tax
   110  6153 f012                               beq     mul10r                          ; if (FAC)=0, got answer
   111  6155 18                                 clc
   112  6156 6902                               adc     #2                              ; augment exp by 2
   113  6158 b3edcc                             +lbcs   overr                           ; overflow
   114                          
   115  615b a200               finml6          ldx     #0
   116  615d 8670                               stx     arisgn                          ; signs are same
   117  615f 20c95d                             jsr     faddc                           ; add together
   118  6162 e663                               inc     facexp                          ; multiply by two
   119  6164 f3e1cc                             +lbeq   overr                           ; overflow
   120                          
   121  6167 60                 mul10r          rts
   122                          
   123                          
   124  6168 20a362             div10           jsr     movaf                           ; move FAC to ARG
   125  616b a919                               lda     #<tenc
   126  616d a05f                               ldy     #>tenc                          ; point to constant of 10.0
   127  616f a200                               ldx     #0                              ; signs are both positive
   128                          
   129  6171 8670               fdivf           stx     arisgn
   130  6173 200e62                             jsr     movfm                           ; put it into FAC
   131  6176 800d                               bra     fdivt
   132                          
   133                          fdivt_c65                                               ; [910402]
   134  6178 a56f                               lda     argsgn
   135  617a 4568                               eor     facsgn
   136  617c 8570                               sta     arisgn                          ; resultant sign
   137  617e a663                               ldx     facexp                          ; set signs on thing to divide
   138  6180 8003                               bra     fdivt                           ; go divide
   139                          
   140  6182 20f760             fdiv            jsr     conupk                          ; unpack constant
   141  6185 f3bdcc             fdivt           +lbeq   doverr                          ; can't divide by zero
   142  6188 20b262                             jsr     round                           ; take FACOV into account in FAC
   143  618b a900                               lda     #0                              ; negate facexp
   144  618d 38                                 sec
   145  618e e563                               sbc     facexp
   146  6190 8563                               sta     facexp
   147  6192 202761                             jsr     muldiv                          ; fix up exponents
   148  6195 e663                               inc     facexp                          ; scale it right
   149  6197 f3aecc                             +lbeq   overr                           ; overflow
   150  619a a2fc                               ldx     #$fc                            ; set up procedure
   151  619c a901                               lda     #1
   152                          
   153                          
   154                          divide                                                  ; this is the best code in the whole pile
   155  619e a46b                               ldy     argho                           ; see what relation holds
   156  61a0 c464                               cpy     facho
   157  61a2 d010                               bne     savquo                          ; (c)=0,1. n(c=0)=0.
   158  61a4 a46c                               ldy     argmoh
   159  61a6 c465                               cpy     facmoh
   160  61a8 d00a                               bne     savquo
   161  61aa a46d                               ldy     argmo
   162  61ac c466                               cpy     facmo
   163  61ae d004                               bne     savquo
   164  61b0 a46e                               ldy     arglo
   165  61b2 c467                               cpy     faclo
   166                          
   167  61b4 08                 savquo          php
   168  61b5 2a                                 rol                                     ; save result
   169  61b6 9009                               bcc     qshft                           ; if not done, continue
   170  61b8 e8                                 inx
   171  61b9 952b                               sta     reslo,x
   172  61bb f031                               beq     ld100
   173  61bd 1033                               bpl     divnrm                          ; note this req 1 no ram then access
   174  61bf a901                               lda     #1
   175                          
   176  61c1 28                 qshft           plp                                     ; return condition codes
   177  61c2 b00e                               bcs     divsub                          ; FAC <= ARG
   178                          
   179  61c4 066e               shfarg          asl     arglo                           ; shift ARG one place left
   180  61c6 266d                               rol     argmo
   181  61c8 266c                               rol     argmoh
   182  61ca 266b                               rol     argho
   183  61cc b0e6                               bcs     savquo                          ; save a result of one for this position and divide
   184  61ce 30ce                               bmi     divide                          ; if msb on, go decide whether to sub
   185  61d0 10e2                               bpl     savquo
   186                          
   187                          
   188  61d2 a8                 divsub          tay                                     ; notice c must be on here
   189  61d3 a56e                               lda     arglo
   190  61d5 e567                               sbc     faclo
   191  61d7 856e                               sta     arglo
   192  61d9 a56d                               lda     argmo
   193  61db e566                               sbc     facmo
   194  61dd 856d                               sta     argmo
   195  61df a56c                               lda     argmoh
   196  61e1 e565                               sbc     facmoh
   197  61e3 856c                               sta     argmoh
   198  61e5 a56b                               lda     argho
   199  61e7 e564                               sbc     facho
   200  61e9 856b                               sta     argho
   201  61eb 98                                 tya
   202  61ec 80d6                               bra     shfarg
   203                          
   204                          
   205                          
   206  61ee a940               ld100           lda     #$40                            ; only want two more bits
   207  61f0 80cf                               bra     qshft                           ; always branches
   208                          
   209                          
   210                          
   211  61f2 0a                 divnrm          asl                                     ; get last two bits into MSB and B6
   212  61f3 0a                                 asl
   213  61f4 0a                                 asl
   214  61f5 0a                                 asl
   215  61f6 0a                                 asl
   216  61f7 0a                                 asl
   217  61f8 8571                               sta     facov
   218  61fa 28                                 plp
   219                          
   220                          
   221                          
   222  61fb a528               movfr           lda     resho                           ; move result to FAC
   223  61fd 8564                               sta     facho
   224  61ff a529                               lda     resmoh
   225  6201 8565                               sta     facmoh
   226  6203 a52a                               lda     resmo
   227  6205 8566                               sta     facmo
   228  6207 a52b                               lda     reslo                           ; move lo and sign
   229  6209 8567                               sta     faclo
   230  620b 831cfc                             +lbra   normal                          ; all done
   231                          
   232                          
   233                          
   234  620e 8524               movfm           sta     index1                          ; move memory into FAC from ROM (unpacked)
   235  6210 8425                               sty     index1+1
   236  6212 a004                               ldy     #4
   237  6214 b124                               lda     (index1),y
   238  6216 8567                               sta     faclo
   239  6218 88                                 dey
   240  6219 b124                               lda     (index1),y
   241  621b 8566                               sta     facmo
   242  621d 88                                 dey
   243  621e b124                               lda     (index1),y
   244  6220 8565                               sta     facmoh
   245  6222 88                                 dey
   246  6223 b124                               lda     (index1),y
   247  6225 8568                               sta     facsgn
   248  6227 0980                               ora     #$80
   249  6229 8564                               sta     facho
   250  622b 88                                 dey
   251  622c b124                               lda     (index1),y
   252  622e 8563                               sta     facexp
   253  6230 8471                               sty     facov
   254  6232 60                                 rts
   255                          
   256                          
   257                          ; Move number from FAC to memory
   258                          
   259  6233 a25e               mov2f           ldx     #tempf2                         ; move from FAC to temp FAC2
   260  6235 2c                                 !text $2c
   261                          
   262  6236 a259               mov1f           ldx     #tempf1                         ; move from FAC to temp FAC1
   263                          
   264  6238 a000                               ldy     #0
   265  623a 20b262             movmf           jsr     round
   266  623d 8624                               stx     index1
   267  623f 8425                               sty     index1+1
   268  6241 a004                               ldy     #4
   269  6243 a567                               lda     faclo
   270  6245 9124                               sta     (index),y                       ; BasePage
   271  6247 88                                 dey
   272  6248 a566                               lda     facmo
   273  624a 9124                               sta     (index),y                       ; BasePage
   274  624c 88                                 dey
   275  624d a565                               lda     facmoh
   276  624f 9124                               sta     (index),y                       ; BasePage
   277  6251 88                                 dey
   278  6252 a568                               lda     facsgn                          ; include sign in ho
   279  6254 097f                               ora     #$7f
   280  6256 2564                               and     facho
   281  6258 9124                               sta     (index),y                       ; BasePage
   282  625a 88                                 dey
   283  625b a563                               lda     facexp
   284  625d 9124                               sta     (index),y                       ; BasePage
   285  625f 8471                               sty     facov                           ; zero it since rounded
   286  6261 60                                 rts                                     ; (y)=0
   287                          
   288                          
   289                          movmf_ram1
   290  6262 20b262                             jsr     round
   291  6265 8624                               stx     index1
   292  6267 8425                               sty     index1+1
   293  6269 da                                 phx
   294  626a a224                               ldx     #index
   295  626c a004                               ldy     #4
   296  626e a567                               lda     faclo
   297  6270 20f022                             jsr     sta_far_ram1                    ; sta (index),y
   298  6273 88                                 dey
   299  6274 a566                               lda     facmo
   300  6276 20f022                             jsr     sta_far_ram1                    ; sta (index),y
   301  6279 88                                 dey
   302  627a a565                               lda     facmoh
   303  627c 20f022                             jsr     sta_far_ram1                    ; sta (index),y
   304  627f 88                                 dey
   305  6280 a568                               lda     facsgn                          ; include sign in ho
   306  6282 097f                               ora     #$7f
   307  6284 2564                               and     facho
   308  6286 20f022                             jsr     sta_far_ram1                    ; sta (index),y
   309  6289 88                                 dey
   310  628a a563                               lda     facexp
   311  628c 20f022                             jsr     sta_far_ram1                    ; sta (index),y
   312  628f 8471                               sty     facov                           ; zero it since rounded
   313  6291 fa                                 plx
   314  6292 60                                 rts                                     ; (y)=0
   315                          
   316                          
   317  6293 a56f               movfa           lda     argsgn
   318                          
   319  6295 8568               movfa1          sta     facsgn
   320                          
   321  6297 a205                               ldx     #5
   322  6299 b569               l173_1          lda     argexp-1,x
   323  629b 9562                               sta     facexp-1,x
   324  629d ca                                 dex
   325  629e d0f9                               bne     l173_1
   326  62a0 8671                               stx     facov
   327  62a2 60                                 rts
   328                          
   329                          
   330  62a3 20b262             movaf           jsr     round
   331                          
   332  62a6 a206               movef           ldx     #6
   333  62a8 b562               l174_1          lda     facexp-1,x
   334  62aa 9569                               sta     argexp-1,x
   335  62ac ca                                 dex
   336  62ad d0f9                               bne     l174_1
   337  62af 8671                               stx     facov                           ; zero it since rounded
   338  62b1 60                 movrts          rts
   339                          
   340                          
   341                          
   342  62b2 a563               round           lda     facexp                          ; zero?
   343  62b4 f0fb                               beq     movrts                          ; yes, done rounding
   344  62b6 0671                               asl     facov                           ; round?
   345  62b8 90f7                               bcc     movrts                          ; no, msb off
   346                          
   347  62ba 20c15e             incrnd          jsr     incfac                          ; yes, add one to lsb(FAC) /// entry from EXP
   348                          ;note .c=1 since incfac doesn't touch .c
   349  62bd f3cafb                             +lbeq   rndshf                          ; carry:   squeeze msb in and rts
   350  62c0 60                                 rts                                     ; no carry: rts now
   351                          
   352                          
   353                          
   354                          ; Put sign in FAC into (a).
   355                          
   356  62c1 a563               sign            lda     facexp
   357  62c3 f009                               beq     signrt                          ; if number is zero, so is result
   358                          
   359  62c5 a568               fcsign          lda     facsgn
   360  62c7 2a                 fcomps          rol
   361  62c8 a9ff                               lda     #$ff                            ; assume negative
   362  62ca b002                               bcs     signrt
   363  62cc a901                               lda     #1                              ; get +1
   364  62ce 60                 signrt          rts
   365                          
   366                          
   367                          
   368                          ; SGN function
   369                          
   370  62cf 20c162             sgn             jsr     sign
   371                          
   372                          ;float the signed integer in accb
   373  62d2 8564               float           sta     facho                           ; put (accb) in high order
   374  62d4 a900                               lda     #0
   375  62d6 8565                               sta     facho+1
   376  62d8 a288                               ldx     #$88                            ; get the exponent
   377                          ;float the signed number in FAC
   378                          
   379                          
   380  62da a564               floats          lda     facho
   381  62dc 49ff                               eor     #$ff
   382  62de 2a                                 rol                                     ; get comp of sign in carry
   383  62df a900               floatc          lda     #0                              ; zero (a) but not carry
   384  62e1 8567                               sta     faclo
   385  62e3 8566                               sta     facmo
   386                          
   387  62e5 8663               floatb          stx     facexp
   388  62e7 8571                               sta     facov
   389  62e9 8568                               sta     facsgn
   390  62eb 8337fb                             +lbra   fadflt
   391                          
   392                          
   393                          
   394                          
   395                          ; Absolute value of FAC
   396                          
   397  62ee 4668               abs             lsr     facsgn
   398  62f0 60                                 rts
   399                          
   400                          
   401                          
   402                          ; Compare two numbers:
   403                          ;
   404                          ; a=1  if  ARG < FAC
   405                          ; a=0  if  ARG = FAC
   406                          ; a=-1 if  ARG > FAC
   407                          
   408  62f1 8526               fcomp           sta     index2
   409  62f3 8427                               sty     index2+1
   410  62f5 a000                               ldy     #0
   411  62f7 b126                               lda     (index2),y                      ; has argexp
   412  62f9 c8                                 iny                                     ; bump pointer up
   413  62fa aa                                 tax                                     ; save a in x and reset codes
   414  62fb f0c4                               beq     sign
   415  62fd b126                               lda     (index2),y
   416  62ff 4568                               eor     facsgn                          ; signs the same
   417  6301 30c2                               bmi     fcsign                          ; signs differ so result is
   418  6303 e463                               cpx     facexp                          ; sign of FAC again
   419  6305 d021                               bne     l175_1
   420                          
   421  6307 b126                               lda     (index2),y
   422  6309 0980                               ora     #$80
   423  630b c564                               cmp     facho
   424  630d d019                               bne     l175_1
   425  630f c8                                 iny
   426  6310 b126                               lda     (index2),y
   427  6312 c565                               cmp     facmoh
   428  6314 d012                               bne     l175_1
   429  6316 c8                                 iny
   430  6317 b126                               lda     (index2),y
   431  6319 c566                               cmp     facmo
   432  631b d00b                               bne     l175_1
   433  631d c8                                 iny
   434  631e a97f                               lda     #$7f
   435  6320 c571                               cmp     facov
   436  6322 b126                               lda     (index2),y
   437  6324 e567                               sbc     faclo                           ; get zero if equal
   438  6326 f028                               beq     qintrt                          ; rts
   439                          
   440  6328 a568               l175_1          lda     facsgn
   441  632a 9002                               bcc     l175_2
   442  632c 49ff                               eor     #$ff
   443  632e 8097               l175_2          bra     fcomps                          ; a part of sign sets up (a)
   444                          
   445                          ;.end
   446                          
   447                          ; ********************************************************************************************
   448                          ;
   449                          ;	Date		Changes
   450                          ;	====		=======
   451                          ;
   452                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/integer.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      integer.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Quick Greatest Integer Function
    16                          ;
    17                          ; Leaves INT(FAC) in FACHO&MO&LO signed
    18                          ; Assumes FAC < 2~23 =8388608
    19                          
    20  6330 a563               qint            lda     facexp
    21  6332 f04f                               beq     clrfac                          ; if zero, got it
    22  6334 38                                 sec
    23  6335 e9a0                               sbc     #$a0                            ; get number of places to shift
    24                          
    25  6337 7f680a                             bbr7    facsgn,l176_1
    26                          
    27  633a aa                                 tax
    28  633b a9ff                               lda     #$ff
    29  633d 8dd702                             sta     bits                            ; put $ff in when shftr shifts bytes
    30  6340 209f5e                             jsr     negfch                          ; truly negate quantity in FAC
    31  6343 8a                                 txa
    32                          
    33  6344 a263               l176_1          ldx     #fac
    34  6346 c9f9                               cmp     #$f9
    35  6348 1007                               bpl     qint1                           ; if number of places > 7 shift 1 place at a time
    36  634a 20e75e                             jsr     shiftr                          ; start shifting bytes, then bits
    37  634d 8cd702                             sty     bits                            ; zero bits since adder wants zero
    38  6350 60                 qintrt          rts
    39                          
    40                          
    41  6351 a8                 qint1           tay                                     ; put count in counter
    42  6352 a568                               lda     facsgn
    43  6354 2980                               and     #$80                            ; get sign bit
    44  6356 4664                               lsr     facho                           ; save first shifted byte
    45  6358 0564                               ora     facho
    46  635a 8564                               sta     facho
    47  635c 20fe5e                             jsr     rolshf                          ; shift the rest
    48  635f 8cd702                             sty     bits                            ; zero (bits)
    49  6362 60                                 rts
    50                          
    51                          
    52                          
    53                          ; Greatest Integer Function
    54                          
    55  6363 a563               int             lda     facexp
    56  6365 c9a0                               cmp     #$a0
    57  6367 b023                               bcs     intrts                          ; forget it
    58  6369 20b262                             jsr     round                           ; round FAC per FACOV (fixes the  INT(.9+.1) -> 0  Microsoft bug.  FAB)
    59  636c 203063                             jsr     qint                            ; INT(FAC)
    60  636f 8471                               sty     facov                           ; clr overflow byte
    61  6371 a568                               lda     facsgn
    62  6373 8468                               sty     facsgn                          ; make FAC look positive
    63  6375 4980                               eor     #$80                            ; get complement of sign in carry
    64  6377 2a                                 rol
    65  6378 a9a0                               lda     #$a0                            ; @230+8
    66  637a 8563                               sta     facexp
    67  637c a567                               lda     faclo
    68  637e 850a                               sta     integr
    69  6380 83a2fa                             +lbra   fadflt
    70                          
    71                          
    72  6383 8564               clrfac          sta     facho                           ; make it really zero
    73  6385 8565                               sta     facmoh
    74  6387 8566                               sta     facmo
    75  6389 8567                               sta     faclo
    76  638b a8                                 tay
    77  638c 60                 intrts          rts
    78                          
    79                          
    80                          ; ********************************************************************************************
    81                          ;
    82                          ;	Date		Changes
    83                          ;	====		=======
    84                          ;
    85                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/fpin.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      fpin.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ; Floating Point Input Routine.
    15                          ;
    16                          ; Number input is left in FAC.  At entry (TXTPTR) points to the first character
    17                          ; in a text buffer.  The first character is also in (a).  FIN packs the digits
    18                          ; into the FAC as an integer and keeps track of where the decimal point is.
    19                          ; (DPTFLG) tells whether a dp has been seen.  (DECCNT) is the number of digits
    20                          ; after the dp.  At the end (DECCNT) and the exponent are used to determine how
    21                          ; many times to multiply or divide by ten to get the correct number.
    22                          
    23                          
    24  638d 8ed202             fin             stx     fin_bank                        ; save bank number where string is stored
    25                          
    26  6390 a000                               ldy     #0                              ; zero facsgn, sgnflg
    27  6392 a20a                               ldx     #$0a                            ; zero exp and ho (and moh)
    28  6394 945f               l177_1          sty     deccnt,x                        ; zero mo and lo
    29  6396 ca                                 dex                                     ; zero tenexp and expsgn
    30  6397 10fb                               bpl     l177_1                          ; zero deccnt, dptflg
    31                          
    32  6399 900f                               bcc     findgq                          ; flags still set from chrget
    33  639b c92d                               cmp     #'-'                            ; a negative sign?
    34  639d d004                               bne     qplus                           ; no, try plus sign
    35  639f 8669                               stx     sgnflg                          ; it's negative. (x=@377)
    36  63a1 8004                               bra     finc                            ; always branches
    37                          
    38                          
    39  63a3 c92b               qplus           cmp     #'+'                            ; plus sign?
    40  63a5 d005                               bne     fin1                            ; yes, skip it
    41                          
    42  63a7 205764             finc            jsr     fin_chrget
    43                          
    44  63aa 9056               findgq          bcc     findig
    45                          
    46  63ac c92e               fin1            cmp     #'.'                            ; the dp?
    47  63ae f02c                               beq     findp                           ; no kidding
    48  63b0 c945                               cmp     #'E'                            ; exponent follows
    49  63b2 d02d                               bne     fine                            ; no
    50                          
    51  63b4 205764                             jsr     fin_chrget                      ; yes, get another, to check sign of exponent
    52  63b7 9017                               bcc     fnedg1                          ; is it a digit. (easier than backing up pointer)
    53  63b9 c9ab                               cmp     #minus_token                    ; minus?
    54  63bb f00e                               beq     finec1                          ; negate
    55  63bd c92d                               cmp     #'-'                            ; minus sign?
    56  63bf f00a                               beq     finec1
    57  63c1 c9aa                               cmp     #plus_token                     ; plus?
    58  63c3 f008                               beq     finec
    59  63c5 c92b                               cmp     #'+'                            ; plus sign?
    60  63c7 f004                               beq     finec
    61  63c9 8007                               bra     finec2
    62                          
    63  63cb 6662               finec1          ror     expsgn                          ; turn it on
    64                          
    65  63cd 205764             finec           jsr     fin_chrget                      ; get another
    66                          
    67  63d0 9055               fnedg1          bcc     finedg                          ; it is a digit
    68  63d2 7f620c             finec2          bbr7    expsgn,fine
    69  63d5 a900                               lda     #0
    70  63d7 38                                 sec
    71  63d8 e560                               sbc     tenexp
    72  63da 8007                               bra     fine1
    73                          
    74  63dc 6661               findp           ror     dptflg
    75  63de 6f61c6                             bbr6    dptflg,finc
    76                          
    77  63e1 a560               fine            lda     tenexp
    78  63e3 38                 fine1           sec
    79  63e4 e55f                               sbc     deccnt                          ; get number of places to shift
    80  63e6 8560                               sta     tenexp
    81  63e8 f012                               beq     finqng                          ; negate?
    82  63ea 1009                               bpl     finmul                          ; positive, so multiply
    83                          
    84  63ec 206861             findiv          jsr     div10
    85  63ef e660                               inc     tenexp                          ; done?
    86  63f1 d0f9                               bne     findiv                          ; no
    87  63f3 8007                               bra     finqng                          ; yes
    88                          
    89                          
    90  63f5 204f61             finmul          jsr     mul10
    91  63f8 c660                               dec     tenexp                          ; done?
    92  63fa d0f9                               bne     finmul                          ; no
    93  63fc a569               finqng          lda     sgnflg
    94  63fe 33fc01                             +lbmi   negop                           ; if negative, negate and return
    95  6401 60                                 rts                                     ; if positive, return
    96                          
    97                          
    98                          
    99  6402 48                 findig          pha
   100  6403 7f6102                             bbr7    dptflg,l178_1
   101  6406 e65f                               inc     deccnt
   102  6408 204f61             l178_1          jsr     mul10
   103  640b 68                                 pla                                     ; get it back
   104  640c 38                                 sec
   105  640d e930                               sbc     #'0'
   106  640f 201464                             jsr     finlog                          ; add it in
   107  6412 8093                               bra     finc
   108                          
   109                          
   110                          
   111  6414 48                 finlog          pha
   112  6415 20a362                             jsr     movaf                           ; save it for later
   113  6418 68                                 pla
   114  6419 20d262                             jsr     float                           ; float the value in (a)
   115                          
   116                          faddt_c65                                               ; [910402]
   117  641c a56f                               lda     argsgn
   118  641e 4568                               eor     facsgn
   119  6420 8570                               sta     arisgn                          ; resultant sign
   120  6422 a663                               ldx     facexp                          ; set signs on thing to add
   121  6424 8398f9                             +lbra   faddt                           ; add together and return
   122                          
   123                          
   124                          ; Pack in the next digit of the exponent.
   125                          ; Multiply the old exp by 10 and add in the next digit.
   126                          ; (note: does not check for exp overflow)
   127                          
   128  6427 a560               finedg          lda     tenexp                          ; get exp so far
   129  6429 c90a                               cmp     #10                             ; will result be >= 100?
   130  642b 9008                               bcc     l179_1
   131  642d a964                               lda     #100
   132  642f ff6220                             bbs7    expsgn,l179_4                   ; if neg exp, no chk for overr
   133  6432 8313ca                             +lbra   overr
   134                          
   135  6435 0a                 l179_1          asl                                     ; max is 120
   136  6436 0a                                 asl                                     ; mult by 2 twice
   137  6437 18                                 clc                                     ; possible shift out of high
   138  6438 6560                               adc     tenexp                          ; like multiplying by five
   139  643a 0a                                 asl                                     ; and now by ten
   140  643b 18                                 clc
   141  643c a000                               ldy     #0
   142  643e 8578                               sta     syntmp
   143                          
   144  6440 add202                             lda     fin_bank                        ; text or string bank?
   145  6443 d005                               bne     l179_2
   146  6445 20c522                             jsr     indtxt                          ; text
   147  6448 8003                               bra     l179_3
   148  644a 20d522             l179_2          jsr     indin1_ram1                     ; string
   149                          
   150  644d 6578               l179_3          adc     syntmp
   151  644f 38                                 sec
   152  6450 e930                               sbc     #'0'
   153  6452 8560               l179_4          sta     tenexp                          ; save result
   154  6454 8377ff                             +lbra   finec
   155                          
   156                          
   157                          ; Get a character from either text or string area, and set the flags
   158                          ; in the manner performed by CHRGET.
   159                          
   160                          fin_chrget
   161  6457 add202                             lda     fin_bank                        ; text or string bank?
   162  645a f327be                             +lbeq   chrget                          ; get byte from text bank via normal CHRGET mechanism
   163                          
   164                          fin_chrget_1                                            ; get byte from string bank via modified CHRGET mechanism
   165  645d e324                               inw     index1
   166                          fin_chrget_2
   167  645f a000                               ldy     #0
   168  6461 20d522                             jsr     indin1_ram1
   169  6464 c93a                               cmp     #':'
   170  6466 b00a                               bcs     l180_1
   171  6468 c920                               cmp     #' '
   172  646a f0f1                               beq     fin_chrget_1                    ; skip over spaces
   173  646c 38                                 sec
   174  646d e930                               sbc     #'0'                            ; set up .c as CHRGET would
   175  646f 38                                 sec
   176  6470 e9d0                               sbc     #$d0
   177  6472 60                 l180_1          rts
   178                          
   179                          ;.end
   180                          
   181                          ; ********************************************************************************************
   182                          ;
   183                          ;	Date		Changes
   184                          ;	====		=======
   185                          ;
   186                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/convert.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      convert.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15  6473 207dff             inprt           jsr     _primm
    16  6476 20494e2000                         !text " IN ",0
    17                          
    18  647b a53c               curprt          lda     curlin+1
    19  647d a63b                               ldx     curlin
    20                          
    21  647f 8564               linprt          sta     facho
    22  6481 8665                               stx     facho+1
    23  6483 a290                               ldx     #$90                            ; exponent of 16
    24  6485 38                                 sec                                     ; number is positive
    25  6486 20df62                             jsr     floatc
    26  6489 209164                             jsr     foutc
    27  648c 83add3                             +lbra   strout                          ; print and return
    28                          
    29                          
    30  648f a001               fout            ldy     #1
    31  6491 a920               foutc           lda     #' '                            ; if positive, print space
    32  6493 7f6802                             bbr7    facsgn,l181_1
    33  6496 a92d                               lda     #'-'                            ; if neg
    34  6498 99ff00             l181_1          sta     fbuffr-1,y                      ; store the character
    35  649b 8568                               sta     facsgn                          ; make FAC pos for QINT
    36  649d 8472                               sty     fbufpt                          ; save for later
    37  649f c8                                 iny
    38  64a0 a930                               lda     #'0'                            ; get zero to type if FAC=0
    39  64a2 a663                               ldx     facexp
    40  64a4 f30901                             +lbeq   fout19
    41                          
    42  64a7 a900                               lda     #0
    43  64a9 e080                               cpx     #$80                            ; is number < 1?
    44  64ab f002                               beq     l181_2                          ; no
    45  64ad b009                               bcs     l181_3
    46                          
    47  64af a937               l181_2          lda     #<nmil                          ; mult by 10~6
    48  64b1 a05f                               ldy     #>nmil
    49  64b3 204860                             jsr     rommlt
    50  64b6 a9f7                               lda     #$f7
    51  64b8 855f               l181_3          sta     deccnt                          ; save count or zero it
    52                          
    53  64ba a932               l181_4          lda     #<n9999
    54  64bc a05f                               ldy     #>n9999
    55  64be 20f162                             jsr     fcomp                           ; is number > 999999.499 or 999999999.5?
    56  64c1 f01e                               beq     l181_9                          ; go to biggies
    57  64c3 1012                               bpl     l181_7                          ; yes, make it smaller
    58                          
    59  64c5 a92d               l181_5          lda     #<n0999
    60  64c7 a05f                               ldy     #>n0999
    61  64c9 20f162                             jsr     fcomp                           ; is number > 99999.9499 or 99999999.90625?
    62  64cc f002                               beq     l181_6
    63  64ce 100e                               bpl     l181_8                          ; yes. done multiplying
    64                          
    65  64d0 204f61             l181_6          jsr     mul10                           ; make it bigger
    66  64d3 c65f                               dec     deccnt
    67  64d5 d0ee                               bne     l181_5                          ; see if that does it (this always goes)
    68                          
    69  64d7 206861             l181_7          jsr     div10                           ; make it smaller
    70  64da e65f                               inc     deccnt
    71  64dc d0dc                               bne     l181_4                          ; see if that does it (this always goes)
    72                          
    73  64de 204d60             l181_8          jsr     faddh                           ; add a half to round up
    74                          
    75                          
    76  64e1 203063             l181_9          jsr     qint                            ; biggies.
    77  64e4 a201                               ldx     #1                              ; decimal point count
    78  64e6 a55f                               lda     deccnt
    79  64e8 18                                 clc
    80  64e9 690a                               adc     #$0a                            ; should number be printed in E notation?  (ie, is number .lt. .01?)
    81  64eb 3009                               bmi     l181_10                         ; yes
    82  64ed c90b                               cmp     #$0b                            ; is it > 999999 or 9999999999?
    83  64ef b006                               bcs     l181_11                         ; yes, use E notation
    84  64f1 69ff                               adc     #$ff                            ; number of places before decimal point
    85  64f3 aa                                 tax                                     ; put into accx
    86  64f4 a902                               lda     #2                              ; no E notation
    87  64f6 38                 l181_10         sec
    88                          
    89  64f7 e902               l181_11         sbc     #2                              ; effectively add 5 to orig exp
    90  64f9 8560                               sta     tenexp                          ; that is the exponent to print
    91  64fb 865f                               stx     deccnt                          ; number of decimal places
    92  64fd 8a                                 txa
    93  64fe f002                               beq     l181_12
    94  6500 1013                               bpl     l181_14                         ; some places before dec pnt
    95                          
    96  6502 a472               l181_12         ldy     fbufpt                          ; get pointer to output
    97  6504 a92e                               lda     #'.'                            ; put in "."
    98  6506 c8                                 iny
    99  6507 99ff00                             sta     fbuffr-1,y
   100  650a 8a                                 txa
   101  650b f006                               beq     l181_13
   102  650d a930                               lda     #'0'                            ; get the ensuing zero
   103  650f c8                                 iny
   104  6510 99ff00                             sta     fbuffr-1,y
   105                          
   106  6513 8472               l181_13         sty     fbufpt                          ; save it for later
   107                          
   108  6515 a000               l181_14         ldy     #0
   109                          
   110  6517 a280               foutim          ldx     #$80                            ; first pass through, accb has msb set
   111  6519 a567               fout2           lda     faclo
   112  651b 18                                 clc
   113  651c 793f5f                             adc     foutbl+3,y
   114  651f 8567                               sta     faclo
   115  6521 a566                               lda     facmo
   116  6523 793e5f                             adc     foutbl+2,y
   117  6526 8566                               sta     facmo
   118  6528 a565                               lda     facmoh
   119  652a 793d5f                             adc     foutbl+1,y
   120  652d 8565                               sta     facmoh
   121  652f a564                               lda     facho
   122  6531 793c5f                             adc     foutbl,y
   123  6534 8564                               sta     facho
   124  6536 e8                                 inx                                     ; it was done yet another time
   125  6537 b004                               bcs     l182_1
   126  6539 10de                               bpl     fout2
   127  653b 3002                               bmi     l182_2
   128                          
   129  653d 30da               l182_1          bmi     fout2
   130  653f 8a                 l182_2          txa
   131  6540 9004                               bcc     l182_3                          ; can use (a) as is
   132  6542 49ff                               eor     #$ff                            ; find 11.(a)
   133  6544 690a                               adc     #10                             ; c is still on to complete negation, and will always be on after
   134                          
   135  6546 692f               l182_3          adc     #'0'-1                          ; get a character to print
   136  6548 c8                                 iny
   137  6549 c8                                 iny
   138  654a c8                                 iny
   139  654b c8                                 iny
   140  654c 8449                               sty     fdecpt
   141  654e a472                               ldy     fbufpt
   142  6550 c8                                 iny                                     ; point to place to store output
   143  6551 aa                                 tax
   144  6552 297f                               and     #$7f                            ; get rid of msb
   145  6554 99ff00                             sta     fbuffr-1,y
   146  6557 c65f                               dec     deccnt
   147  6559 d006                               bne     l182_4                          ; not time for dp yet
   148  655b a92e                               lda     #'.'
   149  655d c8                                 iny
   150  655e 99ff00                             sta     fbuffr-1,y                      ; store dp
   151                          
   152  6561 8472               l182_4          sty     fbufpt                          ; store pointer for later
   153  6563 a449                               ldy     fdecpt
   154  6565 8a                                 txa                                     ; complement accb
   155  6566 49ff                               eor     #$ff                            ; complement acca
   156  6568 2980                               and     #$80                            ; save only msb
   157  656a aa                                 tax
   158  656b c024                               cpy     #fdcend-foutbl
   159                          ; beq l182_5  ;for time converter ????   removed [901014]
   160                          ; cpy #timend-foutbl
   161  656d d0aa                               bne     fout2                           ; continue with output
   162                          
   163  656f a472               l182_5          ldy     fbufpt                          ; get back output pointer
   164  6571 b9ff00             l182_6          lda     fbuffr-1,y                      ; remove trailing blanks
   165  6574 88                                 dey
   166  6575 c930                               cmp     #'0'
   167  6577 f0f8                               beq     l182_6
   168  6579 c92e                               cmp     #'.'
   169  657b f001                               beq     l182_7                          ; ran into dp,  stop
   170  657d c8                                 iny                                     ; something else, save it
   171                          
   172  657e a92b               l182_7          lda     #'+'
   173  6580 a660                               ldx     tenexp
   174  6582 f02e                               beq     fout17                          ; no exponent to output
   175  6584 1008                               bpl     l182_8
   176  6586 a900                               lda     #0
   177  6588 38                                 sec
   178  6589 e560                               sbc     tenexp
   179  658b aa                                 tax
   180  658c a92d                               lda     #'-'                            ; exponent is negative
   181                          
   182  658e 990101             l182_8          sta     fbuffr+1,y                      ; store sign of exponent
   183  6591 a945                               lda     #'E'
   184  6593 990001                             sta     fbuffr,y                        ; store the 'E' character
   185  6596 8a                                 txa
   186                          
   187  6597 a22f                               ldx     #'0'-1
   188  6599 38                                 sec
   189  659a e8                 l182_9          inx                                     ; move closer to output value
   190  659b e90a                               sbc     #10                             ; subtract 10
   191  659d b0fb                               bcs     l182_9                          ; not negative yet
   192                          
   193  659f 693a                               adc     #'9'+1                          ; get second output character
   194  65a1 990301                             sta     fbuffr+3,y                      ; store high digit
   195  65a4 8a                                 txa
   196  65a5 990201                             sta     fbuffr+2,y                      ; store low digit
   197  65a8 a900                               lda     #0                              ; put in terminator
   198  65aa 990401                             sta     fbuffr+4,y
   199  65ad 8008                               bra     fout20                          ; return
   200                          
   201                          
   202  65af 99ff00             fout19          sta     fbuffr-1,y                      ; store the character
   203  65b2 a900               fout17          lda     #0                              ; store the terminator
   204  65b4 990001                             sta     fbuffr,y
   205                          
   206  65b7 a900               fout20          lda     #<fbuffr
   207  65b9 a001                               ldy     #>fbuffr
   208  65bb 60                                 rts                                     ; all done
   209                          
   210                          
   211                          ; Exponentiation and Square Root Functions.
   212                          ;
   213                          ; square root function - sqr(a)
   214                          ; use sqr(x) = x^.5
   215                          
   216  65bc 20a362             sqr             jsr     movaf                           ; move FAC into ARG
   217  65bf a914                               lda     #<fhalf
   218  65c1 a05f                               ldy     #>fhalf
   219                          
   220  65c3 200e62             fpwr            jsr     movfm                           ; put memory into FAC    ARG^MEM
   221                          
   222                          
   223                          ; Last thing fetched is facexp into accx.
   224                          ;
   225                          ; Exponentiation --- x^y.
   226                          ; n.b. 0^0=1
   227                          ; First check if y=0, and if so the result is one.
   228                          ; Next  check if x=0, and if so the result is zero.
   229                          ; Then  check if x>0:
   230                          ; if not check that y is an integer.
   231                          ; if so negate x, so that lg doesn't give fcerr.
   232                          ; If x is negative and y is odd, negate the result returned by exp.
   233                          ; To compute the result use x^y = EXP((y*LOG(x))
   234                          
   235                          
   236  65c6 f03f               fpwrt           beq     exp                             ; if FAC=0, just exponentiate that  ARG^FAC
   237  65c8 a56a                               lda     argexp                          ; is x=0?
   238  65ca f37ff8                             +lbeq   zerof1                          ; zero FAC
   239                          
   240  65cd a250                               ldx     #<tempf3                        ; save it for later in a temp
   241  65cf a000                               ldy     #>tempf3
   242  65d1 203a62                             jsr     movmf                           ; FAC->MEM
   243                          
   244  65d4 a56f                               lda     argsgn                          ; note y=0 already. that's good, in case no one calls int.
   245  65d6 100f                               bpl     l183_1                          ; no problems if x>0
   246  65d8 206363                             jsr     int                             ; integerize the FAC
   247  65db a950                               lda     #<tempf3                        ; get addr of comperand
   248  65dd a000                               ldy     #>tempf3
   249  65df 20f162                             jsr     fcomp                           ; equal?
   250  65e2 d003                               bne     l183_1                          ; leave x neg. log will blow him out
   251                          ;a=-1 and y is irrelavant
   252  65e4 98                                 tya                                     ; negative x. make positive
   253  65e5 a40a                               ldy     integr                          ; get evenness
   254                          
   255  65e7 209562             l183_1          jsr     movfa1                          ; alternate entry point.    ARG->FAC
   256  65ea 5a                                 phy                                     ; save evenness for later
   257  65eb 200e60                             jsr     log                             ; find log
   258  65ee a950                               lda     #<tempf3                        ; multiply FAC times LOG(x)
   259  65f0 a000                               ldy     #>tempf3
   260  65f2 206d60                             jsr     fmult
   261  65f5 200766                             jsr     exp                             ; exponentiate the FAC
   262  65f8 68                                 pla
   263  65f9 4a                                 lsr                                     ; is it even?
   264  65fa 900a                               bcc     negrts                          ; yes. or x>0
   265                          ;negate the number in FAC
   266                          
   267                          
   268                          negop                                                   ; /// entry point
   269  65fc a563                               lda     facexp
   270  65fe f006                               beq     negrts
   271  6600 a568                               lda     facsgn
   272  6602 49ff                               eor     #$ff
   273  6604 8568                               sta     facsgn
   274  6606 60                 negrts          rts
   275                          
   276                          ;.end
   277                          
   278                          ; ********************************************************************************************
   279                          ;
   280                          ;	Date		Changes
   281                          ;	====		=======
   282                          ;
   283                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/logarithms.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      logarithms.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Exponentation Function
    16                          ;
    17                          ; First save the original argument and multiply the FAC by LOG2(e).  The
    18                          ; result is used to determine if overflow will occur since
    19                          ;
    20                          ;  EXP(x) = 2^(x*LOG2(e))
    21                          ;
    22                          ; where
    23                          ;  LOG2(e) = LOG(e), base 2
    24                          ;
    25                          ; Then save the integer part of this to scale the answer at the end, since
    26                          ; 2^y=2^INT(y)*2^(y-INT(y)) and 2^INT(y) are easy to compute.  Now compute
    27                          ;
    28                          ;  2^(x*LOG2(e)-INT(x*LOG2(e))
    29                          ; by
    30                          ;  p(LOG(2)*(INT(x*LOG2(e))+1)-x
    31                          ;
    32                          ; where p is an approximation polynomial. The result is then scaled by the
    33                          ; power of two previously saved.  Re: Taylor expansion.
    34                          
    35                          
    36  6607 a99e               exp             lda     #<logeb2                        ; multiply by LOG(e) base 2
    37  6609 a05f                               ldy     #>logeb2
    38  660b 204860                             jsr     rommlt                          ; LOGEB2->ARG, FAC=FAC*ARG
    39  660e a571                               lda     facov
    40  6610 6950                               adc     #$50                            ; ????
    41  6612 9003                               bcc     l184_1
    42  6614 20ba62                             jsr     incrnd
    43                          
    44  6617 8558               l184_1          sta     oldov
    45  6619 20a662                             jsr     movef                           ; to save in ARG without round.  ARG=FAC, facov=0)
    46  661c a563                               lda     facexp
    47  661e c988                               cmp     #$88                            ; if ABS(FAC) >= 128, too big
    48  6620 9003                               bcc     l184_3
    49                          
    50  6622 204361             l184_2          jsr     mldvex                          ; overflow or overflow
    51  6625 206363             l184_3          jsr     int                             ; FAC=INT(FAC), uses facov
    52  6628 a50a                               lda     integr                          ; get low part
    53  662a 18                                 clc
    54  662b 6981                               adc     #$81
    55  662d f0f3                               beq     l184_2                          ; overflow or overflow!!
    56                          
    57  662f 38                                 sec
    58  6630 e901                               sbc     #1                              ; subtract it
    59  6632 48                                 pha                                     ; save a while
    60                          
    61  6633 a205                               ldx     #5                              ; swap FAC and ARG
    62  6635 b56a               l184_4          lda     argexp,x
    63  6637 b463                               ldy     facexp,x
    64  6639 9563                               sta     facexp,x
    65  663b 946a                               sty     argexp,x
    66  663d ca                                 dex
    67  663e 10f5                               bpl     l184_4
    68                          
    69  6640 a558                               lda     oldov
    70  6642 8571                               sta     facov
    71  6644 20a85d                             jsr     fsubt                           ; FAC=ARG-FAC
    72  6647 20fc65                             jsr     negop                           ; negate FAC
    73  664a a975                               lda     #<expcon
    74  664c a05f                               ldy     #>expcon
    75  664e 207066                             jsr     poly
    76  6651 a900                               lda     #0
    77  6653 8570                               sta     arisgn                          ; multiply by positive 1.0
    78                          
    79  6655 68                                 pla                                     ; recall scale factor
    80  6656 202961                             jsr     mldexp                          ; modify facexp and check for overflow
    81  6659 60                                 rts                                     ; (has to do jsr due to pla's in muldiv)
    82                          
    83                          
    84                          ; ********************************************************************************************
    85                          ;
    86                          ;	Date		Changes
    87                          ;	====		=======
    88                          ;
    89                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/polyeval.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      polyeval.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ; Polynomial Evaluator and the Random Number Generator.
    15                          ;
    16                          ; Evaluate  p(x^2)*x
    17                          ; The pointer to degree is in (a,y) and the constants follow the degree.
    18                          ; For x=FAC, compute  c0*x + c1*x^3 + c2*x^5 + c3*x^7 +...+ c(n)*x^(2*n+1)
    19                          
    20                          
    21  665a 8572               polyx           sta     polypt                          ; retain polynomial pointer for later
    22  665c 8473                               sty     polypt+1
    23  665e 203662                             jsr     mov1f                           ; save FAC in factmp (y=0 upon return)
    24  6661 a959                               lda     #tempf1
    25  6663 206d60                             jsr     fmult                           ; compute x^2.
    26  6666 207466                             jsr     poly1                           ; compute p(x^2).
    27  6669 a959                               lda     #<tempf1
    28  666b a000                               ldy     #>tempf1
    29  666d 83fef9                             +lbra   fmult                           ; multiply by FAC again
    30                          
    31                          
    32                          ; Polynomial Evaluator
    33                          ;
    34                          ; Pointer to degree is in (a,y).
    35                          ; Compute:  c0+c1*x+c2*x^2+c3*x^3+c4*x^4...+c(n-1)*x^(n-1)+c(n)*x^n
    36                          ;  which is roughly (LOG(2)^n)/LOG(EXP(1))/n!
    37                          
    38                          
    39  6670 8572               poly            sta     polypt
    40  6672 8473                               sty     polypt+1
    41                          
    42  6674 203362             poly1           jsr     mov2f                           ; save FAC (rounds, .y=0)
    43  6677 b172                               lda     (polypt),y
    44  6679 8569                               sta     degree
    45  667b e372                               inw     polypt
    46  667d a572                               lda     polypt
    47  667f a473                               ldy     polypt+1
    48                          
    49  6681 204860             l185_1          jsr     rommlt
    50  6684 a572                               lda     polypt                          ; get current pointer
    51  6686 a473                               ldy     polypt+1
    52  6688 18                                 clc
    53  6689 6905                               adc     #5
    54  668b 9001                               bcc     l185_2
    55  668d c8                                 iny
    56  668e 8572               l185_2          sta     polypt
    57  6690 8473                               sty     polypt+1
    58  6692 205160                             jsr     romadd                          ; add in constant
    59  6695 a95e                               lda     #<tempf2                        ; multiply the original FAC
    60  6697 a000                               ldy     #>tempf2
    61  6699 c669                               dec     degree                          ; done?
    62  669b d0e4                               bne     l185_1
    63  669d 60                                 rts                                     ; yes
    64                          
    65                          ;.end
    66                          
    67                          ; ********************************************************************************************
    68                          ;
    69                          ;	Date		Changes
    70                          ;	====		=======
    71                          ;
    72                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: math/trigonometry.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      trigonometry.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Sine, Cosine, and Tangent Functions.
    16                          
    17                          
    18                          
    19                          ; Cosine function cos(x)=sin(x+pi/2)
    20                          
    21                          
    22  669e a923               cos             lda     #<pi2                           ; pointer to pi/2
    23  66a0 a05f                               ldy     #>pi2
    24  66a2 205160                             jsr     romadd                          ; add it in.  fall into sine
    25                          
    26                          
    27                          
    28                          ; Sine function
    29                          ;
    30                          ; Use identities to get FAC in quadrants I or IV.  The FAC is divided by 2*pi
    31                          ; and the integer part is ignored because sin(x+2*pi)=sin(x).  Then the
    32                          ; argument can be compared with pi/2 by comparing the result of the division
    33                          ; with pi/2(2*pi)=1/4.  Identities are then used to get the result in quadrants
    34                          ; I or IV.  An approximation polynomial is then used to compute sin(x).
    35                          
    36                          
    37  66a5 20a362             sin             jsr     movaf
    38  66a8 a928                               lda     #<twopi                         ; get pointer to divisor
    39  66aa a05f                               ldy     #>twopi
    40  66ac a66f                               ldx     argsgn                          ; get sign of result
    41  66ae 207161                             jsr     fdivf
    42  66b1 20a362                             jsr     movaf                           ; get result into ARG
    43  66b4 206363                             jsr     int                             ; integerize FAC
    44  66b7 a900                               lda     #0
    45  66b9 8570                               sta     arisgn                          ; always have the same sign
    46  66bb 20a85d                             jsr     fsubt                           ; keep only the fractional part
    47  66be a90a                               lda     #<fr4                           ; get pointer to 1/4
    48  66c0 a05f                               ldy     #>fr4
    49  66c2 205760                             jsr     romsub
    50  66c5 a568                               lda     facsgn                          ; save sign for later
    51  66c7 48                                 pha
    52  66c8 100d                               bpl     sin1                            ; first quadrant
    53  66ca 204d60                             jsr     faddh                           ; add 1/2 to FAC
    54  66cd a568                               lda     facsgn                          ; sign is negative?
    55  66cf 3009                               bmi     sin2
    56  66d1 a514                               lda     tansgn                          ; quads II and III come here
    57  66d3 49ff                               eor     #$ff
    58  66d5 8514                               sta     tansgn
    59                          
    60  66d7 20fc65             sin1            jsr     negop                           ; if positive, negate it
    61                          
    62  66da a90a               sin2            lda     #<fr4                           ; pointer to 1/4
    63  66dc a05f                               ldy     #>fr4
    64  66de 205160                             jsr     romadd                          ; add it in
    65  66e1 68                                 pla                                     ; get original quadrant
    66  66e2 1003                               bpl     l186_1
    67  66e4 20fc65                             jsr     negop                           ; if negative, negate result
    68                          
    69  66e7 a9b2               l186_1          lda     #<sincon
    70  66e9 a05f                               ldy     #>sincon
    71  66eb 836dff                             +lbra   polyx                           ; do approximation polyomial
    72                          
    73                          
    74                          
    75                          ; Tangent function
    76                          
    77                          
    78  66ee 203662             tan             jsr     mov1f                           ; move FAC into temporary
    79  66f1 a900                               lda     #0
    80  66f3 8514                               sta     tansgn                          ; remember whether to negate
    81  66f5 20a566                             jsr     sin                             ; compute the sin
    82  66f8 a250                               ldx     #<tempf3
    83  66fa a000                               ldy     #>tempf3
    84  66fc 203a62                             jsr     movmf                           ; put sign into other temp
    85  66ff a959                               lda     #<tempf1
    86  6701 a000                               ldy     #>tempf1
    87  6703 200e62                             jsr     movfm                           ; put this memory location into FAC
    88  6706 a900                               lda     #0
    89  6708 8568                               sta     facsgn                          ; start off positive
    90  670a a514                               lda     tansgn
    91  670c 201c67                             jsr     l187_1                          ; compute cosine
    92  670f a950                               lda     #<tempf3
    93  6711 a000                               ldy     #>tempf3                        ; address of sine value
    94                          ; bra fdiv ;divide sine by cosine and return
    95  6713 20f760                             jsr     conupk                          ; unpack constant    [910226] FAB
    96  6716 f32fc7                             +lbeq   overr                           ; overflow error     "
    97  6719 836afa                             +lbra   fdivt                           ; "
    98                          
    99  671c 48                 l187_1          pha                                     ; cosc.
   100  671d 80b8                               bra     sin1
   101                          
   102                          
   103                          ; Arctangent function
   104                          ;
   105                          ; Use identities to get arg between 0 and 1 and then use an approximation
   106                          ; polynomial to compute arctan(x).
   107                          
   108                          
   109  671f a568               atn             lda     facsgn                          ; what is sign?
   110  6721 48                                 pha                                     ; save for later
   111  6722 1003                               bpl     l188_1
   112  6724 20fc65                             jsr     negop                           ; if negative, negate FAC
   113                          ;use arctan(x)=-arctan(-x)
   114  6727 a563               l188_1          lda     facexp
   115  6729 48                                 pha                                     ; save this too for later
   116  672a c981                               cmp     #$81                            ; see if FAC >= 1.0
   117  672c 9007                               bcc     l188_2                          ; it is less than 1
   118  672e a999                               lda     #<fone                          ; get pntr to 1.0
   119  6730 a05f                               ldy     #>fone
   120  6732 205d60                             jsr     romdiv                          ; compute reciprocal
   121                          ;use aectan(x)=pi/2-arctan(1/x)
   122  6735 a9d1               l188_2          lda     #<atncon                        ; pointer to arctan constants
   123  6737 a05f                               ldy     #>atncon
   124  6739 205a66                             jsr     polyx
   125  673c 68                                 pla
   126  673d c981                               cmp     #$81                            ; was original argument < 1?
   127  673f 9007                               bcc     l188_3                          ; yes
   128  6741 a923                               lda     #<pi2
   129  6743 a05f                               ldy     #>pi2
   130  6745 205760                             jsr     romsub                          ; subtract arctan from pi/2
   131                          
   132  6748 68                 l188_3          pla                                     ; was original aurgument positive?
   133  6749 1003                               bpl     l188_4                          ; yes
   134  674b 83affe                             +lbra   negop                           ; if negative, negate result
   135                          
   136  674e 60                 l188_4          rts                                     ; all done
   137                          
   138                          ;.end
   139                          
   140                          ; ********************************************************************************************
   141                          ;
   142                          ;	Date		Changes
   143                          ;	====		=======
   144                          ;
   145                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/boot.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      boot.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;****************************************************************************
    16                          ; BOOT  Boot has three modes of operation...
    17                          ;
    18                          ;   1. *B*LOAD a given binary file and SYS to its load address.
    19                          ;   2. *D*LOAD a BASIC file named AUTOBOOT.C65* and RUN it.
    20                          ;   3. BOOT SYS loads the home sector to $0400 and JMPs to it.
    21                          ;
    22                          ; For modes 1 & 2, syntax is the same as BLOAD.  Differentiate
    23                          ; between the two modes via the presence of a filename.  All other
    24                          ; parameters, such as drive and device numbers, are utilized in the
    25                          ; normal manner.  For mode 3 there are no options.  It's intended
    26                          ; to boot a new OS.  BASIC is turned off if it's successful.  If it
    27                          ; fails, the run time stack & sprites might be corrupted.
    28                          ;****************************************************************************
    29                          
    30  674f c99e               boot            cmp     #sys_token                      ; BOOTSYS?      [910111]
    31  6751 d00d                               bne     l189_1                          ; no
    32  6753 208322                             jsr     chrget                          ; yes- eat token
    33  6756 2059ff                             jsr     _bootsys                        ; attempt to boot a new OS
    34  6759 902f                               bcc     l189_4                          ; returned to us after successful install
    35  675b a224                               ldx     #errbdk                         ; bootsys failed, report 'bad disk'????
    36  675d 83f0c6                             +lbra   error
    37                          
    38  6760 4f7e03             l189_1          bbr4    runmod,l189_2                   ; Error if in Edit mode     [910620]
    39  6763 83f4d5                             +lbra   edit_err
    40                          
    41  6766 a900               l189_2          lda     #0                              ; BOOT "filename"     [910417]
    42  6768 850c                               sta     verck                           ; want 'load', not 'verify'
    43  676a a9e6                               lda     #$e6                            ; set up parameters for DOS parser like BLOAD
    44  676c a2fc                               ldx     #$fc
    45  676e 202274                             jsr     dosprx                          ; parse the command
    46  6771 0f7f17                             bbr0    parsts,l189_5                   ; was there a filename?  branch if not
    47  6774 20ed71                             jsr     bload_boot                      ; yes- bload it
    48  6777 b3bd00                             +lbcs   erexit                          ; load error
    49                          
    50                          ; ldx current_bank ;assume no B(ank) arg was given    [910114]
    51                          ; bbr0 parstx,l189_3  ; correct, use current setup
    52  677a ae8c11                             ldx     dosbnk                          ; else use given bank number
    53  677d 8602               l189_3          stx     _bank
    54  677f a5ac                               lda     _starting_addr                  ; set up address BLOAD loaded to
    55  6781 8504                               sta     _pclo
    56  6783 a5ad                               lda     _starting_addr+1
    57  6785 8503                               sta     _pchi
    58  6787 206eff                             jsr     _jsr_far                        ; call it
    59  678a 60                 l189_4          rts
    60                          
    61  678b a0ff               l189_5          ldy     #$ff
    62  678d c8                 l189_6          iny                                     ; Copy default filename from ROM into buffer
    63  678e b92868                             lda     autoboot_filename,y
    64  6791 999111                             sta     savram,y
    65  6794 d0f7                               bne     l189_6                          ; null terminated
    66                          
    67  6796 8c8511                             sty     dosf1l                          ; length not counting terminator
    68  6799 e77e                               smb6    runmod                          ; set flag for load not to go to ready
    69  679b 207b71                             jsr     dload_boot                      ; Load it
    70  679e b39600                             +lbcs   erexit                          ; error if problems
    71  67a1 8320d6                             +lbra   run_a_program                   ; else go run it
    72                          
    73                          
    74                          ; AUTOBOOT_CSG Runs a system diagnostic if PB0 is low after initialization.
    75                          ;  Diagnostic is copied to RAM-0 from ROM-2 and jumped to.
    76                          
    77                          autobootCSG                                             ; Run ROMed diagnostic if PB0 low   [911105]
    78  67a4 ad01dd                             lda     $dd01
    79  67a7 4a                                 lsr
    80  67a8 b032                               bcs     autoboot                        ; no, try to boot from disk
    81                          
    82  67aa 78                                 sei                                     ; prevent IRQ from wacking code DL'd to $1xxx  [911106]
    83  67ab a20b                               ldx     #12-1
    84  67ad bdd067             l190_1          lda     l190_2,x                        ; prep DMA list
    85  67b0 9d4401                             sta     dma1_cmd,x
    86  67b3 ca                                 dex
    87  67b4 10f7                               bpl     l190_1
    88                          
    89  67b6 a900                               lda     #0
    90  67b8 a201                               ldx     #>dma1_cmd                      ; copy program from ROM to RAM
    91  67ba a044                               ldy     #<dma1_cmd
    92  67bc 8d02d7                             sta     dma_ctlr+2                      ; dma_list bank
    93  67bf 8e01d7                             stx     dma_ctlr+1                      ; dma_list hi
    94  67c2 8c00d7                             sty     dma_ctlr                        ; dma_list lo & trigger
    95                          
    96                          ; jmp run_a_program ;if 'program' was BASIC
    97                          ; lda #0   ;else set up arg's for call to 'long jmp'  [911105]
    98  67c5 8502                               sta     _bank
    99  67c7 8504                               sta     _pclo
   100  67c9 a910                               lda     #$10
   101  67cb 8503                               sta     _pchi
   102  67cd 4c71ff                             jmp     _jmp_far                        ; jump to code, no return.  NOTE: this *MAPs* RAM-0 into context!
   103                          
   104                          ; move from $024001 to $002001, $3FFF bytes  BASIC program
   105                          ;l190_2 .byte $00,$ff,$3f,$01,$40,$02,$01,$20,$00,$00,$00,$00
   106                          
   107                          ; move from $024000 to $1000, $4000 bytes   Diagnostic  [911105]
   108  67d0 0000400040020010...l190_2          !text $00,$00,$40,$00,$40,$02,$00,$10,$00,0,0,0
   109                          
   110                          
   111                          ; AUTOBOOT Attempts to RUN a disk program after cold startup.  The
   112                          ;  program must be a BASIC program called "AUTOBOOT.C65*"
   113                          
   114                          autoboot
   115  67dc a900                               lda     #0                              ; Select internal drive
   116  67de 8d80d0                             sta     fdc
   117  67e1 2c82d0             l191_1          bit     fdc+2                           ; busywait
   118  67e4 30fb                               bmi     l191_1
   119  67e6 ad83d0                             lda     fdc+3                           ; See if a diskette is present
   120  67e9 2908                               and     #$08
   121  67eb f03a                               beq     l191_3                          ; exit with no action taken if not
   122                          
   123  67ed a9e6                               lda     #$e6                            ; set up parameters for DOS parser like BLOAD
   124  67ef a2fc                               ldx     #$fc
   125  67f1 202274                             jsr     dosprx                          ; let the parser init DOS stuff
   126                          
   127  67f4 a0ff                               ldy     #$ff
   128  67f6 c8                 l191_2          iny                                     ; Copy filename from ROM into buffer
   129  67f7 b92868                             lda     autoboot_filename,y
   130  67fa 999111                             sta     savram,y
   131  67fd d0f7                               bne     l191_2                          ; null terminated
   132  67ff 8c8511                             sty     dosf1l                          ; length not counting terminator
   133                          
   134  6802 a941                               lda     #%01000001                      ; set flag for load indicating autoboot
   135  6804 857e                               sta     runmod                          ; set flag for load not to go to ready
   136  6806 207b71                             jsr     dload_boot                      ; skip parser & load it
   137                          
   138  6809 a900                               lda     #0                              ; clear autoboot flags
   139  680b 857e                               sta     runmod
   140  680d da                                 phx                                     ; save end address
   141  680e 5a                                 phy
   142  680f 20b7ff                             jsr     _readst                         ; get status report, but check it later
   143  6812 48                                 pha
   144  6813 209a78                             jsr     Suck_DS                         ; clear any DOS errors (to kill error LED)
   145  6816 68                                 pla                                     ; now check I/O status
   146  6817 7a                                 ply
   147  6818 fa                                 plx
   148  6819 29bf                               and     #$bf                            ; EOI is okay
   149  681b d00a                               bne     l191_3                          ; outside problems
   150  681d b008                               bcs     l191_3                          ; inside problems
   151                          
   152  681f 8682                               stx     text_top                        ; success- set end address & run it
   153  6821 8483                               sty     text_top+1
   154  6823 58                                 cli
   155  6824 839dd5                             +lbra   run_a_program
   156                          
   157  6827 60                 l191_3          rts                                     ; failure- go_ready
   158                          
   159                          
   160                          autoboot_filename
   161  6828 4155544f424f4f54...                !text "AUTOBOOT.C65*",0
   162                          
   163                          
   164                          
   165                          
   166  6836 aa                 erexit          tax                                     ; set termination flags
   167  6837 d316c6                             +lbne   error                           ; normal error
   168  683a 8395c4                             +lbra   break_exit                      ; user break
   169                          
   170                          
   171                          
   172  683d 20d2ff             outch           jsr     _bsout
   173  6840 b0f4                               bcs     erexit
   174  6842 60                                 rts
   175                          
   176                          
   177                          
   178  6843 20cfff             inchr           jsr     _basin
   179  6846 b0ee                               bcs     erexit
   180  6848 60                                 rts
   181                          
   182                          
   183                          coout
   184                          ; jsr put_io_in_map
   185  6849 20c9ff                             jsr     _chkout
   186  684c 20c169                             jsr     dschk                           ; see if device # >=4, and clear DS if so
   187  684f b0e5                               bcs     erexit                          ; take error exit of there was one
   188  6851 60                                 rts
   189                          
   190                          
   191                          coin
   192                          ; jsr put_io_in_map
   193  6852 20c6ff                             jsr     _chkin
   194  6855 20c169                             jsr     dschk                           ; see if device # >=4, and clear DS if so
   195  6858 b0dc                               bcs     erexit
   196  685a 60                                 rts
   197                          
   198                          cgetl
   199                          ; jsr put_io_in_map
   200  685b 20e4ff                             jsr     _getin
   201  685e b371c4                             +lbcs   break_exit                      ; 'stop' key was pressed
   202  6861 60                                 rts
   203                          
   204                          
   205  6862 202569             save            jsr     plsv                            ; parse parameters, dschk
   206                          
   207                          
   208                          savenp                                                  ; Save Program (from DSave)
   209  6865 a682                               ldx     text_top                        ; ending address
   210  6867 a483                               ldy     text_top+1
   211  6869 a92d                               lda     #<txttab                        ; pointer to start address
   212                          
   213                          
   214                          savenb                                                  ; Save Binary (from BSave & KEY SAVE)
   215                          ; jsr put_io_in_map
   216  686b 20d8ff                             jsr     _savesp                         ; save it
   217                          
   218                          ; Any changes to the following code must be duplicated at:
   219                          ;  bload
   220                          ;  load (load_file)
   221                          
   222                          exit_disk_op
   223                          exit_disk_operation
   224  686e 08                                 php                                     ; preserve kernel error status (.c)
   225  686f 48                                 pha                                     ; preserve kernel error # (.a)
   226  6870 206e72                             jsr     print_dos_error                 ; print DOS error msg if any only in direct mode
   227  6873 68                                 pla
   228  6874 28                                 plp
   229  6875 900f                               bcc     l192_3                          ; branch if no error (rts)
   230  6877 ff7e0a                             bbs7    runmod,l192_2                   ; branch if run mode (erexit)
   231  687a c904                               cmp     #errfnf                         ; is it 'file not found' catch-all?
   232  687c d005                               bne     l192_1                          ; no  (erexit)
   233  687e 8dc702                             sta     errnum                          ; yes- save error # for 'er'
   234  6881 0980                               ora     #$80                            ; but no errdis
   235  6883 38                 l192_1          sec
   236  6884 b0b0               l192_2          bcs     erexit                          ; exit if kernel problem (rts)
   237  6886 60                 l192_3          rts
   238                          
   239                          
   240  6887 a901               verify          lda     #1                              ; verify flag
   241  6889 2c                                 !text $2c                               ; skip two bytes
   242                          
   243  688a a900               load            lda     #0                              ; load flag
   244  688c 850c                               sta     verck
   245  688e 4f7e03             l193_1          bbr4    runmod,l193_2                   ; Error if in Edit mode     [910620]
   246  6891 83c6d4                             +lbra   edit_err
   247  6894 202569             l193_2          jsr     plsv                            ; parse parameters, dschk
   248                          
   249                          cld10                                                   ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< entry from dload
   250                          ; jsr put_io_in_map
   251  6897 a50c                               lda     verck
   252  6899 a62d                               ldx     txttab                          ; .x and .y have alt...
   253  689b a42e                               ldy     txttab+1                        ; ...load address
   254                          
   255                          ; Any changes to the following code must be duplicated at:
   256                          ;  bload
   257                          ;  save (exit_disk_op)
   258                          
   259                          load_file
   260  689d 20d5ff                             jsr     _loadsp                         ; load it
   261  68a0 8f7e36                             bbs0    runmod,cld20                    ; skip error checks if autoboot (rts)
   262  68a3 da                                 phx                                     ; save end address
   263  68a4 5a                                 phy
   264  68a5 08                                 php                                     ; save kernel load status (.c)
   265  68a6 48                                 pha                                     ; save kernel error # (.a)
   266  68a7 20b7ff                             jsr     _readst                         ; save I/O status byte
   267  68aa 857f                               sta     parsts
   268  68ac 206e72                             jsr     print_dos_error                 ; report error msg if any only in direct mode
   269  68af 68                                 pla                                     ; restore error stuff
   270  68b0 28                                 plp
   271  68b1 9010                               bcc     l194_3                          ; branch if no error (rts)
   272  68b3 ff7e0a                             bbs7    runmod,l194_2                   ; branch if run mode (erexit)
   273  68b6 c904                               cmp     #errfnf                         ; is it 'file not found' catch-all?
   274  68b8 d005                               bne     l194_1                          ; no  (erexit)
   275  68ba 8dc702                             sta     errnum                          ; yes- save error # for 'er'
   276  68bd 0980                               ora     #$80                            ; but no errdis
   277  68bf 38                 l194_1          sec
   278  68c0 b374ff             l194_2          +lbcs   erexit                          ; exit if kernel problem
   279  68c3 7a                 l194_3          ply                                     ; restore end address
   280  68c4 fa                                 plx
   281  68c5 a50c                               lda     verck
   282  68c7 f011                               beq     cld50                           ; was load
   283                          
   284                          ; Finish verify
   285                          
   286                          verify_check
   287  68c9 a21c                               ldx     #ervfy                          ; assume error
   288                          ; jsr _readst  ;read status
   289  68cb cf7f14                             bbs4    parsts,cld55                    ; branch if 'verify' error
   290  68ce ff7e08                             bbs7    runmod,cld20                    ; branch if not direct mode
   291                          verify_ok
   292  68d1 207dff                             jsr     _primm
   293  68d4 0d4f4b0d00                         !text cr,"OK", cr,0
   294  68d9 60                 cld20           rts
   295                          
   296                          
   297                          
   298                          ; Finish load
   299                          
   300                          cld50
   301                          ; jsr _readst  ;check I/O status
   302  68da a57f                               lda     parsts
   303  68dc 29bf                               and     #%10111111                      ; EOI is okay, so mask it
   304  68de f005                               beq     cld60                           ; good- finish load operation
   305                          
   306                          load_error
   307  68e0 a21d                               ldx     #erload
   308  68e2 836bc5             cld55           +lbra   error
   309                          
   310                          
   311  68e5 8682               cld60           stx     text_top
   312  68e7 8483                               sty     text_top+1                      ; end load address
   313                          
   314  68e9 ff7e0c                             bbs7    runmod,cld70                    ; branch if not direct mode
   315  68ec ef7eea                             bbs6    runmod,cld20                    ; special "RUN file_name" flag...get out here (rts)
   316                          
   317  68ef 20b930                             jsr     link_program                    ; relink
   318  68f2 20a134                             jsr     runc                            ; clear vars
   319  68f5 83f6c5                             +lbra   ready_2                         ; print 'ready' & return to main
   320                          
   321                          
   322                          ; Program load
   323                          
   324  68f8 201f35             cld70           jsr     reset_txtptr
   325  68fb 20b930                             jsr     link_program
   326  68fe 8306cc                             +lbra   fload
   327                          
   328                          
   329  6901 207469             open            jsr     paoc                            ; parse statement
   330  6904 20c0ff                             jsr     _open                           ; open it
   331  6907 8009                               bra     close_out_1
   332                          
   333                          
   334                          
   335  6909 207469             close           jsr     paoc                            ; parse statement
   336                          ; jsr put_io_in_map
   337  690c a54b                               lda     andmsk                          ; get la
   338                          
   339                          
   340                          close_out                                               ; enter with .a=LA   [900725]
   341  690e 18                                 clc                                     ; flag a real close
   342  690f 20c3ff                             jsr     _close                          ; close it
   343                          
   344                          close_out_1
   345  6912 08                                 php
   346  6913 48                                 pha
   347  6914 a5ba                               lda     _fa                             ; special error checking if disk op
   348  6916 c908                               cmp     #8
   349  6918 9005                               bcc     l195_1
   350  691a 68                                 pla
   351  691b 28                                 plp
   352  691c 8350ff                             +lbra   exit_disk_operation             ; disk
   353                          
   354  691f 68                 l195_1          pla                                     ; something else
   355  6920 28                                 plp
   356  6921 b313ff                             +lbcs   erexit
   357  6924 60                                 rts
   358                          
   359                          
   360                          ; Parse LOAD, SAVE, & VERIFY commands
   361                          
   362                          plsv
   363  6925 a900                               lda     #0                              ; set default filename (none)
   364  6927 20bdff                             jsr     _setnam
   365  692a ae0611                             ldx     _default_drive                  ; set default device # (dosffn)
   366  692d a000                               ldy     #0                              ; command 0
   367  692f 20baff                             jsr     _setlfs
   368  6932 a584                               lda     text_bank                       ; all loads to   bank 0 ???? set default memory banks
   369  6934 a685                               ldx     var_bank                        ; all names from bank 1 ????   [910620]
   370  6936 206bff                             jsr     _setbank
   371                          
   372  6939 206169                             jsr     paoc20                          ; by-pass junk
   373  693c 20b869                             jsr     paoc15                          ; get/set file name
   374  693f 206169                             jsr     paoc20                          ; by-pass junk
   375  6942 205b69                             jsr     plsv7                           ; get ',fa'
   376  6945 a000                               ldy     #0                              ; command 0
   377  6947 864b                               stx     andmsk
   378  6949 20baff                             jsr     _setlfs
   379  694c 206169                             jsr     paoc20                          ; by-pass junk
   380  694f 205b69                             jsr     plsv7                           ; get ',sa'
   381  6952 8a                                 txa                                     ; new command
   382  6953 a8                                 tay
   383  6954 a64b                               ldx     andmsk                          ; device #
   384  6956 20baff                             jsr     _setlfs
   385  6959 8066                               bra     dschk                           ; make dosfa current   [900801]
   386                          
   387                          
   388                          
   389                          ; Look for comma followed by byte
   390                          
   391  695b 206969             plsv7           jsr     paoc30
   392  695e 830cf4                             +lbra   getbyt
   393                          
   394                          
   395                          
   396                          ; Skip return if next char is end
   397                          
   398  6961 208522             paoc20          jsr     chrgot
   399  6964 d002                               bne     paocx
   400  6966 68                                 pla
   401  6967 68                                 pla
   402  6968 60                 paocx           rts
   403                          
   404                          
   405                          
   406                          ; Check for comma and good stuff
   407                          
   408  6969 205b4e             paoc30          jsr     chkcom                          ; check comma
   409                          
   410  696c 208522             paoc32          jsr     chrgot                          ; get current character
   411  696f d0f7                               bne     paocx                           ; is okay
   412  6971 83d7c4                             +lbra   snerr                           ; bad...end of line
   413                          
   414                          
   415                          ; Parse OPEN/CLOSE
   416                          
   417  6974 a900               paoc            lda     #sys_bank                       ; ????      [910620]
   418  6976 a685                               ldx     var_bank                        ;
   419  6978 206bff                             jsr     _setbank                        ; filename bank     (string bank)????
   420  697b 20bdff                             jsr     _setnam                         ; default file name (null)
   421  697e 206c69                             jsr     paoc32                          ; must get something
   422  6981 206c5d                             jsr     getbyt                          ; get la
   423  6984 864b                               stx     andmsk
   424  6986 8a                                 txa
   425  6987 ae0611                             ldx     _default_drive                  ; default device
   426  698a a000                               ldy     #0                              ; default command
   427  698c 20baff                             jsr     _setlfs                         ; store it
   428  698f 206169                             jsr     paoc20                          ; skip junk
   429  6992 205b69                             jsr     plsv7
   430  6995 864c                               stx     eormsk
   431  6997 a000                               ldy     #0                              ; default sa (command)
   432  6999 a54b                               lda     andmsk                          ; get la
   433  699b e003                               cpx     #3
   434  699d 9001                               bcc     l196_1
   435  699f 88                                 dey                                     ; if sa not given and fa=serial bus, default to $ff
   436  69a0 20baff             l196_1          jsr     _setlfs                         ; store them
   437  69a3 206169                             jsr     paoc20                          ; skip junk
   438  69a6 205b69                             jsr     plsv7                           ; get sa
   439  69a9 8a                                 txa
   440  69aa a8                                 tay
   441  69ab a64c                               ldx     eormsk
   442  69ad a54b                               lda     andmsk
   443  69af 20baff                             jsr     _setlfs                         ; set up real everything
   444  69b2 206169                             jsr     paoc20
   445  69b5 206969                             jsr     paoc30
   446                          
   447  69b8 20675b             paoc15          jsr     frmstr                          ; do frmevl, frestr. return with len in a, index =~string
   448  69bb 20dd5b                             jsr     getspa                          ; ????fixes old PET bug- load"string",val(chr$(56)) [910917]
   449                          ; ldx index1
   450                          ; ldy index1+1
   451  69be 20bdff                             jsr     _setnam                         ; bank always set at plsv
   452                          ;fall into dschk     [900801]
   453                          
   454                          
   455                          
   456  69c1 08                 dschk           php                                     ; check if current device >=8, and clear DS if so
   457  69c2 48                                 pha
   458  69c3 a5ba                               lda     _fa
   459  69c5 c901                               cmp     #1
   460  69c7 d005                               bne     l197_1
   461  69c9 ad0611                             lda     _default_drive
   462  69cc 85ba                               sta     _fa
   463  69ce c908               l197_1          cmp     #8                              ; ????     [900807]
   464  69d0 9006                               bcc     l197_2
   465  69d2 8d8211                             sta     dosfa                           ; also make last DOS device = current device
   466  69d5 208278                             jsr     Clear_DS
   467  69d8 68                 l197_2          pla
   468  69d9 28                                 plp
   469  69da 60                                 rts
   470                          
   471                          
   472                          ;k_readst
   473                          ; jsr put_io_in_map
   474                          ; jmp _readst
   475                          
   476                          
   477                          
   478                          ;k_setlfs
   479                          ; jsr put_io_in_map
   480                          ; jmp _setlfs
   481                          
   482                          
   483                          
   484                          ;k_setnam
   485                          ; jsr put_io_in_map
   486                          ; jmp _setnam
   487                          
   488                          
   489                          
   490                          ;k_basin
   491                          ; jsr put_io_in_map
   492                          ; jmp _basin
   493                          
   494                          
   495                          ;k_bsout
   496                          ; jsr put_io_in_map
   497                          ; jmp _bsout
   498                          
   499                          
   500                          ;k_clrch
   501                          ; jsr put_io_in_map
   502                          ; jmp _clrch
   503                          
   504                          
   505                          
   506                          ;k_close
   507                          ; jsr put_io_in_map
   508                          ; jmp _close
   509                          
   510                          
   511                          
   512                          ;k_clall
   513                          ; jsr put_io_in_map
   514                          ; jmp _clall
   515                          
   516                          
   517                          
   518                          ;k_primm
   519                          ; jsr put_io_in_map
   520                          ; jmp _primm
   521                          
   522                          
   523                          ;k_setbank
   524                          ; jsr put_io_in_map
   525                          ; jmp _setbank
   526                          ; rts
   527                          
   528                          
   529                          ;k_plot
   530                          ; sta sw_rom_ram0  ;????
   531                          ; jmp _plot
   532                          
   533                          
   534                          ;k_stop
   535                          ; jsr put_io_in_map
   536                          ; jmp _stop
   537                          
   538                          ;.end
   539                          
   540                          ; ********************************************************************************************
   541                          ;
   542                          ;	Date		Changes
   543                          ;	====		=======
   544                          ;
   545                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/text/printusing.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      printusing.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ; Print Using - Formatted print routine
    15                          ;
    16                          ; Entered by cmd, print, or print#
    17                          ; Syntax:  PRINT USING"****";a;b;c
    18                          
    19  69db 202c2e24           pudefs          !text " ,.$"                            ; default:  fill, comma, dec pnt, money symbol
    20                          
    21  69df a2ff               using           ldx     #$ff
    22  69e1 8eeb11                             stx     endfd
    23  69e4 208322                             jsr     chrget
    24  69e7 20ef4c                             jsr     frmevl                          ; evaluate format string
    25  69ea 20dd4c                             jsr     chkstr                          ; must be string type...
    26                          
    27  69ed a566                               lda     facmo                           ; save temp descriptor
    28  69ef 48                                 pha
    29  69f0 a567                               lda     facmo+1
    30  69f2 48                                 pha
    31                          
    32  69f3 a002                               ldy     #2                              ; move (facmo),1&2 to form,form+1
    33  69f5 20a922             l198_1          jsr     indfmo
    34  69f8 88                                 dey
    35  69f9 993f00                             sta     form,y
    36  69fc d0f7                               bne     l198_1
    37                          
    38  69fe 20a922                             jsr     indfmo                          ; get length
    39  6a01 8dea11                             sta     lfor
    40  6a04 a8                                 tay
    41  6a05 f00b                               beq     l198_3                          ; syntax error if length is zero
    42                          
    43  6a07 88                 l198_2          dey
    44  6a08 209d22                             jsr     indfrm
    45  6a0b c923                               cmp     #'#'                            ; at least one # in format?
    46  6a0d f006                               beq     l198_4                          ; yes...
    47  6a0f 98                                 tya                                     ; no...end of format
    48  6a10 d0f5                               bne     l198_2                          ; no...
    49  6a12 8336c4             l198_3          +lbra   snerr                           ; yes...syntax error
    50                          
    51                          
    52  6a15 a93b               l198_4          lda     #';'                            ; '
    53  6a17 205d4e             eex2            jsr     synchr                          ; check character
    54  6a1a 8476                               sty     z_p_temp_1                      ; clear flag for anaf
    55  6a1c 8cd811                             sty     bnr                             ; set pointer to begin of no
    56  6a1f 20ef4c                             jsr     frmevl                          ; evaluate expression
    57  6a22 7f0f39                             bbr7    valtyp,conv                     ; branch if numeric
    58                          
    59  6a25 20536c                             jsr     ini                             ; init counters and flags
    60  6a28 20a16d                             jsr     anaf                            ; analyze format
    61  6a2b aee011                             ldx     chsn                            ; > or = in format field
    62  6a2e f015                               beq     prcha                           ; branch if not
    63  6a30 a200                               ldx     #0
    64  6a32 38                                 sec
    65  6a33 ade611                             lda     cform
    66  6a36 e577                               sbc     hulp                            ; .a=room left in field
    67  6a38 900b                               bcc     prcha                           ; branch if no room left
    68  6a3a a23d                               ldx     #'='
    69  6a3c ece011                             cpx     chsn                            ; = in field
    70  6a3f d003                               bne     l199_1                          ; branch if not
    71  6a41 4a                                 lsr                                     ; .a=.a/2
    72  6a42 6900                               adc     #0                              ; add 1 if odd
    73                          
    74  6a44 aa                 l199_1          tax                                     ; store no of blanks in x
    75  6a45 a000               prcha           ldy     #0
    76  6a47 8a                 chx             txa
    77  6a48 f005                               beq     cpef                            ; branch if no blanks
    78  6a4a ca                                 dex
    79                          
    80  6a4b a920               oblk            lda     #' '                            ; output a blank
    81  6a4d 8008                               bra     outc                            ; always
    82                          
    83                          
    84  6a4f c477               cpef            cpy     hulp                            ; end of string reached?
    85  6a51 b0f8                               bcs     oblk                            ; output blank if yes
    86  6a53 20d522                             jsr     indin1_ram1                     ; lda (index),y
    87  6a56 c8                                 iny
    88                          
    89  6a57 209a6d             outc            jsr     cdout                           ; output character
    90  6a5a d0eb                               bne     chx                             ; branch if not ready
    91  6a5c 8029                               bra     reay
    92                          
    93                          
    94                          
    95  6a5e 208f64             conv            jsr     fout                            ; convert mfp to decimal
    96                          
    97  6a61 a0ff                               ldy     #$ff                            ; build descriptor for fout string
    98  6a63 c8                 l200_1          iny                                     ; how big IS it?
    99  6a64 b90001                             lda     fbuffr,y
   100  6a67 d0fa                               bne     l200_1
   101  6a69 98                                 tya
   102  6a6a 207b5a                             jsr     strspa                          ; jsr getspa,stx dsctmp+1,sty dsctmp+2,sta dsctmp,rts
   103                          
   104  6a6d da                                 phx
   105  6a6e a000                               ldy     #0
   106  6a70 a264                               ldx     #dsctmp+1
   107  6a72 b90001             l200_2          lda     fbuffr,y
   108  6a75 f006                               beq     l200_3
   109  6a77 20f022                             jsr     sta_far_ram1                    ; sta (dsctmp+1),y
   110  6a7a c8                                 iny
   111  6a7b d0f5                               bne     l200_2
   112                          
   113  6a7d fa                 l200_3          plx
   114  6a7e 20d05a                             jsr     putnew
   115  6a81 20536c                             jsr     ini                             ; init counters and flags
   116  6a84 20a46a                             jsr     fform                           ; output one formatted number
   117                          
   118  6a87 208522             reay            jsr     chrgot                          ; get old character
   119  6a8a c92c                               cmp     #','                            ; comma?
   120  6a8c f089                               beq     eex2                            ; continue print use if yes
   121  6a8e 38                                 sec
   122  6a8f 6676                               ror     z_p_temp_1                      ; set flag for anaf
   123  6a91 20a16d                             jsr     anaf                            ; print rest of format
   124  6a94 7a                                 ply                                     ; restore descriptor
   125  6a95 68                                 pla
   126  6a96 20715b                             jsr     fretmp
   127  6a99 208522                             jsr     chrgot
   128  6a9c c93b                               cmp     #';'                            ; semi-colon?
   129  6a9e d357cd                             +lbne   crdo                            ; end of print using
   130  6aa1 4c8322                             jmp     chrget                          ; branch if yes
   131                          
   132                          
   133                          ; ********************************************************************************************
   134                          ;
   135                          ;	Date		Changes
   136                          ;	====		=======
   137                          ;
   138                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/fform.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      fform.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;  FFORM - output a number to format
    15                          ;
    16                          ;  Number is in fbuffr,  format checked by anaf
    17                          
    18                          fform
    19                          ; sta sw_rom_ram0 ;????
    20  6aa4 add411                             lda     pufill
    21  6aa7 8de811                             sta     blfd                            ; set working fill char
    22  6aaa a9ff                               lda     #$ff
    23  6aac 8de711             ana             sta     sno                             ; save blank or '-' in sno
    24  6aaf 8002                               bra     insy
    25                          
    26                          
    27  6ab1 867f               stp             stx     point                           ; set point pointer
    28  6ab3 c477               insy            cpy     hulp                            ; end of no reached?
    29  6ab5 f032                               beq     eoa                             ; branch if yes
    30  6ab7 b90001                             lda     fbuffr,y                        ; get character of no
    31  6aba c8                                 iny
    32  6abb c920                               cmp     #' '                            ; blank?
    33  6abd f0f4                               beq     insy                            ; yes...span
    34  6abf c92d                               cmp     #'-'                            ; sign no negative
    35  6ac1 f0e9                               beq     ana                             ; yes...
    36  6ac3 c92e                               cmp     #'.'                            ; decimal point?
    37  6ac5 f0ea                               beq     stp                             ; yes...
    38  6ac7 c945                               cmp     #'E'                            ; is char 'e'?
    39  6ac9 f010                               beq     lsg                             ; yes...
    40  6acb 9d0001                             sta     fbuffr,x                        ; move number
    41  6ace 8ed911                             stx     enr                             ; update end-no pointer
    42  6ad1 e8                                 inx
    43  6ad2 247f                               bit     point                           ; point pointer set?
    44  6ad4 10dd                               bpl     insy                            ; yes...
    45  6ad6 eedf11                             inc     vn                              ; count digits before point
    46  6ad9 80d8                               bra     insy
    47                          
    48                          
    49  6adb b90001             lsg             lda     fbuffr,y
    50  6ade c92d                               cmp     #'-'                            ; sign of exponent negative
    51  6ae0 d003                               bne     l201_1                          ; no...
    52  6ae2 6edd11                             ror     usgn                            ; make sign negative
    53  6ae5 c8                 l201_1          iny
    54  6ae6 8cde11                             sty     uexp                            ; set exponent pointer
    55                          
    56  6ae9 a57f               eoa             lda     point                           ; decimal found?
    57  6aeb 1002                               bpl     l202_1                          ; yes...
    58  6aed 867f                               stx     point                           ; no...add point
    59                          
    60  6aef 20a16d             l202_1          jsr     anaf                            ; analyze format
    61  6af2 ade111                             lda     vf
    62  6af5 c9ff                               cmp     #$ff
    63  6af7 f029                               beq     l202_3                          ; field overflow
    64  6af9 ade411                             lda     fesp                            ; exponent in field
    65  6afc f03f                               beq     cff                             ; convert to f format if not
    66  6afe adde11                             lda     uexp                            ; exponent in number?
    67  6b01 d012                               bne     l202_2                          ; yes...
    68  6b03 aed911                             ldx     enr
    69  6b06 20286c                             jsr     et2                             ; add exponent to number
    70  6b09 de0201                             dec     fbuffr+2,x
    71  6b0c e8                                 inx
    72  6b0d 8ede11                             stx     uexp
    73  6b10 20af6c                             jsr     alg                             ; delete leading zeros
    74  6b13 f025                               beq     hup                             ; all zero
    75                          
    76  6b15 ace311             l202_2          ldy     posp                            ; + or - in format?
    77  6b18 d017                               bne     sswe                            ; yes...
    78  6b1a ace711                             ldy     sno                             ; +?
    79  6b1d 3012                               bmi     sswe                            ; yes...
    80  6b1f ade111                             lda     vf
    81                          
    82  6b22 f068               l202_3          beq     errf                            ; no room for sign
    83  6b24 cee111                             dec     vf                              ; reserve room
    84  6b27 d005                               bne     l202_4
    85  6b29 ade211                             lda     nf                              ; one #?
    86  6b2c f05e                               beq     errf                            ; yes...error
    87                          
    88  6b2e eedc11             l202_4          inc     swe
    89                          
    90  6b31 20a36b             sswe            jsr     shpn                            ; shift decimal point
    91  6b34 206d6c                             jsr     uround                          ; round number
    92  6b37 20a36b                             jsr     shpn                            ; shift again if necessary
    93                          
    94  6b3a 839401             hup             +lbra   chout                           ; output number
    95                          
    96                          
    97                          
    98  6b3d acde11             cff             ldy     uexp                            ; exponent in no?
    99  6b40 f015                               beq     l203_2                          ; no...
   100  6b42 8577                               sta     hulp                            ; delete exponent
   101  6b44 38                                 sec                                     ; adjust decimal point
   102  6b45 6ee511                             ror     etof                            ; set e-to-f flag
   103  6b48 a47f                               ldy     point
   104  6b4a addd11                             lda     usgn                            ; exec nos3 or nos4
   105  6b4d 1005                               bpl     l203_1                          ; depends on sign of exp
   106  6b4f 20db6b                             jsr     nos3
   107  6b52 800c                               bra     l203_3
   108                          
   109  6b54 20bd6b             l203_1          jsr     nos4
   110                          
   111  6b57 a47f               l203_2          ldy     point                           ; at start of no?
   112  6b59 f005                               beq     l203_3                          ; yes...
   113  6b5b 20b36c                             jsr     cho                             ; no = 0 ?
   114  6b5e f005                               beq     l203_4                          ; yes...no round
   115                          
   116  6b60 206d6c             l203_3          jsr     uround
   117  6b63 8003                               bra     l203_5
   118                          
   119  6b65 cedf11             l203_4          dec     vn                              ; adjust...no was 0
   120  6b68 38                 l203_5          sec
   121  6b69 ade111                             lda     vf
   122  6b6c eddf11                             sbc     vn
   123  6b6f 901b                               bcc     errf                            ; no fit...error
   124  6b71 8ddc11                             sta     swe                             ; save difference
   125  6b74 ace311                             ldy     posp                            ; + or -?
   126  6b77 d01b                               bne     ahp                             ; yes...
   127  6b79 ace711                             ldy     sno                             ; get sign
   128  6b7c 3016                               bmi     ahp                             ; positive...
   129  6b7e a8                                 tay
   130  6b7f f00b                               beq     errf                            ; no room for sign
   131  6b81 88                                 dey
   132  6b82 d013                               bne     ldvn                            ; swe<>1
   133  6b84 ade211                             lda     nf
   134  6b87 0ddf11                             ora     vn                              ; both zero?
   135  6b8a d0ae                               bne     hup                             ; no...
   136                          
   137                          
   138  6b8c a92a               errf            lda     #'*'                            ; format error
   139  6b8e 209a6d             stout           jsr     cdout                           ; fill field with stars
   140  6b91 d0fb                               bne     stout
   141  6b93 60                                 rts
   142                          
   143                          
   144  6b94 a8                 ahp             tay                                     ; output no if swe=0
   145  6b95 f0a3                               beq     hup
   146  6b97 addf11             ldvn            lda     vn
   147  6b9a d09e                               bne     hup                             ; vn<>0
   148  6b9c cedc11                             dec     swe                             ; add extra 0
   149  6b9f e676                               inc     z_p_temp_1                      ; before decimal point
   150  6ba1 8097                               bra     hup
   151                          
   152                          
   153                          ; Using- shift decimal point
   154                          
   155  6ba3 38                 shpn            sec
   156  6ba4 ade111                             lda     vf
   157  6ba7 eddf11                             sbc     vn
   158  6baa f038                               beq     rdy                             ; format o.k
   159  6bac a47f                               ldy     point
   160  6bae 9016                               bcc     pntl                            ; vf<vn
   161  6bb0 8577                               sta     hulp
   162                          
   163  6bb2 ccd911             incy            cpy     enr                             ; end of no reached?
   164  6bb5 f002                               beq     ity
   165  6bb7 b001                               bcs     nos1                            ; yes...
   166                          
   167  6bb9 c8                 ity             iny
   168  6bba eedf11             nos1            inc     vn
   169  6bbd 20f16b             nos4            jsr     eado                            ; adjust exponent
   170  6bc0 c677                               dec     hulp                            ; ready?
   171  6bc2 d0ee                               bne     incy                            ; no...
   172  6bc4 f01c                               beq     poit
   173                          
   174  6bc6 49ff               pntl            eor     #$ff
   175  6bc8 6901                               adc     #1
   176  6bca 8577                               sta     hulp                            ; =vn-vf
   177                          
   178  6bcc ccd811             decy            cpy     bnr                             ; begin of no?
   179  6bcf f006                               beq     inz1                            ; yes...
   180  6bd1 88                                 dey
   181  6bd2 cedf11                             dec     vn
   182  6bd5 8002                               bra     inz2
   183                          
   184                          
   185  6bd7 e676               inz1            inc     z_p_temp_1                      ; add leading zeros
   186  6bd9 a980               inz2            lda     #$80
   187  6bdb 20f36b             nos3            jsr     eadj                            ; adjust exponent
   188  6bde c677                               dec     hulp                            ; ready?
   189  6be0 d0ea                               bne     decy                            ; no...
   190                          
   191  6be2 847f               poit            sty     point                           ; decimal point pointer
   192  6be4 60                 rdy             rts
   193                          
   194                          
   195                          ; Using- adjust exponent
   196                          
   197  6be5 d039               sexp            bne     retrn                           ; no over/underflow
   198  6be7 4909                               eor     #$09                            ; .a is 0 or 9
   199  6be9 9d0001                             sta     fbuffr,x                        ; digit back in exp
   200  6bec ca                                 dex                                     ; = 0 or 9
   201  6bed ecde11                             cpx     uexp
   202  6bf0 60                                 rts
   203                          
   204                          
   205  6bf1 a900               eado            lda     #0
   206  6bf3 aede11             eadj            ldx     uexp
   207  6bf6 e8                                 inx
   208  6bf7 2ce511                             bit     etof                            ; e-to-f flag on?
   209  6bfa 3010                               bmi     l204_2                          ; yes...
   210  6bfc 4ddd11                             eor     usgn
   211  6bff f00b                               beq     l204_2                          ; ++ or --
   212                          
   213  6c01 20366c             l204_1          jsr     tag3                            ; inc exp, overflow?
   214  6c04 20e56b                             jsr     sexp                            ; digit 0 if yes
   215  6c07 b0f8                               bcs     l204_1                          ; try second digit
   216  6c09 833cc2                             +lbra   overr                           ; exp>99
   217                          
   218  6c0c bd0001             l204_2          lda     fbuffr,x
   219  6c0f de0001                             dec     fbuffr,x                        ; decrement exp
   220  6c12 c930                               cmp     #'0'                            ; underflow on digit?
   221  6c14 20e56b                             jsr     sexp                            ; set digit=9 if yes...
   222  6c17 b0f3                               bcs     l204_2                          ; try 2nd digit
   223  6c19 2ce511                             bit     etof                            ; flag off?
   224  6c1c 1005                               bpl     et3                             ; yes...
   225  6c1e 847f                               sty     point                           ; decimal point pointer
   226                          
   227  6c20 68                 retrn           pla
   228  6c21 68                                 pla
   229  6c22 60                                 rts                                     ; return to fform/main
   230                          
   231                          
   232  6c23 addd11             et3             lda     usgn
   233  6c26 4980                               eor     #$80                            ; reverse sign exp
   234  6c28 8ddd11             et2             sta     usgn
   235  6c2b a930                               lda     #'0'
   236  6c2d 9d0101                             sta     fbuffr+1,x                      ; exp<0 here
   237  6c30 a931                               lda     #'1'
   238  6c32 9d0201                             sta     fbuffr+2,x
   239  6c35 60                                 rts
   240                          
   241                          
   242  6c36 bd0001             tag3            lda     fbuffr,x                        ; get digit of exp
   243  6c39 fe0001                             inc     fbuffr,x                        ; increment digit
   244  6c3c c939                               cmp     #'9'                            ; overflow
   245  6c3e 60                                 rts                                     ; return .z set
   246                          
   247                          
   248                          ; Using- ansub: load format field char in .a
   249                          
   250  6c3f 18                 ansub           clc
   251  6c40 c8                                 iny                                     ; begin format?
   252  6c41 f005                               beq     l205_1                          ; yes...
   253  6c43 ccea11                             cpy     lfor                            ; end?
   254  6c46 9004                               bcc     l205_2                          ; no...
   255                          
   256  6c48 a476               l205_1          ldy     z_p_temp_1                      ; <>0?
   257  6c4a d0d4                               bne     retrn                           ; yes...
   258                          
   259  6c4c 209d22             l205_2          jsr     indfrm
   260  6c4f eee611                             inc     cform                           ; pointer to field
   261  6c52 60                                 rts
   262                          
   263                          
   264                          ;  Using- ini: init counters and flags
   265                          
   266  6c53 206d5b             ini             jsr     frefac                          ; free temp descriptor
   267  6c56 8577                               sta     hulp                            ; length string
   268  6c58 a20a                               ldx     #$0a                            ; printed in hulp
   269  6c5a a900                               lda     #0
   270                          
   271  6c5c 9ddc11             l206_1          sta     swe,x                           ; init working registers
   272  6c5f ca                                 dex
   273  6c60 10fa                               bpl     l206_1
   274  6c62 8edb11                             stx     flag                            ; comma flag =ff
   275  6c65 867f                               stx     point                           ; point pointer=ff
   276  6c67 8eda11                             stx     dolr                            ; dollar flag=ff
   277  6c6a aa                                 tax                                     ; x=y=0
   278  6c6b a8                                 tay
   279  6c6c 60                                 rts
   280                          
   281                          
   282                          ; Using- round number
   283                          
   284  6c6d 18                 uround          clc
   285  6c6e a57f                               lda     point
   286  6c70 6de211                             adc     nf                              ; overflow?
   287  6c73 b039                               bcs     rrts                            ; yes...
   288  6c75 38                                 sec
   289  6c76 e576                               sbc     z_p_temp_1                      ; underflow?
   290  6c78 9034                               bcc     rrts                            ; yes...
   291  6c7a cdd911                             cmp     enr                             ; anything to round?
   292  6c7d f002                               beq     l207_1                          ; yes...
   293  6c7f b02d                               bcs     rrts                            ; no...
   294                          
   295  6c81 cdd811             l207_1          cmp     bnr                             ; again...
   296  6c84 9028                               bcc     rrts                            ; no...
   297  6c86 aa                                 tax
   298  6c87 bd0001                             lda     fbuffr,x                        ; get digit
   299  6c8a c935                               cmp     #'5'                            ; <5 ?
   300  6c8c 9020                               bcc     rrts                            ; yes...no round
   301                          
   302  6c8e ecd811             l207_2          cpx     bnr                             ; begin of no reached?
   303  6c91 f00a                               beq     l207_3                          ; yes..add 1
   304  6c93 ca                                 dex
   305  6c94 20366c                             jsr     tag3                            ; increment digit
   306  6c97 8ed911                             stx     enr                             ; new end of no pointer
   307  6c9a f0f2                               beq     l207_2                          ; branch on overflow
   308  6c9c 60                                 rts
   309                          
   310  6c9d a931               l207_3          lda     #'1'
   311  6c9f 9d0001                             sta     fbuffr,x
   312  6ca2 e8                                 inx
   313  6ca3 867f                               stx     point
   314  6ca5 c676                               dec     z_p_temp_1                      ; # of 0's before '.'
   315  6ca7 1005                               bpl     rrts                            ; no underflow
   316  6ca9 e676                               inc     z_p_temp_1                      ; underflow...back to 0
   317  6cab eedf11                             inc     vn
   318  6cae 60                 rrts            rts
   319                          
   320                          
   321                          ; Using- alg: delete leading zeros of no
   322                          
   323  6caf a47f               alg             ldy     point                           ; start with a .?
   324  6cb1 f017                               beq     szer                            ; yes...
   325                          
   326  6cb3 acd811             cho             ldy     bnr
   327  6cb6 b90001             cmo             lda     fbuffr,y                        ; start with a 0?
   328  6cb9 c930                               cmp     #'0'
   329  6cbb 60                                 rts
   330                          
   331                          
   332  6cbc e67f               nbr             inc     point                           ; adjust point
   333  6cbe 20f16b                             jsr     eado                            ; and exponent
   334  6cc1 eed811                             inc     bnr                             ; and pointer to begin of no
   335  6cc4 ccd911                             cpy     enr                             ; end of number?
   336  6cc7 f0e5                               beq     rrts                            ; yes...
   337  6cc9 c8                                 iny
   338                          
   339  6cca 20b66c             szer            jsr     cmo                             ; zero in no?
   340  6ccd f0ed                               beq     nbr                             ; yes...
   341  6ccf 60                                 rts                                     ; no...
   342                          
   343                          
   344                          ; Using- chout: print number
   345                          
   346  6cd0 adda11             chout           lda     dolr                            ; dollar flag set?
   347  6cd3 3002                               bmi     l208_1                          ; no...
   348  6cd5 e676                               inc     z_p_temp_1                      ; make room for $
   349                          
   350  6cd7 aed811             l208_1          ldx     bnr                             ; start of #
   351  6cda ca                                 dex
   352  6cdb ace911                             ldy     begfd                           ; begin of field
   353                          
   354  6cde 209d22             afrm            jsr     indfrm
   355  6ce1 c8                                 iny
   356  6ce2 c92c                               cmp     #','                            ; comma?
   357  6ce4 d00f                               bne     punt                            ; no...
   358  6ce6 2cdb11                             bit     flag                            ; comma flag on?
   359  6ce9 3005                               bmi     bout                            ; yes, do a fill char
   360                          ; sta sw_rom_ram0 ;????
   361  6ceb add511                             lda     pucoma
   362  6cee 8064                               bra     out                             ; no,...output a comma char
   363                          
   364                          
   365  6cf0 ade811             bout            lda     blfd
   366  6cf3 805f                               bra     out
   367                          
   368                          
   369  6cf5 c92e               punt            cmp     #'.'                            ; decimal point?
   370  6cf7 d005                               bne     afplus
   371                          ; sta sw_rom_ram0 ;????
   372  6cf9 add611                             lda     pudot                           ; yes...
   373  6cfc 8056                               bra     out
   374                          
   375                          
   376  6cfe c92b               afplus          cmp     #'+'                            ; plus?
   377  6d00 f03a                               beq     ispl                            ; yes...
   378  6d02 c92d                               cmp     #'-'                            ; minus?
   379  6d04 f031                               beq     ispl1                           ; yes...
   380  6d06 c95e                               cmp     #'^'                            ; up arrow?
   381  6d08 d070                               bne     pndd                            ; no...
   382  6d0a a945                               lda     #'E'
   383  6d0c 209a6d                             jsr     cdout
   384  6d0f acde11                             ldy     uexp
   385  6d12 20b66c                             jsr     cmo                             ; first dig of exp zero?
   386  6d15 d006                               bne     l209_1                          ; no...
   387  6d17 c8                                 iny
   388  6d18 20b66c                             jsr     cmo                             ; second digit?
   389  6d1b f007                               beq     l209_2                          ; yes
   390                          
   391  6d1d a92d               l209_1          lda     #'-'
   392  6d1f 2cdd11                             bit     usgn
   393  6d22 3002                               bmi     l209_3
   394                          
   395  6d24 a92b               l209_2          lda     #'+'
   396  6d26 209a6d             l209_3          jsr     cdout                           ; output sign exp
   397  6d29 aede11                             ldx     uexp
   398  6d2c bd0001                             lda     fbuffr,x
   399  6d2f 209a6d                             jsr     cdout                           ; output first dig exp
   400  6d32 aceb11                             ldy     endfd
   401  6d35 8013                               bra     telx
   402                          
   403  6d37 ade711             ispl1           lda     sno                             ; positive?
   404  6d3a 30b4                               bmi     bout                            ; yes...out blank or *
   405  6d3c ade711             ispl            lda     sno                             ; output sgn
   406  6d3f 8013                               bra     out
   407                          
   408                          
   409  6d41 a576               zerot           lda     z_p_temp_1                      ; # of zeros
   410  6d43 d017                               bne     zerot1
   411  6d45 ecd911                             cpx     enr                             ; end of # reached?
   412  6d48 f005                               beq     zout                            ; yes...output zero
   413                          
   414  6d4a e8                 telx            inx
   415  6d4b bd0001                             lda     fbuffr,x                        ; get digit
   416  6d4e 2c                                 !text $2c                               ; skip
   417                          
   418  6d4f a930               zout            lda     #'0'                            ; output zero
   419                          
   420  6d51 4edb11             outs            lsr     flag                            ; clear comma flag
   421                          
   422  6d54 209a6d             out             jsr     cdout                           ; output character
   423  6d57 f355ff                             +lbeq   rrts
   424  6d5a 8082                               bra     afrm                            ; not ready...
   425                          
   426                          
   427  6d5c c676               zerot1          dec     z_p_temp_1                      ; count leading zeros
   428  6d5e adda11                             lda     dolr                            ; $ flag set?
   429  6d61 30ec                               bmi     zout                            ; no...output zero
   430                          
   431  6d63 209d22                             jsr     indfrm                          ; take a peek at the next character in the format string
   432  6d66 c92c                               cmp     #','                            ; if it's a comma, we got problems
   433  6d68 d007                               bne     l210_1                          ; ...branch if no comma & resume normal processing
   434                          
   435  6d6a ade811                             lda     blfd                            ; here's the "$,999.99" bug fix:
   436  6d6d 209a6d                             jsr     cdout                           ; print a 'fill' character instead of the '$'
   437  6d70 c8                                 iny                                     ; and increment format string pointer past comma
   438                          
   439  6d71 38                 l210_1          sec                                     ; resume normal processing
   440  6d72 6eda11                             ror     dolr                            ; clear the dollar flag & go on to print '$'
   441                          ; sta sw_rom_ram0 ;????
   442  6d75 add711                             lda     pumony
   443  6d78 80d7                               bra     outs                            ; output money symbol
   444                          
   445                          
   446  6d7a addc11             pndd            lda     swe                             ; # of blanks
   447  6d7d f0c2                               beq     zerot
   448  6d7f cedc11                             dec     swe                             ; count !
   449                          
   450  6d82 d36cff             l211_1          +lbne   bout                            ; out blank or *
   451  6d85 ade311                             lda     posp                            ; + or - in field?
   452  6d88 30f8                               bmi     l211_1                          ; yes...out blank or *
   453                          
   454  6d8a 209d22             l211_2          jsr     indfrm
   455  6d8d c92c                               cmp     #','                            ; comma?
   456  6d8f d0a6                               bne     ispl1                           ; no...out sign
   457  6d91 ade811                             lda     blfd                            ; yes...
   458  6d94 209a6d                             jsr     cdout                           ; out blank or *
   459  6d97 c8                                 iny
   460  6d98 80f0                               bra     l211_2
   461                          
   462                          
   463                          
   464  6d9a 203d68             cdout           jsr     outch ;outdo                    ; char out
   465  6d9d cee611                             dec     cform                           ; count it
   466  6da0 60                                 rts
   467                          
   468                          
   469                          ; Using- anaf: analyze format
   470                          
   471  6da1 aceb11             anaf            ldy     endfd                           ; format pointer
   472  6da4 203f6c             gfor            jsr     ansub
   473  6da7 20536e                             jsr     comp                            ; check special chars
   474  6daa d014                               bne     pchar                           ; no match...
   475  6dac 8ce911                             sty     begfd                           ; save beginning of field
   476  6daf 9019                               bcc     ffoun                           ; # was found
   477  6db1 aa                                 tax                                     ; save char
   478                          
   479  6db2 203f6c             sfur            jsr     ansub                           ; get next format char
   480  6db5 b005                               bcs     l212_1                          ; stop on wrap-around
   481  6db7 205b6e                             jsr     com1                            ; compare specials
   482  6dba f009                               beq     foun1                           ; found some...
   483                          
   484  6dbc ace911             l212_1          ldy     begfd
   485  6dbf 8a                                 txa
   486  6dc0 203d68             pchar           jsr     outch ;outdo                    ; out character
   487  6dc3 80df                               bra     gfor
   488                          
   489                          
   490  6dc5 b0eb               foun1           bcs     sfur                            ; no #...keep looking
   491  6dc7 ace911                             ldy     begfd
   492  6dca a676               ffoun           ldx     z_p_temp_1
   493  6dcc d078                               bne     trts
   494  6dce 8ee611                             stx     cform
   495  6dd1 88                                 dey
   496                          
   497  6dd2 cee611             hyo2            dec     cform                           ; correct counter
   498  6dd5 203f6c             hyo             jsr     ansub                           ; get next format char
   499  6dd8 b072                               bcs     efo                             ; end of format
   500  6dda c92c                               cmp     #','                            ; comma?
   501  6ddc f0f7                               beq     hyo                             ; yes...ignore it
   502  6dde 202a6e                             jsr     isp                             ; + or - in format?
   503  6de1 90ef                               bcc     hyo2                            ; yes...
   504  6de3 c92e                               cmp     #'.'                            ; decimal point?
   505  6de5 d008                               bne     avf1                            ; no...
   506  6de7 e8                                 inx
   507  6de8 e002                               cpx     #2                              ; more than 1 decimal?
   508  6dea 90e9                               bcc     hyo                             ; no...
   509  6dec 835cc0             ero             +lbra   snerr                           ; yes...syntax error
   510                          
   511                          
   512  6def 205f6e             avf1            jsr     com2                            ; =, >, or # in field
   513  6df2 d00a                               bne     llar                            ; no...
   514  6df4 9003                               bcc     hyo1                            ; was #
   515  6df6 8de011                             sta     chsn                            ; was > or =
   516                          
   517  6df9 fee111             hyo1            inc     vf,x
   518  6dfc 80d7                               bra     hyo
   519                          
   520  6dfe c924               llar            cmp     #'$'                            ; dollar?
   521  6e00 d00e                               bne     expo                            ; no...
   522  6e02 2cda11                             bit     dolr                            ; test flag
   523  6e05 10f2                               bpl     hyo1                            ; no...
   524  6e07 18                                 clc
   525  6e08 6eda11                             ror     dolr                            ; set flag
   526  6e0b cee111                             dec     vf
   527  6e0e 80e9                               bra     hyo1
   528                          
   529  6e10 c95e               expo            cmp     #'^'                            ; up arrow?
   530  6e12 d016                               bne     isp                             ; no...
   531  6e14 a202                               ldx     #$02
   532  6e16 203f6c             l213_1          jsr     ansub                           ; must be 4 up arrows
   533  6e19 b0d1                               bcs     ero
   534  6e1b c95e                               cmp     #'^'                            ; up arrow?
   535  6e1d d0cd                               bne     ero
   536  6e1f ca                                 dex
   537  6e20 10f4                               bpl     l213_1
   538  6e22 eee411                             inc     fesp                            ; set exp flag
   539  6e25 203f6c                             jsr     ansub                           ; next format char
   540  6e28 b022                               bcs     efo                             ; end of format
   541                          
   542  6e2a c92b               isp             cmp     #'+'                            ; plus?
   543  6e2c d019                               bne     chom                            ; no...
   544  6e2e ade711                             lda     sno                             ; sign neg?
   545  6e31 1005                               bpl     spos                            ; yes...
   546  6e33 a92b                               lda     #'+'
   547  6e35 8de711                             sta     sno
   548                          
   549  6e38 ade311             spos            lda     posp                            ; + or - already?
   550  6e3b d0af                               bne     ero
   551  6e3d 6ee311                             ror     posp                            ; make posp neg/clc
   552  6e40 8ceb11                             sty     endfd                           ; end field pointer
   553  6e43 eee611                             inc     cform                           ; correct counter
   554  6e46 60                 trts            rts
   555                          
   556                          
   557  6e47 c92d               chom            cmp     #'-'                            ; minus?
   558  6e49 f0ed                               beq     spos                            ; yes...
   559  6e4b 38                                 sec
   560  6e4c 8ceb11             efo             sty     endfd                           ; end field pointer
   561  6e4f ceeb11                             dec     endfd
   562  6e52 60                                 rts
   563                          
   564                          
   565                          ; Using- comp: compare .a with symbols
   566                          
   567  6e53 c92b               comp            cmp     #'+'
   568  6e55 f015                               beq     rt
   569  6e57 c92d                               cmp     #'-'
   570  6e59 f011                               beq     rt
   571                          
   572  6e5b c92e               com1            cmp     #'.'
   573  6e5d f00d                               beq     rt
   574                          
   575  6e5f c93d               com2            cmp     #'='
   576  6e61 f009                               beq     rt
   577  6e63 c93e                               cmp     #'>'
   578  6e65 f005                               beq     rt
   579  6e67 c923                               cmp     #'#'
   580  6e69 d001                               bne     rt
   581  6e6b 18                                 clc
   582  6e6c 60                 rt              rts
   583                          
   584                          ;.end
   585                          
   586                          
   587                          
   588                          ; ********************************************************************************************
   589                          ;
   590                          ;	Date		Changes
   591                          ;	====		=======
   592                          ;
   593                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/instr.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      instr.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ;  INSTRing - Find position of str1 in str2 at or after position n
    14                          ;
    15                          ; Usage: INSTR(a$,b${,n})
    16                          
    17  6e6d a566               instr           lda     facmo                           ; save pointer to temporary descriptors
    18  6e6f 8dd302                             sta     tmpdes
    19  6e72 a567                               lda     facmo+1
    20  6e74 8dd402                             sta     tmpdes+1
    21                          
    22  6e77 20ef4c                             jsr     frmevl                          ; get next arg
    23  6e7a 20dd4c                             jsr     chkstr                          ; must be string
    24  6e7d a566                               lda     facmo
    25  6e7f 8dd502                             sta     tmpdes+2
    26  6e82 a567                               lda     facmo+1
    27  6e84 8dd602                             sta     tmpdes+3
    28                          
    29  6e87 a201                               ldx     #1                              ; default starting position
    30  6e89 8667                               stx     faclo
    31  6e8b 208522                             jsr     chrgot
    32  6e8e c929                               cmp     #')'                            ; any length argument?
    33  6e90 f003                               beq     l214_1                          ; branch if not
    34  6e92 20825d                             jsr     combyt                          ; else go get a one byte argument
    35                          
    36  6e95 20554e             l214_1          jsr     chkcls                          ; look for )
    37  6e98 a667                               ldx     faclo
    38  6e9a f362e3                             +lbeq   fcerr                           ; starting position can't be 0
    39  6e9d ca                                 dex
    40  6e9e 8663                               stx     positn
    41                          
    42  6ea0 a203                               ldx     #3                              ; copy 'pointers to temp descriptors' to zero page
    43  6ea2 bdd302             l214_2          lda     tmpdes,x
    44  6ea5 9559                               sta     ptarg1,x
    45  6ea7 ca                                 dex
    46  6ea8 10f8                               bpl     l214_2
    47                          
    48  6eaa a002                               ldy     #2                              ; now get the descriptors
    49  6eac a959               l214_3          lda     #ptarg1
    50  6eae 20d722                             jsr     lda_far_ram1                    ; lda (ptarg1),y
    51  6eb1 995d00                             sta     str1,y
    52  6eb4 a95b                               lda     #ptarg2
    53  6eb6 20d722                             jsr     lda_far_ram1                    ; lda (ptarg2),y
    54  6eb9 996000                             sta     str2,y
    55  6ebc 88                                 dey
    56  6ebd 10ed                               bpl     l214_3
    57                          
    58  6ebf a560                               lda     str2                            ; check if string 2 is null
    59  6ec1 f03b                               beq     l214_8                          ; if so, return 0
    60                          
    61  6ec3 a900               l214_4          lda     #0
    62  6ec5 8564                               sta     match
    63  6ec7 18                                 clc
    64  6ec8 a560                               lda     str2                            ; length of string 2
    65  6eca 6563                               adc     positn
    66  6ecc b030                               bcs     l214_8                          ; too long, not found
    67  6ece c55d                               cmp     str1                            ; see if > length of string 1
    68  6ed0 9002                               bcc     l214_5                          ; < len string 1
    69  6ed2 d02a                               bne     l214_8                          ; must be >, not found
    70                          
    71  6ed4 a464               l214_5          ldy     match
    72  6ed6 c460                               cpy     str2                            ; if match len = str len, then found
    73  6ed8 f01f                               beq     l214_7
    74  6eda 98                                 tya
    75  6edb 18                                 clc
    76  6edc 6563                               adc     positn                          ; compare str1(s+p+m) with str2(m)
    77  6ede a8                                 tay
    78  6edf a95e                               lda     #str1+1
    79  6ee1 20d722                             jsr     lda_far_ram1                    ; lda (str1+1),y
    80  6ee4 8578                               sta     syntmp
    81  6ee6 a464                               ldy     match
    82  6ee8 a961                               lda     #str2+1
    83  6eea 20d722                             jsr     lda_far_ram1                    ; lda (str2+1),y
    84  6eed c578                               cmp     syntmp
    85  6eef f004                               beq     l214_6
    86  6ef1 e663                               inc     positn                          ; not the same, start over from next positn
    87  6ef3 80ce                               bra     l214_4                          ; always
    88                          
    89  6ef5 e664               l214_6          inc     match                           ; count characters that match
    90  6ef7 80db                               bra     l214_5                          ; always
    91                          
    92                          
    93  6ef9 e663               l214_7          inc     positn                          ; found
    94  6efb a563                               lda     positn
    95  6efd 2c                                 !text $2c
    96                          
    97  6efe a900               l214_8          lda     #0                              ; not found
    98                          ; sta sw_rom_ram0 ;????
    99  6f00 48                                 pha
   100  6f01 add502                             lda     tmpdes+2                        ; free temp descriptors
   101  6f04 acd602                             ldy     tmpdes+3
   102  6f07 20715b                             jsr     fretmp
   103                          ; sta sw_rom_ram0 ;????
   104  6f0a add302                             lda     tmpdes
   105  6f0d acd402                             ldy     tmpdes+1
   106  6f10 20715b                             jsr     fretmp
   107  6f13 7a                                 ply
   108  6f14 83bce9                             +lbra   sngflt                          ; float 1 byte in .y
   109                          
   110                          ;.end
   111                          
   112                          
   113                          
   114                          
   115                          ; ********************************************************************************************
   116                          ;
   117                          ;	Date		Changes
   118                          ;	====		=======
   119                          ;
   120                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/type.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      type.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; TYPE  types a given disk (SEQ) file to output channel
    14                          ;
    15                          
    16  6f17 a300               type            ldz     #0
    17                          
    18                          open_SEQ_file
    19  6f19 db                                 phz                                     ; save EDIT load flag    [910620]
    20  6f1a a9e6                               lda     #$e6                            ; parse:  filename [,U#] [,D#]
    21  6f1c 202074                             jsr     dosprs                          ; (like dopen:      0 0 0 *  * 0 0 1 )
    22  6f1f 20dc77                             jsr     chk1                            ; check parameters
    23  6f22 201d71                             jsr     find_la                         ; find an available LA
    24  6f25 200d71                             jsr     find_sa                         ; find an available SA
    25  6f28 a011                               ldy     #fopnseq
    26  6f2a a206                               ldx     #6
    27  6f2c 20fd70                             jsr     open_file                       ; open the file
    28  6f2f b3f6c3                             +lbcs   list_err                        ; exit if error
    29  6f32 fb                                 plz                                     ; [910620]
    30  6f33 f001                               beq     l215_1
    31  6f35 60                                 rts                                     ; or exit if called by EDIT load routine
    32                          
    33  6f36 20e1ff             l215_1          jsr     _stop                           ; check stop key
    34  6f39 f03c                               beq     l215_6                          ; exit if down
    35  6f3b ae8111                             ldx     dosla
    36  6f3e 20c6ff                             jsr     _chkin                          ; get input channel
    37  6f41 b034                               bcs     l215_6                          ; exit if bad??
    38  6f43 a200                               ldx     #0
    39  6f45 e0ff               l215_2          cpx     #255                            ; check buffer (buflen????)
    40                          ; bcs 99$   ; 'too long' error
    41  6f47 f011                               beq     l215_3                          ; allow long lines   [910620]
    42  6f49 20cfff                             jsr     _basin                          ; read file data
    43  6f4c 9d0013                             sta     dosstr,x                        ; buffer it
    44  6f4f e8                                 inx                                     ; bump buffer pointer
    45  6f50 a8                                 tay                                     ; save char
    46  6f51 20b7ff                             jsr     _readst                         ; check channel status
    47  6f54 d004                               bne     l215_3                          ; exit if eof or error
    48  6f56 c00d                               cpy     #cr
    49  6f58 d0eb                               bne     l215_2                          ; loop until eol
    50                          
    51  6f5a 08                 l215_3          php                                     ; save input channel status (beq=eol, bne=eof/err)
    52  6f5b 8e7b11                             stx     t4                              ; save character count
    53  6f5e 20c770                             jsr     dcato                           ; get output channel
    54  6f61 a200                               ldx     #0
    55  6f63 ec7b11             l215_4          cpx     t4                              ; check buffer
    56  6f66 b009                               bcs     l215_5                          ; end of buffered data
    57  6f68 bd0013                             lda     dosstr,x                        ; output data
    58  6f6b 20d2ff                             jsr     _bsout
    59  6f6e e8                                 inx                                     ; bump buffer pointer
    60  6f6f d0f2                               bne     l215_4                          ; loop until end of buffer
    61                          
    62  6f71 20ccff             l215_5          jsr     _clrch
    63  6f74 28                                 plp                                     ; check input status
    64  6f75 f0bf                               beq     l215_1                          ; loop until eof or bad status
    65                          
    66  6f77 83a7c3             l215_6          +lbra   list_exit                       ; release channel, close file, return to main
    67                          
    68                          ;99$ jsr _clrch  ;non-I/O trouble   removed [910620]
    69                          ; lda dosla  ; shut down disk & report BASIC error
    70                          ; clc
    71                          ; jsr _close
    72                          ; bra errlen  ;buffer overflow: report 'string too long'
    73                          
    74                          
    75                          ; ********************************************************************************************
    76                          ;
    77                          ;	Date		Changes
    78                          ;	====		=======
    79                          ;
    80                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/disk.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      disk.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; DISK "command_string" [,U#] [,D#]     new [910123]
    16                          
    17                          disk
    18  6f7a a9f6                               lda     #$f6                            ; parse:  command_string [,U#]
    19  6f7c 202074                             jsr     dosprs
    20  6f7f 20dc77                             jsr     chk1                            ; check parameters
    21  6f82 a900                               lda     #doslfn                         ; la (reserved la)
    22  6f84 8d8111                             sta     dosla
    23  6f87 a96f                               lda     #$6f
    24  6f89 8d8311                             sta     dossa                           ; sa (command channel)
    25  6f8c a053                               ldy     #fdisk
    26  6f8e a202                               ldx     #2                              ; add "/" [911108]
    27  6f90 20fd70                             jsr     open_file                       ; open command channel & send command string
    28  6f93 08                                 php                                     ; save error status    [910404]
    29  6f94 48                                 pha
    30  6f95 a900                               lda     #doslfn                         ; close it
    31  6f97 38                                 sec                                     ; not a real close
    32  6f98 20c3ff                             jsr     _close                          ; close it
    33  6f9b 68                                 pla                                     ; [910404]
    34  6f9c 28                                 plp
    35  6f9d 83cff8                             +lbra   exit_disk_op                    ; common error check & exit path ????
    36                          
    37                          
    38                          ;.end
    39                          
    40                          ; ********************************************************************************************
    41                          ;
    42                          ;	Date		Changes
    43                          ;	====		=======
    44                          ;
    45                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: dos/setup.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      setup.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; These routines take tokens and values after the following BASIC keywords:
    16                          ;
    17                          ;  DOPEN,   DCLOSE,  APPEND,  CONCAT, RECORD
    18                          ;  DLOAD,   DSAVE,   DVERIFY, BLOAD,  BSAVE
    19                          ;  FORMAT,  COLLECT, BACKUP,  COPY
    20                          ;  CATALOG, RENAME,  SCRATCH, DCLEAR
    21                          ;
    22                          ; It then parses the following line and finds syntax errors, checks for values
    23                          ; out of range, and sets variables in the zero-page to be passed to the disk
    24                          ; message generator.
    25                          
    26                          
    27                          directory                                               ; display disk directory (catalog)
    28  6fa0 208522                             jsr     chrgot                          ; get current chr
    29  6fa3 c9fe                               cmp     #esc_command_token              ; eat dirECTORY kludge if it's there
    30  6fa5 d00b                               bne     l216_1
    31  6fa7 208322                             jsr     chrget                          ; (esc token + another)
    32  6faa c929                               cmp     #ectory_token
    33  6fac d39cbe                             +lbne   snerr
    34  6faf 208322                             jsr     chrget                          ; yes- get next good char
    35                          
    36  6fb2 201e74             l216_1          jsr     dospar                          ; parse the line
    37  6fb5 a57f                               lda     parsts                          ; check options
    38  6fb7 29e6                               and     #$e6
    39  6fb9 d38fbe                             +lbne   snerr
    40                          
    41  6fbc a001                               ldy     #fdir                           ; table offset for directory
    42  6fbe 2c8f11                             bit     dosflags                        ; want recoverable files? [901024]
    43  6fc1 5002                               bvc     l216_2                          ; no
    44  6fc3 a005                               ldy     #fdirr                          ; yes
    45  6fc5 a201               l216_2          ldx     #1                              ; just $
    46  6fc7 a57f                               lda     parsts                          ; check for default
    47  6fc9 2911                               and     #$11                            ; no drive?
    48  6fcb f006                               beq     l216_4
    49  6fcd 4a                                 lsr
    50  6fce 9002                               bcc     l216_3                          ; just drive
    51  6fd0 e8                                 inx                                     ; drive and filename
    52  6fd1 e8                                 inx
    53  6fd2 e8                 l216_3          inx
    54  6fd3 8a                 l216_4          txa                                     ; a now has length
    55  6fd4 20f276                             jsr     sendp                           ; build
    56                          
    57  6fd7 a200                               ldx     #sys_bank                       ; set banks????  fname in system space, bank0 [910620]
    58  6fd9 8a                                 txa                                     ; (load bank is don't care- we're not actually loading)
    59  6fda 206bff                             jsr     _setbank
    60                          
    61  6fdd a060                               ldy     #$60                            ; sa, load floppy
    62  6fdf ae8211                             ldx     dosfa
    63  6fe2 a900                               lda     #doslfn                         ; lfn
    64  6fe4 20baff                             jsr     _setlfs                         ; set file parameters
    65  6fe7 20c0ff                             jsr     _open                           ; open it...
    66  6fea 9009                               bcc     l216_5                          ; ...ok
    67  6fec 48                                 pha
    68  6fed 204f70                             jsr     dcat11                          ; ...error, shut down and report
    69  6ff0 fa                                 plx
    70  6ff1 38                                 sec
    71  6ff2 835bbe                             +lbra   error
    72                          
    73  6ff5 a515               l216_5          lda     channl                          ; determine DIR vs LDIR
    74  6ff7 d05e                               bne     ldir                            ; if output channel not default (screen)
    75                          ; use LDIR
    76                          
    77                          ; Get length in blocks
    78                          
    79  6ff9 a200               dir             ldx     #doslfn
    80  6ffb 20c6ff                             jsr     _chkin
    81  6ffe b04f                               bcs     dcat11                          ; if problem??
    82  7000 20b7ff                             jsr     _readst                         ; check status
    83  7003 d04a                               bne     dcat11                          ; exit if bad status
    84  7005 20f737                             jsr     crdo                            ; output new line
    85  7008 a003                               ldy     #3                              ; loop counter
    86                          
    87  700a 8c7911             dcat3           sty     t3                              ; save counter
    88                          
    89  700d 20cfff             l217_1          jsr     _basin                          ; get char
    90  7010 8d7b11                             sta     t4
    91  7013 20cfff                             jsr     _basin                          ; get char
    92  7016 8d7c11                             sta     t4+1
    93  7019 20b7ff                             jsr     _readst                         ; check status
    94  701c d031                               bne     dcat11                          ; exit if eof or bad status
    95  701e ce7911                             dec     t3
    96  7021 d0ea                               bne     l217_1                          ; if not done
    97                          
    98                          ; Output blocks number
    99                          
   100  7023 ae7b11                             ldx     t4
   101  7026 ad7c11                             lda     t4+1
   102  7029 207f64                             jsr     linprt                          ; output number
   103  702c a920                               lda     #' '
   104  702e 20d2ff                             jsr     _bsout                          ; output a space
   105                          
   106                          ; Get name & output it
   107                          
   108  7031 20b7ff             dcat4           jsr     _readst                         ; get status
   109  7034 d016                               bne     dcat10                          ; if bad status
   110  7036 20cfff                             jsr     _basin                          ; get char
   111  7039 f005                               beq     dcat5                           ; if eol
   112  703b 20d2ff                             jsr     _bsout                          ; echo char
   113  703e 80f1                               bra     dcat4                           ; continue to process name until eol or err
   114                          
   115                          ; Here on end of name
   116                          
   117  7040 20f737             dcat5           jsr     crdo                            ; output new line
   118  7043 20e1ff                             jsr     _stop                           ; check stop key
   119  7046 f007                               beq     dcat11                          ; exit if stop request
   120                          
   121                          ; Process next
   122                          
   123  7048 a002                               ldy     #2                              ; perform 2 times
   124  704a 80be                               bra     dcat3
   125                          
   126                          
   127                          ; Exit directory
   128                          
   129  704c 20f737             dcat10          jsr     crdo                            ; flush current line
   130  704f 20b438             dcat11          jsr     release_channels                ; release cmd channel, restore terminal
   131  7052 a900                               lda     #doslfn
   132  7054 83b8f8                             +lbra   close_out                       ; [900725]
   133                          
   134                          
   135                          ; ********************************************************************************************
   136                          ;
   137                          ;	Date		Changes
   138                          ;	====		=======
   139                          ;
   140                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/ldir.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      ldir.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; LDIR  same as DIR, except it buffers each line to reduce
    14                          ;       talker/listener turnaround time.  Even so, it is still
    15                          ; unacceptably slow for normal screen output, which is
    16                          ; why it was split out from the original DIRECTORY routine.
    17                          ;
    18                          
    19                          ; Read block count
    20                          
    21                          ldir
    22  7057 a9c0                               lda     #$c0                            ; serial bus kludge for open4,4:cmd4:dir ????
    23  7059 2d09d6                             and     $d609
    24  705c 1c09d6                             trb     $d609                           ; disable fast serial bus
    25  705f 8586                               sta     sid_speed_flag                  ; but save enables so we can restore them
    26                          
    27  7061 a003                               ldy     #3                              ; loop counter (3=skip fake load adr & link bytes)
    28  7063 8c7911             l218_1          sty     t3                              ; save counter
    29  7066 a200                               ldx     #doslfn
    30  7068 20c6ff                             jsr     _chkin
    31  706b b053                               bcs     ldir_end                        ; problem??
    32                          
    33  706d 20b7ff             l218_2          jsr     _readst                         ; check status
    34  7070 d04e                               bne     ldir_end                        ; exit if bad status
    35  7072 20cfff                             jsr     _basin                          ; get block count
    36  7075 8d0013                             sta     dosstr                          ; buffer it
    37  7078 20cfff                             jsr     _basin
    38  707b 8d0113                             sta     dosstr+1
    39  707e ce7911                             dec     t3
    40  7081 d0ea                               bne     l218_2                          ; continue eating bytes until we have block count
    41                          
    42                          ; Read filename
    43                          
    44  7083 a201                               ldx     #1                              ; buffer index-1
    45  7085 e8                 l218_3          inx
    46  7086 20b7ff                             jsr     _readst                         ; check status
    47  7089 d035                               bne     ldir_end                        ; exit if eof or bad status
    48  708b 20cfff                             jsr     _basin                          ; buffer next character
    49  708e 9d0013                             sta     dosstr,x
    50  7091 d0f2                               bne     l218_3                          ; loop until eol (null terminator)
    51                          
    52                          ; Print one line of directory
    53                          
    54  7093 20c770                             jsr     dcato                           ; get output channel
    55  7096 ae0013                             ldx     dosstr
    56  7099 ad0113                             lda     dosstr+1
    57  709c 207f64                             jsr     linprt                          ; print blocks
    58                          
    59  709f a920                               lda     #' '
    60  70a1 20d2ff                             jsr     _bsout                          ; print space
    61                          
    62  70a4 a202                               ldx     #2
    63  70a6 bd0013             l218_4          lda     dosstr,x
    64  70a9 f006                               beq     l218_5
    65  70ab 20d2ff                             jsr     _bsout                          ; print filename (null terminated)
    66  70ae e8                                 inx
    67  70af d0f5                               bne     l218_4
    68                          
    69  70b1 20f737             l218_5          jsr     crdo                            ; print return
    70  70b4 20ccff                             jsr     _clrch
    71  70b7 20e1ff                             jsr     _stop                           ; check stop key
    72  70ba f004                               beq     ldir_end                        ; exit if stop request
    73                          
    74                          ; Continue with next line
    75                          
    76  70bc a002                               ldy     #2                              ; set to skip fake link bytes
    77  70be 80a3                               bra     l218_1                          ; loop
    78                          
    79                          
    80                          ldir_end
    81  70c0 a586                               lda     sid_speed_flag                  ; serial bus kludge for open4,4:cmd4:dir ????
    82  70c2 0c09d6                             tsb     $d609                           ; restore fast serial bus enables
    83  70c5 8088                               bra     dcat11
    84                          
    85                          
    86                          
    87  70c7 20ccff             dcato           jsr     _clrch
    88  70ca a615                               ldx     channl                          ; restore output channel
    89  70cc f003                               beq     l219_1                          ; branch if screen (default output)
    90  70ce 4cc9ff                             jmp     _chkout                         ; else get output channel
    91                          
    92  70d1 60                 l219_1          rts
    93                          
    94                          
    95                          
    96                          ; ********************************************************************************************
    97                          ;
    98                          ;	Date		Changes
    99                          ;	====		=======
   100                          ;
   101                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/dopen.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      dopen.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; DOPEN dfn(,t(,r))
    13                          
    14  70d2 a922               dopen           lda     #$22                            ; set error flag
    15  70d4 202074                             jsr     dosprs                          ; parse the line
    16  70d7 200478                             jsr     chk6                            ; check required parameters
    17  70da 200d71                             jsr     find_sa                         ; find unused secondary address
    18  70dd a009                               ldy     #fopn                           ; fcb format pointer
    19  70df a204                               ldx     #4                              ; normal length
    20  70e1 6f7f13                             bbr6    parsts,open_it                  ; relative record? branch if not relative
    21  70e4 a208                               ldx     #8                              ; random access length
    22  70e6 800f                               bra     open_it                         ; [910925]
    23                          
    24                          ;l220_1 jsr open_file  ;open it
    25                          ; bra exit_disk_op ;report any DOS errors, & return to main [910404]
    26                          
    27                          
    28                          
    29                          ; APPEND
    30                          
    31  70e8 a9e2               append          lda     #$e2                            ; set error flags
    32  70ea 202074                             jsr     dosprs                          ; parse the line
    33  70ed 200478                             jsr     chk6                            ; check required parameters
    34  70f0 200d71                             jsr     find_sa                         ; find secondary address
    35  70f3 a028                               ldy     #fapn                           ; tabld index
    36  70f5 a205                               ldx     #5                              ; length
    37                          open_it
    38  70f7 20fd70                             jsr     open_file                       ; open it
    39  70fa 8372f7                             +lbra   exit_disk_op                    ; report any DOS errors, & return to main [910404]
    40                          
    41                          
    42                          
    43                          open_file                                               ; dop2.
    44  70fd 8a                                 txa                                     ; set length into a
    45  70fe 20f276                             jsr     sendp
    46  7101 20ccff                             jsr     _clrch
    47  7104 a200                               ldx     #sys_bank                       ; fname is in system space, bank0  [910620]
    48  7106 8a                                 txa                                     ; (load bank not req'd)????
    49  7107 206bff                             jsr     _setbank
    50  710a 4cc0ff                             jmp     _open
    51                          
    52                          
    53                          ; Find an available secondary address
    54                          
    55                          find_sa
    56  710d a061                               ldy     #$61                            ; 2-14 possible
    57                          
    58  710f c8                 l220_1          iny
    59  7110 c06f                               cpy     #$6f
    60  7112 f017                               beq     too_many_files                  ; if none available error
    61  7114 2062ff                             jsr     _lkupsa                         ; kernel will lookup this sa in its tables
    62  7117 90f6                               bcc     l220_1                          ; if used keep looking
    63  7119 8c8311                             sty     dossa                           ; save secondary address
    64  711c 60                                 rts                                     ; return .y = sa
    65                          
    66                          
    67                          
    68                          ; Find an available logical address
    69                          
    70                          find_la
    71  711d a900                               lda     #0                              ; 1-127 possible
    72                          
    73  711f 1a                 l221_1          inc
    74  7120 3009                               bmi     too_many_files                  ; if none available error
    75  7122 205fff                             jsr     _lkupla                         ; kernel will lookup this la in its tables
    76  7125 90f8                               bcc     l221_1                          ; if used keep looking
    77  7127 8d8111                             sta     dosla                           ; save logical address
    78  712a 60                                 rts                                     ; return .a = la
    79                          
    80                          
    81                          
    82                          
    83                          too_many_files
    84  712b a201                               ldx     #errtmf                         ; too many files open
    85  712d 8320bd                             +lbra   error
    86                          
    87                          
    88                          ; Close disk file
    89                          
    90  7130 a9f3               dclose          lda     #$f3                            ; set error flags
    91  7132 202074                             jsr     dosprs                          ; parse the line
    92  7135 208278                             jsr     Clear_DS
    93  7138 2f7f06                             bbr2    parsts,dclall                   ; any la given?  branch if not
    94  713b ad8111                             lda     dosla
    95  713e 83cef7                             +lbra   close_out
    96                          
    97  7141 ad8211             dclall          lda     dosfa                           ; get disk #
    98                          ; jsr put_io_in_map
    99  7144 4c50ff                             jmp     _close_all                      ; close all channels
   100                          
   101                          
   102                          
   103                          ; DSAVE dfn
   104                          
   105  7147 4f7e03             dsave           bbr4    runmod,l222_1                   ; PROGRAM or EDIT mode?    [910620]
   106  714a 83ab4c                             +lbra   edit_save                       ; edit
   107                          
   108  714d a966               l222_1          lda     #$66                            ; set error flags
   109  714f 202074                             jsr     dosprs                          ; parse the line
   110  7152 20e177                             jsr     chk2                            ; check required parameters
   111  7155 a009                               ldy     #fopn                           ; table offset
   112  7157 a904                               lda     #4                              ; ..length,
   113  7159 20f276                             jsr     sendp
   114                          
   115  715c a584                               lda     text_bank                       ; default to text bank set up banks???? [910620]
   116  715e a200                               ldx     #sys_bank                       ; fname is in system space, bank0
   117  7160 206bff                             jsr     _setbank
   118  7163 8300f7                             +lbra   savenp
   119                          
   120                          
   121                          ; DVERIFY
   122                          
   123  7166 a901               dverify         lda     #1                              ; flag 'verify'
   124  7168 2c                                 !text $2c
   125                          
   126                          
   127                          
   128                          ; DLOAD dfn
   129                          
   130  7169 a900               dload           lda     #0
   131  716b 850c                               sta     verck                           ; set load flag (for verify check later)
   132                          
   133  716d 4f7e03                             bbr4    runmod,l223_1                   ; PROGRAM or EDIT mode?    [910620]
   134  7170 839b4b                             +lbra   edit_load                       ; edit
   135                          
   136  7173 a9e6               l223_1          lda     #$e6                            ; set error flags
   137  7175 202074                             jsr     dosprs                          ; parse the line
   138  7178 20e177                             jsr     chk2                            ; check required parameters
   139                          
   140                          
   141                          dload_boot                                              ; <<<<<<<<<<<<<<<<<< entry for BOOT'AUTOBOOT.C65'
   142  717b a900                               lda     #0
   143  717d 8d8311                             sta     dossa                           ; set relocate flag
   144  7180 a009                               ldy     #fopn                           ; table offset
   145  7182 a904                               lda     #4                              ; ..length
   146  7184 20f276                             jsr     sendp
   147                          
   148  7187 a584                               lda     text_bank                       ; set up banks ???? want text_bank ????  [910620]
   149  7189 a200                               ldx     #sys_bank                       ; fname is in system space, bank0
   150  718b 206bff                             jsr     _setbank
   151                          
   152  718e 8307f7                             +lbra   cld10                           ; finish load, using 'LOAD' code.
   153                          
   154                          
   155                          ; BSAVE
   156                          
   157  7191 a966               bsave           lda     #$66                            ; std error flag
   158  7193 a2f8                               ldx     #$f8                            ; auxiliary error flag (allow bank, start & end address)
   159  7195 202274                             jsr     dosprx                          ; parse options
   160  7198 20e177                             jsr     chk2                            ; check required parameters
   161                          
   162  719b a580                               lda     parstx                          ; check for starting & ending addresses
   163  719d 2906                               and     #6
   164  719f c906                               cmp     #6
   165  71a1 d3a7bc                             +lbne   snerr                           ; ..if not present, syntax error
   166                          
   167  71a4 ad8011                             lda     dosofh+1                        ; check that ea>sa
   168  71a7 cd7e11                             cmp     dosofl+1
   169  71aa 9352e0                             +lbcc   fcerr                           ; ...error
   170  71ad d00c                               bne     l224_1
   171  71af ad7f11                             lda     dosofh
   172  71b2 cd7d11                             cmp     dosofl
   173  71b5 9347e0                             +lbcc   fcerr                           ; ...error
   174  71b8 f344e0                             +lbeq   fcerr
   175                          
   176  71bb a009               l224_1          ldy     #fopn                           ; table offset
   177  71bd a904                               lda     #4                              ; ..length
   178  71bf 20f276                             jsr     sendp
   179                          
   180  71c2 ad8c11                             lda     dosbnk                          ; get requested bank
   181  71c5 a200                               ldx     #sys_bank                       ; ..and name will be in system bank
   182  71c7 206bff                             jsr     _setbank                        ; ..and go set up bank
   183                          
   184  71ca ae7d11                             ldx     dosofl                          ; start addr
   185  71cd ac7e11                             ldy     dosofl+1
   186  71d0 a95a                               lda     #highds                         ; ..and a pointer to start address
   187  71d2 865a                               stx     highds
   188  71d4 845b                               sty     highds+1
   189  71d6 ae7f11                             ldx     dosofh                          ; end addr
   190  71d9 ac8011                             ldy     dosofh+1
   191  71dc 838df6                             +lbra   savenb
   192                          
   193                          
   194                          
   195                          ; DVERIFY
   196                          
   197  71df a901               bverify         lda     #1                              ; flag 'verify'
   198  71e1 2c                                 !text $2c
   199                          
   200                          
   201                          
   202                          ; ********************************************************************************************
   203                          ;
   204                          ;	Date		Changes
   205                          ;	====		=======
   206                          ;
   207                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/bload.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      bload.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; BLOAD dfn
    14                          
    15  71e2 a900               bload           lda     #0                              ; flag 'load'
    16  71e4 850c                               sta     verck                           ; eventually the 'load' routine will look here
    17                          
    18  71e6 a9e6                               lda     #$e6                            ; std error flag
    19  71e8 a2fc                               ldx     #$fc                            ; aux error flag (allow bank & load address)
    20  71ea 202274                             jsr     dosprx                          ; parse options
    21                          
    22                          bload_boot                                              ; <<<<<<<<<<<<<<<<<<<<<< entry for BOOT'filename'
    23  71ed 20e177                             jsr     chk2                            ; check required parameters
    24  71f0 ae7d11                             ldx     dosofl                          ; get starting address high
    25  71f3 ac7e11                             ldy     dosofl+1                        ; ..and lo
    26  71f6 a900                               lda     #0                              ; assume x & y not both=ff (means real add., not def)
    27  71f8 e0ff                               cpx     #$ff
    28  71fa d006                               bne     l225_1
    29  71fc c0ff                               cpy     #$ff
    30  71fe d002                               bne     l225_1
    31  7200 a9ff                               lda     #$ff                            ; use defaults
    32  7202 8d8311             l225_1          sta     dossa
    33                          
    34  7205 a009                               ldy     #fopn                           ; table offset
    35  7207 a904                               lda     #4                              ; ..length,
    36  7209 20f276                             jsr     sendp                           ; ...and go send parameters
    37                          
    38  720c ad8c11                             lda     dosbnk
    39  720f a200                               ldx     #sys_bank
    40  7211 206bff                             jsr     _setbank
    41                          
    42  7214 a50c                               lda     verck                           ; flag LOAD or VERIFY
    43  7216 ae7d11                             ldx     dosofl                          ; get starting address high
    44  7219 ac7e11                             ldy     dosofl+1                        ; ..and lo (in case this isn't a 'default' load)
    45  721c 20d5ff                             jsr     _loadsp                         ; load it
    46                          
    47                          ; Any changes to the following code must be duplicated at:
    48                          ;  load (load_file)
    49                          ;  save (exit_disk_op)
    50                          
    51  721f 08                                 php                                     ; save kernel load status (.c)
    52  7220 48                                 pha                                     ; save kernel error # (.a)
    53  7221 20b7ff                             jsr     _readst                         ; save I/O status byte
    54  7224 857f                               sta     parsts
    55  7226 206e72                             jsr     print_dos_error                 ; report DOS problems
    56  7229 68                                 pla                                     ; restore error stuff
    57  722a 28                                 plp
    58  722b 9010                               bcc     l225_4                          ; branch if no error (rts)
    59  722d ff7e0a                             bbs7    runmod,l225_3                   ; branch if run mode (erexit)
    60  7230 c904                               cmp     #errfnf                         ; is it 'file not found' catch-all?
    61  7232 d005                               bne     l225_2                          ; no  (erexit)
    62  7234 8dc702                             sta     errnum                          ; yes- save error # for 'er'
    63  7237 0980                               ora     #$80                            ; but no errdis
    64  7239 38                 l225_2          sec
    65  723a b3faf5             l225_3          +lbcs   erexit                          ; exit if kernel problem (rts)
    66                          
    67  723d a50c               l225_4          lda     verck                           ; load or verify operation?
    68  723f d388f6                             +lbne   verify_check                    ; verify
    69                          
    70                          ; jsr _readst  ;  read status
    71  7242 a57f                               lda     parsts                          ; load
    72  7244 29bf                               and     #%10111111                      ; EOI is okay, so mask it
    73  7246 d398f6                             +lbne   load_error                      ; load error
    74  7249 18                                 clc
    75  724a 60                                 rts
    76                          
    77                          
    78                          ; ********************************************************************************************
    79                          ;
    80                          ;	Date		Changes
    81                          ;	====		=======
    82                          ;
    83                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/header.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      header.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ; HEADER nddn [,id]  (alias: FORMAT)
    15                          
    16  724b 201e74             header          jsr     dospar                          ; parse the line
    17  724e 20dc77                             jsr     chk1                            ; check parameter errors
    18  7251 2901                               and     #$01
    19  7253 c901                               cmp     #$01
    20  7255 d3f3bb                             +lbne   snerr                           ; if required parameters not present
    21                          
    22  7258 20e7ff                             jsr     _clall                          ; close all files
    23  725b 20c378                             jsr     are_you_sure                    ; confirm if in direct mode
    24  725e d072                               bne     header_rts                      ; exit if 'no' response
    25  7260 a02d                               ldy     #fhed                           ; tabld index
    26  7262 a904                               lda     #4                              ; length
    27  7264 ae8d11                             ldx     dosdid                          ; check for diskid
    28  7267 f002                               beq     l226_1
    29  7269 a906                               lda     #6                              ; length with id
    30                          
    31  726b 20f973             l226_1          jsr     trans                           ; build and send command
    32                          ;fall into 'print_dos_error'
    33                          
    34                          
    35                          ; ********************************************************************************************
    36                          ;
    37                          ;	Date		Changes
    38                          ;	====		=======
    39                          ;
    40                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: dos/errors.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      errors.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          print_dos_error                                         ; [900725]
    14  726e ff7e61                             bbs7    runmod,header_rts               ; branch if not direct mode
    15  7271 200e78                             jsr     Check_DS                        ; get current disk error message
    16  7274 a000                               ldy     #0
    17  7276 a97a                               lda     #dsdesc+1
    18  7278 20d722                             jsr     lda_far_ram1                    ; lda (dsdesc+1),y peek at first character
    19  727b c932                               cmp     #'2'
    20  727d 9053                               bcc     header_rts                      ; branch if no error occured ('00' or '01')
    21  727f c937                               cmp     #'7'
    22  7281 d00a                               bne     l227_1                          ; [900730]
    23  7283 c8                                 iny
    24  7284 a97a                               lda     #dsdesc+1
    25  7286 20d722                             jsr     lda_far_ram1                    ; might be '73' powerup message
    26  7289 c933                               cmp     #'3'
    27  728b f045                               beq     header_rts                      ; yup
    28                          
    29                          ; ldx #errbdk  ; bad disk error (carry is set)
    30                          ; bra error
    31                          
    32                          ; Print DOS error message as if it were a BASIC error message   [900910]
    33                          
    34  728d a9ff               l227_1          lda     #$ff                            ; reset error line
    35  728f 8dc802                             sta     errlin                          ;
    36  7292 8dc902                             sta     errlin+1
    37  7295 20ccff                             jsr     _clrch
    38                          ; inc a   ;a=0 restore output to screen   [910909]
    39  7298 8515                               sta     channl
    40  729a 2027af                             jsr     RestoreTextScreen               ; make sure we're in text mode????  [910404]
    41  729d 200935                             jsr     init_stack                      ; clean up system, string temps, etc.  [910121]
    42                          
    43  72a0 20dc3c                             jsr     highlight_text                  ; [910624]
    44  72a3 207dff                             jsr     _primm                          ; start a new line with '?DOS: '
    45  72a6 0d3f444f533a2000                   !text cr,"?DOS: ",0                     ; (to distinguish ?DOS: SYNTAX ERROR from ?SYNTAX ERROR)
    46                          
    47  72ae a003                               ldy     #3                              ; print text part of message only
    48  72b0 a97a                               lda     #dsdesc+1
    49  72b2 20d722                             jsr     lda_far_ram1                    ; skip err#, comma, & leading space if any
    50  72b5 c920                               cmp     #' '
    51  72b7 d00a                               bne     l227_3
    52  72b9 c8                                 iny
    53  72ba a97a               l227_2          lda     #dsdesc+1
    54  72bc 20d722                             jsr     lda_far_ram1
    55  72bf c92c                               cmp     #','                            ; finished at comma preceding trk, sector
    56  72c1 f006                               beq     l227_4
    57  72c3 203d68             l227_3          jsr     outch
    58  72c6 c8                                 iny
    59  72c7 10f1                               bpl     l227_2                          ; loop always (bpl=failsafe)
    60                          
    61  72c9 20cb3c             l227_4          jsr     highlight_done                  ; [910624]
    62  72cc 20f737                             jsr     crdo
    63  72cf 837cbb                             +lbra   ready                           ; we're in direct mode, error msg has been printed, abort
    64                          
    65                          header_rts
    66  72d2 18                                 clc
    67  72d3 60                                 rts
    68                          
    69                          
    70                          ; ********************************************************************************************
    71                          ;
    72                          ;	Date		Changes
    73                          ;	====		=======
    74                          ;
    75                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/scratch.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      scratch.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; SCRATCH sdfn  aliases: DELETE, ERASE
    14                          
    15  72d4 201e74             scratch         jsr     dospar                          ; parse the line
    16  72d7 20dc77                             jsr     chk1
    17  72da 20c378                             jsr     are_you_sure                    ; confirm if in direct mode
    18  72dd d02b                               bne     l228_4                          ; branch if 'no' response given
    19                          
    20  72df a049                               ldy     #fscr                           ; offset
    21  72e1 a904                               lda     #4                              ; length
    22  72e3 2c8f11                             bit     dosflags                        ; scratch or recover?
    23  72e6 5004                               bvc     l228_1                          ; scratch
    24  72e8 a04d                               ldy     #frscr                          ; recover
    25  72ea a906                               lda     #6
    26  72ec 20f973             l228_1          jsr     trans                           ; transmit scratch command
    27  72ef 201378                             jsr     Read_DS                         ; read error channel & update DS$
    28                          
    29  72f2 ff7e15                             bbs7    runmod,l228_4                   ; branch if not direct mode
    30  72f5 20f737                             jsr     crdo                            ; output cr
    31                          
    32  72f8 a000                               ldy     #0                              ; display 'files scratched' DOS message
    33  72fa a97a               l228_2          lda     #dsdesc+1
    34  72fc 20d722                             jsr     lda_far_ram1                    ; lda (dsdesc+1),y
    35  72ff f006                               beq     l228_3                          ; if end of error message
    36  7301 203d68                             jsr     outch                           ; print it
    37  7304 c8                                 iny
    38  7305 10f3                               bpl     l228_2                          ; always (bpl=failsafe)
    39                          
    40  7307 20f737             l228_3          jsr     crdo                            ; done
    41                          
    42  730a 60                 l228_4          rts
    43                          
    44                          
    45                          
    46                          ; ********************************************************************************************
    47                          ;
    48                          ;	Date		Changes
    49                          ;	====		=======
    50                          ;
    51                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/record.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      record.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; RECORD- relative record access
    13                          
    14  730b a923               record          lda     #'#'
    15  730d 205d4e                             jsr     synchr                          ; syntax error if not 'record#'
    16                          
    17  7310 206c5d                             jsr     getbyt                          ; get lfn in x
    18  7313 e000                               cpx     #0
    19  7315 f3e7de                             +lbeq   fcerr                           ; cannot be zero
    20  7318 8e8111                             stx     dosla                           ; save logical address
    21                          
    22  731b 20875d                             jsr     comwrd                          ; check for comma, get record number in 'poker'
    23                          
    24  731e a201                               ldx     #1                              ; set up to get starting byte # - default is 1
    25  7320 202679                             jsr     optbyt
    26  7323 8e8b11                             stx     dosrcl                          ; save byte position (pos)    [911024]
    27  7326 8a                                 txa                                     ; cpx #0
    28  7327 f3d5de                             +lbeq   fcerr                           ; if out of range
    29  732a e8                                 inx                                     ; cpx #$ff
    30  732b f3d1de                             +lbeq   fcerr                           ; if out of range
    31                          
    32  732e ad8111                             lda     dosla                           ; get logical address
    33                          ; jsr put_io_in_map
    34  7331 205fff                             jsr     _lkupla                         ; logical to physical map
    35  7334 b01a                               bcs     l229_1                          ; if file not found (not open)    [910404]
    36  7336 8c9011                             sty     dossa_temp                      ; save secondary address
    37                          
    38  7339 8e8211                             stx     dosfa                           ; set up device number for trans routine
    39  733c a900                               lda     #0
    40  733e 8d8111                             sta     dosla                           ; set up logical address for trans routine
    41  7341 a96f                               lda     #$6f
    42  7343 8d8311                             sta     dossa                           ; and secondary address, too!
    43                          
    44  7346 a055                               ldy     #frec                           ; set pointer
    45  7348 a904                               lda     #4                              ; process five bytes
    46  734a 20f973                             jsr     trans                           ; send command
    47  734d 831fff                             +lbra   print_dos_error                 ; if any
    48                          
    49  7350 a203               l229_1          ldx     #errfno                         ; file not found err (file not open)   [910404]
    50  7352 83fbba                             +lbra   error
    51                          
    52                          
    53                          ; ********************************************************************************************
    54                          ;
    55                          ;	Date		Changes
    56                          ;	====		=======
    57                          ;
    58                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/dclear.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      dclear.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; DCLEAR - reinitilaize the drive
    14                          
    15  7355 201e74             dclear          jsr     dospar                          ; parse the line
    16  7358 a0ff                               ldy     #finit                          ; set code
    17  735a a902                               lda     #2
    18  735c 20f973                             jsr     trans                           ; send command
    19  735f 206e72                             jsr     print_dos_error                 ; if any
    20  7362 83ddfd                             +lbra   dclall
    21                          
    22                          
    23                          ; ********************************************************************************************
    24                          ;
    25                          ;	Date		Changes
    26                          ;	====		=======
    27                          ;
    28                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/collect.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      collect.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; COLLECT v<drive#>
    13                          
    14  7365 201e74             collect         jsr     dospar                          ; parse the line
    15  7368 20ed77                             jsr     chk3                            ; check optional parameters
    16  736b 20e7ff                             jsr     _clall                          ; close all files
    17  736e a033                               ldy     #fcoll                          ; tabld offset
    18  7370 a901                               lda     #1                              ; length
    19  7372 4f7f01                             bbr4    parsts,l230_1
    20  7375 1a                                 inc                                     ; include drive
    21  7376 20f973             l230_1          jsr     trans                           ; send command
    22  7379 83f3fe                             +lbra   print_dos_error                 ; if any
    23                          
    24                          
    25                          
    26                          ; ********************************************************************************************
    27                          ;
    28                          ;	Date		Changes
    29                          ;	====		=======
    30                          ;
    31                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/copy.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      copy.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; COPY cdddfn=sdsfn
    14                          
    15  737c 201e74             dcopy           jsr     dospar                          ; parse the line
    16  737f 2930                               and     #$30
    17  7381 c930                               cmp     #$30                            ; check required parameters
    18  7383 d024                               bne     l231_1                          ; branch if single drive copy
    19  7385 a57f                               lda     parsts                          ; else check for dual drive params
    20  7387 29c7                               and     #$c7
    21  7389 f023                               beq     l231_2
    22  738b 2903                               and     #3                              ; special check for 2nd filename   [910717]
    23  738d c903                               cmp     #3
    24  738f f018                               beq     l231_1                          ; branch if given
    25  7391 a92a                               lda     #'*'
    26  7393 8d8d11                             sta     dosdid                          ; else supply "*" for him, just like 'name2'
    27  7396 a901                               lda     #1
    28  7398 a28d                               ldx     #<dosdid
    29  739a a011                               ldy     #>dosdid
    30  739c 8d8711                             sta     dosf2l
    31  739f 8e8911                             stx     dosf2a
    32  73a2 8c8a11                             sty     dosf2a+1
    33  73a5 a902                               lda     #2                              ; and set filename2 flag
    34  73a7 047f                               tsb     parsts                          ; set flag in status
    35  73a9 a57f               l231_1          lda     parsts
    36  73ab 20f377                             jsr     chk4
    37                          ; lda parsts
    38  73ae a039               l231_2          ldy     #fcopy                          ; tabld offset
    39  73b0 a908                               lda     #8                              ; length
    40  73b2 20f973                             jsr     trans                           ; send command
    41  73b5 83b7fe                             +lbra   print_dos_error                 ; if any
    42                          
    43                          
    44                          
    45                          
    46                          ; ********************************************************************************************
    47                          ;
    48                          ;	Date		Changes
    49                          ;	====		=======
    50                          ;
    51                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/concat.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      concat.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; CONCAT
    13                          
    14  73b8 201e74             concat          jsr     dospar                          ; parse the line
    15  73bb 20f377                             jsr     chk4
    16  73be a01f                               ldy     #fconc                          ; offset
    17  73c0 a90c                               lda     #12                             ; length
    18  73c2 20f973                             jsr     trans                           ; send command
    19  73c5 83a7fe                             +lbra   print_dos_error                 ; if any
    20                          
    21                          
    22                          
    23                          
    24                          ; ********************************************************************************************
    25                          ;
    26                          ;	Date		Changes
    27                          ;	====		=======
    28                          ;
    29                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/rename.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rename.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; RENAME rdddfn=sdsfn
    14                          
    15  73c8 a9e4               rename          lda     #$e4                            ; set error flags
    16  73ca 202074                             jsr     dosprs                          ; parse the line
    17  73cd 20fa77                             jsr     chk5
    18  73d0 a041                               ldy     #fren                           ; offset
    19  73d2 a908                               lda     #8                              ; length
    20  73d4 20f973                             jsr     trans                           ; send command
    21  73d7 8395fe                             +lbra   print_dos_error                 ; if any
    22                          
    23                          
    24                          
    25                          ; BACKUP D<destination_drive>=D<source_drive>
    26                          ;
    27                          ; where destination|source_drive is [0...9]
    28                          
    29  73da a9c7               backup          lda     #$c7                            ; set error flags
    30  73dc 202074                             jsr     dosprs                          ; parse the line
    31  73df 2930                               and     #$30                            ; required parameters
    32  73e1 c930                               cmp     #$30
    33  73e3 d365ba                             +lbne   snerr
    34  73e6 20c378                             jsr     are_you_sure
    35  73e9 f001                               beq     l232_1                          ; if run mode or not 'yes'
    36  73eb 60                                 rts
    37                          
    38  73ec 204171             l232_1          jsr     dclall                          ; close disk
    39  73ef a035                               ldy     #fbak
    40  73f1 a904                               lda     #4                              ; length
    41  73f3 20f973                             jsr     trans                           ; send command
    42  73f6 8376fe                             +lbra   print_dos_error                 ; if any
    43                          
    44                          
    45                          ; ********************************************************************************************
    46                          ;
    47                          ;	Date		Changes
    48                          ;	====		=======
    49                          ;
    50                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/trans.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      trans.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ; Trans subroutine
    15                          
    16  73f9 20f276             trans           jsr     sendp                           ; build string to output
    17  73fc 20ccff                             jsr     _clrch
    18  73ff a200                               ldx     #sys_bank                       ; name is in system space, bank0 ????  [910620]
    19  7401 8a                                 txa
    20  7402 206bff                             jsr     _setbank
    21  7405 20c0ff                             jsr     _open                           ; send it...
    22  7408 08                                 php                                     ; save error status (.c)
    23  7409 48                                 pha                                     ; save error code (if any)
    24  740a ad8111                             lda     dosla
    25  740d 38                                 sec
    26  740e 20c3ff                             jsr     _close                          ; special close...
    27  7411 68                                 pla                                     ; pop error
    28  7412 28                                 plp                                     ; pop error status
    29  7413 b321f4                             +lbcs   erexit                          ; ...branch if there was an error opening
    30  7416 60                                 rts
    31                          
    32                          ;.end
    33                          
    34                          ; ********************************************************************************************
    35                          ;
    36                          ;	Date		Changes
    37                          ;	====		=======
    38                          ;
    39                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: dos/parser.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      parser.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; This is the DOS parser routine which looks at lines passed to it and
    16                          ; verifies that the syntax is proper.  -mgm 7/23/79-
    17                          ;
    18                          ; Entry  (dosprs)
    19                          ; a = parsts bit which must be zero.
    20                          ;
    21                          ; Exit  a = parsts as follows
    22                          ;
    23                          ;    ---------------------------------
    24                          ;    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    25                          ;    ---------------------------------
    26                          ;      ^   ^   ^   ^   ^   ^   ^   ^
    27                          ;      |   |   |   |   |   |   |   |_____ fn1 set for the first filename
    28                          ;      |   |   |   |   |   |   |_______ fn2 set for second filename
    29                          ;      |   |   |   |   |   |_________ la set when #lfn parsed
    30                          ;      |   |   |   |   |___________ fa set for device number
    31                          ;      |   |   |   |_____________ d1 set for first disk unit
    32                          ;      |   |   |_______________ d2 set for second disk unit
    33                          ;      |   |_________________ dosrcl set for record size
    34                          ;      |___________________ @ set when @ encountered
    35                          ;
    36                          ; The following are the vaild bit patterns for parsts after parsing for the
    37                          ; various keywords:
    38                          ;
    39                          ;       7 6 5 4  3 2 1 0
    40                          ;
    41                          ;     header  0 0 0 *  * 0 0 1
    42                          ;     collect 0 0 0 *  * 0 0 0
    43                          ;     dclear  0 0 0 *  * 0 0 0
    44                          ;     backup  0 0 1 1  * 0 0 0
    45                          ;     copy    0 0 1 1  * 0 0 0
    46                          ;      or..   0 0 * *  * 0 1 1
    47                          ;     concat  0 0 * *  * 0 1 1
    48                          ;     bsave   * 0 0 *  * 0 0 1
    49                          ;     dsave   * 0 0 *  * 0 0 1
    50                          ;     bload   0 0 0 *  * 0 0 1
    51                          ;     dload   0 0 0 *  * 0 0 1
    52                          ;     dverify 0 0 0 *  * 0 0 1
    53                          ;     catalog 0 0 0 *  * 0 0 *
    54                          ;     rename  0 0 0 *  * 0 1 1
    55                          ;     append  0 0 0 *  * 1 0 1
    56                          ;     scratch 0 0 0 *  * 0 0 1
    57                          ;     dopen   * * 0 *  * 1 0 1
    58                          ;     dclose  0 0 0 0  * * 0 0
    59                          ;             ^ ^ ^ ^  ^ ^ ^ ^
    60                          ;             @ l d d  f l f f
    61                          ;             r r 2 1  a a n n
    62                          ;             p e          2 1
    63                          ;             l l
    64                          ;
    65                          ;      "0" bits are required to be clear
    66                          ;      "1" bits are required to be set
    67                          ;      "*" bits are optional parameters
    68                          
    69                          ; Entry (dosprs):
    70                          ;  parstx shall be set to prevent any auxiliary options to be specified.
    71                          ;
    72                          ; Entry (dosprx):
    73                          ;  .x = parstx bits which must be zero.
    74                          ;
    75                          ; Exit:  .x = parstx as follows:
    76                          ;
    77                          ;     ---------------------------------
    78                          ;     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
    79                          ;     ---------------------------------
    80                          ;       ^   ^   ^   ^   ^   ^   ^   ^____ bnk is set for bank option
    81                          ;       |   |   |   |   |   |   | ______ offl set for 1st address
    82                          ;       |   |   |   |   |   |_________ offh set for 2nd address
    83                          ;       |   |   |   |   |___________ unused
    84                          ;       |   |   |   |_____________ unused
    85                          ;       |   |   |_______________ unused
    86                          ;       |   |_________________ unused
    87                          ;       |___________________ unused
    88                          ;
    89                          ; The following are the valid bit patterns for parstx after parsing for the
    90                          ; various keywords.  These options are allowed for load/save commands only.
    91                          ;
    92                          ;    7 6 5 4  3 2 1 0
    93                          ;
    94                          ;   bsave   0 0 0 0  0 1 1 *
    95                          ;   bload   0 0 0 0  0 0 * *
    96                          ;   bverify 0 0 0 0  0 0 * *
    97                          ;   [auto]boot 0 0 0 0  0 0 * *
    98                          ;    ^ ^ ^ ^  ^ ^ ^ ^
    99                          ;    ? ? ? ?  ? o o b
   100                          ;        f f n
   101                          ;        h l k
   102                          ;
   103                          ;      "0" bits are required to be clear
   104                          ;      "1" bits are required to be set
   105                          ;      "*" bits are optional parameters
   106                          
   107  7417 ffffffff           dostbl          !word $ffff,$ffff                       ; default start/end address
   108  741b 00086f                             !text doslfn,dosffn,$6f                 ; default la/fa/sa
   109                          
   110                          
   111  741e a900               dospar          lda     #0                              ; DOS Parser
   112                          
   113                          dosprs                                                  ; special error flag entry
   114  7420 a2ff                               ldx     #$ff                            ; no aux options!
   115                          
   116                          dosprx                                                  ; spec aux error flag entry
   117  7422 48                                 pha                                     ; save error flags
   118  7423 da                                 phx
   119  7424 a900                               lda     #0
   120  7426 857f                               sta     parsts                          ; reset parser status/option words
   121  7428 8580                               sta     parstx
   122                          
   123  742a a20d                               ldx     #dosspc                         ; clear DOS scratch area   [900522]
   124  742c 9d8311             l233_1          sta     xcnt-1,x
   125  742f ca                                 dex                                     ; no filenames, null lengths
   126  7430 d0fa                               bne     l233_1
   127                          
   128  7432 a206                               ldx     #dossa-dosofl                   ; set some defaults from table
   129  7434 bd1774             l233_2          lda     dostbl,x
   130  7437 9d7d11                             sta     dosofl,x                        ; start/end adr = $FFFF, la/fa/sa
   131  743a ca                                 dex
   132  743b 10f7                               bpl     l233_2
   133                          
   134  743d ae0611                             ldx     _default_drive                  ; set default device   [900522]
   135  7440 8e8211                             stx     dosfa
   136  7443 aed102                             ldx     current_bank                    ; set current bank
   137  7446 8e8c11                             stx     dosbnk
   138                          
   139  7449 208522                             jsr     chrgot                          ; get next character from command string
   140  744c d00f                               bne     parse1                          ; if eol stick with defaults, else begin parsing
   141                          
   142                          
   143                          ; Done parsing, check for errors, return if everything okay
   144                          
   145  744e 68                 done            pla                                     ; get aux error flag
   146  744f 2580                               and     parstx                          ; repeated or illegal params?
   147  7451 d3f7b9                             +lbne   snerr                           ; yes- report syntax error
   148  7454 68                                 pla                                     ; get error flags
   149  7455 208c76                             jsr     prmrpt
   150  7458 a57f                               lda     parsts
   151  745a a680                               ldx     parstx
   152  745c 60                                 rts
   153                          
   154                          
   155                          ; Parse given parameters.  what it is  example
   156                          ;     -------------------- ---------
   157  745d c922               parse1          cmp     #'"'
   158  745f f30201                             +lbeq   name1                           ; explicit filename "file"
   159  7462 c928                               cmp     #'('
   160  7464 f3fd00                             +lbeq   name1                           ; evaluate filename (f$)
   161  7467 c923                               cmp     #'#'
   162  7469 f039                               beq     logadr                          ; logical file number #1
   163  746b c955                               cmp     #'U'
   164  746d f029                               beq     unit1                           ; unit number  U8
   165  746f c944                               cmp     #'D'
   166  7471 f06d                               beq     drv1                            ; drive number  D0
   167  7473 c950                               cmp     #'P'
   168  7475 f3b700                             +lbeq   doffl                           ; load/save address P1234
   169  7478 c942                               cmp     #'B'
   170  747a f022                               beq     dbank1                          ; load/save bank   B0
   171  747c c957                               cmp     #'W'
   172  747e f038                               beq     reclen                          ; write mode  W
   173  7480 c94c                               cmp     #'L'
   174  7482 f034                               beq     reclen                          ; record length  L80
   175  7484 c952                               cmp     #'R'
   176  7486 f3ce00                             +lbeq   recover                         ; recover mode  R
   177  7489 c949                               cmp     #'I'
   178  748b f06b                               beq     ident                           ; ID   Ixx
   179  748d c991                               cmp     #on_token
   180                          ; beq on1   ; ON token  ON
   181                          
   182  748f d3b9b9                             +lbne   snerr                           ; none of these, syntax error
   183                          
   184                          
   185  7492 20fe75             on1             jsr     on
   186  7495 83e400                             +lbra   del1
   187                          
   188                          
   189  7498 200a76             unit1           jsr     unit                            ; do unit# parsing
   190  749b 83de00                             +lbra   del1                            ; always
   191                          
   192                          
   193  749e 202476             dbank1          jsr     dbank
   194  74a1 83d800                             +lbra   del1                            ; always
   195                          
   196                          
   197  74a4 a904               logadr          lda     #4
   198  74a6 208c76                             jsr     prmrpt                          ; check for repeated parameter
   199  74a9 20695d                             jsr     gtbytc                          ; getval
   200  74ac 8a                                 txa                                     ; cpx #0
   201  74ad f34fdd                             +lbeq   fcerr                           ; if illegal value
   202  74b0 8e8111                             stx     dosla
   203  74b3 a904                               lda     #4                              ; set logical address flag
   204  74b5 83c400                             +lbra   del1                            ; get next parameter
   205                          
   206                          
   207  74b8 aa                 reclen          tax                                     ; save char
   208  74b9 a940                               lda     #$40
   209  74bb 208c76                             jsr     prmrpt                          ; check for repeated parameter
   210  74be e057                               cpx     #'W'
   211  74c0 d005                               bne     l234_1
   212  74c2 208322                             jsr     chrget
   213  74c5 8014                               bra     l234_4                          ; set parsts
   214                          
   215  74c7 a201               l234_1          ldx     #1                              ; a kludge to allow  DOPEN#lf,"relfile",L  [911024]
   216  74c9 208322                             jsr     chrget
   217  74cc f003                               beq     l234_2                          ; eol? open existing rel file
   218  74ce 206c5d                             jsr     getbyt                          ; get reclen (was getval)
   219  74d1 8e8b11             l234_2          stx     dosrcl                          ; store parcel
   220  74d4 8a                                 txa                                     ; cpx #0
   221  74d5 f001                               beq     l234_3                          ; zero illegal dosrcl
   222  74d7 e8                                 inx                                     ; cpx #255
   223  74d8 f324dd             l234_3          +lbeq   fcerr                           ; illegal dosrcl
   224                          
   225  74db a940               l234_4          lda     #$40                            ; set dosrcl flag &
   226  74dd 839c00                             +lbra   del1
   227                          
   228                          
   229  74e0 a910               drv1            lda     #$10
   230  74e2 208c76                             jsr     prmrpt                          ; check for repeated parameter
   231  74e5 20695d                             jsr     gtbytc                          ; getval
   232  74e8 e00a                               cpx     #10
   233  74ea b312dd                             +lbcs   fcerr                           ; illegal drv# if >9 [allow 0: to 9: ?????]
   234  74ed 8e8611                             stx     dosds1
   235  74f0 8e8811                             stx     dosds2
   236  74f3 a910                               lda     #$10
   237  74f5 838400                             +lbra   del1
   238                          
   239                          
   240  74f8 a980               ident           lda     #$80                            ; set ID flag
   241  74fa 0c8f11                             tsb     dosflags
   242  74fd d34bb9                             +lbne   snerr                           ; repeated parameter
   243  7500 208322                             jsr     chrget                          ; get next character
   244  7503 c928                               cmp     #'('                            ; c65: allow I(ID$) syntax  [900710]
   245  7505 d019                               bne     l235_1
   246  7507 20675b                             jsr     frmstr                          ; get ID from var
   247  750a c902                               cmp     #2
   248  750c 935c01                             +lbcc   err_mfn                         ; if length < 2, error
   249  750f a000                               ldy     #0
   250  7511 20d522                             jsr     indin1_ram1                     ; else grab first two characters
   251  7514 8d8d11                             sta     dosdid
   252  7517 c8                                 iny
   253  7518 20d522                             jsr     indin1_ram1
   254  751b 8d8e11                             sta     dosdid+1
   255  751e 805d                               bra     delim1                          ; continue
   256                          
   257  7520 8d8d11             l235_1          sta     dosdid                          ; m(txtptr => dosdid
   258  7523 208322                             jsr     chrget
   259  7526 8d8e11                             sta     dosdid+1
   260  7529 208322                             jsr     chrget                          ; continue
   261  752c 8052                               bra     delim2
   262                          
   263                          
   264  752e a902               doffl           lda     #$02                            ; check aux status
   265  7530 209276                             jsr     prxrpt
   266  7533 207576                             jsr     getoff                          ; get offset value
   267  7536 8c7d11                             sty     dosofl
   268  7539 8d7e11                             sta     dosofl+1
   269  753c a902                               lda     #$02
   270  753e 0580               dlimx1          ora     parstx                          ; set aux status bits
   271  7540 8580                               sta     parstx
   272  7542 d039                               bne     delim1                          ; try for next param
   273                          
   274                          
   275  7544 a904               doffh           lda     #$04
   276  7546 209276                             jsr     prxrpt
   277  7549 207576                             jsr     getoff
   278  754c 8c7f11                             sty     dosofh
   279  754f 8d8011                             sta     dosofh+1
   280  7552 a904                               lda     #$04
   281  7554 80e8                               bra     dlimx1                          ; set aux status
   282                          
   283                          
   284  7556 a940               recover         lda     #$40
   285  7558 0c8f11                             tsb     dosflags                        ; set 'recover' bit
   286  755b d3edb8                             +lbne   snerr                           ; if repeated parameter
   287  755e 208322                             jsr     chrget                          ; continue
   288  7561 801d                               bra     delim2
   289                          
   290                          
   291  7563 a901               name1           lda     #1                              ; name1 allowed only once
   292  7565 203676                             jsr     newnam                          ; do name parsing
   293  7568 8d8511                             sta     dosf1l
   294                          
   295  756b a000                               ldy     #0
   296  756d 20d522             l236_1          jsr     indin1_ram1
   297  7570 999111                             sta     savram,y                        ; copy name into buffer
   298  7573 c8                                 iny
   299  7574 cc8511                             cpy     dosf1l
   300  7577 90f4                               bcc     l236_1                          ; ...copy all of it
   301  7579 a901                               lda     #1                              ; set name1 flag
   302                          
   303                          
   304  757b 047f               del1            tsb     parsts
   305                          
   306  757d 208522             delim1          jsr     chrgot
   307  7580 d016               delim2          bne     nxxx
   308  7582 83cafe                             +lbra   done                            ; <cr>/<> => done
   309                          
   310                          
   311  7585 c991               next6           cmp     #on_token
   312  7587 f309ff                             +lbeq   on1
   313  758a c9a4                               cmp     #to_token                       ; "to" token
   314  758c d3bcb8                             +lbne   snerr                           ; syntax error
   315                          
   316                          ;  If "to" is not followed by an offset param, then do file2 params.
   317                          ;  Otherwise, do high offset and continue with file0 options.
   318                          
   319  758f 208322                             jsr     chrget
   320  7592 c950                               cmp     #'P'
   321  7594 d00f                               bne     pars22
   322  7596 f0ac                               beq     doffh
   323                          
   324                          
   325  7598 c92c               nxxx            cmp     #','
   326  759a d0e9                               bne     next6
   327  759c 208322                             jsr     chrget
   328  759f 83bcfe                             +lbra   parse1
   329                          
   330                          
   331  75a2 208322             parse2          jsr     chrget
   332  75a5 c944               pars22          cmp     #'D'
   333  75a7 f010                               beq     l237_1
   334  75a9 c991                               cmp     #on_token                       ; "on" token
   335  75ab f020                               beq     on2
   336  75ad c955                               cmp     #'U'
   337  75af f021                               beq     unit2
   338  75b1 c922                               cmp     #'"'
   339  75b3 f022                               beq     name2
   340  75b5 c928                               cmp     #'('
   341  75b7 f01e                               beq     name2
   342                          
   343  75b9 a920               l237_1          lda     #$20
   344  75bb 208c76                             jsr     prmrpt                          ; check for repeated parameter
   345  75be 20695d                             jsr     gtbytc                          ; getval
   346  75c1 e00a                               cpx     #10
   347  75c3 b339dc                             +lbcs   fcerr                           ; illegal drive #  [allow 0: to 9: ????]
   348  75c6 8e8811                             stx     dosds2
   349  75c9 a920                               lda     #$20
   350  75cb 801a                               bra     del2
   351                          
   352  75cd 20fe75             on2             jsr     on
   353  75d0 8015                               bra     del2
   354                          
   355                          
   356  75d2 200a76             unit2           jsr     unit                            ; do unit# parsing
   357  75d5 8010                               bra     del2                            ; always
   358                          
   359  75d7 a902               name2           lda     #2                              ; name2 allowed only once
   360  75d9 203676                             jsr     newnam
   361  75dc 8d8711                             sta     dosf2l
   362  75df 8e8911                             stx     dosf2a
   363  75e2 8c8a11                             sty     dosf2a+1
   364                          
   365  75e5 a902                               lda     #2                              ; set filename2 flag &
   366  75e7 047f               del2            tsb     parsts                          ; set flag in status
   367  75e9 208522                             jsr     chrgot
   368  75ec f360fe                             +lbeq   done                            ; done on <cr>/<>
   369  75ef c92c                               cmp     #','
   370  75f1 f0af                               beq     parse2
   371  75f3 c991                               cmp     #on_token                       ; "on" token
   372  75f5 f0d6                               beq     on2
   373  75f7 c955                               cmp     #'U'
   374  75f9 f0d7                               beq     unit2
   375  75fb 834db8                             +lbra   snerr
   376                          
   377                          
   378  75fe 208322             on              jsr     chrget
   379  7601 c942                               cmp     #'B'
   380  7603 f01f                               beq     dbank
   381  7605 c955                               cmp     #'U'
   382  7607 d341b8                             +lbne   snerr
   383                          
   384                          
   385  760a 20695d             unit            jsr     gtbytc                          ; getval
   386  760d e01f                               cpx     #31
   387  760f b05c                               bcs     err_ild                         ; error if >30
   388  7611 e001                               cpx     #1                              ; drive 1 = use system default drive  [910221]
   389  7613 d005                               bne     l238_1
   390  7615 ae0611                             ldx     _default_drive
   391  7618 8004                               bra     l238_2
   392  761a e004               l238_1          cpx     #4
   393  761c 904f                               bcc     err_ild                         ; error if <4
   394  761e 8e8211             l238_2          stx     dosfa
   395  7621 a908                               lda     #$08                            ; set parser's unit flag
   396  7623 60                                 rts
   397                          
   398                          
   399  7624 a901               dbank           lda     #$01                            ; repeated param?
   400  7626 209276                             jsr     prxrpt
   401  7629 20695d                             jsr     gtbytc                          ; getval
   402                          ; cpx #16  ;bank too large?
   403                          ; bcs fcerr ;illegal qty
   404  762c 8e8c11                             stx     dosbnk
   405  762f a901                               lda     #$01
   406  7631 0480                               tsb     parstx                          ; set bnk bit in aux status
   407  7633 a900                               lda     #0                              ; .a=std status wrd, no bits to set
   408  7635 60                                 rts
   409                          
   410                          
   411                          newnam
   412  7636 48                                 pha                                     ; save nam1,2 for subdir check later  [901115]
   413  7637 208c76                             jsr     prmrpt                          ; check for repeated parameter
   414  763a 20675b                             jsr     frmstr
   415  763d aa                                 tax                                     ; save length of string
   416  763e f02a                               beq     err_mfn                         ; if length = 0
   417  7640 a000                               ldy     #0
   418  7642 20d522                             jsr     indin1_ram1
   419  7645 c940                               cmp     #'@'                            ; Replace file convention?
   420  7647 d00c                               bne     l239_1                          ; no
   421  7649 a980                               lda     #$80                            ; yes- check for repeated param
   422  764b 208c76                             jsr     prmrpt
   423  764e f77f                               smb7    parsts                          ; set "@" flag
   424  7650 ca                                 dex                                     ; decrement length
   425  7651 e324                               inw     index1                          ; increment past "@"
   426  7653 800c                               bra     lenchk
   427                          
   428  7655 c92f               l239_1          cmp     #'/'                            ; Subdirectory (partition)?   [901115]
   429  7657 d008                               bne     lenchk                          ; no
   430  7659 68                                 pla                                     ; yes- recall nam1 or nam2
   431  765a 0c8f11                             tsb     dosflags                        ; set appropriate '/' flag (.a=1 or 2)
   432  765d ca                                 dex                                     ; decrement length
   433  765e e324                               inw     index1                          ; increment past "@"
   434  7660 89                                 !text $89
   435                          
   436                          
   437  7661 68                 lenchk          pla                                     ; [901115]
   438  7662 8a                                 txa                                     ; Check filename length
   439  7663 f005                               beq     err_mfn                         ; too small, missing filename  [901115]
   440                          ; cmp #17  ;  ???? (problem if name has ',P')
   441                          ; bcs errlen ; too long
   442  7665 a624                               ldx     index1
   443  7667 a425                               ldy     index1+1                        ; ok- return pointer to filename
   444  7669 60                                 rts
   445                          
   446                          
   447  766a a208               err_mfn         ldx     #err_missing_fname
   448  766c 2c                                 !text $2c
   449                          
   450  766d a209               err_ild         ldx     #err_illegal_device
   451  766f 2c                                 !text $2c
   452                          
   453  7670 a217               errlen          ldx     #errls                          ; string or filename too long
   454  7672 83dbb7                             +lbra   error
   455                          
   456                          
   457                          
   458                          ; Get next value routine (use gtbytc instead!)
   459                          
   460                          ;getval jsr chrget ;get nxt chr
   461                          ; beq snerr ;if end of statement
   462                          ; bra getbyt ;       [911024]
   463                          
   464                          ; bcc getbyt ;can be numeric, go evaluate it  why this crap ????
   465                          ; jsr chkopn ;or a "("
   466                          ; jsr getbyt ;anything else is an error
   467                          ; bra chkcls ;need closing ")"
   468                          
   469                          
   470                          
   471                          ; Get next 2-byte expression.  Exit: .a,.y (high,low) value
   472                          
   473  7675 208322             getoff          jsr     chrget                          ; get nxt chr
   474  7678 f3d0b7                             +lbeq   snerr                           ; if end of statement
   475  767b 930de7                             +lbcc   getwrd                          ; can be num. const, go evaluate it
   476  767e 20584e                             jsr     chkopn                          ; or a "("
   477  7681 208a5d                             jsr     getwrd                          ; expr
   478  7684 20554e                             jsr     chkcls                          ; need closing ")"
   479  7687 a416                               ldy     poker
   480  7689 a517                               lda     poker+1
   481  768b 60                                 rts
   482                          
   483                          
   484                          
   485                          ; Prmrpt checks for a repeated parameter.
   486                          ;
   487                          ; Entry: .a contains parsts flag to check
   488                          
   489                          
   490  768c 257f               prmrpt          and     parsts                          ; compare mask with status
   491  768e d3bab7                             +lbne   snerr                           ; error if bit previously set
   492  7691 60                                 rts
   493                          
   494                          
   495                          
   496                          ; Prxrpt checks for a repeated parameter.
   497                          ;
   498                          ; Entry: .a contains parstx flag to check
   499                          
   500                          
   501  7692 2580               prxrpt          and     parstx                          ; and with parstx
   502  7694 d3b4b7                             +lbne   snerr                           ; if bit previously set
   503  7697 60                                 rts
   504                          
   505                          ;.end
   506                          
   507                          
   508                          
   509                          ; CBM-2001 BASIC-4 disk verb processors.  -- rsr 7-24-79 --
   510                          ;
   511                          ; Token Table Definitions
   512                          
   513                          xsca            =$c2                                    ; send dossca
   514                          xid             =$d0                                    ; sends disk id
   515                          xd1             =$d1                                    ; sends dosds1
   516                          xd2             =$d2                                    ; sends dosds2
   517                          xrec            =$e0                                    ; sends S for SEQ, or dosrcl
   518                          xwrt            =$e1                                    ; sends W or L
   519                          xrcl            =$e2                                    ; send low ((poker))
   520                          xfat            =$f0                                    ; sends "@" or "/" if specified
   521                          xfn1            =$f1                                    ; sends filename1
   522                          xfn2            =$f2                                    ; sends filename2
   523                          
   524                          
   525                          ; Tabld - used to build disk command strings
   526                          
   527                          tabld
   528                          finit           = $ff                                   ; Dclear
   529  7698 49d1                               !text "I",xd1
   530                          
   531                          fdir            = *-tabld-1                             ; Dir
   532  769a 24d13af1                           !text "$",xd1,":",xfn1
   533                          
   534                          fdirr           = *-tabld-1                             ; Recover Dir  [901024]
   535  769e 5fd13af1                           !text "_",xd1,":",xfn1                  ; ('_'=CBM backarrow, $5F)
   536                          
   537                          fopn            = *-tabld-1                             ; Dopen
   538  76a2 f0d13af12ce12ce0                   !text xfat,xd1,":",xfn1,",",xwrt,",",xrec
   539                          
   540                          fopnseq         = *-tabld-1                             ; Type   [900801]
   541  76aa f0d13af12c53                       !text xfat,xd1,":",xfn1,",S"
   542                          
   543                          fsavseq         = *-tabld-1                             ; EDIT_SAVE  [910620]
   544  76b0 f0d13af12c532c57                   !text xfat,xd1,":",xfn1,",S,W"
   545                          
   546                          fconc           = *-tabld-1                             ; Concat
   547  76b8 43d23af23dd23af2...                !text "C",xd2,":",xfn2,"=",xd2,":",xfn2,","
   548                          
   549                          fapn            = *-tabld-1                             ; Append
   550  76c1 d13af12c41                         !text xd1,":",xfn1,",A"
   551                          
   552                          fhed            = *-tabld-1                             ; Header
   553  76c6 4ed13af12cd0                       !text "N",xd1,":",xfn1,",",xid
   554                          
   555                          fcoll           = *-tabld-1                             ; Collect
   556  76cc 56d1                               !text "V",xd1
   557                          
   558                          fbak            = *-tabld-1                             ; Backup
   559  76ce 44d23dd1                           !text "D",xd2,"=",xd1
   560                          
   561                          fcopy           = *-tabld-1                             ; Copy
   562  76d2 43d23af23dd13af1                   !text "C",xd2,":",xfn2,"=",xd1,":",xfn1
   563                          
   564                          fren            = *-tabld-1                             ; Rename
   565  76da 52d13af23dd13af1                   !text "R",xd1,":",xfn2,"=",xd1,":",xfn1
   566                          
   567                          fscr            = *-tabld-1                             ; Scratch
   568  76e2 53d13af1                           !text "S",xd1,":",xfn1
   569                          
   570                          frscr           = *-tabld-1                             ; Recover Del  [901024]
   571  76e6 462d52d13af1                       !text "F-R",xd1,":",xfn1
   572                          
   573                          fdisk           = *-tabld-1                             ; Disk command  [910123]
   574  76ec f0f1                               !text xfat,xfn1                         ; pass '/' [911030]
   575                          
   576                          frec            = *-tabld-1                             ; Record
   577  76ee 50c2e2e0                           !text "P",xsca,xrcl,xrec
   578                          
   579                          
   580                          
   581                          ; ********************************************************************************************
   582                          ;
   583                          ;	Date		Changes
   584                          ;	====		=======
   585                          ;
   586                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: dos/sendparam.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      sendparam.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; Send parameters to device
    13                          ;
    14                          ; Entry: .a = number of bytes in format
    15                          ;  .y = pointer to TABLD entry
    16                          
    17  76f2 8d8411             sendp           sta     xcnt                            ; save number of string bytes
    18  76f5 5a                                 phy
    19  76f6 208278                             jsr     Clear_DS                        ; clear old status
    20                          
    21  76f9 a200                               ldx     #0
    22  76fb 68                 sdp1            pla
    23  76fc ce8411                             dec     xcnt
    24  76ff 304d                               bmi     tranr
    25  7701 a8                                 tay
    26  7702 c8                                 iny                                     ; move down table
    27  7703 5a                                 phy
    28  7704 b99876                             lda     tabld,y                         ; get next entry
    29  7707 103f                               bpl     sdp5                            ; if not escape code
    30  7709 c9c2                               cmp     #xsca                           ; if not secondary address
    31  770b f058                               beq     rsca
    32  770d c9d0                               cmp     #xid
    33  770f f06a                               beq     rid                             ; if disk id
    34  7711 c9e2                               cmp     #xrcl
    35  7713 f38400                             +lbeq   rdcn                            ; if record number
    36  7716 c9e1                               cmp     #xwrt
    37  7718 f06d                               beq     rwrt                            ; if W or L
    38  771a c9f0                               cmp     #xfat
    39  771c f04c                               beq     rfat                            ; if "@" symbol request
    40  771e c9f1                               cmp     #xfn1
    41  7720 f38100                             +lbeq   rsfn                            ; if filename 1
    42  7723 c9f2                               cmp     #xfn2
    43  7725 f39200                             +lbeq   rdfn                            ; if filename 2
    44  7728 c9e0                               cmp     #xrec
    45  772a d00a                               bne     sdp2                            ; if not record type
    46  772c ad8b11                             lda     dosrcl                          ; get rec #
    47  772f c901                               cmp     #1                              ; kludge to allow DOPEN#lf,"relfile",L  [911024]
    48  7731 d015                               bne     sdp5                            ; (note RECORD byte 0 = byte 1 anyhow)
    49  7733 3a                                 dec
    50  7734 8012                               bra     sdp5                            ; always branch
    51                          
    52  7736 c9d1               sdp2            cmp     #xd1
    53  7738 d005                               bne     sdp3                            ; if not drive 1
    54  773a ad8611                             lda     dosds1
    55  773d 8007                               bra     sdp4                            ; always branch
    56                          
    57  773f c9d2               sdp3            cmp     #xd2
    58  7741 d0b8                               bne     sdp1                            ; if not drive 2, continue
    59  7743 ad8811                             lda     dosds2
    60  7746 0930               sdp4            ora     #'0'                            ; change # to PETSCII
    61                          
    62  7748 9d0013             sdp5            sta     dosstr,x                        ; else into buffer
    63  774b e8                                 inx
    64  774c 80ad                               bra     sdp1                            ; always
    65                          
    66                          
    67  774e 8a                 tranr           txa                                     ; length to a
    68  774f 48                                 pha
    69  7750 a200                               ldx     #<dosstr                        ; set filename
    70  7752 a013                               ldy     #>dosstr
    71  7754 20bdff                             jsr     _setnam
    72                          
    73  7757 ad8111                             lda     dosla                           ; set channel
    74  775a ae8211                             ldx     dosfa
    75  775d ac8311                             ldy     dossa
    76  7760 20baff                             jsr     _setlfs
    77                          
    78  7763 68                                 pla
    79  7764 60                                 rts
    80                          
    81                          
    82                          
    83                          
    84  7765 ad9011             rsca            lda     dossa_temp                      ; secondary address (record)
    85  7768 80de                               bra     sdp5                            ; always
    86                          
    87                          
    88  776a 7f7f04             rfat            bbr7    parsts,l240_1                   ; if "@" not encountered
    89  776d a940                               lda     #'@'
    90  776f 80d7                               bra     sdp5                            ; always
    91                          
    92  7771 ad8f11             l240_1          lda     dosflags
    93  7774 4a                                 lsr
    94  7775 9084                               bcc     sdp1                            ; if "/" not encountered
    95  7777 a92f                               lda     #'/'
    96  7779 80cd                               bra     sdp5
    97                          
    98                          
    99                          ; ID subroutine
   100                          
   101  777b ad8d11             rid             lda     dosdid                          ; include id
   102  777e 9d0013                             sta     dosstr,x
   103  7781 e8                                 inx
   104  7782 ad8e11                             lda     dosdid+1
   105  7785 80c1                               bra     sdp5                            ; always
   106                          
   107                          
   108  7787 ad8b11             rwrt            lda     dosrcl                          ; check for L or W
   109  778a f004                               beq     l241_1                          ; zero then write
   110  778c a94c                               lda     #'L'
   111  778e 80b8                               bra     sdp5                            ; always
   112                          
   113  7790 a953               l241_1          lda     #'S'                            ; send W,S
   114  7792 8d8b11                             sta     dosrcl
   115  7795 a957                               lda     #'W'
   116  7797 80af                               bra     sdp5                            ; always
   117                          
   118                          
   119                          
   120                          ; Move record number
   121                          
   122  7799 a516               rdcn            lda     poker
   123  779b 9d0013                             sta     dosstr,x
   124  779e a517                               lda     poker+1
   125  77a0 e8                                 inx
   126  77a1 80a5                               bra     sdp5                            ; always
   127                          
   128                          
   129                          ; Move file names
   130                          
   131  77a3 ac8511             rsfn            ldy     dosf1l                          ; file name 1: get length
   132  77a6 f030                               beq     rdrt0                           ; if null string
   133                          
   134  77a8 a000                               ldy     #0                              ; move name to dosstr
   135  77aa b99111             l242_1          lda     savram,y
   136  77ad 9d0013                             sta     dosstr,x
   137  77b0 e8                                 inx
   138  77b1 c8                                 iny
   139  77b2 cc8511                             cpy     dosf1l
   140  77b5 d0f3                               bne     l242_1                          ; if move not complete
   141  77b7 8020                               bra     rdrt1                           ; always
   142                          
   143                          
   144  77b9 ad8911             rdfn            lda     dosf2a
   145  77bc 8524                               sta     index1
   146  77be ad8a11                             lda     dosf2a+1
   147  77c1 8525                               sta     index1+1
   148  77c3 ac8711                             ldy     dosf2l
   149  77c6 f010                               beq     rdrt0                           ; if null string
   150                          
   151  77c8 a000                               ldy     #0                              ; move name to dosstr
   152  77ca 20d522             l243_1          jsr     indin1_ram1
   153  77cd 9d0013                             sta     dosstr,x
   154  77d0 e8                                 inx
   155  77d1 c8                                 iny
   156  77d2 cc8711                             cpy     dosf2l
   157  77d5 d0f3                               bne     l243_1                          ; if move not complete
   158  77d7 89                                 !text $89                               ; hop
   159                          
   160  77d8 ca                 rdrt0           dex                                     ; case cdd=sd
   161  77d9 8320ff             rdrt1           +lbra   sdp1                            ; get next symbol
   162                          
   163                          
   164                          ; Syntax checker DOS write
   165                          
   166  77dc 29e6               chk1            and     #$e6                            ; for HEADER, DLOAD, SCRATCH, TYPE, LIST
   167  77de d36ab6                             +lbne   snerr
   168                          
   169  77e1 a57f               chk2            lda     parsts                          ; for DSAVE
   170  77e3 2901                               and     #1
   171  77e5 c901                               cmp     #1                              ; check required parameters
   172  77e7 d361b6                             +lbne   snerr                           ; error if 1 missing
   173  77ea a57f                               lda     parsts                          ; reload for return
   174  77ec 60                                 rts
   175                          
   176                          
   177  77ed 29e7               chk3            and     #$e7                            ; for COLLECT
   178  77ef d359b6                             +lbne   snerr                           ; check optional parameters
   179  77f2 60                                 rts
   180                          
   181                          
   182  77f3 29c4               chk4            and     #$c4                            ; for COPY, CONCAT
   183  77f5 d353b6                             +lbne   snerr                           ; check optional parameters
   184  77f8 a57f                               lda     parsts
   185  77fa 2903               chk5            and     #3                              ; for RENAME
   186  77fc c903                               cmp     #3                              ; check required parameters
   187  77fe d34ab6                             +lbne   snerr
   188  7801 a57f                               lda     parsts                          ; reload for return
   189  7803 60                                 rts
   190                          
   191                          
   192  7804 2905               chk6            and     #5                              ; for APPEND, DOPEN
   193  7806 c905                               cmp     #5                              ; check required parameters
   194  7808 d340b6                             +lbne   snerr
   195  780b a57f                               lda     parsts                          ; reload for rts
   196  780d 60                                 rts
   197                          
   198                          ;.end
   199                          
   200                          
   201                          
   202                          ; Allocate DS$ if nesessary, but use old DS$ string otherwise
   203                          ; Called by DS$ and DS
   204                          
   205                          Check_DS                                                ; chkds.
   206  780e a579                               lda     dsdesc
   207  7810 f005                               beq     Read_DS_1                       ; branch if DS$ is not in memory
   208  7812 60                                 rts                                     ; else return & use old one
   209                          
   210                          
   211                          ; Allocate DS$ if necessary & Read DOS error channel
   212                          
   213                          Read_DS                                                 ; errchl.
   214  7813 a579                               lda     dsdesc                          ; has DS$ space been allocated?
   215  7815 d01a                               bne     Read_DS_2                       ; yes
   216                          
   217                          Read_DS_1
   218  7817 a928                               lda     #40                             ; no- get 40 char string
   219  7819 8579                               sta     dsdesc
   220  781b 20dd5b                             jsr     getspa                          ; allocate space for DS$
   221  781e 867a                               stx     dsdesc+1                        ; low address of string
   222  7820 847b                               sty     dsdesc+2                        ; high   "    "    "
   223  7822 a27a                               ldx     #dsdesc+1                       ; set up string back pointer to dsdesc
   224  7824 a028                               ldy     #40
   225  7826 a979                               lda     #<dsdesc
   226  7828 20f022                             jsr     sta_far_ram1                    ; sta (dsdesc+1),y
   227  782b c8                                 iny
   228  782c a900                               lda     #>dsdesc
   229  782e 20f022                             jsr     sta_far_ram1                    ; sta (dsdesc+1),y
   230                          
   231                          Read_DS_2
   232  7831 ae8211                             ldx     dosfa                           ; fa
   233  7834 e002                               cpx     #2
   234  7836 b006                               bcs     l244_1                          ; if =0 or 1 use default  [910429]
   235  7838 ae0611                             ldx     _default_drive                  ; (was dosffn)   [900710]
   236  783b 8e8211                             stx     dosfa
   237  783e a900               l244_1          lda     #doslfn                         ; la (reserved la)
   238  7840 a06f                               ldy     #$6f                            ; sa (command channel)
   239  7842 20baff                             jsr     _setlfs
   240  7845 a900                               lda     #0                              ; no name (so no setbank)
   241  7847 20bdff                             jsr     _setnam
   242  784a 20c0ff                             jsr     _open                           ; get command channel
   243  784d a200                               ldx     #doslfn
   244  784f 20c6ff                             jsr     _chkin
   245  7852 b023                               bcs     l244_4                          ; a problem (file already open??)
   246                          
   247  7854 a0ff                               ldy     #$ff
   248  7856 c8                 l244_2          iny                                     ; read disk error message
   249  7857 20cfff                             jsr     _basin
   250  785a c90d                               cmp     #cr
   251  785c f009                               beq     l244_3                          ; if eol
   252  785e a27a                               ldx     #dsdesc+1
   253  7860 20f022                             jsr     sta_far_ram1                    ; sta (dsdesc+1),y copy to DS$
   254  7863 c028                               cpy     #40
   255  7865 90ef                               bcc     l244_2                          ; loop unless too long
   256                          
   257  7867 a900               l244_3          lda     #0                              ; errend.
   258  7869 a27a                               ldx     #dsdesc+1                       ; terminate DS$ with a null
   259  786b 20f022                             jsr     sta_far_ram1                    ; sta (dsdesc+1),y
   260                          
   261  786e 20ccff                             jsr     _clrch                          ; shut down command channel
   262  7871 a900                               lda     #doslfn
   263  7873 38                                 sec                                     ; not a real close
   264  7874 4cc3ff                             jmp     _close                          ; close it and rts
   265                          
   266  7877 48                 l244_4          pha                                     ; errbad.
   267  7878 206778                             jsr     l244_3
   268  787b 208278                             jsr     Clear_DS                        ; flag 'no DS available'
   269  787e fa                                 plx                                     ; get error
   270  787f 83ceb5                             +lbra   error
   271                          
   272                          
   273                          ; Clear_DS subroutine - forget current DS$ message, if any
   274                          ;
   275                          
   276                          Clear_DS                                                ; oldclr.
   277  7882 a579                               lda     dsdesc                          ; check for allocation
   278  7884 f013                               beq     l245_1                          ; branch if not allocated
   279                          
   280  7886 5a                                 phy                                     ; mark current DS$ string as garbage
   281  7887 da                                 phx
   282                          ; lda #40   ;   standard DS$ allocation
   283  7888 a8                                 tay
   284  7889 a27a                               ldx     #dsdesc+1
   285  788b 20f022                             jsr     sta_far_ram1                    ; sta (dsdesc+1),y length of garbage
   286  788e c8                                 iny
   287  788f a9ff                               lda     #$ff
   288  7891 20f022                             jsr     sta_far_ram1                    ; sta (dsdesc+1),y garbage flagged
   289  7894 1a                                 inc
   290  7895 8579                               sta     dsdesc                          ; (0)    kill DS$
   291  7897 fa                                 plx
   292  7898 7a                                 ply
   293                          
   294  7899 60                 l245_1          rts
   295                          
   296                          
   297                          ; Read DOS error message, but don't care what it is.  Want to stop disk LED blink.
   298                          ;
   299                          
   300                          Suck_DS
   301  789a ae8211                             ldx     dosfa                           ; fa
   302  789d a900                               lda     #doslfn                         ; la (reserved la)
   303  789f a06f                               ldy     #$6f                            ; sa (command channel)
   304  78a1 20baff                             jsr     _setlfs
   305  78a4 a900                               lda     #0                              ; no name (so no setbank)
   306  78a6 20bdff                             jsr     _setnam
   307  78a9 20c0ff                             jsr     _open                           ; get command channel
   308  78ac a200                               ldx     #doslfn
   309  78ae 20c6ff                             jsr     _chkin
   310  78b1 b007                               bcs     l246_2                          ; skip input if problem
   311                          
   312  78b3 20cfff             l246_1          jsr     _basin                          ; read disk error message
   313  78b6 c90d                               cmp     #cr
   314  78b8 d0f9                               bne     l246_1                          ; loop until eol
   315                          
   316  78ba 20ccff             l246_2          jsr     _clrch                          ; shut down command channel
   317  78bd a900                               lda     #doslfn
   318  78bf 38                                 sec                                     ; not a real close
   319  78c0 4cc3ff                             jmp     _close                          ; close it
   320                          
   321                          
   322                          ; R-U-sure subroutine
   323                          
   324                          are_you_sure
   325                          
   326  78c3 ff7e29                             bbs7    runmod,response_fake            ; branch if not direct mode
   327                          
   328  78c6 207dff                             jsr     _primm                          ; else prompt user for y/n answer
   329  78c9 41524520594f5520...                !text "ARE YOU SURE? ", 0
   330                          
   331                          
   332                          response_get
   333  78d8 20ccff                             jsr     _clrch                          ; clear channel for basin
   334  78db 20cfff                             jsr     _basin                          ; next char
   335  78de 48                                 pha                                     ; save first char of reply
   336                          
   337  78df c90d               l247_1          cmp     #cr                             ; eat chars until end of line
   338  78e1 f005                               beq     l247_2                          ; if cr received, exit
   339  78e3 20cfff                             jsr     _basin
   340  78e6 d0f7                               bne     l247_1                          ; continue to ignore
   341                          
   342  78e8 20d2ff             l247_2          jsr     _bsout                          ; new line     [910212] FAB
   343  78eb 68                                 pla
   344  78ec c959                               cmp     #'Y'                            ; z set means ans=y.....
   345  78ee 60                                 rts
   346                          
   347                          
   348                          response_fake
   349  78ef a900                               lda     #0                              ; ...or not in direct mode
   350  78f1 60                                 rts
   351                          
   352                          ;.end
   353                          
   354                          
   355                          
   356                          ;*****************************************************************
   357                          ;  OPTWRD - get an optional, unsigned 2-byte value in y,a.
   358                          ;
   359                          ;      case 1 : pointer at end of line:
   360                          ;   return a=y=0, clear c to flag 'default'
   361                          ;      case 2 : pointer is at comma, next non-blank is also a comma:
   362                          ;   return a=y=0, clear c to flag 'default'
   363                          ;      case 3 : pointer is at comma, next non-blank is not a comma:
   364                          ;   get word in y,a, set c to flag 'non-default'
   365                          ;*****************************************************************
   366                          
   367  78f2 208522             optwrd          jsr     chrgot
   368  78f5 f00c                               beq     l248_1
   369  78f7 205b4e                             jsr     chkcom
   370  78fa c92c                               cmp     #','
   371  78fc f005                               beq     l248_1
   372  78fe 208a5d                             jsr     getwrd
   373  7901 38                                 sec
   374  7902 60                                 rts
   375                          
   376  7903 a900               l248_1          lda     #0
   377  7905 a8                                 tay
   378                          
   379  7906 18                 optw99          clc
   380  7907 60                                 rts
   381                          
   382                          
   383  7908 205b4e             comsad          jsr     chkcom                          ; get a comma & signed 2-byte arg in y,a   [910307]
   384  790b 83d83e                             +lbra   sadwrd
   385                          
   386                          
   387                          
   388  790e 208522             optsad          jsr     chrgot                          ; get a comma & optional, signed 2-byte arg in y,a [910307]
   389  7911 f00c                               beq     l249_1                          ; eol, therefore this arg is not specified
   390  7913 205b4e                             jsr     chkcom                          ; eat comma
   391  7916 c92c                               cmp     #','                            ; is next a comma too?
   392  7918 f005                               beq     l249_1                          ; yes, therefore this arg is not specified
   393  791a 20e5b7                             jsr     sadwrd                          ; get signed word
   394  791d 38                                 sec
   395  791e 60                                 rts
   396                          
   397  791f a900               l249_1          lda     #0                              ; default optional arg to zero
   398  7921 a8                                 tay
   399  7922 18                                 clc
   400  7923 60                                 rts
   401                          
   402                          
   403                          ;*****************************************************************
   404                          ;  OPTBYT - get an optional 1 byte value in x.
   405                          ;
   406                          ;  Enter with default value in x.
   407                          ;
   408                          ;      case 1 : pointer at end of line:
   409                          ;   return default x.
   410                          ;      case 2 : pointer is at comma, next non-blank is also a comma:
   411                          ;   return default x.
   412                          ;      case 3 : pointer is at comma, next non-blank is not a comma:
   413                          ;   get byte in x.
   414                          ;*****************************************************************
   415                          
   416  7924 a200               optzer          ldx     #0                              ; optional byte, with default=0
   417                          
   418  7926 208522             optbyt          jsr     chrgot
   419  7929 f0db                               beq     optw99                          ; EOL: clc/rts
   420  792b 205b4e                             jsr     chkcom
   421  792e c92c                               cmp     #','
   422  7930 f0d4                               beq     optw99                          ; Comma: clc/rts
   423  7932 206c5d                             jsr     getbyt
   424  7935 38                                 sec
   425  7936 60                                 rts
   426                          
   427                          
   428                          prtdec
   429  7937 5a                                 phy
   430  7938 da                                 phx
   431  7939 aa                                 tax                                     ; prints decimal value of chr in .a
   432  793a a900                               lda     #0
   433  793c 207f64                             jsr     linprt
   434  793f fa                                 plx
   435  7940 7a                                 ply
   436  7941 60                                 rts
   437                          
   438                          
   439                          
   440                          retpat                                                  ; f.bowen
   441  7942 88                                 dey                                     ; [910828]
   442  7943 b13f                               lda     (fndpnt),y                      ; restore pointers
   443  7945 853e                               sta     txtptr+1
   444  7947 88                                 dey
   445  7948 b13f                               lda     (fndpnt),y
   446  794a 853d                               sta     txtptr
   447  794c 88                                 dey
   448  794d b13f                               lda     (fndpnt),y
   449                          
   450  794f 853c                               sta     curlin+1                        ; fixes a problem when RETURNing to a GOSUB in direct mode
   451  7951 88                                 dey                                     ; or LOOPing to a DO in direct mode. 'curlin+1' must not be
   452  7952 aa                                 tax                                     ; restored to $ff without also resetting 'runmod'
   453  7953 e8                                 inx
   454  7954 d004                               bne     l250_1                          ; branch if GOSUB or DO was from a program
   455  7956 a9c0                               lda     #%11000000
   456  7958 147e                               trb     runmod                          ; else force return to direct mode
   457                          
   458  795a b13f               l250_1          lda     (fndpnt),y
   459  795c 853b                               sta     curlin
   460  795e 60                                 rts
   461                          
   462                          
   463  795f 010204010204       vbits           !text $01,$02,$04,$01,$02,$04           ; for stereo filter, volume bit setting
   464  7965 0102040810204080   sbits           !text $01,$02,$04,$08,$10,$20,$40,$80
   465  796d 8040201008040201   rbits           !text $80,$40,$20,$10,$08,$04,$02,$01
   466                          
   467                          ;.end
   468                          
   469                          ; ********************************************************************************************
   470                          ;
   471                          ;	Date		Changes
   472                          ;	====		=======
   473                          ;
   474                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: handler/irq.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      irq.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          basic_irq
    16                          ; lda _vicIRQ  ;a VIC raster interrupt?
    17                          ; and #%10000001  ; (used to update moving sprites & sound stuff)
    18                          ; cmp #%10000001
    19                          ; bne collision_irq ; no, go check other VIC interrupts
    20                          
    21  7975 addb02                             lda     irq_wrap_flag                   ; filter out wrapped IRQ calls (allows interruptable code)
    22  7978 f001                               beq     l251_1                          ; it's ok
    23  797a 60                                 rts                                     ; exit- we're already handling one interrupt
    24                          
    25  797b eedb02             l251_1          inc     irq_wrap_flag                   ; shut the door
    26  797e 58                                 cli                                     ; but leave the window open
    27                          
    28                          
    29                          ; Test if there was a VIC collision/light pen interrupt
    30                          
    31                          collision_irq
    32                          ; sei
    33  797f a5a0                               lda     _vicIRQ                         ; check VIC IRQ flags
    34  7981 290e                               and     #%00001110                      ; mask all but lp, s/s, and s/bgnd flags
    35  7983 f04c                               beq     l252_5                          ; exit if none set
    36  7985 14a0                               trb     _vicIRQ                         ; else reset flags we're going to handle
    37  7987 4a                                 lsr                                     ; shift out raster interrupt bit (not used)
    38                          
    39                          ; Test for 3 types of collision interrupts : sprite/sprite, sprite/bgnd, & light pen
    40                          
    41  7988 a001                               ldy     #1                              ; loop for sprite/bgnd and sprite/sprite collision check
    42  798a 4a                 l252_1          lsr
    43  798b 901b                               bcc     l252_4                          ; bit not set ==> not source of interrupt
    44                          
    45  798d 48                                 pha
    46  798e b91ed0                             lda     vic+30,y                        ; accumulate collision data (resets register)
    47  7991 19e602                             ora     collisions,y
    48  7994 99e602                             sta     collisions,y
    49                          
    50  7997 addc02                             lda     intval                          ; allowable interrupts
    51  799a c000                               cpy     #0                              ; examine selected bit
    52  799c f001                               beq     l252_2
    53  799e 4a                                 lsr
    54  799f 4a                 l252_2          lsr
    55  79a0 9005                               bcc     l252_3                          ; BASIC doesn't want this interrupt
    56  79a2 a9ff                               lda     #$ff
    57  79a4 99dd02                             sta     int_trip_flag,y                 ; turn on trip flag
    58                          
    59  79a7 68                 l252_3          pla
    60                          
    61  79a8 88                 l252_4          dey
    62  79a9 10df                               bpl     l252_1
    63                          
    64                          
    65                          ; Check light pen latch
    66                          
    67  79ab 4a                                 lsr
    68  79ac 9023                               bcc     l252_5                          ; LightPen latch not valid
    69                          
    70  79ae ae31d0                             ldx     vic+49                          ; 4567R7 bug- must read LP_latches in Slow mode????
    71  79b1 a940                               lda     #%01000000                      ; [910618]
    72  79b3 1c31d0                             trb     vic+49
    73  79b6 ac13d0                             ldy     vic+19                          ; save latched x position
    74  79b9 8ce802                             sty     lightpen_xpos
    75  79bc ac14d0                             ldy     vic+20                          ; save latched y position
    76  79bf 8ce902                             sty     lightpen_ypos
    77  79c2 8e31d0                             stx     vic+49                          ; restore speed     [910618]
    78                          
    79  79c5 addc02                             lda     intval                          ; is BASIC interested in our little find?
    80  79c8 2904                               and     #4
    81  79ca f005                               beq     l252_5                          ; no, move on to next IRQ task
    82  79cc a9ff                               lda     #$ff
    83  79ce 8ddf02                             sta     int_trip_flag+2                 ; yes- let BASIC know we caught one
    84                          
    85                          l252_5
    86                          
    87                          ; Update moving sprites
    88                          
    89                          movspr_irq
    90  79d1 ad15d0                             lda     vic+21                          ; any sprites active?    [910212]
    91  79d4 f3f100                             +lbeq   music_irq                       ; no- skip ahead
    92                          
    93  79d7 a007                               ldy     #7                              ; check each of 8 sprites
    94  79d9 ad15d0             l253_1          lda     vic+21                          ; is this sprite is enabled?
    95  79dc 396579                             and     sbits,y
    96  79df f03d                               beq     l253_5                          ; sprite not enabled
    97                          
    98  79e1 befeb7                             ldx     sproff,y                        ; get offset to sprite info from a table
    99  79e4 bd0512                             lda     sprite_data,x                   ; is this sprite moving (speed >0 )?
   100  79e7 f035                               beq     l253_5                          ; sprite not moving
   101  79e9 1005                               bpl     l253_2                          ; sprite moving, no destination
   102  79eb 633700                             bsr     movspr_to_irq                   ; sprite moving to a destination [910809]
   103  79ee 802e                               bra     l253_5
   104                          
   105  79f0 9d0612             l253_2          sta     sprite_data+1,x                 ; set counter
   106  79f3 98                 l253_3          tya                                     ; convert sprite# to a VIC register pointer
   107  79f4 0a                                 asl
   108  79f5 a8                                 tay
   109  79f6 bd0712                             lda     sprite_data+2,x                 ; get angle sign
   110  79f9 3a                                 dec                                     ; subtract 1 for cosine
   111  79fa e8                                 inx
   112  79fb e8                                 inx
   113  79fc c8                                 iny
   114  79fd 20c67b                             jsr     sprsub                          ; update y position
   115  7a00 ca                                 dex
   116  7a01 ca                                 dex
   117  7a02 88                                 dey
   118  7a03 bd0712                             lda     sprite_data+2,x
   119  7a06 20c67b                             jsr     sprsub                          ; update x position
   120  7a09 08                                 php
   121  7a0a 98                                 tya
   122  7a0b 4a                                 lsr                                     ; restore index (.Y=sprite pointer)
   123  7a0c a8                                 tay
   124  7a0d 28                                 plp
   125  7a0e 9009                               bcc     l253_4                          ; skip if no overflow
   126  7a10 ad10d0                             lda     vic+16                          ; get x position msb bits ???vic_save
   127  7a13 596579                             eor     sbits,y                         ; invert bit
   128  7a16 8d10d0                             sta     vic+16                          ; ???vic_save
   129  7a19 de0612             l253_4          dec     sprite_data+1,x
   130  7a1c d0d5                               bne     l253_3                          ; loop until counter done
   131                          
   132  7a1e 88                 l253_5          dey                                     ; check next sprite
   133  7a1f 10b8                               bpl     l253_1                          ; loop until done moving all sprites
   134  7a21 83a400                             +lbra   music_irq                       ; then continue with next IRQ task
   135                          
   136                          movspr_to_irq                                           ; [910809]
   137  7a24 5a                                 phy                                     ; sprite #
   138  7a25 293f                               and     #$3f                            ; speed factor
   139  7a27 4b                                 taz
   140  7a28 98                                 tya                                     ; vic sprite index
   141  7a29 0a                                 asl
   142  7a2a a8                                 tay
   143                          
   144  7a2b 38                 l254_1          sec                                     ; for i = 1 to abs(greatr)
   145  7a2c bd0612                             lda     sprite_data+1,x
   146  7a2f e901                               sbc     #1
   147  7a31 9d0612                             sta     sprite_data+1,x
   148  7a34 b011                               bcs     l254_2
   149  7a36 bd0712                             lda     sprite_data+2,x
   150  7a39 e900                               sbc     #0
   151  7a3b 9d0712                             sta     sprite_data+2,x
   152  7a3e b007                               bcs     l254_2
   153  7a40 a900                               lda     #0
   154  7a42 9d0512                             sta     sprite_data,x                   ; done!  sprite is at its destination
   155  7a45 7a                                 ply                                     ; remember sprite #
   156  7a46 60                                 rts
   157                          
   158  7a47 bd0812             l254_2          lda     sprite_data+3,x                 ; ptr(lesser)
   159  7a4a 3c0f12                             bit     sprite_data+10,x
   160  7a4d 3009                               bmi     l254_3                          ; if e > 0
   161  7a4f 3c0812                             bit     sprite_data+3,x                 ; sgn(lesser) (b7=1=neg, b6=1=pos, else 0)
   162  7a52 20907a                             jsr     drwinc                          ; pos(lesser) = pos(lesser) + sgn(lesser)
   163                          
   164  7a55 bd0912                             lda     sprite_data+4,x                 ; ptr(greater)
   165  7a58 4a                 l254_3          lsr                                     ; which f?
   166  7a59 b014                               bcs     l254_4
   167  7a5b bd0e12                             lda     sprite_data+9,x                 ; e = e + f1
   168  7a5e 7d0a12                             adc     sprite_data+5,x
   169  7a61 9d0e12                             sta     sprite_data+9,x
   170  7a64 bd0f12                             lda     sprite_data+10,x
   171  7a67 7d0b12                             adc     sprite_data+6,x
   172  7a6a 9d0f12                             sta     sprite_data+10,x
   173  7a6d 8013                               bra     l254_5
   174                          
   175  7a6f 18                 l254_4          clc
   176  7a70 bd0e12                             lda     sprite_data+9,x                 ; e = e + f2
   177  7a73 7d0c12                             adc     sprite_data+7,x
   178  7a76 9d0e12                             sta     sprite_data+9,x
   179  7a79 bd0f12                             lda     sprite_data+10,x
   180  7a7c 7d0d12                             adc     sprite_data+8,x
   181  7a7f 9d0f12                             sta     sprite_data+10,x
   182                          
   183  7a82 bd0912             l254_5          lda     sprite_data+4,x                 ; ptr(greater)
   184  7a85 3c0912                             bit     sprite_data+4,x                 ; sgn(greater) (b7=1=neg, b6=1=pos, else 0)
   185  7a88 20907a                             jsr     drwinc                          ; pos(greater) = pos(greater) + sgn(greater)
   186                          
   187  7a8b 3b                                 dez                                     ; count
   188  7a8c d09d                               bne     l254_1
   189  7a8e 7a                                 ply                                     ; remember sprite #
   190  7a8f 60                                 rts                                     ; done this frame
   191                          
   192                          
   193  7a90 08                 drwinc          php
   194  7a91 2901                               and     #1                              ; adjust .y for x or y position
   195  7a93 f001                               beq     l255_1                          ; 0=x
   196  7a95 c8                                 iny                                     ; 1=y
   197  7a96 28                 l255_1          plp
   198  7a97 300b                               bmi     l255_2                          ; enter with b7=negative, b6=positive, else zero
   199  7a99 5027                               bvc     l255_4
   200                          
   201  7a9b b900d0                             lda     vic,y                           ; positive direction
   202  7a9e 1a                                 inc
   203  7a9f 9900d0                             sta     vic,y
   204  7aa2 8009                               bra     l255_3
   205                          
   206  7aa4 b900d0             l255_2          lda     vic,y                           ; negative direction
   207  7aa7 3a                                 dec
   208  7aa8 9900d0                             sta     vic,y
   209  7aab c9ff                               cmp     #$ff
   210                          
   211  7aad d013               l255_3          bne     l255_4                          ; no wrap
   212  7aaf 98                                 tya
   213  7ab0 8901                               bit     #1
   214  7ab2 d00e                               bne     l255_4                          ; wrap in y okay
   215  7ab4 4a                                 lsr
   216  7ab5 a8                                 tay
   217  7ab6 b96579                             lda     sbits,y                         ; wrap in x- toggle msb
   218  7ab9 4d10d0                             eor     vic+16
   219  7abc 8d10d0                             sta     vic+16
   220  7abf 98                                 tya
   221  7ac0 0a                                 asl
   222  7ac1 a8                                 tay
   223                          
   224  7ac2 98                 l255_4          tya                                     ; restore y to sprite offset
   225  7ac3 29fe                               and     #$fe
   226  7ac5 a8                                 tay
   227  7ac6 60                                 rts
   228                          
   229                          
   230                          ; Play music, if in progress
   231                          
   232                          music_irq
   233  7ac7 a200                               ldx     #0
   234  7ac9 bc5e12             l256_1          ldy     voices+1,x
   235  7acc 3025                               bmi     l256_2                          ; skip if not active
   236                          
   237  7ace bd5d12                             lda     voices,x
   238  7ad1 38                                 sec
   239  7ad2 ed7312                             sbc     tempo_rate                      ; decrement current value by current tempo
   240  7ad5 9d5d12                             sta     voices,x
   241  7ad8 b019                               bcs     l256_2
   242  7ada 98                                 tya                                     ; lda voices+1,x
   243  7adb e900                               sbc     #0
   244  7add 9d5e12                             sta     voices+1,x
   245  7ae0 b011                               bcs     l256_2                          ; ok, no underflow
   246                          
   247  7ae2 8a                                 txa
   248  7ae3 4a                                 lsr                                     ; get offset to waveform
   249  7ae4 a8                                 tay
   250  7ae5 b96912                             lda     waveform,y                      ; get waveform
   251  7ae8 29fe                               and     #$fe                            ; mask out gate bit
   252  7aea 48                                 pha
   253  7aeb b9004a                             lda     SID_offset,y                    ; get offset to correct oscillator
   254  7aee a8                                 tay
   255  7aef 68                                 pla
   256                          ; jsr go_slow  ;      [910716] 4567R7A
   257  7af0 9904d4                             sta     sid1+4,y                        ; turn off sound
   258                          ; jsr go_fast  ;      [910716] 4567R7A
   259                          
   260  7af3 e8                 l256_2          inx
   261  7af4 e8                                 inx
   262  7af5 e00c                               cpx     #6+6                            ; [910612]
   263  7af7 90d0                               bcc     l256_1                          ; loop for 6 voices
   264                          ;then continue with next IRQ task
   265                          
   266                          ; Test if SOUND command wants anything
   267                          
   268                          sound_irq
   269  7af9 a005                               ldy     #6-1                            ; test six voices    [910612]
   270  7afb b9c412             l257_1          lda     sound_time_hi,y                 ; active if msb clear
   271  7afe 1006                               bpl     l257_3
   272  7b00 88                 l257_2          dey
   273  7b01 10f8                               bpl     l257_1
   274  7b03 83bc00                             +lbra   basic_irq_end
   275                          
   276  7b06 18                 l257_3          clc                                     ; add step to frequency
   277  7b07 b9f412                             lda     sound_freq_lo,y
   278  7b0a 79e812                             adc     sound_step_lo,y
   279  7b0d 99f412                             sta     sound_freq_lo,y
   280  7b10 b9fa12                             lda     sound_freq_hi,y
   281  7b13 79ee12                             adc     sound_step_hi,y
   282  7b16 99fa12                             sta     sound_freq_hi,y
   283                          
   284  7b19 b9e212                             lda     sound_direction,y               ; test if this is up or down
   285  7b1c aa                                 tax
   286  7b1d 2901                               and     #1
   287  7b1f f02d                               beq     l257_6                          ; branch if up
   288                          
   289                          ; If step direction is down, .C==0 OR freq < min  ==> reset value
   290                          
   291  7b21 900f                               bcc     l257_4                          ; underflow, reset
   292  7b23 38                                 sec
   293  7b24 b9f412                             lda     sound_freq_lo,y
   294  7b27 f9d612                             sbc     sound_min_lo,y
   295  7b2a b9fa12                             lda     sound_freq_hi,y
   296  7b2d f9dc12                             sbc     sound_min_hi,y
   297  7b30 b04c                               bcs     l257_9                          ; no borrow, don't reset
   298                          
   299  7b32 e002               l257_4          cpx     #2                              ; is 'cycle' bit set?
   300  7b34 900a                               bcc     l257_5                          ; no, keep direction 'down'
   301                          
   302  7b36 20ab7b                             jsr     negate_step                     ; make step 2's comp
   303  7b39 a902                               lda     #2                              ; change direction to 'up'
   304  7b3b 99e212                             sta     sound_direction,y
   305  7b3e d032                               bne     l257_8                          ; go reset for 'up'
   306                          
   307  7b40 b9ca12             l257_5          lda     sound_max_lo,y                  ; reset to max
   308  7b43 99f412                             sta     sound_freq_lo,y
   309  7b46 b9d012                             lda     sound_max_hi,y
   310  7b49 99fa12                             sta     sound_freq_hi,y
   311  7b4c 8030                               bra     l257_9                          ; go update SID frequency
   312                          
   313                          ; If step direction is up, overflow (.C==1) OR freq > max ==> reset frequency
   314                          
   315  7b4e b014               l257_6          bcs     l257_7                          ; overflow, must reset
   316  7b50 b9fa12                             lda     sound_freq_hi,y                 ; 16 bit compare (yech!)
   317  7b53 d9d012                             cmp     sound_max_hi,y
   318  7b56 9026                               bcc     l257_9                          ; freq < max, no reset
   319  7b58 d00a                               bne     l257_7                          ; freq > max, reset
   320  7b5a b9f412                             lda     sound_freq_lo,y                 ; msb's the same, test lsb's
   321  7b5d d9ca12                             cmp     sound_max_lo,y
   322  7b60 901c                               bcc     l257_9                          ; freq < max, no reset
   323  7b62 f01a                               beq     l257_9                          ; freq = max, no reset
   324                          
   325  7b64 e002               l257_7          cpx     #2                              ; is this 'cycle'?
   326  7b66 900a                               bcc     l257_8                          ; no, go reset for next 'up'
   327                          
   328  7b68 20ab7b                             jsr     negate_step                     ; make step 2's comp
   329  7b6b a903                               lda     #3                              ; change direction to 'down'
   330  7b6d 99e212                             sta     sound_direction,y
   331  7b70 d0ce                               bne     l257_5                          ; go reset for next 'down'
   332                          
   333  7b72 b9d612             l257_8          lda     sound_min_lo,y                  ; set freq to minimum value
   334  7b75 99f412                             sta     sound_freq_lo,y
   335  7b78 b9dc12                             lda     sound_min_hi,y
   336  7b7b 99fa12                             sta     sound_freq_hi,y
   337                          
   338                          ; Update SID frequency registers
   339                          
   340                          l257_9
   341                          ; jsr go_slow  ;      [910716] 4567R7A
   342  7b7e be004a                             ldx     SID_offset,y                    ; get index to SID voices
   343  7b81 b9f412                             lda     sound_freq_lo,y
   344  7b84 9d00d4                             sta     sid1,x
   345  7b87 b9fa12                             lda     sound_freq_hi,y
   346  7b8a 9d01d4                             sta     sid1+1,x
   347                          ; jsr go_fast  ;      [910716] 4567R7A
   348                          
   349                          ; Decrement total time - see if it's time to bring down the curtain
   350                          
   351  7b8d 98                                 tya
   352  7b8e aa                                 tax
   353  7b8f bdbe12                             lda     sound_time_lo,x                 ; 16 bit decrement - not very pretty
   354  7b92 d003                               bne     l257_10
   355  7b94 dec412                             dec     sound_time_hi,x
   356  7b97 debe12             l257_10         dec     sound_time_lo,x
   357                          
   358  7b9a bdc412                             lda     sound_time_hi,x                 ; underflow?
   359  7b9d 1361ff                             +lbpl   l257_2                          ; nope
   360                          
   361                          ; Time to turn off this voice
   362                          
   363                          ; jsr go_slow  ;      [910716] 4567R7A
   364  7ba0 a908                               lda     #$08
   365  7ba2 be004a                             ldx     SID_offset,y
   366  7ba5 9d04d4                             sta     sid1+4,x
   367                          ; jsr go_fast  ;      [910716] 4567R7A
   368  7ba8 8356ff                             +lbra   l257_2
   369                          
   370                          
   371                          negate_step
   372  7bab b9e812                             lda     sound_step_lo,y
   373  7bae 49ff                               eor     #$ff
   374  7bb0 18                                 clc
   375  7bb1 6901                               adc     #1
   376  7bb3 99e812                             sta     sound_step_lo,y
   377  7bb6 b9ee12                             lda     sound_step_hi,y
   378  7bb9 49ff                               eor     #$ff
   379  7bbb 6900                               adc     #0
   380  7bbd 99ee12                             sta     sound_step_hi,y
   381  7bc0 60                                 rts
   382                          
   383                          
   384                          
   385                          ; Here is where BASIC_IRQ exits
   386                          
   387                          basic_irq_end
   388  7bc1 cedb02                             dec     irq_wrap_flag                   ; open the door to IRQ
   389  7bc4 58                                 cli
   390  7bc5 60                                 rts
   391                          
   392                          
   393                          ; Update sprite position subroutine
   394                          
   395  7bc6 48                 sprsub          pha                                     ; save angle phase
   396  7bc7 18                                 clc
   397  7bc8 bd0812                             lda     sprite_data+3,x                 ; add low bytes
   398  7bcb 7d0c12                             adc     sprite_data+7,x
   399  7bce 9d0c12                             sta     sprite_data+7,x
   400  7bd1 bd0912                             lda     sprite_data+4,x                 ; add high bytes
   401  7bd4 7d0d12                             adc     sprite_data+8,x
   402  7bd7 9d0d12                             sta     sprite_data+8,x
   403  7bda 68                                 pla                                     ; get angle sign
   404  7bdb 9012                               bcc     l258_3                          ; skip if no carry - do not update position
   405  7bdd 4a                                 lsr
   406  7bde 4a                                 lsr                                     ; test if positive or negative
   407  7bdf b900d0                             lda     vic,y                           ; ???vic_save
   408  7be2 b004                               bcs     l258_1                          ; skip if negative
   409  7be4 6901                               adc     #1                              ; increment position
   410  7be6 8004                               bra     l258_2
   411                          
   412  7be8 e901               l258_1          sbc     #1                              ; decrement position
   413  7bea c9ff                               cmp     #$ff                            ; set carry if underflow
   414  7bec 9900d0             l258_2          sta     vic,y                           ; decrement position  ???vic_save
   415  7bef 60                 l258_3          rts
   416                          
   417                          ;.end
   418                          
   419                          ; ********************************************************************************************
   420                          ;
   421                          ;	Date		Changes
   422                          ;	====		=======
   423                          ;
   424                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/mouse.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      mouse.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;***********************************************************************
    16                          ;*   MOUSE  ON  [,[port] [,[sprite] [,[hotspot] [,X/Yposition] ]]]
    17                          ;*   MOUSE  OFF
    18                          ;*    where: port     = (1...3) for joyport 1, 2, or either (both)
    19                          ;*  sprite   = (0...7) sprite pointer
    20                          ;*  hotspot  = x,y offset in sprite, default 0,0
    21                          ;*  position = normal, relative, or angluar coordinates
    22                          ;*
    23                          ;*      (defaults to sprite 0, port 2, last hotspot & position)
    24                          ;***********************************************************************
    25                          
    26  7bf0 c991               mouse           cmp     #on_token                       ; new [910122]
    27  7bf2 f010                               beq     l259_1
    28  7bf4 2016b5                             jsr     chkesc
    29  7bf7 c924                               cmp     #off_token
    30  7bf9 d34fb2                             +lbne   snerr
    31                          
    32                          ;    The Kernel MOUSE_CMD is called to install or remove mouse driver.
    33                          ; .a= B7,6 set to install mouse in game port 2 ($80), 1 ($40), or both ($C0)
    34                          ; .a= 0 to disable mouse driver
    35                          ; .x= 0-7 physical sprite pointer
    36                          
    37  7bfc a900                               lda     #0                              ; TURN MOUSE OFF
    38  7bfe 201be0                             jsr     _mouse                          ; do it
    39  7c01 831f39                             +lbra   chkeos                          ; eat token & exit after checking for eos
    40                          
    41                          ;TURN MOUSE ON
    42  7c04 208322             l259_1          jsr     chrget                          ; eat token
    43  7c07 a202                               ldx     #2                              ; get (optional) port# in .X
    44  7c09 202679                             jsr     optbyt                          ; if not present default to port 2
    45  7c0c e004                               cpx     #4                              ;
    46  7c0e b3eed5                             +lbcs   fcerr                           ; illegal value
    47  7c11 da                                 phx
    48                          
    49  7c12 a200                               ldx     #0                              ; get (optional) sprite# in .X
    50  7c14 202679                             jsr     optbyt                          ; if not present default to sprite 0
    51  7c17 e008                               cpx     #8
    52  7c19 b3e3d5                             +lbcs   fcerr                           ; illegal value
    53  7c1c 8676                               stx     z_p_temp_1
    54  7c1e bcfeb7                             ldy     sproff,x                        ; kill moving sprite
    55  7c21 a900                               lda     #0                              ; get offset to speed data
    56  7c23 990512                             sta     sprite_data,y                   ; reset sprite's speed value
    57                          
    58  7c26 68                                 pla                                     ; setup for Kernel call- get port# into b7,6
    59  7c27 6a                                 ror                                     ; .a= port(s), .x=sprite
    60  7c28 6a                                 ror
    61  7c29 6a                                 ror
    62  7c2a 201be0                             jsr     _mouse                          ; do it (???? do after coord error check)
    63                          
    64                          
    65  7c2d 202679                             jsr     optbyt                          ; get (optional) hotspot, x  new [910307]
    66  7c30 9014                               bcc     l259_2                          ; not given
    67  7c32 e018                               cpx     #24
    68  7c34 b3c8d5                             +lbcs   fcerr                           ; out of range (0-23)
    69  7c37 8a                                 txa
    70  7c38 42                                 neg
    71  7c39 aa                                 tax
    72  7c3a 6918                               adc     #24
    73  7c3c 8d3d11                             sta     _mouse_left
    74  7c3f 8a                                 txa
    75  7c40 18                                 clc
    76  7c41 6957                               adc     #87
    77  7c43 8d3e11                             sta     _mouse_right
    78                          
    79  7c46 202679             l259_2          jsr     optbyt                          ; get (optional) hotspot, y
    80  7c49 9014                               bcc     l259_3                          ; not given
    81  7c4b e015                               cpx     #21
    82  7c4d b3afd5                             +lbcs   fcerr                           ; out of range (0-20)
    83  7c50 8a                                 txa
    84  7c51 42                                 neg
    85  7c52 aa                                 tax
    86  7c53 6932                               adc     #50
    87  7c55 8d3b11                             sta     _mouse_top
    88  7c58 8a                                 txa
    89  7c59 18                                 clc
    90  7c5a 69fa                               adc     #250
    91  7c5c 8d3c11                             sta     _mouse_bottom
    92                          
    93  7c5f 208522             l259_3          jsr     chrgot                          ; get (optional) position coordinate  [910123]
    94  7c62 f028                               beq     l259_4                          ; eol, use this sprite's last position
    95  7c64 20c3b7                             jsr     sprcor                          ; else get first coordinate
    96  7c67 2cf411                             bit     numcnt                          ; test coordinate type
    97  7c6a 73deb1                             +lbvs   snerr                           ; syntax error
    98  7c6d 8cf011                             sty     xdest                           ; save coordinate value
    99  7c70 8cf211                             sty     xdest+2
   100  7c73 8df111                             sta     xdest+1
   101  7c76 8df311                             sta     xdest+3
   102                          
   103  7c79 a97f                               lda     #$7f                            ; flag 'mouse' for movspr call  [910808]
   104  7c7b 8587                               sta     op
   105  7c7d 20c3b7                             jsr     sprcor                          ; get second coordinate
   106  7c80 2cf411                             bit     numcnt                          ; test type of coordinate
   107  7c83 53bf39                             +lbvc   movspr_normal                   ; position sprite, normal coordinates
   108  7c86 339e39                             +lbmi   movspr_angle                    ; angular coordinates
   109  7c89 83bfb1                             +lbra   snerr                           ; else error
   110                          
   111  7c8c 60                 l259_4          rts
   112                          
   113                          ;.end
   114                          
   115                          ; ********************************************************************************************
   116                          ;
   117                          ;	Date		Changes
   118                          ;	====		=======
   119                          ;
   120                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/rmouse.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rmouse.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;************************************************************************
    15                          ;*   RMOUSE Returns in variable list current status of mouse *
    16                          ;*         *
    17                          ;*   Syntax: RMOUSE [Xposition [,Yposition [, Buttons] ]]  *
    18                          ;*         *
    19                          ;*   Where: X,Yposition = current position of mouse pointer sprite *
    20                          ;*  Button      = current status of mouse buttons  *
    21                          ;*         *
    22                          ;*   0   = no button     *
    23                          ;*   1   = right button    *
    24                          ;*   128 = left button    *
    25                          ;*   129 = both buttons    *
    26                          ;*         *
    27                          ;* If a mouse is not installed, "-1" is returned for all vars. *
    28                          ;* If both ports are enabled, buttons from each port are merged. *
    29                          ;************************************************************************
    30                          
    31  7c8d a900               rmouse          lda     #0                              ; Init
    32  7c8f 850d                               sta     count                           ; variable count = 0
    33  7c91 3a                                 dec
    34  7c92 a205                               ldx     #6-1
    35  7c94 9587               l260_1          sta     grapnt,x                        ; positions/buttons = -1
    36  7c96 ca                                 dex
    37  7c97 10fb                               bpl     l260_1
    38                          
    39  7c99 ad3511                             lda     _mouse_enable                   ; Is there a mouse in the house?
    40  7c9c 29c0                               and     #%11000000
    41  7c9e f050                               beq     l260_5                          ; no, exit
    42  7ca0 48                                 pha                                     ; yes, save port assigns for later
    43  7ca1 78                                 sei
    44  7ca2 ac3611                             ldy     _mouse_pointer                  ; Where is it?  Get pointer to sprite
    45  7ca5 b900d0                             lda     vic,y                           ; Get X position    ???vic_save
    46  7ca8 8587                               sta     grapnt                          ; lsb
    47  7caa b96579                             lda     sbits,y
    48  7cad 2d10d0                             and     vic+16                          ; msb    ???vic_save
    49  7cb0 f002                               beq     l260_2
    50  7cb2 a901                               lda     #1                              ; convert to 0 or 1
    51  7cb4 8588               l260_2          sta     grapnt+1
    52  7cb6 c8                                 iny                                     ; Get Y position
    53  7cb7 b900d0                             lda     vic,y                           ; lsb    ???vic_save
    54  7cba 8589                               sta     grapnt+2
    55  7cbc a900                               lda     #0                              ; msb (fake it)
    56  7cbe 858a                               sta     grapnt+3
    57                          
    58  7cc0 858b                               sta     grapnt+4                        ; Init button status
    59  7cc2 858c                               sta     grapnt+5
    60  7cc4 ab00dc                             ldz     d1pra                           ; Set up port & read buttons
    61  7cc7 a9ff                               lda     #$ff                            ; save kybd output lines (IRQ already disabled)
    62  7cc9 8d00dc                             sta     d1pra                           ; set to not read any kybd inputs
    63                          
    64  7ccc a000                               ldy     #0                              ; which port?
    65  7cce fa                                 plx                                     ; recall port assignments
    66  7ccf 8a                 l260_3          txa
    67  7cd0 0a                                 asl                                     ; .c=1 if this one
    68  7cd1 aa                                 tax
    69  7cd2 900f                               bcc     l260_4                          ; not this one
    70  7cd4 b900dc                             lda     d1pra,y                         ; read it (logical port is opposite physical port)
    71  7cd7 2911                               and     #%00010001                      ; want left, right buttons only
    72  7cd9 4911                               eor     #%00010001                      ; (invert, since low means button down)
    73  7cdb 048b                               tsb     grapnt+4
    74  7cdd 2910                               and     #%00010000                      ; shift left button to msb
    75  7cdf f002                               beq     l260_4
    76  7ce1 f78b                               smb7    grapnt+4
    77  7ce3 c8                 l260_4          iny                                     ; next port
    78  7ce4 c002                               cpy     #2
    79  7ce6 90e7                               bcc     l260_3
    80                          
    81  7ce8 a97e                               lda     #%01111110                      ; clean up
    82  7cea 148b                               trb     grapnt+4                        ; fix button register
    83  7cec 9c00dc                             stz     d1pra                           ; restore port for Kernel
    84  7cef 58                                 cli
    85                          
    86                          ; At this point, we have snapshot the current mouse status.
    87                          ; Now pass requested info along in a manner very similar to RREG...
    88                          
    89  7cf0 208522             l260_5          jsr     chrgot                          ; Get a variable name from variable list
    90  7cf3 f032                               beq     l260_8                          ; eol- exit
    91  7cf5 c92c                               cmp     #','                            ;
    92  7cf7 f01a                               beq     l260_7                          ; null- skip this arg
    93  7cf9 207c4f                             jsr     ptrget                          ; Get pointer to target variable
    94  7cfc 854b                               sta     forpnt                          ; set up so we can share LET code
    95  7cfe 844c                               sty     forpnt+1
    96  7d00 a50f                               lda     valtyp                          ; what kind of variable name did ptrget find?
    97  7d02 d3e3cf                             +lbne   chkerr                          ; string- type mismatch error
    98                          
    99  7d05 a60d               l260_6          ldx     count                           ; Make assignment
   100  7d07 b487                               ldy     grapnt,x                        ; low byte
   101  7d09 b588                               lda     grapnt+1,x                      ; high byte
   102  7d0b 203f4e                             jsr     givayf                          ; float it
   103  7d0e a510                               lda     intflg                          ; set flags for type of var (int/float)
   104  7d10 209336                             jsr     qintgr                          ; use part of LET to do the work
   105                          
   106  7d13 e60d               l260_7          inc     count                           ; Next assignment
   107  7d15 e60d                               inc     count
   108  7d17 a60d                               ldx     count
   109  7d19 e006                               cpx     #6                              ; there are 3 possible
   110  7d1b b00a                               bcs     l260_8                          ; done all 3, exit
   111  7d1d 208522                             jsr     chrgot                          ; check terminator
   112  7d20 f005                               beq     l260_8                          ; eol- exit
   113  7d22 205b4e                             jsr     chkcom                          ; check delimiter
   114  7d25 80c9                               bra     l260_5                          ; loop until done
   115                          
   116  7d27 60                 l260_8          rts
   117                          
   118                          ;.end
   119                          
   120                          ; ********************************************************************************************
   121                          ;
   122                          ;	Date		Changes
   123                          ;	====		=======
   124                          ;
   125                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/cursor.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      cursor.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*****************************************************************
    16                          ;*   CURSOR [ON|OFF,] [column] [,row [,style] ]
    17                          ;*
    18                          ;*   where: column,row = x,y logical screen position
    19                          ;*  style      = flashing (0) or solid (1)
    20                          ;*  ON,OFF     = to turn the cursor on or off
    21                          ;*****************************************************************
    22                          
    23  7d28 c991               cursor          cmp     #on_token                       ; Check for ON | OFF
    24  7d2a 18                                 clc
    25  7d2b f046                               beq     l261_3                          ; turn cursor on (.c=0)
    26  7d2d c9fe                               cmp     #esc_command_token
    27  7d2f d00a                               bne     l261_1                          ; (might be a function)
    28  7d31 2016b5                             jsr     chkesc
    29  7d34 c924                               cmp     #off_token                      ; turn cursor off (.c=1)
    30  7d36 f03b                               beq     l261_3
    31  7d38 8310b1                             +lbra   snerr
    32                          
    33  7d3b 48                 l261_1          pha                                     ; Evaluate cursor position parameters
    34  7d3c 38                                 sec
    35  7d3d 20f0ff                             jsr     _plot                           ; get current cursor position & save it
    36  7d40 8688                               stx     srow
    37  7d42 8487                               sty     column
    38                          
    39  7d44 a687                               ldx     column                          ; get new column, default=current column
    40  7d46 68                                 pla
    41  7d47 c92c                               cmp     #','
    42  7d49 f003                               beq     l261_2                          ; not given, use default
    43  7d4b 206c5d                             jsr     getbyt
    44  7d4e 8687               l261_2          stx     column
    45  7d50 a688                               ldx     srow                            ; get new row, default=current row
    46  7d52 202679                             jsr     optbyt
    47                          ; stx srow
    48  7d55 a487                               ldy     column
    49  7d57 18                                 clc
    50  7d58 20f0ff                             jsr     _plot                           ; set new cursor position
    51  7d5b b3a1d4                             +lbcs   fcerr                           ; error if bad position
    52                          
    53  7d5e 202479                             jsr     optzer                          ; Get new cursor type   ???? assumes screen output
    54  7d61 901d                               bcc     l261_4                          ; not given, exit
    55  7d63 a91b                               lda     #esc
    56  7d65 20d2ff                             jsr     _bsout                          ; use escape sequence to set
    57  7d68 8a                                 txa
    58  7d69 2901                               and     #1
    59  7d6b 4901                               eor     #1                              ; [910808]
    60  7d6d 18                                 clc
    61  7d6e 6945                               adc     #'E'                            ; 0=F=flash, 1=E=solid
    62  7d70 4cd2ff                             jmp     _bsout                          ; set it and exit
    63                          
    64  7d73 2030e0             l261_3          jsr     _cursor                         ; Turn cursor ON or OFF per .c
    65                          
    66  7d76 208322                             jsr     chrget                          ; eat token, get next character
    67  7d79 f005                               beq     l261_4                          ; eol- exit
    68  7d7b 205b4e                             jsr     chkcom                          ; else, must be comma
    69  7d7e 80bb                               bra     l261_1                          ; it is- go evaluate position
    70                          
    71  7d80 60                 l261_4          rts                                     ; eol
    72                          
    73                          
    74                          ; ********************************************************************************************
    75                          ;
    76                          ;	Date		Changes
    77                          ;	====		=======
    78                          ;
    79                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/rcursor.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rcursor.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;************************************************************************
    15                          ;*   RCURSOR Returns in variable list current cursor position *
    16                          ;*         *
    17                          ;*   Syntax: RCURSOR [column [,row] ]    *
    18                          ;************************************************************************
    19                          
    20  7d81 38                 rcursor         sec                                     ; new [910228]
    21  7d82 20f0ff                             jsr     _plot                           ; get current cursor position & save it
    22  7d85 8688                               stx     srow
    23  7d87 8487                               sty     column
    24                          
    25  7d89 a200                               ldx     #0                              ; just like RREG and RMOUSE...
    26  7d8b 860d                               stx     count
    27  7d8d 208522             l262_1          jsr     chrgot                          ; Get a variable name from variable list
    28  7d90 f030                               beq     l262_4                          ; eol- exit
    29  7d92 c92c                               cmp     #','                            ;
    30  7d94 f01a                               beq     l262_3                          ; null- skip this arg
    31  7d96 207c4f                             jsr     ptrget                          ; Get pointer to target variable
    32  7d99 854b                               sta     forpnt                          ; set up so we can share LET code
    33  7d9b 844c                               sty     forpnt+1
    34  7d9d a50f                               lda     valtyp                          ; what kind of variable name did ptrget find?
    35  7d9f d346cf                             +lbne   chkerr                          ; string- type mismatch error
    36                          
    37  7da2 a60d               l262_2          ldx     count                           ; Make assignment
    38  7da4 b487                               ldy     column,x                        ; low byte
    39  7da6 a900                               lda     #0                              ; high byte
    40  7da8 203f4e                             jsr     givayf                          ; float it
    41  7dab a510                               lda     intflg                          ; set flags for type of var (int/float)
    42  7dad 209336                             jsr     qintgr                          ; use part of LET to do the work
    43                          
    44  7db0 e60d               l262_3          inc     count                           ; Next assignment
    45  7db2 a60d                               ldx     count
    46  7db4 e002                               cpx     #2                              ; there are 2 possible
    47  7db6 b00a                               bcs     l262_4                          ; done 2, exit
    48  7db8 208522                             jsr     chrgot                          ; check terminator
    49  7dbb f005                               beq     l262_4                          ; eol- exit
    50  7dbd 205b4e                             jsr     chkcom                          ; check delimiter
    51  7dc0 80cb                               bra     l262_1                          ; loop until done
    52                          
    53  7dc2 60                 l262_4          rts
    54                          
    55                          ;.end
    56                          
    57                          
    58                          
    59                          AutoScroll
    60  7dc3 48                                 pha                                     ; save character for Editor
    61  7dc4 ff7e1e                             bbs7    runmod,AutoScrollno             ; branch if not direct mode
    62  7dc7 a415                               ldy     channl                          ; is output redirected?
    63  7dc9 d01a                               bne     AutoScrollno                    ; yes- can't do scroll (need to read screen)
    64  7dcb a52d                               lda     txttab
    65  7dcd a62e                               ldx     txttab+1                        ; is there a program in memory to scroll?
    66  7dcf 853d                               sta     txtptr
    67  7dd1 863e                               stx     txtptr+1
    68  7dd3 c8                                 iny                                     ; (1)
    69  7dd4 20c522                             jsr     indtxt
    70  7dd7 d011                               bne     AutoScrollyes                   ; yes- continue
    71  7dd9 800a                               bra     AutoScrollno                    ; no-  exit
    72                          
    73                          AutoScrollpop
    74  7ddb 68                                 pla
    75  7ddc 68                                 pla
    76                          AutoScrollng
    77  7ddd a67f                               ldx     point                           ; restore cursor position
    78  7ddf a480                               ldy     point+1
    79  7de1 18                                 clc
    80  7de2 20f0ff                             jsr     _plot
    81                          AutoScrollno
    82  7de5 1755                               rmb1    helper                          ; remove LINGET flag
    83  7de7 68                                 pla                                     ; restore character
    84  7de8 38                                 sec                                     ; return to Editor with no action taken
    85  7de9 60                                 rts
    86                          
    87                          AutoScrollyes
    88  7dea 663f                               ror     form                            ; save .c=direction (character already on stack)
    89  7dec 38                                 sec
    90  7ded 20f0ff                             jsr     _plot                           ; get current cursor position & save it
    91  7df0 867f                               stx     point
    92  7df2 8480                               sty     point+1
    93  7df4 9755                               smb1    helper                          ; set flag for LINGET not to go to error if it has problems
    94  7df6 ff3f3d                             bbs7    form,AutoScrolldn               ; branch according to direction of scroll...
    95                          
    96                          
    97                          AutoScrollup                                            ; wanting to scroll up
    98  7df9 38                                 sec
    99  7dfa a5e4                               lda     _screen_bottom                  ; put cursor at bottom of screen
   100  7dfc e5e5                               sbc     _screen_top
   101  7dfe 8540                               sta     form+1                          ; save where it is- we'll be printing line there
   102  7e00 aa                                 tax
   103  7e01 20a87e                             jsr     AutoSearch                      ; search for a line number on screen, put it in linnum
   104  7e04 20fa31                             jsr     FindLine                        ; find the line in program
   105  7e07 900e                               bcc     l263_1   ;  line not found      ; we have a pointer to the next line
   106  7e09 a000                               ldy     #0
   107  7e0b 20ad22                             jsr     indlow                          ; find the next line, the one we want to print, via link bytes
   108  7e0e aa                                 tax
   109  7e0f c8                                 iny
   110  7e10 20ad22                             jsr     indlow
   111  7e13 8661                               stx     lowtr                           ; advance pointer to it
   112  7e15 8562                               sta     lowtr+1
   113  7e17 a640               l263_1          ldx     form+1                          ; put cursor back at bottom of screen
   114  7e19 a000                               ldy     #0
   115  7e1b 18                                 clc
   116  7e1c 20f0ff                             jsr     _plot
   117  7e1f 20f737             l263_2          jsr     crdo                            ; get a blank line to print on- scroll screen up
   118  7e22 a001                               ldy     #1
   119  7e24 20ad22                             jsr     indlow                          ; end of program marker?
   120  7e27 d05f                               bne     AutoScrollprint                 ; no-  print this line & exit
   121  7e29 a52d                               lda     txttab                          ; yes- loop to start of program,
   122  7e2b a62e                               ldx     txttab+1
   123  7e2d 8561                               sta     lowtr
   124  7e2f 8662                               stx     lowtr+1
   125  7e31 20f737                             jsr     crdo                            ; and add an extra newline
   126  7e34 80e9                               bra     l263_2
   127                          
   128                          
   129                          AutoScrolldn                                            ; wanting to scroll down
   130  7e36 a200                               ldx     #0                              ; put cursor at top of screen
   131  7e38 20a87e                             jsr     AutoSearch                      ; search for a line number on screen, put it in linnum
   132  7e3b a200                               ldx     #0                              ; get a blank line to print on
   133  7e3d a000                               ldy     #0                              ; put cursor at top of screen
   134  7e3f 18                                 clc
   135  7e40 20f0ff                             jsr     _plot
   136  7e43 207dff             l264_1          jsr     _primm                          ; and scroll screen (kill any pending Editor modes, too)
   137  7e46 1b1b1b5700                         !text esc,esc,esc,"W",0
   138  7e4b 20fa31                             jsr     FindLine                        ; find the line in program whose number we found on screen
   139  7e4e a561                               lda     lowtr                           ; (does not matter if it or next higher line is found)
   140  7e50 c52d                               cmp     txttab
   141  7e52 d012                               bne     l264_2
   142  7e54 a562                               lda     lowtr+1
   143  7e56 c52e                               cmp     txttab+1
   144  7e58 d00c                               bne     l264_2
   145  7e5a a9ff                               lda     #$ff                            ; special case- it's the very first line, want to wrap to last line
   146  7e5c 8517                               sta     linnum+1                        ; fake pointer to the last line,
   147  7e5e 207dff                             jsr     _primm                          ; scroll screen to insert extra space,
   148  7e61 1b5700                             !text esc,"W",0
   149  7e64 80dd                               bra     l264_1                          ; and go around again
   150                          
   151  7e66 a52d               l264_2          lda     txttab                          ; start at beginning of program (txttab) and find the line which points at (lowtr)
   152  7e68 a62e                               ldx     txttab+1
   153  7e6a 8524               l264_3          sta     index                           ; pointer to link bytes
   154  7e6c 8625                               stx     index+1
   155  7e6e a001                               ldy     #1
   156  7e70 20c122                             jsr     indin1                          ; get link bytes
   157  7e73 aa                                 tax
   158  7e74 88                                 dey
   159  7e75 20c122                             jsr     indin1
   160  7e78 e462                               cpx     lowtr+1                         ; do link bytes point at target line?
   161  7e7a d0ee                               bne     l264_3
   162  7e7c c561                               cmp     lowtr
   163  7e7e d0ea                               bne     l264_3                          ; no- use these link bytes to find next line
   164                          
   165  7e80 a524                               lda     index                           ; yes- copy pointer
   166  7e82 a625                               ldx     index+1
   167  7e84 8561                               sta     lowtr
   168  7e86 8662                               stx     lowtr+1
   169                          ; bra AutoScrollprint ; print the line & exit
   170                          
   171                          
   172                          AutoScrollprint
   173  7e88 a002                               ldy     #2                              ; get line number to print
   174  7e8a 20ad22                             jsr     indlow
   175  7e8d aa                                 tax
   176  7e8e c8                                 iny
   177  7e8f 20ad22                             jsr     indlow
   178  7e92 207733                             jsr     p1line                          ; print the number & the line
   179                          ; bra AutoScrolldone ;Normal exit
   180                          
   181                          AutoScrolldone
   182  7e95 207dff                             jsr     _primm                          ; kill special Editor modes
   183  7e98 1b1b00                             !text esc,esc,0
   184  7e9b a67f                               ldx     point                           ; restore cursor position
   185  7e9d a480                               ldy     point+1
   186  7e9f 18                                 clc
   187  7ea0 20f0ff                             jsr     _plot
   188  7ea3 1755                               rmb1    helper                          ; remove LINGET flag
   189  7ea5 68                                 pla                                     ; restore character
   190  7ea6 18                                 clc                                     ; return to Editor, with flag we handled character
   191  7ea7 60                                 rts
   192                          
   193                          AutoSearch
   194  7ea8 a000                               ldy     #0                              ; search for any line number on screen in leftmost column
   195  7eaa 18                                 clc
   196  7eab 20f0ff                             jsr     _plot                           ; move to beginning of next line
   197                          ; bcs AutoScrollpop ;  exit if no more lines
   198  7eae b02a                               bcs     l265_4                          ; no more lines- fake one   [910716]
   199  7eb0 38                                 sec
   200  7eb1 20f0ff                             jsr     _plot                           ; else check if wrapped line
   201  7eb4 b018                               bcs     l265_1                          ; it's wrapped- move up one line
   202  7eb6 a5e0                               lda     _pnt
   203  7eb8 65e6                               adc     _screen_left                    ; (.c=0)
   204  7eba 853d                               sta     txtptr                          ; copy screen address of logical line to txtptr
   205  7ebc a5e1                               lda     _pnt+1
   206  7ebe 6900                               adc     #0
   207  7ec0 853e                               sta     txtptr+1
   208  7ec2 a000                               ldy     #0                              ; get first character on this line in window
   209  7ec4 b13d                               lda     (txtptr),y
   210                          ; jsr indtxt  ;    (I did not want to limit search to the first column,
   211  7ec6 c93a                               cmp     #'9'+1                          ; but it was way too slow searching the entire screen)
   212  7ec8 b004                               bcs     l265_1                          ; it's not a number
   213  7eca c930                               cmp     #'0'
   214  7ecc b008                               bcs     l265_3                          ; it's a digit 0-9, continue
   215                          
   216  7ece ff3f02             l265_1          bbs7    form,l265_2                     ; not on this line- move to next line
   217  7ed1 ca                                 dex                                     ; move up one line
   218  7ed2 89                                 !text $89
   219  7ed3 e8                 l265_2          inx                                     ; move down one line
   220  7ed4 80d2                               bra     AutoSearch                      ; loop until we find a numeric digit or run out of lines
   221                          
   222  7ed6 18                 l265_3          clc                                     ; found a digit, get entire number into linnum & rts
   223  7ed7 8355b3                             +lbra   linget
   224                          
   225  7eda a9ff               l265_4          lda     #$ff                            ; no line found, fake end of program   [910716]
   226  7edc 8517                               sta     linnum+1
   227  7ede 60                                 rts
   228                          
   229                          
   230                          
   231                          
   232                          ;.end
   233                          
   234                          ; ********************************************************************************************
   235                          ;
   236                          ;	Date		Changes
   237                          ;	====		=======
   238                          ;
   239                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/screen.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      screen.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                                          * = $af00                               ; [911001]
    16                          
    17                          ;*****************************************************************
    18                          ; SCREEN DEF      define a screen
    19                          ; SCREEN SET  set draw, view screen
    20                          ; SCREEN CLR  clear a screen
    21                          ; SCREEN OPEN  open a screen
    22                          ; SCREEN CLOSE  close a screen
    23                          ;*****************************************************************
    24                          
    25                          Screen
    26  af00 c99f                               cmp     #open_token                     ; else dispatch per secondary token...
    27  af02 f39200                             +lbeq   ScreenOpen
    28  af05 c9a0                               cmp     #close_token
    29  af07 f39e00                             +lbeq   ScreenClose
    30  af0a c996                               cmp     #def_token
    31  af0c f058                               beq     ScreenDef
    32  af0e c99c                               cmp     #clr_token
    33  af10 f020                               beq     ScreenClr
    34                          
    35  af12 2016b5                             jsr     chkesc                          ; [910930]
    36                          ; cmp #esc_command_token
    37                          ; bne l266_1
    38                          ; jsr chrget  ; get past escape token
    39  af15 c92d                               cmp     #set_token
    40  af17 f02f                               beq     ScreenSet
    41  af19 832f7f             l266_1          +lbra   snerr                           ; report syntax error
    42                          
    43                          
    44                          CheckGraphicMode
    45  af1c 2c4b1f                             bit     $1f4b                           ; Check draw screen allocation   [910711]
    46  af1f 3001                               bmi     NoGraphicArea
    47  af21 60                                 rts                                     ; ok
    48                          
    49                          
    50                          NoGraphicArea
    51  af22 a223                               ldx     #errng                          ; bad- no graphic area????
    52  af24 83297f                             +lbra   error
    53                          
    54                          
    55                          RestoreTextScreen                                        ; [910404]
    56  af27 a9ff                               lda     #$ff                            ; [910930]
    57  af29 8d001f                             sta     GKI__parm1                      ; leave drawscreen as is
    58  af2c 8d011f                             sta     GKI__parm2                      ; set viewscreen to text
    59  af2f 6c0e80                             jmp     ($800e)                         ; kg65.screen
    60                          
    61                          ; lda vic+49  ;Check graphic screen allocation
    62                          ; and #%00010000
    63                          ; beq 99$   ; we're in text mode
    64                          ;; bit $1f43
    65                          ;; bmi NoGraphicArea
    66                          ;
    67                          ; sei
    68                          ; lda #$80
    69                          ; bit _mode  ;40/80 mode, 0=80 128=40
    70                          ; bmi l267_1
    71                          ;
    72                          ; tsb vic+49  ; 80
    73                          ; lda #1
    74                          ; trb vic+22  ;  fix x-scroll register
    75                          ; bra 99$
    76                          ;
    77                          ;l267_1 trb vic+49  ; 40
    78                          ; lda #1
    79                          ; tsb vic+22  ;  fix x-scroll register
    80                          ;
    81                          ;99$ cli
    82                          ;; lda #0
    83                          ;; sta _graphm  ;text mode????
    84                          ; rts
    85                          
    86                          
    87                          ;*****************************************************************
    88                          ; SCNCLR  clear a text or graphic screen
    89                          ;
    90                          ;  Syntax : SCNCLR  [ColorReg]
    91                          ;
    92                          ; if [ColorReg] not specified, clears text screen
    93                          ; else clears the graphic screen with given value.
    94                          ;*****************************************************************
    95                          
    96                          ScreenClr
    97  af32 208322                             jsr     chrget                          ; eat token & fall into SCNCLR
    98                          
    99                          scnclr
   100  af35 d005                               bne     C65__screenclear                ; have a parameter, go clear graphic screen
   101                          
   102  af37 a993                               lda     #$93
   103  af39 4cd2ff                             jmp     _bsout                          ; no parameter, clear text screen
   104                          ; rts
   105                          
   106                          
   107                          
   108                          ;*****************************************************************
   109                          ;* SCREEN CLR  clear a graphic screen
   110                          ;*
   111                          ;*  Syntax : SCREEN CLR  color_reg#
   112                          ;*
   113                          ;*           parm1 = color reg#  0-255
   114                          ;*****************************************************************
   115                          
   116                          C65__screenclear
   117  af3c 206c5d                             jsr     getbyt                          ; get color register # (range 0-255)?????
   118                          ;limit to range allowed by current screen def?
   119  af3f 8e001f                             stx     GKI__parm1
   120  af42 201caf                             jsr     CheckGraphicMode
   121  af45 6c0c80                             jmp     ($800c)                         ; bra screenclear
   122                          
   123                          
   124                          ;*****************************************************************
   125                          ;* SCREEN SET  specify draw & view screens
   126                          ;*
   127                          ;*  Syntax : SCREEN SET  [DrawScreen] [,ViewScreen]
   128                          ;*
   129                          ;*           parm1 = draw screen # 0-3, 255=don't change    [910711]
   130                          ;*           parm2 = view screen # 0-3, 255=text
   131                          ;*****************************************************************
   132                          
   133                          ScreenSet
   134  af48 208322                             jsr     chrget                          ; advance past token
   135                          
   136                          C65__screen
   137                          ; beq snerr  ;missing args??      [911017]
   138  af4b a2ff                               ldx     #255                            ; [911028]
   139  af4d c92c                               cmp     #','
   140  af4f f003                               beq     l267_1                          ; options byte only
   141                          
   142  af51 206c5d                             jsr     getbyt                          ; get draw screen# in .x
   143                          ; cpx #4   ;       [910711]
   144                          ; bcs 20$   ;  out of range error???? (255=leave alone)  [910930]
   145  af54 8e001f             l267_1          stx     GKI__parm1
   146                          
   147  af57 ae691f                             ldx     $1f69                           ; current viewscreen     [911017]
   148  af5a 202679                             jsr     optbyt                          ; eat a comma, get view screen# in .x
   149                          ; cpx #4   ;
   150                          ;20$ bcs fcerr  ;  out of range error???? (255=text)   [910930]
   151  af5d 8e011f                             stx     GKI__parm2
   152                          
   153  af60 220e80                             jsr     ($800e)                         ; kg65.screen
   154  af63 b0bd                               bcs     NoGraphicArea
   155  af65 60                                 rts
   156                          
   157                          
   158                          ;*****************************************************************
   159                          ;* SCREEN DEF  define a graphic screen
   160                          ;*
   161                          ;*  Syntax : SCREEN DEF  screen#, width, height, depth
   162                          ;*
   163                          ;*           parm1 = screen#           0-3    [910711]
   164                          ;*           parm2 = width             0=320, 1=640, 2=1280
   165                          ;*           parm3 = height            0=200, 1=400
   166                          ;*           parm4 = depth             1-8 bitplanes (2-256 colors)
   167                          ;*****************************************************************
   168                          
   169                          ScreenDef
   170  af66 208322                             jsr     chrget                          ; advance past token
   171                          
   172                          C65__screendef
   173  af69 206c5d                             jsr     getbyt                          ; get screen number
   174  af6c e004                               cpx     #4                              ; range 0-3   [910711]
   175  af6e b01d                               bcs     l268_1
   176  af70 8e001f                             stx     GKI__parm1                      ; screen#
   177                          
   178  af73 20825d                             jsr     combyt                          ; get width
   179  af76 e003                               cpx     #3                              ; range 0-2 ???? 1280 mode ????
   180  af78 b013                               bcs     l268_1
   181  af7a 8e011f                             stx     GKI__parm2                      ; width
   182                          
   183  af7d 20825d                             jsr     combyt                          ; get height
   184  af80 e002                               cpx     #2                              ; range 0-1
   185  af82 b009                               bcs     l268_1
   186  af84 8e021f                             stx     GKI__parm3                      ; height
   187                          
   188  af87 20825d                             jsr     combyt                          ; get depth (# bitplanes)
   189  af8a ca                                 dex                                     ; convert 1-8 to 0-7
   190  af8b e008                               cpx     #8                              ; range 0-7
   191  af8d b36fa2             l268_1          +lbcs   fcerr                           ; illegal quantity error
   192  af90 8e031f                             stx     GKI__parm4                      ; depth
   193                          
   194  af93 6c0680                             jmp     ($8006)                         ; bra screendef
   195                          
   196                          
   197                          ;*****************************************************************
   198                          ;* SCREEN OPEN  open a graphic screen for viewing or drawing
   199                          ;*
   200                          ;*  Syntax : SCREEN OPEN screen#
   201                          ;*
   202                          ;*           parm1 = screen#      0-3    [910711]
   203                          ;*****************************************************************
   204                          
   205                          
   206                          ScreenOpen
   207  af96 208322                             jsr     chrget                          ; advance past Open token
   208                          
   209                          C65__screenopen
   210  af99 206c5d                             jsr     getbyt                          ; get screen# in .x
   211  af9c e004                               cpx     #4                              ; range 0-3   [910711]
   212  af9e b35ea2                             +lbcs   fcerr                           ; branch if out of range
   213                          
   214  afa1 8e001f                             stx     GKI__parm1
   215  afa4 6c0880                             jmp     ($8008)                         ; screenopen    [910826]
   216                          
   217                          ; bcs NoGraphicArea ; bad ???? let user catch via RGRAPHIC
   218                          ; rts
   219                          
   220                          
   221                          ;*****************************************************************
   222                          ;* SCREEN CLOSE  close a graphic screen
   223                          ;*
   224                          ;*  Syntax : SCREEN CLOSE screen#
   225                          ;*
   226                          ;*           parm1 = screen#  0-3    [910711]
   227                          ;*****************************************************************
   228                          
   229                          
   230                          ScreenClose
   231  afa7 208322                             jsr     chrget                          ; advance past Close token
   232                          
   233                          C65__screenclose
   234  afaa 206c5d                             jsr     getbyt                          ; get screen#
   235  afad e004                               cpx     #4                              ; range 0-3   [910711]
   236  afaf b34da2                             +lbcs   fcerr                           ; branch if out of range
   237  afb2 8e001f                             stx     GKI__parm1
   238                          
   239  afb5 6c0a80                             jmp     ($800a)                         ; bra screenclose
   240                          
   241                          
   242                          ; ********************************************************************************************
   243                          ;
   244                          ;	Date		Changes
   245                          ;	====		=======
   246                          ;
   247                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/pen.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      pen.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ;*****************************************************************
    14                          ;* PEN
    15                          ;*
    16                          ;*  Syntax : PEN  Pen#, ColorReg
    17                          ;*
    18                          ;*           parm1 = pen#  0-2
    19                          ;*           parm2 = color reg#  0-255
    20                          ;*****************************************************************
    21                          
    22                          C65__setpen
    23  afb8 206c5d                             jsr     getbyt                          ; get pen#
    24  afbb e003                               cpx     #3                              ; range 0-2
    25  afbd b33fa2                             +lbcs   fcerr                           ; branch if out of range
    26  afc0 8e001f                             stx     GKI__parm1
    27                          
    28  afc3 20825d                             jsr     combyt                          ; get color reg#
    29                          ;???? error check for max color allowed
    30                          ; for the current screen.
    31  afc6 8e011f                             stx     GKI__parm2
    32                          
    33  afc9 6c1080                             jmp     ($8010)                         ; bra setpen
    34                          
    35                          
    36                          ; ********************************************************************************************
    37                          ;
    38                          ;	Date		Changes
    39                          ;	====		=======
    40                          ;
    41                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/dmode.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      dmode.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;*****************************************************************
    15                          ;* DMODE   Set Draw Mode
    16                          ;*
    17                          ;*  Syntax : DMODE  jam, complement, stencil, style, thickness
    18                          ;*
    19                          ;*         parm1 = jam           0-1
    20                          ;*         parm2 = complement (XOR) 0-1
    21                          ;*         parm3 = stencil       0-1  <<< not implemented  [911003]
    22                          ;*         parm4 = style         0-3  <<< only 0-1 implemented [911003]
    23                          ;*         parm5 = thickness     1-8  <<< not implemented  [911003]
    24                          ;*******************************************************************
    25                          
    26                          C65__setdmode
    27  afcc 206c5d                             jsr     getbyt                          ; jam mode
    28  afcf e002                               cpx     #2
    29  afd1 b026                               bcs     l269_1
    30  afd3 8e001f                             stx     GKI__parm1
    31                          
    32  afd6 20825d                             jsr     combyt                          ; complement (xor) mode
    33  afd9 e002                               cpx     #2                              ; (ignores jam mode if set)
    34  afdb b01c                               bcs     l269_1
    35  afdd 8e011f                             stx     GKI__parm2
    36                          
    37  afe0 20825d                             jsr     combyt                          ; stencil mode (not implemented)
    38  afe3 e002                               cpx     #2
    39  afe5 b012                               bcs     l269_1
    40  afe7 8e021f                             stx     GKI__parm3
    41                          
    42  afea 20825d                             jsr     combyt                          ; style mode
    43  afed e004                               cpx     #4                              ; 0=solid, 1=pattern, 2=tile (not implemented), 3=reserved
    44  afef b008                               bcs     l269_1
    45  aff1 8e031f                             stx     GKI__parm4
    46                          
    47  aff4 20825d                             jsr     combyt                          ; thickness mode (not implemented)
    48                          ; dex   ; adjust to 0-7     [911003]
    49  aff7 e009                               cpx     #8+1
    50  aff9 b303a2             l269_1          +lbcs   fcerr                           ; illegal quantity error
    51  affc 8e041f                             stx     GKI__parm5
    52                          
    53  afff 6c1480                             jmp     ($8014)                         ; bra setdmode
    54                          
    55                          
    56                          ; ********************************************************************************************
    57                          ;
    58                          ;	Date		Changes
    59                          ;	====		=======
    60                          ;
    61                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/dpat.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      dpat.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;*****************************************************************
    15                          ;* DPAT   set draw pattern
    16                          ;*
    17                          ;*  Syntax : DPAT  type [, # bytes, byte1, byte2, byte3, byte4]
    18                          ;*
    19                          ;*           parm1 = type        0-63  <<< only 0-4 implemented [911003]
    20                          ;*           parm2 = # bytes     1-4
    21                          ;*           parm3 = byte1       0-255
    22                          ;*           parm4 = byte2       0-255
    23                          ;*           parm5 = byte3       0-255
    24                          ;*           parm6 = byte4       0-255
    25                          ;*****************************************************************
    26                          
    27                          C65__setdpat
    28  b002 206c5d                             jsr     getbyt                          ; get pattern type
    29  b005 e005                               cpx     #4+1                            ; 63+1       [911028]
    30  b007 b3f5a1             l270_1          +lbcs   fcerr                           ; if out of range
    31  b00a 8e001f                             stx     GKI__parm1
    32  b00d 8a                                 txa
    33  b00e d033                               bne     l270_2                          ; if parm1 is 0 then get extra stuff
    34                          
    35  b010 20825d                             jsr     combyt                          ; get number of bytes
    36  b013 e005                               cpx     #5
    37  b015 b0f0                               bcs     l270_1                          ; too many bytes
    38  b017 8e011f                             stx     GKI__parm2
    39  b01a 8676                               stx     z_p_temp_1                      ; save for count
    40                          
    41  b01c 20825d                             jsr     combyt                          ; get byte 1
    42  b01f 8e021f                             stx     GKI__parm3
    43  b022 c676                               dec     z_p_temp_1
    44  b024 f01d                               beq     l270_2
    45  b026 33d6a1                             +lbmi   fcerr                           ; too few bytes
    46                          
    47  b029 20825d                             jsr     combyt                          ; get byte 2
    48  b02c 8e031f                             stx     GKI__parm4
    49  b02f c676                               dec     z_p_temp_1
    50  b031 f010                               beq     l270_2
    51                          
    52  b033 20825d                             jsr     combyt                          ; get byte 3
    53  b036 8e041f                             stx     GKI__parm5
    54  b039 c676                               dec     z_p_temp_1
    55  b03b f006                               beq     l270_2
    56                          
    57  b03d 20825d                             jsr     combyt                          ; get byte 4
    58  b040 8e051f                             stx     GKI__parm6
    59                          
    60  b043 6c1680             l270_2          jmp     ($8016)                         ; bra setdpat
    61                          
    62                          
    63                          ; ********************************************************************************************
    64                          ;
    65                          ;	Date		Changes
    66                          ;	====		=======
    67                          ;
    68                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/palette.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      palette.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;*****************************************************************
    15                          ;* PALETTE   set palette colors
    16                          ;*
    17                          ;*  Syntax : PALETTE {screen|COLOR}, color_index, red, green, blue
    18                          ;*           PALETTE RESTORE
    19                          ;*
    20                          ;*           parm1 = screen  0-3     [910711]
    21                          ;*           parm2 = color_index 0-255
    22                          ;*           parm3 = red           0-31 (b0-3 red, b4=fgbg)  [910520]
    23                          ;*           parm4 = green         0-15
    24                          ;*           parm5 = blue          0-15
    25                          ;*****************************************************************
    26                          
    27                          C65__setpalette
    28  b046 c98c                               cmp     #restore_token                  ; restore palette?
    29  b048 d006                               bne     l271_1                          ; no
    30  b04a 208322                             jsr     chrget                          ; yes- advance past Restore token
    31  b04d 4c27e0                             jmp     _palette_init
    32                          
    33  b050 c9e7               l271_1          cmp     #color_token                    ; set physical color register?
    34  b052 d00b                               bne     l271_2                          ; no- set logical color register
    35  b054 8d001f                             sta     GKI__parm1
    36  b057 208322                             jsr     chrget                          ; yes- advance past Color token
    37  b05a 206c5d                             jsr     getbyt
    38  b05d 800e                               bra     l271_3
    39                          
    40  b05f 206c5d             l271_2          jsr     getbyt                          ; get screen#
    41  b062 e004                               cpx     #4                              ; [910711]
    42  b064 b398a1                             +lbcs   fcerr
    43  b067 8e001f                             stx     GKI__parm1
    44                          
    45  b06a 20825d                             jsr     combyt                          ; get color reg #
    46  b06d 8e011f             l271_3          stx     GKI__parm2                      ; (GKI will check for out of range????)
    47                          
    48                          set_palette
    49  b070 20825d                             jsr     combyt                          ; get red & fgbg
    50  b073 e020                               cpx     #32                             ; [910520]
    51  b075 b387a1                             +lbcs   fcerr
    52  b078 8e021f                             stx     GKI__parm3
    53                          
    54  b07b 200ab5                             jsr     getcomnyb                       ; get green
    55                          ; cpx #16
    56                          ; bcs 10$
    57  b07e 8e031f                             stx     GKI__parm4
    58                          
    59  b081 200ab5                             jsr     getcomnyb                       ; get blue
    60                          ; cpx #16
    61                          ; bcs fcerr  ; illegal quantity error
    62  b084 8e041f                             stx     GKI__parm5
    63                          
    64  b087 ad001f                             lda     GKI__parm1                      ; logical or physical color register?
    65  b08a 1017                               bpl     l272_1                          ; logical
    66  b08c ae011f                             ldx     GKI__parm2
    67  b08f ad021f                             lda     GKI__parm3                      ; physical
    68  b092 9d00d1                             sta     _red,x
    69  b095 ad031f                             lda     GKI__parm4
    70  b098 9d00d2                             sta     _green,x
    71  b09b ad041f                             lda     GKI__parm5
    72  b09e 9d00d3                             sta     _blue,x
    73  b0a1 8006                               bra     l272_2
    74                          
    75  b0a3 221280             l272_1          jsr     ($8012)                         ; go set screen palette
    76  b0a6 b37afe                             +lbcs   NoGraphicArea                   ; illegal screen# or color#  [910917]
    77                          
    78  b0a9 202679             l272_2          jsr     optbyt                          ; get another color reg # ?
    79  b0ac 8e011f                             stx     GKI__parm2
    80  b0af b0bf                               bcs     set_palette                     ; yes- loop
    81  b0b1 60                                 rts
    82                          
    83                          
    84                          ; ********************************************************************************************
    85                          ;
    86                          ;	Date		Changes
    87                          ;	====		=======
    88                          ;
    89                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/line.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      line.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ;*****************************************************************
    14                          ;* LINE  draw a dot, a line or a stick shape
    15                          ;*
    16                          ;*  Syntax : LINE  x0, y0 [,[x1] [,y1]]...
    17                          ;*
    18                          ;* parm1,2 = x0 (lo/hi)
    19                          ;* parm3,4 = y0
    20                          ;* parm5,6 = x1 (x1,y1)=(x0,y0) if not specified
    21                          ;* parm7,8 = y1
    22                          ;*****************************************************************
    23                          
    24                          C65__line
    25  b0b2 c984                               cmp     #input_token                    ; special check for 'line input#'  [910103]
    26  b0b4 f3e687                             +lbeq   linputn                         ; yes
    27  b0b7 c985                               cmp     #input_token+1                  ; special check for 'line input'
    28  b0b9 f3ff87                             +lbeq   linput                          ; yes
    29                          
    30  b0bc 201caf                             jsr     CheckGraphicMode
    31  b0bf 20e5b7                             jsr     sadwrd                          ; get x0
    32  b0c2 8c001f                             sty     GKI__parm1
    33  b0c5 8d011f                             sta     GKI__parm2
    34  b0c8 8c041f                             sty     GKI__parm5                      ; [910228]
    35  b0cb 8d051f                             sta     GKI__parm6
    36                          
    37  b0ce 200879                             jsr     comsad                          ; get y0
    38  b0d1 8c021f                             sty     GKI__parm3
    39  b0d4 8d031f                             sta     GKI__parm4
    40  b0d7 8c061f                             sty     GKI__parm7                      ; [910228]
    41  b0da 8d071f                             sta     GKI__parm8
    42                          
    43  b0dd 200e79                             jsr     optsad                          ; get x1     [910228]
    44  b0e0 9006                               bcc     l273_2                          ; use x0
    45  b0e2 8c041f             l273_1          sty     GKI__parm5
    46  b0e5 8d051f                             sta     GKI__parm6
    47                          
    48  b0e8 200e79             l273_2          jsr     optsad                          ; get y1     [910228]
    49  b0eb 9006                               bcc     l273_3                          ; use y0
    50  b0ed 8c061f                             sty     GKI__parm7
    51  b0f0 8d071f                             sta     GKI__parm8
    52                          
    53  b0f3 221880             l273_3          jsr     ($8018)                         ; draw a line from x0,y0 to x1,y1
    54                          
    55  b0f6 a203                               ldx     #3
    56  b0f8 bd041f             l273_4          lda     GKI__parm5,x                    ; copy x1,y1 to x0,y0
    57  b0fb 9d001f                             sta     GKI__parm1,x
    58  b0fe ca                                 dex
    59  b0ff 10f7                               bpl     l273_4
    60                          
    61  b101 200e79                             jsr     optsad                          ; more?
    62  b104 b0dc                               bcs     l273_1                          ; yes, continue
    63  b106 60                                 rts
    64                          
    65                          
    66                          ; ********************************************************************************************
    67                          ;
    68                          ;	Date		Changes
    69                          ;	====		=======
    70                          ;
    71                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/box.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      box.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ;*****************************************************************
    14                          ;* BOX   draw a 4-sided figure
    15                          ;*
    16                          ;*  Syntax :  BOX x0,y0, x1,y1, x2,y2, x3,y3 [,solid flag]
    17                          ;*
    18                          ;* parm1,2   = x0  (lo/hi)
    19                          ;* parm3,4   = y0
    20                          ;* parm5,6   = x1
    21                          ;* parm7,8   = y1
    22                          ;* parm9,10  = x2
    23                          ;* parm11,12 = y2
    24                          ;* parm13,14 = x3
    25                          ;* parm15,16 = y3
    26                          ;* parm17    = solid flag
    27                          ;*****************************************************************
    28                          
    29                          C65__box
    30  b107 201caf                             jsr     CheckGraphicMode
    31  b10a 20e5b7                             jsr     sadwrd                          ; get x0
    32  b10d 8c001f                             sty     GKI__parm1
    33  b110 8d011f                             sta     GKI__parm2
    34                          
    35  b113 200879                             jsr     comsad                          ; get y0
    36  b116 8c021f                             sty     GKI__parm3
    37  b119 8d031f                             sta     GKI__parm4
    38                          
    39  b11c 200879                             jsr     comsad                          ; get x1
    40  b11f 8c041f                             sty     GKI__parm5
    41  b122 8d051f                             sta     GKI__parm6
    42                          
    43  b125 200879                             jsr     comsad                          ; get y1
    44  b128 8c061f                             sty     GKI__parm7
    45  b12b 8d071f                             sta     GKI__parm8
    46                          
    47  b12e 200879                             jsr     comsad                          ; get x2
    48  b131 8c081f                             sty     GKI__parm9
    49  b134 8d091f                             sta     GKI__parm10
    50                          
    51  b137 200879                             jsr     comsad                          ; get y2
    52  b13a 8c0a1f                             sty     GKI__parm11
    53  b13d 8d0b1f                             sta     GKI__parm12
    54                          
    55  b140 200879                             jsr     comsad                          ; get x3
    56  b143 8c0c1f                             sty     GKI__parm13
    57  b146 8d0d1f                             sta     GKI__parm14
    58                          
    59  b149 200879                             jsr     comsad                          ; get y3
    60  b14c 8c0e1f                             sty     GKI__parm15
    61  b14f 8d0f1f                             sta     GKI__parm16
    62                          
    63  b152 202479                             jsr     optzer                          ; get solid flag
    64  b155 8e101f                             stx     GKI__parm17
    65                          
    66  b158 6c1a80                             jmp     ($801a)                         ; bra box
    67                          
    68                          
    69                          ; ********************************************************************************************
    70                          ;
    71                          ;	Date		Changes
    72                          ;	====		=======
    73                          ;
    74                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/circle.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      circle.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ;*****************************************************************
    14                          ;* CIRCLE   draw a Circle
    15                          ;*
    16                          ;*  Syntax : CIRCLE  CenterX, CenterY, radius [,solid flag]
    17                          ;*
    18                          ;*         parm1 = center x lo
    19                          ;*         parm2 = center x hi
    20                          ;*         parm3 = center y lo
    21                          ;*         parm4 = center y hi
    22                          ;*         parm5 = radius lo
    23                          ;*         parm6 = radius hi
    24                          ;*         parm7 = solid flag 0=no, 1=yes
    25                          ;*****************************************************************
    26                          
    27                          C65__circle
    28  b15b 201caf                             jsr     CheckGraphicMode
    29  b15e 20e5b7                             jsr     sadwrd                          ; get center x
    30  b161 8c001f                             sty     GKI__parm1
    31  b164 8d011f                             sta     GKI__parm2
    32                          
    33  b167 200879                             jsr     comsad                          ; get center y
    34  b16a 8c021f                             sty     GKI__parm3
    35  b16d 8d031f                             sta     GKI__parm4
    36                          
    37  b170 200879                             jsr     comsad                          ; get radius
    38  b173 8c041f                             sty     GKI__parm5
    39  b176 8d051f                             sta     GKI__parm6
    40                          
    41  b179 202479                             jsr     optzer                          ; get solid flag
    42  b17c e002                               cpx     #2
    43  b17e b37ea0                             +lbcs   fcerr
    44  b181 8e061f                             stx     GKI__parm7
    45                          
    46  b184 6c1c80                             jmp     ($801c)                         ; bra circle
    47                          
    48                          
    49                          
    50                          ; ********************************************************************************************
    51                          ;
    52                          ;	Date		Changes
    53                          ;	====		=======
    54                          ;
    55                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/ellipse.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      ellipse.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;*****************************************************************
    15                          ;* ELLIPSE   draw an Ellipse
    16                          ;*
    17                          ;*  Syntax : ELLIPSE  CenterX, CenterY, RadiusX,  RadiusY  [,solid flag]
    18                          ;*
    19                          ;*         parm1 = center x lo
    20                          ;*         parm2 = center x hi
    21                          ;*         parm3 = center y lo
    22                          ;*         parm4 = center y hi
    23                          ;*         parm5 = x radius lo
    24                          ;*         parm6 = x radius hi
    25                          ;*         parm7 = y radius lo
    26                          ;*         parm8 = y radius hi
    27                          ;*         parm9 = solid flag 0-1
    28                          ;*****************************************************************
    29                          
    30                          C65__ellipse
    31  b187 201caf                             jsr     CheckGraphicMode
    32  b18a 20e5b7                             jsr     sadwrd                          ; get center x
    33  b18d 8c001f                             sty     GKI__parm1
    34  b190 8d011f                             sta     GKI__parm2
    35                          
    36  b193 200879                             jsr     comsad                          ; get center y
    37  b196 8c021f                             sty     GKI__parm3
    38  b199 8d031f                             sta     GKI__parm4
    39                          
    40  b19c 200879                             jsr     comsad                          ; get xradius
    41  b19f 8c041f                             sty     GKI__parm5
    42  b1a2 8d051f                             sta     GKI__parm6
    43                          
    44  b1a5 200879                             jsr     comsad                          ; get yradius
    45  b1a8 8c061f                             sty     GKI__parm7
    46  b1ab 8d071f                             sta     GKI__parm8
    47                          
    48  b1ae 202479                             jsr     optzer                          ; get solid flag
    49  b1b1 e002                               cpx     #2
    50  b1b3 b349a0                             +lbcs   fcerr
    51  b1b6 8e081f                             stx     GKI__parm9
    52                          
    53  b1b9 6c2080                             jmp     ($8020)                         ; bra ellipse
    54                          
    55                          
    56                          ; ********************************************************************************************
    57                          ;
    58                          ;	Date		Changes
    59                          ;	====		=======
    60                          ;
    61                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/polygon.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      polygon.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*****************************************************************
    16                          ;* POLYGON   draw a regular n-sided Polygon
    17                          ;*
    18                          ;*  POLYGON  X,Y, Xradius, Yradius, sides [,drawsides [,subtend [,angle [,solid] ]]]
    19                          ;*
    20                          ;*         parm1 = center x lo
    21                          ;*         parm2 = center x hi
    22                          ;*         parm3 = center y lo
    23                          ;*         parm4 = center y hi
    24                          ;*         parm5 = xradius lo
    25                          ;*         parm6 = xradius hi
    26                          ;*         parm7 = yradius lo
    27                          ;*         parm8 = yradius hi
    28                          ;*         parm9 = solid flag 0-1
    29                          ;*         parm10 = sa lo (starting angle 0-360)
    30                          ;*         parm11 = sa hi
    31                          ;*         parm12 = # of sides to draw (1 to 127)
    32                          ;*         parm13 = # of sides (3 to parm12)
    33                          ;*         parm14 = subtend flag 0-1
    34                          ;****************************************************************
    35                          
    36                          C65__polygon                                            ; changed BASIC syntax to something more reasonable [910923] FAB
    37  b1bc 201caf                             jsr     CheckGraphicMode
    38  b1bf 20e5b7                             jsr     sadwrd                          ; get center x
    39  b1c2 8c001f                             sty     GKI__parm1
    40  b1c5 8d011f                             sta     GKI__parm2
    41                          
    42  b1c8 200879                             jsr     comsad                          ; get center y
    43  b1cb 8c021f                             sty     GKI__parm3
    44  b1ce 8d031f                             sta     GKI__parm4
    45                          
    46  b1d1 20875d                             jsr     comwrd                          ; get x radius
    47  b1d4 8c041f                             sty     GKI__parm5
    48  b1d7 8d051f                             sta     GKI__parm6
    49                          
    50  b1da 20875d                             jsr     comwrd                          ; get y radius
    51  b1dd 8c061f                             sty     GKI__parm7
    52  b1e0 8d071f                             sta     GKI__parm8
    53                          
    54  b1e3 20825d                             jsr     combyt                          ; get number of sides
    55  b1e6 e003                               cpx     #3
    56  b1e8 900d                               bcc     l274_2                          ; too few
    57  b1ea e080                               cpx     #128
    58  b1ec b310a0             l274_1          +lbcs   fcerr                           ; too many
    59  b1ef 8e0c1f                             stx     GKI__parm13
    60                          
    61                          ; ldx GKI__parm13  ;get number of sides to draw (default=#sides)
    62  b1f2 202679                             jsr     optbyt
    63  b1f5 e001                               cpx     #1                              ; must be at least 1 side
    64  b1f7 9305a0             l274_2          +lbcc   fcerr
    65  b1fa 8e0b1f                             stx     GKI__parm12
    66  b1fd ca                                 dex
    67  b1fe ec0c1f                             cpx     GKI__parm13                     ; draw sides must be <= #sides
    68  b201 b0e9                               bcs     l274_1
    69                          
    70  b203 202479                             jsr     optzer                          ; get subtend flag
    71                          ; cpx #2
    72                          ; bcs l274_1
    73  b206 8e0d1f                             stx     GKI__parm14
    74                          
    75  b209 20f278                             jsr     optwrd                          ; get starting angle (default=0 degrees)
    76  b20c 8c091f                             sty     GKI__parm10                     ; lo
    77  b20f 8d0a1f                             sta     GKI__parm11                     ; hi
    78                          
    79  b212 202479                             jsr     optzer                          ; get solid flag
    80                          ; cpx #2
    81                          ; bcs l274_1
    82  b215 8e081f                             stx     GKI__parm9
    83                          
    84  b218 6c1e80                             jmp     ($801e)                         ; bra polygon
    85                          
    86                          
    87                          ; ********************************************************************************************
    88                          ;
    89                          ;	Date		Changes
    90                          ;	====		=======
    91                          ;
    92                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/set.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      set.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;  SET  A multipurpose command initiator
    16                          
    17                          
    18                          C65__set
    19  b21b c995                               cmp     #verify_token                   ; SET VERIFY <ON | OFF>  new [910429]
    20  b21d f39c00                             +lbeq   verify_mode
    21  b220 c996                               cmp     #def_token                      ; SET DEF unit
    22  b222 d00c                               bne     l275_1
    23  b224 2085b2                             jsr     getdisknum_1
    24  b227 8e0611                             stx     _default_drive
    25  b22a 8e8211                             stx     dosfa                           ; Make last DOS device = current device
    26  b22d 8353c6                             +lbra   Clear_DS
    27                          
    28                          
    29                          
    30  b230 2016b5             l275_1          jsr     chkesc                          ; Must be ESCape token
    31  b233 c940                               cmp     #disk_token                     ; ok so far
    32  b235 d3047c                             +lbne   bad_command                     ; unknown command
    33                          
    34                          
    35                          
    36                          
    37  b238 2085b2                             jsr     getdisknum_1                    ; SET DISK # [<,|TO> #]
    38  b23b 8e8211                             stx     dosfa                           ; got current disk unit #
    39                          
    40  b23e 208522                             jsr     chrgot                          ; check delimiter (comma, 'TO', or eos)
    41  b241 f33fc6                             +lbeq   Clear_DS                        ; eos- just change DOS' current drive [910417]
    42  b244 c92c                               cmp     #','                            ; not eos, must be comma or 'TO'
    43  b246 f005                               beq     l275_2
    44  b248 c9a4                               cmp     #to_token
    45  b24a d3fe7b                             +lbne   snerr
    46                          
    47  b24d 2085b2             l275_2          jsr     getdisknum_1                    ; skip delimiter
    48  b250 8e8811                             stx     dosds2                          ; got new disk unit #
    49                          
    50                          
    51                          
    52                          ;  Open disk command channel & pass it 'renumber' command
    53                          
    54  b253 204171                             jsr     dclall                          ; Close any open files????
    55                          
    56  b256 a205                               ldx     #6-1
    57  b258 bd7fb2             l275_3          lda     disk_renum_cmd,x                ; move command to RAM, setup for open
    58  b25b 9d9111                             sta     savram,x
    59  b25e ca                                 dex
    60  b25f 10f7                               bpl     l275_3
    61  b261 ad8811                             lda     dosds2
    62  b264 0920                               ora     #32                             ; make new # a talk/listen address
    63  b266 8d9711                             sta     savram+6
    64  b269 ad8811                             lda     dosds2
    65  b26c 0940                               ora     #64
    66  b26e 8d9811                             sta     savram+7
    67                          
    68  b271 a908                               lda     #8                              ; command string length
    69  b273 2096b2                             jsr     SendDiskCmd                     ; Send command
    70  b276 ad8811                             lda     dosds2
    71  b279 8d8211                             sta     dosfa                           ; Make last DOS device = current device
    72  b27c 8394b6                             +lbra   close_out_1                     ; common error check & exit path ????
    73                          
    74                          
    75  b27f 4d2d57770002       disk_renum_cmd  !text "M-W",119,0,2                     ; Renumber Drive command
    76                          
    77                          
    78                          
    79                          ;  GetDiskNum - Get a (required) disk number and check it
    80                          
    81                          getdisknum_1
    82  b285 208322                             jsr     chrget                          ; skip current character
    83                          getdisknum
    84  b288 206c5d                             jsr     getbyt                          ; get number in .x
    85  b28b e008                               cpx     #8                              ; check range (8-30)
    86  b28d 936f9f                             +lbcc   fcerr
    87  b290 e01f                               cpx     #31
    88  b292 b36a9f                             +lbcs   fcerr
    89  b295 60                                 rts                                     ; returns only if okay
    90                          
    91                          
    92                          
    93                          ;  SendDiskCmd - Send command in SAVRAM to disk, length in .A
    94                          
    95                          SendDiskCmd
    96                          ; lda #   ; command string length
    97  b296 a291                               ldx     #<savram                        ; address
    98  b298 a011                               ldy     #>savram
    99  b29a 20bdff                             jsr     _setnam
   100  b29d a200                               ldx     #sys_bank                       ; ???? sysbank ????
   101  b29f 206bff                             jsr     _setbank
   102  b2a2 20ccff                             jsr     _clrch                          ; Restore normal channels, establish our's
   103  b2a5 ae8211                             ldx     dosfa                           ; fa
   104  b2a8 a900                               lda     #doslfn                         ; la (reserved la)
   105  b2aa a06f                               ldy     #$6f                            ; sa (command channel)
   106  b2ac 20baff                             jsr     _setlfs
   107  b2af 20c0ff                             jsr     _open                           ; open channel & send command
   108  b2b2 a900                               lda     #doslfn                         ; close it already
   109  b2b4 38                                 sec                                     ; not a real close
   110  b2b5 20c3ff                             jsr     _close
   111  b2b8 83c8c5                             +lbra   Clear_DS                        ; Exit
   112                          
   113                          
   114                          ;  SET VERIFY <ON | OFF> Set DOS verify-after-write mode for 3.5" drives
   115                          
   116                          verify_mode
   117  b2bb 208322                             jsr     chrget                          ; eat 'verify' token, get next  new [910429]
   118  b2be c991                               cmp     #on_token
   119  b2c0 38                                 sec
   120  b2c1 f009                               beq     l276_1                          ; turn verify on (.c=1)
   121  b2c3 2016b5                             jsr     chkesc
   122  b2c6 c924                               cmp     #off_token                      ; turn cursor off (.c=0)
   123  b2c8 d3807b                             +lbne   snerr
   124  b2cb 18                                 clc
   125                          
   126                          ;  Open disk command channel & pass it 'verify' command
   127                          
   128  b2cc 08                 l276_1          php                                     ; Save mode
   129  b2cd 2022b5                             jsr     chkeos                          ; eat 'on/off' token, error if not eos
   130                          
   131  b2d0 a203                               ldx     #4-1
   132  b2d2 bdecb2             l276_2          lda     verify_cmd,x                    ; move command to RAM, setup for open
   133  b2d5 9d9111                             sta     savram,x
   134  b2d8 ca                                 dex
   135  b2d9 10f7                               bpl     l276_2
   136                          
   137  b2db a900                               lda     #0                              ; form on/off flag
   138  b2dd 28                                 plp
   139  b2de 2a                                 rol
   140  b2df 0930                               ora     #$30
   141  b2e1 8d9511                             sta     savram+4
   142                          
   143  b2e4 a905                               lda     #5                              ; command string length
   144  b2e6 2096b2                             jsr     SendDiskCmd                     ; Send command
   145  b2e9 8327b6                             +lbra   close_out_1                     ; common error check & exit path ????
   146                          
   147                          
   148  b2ec 55303e56           verify_cmd      !text "U0>V"                            ; Verify on/off command
   149                          
   150                          ;.end
   151                          
   152                          ; ********************************************************************************************
   153                          ;
   154                          ;	Date		Changes
   155                          ;	====		=======
   156                          ;
   157                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/char.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      char.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*****************************************************************
    16                          ;* CHAR   draw a character string
    17                          ;*
    18                          ;*  Syntax : CHAR column, row, height, width, direction, "string" [,charsetadr [,bank]]
    19                          ;*
    20                          ;* parm1  = column#
    21                          ;* parm2  = row lo
    22                          ;* parm3  = row hi
    23                          ;* parm4  = height
    24                          ;* parm5  = width
    25                          ;* parm6  = direction
    26                          ;* parm7  = len of string
    27                          ;* parm8  = lo addr of string
    28                          ;* parm9  = hi addr of string
    29                          ;* parm10 = lo addr of character set $29800 default
    30                          ;* parm11 = hi addr of character set
    31                          ;* parm12 = bank of character set   [910912]
    32                          ;****************************************************************
    33                          
    34                          C65__char
    35  b2f0 201caf                             jsr     CheckGraphicMode
    36  b2f3 206c5d                             jsr     getbyt                          ; get column
    37  b2f6 8e001f                             stx     GKI__parm1
    38                          
    39  b2f9 200879                             jsr     comsad                          ; get row
    40  b2fc 8c011f                             sty     GKI__parm2
    41  b2ff 8d021f                             sta     GKI__parm3
    42                          
    43  b302 20825d                             jsr     combyt                          ; get height
    44  b305 8e031f                             stx     GKI__parm4
    45                          
    46  b308 20825d                             jsr     combyt                          ; get width
    47  b30b 8e041f                             stx     GKI__parm5
    48                          
    49  b30e 20825d                             jsr     combyt                          ; get direction
    50  b311 8e051f                             stx     GKI__parm6
    51                          
    52  b314 205b4e                             jsr     chkcom
    53  b317 20ef4c                             jsr     frmevl                          ; evaluate the string
    54  b31a 20dd4c                             jsr     chkstr                          ; type mismatch error if not string
    55  b31d a000                               ldy     #0
    56  b31f 20a922                             jsr     indfmo                          ; pointer to string descriptor is left in the fac by frmevl
    57  b322 8d061f                             sta     GKI__parm7                      ; length  ???? check for null string ????
    58  b325 48                                 pha
    59  b326 c8                                 iny
    60  b327 20a922                             jsr     indfmo
    61  b32a 8d071f                             sta     GKI__parm8                      ; adrlo
    62  b32d c8                                 iny
    63  b32e 20a922                             jsr     indfmo
    64  b331 8d081f                             sta     GKI__parm9                      ; adrhi
    65  b334 206d5b                             jsr     frefac                          ; [910917]
    66  b337 68                                 pla
    67  b338 20dd5b                             jsr     getspa
    68                          
    69  b33b 20f278                             jsr     optwrd                          ; get charset address (????bank)
    70  b33e b004                               bcs     l277_1                          ; given
    71  b340 a000                               ldy     #<$9800                         ; not given- use ROM as default   [910207] FAB
    72  b342 a998                               lda     #>$9800                         ; ???? uc/lc or graphic set ????
    73  b344 8c091f             l277_1          sty     GKI__parm10                     ; lo
    74  b347 8d0a1f                             sta     GKI__parm11                     ; hi
    75  b34a a202                               ldx     #2                              ; default to ROM bank 2    [910912] FAB
    76  b34c 202679                             jsr     optbyt
    77  b34f 8e0b1f                             stx     GKI__parm12
    78                          
    79  b352 ad061f                             lda     GKI__parm7                      ; ???? check for null string ????
    80  b355 f003                               beq     l277_2
    81  b357 6c2c80                             jmp     ($802c)                         ; bra kg65.char
    82                          
    83  b35a 60                 l277_2          rts
    84                          
    85                          
    86                          ; ********************************************************************************************
    87                          ;
    88                          ;	Date		Changes
    89                          ;	====		=======
    90                          ;
    91                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/paint.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      paint.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*****************************************************************
    16                          ;* PAINT   fill a graphic area with color
    17                          ;*
    18                          ;*  Syntax : PAINT x, y [,mode [,color]]
    19                          ;*
    20                          ;* parm1  = x lo
    21                          ;* parm2  = x lo
    22                          ;* parm3  = y lo
    23                          ;* parm4  = y hi
    24                          ;* parm5  = mode
    25                          ;* parm6  = color
    26                          ;*
    27                          ;* fill color is pen-A
    28                          ; mode 0: fill region defined by color at x,y (default) new modes [910916] FAB
    29                          ; mode 1: fill region using given color as boundary
    30                          ; mode 2: fill connected region
    31                          ;****************************************************************
    32                          
    33                          C65__paint                                              ; new [910228] FAB
    34  b35b 201caf                             jsr     CheckGraphicMode
    35  b35e 20e5b7                             jsr     sadwrd                          ; get x
    36  b361 8c001f                             sty     GKI__parm1
    37  b364 8d011f                             sta     GKI__parm2
    38                          
    39  b367 200879                             jsr     comsad                          ; get y
    40  b36a 8c021f                             sty     GKI__parm3
    41  b36d 8d031f                             sta     GKI__parm4
    42                          
    43  b370 a200                               ldx     #0                              ; [910916]
    44  b372 202679                             jsr     optbyt                          ; mode, default = 0 (fill region pointed to)
    45  b375 e003                               cpx     #3
    46  b377 b3859e                             +lbcs   fcerr                           ; (range 0-2)
    47  b37a 8e041f                             stx     GKI__parm5
    48  b37d a200                               ldx     #0
    49  b37f 202679                             jsr     optbyt                          ; boundary color, default = 0
    50  b382 8e051f                             stx     GKI__parm6
    51                          
    52  b385 20335c             l278_1          jsr     garba2                          ; create space in var bank for paint stack [910716]
    53  b388 a533                               lda     strend
    54  b38a 8d061f                             sta     GKI__parm7                      ; pass pointer to bottom of bank-1 free space
    55  b38d a534                               lda     strend+1                        ; (top of stack)
    56  b38f 8d071f                             sta     GKI__parm8
    57  b392 38                                 sec
    58  b393 a535                               lda     fretop                          ; pass pointer to top of free space
    59  b395 e903                               sbc     #3                              ; (bottom of stack)
    60  b397 8d081f                             sta     GKI__parm9
    61  b39a a536                               lda     fretop+1
    62  b39c e900                               sbc     #0
    63  b39e 8d091f                             sta     GKI__parm10
    64                          
    65  b3a1 222e80                             jsr     ($802e)                         ; bra paint
    66  b3a4 b001                               bcs     l278_2                          ; error- stack overflow or stop key
    67  b3a6 60                                 rts
    68                          
    69  b3a7 e010               l278_2          cpx     #errom
    70  b3a9 f3a47a                             +lbeq   error                           ; stack overflow, say 'out of memory'
    71  b3ac 832379                             +lbra   break_exit                      ; user hit stop key
    72                          
    73                          
    74                          ; ********************************************************************************************
    75                          ;
    76                          ;	Date		Changes
    77                          ;	====		=======
    78                          ;
    79                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/loadiff.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      loadiff.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*****************************************************************
    16                          ;*   LOADIFF "filename" [,U#] [,D#]
    17                          ;*
    18                          ;* ???? requires SCREEN already opened   910402 FAB
    19                          ;*****************************************************************
    20                          
    21                          loadiff
    22  b3af 201caf                             jsr     CheckGraphicMode
    23  b3b2 a9e6                               lda     #$e6                            ; parse:  filename [,U#] [,D#]
    24  b3b4 202074                             jsr     dosprs                          ; (like dopen:  0 0 0 *  * 0 0 1 )
    25  b3b7 20dc77                             jsr     chk1                            ; check parameters
    26  b3ba a900                               lda     #0
    27  b3bc 8d8311                             sta     dossa                           ; setup as dload would (0 = load channel)
    28  b3bf 201d71                             jsr     find_la                         ; find an available la to use (cannot use reserved one)
    29  b3c2 a009                               ldy     #fopn
    30  b3c4 a204                               ldx     #4
    31  b3c6 20fd70                             jsr     open_file                       ; open the file
    32  b3c9 b006                               bcs     l279_1                          ; exit if error
    33                          
    34  b3cb ae8111                             ldx     dosla
    35                          ; stx GKI__parm1
    36  b3ce 20c6ff                             jsr     _chkin                          ; get input channel
    37  b3d1 b3547f             l279_1          +lbcs   list_err                        ; exit if error
    38                          
    39  b3d4 222a80                             jsr     ($802a)                         ; Load it
    40                          
    41                          exit_GKI_disk_op
    42  b3d7 08                                 php                                     ; preserve completion status
    43  b3d8 48                                 pha
    44  b3d9 20ccff                             jsr     _clrch
    45  b3dc ad8111                             lda     dosla
    46  b3df 200e69                             jsr     close_out                       ; close channel
    47                          
    48  b3e2 20cc2c                             jsr     is_stop_key_down                ; weed out BREAK error
    49  b3e5 fa                                 plx
    50  b3e6 28                                 plp
    51  b3e7 b3667a                             +lbcs   error                           ; must be I/O or file data error
    52  b3ea 60                                 rts                                     ; load was successful
    53                          
    54                          
    55                          ; ********************************************************************************************
    56                          ;
    57                          ;	Date		Changes
    58                          ;	====		=======
    59                          ;
    60                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/saveiff.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      saveiff.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ;*****************************************************************
    14                          ;*
    15                          ;*   SAVEIFF "[@]filename" [,U#] [,D#]      [910930] FAB
    16                          ;*
    17                          ;*****************************************************************
    18                          
    19                          saveiff
    20  b3eb 201caf                             jsr     CheckGraphicMode
    21  b3ee a966                               lda     #$66                            ; set error flags
    22  b3f0 202074                             jsr     dosprs                          ; parse the line
    23  b3f3 20e177                             jsr     chk2                            ; check required parameters
    24  b3f6 a901                               lda     #1
    25  b3f8 8d8311                             sta     dossa                           ; setup as dsave would (1 = save channel)
    26  b3fb 201d71                             jsr     find_la                         ; find an available la to use (cannot use reserved one)
    27  b3fe a009                               ldy     #fopn
    28  b400 a204                               ldx     #4
    29  b402 20fd70                             jsr     open_file                       ; open the file
    30  b405 b006                               bcs     l280_1                          ; exit if error
    31                          
    32  b407 ae8111                             ldx     dosla
    33                          ; stx GKI__parm1
    34  b40a 20c9ff                             jsr     _chkout                         ; get output channel
    35  b40d b3187f             l280_1          +lbcs   list_err                        ; exit if error
    36                          
    37  b410 223a80                             jsr     ($803a)                         ; Save it
    38  b413 80c2                               bra     exit_GKI_disk_op
    39                          
    40                          ; php   ;preserve completion status
    41                          ; pha
    42                          ; jsr _clrch
    43                          ; lda dosla
    44                          ; jsr close_out  ;close channel
    45                          ;
    46                          ; jsr is_stop_key_down ; weed out BREAK error
    47                          ; plx
    48                          ; plp
    49                          ; bcs error  ; must be I/O or file data error
    50                          ; rts   ; load was successful
    51                          
    52                          ;.end
    53                          
    54                          ; ********************************************************************************************
    55                          ;
    56                          ;	Date		Changes
    57                          ;	====		=======
    58                          ;
    59                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/viewport.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      viewport.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*****************************************************************
    16                          ;*   VIEWPORT <CLR | DEF>  x, y, viewport_width, viewport_height
    17                          ;*
    18                          ;* assumes SCREEN already opened   910626 FAB
    19                          ;*****************************************************************
    20                          
    21                          C65__Viewport
    22  b415 48                                 pha                                     ; save secondary command
    23  b416 208322                             jsr     chrget                          ; advance past it
    24  b419 201caf                             jsr     CheckGraphicMode                ; make sure a screen is open
    25                          
    26  b41c 20e5b7                             jsr     sadwrd                          ; get x0
    27  b41f 8c001f                             sty     GKI__parm1
    28  b422 8d011f                             sta     GKI__parm2
    29                          
    30  b425 200879                             jsr     comsad                          ; get y0
    31  b428 8c021f                             sty     GKI__parm3
    32  b42b 8d031f                             sta     GKI__parm4
    33                          
    34  b42e 200879                             jsr     comsad                          ; get width (delta-x)
    35  b431 8c041f                             sty     GKI__parm5
    36  b434 8d051f                             sta     GKI__parm6
    37                          
    38  b437 200879                             jsr     comsad                          ; get height (delta-y)
    39  b43a 8c061f                             sty     GKI__parm7
    40  b43d 8d071f                             sta     GKI__parm8
    41                          
    42  b440 68                                 pla                                     ; dispatch per secondary token...
    43  b441 c99c                               cmp     #clr_token
    44  b443 f008                               beq     l281_1
    45  b445 c996                               cmp     #def_token
    46  b447 d3017a                             +lbne   snerr                           ; error
    47                          
    48  b44a 6c3080                             jmp     ($8030)                         ; define viewport & return
    49                          
    50  b44d 6c2280             l281_1          jmp     ($8022)                         ; clear viewport (???? make this a box command)
    51                          
    52                          
    53                          C65__copy
    54                          C65__cut
    55                          C65__paste
    56  b450 4c3b2e                             jmp     bad_command
    57                          
    58                          
    59                          ; ********************************************************************************************
    60                          ;
    61                          ;	Date		Changes
    62                          ;	====		=======
    63                          ;
    64                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/genlock.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      genlock.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*****************************************************************
    16                          ;* GENLOCK  set/reset genlock mode & color registers
    17                          ;*
    18                          ;*  Syntax: GENLOCK <ON[,color#[,...]] | OFF[,color#,R,G,B]>
    19                          ;*****************************************************************
    20                          
    21  b453 8d001f             genlock         sta     GKI__parm1                      ; save token as flag for set palette   [910107]
    22  b456 c991                               cmp     #on_token
    23  b458 f028                               beq     l282_4
    24  b45a 2016b5                             jsr     chkesc
    25  b45d c924                               cmp     #off_token
    26  b45f d3e979                             +lbne   snerr
    27                          ;TURN GENLOCK OFF
    28  b462 ad31d0                             lda     vic+49                          ; any interlaced bitplanes on?
    29  b465 2919                               and     #%00011001
    30  b467 c919                               cmp     #%00011001
    31  b469 f005                               beq     l282_1                          ; yes, leave interlace mode on
    32                          
    33  b46b a901                               lda     #%00000001
    34  b46d 1c31d0                             trb     vic+49                          ; no, turn interlace off
    35  b470 a902               l282_1          lda     #%00000010
    36  b472 1c30d0                             trb     vic+48                          ; reset external sync mode
    37                          ; beq l282_2   ;       [910114]
    38                          ; lda vic+63  ;       [910111]
    39                          ; inc a   ;  adjust vert. position (chip bug ????)
    40                          ; inc a   ;  (to be handled by a custom C65 genlock board)
    41                          ; inc a
    42                          ; sta vic+63
    43                          
    44  b475 208322             l282_2          jsr     chrget                          ; eat token
    45  b478 202679                             jsr     optbyt                          ; get (optional) color reg# in .X
    46  b47b 8e011f                             stx     GKI__parm2                      ; save it
    47  b47e b3f0fb                             +lbcs   set_palette                     ; if present, go do it & exit
    48  b481 60                 l282_3          rts                                     ; if not present (eol), exit
    49                          
    50                          
    51  b482 a901               l282_4          lda     #%00000001                      ; TURN GENLOCK ON
    52  b484 0c31d0                             tsb     vic+49                          ; set interlace mode
    53  b487 0a                                 asl
    54  b488 0c30d0                             tsb     vic+48                          ; set external sync mode
    55                          ; bne l282_5   ;       [910114]
    56                          ; lda vic+63  ;       [910111]
    57                          ; dec a   ;  adjust vert. position (chip bug ????)
    58                          ; dec a   ;  (to be handled by a custom C65 genlock board)
    59                          ; dec a
    60                          ; sta vic+63
    61                          
    62  b48b 208322             l282_5          jsr     chrget                          ; eat token
    63  b48e 202679             l282_6          jsr     optbyt                          ; get (optional) color reg# in .X
    64  b491 90ee                               bcc     l282_3                          ; if not present (eol), exit
    65  b493 a910                               lda     #%00010000                      ; if present, set FGBG bit in red palette
    66  b495 9d00d1                             sta     _red,x
    67  b498 80f4                               bra     l282_6                          ; loop
    68                          
    69                          
    70                          ; ********************************************************************************************
    71                          ;
    72                          ;	Date		Changes
    73                          ;	====		=======
    74                          ;
    75                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/color.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      color.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          
    16                          ;*****************************************************************
    17                          ;* COLOR       <ON | OFF> Enable|Disable SW & HW color
    18                          ;* FOREGROUND  color# Set Foreground color (text)
    19                          ;* HIGHLIGHT   color# Set Highlight color (text)
    20                          ;* BACKGROUND  color# Set VIC Background color
    21                          ;* BORDER      color# Set VIC Border color
    22                          ;*****************************************************************
    23                          
    24  b49a c92c               color           cmp     #','                            ; optional first arg
    25  b49c f01f                               beq     l283_3
    26  b49e c991                               cmp     #on_token                       ; SOFTWARE (Editor) color mode
    27  b4a0 f00b                               beq     l283_2
    28  b4a2 2016b5                             jsr     chkesc
    29  b4a5 c924                               cmp     #off_token
    30  b4a7 d3a179             l283_1          +lbne   snerr
    31                          
    32  b4aa a05b                               ldy     #'['                            ; OFF (color & attributes)
    33  b4ac 2c                                 !text $2c
    34  b4ad a05d               l283_2          ldy     #']'                            ; ON
    35  b4af a91b                               lda     #esc
    36  b4b1 20d2ff                             jsr     _bsout                          ; do it
    37  b4b4 98                                 tya
    38  b4b5 20d2ff                             jsr     _bsout
    39  b4b8 208322                             jsr     chrget                          ; eat token
    40  b4bb f01d                               beq     l283_6                          ; eol- exit
    41                          
    42  b4bd 205b4e             l283_3          jsr     chkcom                          ; else must be comma, eat & get next
    43                          ; jsr chrgot  ;      [910930]
    44  b4c0 c991                               cmp     #on_token                       ; HARDWARE (Vic) color mode
    45  b4c2 f00e                               beq     l283_4
    46  b4c4 2016b5                             jsr     chkesc
    47  b4c7 c924                               cmp     #off_token
    48  b4c9 d0dc                               bne     l283_1
    49                          
    50  b4cb a902                               lda     #%00000010                      ; OFF (monochrome)
    51  b4cd 0c31d0                             tsb     vic+49
    52  b4d0 8005                               bra     l283_5
    53                          
    54  b4d2 a902               l283_4          lda     #%00000010                      ; ON
    55  b4d4 1c31d0                             trb     vic+49
    56  b4d7 83aa6d             l283_5          +lbra   chrget                          ; exit after eating last token
    57                          
    58  b4da 60                 l283_6          rts                                     ; exit after encountering eol
    59                          
    60                          
    61                          foreground
    62  b4db 200db5                             jsr     getnyb                          ; Set text foreground color
    63  b4de 86f1                               stx     _color
    64  b4e0 60                                 rts
    65                          
    66                          
    67                          
    68                          highlight
    69  b4e1 f36779                             +lbeq   snerr                           ; missing args??     [911017]
    70  b4e4 c92c                               cmp     #','
    71  b4e6 f006                               beq     l284_1                          ; options byte only
    72                          
    73  b4e8 206c5d                             jsr     getbyt                          ; Set text highlight color
    74  b4eb 8ed802                             stx     highlight_color
    75                          
    76  b4ee 202479             l284_1          jsr     optzer                          ; set options:     [911001]
    77  b4f1 9008                               bcc     l284_2                          ; comma but no value not given??
    78  b4f3 8a                                 txa
    79  b4f4 2903                               and     #3                              ; 0= error msgs only
    80  b4f6 0a                                 asl                                     ; 1= REMs
    81  b4f7 0a                                 asl                                     ; 2= tokens
    82  b4f8 0a                                 asl
    83  b4f9 8555                               sta     helper
    84  b4fb 60                 l284_2          rts
    85                          
    86                          
    87                          
    88                          background
    89  b4fc 200db5                             jsr     getnyb                          ; Set Vic background color
    90  b4ff 8e21d0                             stx     vic+33
    91  b502 60                                 rts
    92                          
    93                          
    94                          
    95                          border
    96  b503 200db5                             jsr     getnyb                          ; Set Vic border color
    97  b506 8e20d0                             stx     vic+32
    98  b509 60                                 rts
    99                          
   100                          
   101                          getcomnyb
   102  b50a 205b4e                             jsr     chkcom                          ; check for comma
   103                          getnyb
   104  b50d 206c5d                             jsr     getbyt                          ; Get a nybble, check range (0-15)
   105                          chknyb
   106  b510 e010                               cpx     #16
   107  b512 b3ea9c                             +lbcs   fcerr
   108  b515 60                                 rts
   109                          
   110                          
   111                          
   112                          chkesc                                                  ; Check for escape token, error if not, else get next token
   113  b516 c9fe                               cmp     #esc_command_token
   114  b518 d33079                             +lbne   snerr
   115  b51b 208322                             jsr     chrget
   116  b51e f32a79                             +lbeq   snerr                           ; eos? report error if so
   117  b521 60                                 rts
   118                          
   119                          
   120                          
   121                          chkeos                                                  ; Check for next byte = end of statement, error if not
   122  b522 208322                             jsr     chrget
   123  b525 d32379                             +lbne   snerr                           ; eos? report error if not
   124  b528 60                                 rts
   125                          
   126                          
   127                          ;.end
   128                          
   129                          ; ********************************************************************************************
   130                          ;
   131                          ;	Date		Changes
   132                          ;	====		=======
   133                          ;
   134                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/sprite.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      sprite.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;************************************************************************************
    16                          ; SPRITE CLR
    17                          ; SPRITE {LOAD|SAVE} "filename" [,Ddrive] [,Udevice]
    18                          ; SPRITE sprite [,enable [,color [,priority [,xexp [,yexp [,resolution] ]]]]]
    19                          ;
    20                          ; where: sprite  :== sprite number (1-8)
    21                          ;  enable  :== enable  (0=off, 1=on)
    22                          ;  color  :== color  (0-15)
    23                          ;  priority :== sprite/bgnd  (0=sprite, 1=bgnd)
    24                          ;  xexp  :== expand x direction (0=no, 1=yes)
    25                          ;  yexp  :== expand y direction (0=no, 1=yes)
    26                          ;  resolution :== resolution  (0=hires, 1=multicolor)
    27                          ;************************************************************************************
    28                          
    29  b529 c99c               sprite          cmp     #clr_token                      ; SPRITE CLR: init environment   [910717]
    30  b52b f3a709                             +lbeq   Sprite_CLR                      ; yes
    31  b52e c994                               cmp     #save_token                     ; SPRITE SAVE: save sprite data   [911001]
    32  b530 f048                               beq     Sprite_Save                     ; yes
    33  b532 c993                               cmp     #load_token                     ; SPRITE LOAD: load sprite data   [911001]
    34  b534 f057                               beq     Sprite_Load                     ; yes
    35                          
    36  b536 20b5b5                             jsr     get_sprite_number               ; get sprite number in z_p_temp_1
    37  b539 202679                             jsr     optbyt                          ; look for (optional) enable
    38  b53c 9005                               bcc     l285_1                          ; none here, don't change
    39  b53e a015                               ldy     #21
    40  b540 209fb5                             jsr     sprbit                          ; set/clear sprite bit
    41                          
    42  b543 202679             l285_1          jsr     optbyt                          ; get (optional) color
    43  b546 9009                               bcc     l285_2                          ; branch if no arg
    44  b548 2010b5                             jsr     chknyb                          ; [910109]
    45  b54b 8a                                 txa
    46  b54c a676                               ldx     z_p_temp_1                      ; get back sprite number
    47                          ; jsr put_io_in_map
    48  b54e 9d27d0                             sta     vic+39,x
    49                          
    50  b551 202679             l285_2          jsr     optbyt                          ; look for (optional) priority
    51  b554 9005                               bcc     l285_3
    52  b556 a01b                               ldy     #27
    53  b558 209fb5                             jsr     sprbit
    54                          
    55  b55b 202679             l285_3          jsr     optbyt                          ; look for (optional) x expansion
    56  b55e 9005                               bcc     l285_4
    57  b560 a01d                               ldy     #29
    58  b562 209fb5                             jsr     sprbit
    59                          
    60  b565 202679             l285_4          jsr     optbyt                          ; look for (optional) y expansion
    61  b568 9005                               bcc     l285_5
    62  b56a a017                               ldy     #23
    63  b56c 209fb5                             jsr     sprbit
    64                          
    65  b56f 202679             l285_5          jsr     optbyt                          ; look for (optional) resolution
    66  b572 9005                               bcc     l285_6
    67  b574 a01c                               ldy     #28
    68  b576 209fb5                             jsr     sprbit
    69                          
    70  b579 60                 l285_6          rts
    71                          
    72                          
    73                          Sprite_Save                                             ; Just like Key_Save     [911001]
    74  b57a 202e47                             jsr     GetSaveChannel
    75  b57d a95a                               lda     #highds                         ; set starting & ending addresses
    76  b57f a006                               ldy     #>sprite_base                   ; start address & pointer to it
    77  b581 a200                               ldx     #<sprite_base
    78  b583 845b                               sty     highds+1
    79  b585 865a                               stx     highds
    80  b587 c8                                 iny                                     ; end address = start address + 512 + 1
    81  b588 c8                                 iny
    82  b589 e8                                 inx
    83  b58a 83dfb2                             +lbra   savenb                          ; [910925]
    84                          
    85                          
    86                          
    87                          Sprite_Load
    88  b58d 20c946                             jsr     GetLoadChannel                  ; get a channel      [911001]
    89  b590 a006                               ldy     #>sprite_base
    90  b592 a900                               lda     #<sprite_base
    91  b594 20fa46                             jsr     LoadBlock                       ; load first block
    92  b597 e65b                               inc     highds+1
    93  b599 20fe46                             jsr     LoadBlockNext                   ; load second block
    94  b59c 83897d                             +lbra   list_err                        ; release channel, close file, return to main
    95                          
    96                          
    97                          ;  Set or clear a bit in a VIC register
    98                          ;
    99                          ; .X = 1 to set, 0 to clear
   100                          ; .Y = register in VIC to operate opon
   101                          
   102  b59f 8a                 sprbit          txa
   103  b5a0 4a                                 lsr                                     ; put lsb in .C (0 clear, 1 set sprite bit)
   104  b5a1 d35b9c                             +lbne   fcerr                           ; only 0 or 1, please.
   105                          ; jsr put_io_in_map
   106  b5a4 a676                               ldx     z_p_temp_1                      ; get sprite number
   107  b5a6 bd6579                             lda     sbits,x
   108  b5a9 1900d0                             ora     vic,y
   109  b5ac b003                               bcs     l286_1
   110  b5ae 5d6579                             eor     sbits,x
   111  b5b1 9900d0             l286_1          sta     vic,y
   112  b5b4 60                                 rts
   113                          
   114                          
   115                          get_sprite_number
   116  b5b5 206c5d                             jsr     getbyt
   117                          ; dex        [910221]
   118  b5b8 e008                               cpx     #8
   119  b5ba b3429c                             +lbcs   fcerr
   120  b5bd 8676                               stx     z_p_temp_1
   121  b5bf 60                                 rts
   122                          
   123                          ;.end
   124                          
   125                          ; ********************************************************************************************
   126                          ;
   127                          ;	Date		Changes
   128                          ;	====		=======
   129                          ;
   130                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/movspr.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      movspr.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;****************************************************************
    16                          ; Move Sprite.  Position sprite and optionally animate it.
    17                          ;
    18                          ;   MOVSPR n, [ p | x#y ]   or   MOVSPR n, p1 TO p2, speed
    19                          ;
    20                          ;  n = Sprite number (0-7)
    21                          ; p = (x,y) coordinate.
    22                          ;  Relative and angular distances  are relative to
    23                          ;  current sprite position and scaled if scaling is on.
    24                          ; x#y = Constant movement at an angle-x with speed-y.
    25                          ;****************************************************************
    26                          
    27  b5c0 a900               movspr          lda     #0                              ; flag 'movspr' initial coord   [910808]
    28  b5c2 8587                               sta     op                              ; (0=movspr, $80=movspr_to, $7f=mouse)
    29  b5c4 20b5b5                             jsr     get_sprite_number               ; get sprite #
    30  b5c7 20c3b7                             jsr     sprcor                          ; get first coordinate (y,a)
    31                          movspr_1                                                ; entry to eval destination coordinate  [910808]
    32  b5ca 2cf411                             bit     numcnt                          ; test coordinate type
    33  b5cd 737b78                             +lbvs   snerr                           ; syntax error
    34  b5d0 8cf011                             sty     xdest                           ; save coordinate value
    35  b5d3 8cf211                             sty     xdest+2
    36  b5d6 8df111                             sta     xdest+1
    37  b5d9 8df311                             sta     xdest+3
    38                          
    39  b5dc 20c3b7                             jsr     sprcor                          ; get second coordinate (y,a)
    40  b5df 2cf411                             bit     numcnt                          ; test coordinate type & dispatch accordingly
    41  b5e2 5060                               bvc     movspr_normal                   ; normal coordinates
    42  b5e4 3040                               bmi     movspr_angle                    ; angular coordinates
    43                          
    44  b5e6 2487                               bit     op                              ; angle#speed, test if allowed
    45  b5e8 336078                             +lbmi   snerr                           ; ng- movspr_to call
    46  b5eb 5a                                 phy                                     ; ok- save speed value
    47  b5ec a004                               ldy     #xdest-vwork
    48  b5ee 20b5ba                             jsr     getang                          ; get angle of movement
    49  b5f1 a676                               ldx     z_p_temp_1                      ; get sprite number
    50  b5f3 bcfeb7                             ldy     sproff,x                        ; get offset to speed data
    51  b5f6 a900                               lda     #0
    52  b5f8 990512                             sta     sprite_data,y                   ; turn off sprite speed
    53  b5fb c8                                 iny
    54                          
    55  b5fc a203                               ldx     #3
    56  b5fe 5efb11             l287_1          lsr     sinval,x
    57  b601 ca                                 dex
    58  b602 7efb11                             ror     sinval,x
    59  b605 ca                                 dex
    60  b606 10f6                               bpl     l287_1
    61                          
    62  b608 78                 l287_2          sei
    63  b609 e8                                 inx                                     ; x=0
    64  b60a bdfa11                             lda     angsgn,x                        ; move angle data to speed data
    65  b60d c8                                 iny
    66  b60e 990512                             sta     sprite_data,y
    67  b611 e004                               cpx     #4
    68  b613 d0f3                               bne     l287_2
    69                          
    70  b615 a900                               lda     #0                              ; clear speed angle counts
    71  b617 c8                 l287_3          iny
    72  b618 990512                             sta     sprite_data,y
    73  b61b ca                                 dex
    74  b61c d0f9                               bne     l287_3
    75                          
    76  b61e 68                                 pla                                     ; restore speed value
    77  b61f 293f                               and     #$3f                            ; limit range (0-63) ????  [910806]
    78  b621 99fb11                             sta     sprite_data-10,y                ; start sprite movement
    79  b624 58                                 cli
    80  b625 60                                 rts
    81                          
    82                          movspr_angle
    83                          ; jsr swapxy  ;swap y and a (eventually) : y ==> x
    84                          ; tay   ;        a ==> y
    85                          ; txa   ;        x ==> a
    86  b626 48                                 pha
    87  b627 98                                 tya
    88  b628 7a                                 ply
    89                          
    90  b629 20b8ba                             jsr     gtang1                          ; get angle values
    91                          ; ldx #xdest-vwork
    92                          ; jsr scalxy  ;scale lengths
    93  b62c a204                               ldx     #xdest-vwork
    94  b62e 18                                 clc
    95                          
    96  b62f 2011bb             l288_1          jsr     angmlt                          ; multiply lengths*angles for x and y
    97  b632 9dec11                             sta     vwork,x
    98  b635 98                                 tya
    99  b636 9ded11                             sta     vwork+1,x
   100  b639 e8                                 inx
   101  b63a e8                                 inx
   102  b63b e006                               cpx     #ydest-vwork
   103  b63d f0f0                               beq     l288_1                          ; loop to do y-position
   104                          
   105  b63f 6ef411                             ror     numcnt                          ; shift in carry to set msb
   106  b642 8006                               bra     movspr_position                 ; go place sprite
   107                          
   108                          
   109                          movspr_normal                                           ; [910122]
   110  b644 8cf211                             sty     xdest+2                         ; save second coordinate (y,a)
   111  b647 8df311                             sta     xdest+3
   112                          ; ldx #xdest-vwork
   113                          ; jsr scalxy  ;scale the coordinates
   114                          
   115                          
   116                          movspr_position
   117  b64a 78                                 sei                                     ; [910123]
   118  b64b a576                               lda     z_p_temp_1                      ; get sprite number
   119  b64d aa                                 tax                                     ; use as an index
   120  b64e 0a                                 asl
   121  b64f a8                                 tay                                     ; get sprite-number * 2 as another index
   122                          
   123  b650 7f8701                             bbr7    op,l289_1
   124  b653 60                                 rts                                     ; >>>exit here if movspr_to call   [910808]
   125                          
   126  b654 adf211             l289_1          lda     xdest+2                         ; get y-coordinate
   127  b657 0ef411                             asl     numcnt                          ; test if relative
   128  b65a 9009                               bcc     l289_3                          ; skip if absolute
   129  b65c 18                                 clc
   130  b65d 1003                               bpl     l289_2                          ; skip if normal coordinates
   131  b65f 49ff                               eor     #$ff
   132  b661 38                                 sec                                     ; invert to subtract if angular
   133  b662 7901d0             l289_2          adc     vic+1,y                         ; add to current sprite y-value  ???vic_save
   134                          
   135  b665 9901d0             l289_3          sta     vic+1,y                         ; save new sprite y-position  ???vic_save
   136  b668 adf011                             lda     xdest                           ; get low byte of x-coordinate
   137  b66b 0ef411                             asl     numcnt                          ; test if relative
   138  b66e 1011                               bpl     l289_5                          ; skip if absolute
   139  b670 18                                 clc
   140  b671 7900d0                             adc     vic,y                           ; add current sprite x-position  ???vic_save
   141  b674 9900d0                             sta     vic,y                           ; save sprite x-position   ???vic_save
   142  b677 b003                               bcs     l289_4                          ; skip if carry
   143  b679 eef111                             inc     xdest+1                         ; invert lsb
   144                          
   145  b67c ad10d0             l289_4          lda     vic+16                          ; get x-position msb bits  ???vic_save
   146  b67f 8009                               bra     l289_6                          ; test if need to invert msb bit
   147                          
   148  b681 9900d0             l289_5          sta     vic,y                           ; save new sprite x-position  ???vic_save
   149  b684 ad10d0                             lda     vic+16                          ; ???vic_save
   150  b687 1d6579                             ora     sbits,x                         ; set x-position msb bit
   151                          
   152  b68a 4ef111             l289_6          lsr     xdest+1                         ; match to lsb of x-coordinate high byte
   153  b68d b003                               bcs     l289_7                          ; skip if should be set
   154  b68f 5d6579                             eor     sbits,x                         ; reset bit
   155                          
   156  b692 8d10d0             l289_7          sta     vic+16                          ; save position msb bits   ???vic_save
   157                          ; cli
   158                          ;1l289_1 rts   ; mouse or movspr_to
   159                          
   160                          
   161                          movspr_to                                               ; setup for moving sprite to a particular position
   162                          ;we have already positioned the sprite onscreen
   163  b695 208522                             jsr     chrgot                          ; reget terminating character
   164  b698 c9a4                               cmp     #to_token
   165  b69a f002                               beq     l290_1                          ; not our call
   166  b69c 58                                 cli
   167  b69d 60                                 rts
   168                          
   169  b69e f787               l290_1          smb7    op                              ; it's for us- let everybody else know we're in charge
   170  b6a0 208322                             jsr     chrget                          ; move to next non-space character
   171  b6a3 18                                 clc
   172  b6a4 20c6b7                             jsr     sprcor_1                        ; go get & evaluate destination coordinate
   173  b6a7 20cab5                             jsr     movspr_1                        ; returns with sprite# in .x, VIC sprite index in .y,
   174                          ;P1 in VIC sprite regs, and P2 in x,ydest
   175  b6aa 0ef411                             asl     numcnt                          ; Y: handle specific coordinate types
   176  b6ad 900f                               bcc     l290_3                          ; skip if absolute
   177  b6af 18                                 clc
   178  b6b0 adf211                             lda     xdest+2                         ; get y-coordinate
   179  b6b3 1003                               bpl     l290_2                          ; skip if normal coordinates
   180  b6b5 49ff                               eor     #$ff
   181  b6b7 38                                 sec                                     ; invert to subtract if angular
   182  b6b8 7901d0             l290_2          adc     vic+1,y                         ; add to current sprite y-value ???vic_save
   183  b6bb 8df211                             sta     xdest+2                         ; save sprite destination y-position
   184                          
   185  b6be 0ef411             l290_3          asl     numcnt                          ; X: handle specific coordinate types
   186  b6c1 100f                               bpl     l290_4                          ; skip if absolute
   187  b6c3 18                                 clc
   188  b6c4 adf011                             lda     xdest                           ; get low byte of x-coordinate
   189  b6c7 7900d0                             adc     vic,y                           ; add current sprite x-position  ???vic_save
   190  b6ca 8df011                             sta     xdest                           ; save sprite destination x-position
   191  b6cd 9003                               bcc     l290_4
   192  b6cf eef111                             inc     xdest+1
   193                          
   194  b6d2 5a                 l290_4          phy
   195  b6d3 20825d                             jsr     combyt                          ; get speed parameter
   196  b6d6 8a                                 txa
   197  b6d7 293f                               and     #$3f                            ; limit range (0-63) ????
   198  b6d9 0980                               ora     #$80
   199  b6db 8d8411                             sta     xcnt                            ; save in temp.
   200  b6de 7a                                 ply
   201                          
   202  b6df b900d0                             lda     vic,y                           ; copy current sprite pos'n to line vars
   203  b6e2 8dec11                             sta     xpos                            ; in preparation for line calculations
   204  b6e5 b901d0                             lda     vic+1,y
   205  b6e8 8dee11                             sta     ypos
   206  b6eb a900                               lda     #0
   207  b6ed 8ded11                             sta     xpos+1
   208  b6f0 8def11                             sta     ypos+1
   209  b6f3 98                                 tya
   210  b6f4 4a                                 lsr
   211  b6f5 a8                                 tay
   212  b6f6 b96579                             lda     sbits,y
   213  b6f9 2d10d0                             and     vic+16
   214  b6fc f003                               beq     l290_5
   215  b6fe eeed11                             inc     xpos+1
   216                          l290_5
   217                          
   218                          ;******************************************************************
   219                          ;  MOVSPR n, p1 TO p2 - move a sprite along line from p1 to p2
   220                          ;
   221                          ; The following is performed now:
   222                          ;
   223                          ;           absx    = abs(destx-posx) : absy = abs(desty-posy)
   224                          ;           sgnx    = sgn(destx-posx) : sgny = sgn(desty-posy)
   225                          ;                     ( sgn=(1,0,-1) if (+,0,-) )
   226                          ;           greatr  = index to the greatr of absx,absy
   227                          ;           lesser  = index to the smaller of absx,absy
   228                          ;
   229                          ;           fct1    = 2*min(absx,absy)
   230                          ;           fct2    = fct1 - 2*max(absx,absy)
   231                          ;           error   = fct1 - max(absx,absy)
   232                          ;
   233                          ; The following is performed during IRQ:
   234                          ;
   235                          ;           for i:= 1 to max(absx,absy) do begin
   236                          ;                 movspr n, posx, posy
   237                          ;                 if error > 0 then begin
   238                          ;                      pos(lesser):= pos(lesser) + sgn(lesser)
   239                          ;                      error:= error + fct2
   240                          ;                      end
   241                          ;                      else error:= error + fct1
   242                          ;                 pos(greatr):= pos(greatr) + sgn(greatr)
   243                          ;           end;
   244                          ;
   245                          ; (modification of C128 Bresenham DrawLn algorithm 910808 F.Bowen)
   246                          ;******************************************************************
   247                          
   248                          movspr_line
   249  b701 a202                               ldx     #ypos-vwork
   250  b703 a006                               ldy     #ydest-vwork
   251  b705 a900               l291_1          lda     #0
   252  b707 9d9511                             sta     xsgn,x                          ; init direction pointers
   253  b70a 9d9611                             sta     xsgn+1,x
   254  b70d 207fbb                             jsr     abstwo                          ; get absolute value of coordinate differences
   255  b710 1008                               bpl     l291_2                          ; and determine direction
   256  b712 de9511                             dec     xsgn,x                          ; negative direction
   257  b715 de9611                             dec     xsgn+1,x
   258  b718 800b                               bra     l291_4
   259                          
   260  b71a c900               l291_2          cmp     #0
   261  b71c d004                               bne     l291_3
   262  b71e c000                               cpy     #0
   263  b720 f003                               beq     l291_4                          ; zero direction
   264  b722 fe9511             l291_3          inc     xsgn,x                          ; positive direction
   265  b725 9d9111             l291_4          sta     xabs,x
   266  b728 0a                                 asl
   267  b729 9d9911                             sta     fct,x                           ; fct(x,y) = 2*abs(x,y)
   268  b72c 98                                 tya
   269  b72d 9d9211                             sta     xabs+1,x
   270  b730 2a                                 rol
   271  b731 9d9a11                             sta     fct+1,x
   272  b734 ca                                 dex
   273  b735 ca                                 dex
   274  b736 a004                               ldy     #xdest-vwork                    ; loop to do in x-direction
   275  b738 e000                               cpx     #xpos-vwork
   276  b73a f0c9                               beq     l291_1
   277                          
   278  b73c a202                               ldx     #yabs-savram                    ; determine max(xabs,yabs)
   279  b73e a000                               ldy     #xabs-savram
   280  b740 205cbb                             jsr     subtwo_savram
   281  b743 a900                               lda     #0
   282  b745 2a                                 rol
   283  b746 2a                                 rol                                     ; a = c * 2
   284  b747 8d0312                             sta     lesser                          ; index to smaller delta
   285  b74a 4902                               eor     #2
   286  b74c 8d0412                             sta     greatr                          ; index to greater delta
   287                          
   288  b74f 18                                 clc
   289  b750 a908                               lda     #fct-savram
   290  b752 6d0312                             adc     lesser
   291  b755 48                                 pha
   292  b756 a8                                 tay
   293  b757 4902                               eor     #2
   294  b759 aa                                 tax
   295  b75a 205cbb                             jsr     subtwo_savram                   ; fct(greatr) = fct(lesser)-fct(greatr)
   296  b75d 9d9111                             sta     savram,x
   297  b760 8b9211                             sty     savram+1,x
   298                          
   299  b763 7a                                 ply                                     ; fct(lesser)
   300  b764 18                                 clc
   301  b765 a900                               lda     #xabs-savram
   302  b767 6d0412                             adc     greatr
   303  b76a aa                                 tax
   304  b76b 205cbb                             jsr     subtwo_savram                   ; error = fct(lesser) - abs(greatr)
   305  b76e 8d9d11                             sta     errval
   306  b771 8c9e11                             sty     errval+1
   307                          
   308                          ; At this point, we've positioned the sprite at the start position, and have
   309                          ; calculated everything we need to move it along a line towards the destination
   310                          ; position.  All that's left is to copy the working vars into the sprite_data
   311                          ; tables where the IRQ routine can find & diddle with our data.
   312                          ;
   313                          ;    move ang/dist move line
   314                          ;  offset= 0 b7=0+speed b7=1+speed
   315                          ;   1 counter  counter lo
   316                          ;   2 angle sign         hi
   317                          ;   3,4 delta-X  dir+min/max
   318                          ;   5,6 delta-Y  fct1
   319                          ;   7,8 total-X  fct2
   320                          ;   9,10 total-Y  error
   321                          
   322  b774 a476                               ldy     z_p_temp_1                      ; sprite #
   323  b776 befeb7                             ldx     sproff,y                        ; sprite IRQ table offset
   324                          
   325  b779 ad8411                             lda     xcnt                            ; set speed factor
   326  b77c 9d0512                             sta     sprite_data,x
   327  b77f ac0412                             ldy     greatr
   328  b782 b99111                             lda     xabs,y                          ; set counter = max(xyabs)
   329  b785 9d0612                             sta     sprite_data+1,x
   330  b788 b99211                             lda     xabs+1,y
   331  b78b 9d0712                             sta     sprite_data+2,x
   332  b78e b99511                             lda     xsgn,y                          ; set dir(max) and max
   333  b791 199611                             ora     xsgn+1,y
   334  b794 2903                               and     #3
   335  b796 4a                                 lsr
   336  b797 6a                                 ror
   337  b798 0d0412                             ora     greatr
   338  b79b 6a                                 ror
   339  b79c 9d0912                             sta     sprite_data+4,x
   340  b79f ac0312                             ldy     lesser
   341  b7a2 b99511                             lda     xsgn,y                          ; set dir(min) and min
   342  b7a5 199611                             ora     xsgn+1,y
   343  b7a8 2903                               and     #3
   344  b7aa 4a                                 lsr
   345  b7ab 6a                                 ror
   346  b7ac 0d0312                             ora     lesser
   347  b7af 6a                                 ror
   348  b7b0 9d0812                             sta     sprite_data+3,x
   349  b7b3 a000                               ldy     #0                              ; set f1, f2, and e
   350  b7b5 b99911             l291_5          lda     fct,y
   351  b7b8 9d0a12                             sta     sprite_data+5,x
   352  b7bb e8                                 inx
   353  b7bc c8                                 iny
   354  b7bd c006                               cpy     #6
   355  b7bf 90f4                               bcc     l291_5
   356                          
   357  b7c1 58                                 cli
   358  b7c2 60                                 rts                                     ; done!
   359                          
   360                          
   361                          ; ********************************************************************************************
   362                          ;
   363                          ;	Date		Changes
   364                          ;	====		=======
   365                          ;
   366                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/sprcor.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      sprcor.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ;  SPRCOR  -- Get sprite position coordinate
    15                          ;
    16                          
    17  b7c3 20ebb7             sprcor          jsr     chkcom_1                        ; check for a comma
    18                          sprcor_1
    19  b7c6 6ef411                             ror     numcnt                          ; reset msb if comma else set msb
    20  b7c9 100b                               bpl     l292_1                          ; skip if got a comma
    21  b7cb c93b                               cmp     #';'                            ; test if angular data
    22  b7cd f013                               beq     l292_3                          ; skip if yes - 2 msb's = 1 1
    23  b7cf c923                               cmp     #'#'                            ; test if speed type
    24  b7d1 f00e                               beq     l292_2                          ; skip if yes - 2 msb's = 0 1
    25  b7d3 837576                             +lbra   snerr                           ; syntax error if none of above
    26                          
    27  b7d6 208522             l292_1          jsr     chrgot                          ; test for relative coordinate
    28  b7d9 c9aa                               cmp     #plus_token                     ; test if plus sign
    29  b7db f005                               beq     l292_3                          ; skip if yes - show relative
    30  b7dd c9ab                               cmp     #minus_token                    ; test if minus sign
    31  b7df f001                               beq     l292_3                          ; skip if yes - show relative
    32  b7e1 18                 l292_2          clc                                     ; reset to show absolute
    33  b7e2 6ef411             l292_3          ror     numcnt                          ; shift in second flag bit
    34                          
    35  b7e5 20d84c             sadwrd          jsr     frmnum                          ; get number     label [910307]
    36  b7e8 83a8a5                             +lbra   getsad                          ; get signed 2 byte coordinate,do rts
    37                          
    38                          
    39                          ;*************************************************************
    40                          ; CHKCOM_1  --  Check for a comma
    41                          ;
    42                          ;  carry set & eq = end of string
    43                          ;  carry set & neq = not a comma
    44                          ;  carry clear = a comma
    45                          ;*************************************************************
    46                          
    47                          chkcom_1
    48  b7eb 208522                             jsr     chrgot                          ; get character in input stream
    49  b7ee f00d                               beq     l293_2                          ; skip if end of string
    50  b7f0 c92c                               cmp     #','                            ; check if a comma
    51  b7f2 18                                 clc
    52  b7f3 f001                               beq     l293_1                          ; skip if yes
    53  b7f5 38                                 sec                                     ; set carry if not
    54  b7f6 08                 l293_1          php
    55  b7f7 48                                 pha
    56  b7f8 208322                             jsr     chrget                          ; move to next non-space character
    57  b7fb 68                                 pla
    58  b7fc 28                                 plp
    59  b7fd 60                 l293_2          rts
    60                          
    61                          
    62  b7fe 000b16212c37424d   sproff          !text 0,11,22,33,44,55,66,77            ; sprite offsets into speed table
    63                          
    64                          ;.end
    65                          
    66                          ; ********************************************************************************************
    67                          ;
    68                          ;	Date		Changes
    69                          ;	====		=======
    70                          ;
    71                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/sprcolor.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      sprcolor.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;**************************************************************
    16                          ;*
    17                          ;*   SPRCOLOR - Set sprite multicolor registers
    18                          ;*
    19                          ;* syntax : SPRCOLOR [multicolor_1] [,multicolor_2]
    20                          ;*
    21                          ;**************************************************************
    22                          
    23                          sprcolor
    24  b806 c92c                               cmp     #','                            ; is there a first arg?
    25  b808 f006                               beq     l294_1                          ; nope, skip to second
    26                          
    27  b80a 200db5                             jsr     getnyb                          ; get 1 byte arg in .X, range 0-15
    28                          ; jsr put_io_in_map
    29  b80d 8e25d0                             stx     vic+37
    30                          
    31  b810 202679             l294_1          jsr     optbyt                          ; get (optional) 1 byte arg in .X
    32  b813 9006                               bcc     l294_2
    33  b815 2010b5                             jsr     chknyb                          ; range 0-15
    34                          ; jsr put_io_in_map
    35  b818 8e26d0                             stx     vic+38
    36                          
    37  b81b 60                 l294_2          rts
    38                          
    39                          ;.end
    40                          
    41                          
    42                          
    43                          ;***************************************************************
    44                          ;  SPRSAV ( n1 / s1$ ) , ( n2 / s2$ )
    45                          ;   - move string(s1) or sprite(n1) to string(s2) or sprite(n2)
    46                          ;               n1 & n2 = a sprite number (1-8)
    47                          ;                   s1$ = a string variable or expression
    48                          ;                   s2$ = a string variable
    49                          ;***************************************************************
    50                          
    51  b81c 20a9b8             sprsav          jsr     savinp                          ; evaluate 1st expression
    52  b81f b02f                               bcs     l295_2                          ; skip if source is a string
    53  b821 854b                               sta     forpnt
    54  b823 844c                               sty     forpnt+1                        ; save sprite address
    55  b825 a03e                               ldy     #62
    56                          
    57  b827 b14b               l295_1          lda     (forpnt),y                      ; move sprite def to save area
    58  b829 999111                             sta     savram,y
    59  b82c 88                                 dey
    60  b82d 10f8                               bpl     l295_1
    61                          
    62  b82f c8                                 iny                                     ; (0)
    63  b830 8cd111                             sty     savram+64                       ; save sprite column length
    64  b833 8cd311                             sty     savram+66                       ; save sprite row length
    65  b836 a917                               lda     #23
    66  b838 8dd011                             sta     savram+63
    67  b83b a914                               lda     #20
    68  b83d 8dd211                             sta     savram+65
    69  b840 a291                               ldx     #<savram                        ; set ptr to start of sprite def
    70  b842 a011                               ldy     #>savram
    71  b844 8670                               stx     strng1                          ; **
    72  b846 8471                               sty     strng1+1                        ; **
    73                          
    74  b848 a943                               lda     #67                             ; set sprite length including lengths
    75  b84a 20b75a                             jsr     strlit_1                        ; **get string space, copy savram to it
    76  b84d 20c2b8                             jsr     desc_free                       ; **free up temp descriptor
    77                          
    78  b850 8eff11             l295_2          stx     savsiz                          ; save source length
    79  b853 8d0012                             sta     savsiz+1
    80  b856 8c0112                             sty     savsiz+2                        ; save source start address
    81                          
    82  b859 205b4e                             jsr     chkcom                          ; check for a comma
    83  b85c a53d                               lda     txtptr                          ; save basic text pointer
    84  b85e 8d0312                             sta     sprtmp_1
    85  b861 a53e                               lda     txtptr+1
    86  b863 8d0412                             sta     sprtmp_2
    87  b866 20a9b8                             jsr     savinp                          ; get next destination parameter
    88  b869 b022                               bcs     savs50                          ; skip if string
    89                          
    90  b86b 8587                               sta     grapnt
    91  b86d 8488                               sty     grapnt+1                        ; save sprite address
    92  b86f ad0012                             lda     savsiz+1
    93  b872 854b                               sta     forpnt                          ; get source address
    94  b874 ad0112                             lda     savsiz+2
    95  b877 854c                               sta     forpnt+1
    96  b879 a000                               ldy     #0
    97  b87b ccff11             l295_3          cpy     savsiz                          ; test index vs source length
    98  b87e f00c                               beq     l295_4                          ; exit if source depleted
    99  b880 a94b                               lda     #forpnt                         ; move source byte to sprite
   100  b882 20d722                             jsr     lda_far_ram1                    ; (from ram bank 1)
   101                          ; sta sw_rom_ram0
   102  b885 9187                               sta     (grapnt),y                      ; (to sprite area in bank 0)????
   103  b887 c8                                 iny
   104  b888 c03f                               cpy     #63
   105  b88a d0ef                               bne     l295_3
   106  b88c 60                 l295_4          rts
   107                          
   108                          
   109  b88d ad0312             savs50          lda     sprtmp_1                        ; restore basic text pointer
   110  b890 853d                               sta     txtptr
   111  b892 ad0412                             lda     sprtmp_2
   112  b895 853e                               sta     txtptr+1
   113  b897 207c4f                             jsr     ptrget                          ; get symbol table descriptor for string dest.
   114  b89a 854b                               sta     forpnt
   115  b89c 844c                               sty     forpnt+1                        ; save symbol table address
   116  b89e a9ff                               lda     #<savsiz
   117  b8a0 8566                               sta     facmo                           ; save descriptor address of source
   118  b8a2 a911                               lda     #>savsiz
   119  b8a4 8567                               sta     facmo+1
   120  b8a6 830d7e                             +lbra   inpcom                          ; move source to dest, do rts (snerr if not eol)
   121                          
   122                          
   123  b8a9 20ef4c             savinp          jsr     frmevl                          ; evaluate expression
   124  b8ac ff0f13                             bbs7    valtyp,desc_free                ; exit if a string
   125  b8af 206f5d                             jsr     conint                          ; get one byte integer in .X
   126                          ; dex    ;adjust sprite 1..8 to 0..7  [910220]
   127  b8b2 e008                               cpx     #8
   128  b8b4 b34899                             +lbcs   fcerr                           ; bad value
   129  b8b7 8a                                 txa                                     ; move sprite number to .A
   130  b8b8 4a                                 lsr
   131  b8b9 6a                                 ror
   132  b8ba 6a                                 ror                                     ; get sprite address
   133  b8bb a006                               ldy     #>sprite_base
   134  b8bd 9001                               bcc     l296_1
   135  b8bf c8                                 iny
   136  b8c0 18                 l296_1          clc                                     ; flag 'sprite' (as opposed to 'string')
   137  b8c1 60                                 rts
   138                          
   139                          
   140                          desc_free                                               ; free temporary descriptor, set up pointers to string.
   141  b8c2 a566                               lda     facmo                           ; get address of temp descriptor
   142  b8c4 a467                               ldy     facmo+1
   143  b8c6 20cc5b                             jsr     fretms
   144  b8c9 a000                               ldy     #0                              ; get len, addr of string
   145  b8cb 20a922                             jsr     indfmo
   146  b8ce aa                                 tax
   147  b8cf c8                                 iny
   148  b8d0 20a922                             jsr     indfmo
   149  b8d3 48                                 pha
   150  b8d4 c8                                 iny
   151  b8d5 20a922                             jsr     indfmo
   152  b8d8 a8                                 tay
   153  b8d9 68                                 pla
   154  b8da 38                                 sec                                     ; flag 'string found'
   155  b8db 60                                 rts                                     ; return w/ x=len, (a,y)==> string
   156                          
   157                          ;.end
   158                          
   159                          ; ********************************************************************************************
   160                          ;
   161                          ;	Date		Changes
   162                          ;	====		=======
   163                          ;
   164                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: command/graphics/collision.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      collision.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;*****************************************************************
    16                          ; COLLISION Command
    17                          ;
    18                          ; Syntax:  COLLISION n [,address]
    19                          ;
    20                          ; Where:   n= 1 ==> sprite / sprite
    21                          ;   2 ==> sprite / background
    22                          ;   3 ==> light pen
    23                          ;
    24                          ; Address ==> BASIC line number to trap to on interrupt
    25                          ;      (no address ==> disable trapping)
    26                          ;*****************************************************************
    27                          
    28                          collision
    29  b8dc 206c5d                             jsr     getbyt                          ; get type in .X
    30  b8df ca                                 dex                                     ; adjust 1..3 to 0..2
    31  b8e0 e003                               cpx     #3
    32  b8e2 b31a99                             +lbcs   fcerr                           ; value error
    33                          
    34  b8e5 da                                 phx                                     ; save collision type
    35  b8e6 20f278                             jsr     optwrd                          ; get address (line number) in .Y,.A (optional)
    36  b8e9 fa                                 plx
    37                          ; php   ;save .C (.C == 1 ==> real value)
    38  b8ea 9de302                             sta     int_adr_hi,x                    ; save address given
    39  b8ed 8be002                             sty     int_adr_lo,x
    40                          
    41  b8f0 addc02                             lda     intval                          ; this records valid interrupts
    42  b8f3 1d6579                             ora     sbits,x                         ; set correct bit
    43                          ; plp
    44  b8f6 b003                               bcs     l297_1                          ; ..unless this is a 'clear',
    45  b8f8 5d6579                             eor     sbits,x                         ; ..in which case we'll reset bit
    46  b8fb 8ddc02             l297_1          sta     intval
    47  b8fe 60                                 rts
    48                          
    49                          ;.end
    50                          
    51                          ; ********************************************************************************************
    52                          ;
    53                          ;	Date		Changes
    54                          ;	====		=======
    55                          ;
    56                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/graphics/rcolor.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rcolor.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;************************************************************************
    16                          ;  RCOLOR (source)  --  return current color assigned to source
    17                          ;   0  :  Background color
    18                          ;   1  :  Foreground color
    19                          ;   2  :  Highlight color
    20                          ;   3  :  Border color
    21                          ;************************************************************************
    22                          
    23  b8ff 206f5d             rcolor          jsr     conint                          ; evaluate integer argument, put in .X
    24                          ; jsr put_io_in_map
    25                          
    26  b902 e004                               cpx     #4
    27  b904 b3f898                             +lbcs   fcerr                           ; illegal qty
    28  b907 8a                                 txa
    29  b908 0a                                 asl                                     ; make into word pointer
    30  b909 aa                                 tax
    31  b90a bd1eb9                             lda     color_source,x                  ; get address of source
    32  b90d 8587                               sta     grapnt
    33  b90f bd1fb9                             lda     color_source+1,x
    34  b912 8588                               sta     grapnt+1
    35  b914 a000                               ldy     #0
    36  b916 b187                               lda     (grapnt),y                      ; read source (aways system space or I/O????)
    37  b918 290f                               and     #$0f                            ; mask unused bits
    38  b91a a8                                 tay
    39                          ; iny   ; make color match keytops
    40  b91b 83b59f                             +lbra   sngflt                          ; float 1 byte in .Y
    41                          
    42                          color_source
    43  b91e 21d0f100d80220d0                   !word vic+33,_color,highlight_color,vic+32
    44                          
    45                          
    46                          ; ********************************************************************************************
    47                          ;
    48                          ;	Date		Changes
    49                          ;	====		=======
    50                          ;
    51                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/graphics/rgraphic.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rgraphic.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ; Return graphic screen status & parameters      [910826]
    16                          ; RGRAPHIC (screen, param) where param = 0 open (1), closed (0), or invalid (>1)
    17                          ;            1 width  (0=320, 1=640, 2=1280)
    18                          ;            2 height (0=200, 1=400)
    19                          ;            3 depth (1-8 bitplanes)
    20                          ;            4 bitplanes used  (bitmask)
    21                          ;            5 bank A blocks used (bitmask)
    22                          ;            6 bank B blocks used (bitmask)
    23                          ;            7 drawscreen # (0-3)
    24                          ;            8 viewscreen # (0-3)
    25                          ;            9 drawmodes  (bitmask)
    26                          ;           10 pattern type  (bitmask)
    27                          ;
    28                          ; Requires a kludge, because RGR used to be a normal 1-arg function in the C128
    29                          ; but now it takes two args.
    30                          
    31                          rgraphic
    32                          ; jsr CheckGraphicMode ;verify screen open
    33  b926 68                                 pla                                     ; remove token from stack
    34  b927 20e8b9                             jsr     PushParms                       ; preserve Graphics parameters & LINNUM  [910820]
    35                          
    36  b92a 20584e                             jsr     chkopn                          ; check for open paren
    37  b92d 206c5d                             jsr     getbyt                          ; get screen # in .X
    38  b930 8e001f                             stx     GKI__parm1
    39  b933 20825d                             jsr     combyt                          ; get param # in .X
    40  b936 e00b                               cpx     #10+1                           ; [911028]
    41  b938 b007                               bcs     l298_1                          ; illegal param #
    42  b93a da                                 phx
    43  b93b 20554e                             jsr     chkcls                          ; check for closing parens
    44                          
    45  b93e 223880                             jsr     ($8038)                         ; read screen params
    46  b941 b3bb98             l298_1          +lbcs   fcerr                           ; bad input????
    47                          
    48  b944 ad011f                             lda     GKI__parm2
    49  b947 fa                                 plx                                     ; get back desired param #
    50  b948 ca                                 dex
    51  b949 1006                               bpl     l298_2
    52  b94b 4980                               eor     #$80                            ; make 0=closed, 1=open, >1=invalid
    53  b94d 4a                                 lsr
    54  b94e 4a                                 lsr
    55  b94f 8003                               bra     l298_3                          ; return screen open status
    56                          
    57  b951 ca                 l298_2          dex
    58  b952 1008                               bpl     l298_5
    59  b954 4a                 l298_3          lsr
    60  b955 4a                 l298_4          lsr
    61  b956 4a                                 lsr
    62  b957 4a                                 lsr
    63  b958 2903                               and     #3
    64  b95a 8012                               bra     l298_8                          ; return width, height
    65                          
    66  b95c ca                 l298_5          dex
    67  b95d 1004                               bpl     l298_6
    68  b95f 2908                               and     #8
    69  b961 80f2                               bra     l298_4
    70  b963 ca                 l298_6          dex
    71  b964 1005                               bpl     l298_7
    72  b966 2907                               and     #7                              ; return depth
    73  b968 1a                                 inc                                     ; make depth 1-8
    74  b969 8003                               bra     l298_8
    75                          
    76  b96b bd021f             l298_7          lda     GKI__parm3,x                    ; return bp bask, banks, etc.
    77  b96e a8                 l298_8          tay
    78  b96f 20d258                             jsr     sngflt                          ; float 1 byte arg in .y
    79                          
    80  b972 20f9b9                             jsr     PopParms                        ; restore Graphics parameters & LINNUM
    81  b975 60                                 rts
    82                          
    83                          
    84                          ; ********************************************************************************************
    85                          ;
    86                          ;	Date		Changes
    87                          ;	====		=======
    88                          ;
    89                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/graphics/pixel.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      pixel.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; Return the color of a given X,Y pixel location on the drawscreen  [910801]
    14                          ;  PIXEL (x,y)
    15                          
    16  b976 201caf             pixel           jsr     CheckGraphicMode                ; verify screen open
    17  b979 20e8b9                             jsr     PushParms                       ; preserve Graphics parameters & LINNUM  [910820]
    18                          
    19  b97c 20925d                             jsr     getsad                          ; get x
    20  b97f 8c001f                             sty     GKI__parm1
    21  b982 8d011f                             sta     GKI__parm2
    22  b985 200879                             jsr     comsad                          ; get y
    23  b988 8c021f                             sty     GKI__parm3
    24  b98b 8d031f                             sta     GKI__parm4
    25  b98e 20554e                             jsr     chkcls                          ; check for closing parens
    26                          
    27  b991 223280                             jsr     ($8032)                         ; get Bitplane data at pixel (x,y), returned in .y
    28  b994 20d258                             jsr     sngflt                          ; go float 1 byte arg in .Y
    29                          
    30  b997 20f9b9                             jsr     PopParms                        ; restore graphics parameters
    31  b99a 60                                 rts
    32                          
    33                          
    34                          ; ********************************************************************************************
    35                          ;
    36                          ;	Date		Changes
    37                          ;	====		=======
    38                          ;
    39                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/graphics/rpen.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rpen.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          ; Return the color of a drawscreen's PEN      [910820]
    14                          ;  RPEN (pen#) where pen# = 0,1,2
    15                          
    16  b99b 201caf             rpen            jsr     CheckGraphicMode                ; verify screen open
    17  b99e 20e8b9                             jsr     PushParms                       ; preserve Graphics parameters & LINNUM  [910820]
    18                          
    19  b9a1 206f5d                             jsr     conint                          ; get 1 byte arg in .x (old style single arg function)
    20  b9a4 e003                               cpx     #3
    21  b9a6 b006                               bcs     l299_1                          ; illegal pen #?
    22  b9a8 8e001f                             stx     GKI__parm1
    23                          
    24  b9ab 223680                             jsr     ($8036)                         ; convert to logical color# (palette index#)
    25  b9ae b34e98             l299_1          +lbcs   fcerr                           ; drawscreen not set or illegal quantity somewhere
    26                          
    27  b9b1 20d258                             jsr     sngflt                          ; go float 1 byte arg in .Y
    28                          
    29  b9b4 20f9b9                             jsr     PopParms                        ; restore graphics parameters
    30  b9b7 60                                 rts
    31                          
    32                          
    33                          
    34                          ; ********************************************************************************************
    35                          ;
    36                          ;	Date		Changes
    37                          ;	====		=======
    38                          ;
    39                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/graphics/rpalette.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rpalette.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          ; Return the R,G, or B component of a color     [910820]
    13                          ; RPALETTE (screen#, color#, rgb)
    14                          
    15                          rpalette
    16  b9b8 201caf                             jsr     CheckGraphicMode                ; verify screen open
    17  b9bb 20e8b9                             jsr     PushParms                       ; Save graphics parameters
    18                          
    19  b9be 206f5d                             jsr     conint                          ; get screen# in .x
    20  b9c1 e004                               cpx     #4
    21  b9c3 b013                               bcs     l300_1                          ; illegal screen#
    22  b9c5 8e001f                             stx     GKI__parm1
    23                          
    24  b9c8 20825d                             jsr     combyt                          ; get color# in .x ????check for legal color#
    25  b9cb 8e011f                             stx     GKI__parm2
    26                          
    27  b9ce 223480                             jsr     ($8034)                         ; get RGB components of color# in PARM3,4,5
    28  b9d1 b005                               bcs     l300_1                          ; something is wrong????
    29                          
    30  b9d3 20825d                             jsr     combyt                          ; get r,g,b component#
    31  b9d6 e003                               cpx     #3
    32  b9d8 b32498             l300_1          +lbcs   fcerr                           ; illegal value
    33                          
    34  b9db bc021f                             ldy     GKI__parm3,x                    ; get r,g,b value
    35  b9de 20d258                             jsr     sngflt                          ; float 1 byte arg in .y
    36                          
    37  b9e1 20554e                             jsr     chkcls                          ; check for closing paren
    38  b9e4 20f9b9                             jsr     PopParms                        ; restore graphics parameters
    39  b9e7 60                                 rts
    40                          
    41                          
    42                          PushParms                                               ; [910820]
    43  b9e8 7a                                 ply                                     ; Grab return address
    44  b9e9 fb                                 plz
    45                          
    46  b9ea fc1600                             phw     linnum                          ; Save 'poker' value
    47                          
    48  b9ed a210                               ldx     #17-1
    49  b9ef bd001f             l301_1          lda     GKI__parm1,x                    ; Save Graphics parameters
    50  b9f2 48                                 pha                                     ; [eg: CHAR x,y,1,1,2,str$(PIXEL(x,y))]
    51  b9f3 ca                                 dex
    52  b9f4 10f9                               bpl     l301_1
    53                          
    54  b9f6 db                                 phz                                     ; Restore return address
    55  b9f7 5a                                 phy
    56  b9f8 60                                 rts
    57                          
    58                          
    59                          PopParms                                                ; [910820]
    60  b9f9 7a                                 ply                                     ; Grab return address
    61  b9fa fb                                 plz
    62                          
    63  b9fb a200                               ldx     #0
    64  b9fd 68                 l302_1          pla                                     ; Restore Graphics parameters
    65  b9fe 9d001f                             sta     GKI__parm1,x
    66  ba01 e8                                 inx
    67  ba02 e011                               cpx     #17
    68  ba04 90f7                               bcc     l302_1
    69                          
    70  ba06 68                                 pla                                     ; Restore 'poker' value
    71  ba07 8517                               sta     linnum+1
    72  ba09 68                                 pla
    73  ba0a 8516                               sta     linnum
    74                          
    75  ba0c db                                 phz                                     ; Restore return address
    76  ba0d 5a                                 phy
    77  ba0e 60                                 rts
    78                          
    79                          ;.end
    80                          
    81                          ; ********************************************************************************************
    82                          ;
    83                          ;	Date		Changes
    84                          ;	====		=======
    85                          ;
    86                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/graphics/rsprite.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rsprite.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;******************************************************************
    16                          ;* RSPRITE - Return sprite information
    17                          ;*
    18                          ;* Syntax : RSPRITE (sprite_number, argument)
    19                          ;*
    20                          ;* Where  : sprite_number = [0..7]
    21                          ;*   argument = [0..5]
    22                          ;*   0 : enabled?   (y(1)/n(0))
    23                          ;*   1 : color?     (0-15)
    24                          ;*   2 : priority over background? (y(1)/n(0))
    25                          ;*   3 : expand in x direction? (y(1)/n(0))
    26                          ;*   4 : expand in Y direction? (y(1)/n(0))
    27                          ;*   5 : multicolor sprite?  (y(1)/n(0))
    28                          ;******************************************************************
    29                          
    30  ba0f 206f5d             rsprite         jsr     conint                          ; get first arg, sprite #, in .X
    31                          ; dex  ;adjust [1..8] to [0..7]   [910220]
    32  ba12 e008                               cpx     #8  ; (318018-03 mod            ; fab)
    33  ba14 b00a                               bcs     l303_1                          ; value error
    34  ba16 8a                                 txa
    35  ba17 48                                 pha                                     ; save sprite number
    36                          
    37                          ; jsr chkcom ;check for proper delimiter
    38                          ; jsr getbyt ;do frmevl, get 1 byte arg (arg) in .X
    39  ba18 20825d                             jsr     combyt                          ; [910820]
    40  ba1b 20554e                             jsr     chkcls                          ; look for closing paren
    41  ba1e e006                               cpx     #6
    42  ba20 b3dc97             l303_1          +lbcs   fcerr                           ; value error
    43                          
    44  ba23 7a                                 ply                                     ; sprite number
    45                          ; jsr put_io_in_map
    46  ba24 b927d0                             lda     vic+39,y                        ; assume 'color'
    47  ba27 290f                               and     #$0f                            ; range 0-15
    48                          ; inc a  ;adjust to 'keyboard' colors   [910724]
    49  ba29 e001                               cpx     #1
    50  ba2b f00e                               beq     l303_2                          ; it was color. set up for float
    51                          
    52  ba2d bd3fba                             lda     rspmod,x                        ; get index for this function
    53  ba30 aa                                 tax
    54  ba31 b96579                             lda     sbits,y                         ; get mask for this sprite number
    55  ba34 3d00d0                             and     vic,x
    56  ba37 f002                               beq     l303_2
    57  ba39 a901                               lda     #1                              ; return all non-zeros as '1'
    58                          
    59  ba3b a8                 l303_2          tay
    60  ba3c 83949e                             +lbra   sngflt                          ; go float 1 byte arg in .Y
    61                          
    62                          
    63  ba3f 15271b1d171c       rspmod          !text 21,39,27,29,23,28                 ; VIC registers associated with arg#
    64                          
    65                          ;.end
    66                          
    67                          
    68                          
    69                          ;******************************************************************
    70                          ;* RSPCOLOR - return sprite multicolor reg's
    71                          ;*
    72                          ;* Syntax : RSPCOLOR (argument)
    73                          ;*
    74                          ;* Where  : argument = [1..2]
    75                          ;*   1 : return multicolor #1
    76                          ;*   2 : return multicolor #2
    77                          ;******************************************************************
    78                          
    79                          rspcolor
    80  ba45 20554e                             jsr     chkcls                          ; check for closing paren
    81  ba48 206f5d                             jsr     conint                          ; get arg in .X
    82  ba4b ca                                 dex                                     ; adjust [1..2] to [0..1
    83  ba4c e002                               cpx     #2
    84  ba4e b3ae97                             +lbcs   fcerr                           ; value error
    85                          
    86                          ; jsr put_io_in_map
    87  ba51 bd25d0                             lda     vic+37,x
    88  ba54 290f                               and     #$0f
    89  ba56 a8                                 tay
    90                          ; iny  ;range 0-15     [910724]
    91  ba57 83799e                             +lbra   sngflt                          ; float 1 byte arg in .Y
    92                          
    93                          ;.end
    94                          
    95                          ; ********************************************************************************************
    96                          ;
    97                          ;	Date		Changes
    98                          ;	====		=======
    99                          ;
   100                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/graphics/rsppos.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      rsppos.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;******************************************************************
    16                          ;* RSPPOS - Return sprite location / speed data
    17                          ;*
    18                          ;* Syntax:  RSPPOS (sprite_number, argument)
    19                          ;*
    20                          ;* Where:   sprite_number = [0..7]
    21                          ;*    argument = [0..2]
    22                          ;*   0 : return X position
    23                          ;*   1 : return Y position
    24                          ;*   2 : return current speed
    25                          ;******************************************************************
    26                          
    27  ba5a 206f5d             rsppos          jsr     conint                          ; get first arg, sprite #, in .X
    28                          ; dex  ;adjust [1..8] to [0..7]   [910220]
    29  ba5d e008                               cpx     #8  ; (318018-03 mod            ; fab)
    30  ba5f b009                               bcs     l304_1                          ; value error
    31                          
    32  ba61 da                                 phx                                     ; save sprite number
    33                          ; jsr chkcom ;check for proper delimiter
    34                          ; jsr getbyt ;do frmevl, get 1 byte arg (arg) in .X
    35  ba62 20825d                             jsr     combyt                          ; [910820]
    36  ba65 20554e                             jsr     chkcls                          ; look for closing paren
    37  ba68 e003                               cpx     #3
    38  ba6a b39297             l304_1          +lbcs   fcerr                           ; value error
    39                          
    40  ba6d 7a                                 ply                                     ; sprite number
    41  ba6e e002                               cpx     #2
    42  ba70 d009                               bne     l304_2                          ; branch if x or y position
    43                          
    44  ba72 befeb7                             ldx     sproff,y                        ; get offset into speed data
    45  ba75 bc0512                             ldy     sprite_data,x                   ; get speed data
    46  ba78 83589e                             +lbra   sngflt                          ; go float 1 byte arg in .Y
    47                          
    48                          ; Get msb of sprite position (in case this is for x position)
    49                          
    50  ba7b 78                 l304_2          sei
    51  ba7c b96579                             lda     sbits,y                         ; get bit mask for this sprite
    52  ba7f 2d10d0                             and     vic+16                          ; ???vic_save
    53  ba82 f002                               beq     l304_3
    54  ba84 a901                               lda     #1                              ; change any non-zero to a '1'
    55  ba86 48                 l304_3          pha                                     ; save msb
    56                          
    57  ba87 98                                 tya                                     ; y = sprite# * 2
    58  ba88 0a                                 asl
    59  ba89 a8                                 tay
    60  ba8a 8a                                 txa                                     ; see if this is y position
    61  ba8b 4a                                 lsr                                     ; .C = 0 for x pos'n, 1 for y pos'n
    62  ba8c 9005                               bcc     l304_4                          ; branch if x pos'n
    63                          
    64  ba8e c8                                 iny                                     ; adjust pointer to point to y pos'n in register data
    65  ba8f 68                                 pla
    66  ba90 a900                               lda     #0                              ; ..and force 'msb' to be zero
    67  ba92 48                                 pha
    68                          
    69  ba93 b900d0             l304_4          lda     vic,y                           ; get correct location lsb   ???vic_save
    70  ba96 58                                 cli
    71  ba97 a8                                 tay
    72  ba98 68                                 pla                                     ; ..and get msb,
    73  ba99 832c9e                             +lbra   nosflt                          ; ..and go float 2 byte value in y,a
    74                          
    75                          ;.end
    76                          
    77                          ; ********************************************************************************************
    78                          ;
    79                          ;	Date		Changes
    80                          ;	====		=======
    81                          ;
    82                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: function/graphics/bump.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      bump.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          ;******************************************************************
    16                          ;* BUMP - read sprite collision
    17                          ;*
    18                          ;* Syntax : BUMP (argument)
    19                          ;*
    20                          ;* Where  : argument = [1..2]
    21                          ;*   1 : sprite/sprite collision
    22                          ;*   2 : sprite/background collision
    23                          ;******************************************************************
    24                          
    25  ba9c 20554e             bump            jsr     chkcls
    26  ba9f 206f5d                             jsr     conint                          ; get arg in .X
    27  baa2 ca                                 dex                                     ; adjust [1..2] to [0..1]
    28  baa3 e002                               cpx     #2
    29  baa5 b35797                             +lbcs   fcerr                           ; value error
    30                          
    31  baa8 78                                 sei
    32  baa9 bce602                             ldy     collisions,x                    ; get recorded collisions
    33  baac a900                               lda     #0                              ; reset them
    34  baae 9de602                             sta     collisions,x
    35  bab1 58                                 cli
    36  bab2 831e9e                             +lbra   sngflt                          ; float 1 byte arg in .Y
    37                          
    38                          ;.end
    39                          
    40                          
    41                          
    42                          ; GRAPHIC3.SRC
    43                          ;****************************************************************
    44                          ;  getang  -  set cosine & sine values
    45                          ;             results in sinval & cosval based as a fraction
    46                          ;             - over 65536
    47                          ;             angsgn = angle phase (0-3)
    48                          ;    on input vwork+y = 2 byte angle
    49                          ;***************************************************************
    50                          
    51                          getang
    52  bab5 2075bb                             jsr     settwo                          ; move angle value into y/a
    53                          
    54  bab8 a200               gtang1          ldx     #0                              ; init count of phase
    55                          
    56  baba e8                 l305_1          inx
    57  babb 38                                 sec
    58  babc e95a                               sbc     #90                             ; subtract 90 until less than 0
    59  babe b0fa                               bcs     l305_1
    60  bac0 88                                 dey
    61  bac1 10f7                               bpl     l305_1
    62  bac3 8efa11                             stx     angsgn                          ; save phase (here it is 1-4)
    63  bac6 48                                 pha
    64  bac7 695a                               adc     #90                             ; make positive
    65  bac9 20d5ba                             jsr     l305_2                          ; do division by 10
    66  bacc 68                                 pla                                     ; get 2's comp of angle
    67  bacd 18                                 clc
    68  bace 49ff                               eor     #$ff
    69  bad0 6901                               adc     #1                              ; make positive
    70  bad2 cefa11                             dec     angsgn                          ; correct phase
    71                          
    72  bad5 a2ff               l305_2          ldx     #$ff
    73  bad7 e8                 l305_3          inx                                     ; do division by 10
    74  bad8 38                                 sec
    75  bad9 e90a                               sbc     #10
    76  badb b0fa                               bcs     l305_3
    77  badd 690a                               adc     #10                             ; make positive
    78  badf 8df511                             sta     vtemp1                          ; save remainder
    79  bae2 8a                                 txa
    80  bae3 0a                                 asl                                     ; get quotient*2 as index
    81  bae4 aa                                 tax
    82  bae5 bda2bc                             lda     angval+1,x                      ; get low byte base
    83  bae8 bca1bc                             ldy     angval,x                        ; get high byte value
    84                          
    85  baeb 18                 l305_4          clc
    86  baec cef511                             dec     vtemp1
    87  baef 300c                               bmi     l305_5                          ; done - remainder = 0
    88  baf1 7db6bc                             adc     incval+1,x                      ; add low byte increment
    89  baf4 48                                 pha
    90  baf5 98                                 tya
    91  baf6 7db5bc                             adc     incval,x                        ; add high byte increment
    92  baf9 a8                                 tay
    93  bafa 68                                 pla
    94  bafb 90ee                               bcc     l305_4                          ; ...always
    95                          
    96  bafd 48                 l305_5          pha                                     ; save low byte of result
    97  bafe a200                               ldx     #0                              ; point to sinval
    98  bb00 adfa11                             lda     angsgn
    99  bb03 4a                                 lsr
   100  bb04 b002                               bcs     l305_6                          ; skip if sine value
   101  bb06 a202                               ldx     #2                              ; point to cosval
   102                          
   103  bb08 68                 l305_6          pla
   104  bb09 9dfb11                             sta     sinval,x                        ; save low byte result
   105  bb0c 98                                 tya
   106  bb0d 9dfc11                             sta     sinval+1,x                      ; save high byte result
   107  bb10 60                                 rts
   108                          
   109                          
   110                          ;*************************************************************
   111                          ;  angmlt  -  multiple 2-byte integer times angle
   112                          ;       carry set/reset = cosine/sine
   113                          ;
   114                          ;       vwork+x = 2-byte integer
   115                          ;       result left in y/a
   116                          ;*************************************************************
   117                          
   118                          angmlt
   119  bb11 a00f                               ldy     #sinval-vwork                   ; get offset to angle value
   120  bb13 9002                               bcc     l306_1                          ; get cosine/sine offset
   121  bb15 a011                               ldy     #cosval-vwork
   122                          
   123  bb17 adfa11             l306_1          lda     angsgn
   124  bb1a 6902                               adc     #2                              ; correct phase for cosine to look as sine
   125  bb1c 4a                                 lsr
   126  bb1d 4a                                 lsr
   127  bb1e 08                                 php                                     ; save if carry - means negative angle value
   128  bb1f 2075bb                             jsr     settwo                          ; get angle fraction in y/a
   129  bb22 c0ff                               cpy     #$ff                            ; test if value should be 1
   130  bb24 9007                               bcc     l306_2                          ; skip if not
   131  bb26 8a                                 txa
   132  bb27 a8                                 tay                                     ; get offset to integer
   133  bb28 2075bb                             jsr     settwo                          ; just get integer - multiplied by 1
   134  bb2b b003                               bcs     l306_3
   135                          
   136  bb2d 2094bb             l306_2          jsr     twobyt                          ; multiply integer times angle value
   137  bb30 28                 l306_3          plp                                     ; get sign of angle
   138  bb31 9051                               bcc     invert                          ; invert result if negative,do rts
   139  bb33 60                                 rts
   140                          
   141                          
   142                          ;*************************************************************
   143                          ;  angdst  -  set up values for distance * angles
   144                          ;       vwork+x = x & y distances
   145                          ;       a = angles : ang1,ang2,ang3,ang4,0,0,0,0
   146                          ;       get  xdist1 = xdist1 * angle-1
   147                          ;     ydist1 = ydist1 * angle-2
   148                          ;     xdist2 = xdist2 * angle-3
   149                          ;     ydist2 = ydist2 * angle-4
   150                          ;*************************************************************
   151                          ;
   152                          ;angdst
   153                          ; sta angcnt      ;save angles
   154                          ; ldx #xdist1-vwork
   155                          ;angd10
   156                          ; asl angcnt
   157                          ; jsr angmlt      ;multiply angle * distance
   158                          ; sta vwork,x
   159                          ; tya  ;save results
   160                          ; sta vwork+1,x
   161                          ; inx  ;point to next distance
   162                          ; inx
   163                          ; cpx #disend-vwork
   164                          ; bcc angd10 ;loop 4 times
   165                          ;angd20 rts
   166                          
   167                          ;.end
   168                          
   169                          ; GRAPHIC8.SRC
   170                          ;****************************************************************
   171                          ;  docolr  --  set up color for 8x8 charcater cell
   172                          ;   x = row number  --  y = column number
   173                          ;****************************************************************
   174                          ;
   175                          ;docolr lda _ldtb2,x      ;put address of video ram into grapnt
   176                          ; sta grapnt
   177                          ; lda graphic_ldtb1,x ;point to bit mapped color area
   178                          ; sta grapnt+1
   179                          ;
   180                          ; lda colsel  ;get current color source selected
   181                          ;
   182                          ; bne l306_1   ;branch if NOT background
   183                          ; lda fg_bg
   184                          ; bit _graphm  ;test if mode = hires
   185                          ; bpl 25$   ;if so, go set up byte
   186                          ; rts   ;else exit
   187                          ;
   188                          ;l306_1 cmp #2
   189                          ; bne l306_3   ;branch if NOT multi-color 1
   190                          ;
   191                          ;l306_2 lda fg_mc1  ;get correct packed colors for multicolor mode.
   192                          ;25$ and #$0f
   193                          ; sta z_p_temp_1
   194                          ; lda (grapnt),y
   195                          ; and #$f0
   196                          ; ora z_p_temp_1
   197                          ; sta (grapnt),y
   198                          ; rts
   199                          ;
   200                          ;l306_3 bcs 40$   ;branch if multicolor 2
   201                          ;
   202                          ; lda fg_bg  ;here for foreground. get packed colors.
   203                          ; and #$f0
   204                          ; sta z_p_temp_1
   205                          ; lda (grapnt),y  ;do foreground
   206                          ; and #$0f
   207                          ; ora z_p_temp_1
   208                          ; sta (grapnt),y
   209                          ; rts
   210                          ;
   211                          ;40$ lda grapnt+1  ;do multicolor 2
   212                          ; and #3
   213                          ; ora #>color_ram_hi ;set up to point to high color area
   214                          ; sta grapnt+1
   215                          ;
   216                          ; lda #0   ;put i/o in map
   217                          ; sta mmu_config_reg
   218                          ;
   219                          ; sei
   220                          ; lda _6510_data_reg
   221                          ; pha
   222                          ; and #%11111110  ;point cpu at correct nybble bank
   223                          ; sta _6510_data_reg
   224                          ; lda multicolor_2
   225                          ; sta (grapnt),y
   226                          ; pla
   227                          ; sta _6510_data_reg
   228                          ; cli
   229                          ; rts
   230                          ;
   231                          ;
   232                          ;
   233                          ;graphic_ldtb1   ;_ldtb1 adjusted for an org at color_ram_lo
   234                          ;99$=color_ram_lo
   235                          ;1$=color_ram_lo+40*1
   236                          ;2$=color_ram_lo+40*2
   237                          ;3$=color_ram_lo+40*3
   238                          ;4$=color_ram_lo+40*4
   239                          ;5$=color_ram_lo+40*5
   240                          ;6$=color_ram_lo+40*6
   241                          ;7$=color_ram_lo+40*7
   242                          ;8$=color_ram_lo+40*8
   243                          ;9$=color_ram_lo+40*9
   244                          ;l306_1=color_ram_lo+40*10
   245                          ;11$=color_ram_lo+40*11
   246                          ;12$=color_ram_lo+40*12
   247                          ;13$=color_ram_lo+40*13
   248                          ;14$=color_ram_lo+40*14
   249                          ;15$=color_ram_lo+40*15
   250                          ;16$=color_ram_lo+40*16
   251                          ;17$=color_ram_lo+40*17
   252                          ;18$=color_ram_lo+40*18
   253                          ;19$=color_ram_lo+40*19
   254                          ;l306_2=color_ram_lo+40*20
   255                          ;21$=color_ram_lo+40*21
   256                          ;22$=color_ram_lo+40*22
   257                          ;23$=color_ram_lo+40*23
   258                          ;24$=color_ram_lo+40*24
   259                          ;
   260                          ; .byte >99$,>1$,>2$,>3$,>4$,>5$,>6$,>7$,>8$,>9$,>l306_1
   261                          ; .byte >11$,>12$,>13$,>14$,>15$,>16$,>17$,>18$,>19$
   262                          ; .byte >l306_2,>21$,>22$,>23$,>24$
   263                          
   264                          
   265                          ;******************************************************************
   266                          ;  getpos - get address in graphic bit map into grapnt
   267                          ;      x = bit offset into byte specified (0-7)
   268                          ;      y = offset to byte within 8x8 character cell
   269                          ;      a = bit mask to the bit (or bits if multicolor mode)
   270                          ;******************************************************************
   271                          ;
   272                          ;getpos jsr divpos      ;get xpos/ypos to column/row position
   273                          ; bcs grprts      ;abort if position too large
   274                          ;
   275                          ;getps1 tya  ;get addr for row (X) and col (Y) in grapnt
   276                          ; clc
   277                          ; adc _ldtb2,x ;add column position to low byte offset
   278                          ; sta grapnt
   279                          ; lda _ldtb1,x ;get high byte screen address
   280                          ; adc #0  ;add any carry
   281                          ; asl grapnt
   282                          ; rol a
   283                          ; asl grapnt ;mult by 8 to get offset into 8k area
   284                          ; rol a
   285                          ; asl grapnt
   286                          ; rol a
   287                          ; sta grapnt+1
   288                          ;
   289                          ; lda ypos
   290                          ; and #07
   291                          ; tay  ;get byte offset into 8x8 char cell
   292                          ; lda xpos
   293                          ; bit _graphm
   294                          ; php
   295                          ; bpl grpos3 ;skip if not multicolor mode
   296                          ; asl a  ;shift x-pos for multicolor mode
   297                          ;
   298                          ;grpos3 and #07
   299                          ; tax
   300                          ; lda rbits,x ;get bit mask
   301                          ; plp
   302                          ; bpl grprts ;done if not multicolor mode
   303                          ; inx
   304                          ; ora rbits,x ;mask for 2 bits if multicolor mode
   305                          ;grprts rts
   306                          ;
   307                          ;rbits .byte   $80,$40,$20,$10,$08,$04,$02,$01
   308                          
   309                          
   310                          ;**************************************************************
   311                          ;  divpos  --  convert xpos to column number
   312                          ;  convert ypos to row number
   313                          ;  return carry set if either above limits
   314                          ;**************************************************************
   315                          ;
   316                          ;divpos lda xpos+1
   317                          ; lsr a
   318                          ; bne l306_2       ;out of bounds if greater than 1
   319                          ; lda xpos
   320                          ; ror a
   321                          ; lsr a  ;get column position = xpos/8
   322                          ; bit _graphm
   323                          ; bmi l306_1  ;skip if multicolor mode
   324                          ; lsr a  ;divide by 8 if a hires or text mode
   325                          ;l306_1 tay
   326                          ; cpy #llen
   327                          ; bcs l306_2  ;error exit if out of bounds
   328                          ; lda ypos+1
   329                          ; bne l306_2  ;out of bounds error if not = 0
   330                          ; lda ypos
   331                          ; lsr a
   332                          ; lsr a  ;get row number = ypos/8
   333                          ; lsr a
   334                          ; tax
   335                          ; cmp #nlines ;compare to max number of rows
   336                          ; rts  ;carry clr if okay
   337                          ;l306_2 sec
   338                          ; rts
   339                          
   340                          
   341                          ;***************************************************************
   342                          ;   SCALXY  - Scale the x & y coordinates found in vwork+x
   343                          ;***************************************************************
   344                          ;
   345                          ;scalxy lda scalem
   346                          ; beq sclrts      ;do nothing if scaling off
   347                          ;
   348                          ; lda scale_x
   349                          ; ldy scale_x+1
   350                          ; jsr doscal      ;scale in the x-direction
   351                          ;
   352                          ; lda scale_y
   353                          ; ldy scale_y+1 ;scale in the y direction
   354                          ;
   355                          ;doscal jsr twobyt ;multiply * coordinate
   356                          ; sta vwork,x
   357                          ; tya
   358                          ; inx  ;store back into original position
   359                          ; sta vwork,x
   360                          ; inx
   361                          ;sclrts
   362                          ; rts
   363                          
   364                          ;.end
   365                          
   366                          ;GRAPHICS9.SRC
   367                          ;***************************************************************
   368                          ;   DOTWO  - Add      two 2-byte values if carry clear
   369                          ;  Subtract two 2-byte values if carry set
   370                          ;***************************************************************
   371                          
   372                          dotwo2
   373  bb34 9007                               bcc     addtw2                          ; go do addition
   374  bb36 b014                               bcs     subtw2                          ; go do subtraction
   375                          dotwo
   376  bb38 b00f                               bcs     subtwo                          ; go do subtraction
   377                          
   378                          ;***************************************************************
   379                          ;  ADDTWO  - Add vwork+y and vwork+x  Result in y/a
   380                          ;***************************************************************
   381                          
   382                          addtwo
   383  bb3a 2075bb                             jsr     settwo                          ; put vwrok+y into y/a
   384                          
   385                          addtw2                                                  ; enter here to add y/a to vwork+x
   386  bb3d 18                                 clc
   387  bb3e 7dec11                             adc     vwork,x
   388  bb41 48                                 pha
   389  bb42 98                                 tya
   390  bb43 7ded11                             adc     vwork+1,x
   391  bb46 a8                                 tay
   392  bb47 68                                 pla
   393  bb48 60                                 rts
   394                          
   395                          
   396                          ;****************************************************************
   397                          ;  SUBTWO  - Subtract vwork+y - vwork+x Result in y/a
   398                          ;****************************************************************
   399                          
   400                          subtwo
   401  bb49 2075bb                             jsr     settwo                          ; move vwork+y into y/a
   402                          
   403                          subtw2                                                  ; enter here with 1st value in y/a
   404  bb4c 38                                 sec
   405  bb4d fdec11                             sbc     vwork,x
   406  bb50 8559                               sta     tempf1
   407  bb52 98                                 tya
   408  bb53 fded11                             sbc     vwork+1,x
   409  bb56 a8                                 tay
   410  bb57 08                                 php
   411  bb58 a559                               lda     tempf1
   412  bb5a 28                                 plp
   413  bb5b 60                                 rts
   414                          
   415                          
   416                          subtwo_savram
   417  bb5c b99111                             lda     savram,y                        ; load value into y,a
   418  bb5f 48                                 pha
   419  bb60 b99211                             lda     savram+1,y
   420  bb63 a8                                 tay
   421  bb64 68                                 pla
   422  bb65 38                                 sec
   423  bb66 fd9111                             sbc     savram,x
   424  bb69 8559                               sta     tempf1
   425  bb6b 98                                 tya
   426  bb6c fd9211                             sbc     savram+1,x
   427  bb6f a8                                 tay
   428  bb70 08                                 php
   429  bb71 a559                               lda     tempf1
   430  bb73 28                                 plp
   431  bb74 60                                 rts
   432                          
   433                          
   434                          ;************************************************************
   435                          ;  SETTWO  - Move value in vwork+y into y/a
   436                          ;************************************************************
   437                          
   438                          settwo
   439  bb75 b9ec11                             lda     vwork,y
   440  bb78 48                                 pha
   441  bb79 b9ed11                             lda     vwork+1,y
   442  bb7c a8                                 tay
   443  bb7d 68                                 pla
   444  bb7e 60                                 rts
   445                          
   446                          ;******************************************************************
   447                          ;  ABSTWO  - Get absolute value of vwork+y - vwork+x
   448                          ;  Result in y/a  -  carry === vwork+y >= vwork+x
   449                          ;******************************************************************
   450                          
   451                          abstwo                                                  ; movspr_to [910809]
   452  bb7f 2049bb                             jsr     subtwo                          ; subtract vwork+y - vwork+x
   453                          abstw2                                                  ; entrance with vwork+y in y/a
   454  bb82 100f                               bpl     absrts                          ; done if result is positive
   455  bb84 08                 invert          php
   456  bb85 18                                 clc
   457  bb86 49ff                               eor     #$ff                            ; invert low byte result and add 1
   458  bb88 6901                               adc     #1
   459  bb8a 48                                 pha
   460  bb8b 98                                 tya
   461  bb8c 49ff                               eor     #$ff                            ; invert high byte result
   462  bb8e 6900                               adc     #0                              ; add back any carry
   463  bb90 a8                                 tay
   464  bb91 68                                 pla
   465  bb92 28                                 plp
   466  bb93 60                 absrts          rts
   467                          
   468                          
   469                          ;****************************************************************
   470                          ;  TWOBYT  - Multiply 2 byte fraction in y/a times 2 bytes
   471                          ;  Integer found in vwork+x-reg.  Result = y/a
   472                          ;****************************************************************
   473                          
   474                          twobyt
   475  bb94 8cf511                             sty     vtemp1                          ; save fraction
   476  bb97 8df611                             sta     vtemp2
   477  bb9a bdec11                             lda     vwork,x
   478  bb9d bced11                             ldy     vwork+1,x
   479  bba0 08                                 php                                     ; save sign of integer
   480  bba1 2082bb                             jsr     abstw2                          ; absolute value
   481  bba4 9dec11                             sta     vwork,x
   482  bba7 98                                 tya
   483  bba8 9ded11                             sta     vwork+1,x
   484  bbab a900                               lda     #0
   485  bbad 8df711                             sta     vtemp3                          ; initialize result to zero
   486                          
   487  bbb0 a010                               ldy     #16                             ; initialize count
   488  bbb2 4ef511             l307_1          lsr     vtemp1
   489  bbb5 6ef611                             ror     vtemp2
   490  bbb8 900f                               bcc     l307_2                          ; skip if no bit set
   491  bbba 18                                 clc
   492  bbbb 7dec11                             adc     vwork,x                         ; add integer low byte
   493  bbbe 48                                 pha
   494  bbbf adf711                             lda     vtemp3
   495  bbc2 7ded11                             adc     vwork+1,x                       ; add integer high byte to total
   496  bbc5 8df711                             sta     vtemp3
   497  bbc8 68                                 pla
   498                          
   499  bbc9 4ef711             l307_2          lsr     vtemp3                          ; divide by 2
   500  bbcc 6a                                 ror
   501  bbcd 88                                 dey
   502  bbce d0e2                               bne     l307_1                          ; loop 16 times - test all bits in 2 bytes
   503                          
   504  bbd0 6900                               adc     #0                              ; add back round factor
   505  bbd2 acf711                             ldy     vtemp3
   506  bbd5 9001                               bcc     l307_3
   507  bbd7 c8                                 iny
   508  bbd8 28                 l307_3          plp                                     ; pop sign
   509  bbd9 80a7                               bra     abstw2                          ; return with signed product in y/a
   510                          
   511                          
   512                          ;******************************************************************
   513                          ;  dstpos  -  move xdest/ydest to xpos/ypos
   514                          ;******************************************************************
   515                          ;
   516                          ;dstpos
   517                          ; ldy #0
   518                          ; jsr dstmov
   519                          ; ldy #2
   520                          ;dstmov
   521                          ; lda xdest,y
   522                          ; sta xpos,y
   523                          ; lda xdest+1,y
   524                          ; sta xpos+1,y
   525                          ; rts
   526                          
   527                          ;.end
   528                          
   529                          ;GRAPHICS10.SRC
   530                          ;************************************************************
   531                          ;   incolr  --  get color selection parameter into colsel
   532                          ;************************************************************
   533                          ;
   534                          ;incolr
   535                          ; ldx #1   ;get an optional 1 byte val, def=fg(1)
   536                          ; jsr chrgot
   537                          ;incol1
   538                          ; beq incol2       ;eol, use default
   539                          ; cmp #','
   540                          ; beq incol2       ;just ',', use default
   541                          ; jsr getbyt
   542                          ; cpx #4   ;must be 0-3
   543                          ; bcs illval       ;..else illegal value
   544                          ; cpx #2
   545                          ; bit _graphm       ;if hires, must be 0 or 1
   546                          ; bmi incol2
   547                          ; bcs illval
   548                          ;incol2
   549                          ; stx colsel
   550                          ; rts
   551                          ;
   552                          ;illval
   553                          ; jmp fcerr  ;illegal value
   554                          
   555                          
   556                          
   557                          ;******************************************************************
   558                          ;  INCORD  ---  Get X,Y coordinate from input stream into vwork+x
   559                          ;
   560                          ;  Coordinate may have any of the forms:
   561                          ;    x,y  = absolute xpos & absolute ypos
   562                          ; +/-x,y  = relative xpos & absolute ypos
   563                          ;    x,+/-y = absolute xpos & relative ypos
   564                          ; +/-x,+/-y = relative xpos & relative ypos
   565                          ;    x;y  = x-distance at an angle y
   566                          ;
   567                          ;  Relative and angle distances are relative to current x,ypos.
   568                          ;  Values are scaled to current mode parameters if required.
   569                          ;******************************************************************
   570                          
   571                          
   572                          incor2                                                  ; enter here for optional argument
   573  bbdb 208522                             jsr     chrgot                          ; end of line?
   574  bbde f007                               beq     l308_1                          ; yes, use defaults
   575  bbe0 205b4e                             jsr     chkcom
   576  bbe3 c92c                               cmp     #','                            ; is there really an arg?
   577  bbe5 d00f                               bne     incord                          ; yes, let'er rip
   578                          
   579  bbe7 a000               l308_1          ldy     #0                              ; set default pos = current pos
   580  bbe9 b9ec11             l308_2          lda     xpos,y
   581  bbec 9dec11                             sta     vwork,x
   582  bbef e8                                 inx
   583  bbf0 c8                                 iny
   584  bbf1 c004                               cpy     #4
   585  bbf3 90f4                               bcc     l308_2
   586  bbf5 60                                 rts
   587                          
   588                          
   589                          ;incor3    ;enter here for non-optional arg preceded by a comma
   590                          ; jsr chkcom
   591                          incord
   592  bbf6 8ef811                             stx     vtemp4                          ; save offset to destination
   593  bbf9 2081bc                             jsr     cordsb                          ; get 2-byte x-parameter
   594  bbfc 208522                             jsr     chrgot
   595  bbff c92c                               cmp     #','
   596  bc01 f051                               beq     docord                          ; skip ahead if have comma
   597                          
   598  bc03 c93b                               cmp     #';'                            ; check for semi-colon
   599  bc05 d34372                             +lbne   snerr                           ; missing angle param- show syntax message
   600  bc08 208322                             jsr     chrget       ;skip over '       ; '
   601  bc0b 208a5d                             jsr     getwrd                          ; get 2-byte angle in a,y
   602  bc0e 8576                               sta     z_p_temp_1                      ; swap a,y
   603  bc10 98                                 tya
   604  bc11 a476                               ldy     z_p_temp_1
   605  bc13 20b8ba                             jsr     gtang1                          ; get sine & cosine values for the angle
   606  bc16 aef811                             ldx     vtemp4
   607  bc19 bdec11                             lda     vwork,x
   608  bc1c 9dee11                             sta     vwork+2,x                       ; move length to y-parameter
   609  bc1f bded11                             lda     vwork+1,x
   610  bc22 9def11                             sta     vwork+3,x
   611                          ; jsr scalxy       ;scale the values
   612  bc25 a90e                               lda     #$0e
   613  bc27 8df911                             sta     vtemp5
   614  bc2a 18                                 clc
   615  bc2b aef811                             ldx     vtemp4
   616                          
   617  bc2e 2011bb             l309_1          jsr     angmlt                          ; multiply length * angle
   618  bc31 9dec11                             sta     vwork,x                         ; save angle result
   619  bc34 98                                 tya
   620  bc35 9ded11                             sta     vwork+1,x
   621  bc38 a000                               ldy     #xpos-vwork
   622  bc3a 4ef911                             lsr     vtemp5
   623  bc3d 9002                               bcc     l309_2
   624  bc3f a002                               ldy     #ypos-vwork
   625                          
   626  bc41 2038bb             l309_2          jsr     dotwo                           ; add/subtract value to current position
   627  bc44 9dec11                             sta     vwork,x
   628  bc47 98                                 tya                                     ; save result in destination
   629  bc48 9ded11                             sta     vwork+1,x
   630  bc4b e8                                 inx
   631  bc4c e8                                 inx
   632  bc4d 4ef911                             lsr     vtemp5
   633  bc50 d0dc                               bne     l309_1                          ; do y-coordinate
   634  bc52 18                                 clc
   635  bc53 60                                 rts
   636                          
   637                          
   638  bc54 208322             docord          jsr     chrget                          ; skip over comma
   639  bc57 eef811                             inc     vtemp4                          ; point to y-destination
   640  bc5a eef811                             inc     vtemp4
   641  bc5d 2081bc                             jsr     cordsb                          ; get y-paramter
   642                          ; ldx vtemp4
   643                          ; dex
   644                          ; dex
   645                          ; jsr scalxy       ;scale the values
   646  bc60 a002                               ldy     #ypos-vwork
   647  bc62 aef811                             ldx     vtemp4
   648  bc65 e8                                 inx
   649  bc66 e8                                 inx
   650                          
   651  bc67 ca                 docor1          dex
   652  bc68 ca                                 dex
   653  bc69 4ef911                             lsr     vtemp5
   654  bc6c 900a                               bcc     docor2                          ; skip if not relative
   655  bc6e 203abb                             jsr     addtwo                          ; add to current position
   656  bc71 9dec11                             sta     vwork,x
   657  bc74 98                                 tya
   658  bc75 9ded11                             sta     vwork+1,x
   659                          
   660  bc78 a000               docor2          ldy     #xpos-vwork
   661  bc7a ecf811                             cpx     vtemp4
   662  bc7d f0e8                               beq     docor1                          ; loop to do x-coordinate
   663  bc7f 18                                 clc
   664  bc80 60                                 rts
   665                          
   666                          ;
   667                          ; CORDSB -- Get the next 2-byte parameter
   668                          ;
   669                          
   670  bc81 208522             cordsb          jsr     chrgot                          ; read character
   671  bc84 c9aa                               cmp     #plus_token                     ; check if relative - plus sign
   672  bc86 f005                               beq     l310_1                          ; skip if yes
   673  bc88 c9ab                               cmp     #minus_token
   674  bc8a f001                               beq     l310_1                          ; skip if relative - minus sign
   675  bc8c 18                                 clc                                     ; .c=1 if relative coord, .c=0 if absolute
   676  bc8d 2ef911             l310_1          rol     vtemp5                          ; save coord type for later
   677  bc90 20d84c                             jsr     frmnum
   678  bc93 20925d                             jsr     getsad                          ; get signed 2 byte coordinate (y,a), do rts
   679  bc96 aef811                             ldx     vtemp4
   680  bc99 9ded11                             sta     vwork+1,x                       ; save 2-byte parameter
   681  bc9c 98                                 tya
   682  bc9d 9dec11                             sta     vwork,x
   683  bca0 60                                 rts
   684                          
   685                          ;.end
   686                          
   687                          ;GRAPHICS11.SRC
   688                          
   689                          ;  ANGVAL  -- Table of angle values on 10 degree boundaries
   690                          ;  Values based as fraction of 65536
   691                          
   692                          angval
   693  bca1 0000                               !text $00,$00                           ; sine 00 degrees -  .0000
   694  bca3 2c71                               !text $2c,$71                           ; sine 10 degrees -  .1736
   695  bca5 578d                               !text $57,$8d                           ; sine 20 degrees -  .3420
   696  bca7 8000                               !text $80,$00                           ; sine 30 degrees -  .5000
   697  bca9 a48f                               !text $a4,$8f                           ; sine 40 degrees -  .6428
   698  bcab c419                               !text $c4,$19                           ; sine 50 degrees -  .7660
   699  bcad ddb2                               !text $dd,$b2                           ; sine 60 degrees -  .8660
   700  bcaf f090                               !text $f0,$90                           ; sine 70 degrees -  .9397
   701  bcb1 fc1c                               !text $fc,$1c                           ; sine 80 degrees -  .9848
   702  bcb3 ffff                               !text $ff,$ff                           ; sine 90 degrees - 1.0000
   703                          
   704                          ;  INCVAL  -- Table of incremental values between 10 degrees
   705                          ;  Values based on fraction of 65536
   706                          
   707                          incval
   708  bcb5 0472                               !text $04,$72                           ; 01 - 09 degrees -  .01739
   709  bcb7 0450                               !text $04,$50                           ; 11 - 19 degrees -  .01692
   710  bcb9 040b                               !text $04,$0b                           ; 21 - 29 degrees -  .01592
   711  bcbb 03a8                               !text $03,$a8                           ; 31 - 39 degrees -  .01443
   712  bcbd 0328                               !text $03,$28                           ; 41 - 49 degrees -  .01252
   713  bcbf 0290                               !text $02,$90                           ; 51 - 59 degrees -  .01023
   714  bcc1 01e3                               !text $01,$e3                           ; 61 - 69 degrees -  .00762
   715  bcc3 0128                               !text $01,$28                           ; 71 - 79 degrees -  .00477
   716  bcc5 0063                               !text $00,$63                           ; 81 - 89 degrees -  .00179
   717                          
   718                          ;.end
   719                          
   720                          
   721                          ; ********************************************************************************************
   722                          ;
   723                          ;	Date		Changes
   724                          ;	====		=======
   725                          ;
   726                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: edit/mode.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      mode.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          ; Edit mode is simply a poor man's word processor.  Text is entered normally
    15                          ; as if the user were typing in a program, but tokenization is turned off.
    16                          ; This affects only that text which follows a line number.  CRUNCH and QPLOP
    17                          ; test for this mode, and deal with the text accordingly.  RUN, GOTO, etc.
    18                          ; test for this mode and error-out if it's enabled.  LOADing a text file
    19                          ; will automatically add line numbers, SAVEing a text file will remove them.
    20                          ;
    21                          ; Syntax:  EDIT < ON | OFF >
    22                          ;
    23                          ; F. Bowen        [910620]
    24                          
    25  bcc7 20ed58             edit            jsr     errind                          ; direct mode only command
    26  bcca c991                               cmp     #on_token
    27  bccc d004                               bne     l311_1
    28  bcce a910                               lda     #%00010000                      ; EDIT ON
    29  bcd0 800a                               bra     l311_3                          ; (this kills trace mode, too)
    30                          
    31  bcd2 2016b5             l311_1          jsr     chkesc                          ; [910930]
    32                          ; cmp #esc_command_token
    33                          ; bne l311_2
    34                          ; jsr chrget
    35  bcd5 c924                               cmp     #off_token
    36  bcd7 d37171             l311_2          +lbne   snerr
    37  bcda a900                               lda     #0                              ; EDIT OFF
    38  bcdc 857e               l311_3          sta     runmod
    39  bcde 4c8322                             jmp     chrget                          ; exit
    40                          
    41                          
    42                          edit_crunch                                             ; Edit mode only, find end of plain text in input buffer
    43  bce1 fc3d00                             phw     txtptr                          ; save current position in input buffer
    44  bce4 205635                             jsr     rem                             ; find the end of the line
    45  bce7 a63d                               ldx     txtptr
    46  bce9 68                                 pla                                     ; restore buffer pointer
    47  bcea 853e                               sta     txtptr+1
    48  bcec 68                                 pla
    49  bced 853d                               sta     txtptr
    50  bcef 38                                 sec                                     ; compute length of line
    51  bcf0 8a                                 txa
    52  bcf1 e53d                               sbc     txtptr
    53  bcf3 a8                                 tay
    54  bcf4 c8                                 iny
    55  bcf5 60                                 rts                                     ; done
    56                          
    57                          
    58                          edit_p1line                                             ; Edit mode only, list a line of plain text
    59  bcf6 207f64                             jsr     linprt                          ; print line number in (a,x)
    60  bcf9 a920                               lda     #' '                            ; print a space
    61                          
    62  bcfb a003                               ldy     #3                              ; start printing at text following line number
    63  bcfd 203d68             l312_1          jsr     outch                           ; print character
    64  bd00 c8                                 iny
    65  bd01 5f5503                             bbr5    helper,l312_2                   ; if called from FIND/CHANGE check for highlighting
    66  bd04 20963c                             jsr     helpsb
    67  bd07 20ad22             l312_2          jsr     indlow                          ; get next character
    68  bd0a d0f1                               bne     l312_1                          ; loop until eol
    69  bd0c 60                                 rts                                     ; done
    70                          
    71                          
    72                          ;.end
    73                          
    74                          ; EDIT LOAD/SAVE  Load or Save a plain text SEQ file in memory
    75                          
    76                          edit_load                                               ; Called by DLOAD/DVERIFY when in EDIT mode
    77  bd0d a301                               ldz     #1
    78  bd0f 20196f                             jsr     open_SEQ_file                   ; Open the file just like TYPE: filename [,U#] [,D#]
    79  bd12 200e78                             jsr     Check_DS                        ; check current disk error message
    80  bd15 a000                               ldy     #0
    81  bd17 a97a                               lda     #dsdesc+1
    82  bd19 20d722                             jsr     lda_far_ram1                    ; lda (dsdesc+1),y peek at first character
    83  bd1c c932                               cmp     #'2'
    84  bd1e b3bb00                             +lbcs   l313_12                         ; exit if error
    85  bd21 208278                             jsr     Clear_DS                        ; else zap 'ok' message so user gets fresh one
    86  bd24 ae8111                             ldx     dosla
    87  bd27 20c6ff                             jsr     _chkin                          ; get input channel
    88  bd2a b3af00                             +lbcs   l313_12                         ; error
    89                          
    90  bd2d 8f0c0e                             bbs0    verck,l313_1
    91  bd30 207dff                             jsr     _primm
    92  bd33 0d4c4f4144494e47...                !text cr,"LOADING",0
    93  bd3c 800e                               bra     l313_2
    94  bd3e 207dff             l313_1          jsr     _primm
    95  bd41 0d56455249465949...                !text cr,"VERIFYING",0
    96                          
    97  bd4c a9e8               l313_2          lda     #<1000                          ; default starting line #
    98  bd4e a203                               ldx     #>1000
    99  bd50 8516                               sta     linnum
   100  bd52 8617                               stx     linnum+1
   101                          
   102  bd54 a52d                               lda     txttab                          ; load address
   103  bd56 a62e                               ldx     txttab+1
   104  bd58 8524                               sta     index
   105  bd5a 8625                               stx     index+1
   106                          
   107  bd5c a000               l313_3          ldy     #0                              ; Input one line of text
   108  bd5e 20e1ff                             jsr     _stop                           ; check stop key
   109  bd61 f072                               beq     l313_11                         ; exit if down
   110  bd63 20b7ff                             jsr     _readst                         ; check channel status
   111  bd66 d06d                               bne     l313_11                         ; exit if eof or error
   112                          
   113  bd68 0f0c04                             bbr0    verck,l313_4
   114  bd6b a003                               ldy     #3
   115  bd6d 8020                               bra     l313_5                          ; skip ahead if verify op
   116                          
   117  bd6f a901               l313_4          lda     #1                              ; install fake line links for this line
   118  bd71 200623                             jsr     sta_far_in1
   119  bd74 c8                                 iny                                     ; 1
   120  bd75 200623                             jsr     sta_far_in1
   121  bd78 c8                                 iny                                     ; 2
   122  bd79 a516                               lda     linnum                          ; install line number for this line
   123  bd7b 200623                             jsr     sta_far_in1
   124  bd7e c8                                 iny                                     ; 3
   125  bd7f a517                               lda     linnum+1
   126  bd81 200623                             jsr     sta_far_in1
   127  bd84 18                                 clc
   128  bd85 a516                               lda     linnum                          ; generate next line number
   129  bd87 690a                               adc     #10
   130  bd89 8516                               sta     linnum
   131  bd8b 9002                               bcc     l313_5
   132  bd8d e617                               inc     linnum+1
   133                          
   134                          
   135  bd8f c8                 l313_5          iny                                     ; bump buffer pointer
   136  bd90 c0a1                               cpy     #buflen                         ; check buffer (160 max. input buffer size to edit)
   137  bd92 f01e                               beq     l313_8                          ; split long lines into two????
   138  bd94 20cfff                             jsr     _basin                          ; read file data
   139  bd97 f019                               beq     l313_8                          ; CR or null terminates line
   140  bd99 c90d                               cmp     #cr
   141  bd9b f015                               beq     l313_8
   142                          ; cmp #$20  ;adjust invisible characters less than space
   143                          ; bcc l313_6   ; ????make them appear in reverse field, but note
   144                          ; ora #$80  ; that these lines can't be edited without losing them.
   145                          
   146  bd9d 0f0c0d             l313_6          bbr0    verck,l313_7
   147  bda0 201723                             jsr     indcmp_in1                      ; Compare to memory
   148  bda3 f0ea                               beq     l313_5                          ; ok
   149  bda5 202033                             jsr     list_exit
   150  bda8 a21c                               ldx     #ervfy                          ; verify error
   151  bdaa 83a370                             +lbra   error
   152                          
   153  bdad 200623             l313_7          jsr     sta_far_in1                     ; Load into memory
   154  bdb0 80dd                               bra     l313_5                          ; loop until eol or error (kernel returns CR in case of error)
   155                          
   156  bdb2 8f0c05             l313_8          bbs0    verck,l313_9
   157  bdb5 a900                               lda     #0
   158  bdb7 200623                             jsr     sta_far_in1                     ; terminate line with null (replaces CR)
   159  bdba c8                 l313_9          iny
   160  bdbb 98                                 tya
   161  bdbc 18                                 clc
   162  bdbd 6524                               adc     index
   163  bdbf 8524                               sta     index
   164  bdc1 9002                               bcc     l313_10
   165  bdc3 e625                               inc     index+1
   166  bdc5 a525               l313_10         lda     index+1
   167  bdc7 cdd002                             cmp     max_mem_0+1                     ; out of memory????
   168  bdca 9090                               bcc     l313_3                          ; no, continue until eof
   169  bdcc 631000                             bsr     edit_load_done                  ; yes, patch things up best we can
   170  bdcf 202033                             jsr     list_exit                       ; close disk
   171  bdd2 836d70                             +lbra   omerr                           ; report error & exit
   172                          
   173  bdd5 8f0c03             l313_11         bbs0    verck,l313_12
   174  bdd8 20debd                             jsr     edit_load_done                  ; EOF: terminate memory with a pair of nulls
   175  bddb 834375             l313_12         +lbra   list_exit                       ; release channel, close file, etc.
   176                          
   177                          ; bbr0 verck,40$
   178                          ; jsr verify_ok  ;if Verify, report 'ok'
   179                          ;40$ lda #0   ;exit directly to main????
   180                          ; bra end
   181                          
   182                          edit_load_done
   183  bdde a900                               lda     #0                              ; EOF: terminate memory with a pair of nulls
   184  bde0 a8                                 tay
   185  bde1 200623                             jsr     sta_far_in1
   186  bde4 c8                                 iny
   187  bde5 200623                             jsr     sta_far_in1
   188  bde8 e324                               inw     index
   189  bdea e324                               inw     index
   190  bdec a624                               ldx     index                           ; set top
   191  bdee a425                               ldy     index+1
   192  bdf0 8682                               stx     text_top
   193  bdf2 8483                               sty     text_top+1
   194  bdf4 83c372                             +lbra   link_program                    ; relink & RTS
   195                          
   196                          
   197                          edit_save
   198  bdf7 a9e6                               lda     #$e6                            ; parse:  filename [,U#] [,D#]
   199  bdf9 202074                             jsr     dosprs                          ; (like dopen:      0 0 0 *  * 0 0 1 )
   200  bdfc 20dc77                             jsr     chk1                            ; check parameters
   201  bdff 201d71                             jsr     find_la                         ; find an available LA
   202  be02 200d71                             jsr     find_sa                         ; find an available SA
   203  be05 a017                               ldy     #fsavseq
   204  be07 a208                               ldx     #8
   205  be09 20fd70                             jsr     open_file                       ; open the file
   206  be0c b31975                             +lbcs   list_err                        ; exit if error
   207  be0f ae8111                             ldx     dosla
   208  be12 20c9ff                             jsr     _chkout                         ; get output channel
   209  be15 b03b                               bcs     l314_5                          ; error
   210                          
   211  be17 a52d                               lda     txttab                          ; save address
   212  be19 a62e                               ldx     txttab+1
   213  be1b 8524                               sta     index
   214  be1d 8625                               stx     index+1
   215                          
   216  be1f 20e1ff             l314_1          jsr     _stop                           ; check stop key
   217  be22 f02e                               beq     l314_5                          ; exit if down
   218  be24 20b7ff                             jsr     _readst                         ; check channel status
   219  be27 d029                               bne     l314_5                          ; exit if eof or error????
   220                          
   221  be29 a003                               ldy     #3                              ; save a line, starting past links & line#
   222  be2b c8                 l314_2          iny                                     ; bump buffer pointer
   223                          ; cpy #buflen  ;check buffer (160 max. input buffer size to edit)
   224                          ; beq ??$   ; split long lines into two????
   225  be2c 20c122                             jsr     indin1
   226  be2f aa                                 tax                                     ; save character for eol check
   227  be30 d002                               bne     l314_3
   228  be32 a90d                               lda     #cr                             ; eol: substitute CR ???? allow some other terminator
   229  be34 20d2ff             l314_3          jsr     _bsout                          ; write file data
   230  be37 8a                                 txa
   231  be38 d0f1                               bne     l314_2                          ; loop until eol
   232                          
   233  be3a c8                                 iny                                     ; advance text index to start of next line
   234  be3b 98                                 tya
   235  be3c 18                                 clc
   236  be3d 6524                               adc     index
   237  be3f 8524                               sta     index
   238  be41 9002                               bcc     l314_4
   239  be43 e625                               inc     index+1
   240                          
   241  be45 a000               l314_4          ldy     #0                              ; check for EOF: a pair of null links
   242  be47 20c122                             jsr     indin1
   243  be4a d0d3                               bne     l314_1
   244  be4c c8                                 iny
   245  be4d 20c122                             jsr     indin1
   246  be50 d0cd                               bne     l314_1                          ; loop until end of text
   247                          
   248  be52 83cc74             l314_5          +lbra   list_exit                       ; release channel, close file, exit
   249                          
   250                          ;.end
   251                          
   252                          
   253                          Sound_CLR
   254  be55 2022b5                             jsr     chkeos                          ; eat CLR token, check eos   [910717] new
   255                          Sound_CLR_1
   256  be58 08                                 php
   257  be59 78                                 sei
   258                          ; jsr go_slow  ;      [910716] 4567R7A
   259  be5a a900                               lda     #0
   260  be5c a217                               ldx     #24-1
   261  be5e 9d00d4             l315_1          sta     sid1,x                          ; initialize SID chips
   262  be61 9d20d4                             sta     sid2,x
   263  be64 ca                                 dex
   264  be65 10f7                               bpl     l315_1
   265                          
   266  be67 8d7a12                             sta     filters1+2                      ; set filters off
   267  be6a 8d7e12                             sta     filters2+2
   268                          
   269  be6d a908                               lda     #8                              ; set default volume
   270  be6f 8d7b12                             sta     filters1+3
   271  be72 8d7f12                             sta     filters2+3                      ; [910612]
   272                          ; sta filters+4  ;why?      [910612]
   273  be75 8d18d4                             sta     sid1+24
   274  be78 8d38d4                             sta     sid2+24
   275                          
   276                          ; jsr go_fast  ;      [910716] 4567R7A
   277                          
   278  be7b 2c0311                             bit     _pal_ntsc                       ; determine if PAL or NTSC system  [910724]
   279  be7e 3006                               bmi     l315_2                          ; ...branch if PAL
   280  be80 a928                               lda     #(<beats_ntsc)/4                ; set beat to quarter note (4/4 time = .5 sec)
   281  be82 a001                               ldy     #>beats_ntsc/4
   282  be84 8004                               bra     l315_3
   283  be86 a92c               l315_2          lda     #<beats_pal/4
   284  be88 a001                               ldy     #>beats_pal/4
   285  be8a 8d7612             l315_3          sta     ntime
   286  be8d 8c7712                             sty     ntime+1
   287                          
   288  be90 a904                               lda     #4                              ; set default octave
   289  be92 8d7012                             sta     octave
   290  be95 a90c                               lda     #12                             ; set default tempo    [910220]
   291  be97 8d7312                             sta     tempo_rate                      ; 12 makes whole note in 4/4 time last 2 seconds
   292                          
   293  be9a a01d                               ldy     #30-1                           ; initialize music tables
   294  be9c b9d849             l315_4          lda     atkmus,y
   295  be9f 998912                             sta     atktab,y
   296  bea2 88                                 dey
   297  bea3 10f7                               bpl     l315_4
   298                          
   299  bea5 a209                               ldx     #10-1                           ; initialize pulse widths
   300  bea7 bdf649             l315_5          lda     pwhmus,x
   301  beaa 9db112                             sta     pulshi,x
   302  bead ca                                 dex
   303  beae 10f7                               bpl     l315_5
   304                          
   305  beb0 8a                                 txa                                     ; $ff
   306  beb1 a205                               ldx     #6-1                            ; stereo SIDs   (save space) [911119]
   307  beb3 a001                               ldy     #1
   308  beb5 9dc412             l315_6          sta     sound_time_hi,x                 ; turn all SOUND counters off
   309  beb8 995d12                             sta     voices,y                        ; turn all PLAY counters off
   310  bebb c8                                 iny
   311  bebc c8                                 iny
   312  bebd ca                                 dex
   313  bebe 10f5                               bpl     l315_6
   314                          
   315  bec0 a005                               ldy     #6-1                            ; set default envelope (piano) for all voices (6)
   316  bec2 8c6f12                             sty     voice
   317  bec5 a200               l315_7          ldx     #0
   318  bec7 200748                             jsr     set_envelope_1
   319  beca ce6f12                             dec     voice
   320  becd 10f6                               bpl     l315_7
   321  becf ee6f12                             inc     voice                           ; set default voice (0)
   322                          
   323  bed2 28                                 plp
   324  bed3 60                                 rts
   325                          
   326                          
   327                          ; ********************************************************************************************
   328                          ;
   329                          ;	Date		Changes
   330                          ;	====		=======
   331                          ;
   332                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: initialise/sprites.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      sprites.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          Sprite_CLR
    14  bed4 2022b5                             jsr     chkeos                          ; eat CLR token, check eos   [910717] new
    15                          Sprite_CLR_1
    16  bed7 08                                 php
    17  bed8 78                                 sei
    18  bed9 a900                               lda     #0
    19  bedb 8d15d0                             sta     vic+21                          ; Turn off all sprites
    20  bede 8d17d0                             sta     vic+23                          ; Unexpand them     [910828]
    21  bee1 8d1bd0                             sta     vic+27                          ; Sprite priority
    22  bee4 8d1cd0                             sta     vic+28                          ; Hires sprites
    23  bee7 8d1dd0                             sta     vic+29
    24                          
    25  beea a257                               ldx     #init_as_0                      ; Init sprite tables
    26  beec 9d0512             l316_1          sta     sprite_data,x
    27  beef ca                                 dex
    28  bef0 10fa                               bpl     l316_1
    29                          
    30  bef2 a91f                               lda     #sprite_base/64+7               ; Set up sprite pointers
    31  bef4 a007                               ldy     #7
    32  bef6 7fd705             l316_2          bbr7    _mode,l316_3
    33  bef9 99f80b                             sta     sprite_ptrs_40,y                ; 40 col screen
    34  befc 8003                               bra     l316_4
    35  befe 99f80f             l316_3          sta     sprite_ptrs_80,y                ; 80 col screen
    36  bf01 3a                 l316_4          dec
    37  bf02 88                                 dey
    38  bf03 10f1                               bpl     l316_2
    39                          
    40  bf05 28                                 plp
    41                          ; rts
    42                          
    43                          ;.end
    44                          
    45                          ; ********************************************************************************************
    46                          ;
    47                          ;	Date		Changes
    48                          ;	====		=======
    49                          ;
    50                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: handler/nmi.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      nmi.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                          basic_nmi                                               ; removed [910826]
    16                          ; lda nmi_wrap_flag ;filter out wrapped NMI calls   [910523] audio
    17                          ; beq 1$   ; it's ok
    18                          ; rts   ; exit- we're already handling one interrupt
    19                          ;
    20                          ;1$ inc nmi_wrap_flag ;shut the door to NMI
    21                          ;
    22                          ;basic_nmi_end
    23                          ; dec nmi_wrap_flag ;open the door to NMI
    24  bf06 60                                 rts
    25                          
    26                          
    27                          
    28                          
    29                          ;.end
    30                          
    31                          ; ********************************************************************************************
    32                          ;
    33                          ;	Date		Changes
    34                          ;	====		=======
    35                          ;
    36                          ; ********************************************************************************************

; ******** Source: basic.asm

; ******** Source: system/jumptable.asm
     1                          ; ********************************************************************************************
     2                          ; ********************************************************************************************
     3                          ;
     4                          ;	Name :      jumptable.asm
     5                          ;	Purpose :   ..
     6                          ;	Created :   15th Nov 1991
     7                          ;	Updated :   4th Jan 2021
     8                          ;	Authors :   Fred Bowen
     9                          ;
    10                          ; ********************************************************************************************
    11                          ; ********************************************************************************************
    12                          
    13                          
    14                          
    15                                          * = $7f00
    16                          
    17                          
    18                          ; Format Conversions     [6]
    19                          
    20  7f00 83b2d9                             +lbra   ayint                           ; convert floating point to integer
    21  7f03 833acf                             +lbra   givayf                          ; convert integer to floating point
    22  7f06 8387e5                             +lbra   fout                            ; convert floating point to PETSCII string
    23  7f09 8341d6                             +lbra   val_1                           ; convert PETSCII string to floating point
    24  7f0c 837fde                             +lbra   getadr                          ; convert floating point to an address
    25  7f0f 83cee3                             +lbra   floatc                          ; convert address to floating point
    26                          
    27                          ; Math Functions     [24]
    28                          
    29  7f12 8391de                             +lbra   fsub                            ; MEM - FACC
    30  7f15 8391de                             +lbra   fsubt                           ; ARG - FACC
    31  7f18 83a1de                             +lbra   fadd                            ; MEM + FACC
    32  7f1b 83ffe4                             +lbra   faddt_c65                       ; ARG - FACC      [910402]
    33  7f1e 834de1                             +lbra   fmult                           ; MEM * FACC
    34  7f21 8340e1                             +lbra   fmultt_c65                      ; ARG * FACC      [910402]
    35  7f24 835ce2                             +lbra   fdiv                            ; MEM / FACC
    36  7f27 834fe2                             +lbra   fdivt_c65                       ; ARG / FACC      [910402]
    37  7f2a 83e2e0                             +lbra   log                             ; compute natural log of FACC
    38  7f2d 8334e4                             +lbra   int                             ; perform BASIC INT() on FACC
    39  7f30 838ae6                             +lbra   sqr                             ; compute square root of FACC
    40  7f33 83c7e6                             +lbra   negop                           ; negate FACC
    41  7f36 838be6                             +lbra   fpwr                            ; raise ARG to the MEM power
    42  7f39 838be6                             +lbra   fpwrt                           ; raise ARG to the FACC power
    43  7f3c 83c9e6                             +lbra   exp                             ; compute EXP of FACC
    44  7f3f 835de7                             +lbra   cos                             ; compute COS of FACC
    45  7f42 8361e7                             +lbra   sin                             ; compute SIN of FACC
    46  7f45 83a7e7                             +lbra   tan                             ; compute TAN of FACC
    47  7f48 83d5e7                             +lbra   atn                             ; compute ATN of FACC
    48  7f4b 8365e3                             +lbra   round                           ; round FACC
    49  7f4e 839ee3                             +lbra   abs                             ; absolute value of FACC
    50  7f51 836ee3                             +lbra   sign                            ; test sign of FACC
    51  7f54 839be3                             +lbra   fcomp                           ; compare FACC with MEM
    52  7f57 83cdd8                             +lbra   rnd_0                           ; generate random floating point number
    53                          
    54                          ; Movement      [22]
    55                          
    56  7f5a 839be1                             +lbra   conupk                          ; move RAM MEM to ARG
    57  7f5d 836de1                             +lbra   romupk                          ; move ROM MEM to ARG
    58  7f60 83f0cf                             +lbra   movfrm                          ; move RAM MEM to FACC
    59  7f63 83a9e2                             +lbra   movfm                           ; move ROM MEM to FACC
    60  7f66 83d2e2                             +lbra   movmf                           ; move FACC to MEM
    61  7f69 8328e3                             +lbra   movfa                           ; move ARG to FACC
    62  7f6c 8335e3                             +lbra   movaf                           ; move FACC to ARG
    63                          
    64                          ; bra optab ;????not executable
    65                          ; bra drawln
    66                          ; bra gplot
    67                          ; bra cirsub
    68  7f6f 8343be                             +lbra   run
    69  7f72 832db5                             +lbra   runc
    70  7f75 8354b5                             +lbra   clearc                          ; [910410]
    71  7f78 83dbb4                             +lbra   new
    72  7f7b 833cb1                             +lbra   link_program
    73  7f7e 839fa3                             +lbra   crunch
    74  7f81 8377b2                             +lbra   FindLine
    75  7f84 8387ac                             +lbra   newstt
    76  7f87 8359ce                             +lbra   eval
    77  7f8a 8363cd                             +lbra   frmevl
    78  7f8d 8334be                             +lbra   run_a_program
    79  7f90 8309be                             +lbra   setexc
    80  7f93 8399b2                             +lbra   linget
    81  7f96 839bdc                             +lbra   garba2
    82  7f99 8376af                             +lbra   execute_a_line
    83                          
    84                          ; Temporaries for C65 development (???? used by graphics) [12]
    85                          
    86  7f9c 83e5a2                             +lbra   chrget
    87  7f9f 83e4a2                             +lbra   chrgot
    88  7fa2 83b7ce                             +lbra   chkcom
    89  7fa5 8331cd                             +lbra   frmnum
    90  7fa8 83e3dd                             +lbra   getadr
    91  7fab 83cfdd                             +lbra   getnum
    92  7fae 83bcdd                             +lbra   getbyt
    93  7fb1 8372e9                             +lbra   plsv
    94                          
    95  7fb4 8311a3                             +lbra   lda_far_ram0                    ; lda (.x),y from BASIC text bank [910716]
    96  7fb7 831ea3                             +lbra   lda_far_ram1                    ; lda (.x),y from BASIC variable bank [910716]
    97  7fba 8350a3                             +lbra   sta_far_ram0                    ; sta (.x),y to   BASIC text bank [910716]
    98  7fbd 8331a3                             +lbra   sta_far_ram1                    ; sta (.x),y to   BASIC variable bank [910716]
    99                          
   100                          
   101                          ; Graphic Kernel Call. (Temporary for C65 development ????)
   102                          ;
   103                          ;  syntax:  GRAPHIC command# [,args]
   104                          ;
   105                          ; Basically this is a modified C64-type SYS command, minus the address.
   106                          ; In the final C65 system, this will represent the ML interface, not the
   107                          ; BASIC 10.0 interface which is implemented here in the development system.
   108                          
   109                          
   110                          graphic
   111  7fc0 c99c                               cmp     #clr_token                      ; GRAPHIC CLR (graphic system initialize)
   112  7fc2 d006                               bne     l317_1                          ; no
   113  7fc4 208322                             jsr     chrget                          ; yes advance past token
   114  7fc7 6c0080                             jmp     ($8000)                         ; go initialize graphic kernel
   115                          
   116                          l317_1
   117                          ; tax
   118                          ; bmi snerr  ;Syntax error if any other secondary token
   119                          ;
   120                          ;
   121  7fca 6cfe02                             jmp     (graphic_vector)                ; Else, call the Graphics Kernel's Parser...
   122                          ;
   123                          ;
   124                          graphic_kernel                                          ; ...via indirect
   125  7fcd 6c0280                             jmp     ($8002)
   126                          
   127                          
   128                          ; C65 Graphic Kernel Jump Table      [910826]
   129                          ;
   130                          ; 8000 init   ;sets up graphic vars
   131                          ; 8002 parser   ;GRAPHIC ML Parser????
   132                          ;
   133                          ; 8004 kg65.start-1  ;0 commands
   134                          ; 8006 kg65.screendef-1 ;1
   135                          ; 8008 kg65.screenopen-1 ;2
   136                          ; 800a kg65.screenclose-1 ;3
   137                          ; 800c kg65.screenclear-1 ;4
   138                          ; 800e kg65.screen-1  ;5
   139                          ; 8010 kg65.setpen-1  ;6
   140                          ; 8012 kg65.setpalette-1 ;7
   141                          ; 8014 kg65.setdmode-1  ;8
   142                          ; 8016 kg65.setdpat-1  ;9
   143                          ; 8018 kg65.line-1  ;10
   144                          ; 801a kg65.box-1  ;11
   145                          ; 801c kg65.circle-1  ;12
   146                          ; 801e kg65.polygon-1  ;13
   147                          ; 8020 kg65.ellipse-1  ;14
   148                          ; 8022 kg65.viewpclr-1  ;15
   149                          ; 8024 kg65.copy-1  ;16
   150                          ; 8026 kg65.cut-1  ;17
   151                          ; 8028 kg65.paste-1  ;18
   152                          ; 802a kg65.load-1  ;19
   153                          ; 802c kg65.char-1  ;20
   154                          ; 802e kg65.paint-1  ;21
   155                          ; 8030 kg65.viewpdef-1  ;22
   156                          ; 8032 kg65.f.pixel-1  ;23
   157                          ; 8034 kg65.f.rpalette-1 ;24
   158                          ; 8036 kg65.f.index2color-1 ;25
   159                          ; 8038 kg65.f.rgraphic  ;26
   160                          
   161                          
   162                          
   163                          
   164                          
   165                          
   166                          ; ********************************************************************************************
   167                          ;
   168                          ;	Date		Changes
   169                          ;	====		=======
   170                          ;
   171                          ; ********************************************************************************************

; ******** Source: basic.asm
