; .nam C65 Development BASIC 10.0 (C)1991 CBM
; .subttl *** Copyright (C) 1991  by  Commodore Business Machines, Inc. ***

;  ***************************************************************************
;  *                               //                                        *
;  *              CCCCCCC         //    6666666     555555555                *
;  *             CCC   CCC       //    666   666    555                      *
;  *            CCC             //    666           555                      *
;  *            CCC            //     666 6666      55555555                 *
;  *            CCC           //      6666   666          555                *
;  *            CCC          //       666     666          555               *
;  *             CCC   CCC  //         666   666    555   555                *
;  *              CCCCCCC  //           6666666      5555555                 *
;  *                      //                                                 *
;  *                                                                         *
;  *          BBBBBBBBB      AAAA      SSSSSSSS   III    CCCCCCC             *
;  *          BBB    BBB   AAA  AAA   SSS    SSS  III   CCC   CCC            *
;  *          BBB    BBB  AAA    AAA  SSS         III  CCC                   *
;  *          BBBBBBBBB   AAAAAAAAAA   SSSSSSSS   III  CCC                   *
;  *          BBB    BBB  AAA    AAA         SSS  III  CCC                   *
;  *          BBB    BBB  AAA    AAA  SSS    SSS  III   CCC   CCC            *
;  *          BBBBBBBBB   AAA    AAA   SSSSSSSS   III    CCCCCCC             *
;  *                                                                         *
;  *                       V E R S I O N   1 0 . 0                           *
;  *              *
;  *        Copyright (C)1991  by   Commodore Business Machines, Inc.        *
;  *              *
;  *       All  Rights  Reserved        *
;  *              *
;  ***************************************************************************

;   ROM VERSION  911115  (ver 0.9B)

; ******************************************************************
; *                                                                *
; * This listing contains confidential and proprietary information *
; * of CBM, Inc.  The reproduction, dissemination or disclosure to *
; * others without express written permission is prohibited.  This *
; * software is for use in prototype Commodore C/65 systems only.  *
; *                                                                *
; *  The information in this document will change without notice.  *
; *                                                                *
; *  No  responsibility  is  assumed  for the reliability of this  *
; *                          software.                             *
; *                                                                *
; ******************************************************************

; .STORE $2000,$a000,"b65.rom"

; This version written and assembled by Fred Bowen using BSO format.
; .page
; Adapted from the following C128 files, ROM part numbers 318018-04, 3180194-04:
;
; disclaim  resume   hexfunc
; declare   doloop   rgr
; entries   key   rclr
; header   paint   joy
; init   box   penpot
; indjumps  sshape   pointer
; crunch   gshape   rsprite
; tokens1   circle   rspcolor
; tokens2   draw   bump
; disptable  char   rsppos
; errmsgs   locate   xor
; errprint  scale   rwindow
; execute   color   rnd
; functions  scnclr   code12
; code0   graphic   stringfns
; rtstack   bank   code17
; findline  sleep   code18
; lineget   wait   code19
; list   sprite   code21
; newclr   movspr   code22
; return   play   code23
; remdata   filter   code24
; if   envelope  code26
; ongoto   collision  grbcol
; let   sprcolor  trig
; print   width   using
; input   volume   instring
; next   sound   graphic3
; dim   window   rdot
; sys   boot   graphic7
; trontroff  sprdef   graphic8
; rreg   sprsav   graphic9
; midequal  fast   graphic10
; auto   slow   graphic11
; help   checkval  sethires
; gosubgoto  formeval  clrhires
; go   variables  dos1
; continue  getpointr  dos2
; run   array   dos3
; restore   patcheslo  dos4
; renumber  fre   overflow
; for   val   irq
; delete   dec   stash
; pudef   peekpoke  fetch
; trap   errfunc   swap
; patcheshi  jumptable  def
; strings
; .page
; .subttl C65 BASIC 10.0 Macro Definitions

; .blist

; .page
; .subttl C65 BASIC 10.0 Declarations

; General assignments and equates

doslfn           = 0                                      ; DOS' private logical file number
dosffn           = 8                                      ; DOS' default drive number

strsiz           = 3                                      ; string descriptor size in temps. and arrays
lengos           = 5                                      ; length of a GOSUB entry on the runtime stack
lenfor           = 18                                     ; length of a FOR entry in the runtime stack

; maxchr = 80  ;misc. command equates
; llen  = 40
; nlines = 25
column_width     = 10                                     ; print comma spacing

beats_pal        = 1200                                   ; whole note (4/4 time = 2sec.)    [910724]
beats_ntsc       = 1440                                   ;

lf               = $0a                                    ; line feed
cr               = $0d                                    ; carriage return
esc              = $1b                                    ; escape
pi               = $ff

basbgn           = $2000                                  ; bottom of BASIC text bank
baswrk           = basbgn+1                               ; where BASIC text starts
varbgn           = $2000                                  ; bottom of BASIC data bank (C65: DOS RAM below $12000)
bank_0_top       = $8000                                  ; top of BASIC text bank ($FF00)    [910528]
bank_1_top       = $8000                                  ; top of BASIC data bank ($f800, VIC attributes)  [910528]

; graphic_base = $2000
; color_ram_lo = $1c00
; color_ram_hi = $d800

vic              = $d000                                  ; Video controller

fdc              = $d080                                  ; Built-in floppy disk controller

sid1             = $d400                                  ; Audio processors (right)
sid2             = $d420                                  ; (left)

d1_6526          = $dc00                                  ; Ports, peripheral control
d1pra            = d1_6526
d2_6526          = $dd00
d2pra            = d2_6526

dma_ctlr         = $d700                                  ; DMA Controller

; .page
;  BASIC base page storage

                 * = $0000

                 !fill 2                                  ; '4510' registers (not used in C65 mode)
srchtk           !fill 1                                  ; token 'search' looks for (run-time stack) / SYS 'bank#'

                 * = $000a                                ; skip over SYS address, status, a/x/y/z registers

integr                                                    ; used by math routines (this & following location)
charac           !fill 1
endchr           !fill 1
verck            !fill 1                                  ; LOAD/VERIFY flag
count            !fill 1                                  ; temp used all over
dimflg           !fill 1                                  ; DIM flag used by variable search
valtyp           !fill 1                                  ; 0=numeric, $FF=string
intflg           !fill 1                                  ; b7: (0=float,1=integer), b6: (1=get flag)
garbfl                                                    ; garbage collection temporary
dores            !fill 1                                  ; b7: P1LINE quote flag
subflg           !fill 1                                  ; b7: subscript flag (set to disallow subscripts() & integers%)
input_flag       !fill 1                                  ; READ($98), GET($40), or INPUT($00)
domask
tansgn           !fill 1
channl           !fill 1                                  ; active I/O channel
poker                                                     ; temp used all over
linnum           !fill 2                                  ; line number

temppt           !fill 1                                  ; pointer to next temporary descriptor in tempst
lastpt           !fill 2                                  ; pointer to last used temporary string
tempst           !fill 9                                  ; temporary descriptor pointers (3 at 3 bytes each)

index
index1           !fill 2
index2           !fill 2

multiplicand                                              ; 2 bytes wide, for unsigned integer multiply
resho            !fill 1
resmoh           !fill 1
product                                                   ; 3 bytes wide, for unsigned integer multiply
addend
resmo            !fill 1
reslo            !fill 1
                 !fill 1
txttab           !fill 2                                  ; where BASIC program begins   (text_bank)
vartab           !fill 2                                  ; where variable descriptors begin  (var_bank)
arytab           !fill 2                                  ; where array table begins   (var_bank)
strend           !fill 2                                  ; where arrays table ends   (var_bank)
fretop           !fill 2                                  ; bottom of string storage   (var_bank)
frespc           !fill 2                                  ; where temporary strings begin   (var_bank)
max_mem_1        !fill 2                                  ; highest address available to BASIC in RAM 1 (var_bank)
curlin           !fill 2
txtptr           !fill 2                                  ; pointer to BASIC text used by CHRGET, etc.
form                                                      ; used by print using
fndpnt           !fill 2                                  ; pointer to item found by search
datlin           !fill 2
datptr           !fill 2
inpptr           !fill 2
varnam           !fill 2
fdecpt
varpnt           !fill 2
lstpnt
andmsk
forpnt           !fill 2
eormsk           =forpnt+1
vartxt
opptr            !fill 2
opmask           !fill 1
grbpnt
tempf3
defpnt           !fill 2
dscpnt           !fill 2
token_saver                                               ; temp used by P1LINE/HELPSB (was spare????) [910628]
trmpos           !fill 1                                  ; temp used by SPC(), TAB()   [910628]

helper           !fill 1                                  ; P1LINE flag b7: HELP vs. LIST
;  b6: memory vs. file
;  b5: FIND/CHANGE
;  b4: highlight tokens
;  b3: highlight REM
;  b1: LINGET flag for AUTOSCROLL
;  b0: token in progress

jmper            !fill 1                                  ; 3 locations used by Function handler
                 !fill 1                                  ;
oldov            !fill 1                                  ;

tempf1           !fill 1                                  ; used by math routines
ptarg1           =tempf1                                  ; multiply defined for INSTR thru FACexp
ptarg2           =tempf1+2                                ; (also used by Monitor Utility, thru lowtr)
str1             =tempf1+4
str2             =tempf1+7
positn           =tempf1+10
match            =tempf1+11

arypnt
highds           !fill 2
hightr           !fill 2

tempf2           !fill 1                                  ; used by math routines
deccnt           !fill 2
tenexp           = deccnt+1
grbtop
dptflg
lowtr            !fill 1
expsgn           !fill 1

fac                                                       ; Floating point accumulator (primary) FAC1
dsctmp
facexp           !fill 1
facho            !fill 1
facmoh           !fill 1
indice
facmo            !fill 1
faclo            !fill 1
facsgn           !fill 1
degree
sgnflg           !fill 1

argexp           !fill 1                                  ; Floating point accumulator (secondary) FAC2
argho            !fill 1
argmoh           !fill 1
argmo            !fill 1
arglo            !fill 1
argsgn           !fill 1

strng1
arisgn           !fill 1
facov            !fill 1

strng2
polypt
curtol
fbufpt           !fill 2

autinc           !fill 2                                  ; incremental value for AUTO (0=off)

z_p_temp_1       !fill 1                                  ; USING's leading zero counter
;GET, RENUMBER, KEY temporary
;MOVSPR, SPRITE, PLAY, VOL temporary
;MID$= temporary

hulp                                                      ; counter
keysiz           !fill 1

syntmp           !fill 1                                  ; used as temp all over the place
dsdesc           !fill 3                                  ; descriptor for DS$
tos              !fill 2                                  ; top of run time stack
runmod           !fill 1                                  ; flags run/direct(b7), load(b6), trace(b5), edit(b4) modes
; autoboot wedge (b0)
point                                                     ; USING's pointer to decimal point, 2 bytes used by AutoScroll
parsts           !fill 1                                  ; DOS parser status word
parstx           !fill 1                                  ; DOS parser status extensions

oldstk           !fill 1                                  ; BASIC saves uP stack pointer here

text_top         !fill 2                                  ; top of BASIC text pointer  (in text_bank)
text_bank        !fill 1                                  ; where BASIC text lives   (RAM0 default)
var_bank         !fill 1                                  ; where BASIC vars live   (RAM1 default)
sys_bank         = 0                                      ; where system space is  ???? (RAM0, make this a var?)

sid_speed_flag   !fill 1                                  ; saves system speed during SID ops (used during IRQ)

time                                                      ; temporaries for TI, TI$, SLEEP (4 bytes)
grapnt                                                    ; used by SPRSAV, RMOUSE, RCOLOR
op
column           !fill 1                                  ; temporaries for FIND/CHANGE, [L]INPUT, [L]READ, CURSOR
srow
fstr1            !fill 3                                  ;
fstr2            !fill 3                                  ;

; .page
                 * = $00ff

lofbuf           !fill 1
fbuffr           !fill 16                                 ; MathPack builds numbers here, USING, RENUMBER

;  Kernel MAP configurations & DMA lists

                 !fill 16+36                              ; (4 configs + 3 DMA lists)

;  BASIC DMA lists  (2 @ 12bytes each = 24 bytes)

dma1_cmd         !fill 1                                  ; This list is used by BASIC OS
dma1_cnt_lo      !fill 1
dma1_cnt_hi      !fill 1
dma1_src_lo      !fill 1
dma1_src_hi      !fill 1
dma1_src_bank    !fill 1
dma1_dest_lo     !fill 1
dma1_dest_hi     !fill 1
dma1_dest_bank   !fill 1
dma1_subcmd      !fill 1                                  ; (from here on not supported until F018A) [910520] F018A
dma1_mod_lo      !fill 1
dma1_mod_hi      !fill 1

dma2_cmd         !fill 1                                  ; This list is used by DMA command & Graphics
dma2_cnt_lo      !fill 1
dma2_cnt_hi      !fill 1
dma2_src_lo      !fill 1
dma2_src_hi      !fill 1
dma2_src_bank    !fill 1
dma2_dest_lo     !fill 1
dma2_dest_hi     !fill 1
dma2_dest_bank   !fill 1
dma2_subcmd      !fill 1                                  ; (from here on not supported until F018A) [910520] F018A
dma2_mod_lo      !fill 1
dma2_mod_hi      !fill 1

                 !fill 1                                  ; Kernel's dma_byte

sysstk                                                    ; bottom of system stack
stkend           = $1fb                                   ; top of system stack

; .page
                 * = $0200

buflen           = 161                                    ; input buffer size (2 80-column lines + 1)
buf              !fill buflen                             ; BASIC/Monitor line input buffer
buf_txtptr       = buf-1

; .page
                 * = $02c0
; BASIC RAM code  (RAM code not needed- following moved to ROM)
;
; chrget *=*+42  ;get byte from text bank after incrementing TXTPTR
; chrgot = chrget+2 ;get byte from text bank at TXTPTR
; qnum  = chrget+27 ;evaluate byte as a number & set flags accordingly

adray1           !fill 2                                  ; ptr to routine:  convert float -> integer ???? why keep
adray2           !fill 2                                  ; ptr to routine:  convert integer -> float ???? why keep
zero             !fill 3                                  ; numeric constant for BASIC, downloaded from ROM

errnum           !fill 1                                  ; used by error trapping routine-last error number
errlin           !fill 2                                  ; line # of last error ($FFFF if no error)
trapno           !fill 2                                  ; line to go to on error ($FFxx if none set)
tmptrp           !fill 1                                  ; hold trap # temporary
errtxt           !fill 2                                  ; pointer to statement causing last error
max_mem_0        !fill 2                                  ; highest address available to BASIC in RAM 0 (text bank)

current_bank     !fill 1                                  ; context for PEEK,POKE,BOOT,SYS,WAIT,BLOAD/SAVE set by BANK.
fin_bank         !fill 1                                  ; bank pointer for string->number conversion routine FIN
tmpdes           !fill 4                                  ; pointers to temporary descriptors for INSTR
bits             !fill 1                                  ; flag for math bit/byte shifter
highlight_color  !fill 1                                  ; color for highlighting text
highlight_save   !fill 1                                  ; saves normal color during highlighting, msb=flag
find_count       !fill 1                                  ; count for LIST to highlight FIND text

; Interrupt stuff

irq_wrap_flag    !fill 1                                  ; used by BASIC_IRQ to block all but one IRQ call
intval           !fill 1                                  ; BASIC interrupts enabled (via collision command)
int_trip_flag    !fill 3                                  ; flags which interrupts occurred
int_adr_lo       !fill 3                                  ; where to go for each type of collision (line number)
int_adr_hi       !fill 3                                  ;
collisions       !fill 2                                  ; sprite collisions, s/s and s/bgnd, recorded during IRQ
lightpen_xpos    !fill 1                                  ; lightpen position recorded during IRQ
lightpen_ypos    !fill 1

; dejavu *=*+1  ;'cold' or 'warm' reset status (must be in page 5!)????

; nmi_wrap_flag *=*+1  ;used by BASIC_NMI to block all but one NMI call [910523]
;    ; (removed)      [910826]
;(leaving 12 bytes)
; .page
; BASIC indirect vectors

                 * = $02f7

usrpok           !fill 3                                  ; USR vector (must be set by application)

vectors_begin
iAutoScroll      !fill 2                                  ; AutoScroll vector
esc_fn_vec       !fill 2                                  ; Escape Function vector
graphic_vector   !fill 2                                  ; Graphic Kernel vector (was 'bnkvec')
ierror           !fill 2                                  ; indirect error (output error in .x)
imain            !fill 2                                  ; indirect main (system direct loop)
icrnch           !fill 2                                  ; indirect crunch (tokenization routine)
iqplop           !fill 2                                  ; indirect list (char list)
igone            !fill 2                                  ; indirect gone (char dispatch)
ieval            !fill 2                                  ; indirect eval (symbol evaluation)
iesclk           !fill 2                                  ; escape token crunch
iescpr           !fill 2                                  ; escape token list
iescex           !fill 2                                  ; escape token execute
itime            !fill 2                                  ; 60Hz interrupt vector (before jiffy)
cinv             !fill 2                                  ; IRQ RAM vector
cbinv            !fill 2                                  ; BRK RAM vector

; Remainder of this area reserved for Kernel indirects & Kernel RAM code

; .page
                 * = $0400                                ; BASIC's run-time stack (2 pages)
stktop                                                    ; (also used by BOOT SYS and Monitor)
stkbot           = $05ff


                 * = $0600                                ; Sprite definitions (2 pages, must be below $1000)
sprite_base


                 * = $0800
screen_start                                              ; Text display screen
                 * = *+2000

sprite_ptrs_40   = screen_start+$3f8
sprite_ptrs_80   = screen_start+$7f8

; .page
                 * = $1170                                ; previous to this used by Kernel

oldlin           !fill 2                                  ; BASIC storage
oldtxt           !fill 2                                  ; BASIC storage
rndx             !fill 5                                  ; Floating Point representation of last random #


; Yet more temporaries shared by various routines

window_temp                                               ; window  (4 bytes)
t3                                                        ; dcat  (1 byte)
renum_tmp_1                                               ; renumber (2 bytes)
tmptxt           !fill 2                                  ; do/loop (2 bytes)

t4                                                        ; dcat  (2 bytes)
renum_tmp_2                                               ; renumber (2 bytes)
tmplin           !fill 2                                  ; do/loop (2 bytes)


;  BASIC/DOS interface vars  (20 bytes)

dosofl           !fill 2                                  ; BLOAD/BSAVE starting addr
dosofh           !fill 2                                  ; BSAVE ending addr
dosla            !fill 1                                  ; DOS logical addr
dosfa            !fill 1                                  ; DOS physical addr
dossa            !fill 1                                  ; DOS secondary addr

xcnt             !fill 1                                  ; DOS loop counter------ this area zeroed-out each DOS call -----
dosf1l           !fill 1                                  ; DOS filename 1 len
dosds1           !fill 1                                  ; DOS disk drive 1
dosf2l           !fill 1                                  ; DOS filename 2 len
dosds2           !fill 1                                  ; DOS disk drive 2
dosf2a           !fill 2                                  ; DOS filename 2 addr
dosrcl           !fill 1                                  ; DOS record length
dosbnk           !fill 1                                  ; DOS load/save bank
dosdid           !fill 2                                  ; DOS ID identifier
dosflags         !fill 1                                  ; DOS flags  7:ID,  6:recover
dossa_temp       !fill 1                                  ; temp storage for file's sa during RECORD command
dosspc           = *-xcnt                                 ; space used by DOS routines-------------------------------------

savram           !fill 67                                 ; buffer used by MOVSPR, SPRDEF, SAVSPR, and DOS parser

xabs             = savram                                 ; movspr_line calculations   [910809]
yabs             = savram+2
xsgn             = savram+4
ysgn             = savram+6
fct              = savram+8
errval           = savram+12

; .page
; PRINT USING definitions & storage  (24 bytes)

puchrs                                                    ; Declarations for PRINT USING...
pufill           !fill 1                                  ; print using fill symbol
pucoma           !fill 1                                  ; print using comma symbol
pudot            !fill 1                                  ; print using decimal point symbol
pumony           !fill 1                                  ; print using monetary symbol

bnr              !fill 1                                  ; pointer to begin #
enr              !fill 1                                  ; pointer to end #
dolr             !fill 1                                  ; dollar flag
flag             !fill 1                                  ; comma flag (also used by PLAY)????
swe              !fill 1                                  ; counter
usgn             !fill 1                                  ; sign exponent
uexp             !fill 1                                  ; pointer to exponent
vn               !fill 1                                  ; # of digits before decimal point
chsn             !fill 1                                  ; justify flag
vf               !fill 1                                  ; # of positions before decimal point (field)
nf               !fill 1                                  ; # of positions after decimal point (field)
posp             !fill 1                                  ; +/- flag (field)
fesp             !fill 1                                  ; exponent flag (field)
etof             !fill 1                                  ; switch
cform            !fill 1                                  ; char counter (field)
sno              !fill 1                                  ; sign no
blfd             !fill 1                                  ; blank/star flag
begfd            !fill 1                                  ; pointer to begin of field
lfor             !fill 1                                  ; length of format
endfd            !fill 1                                  ; pointer to end of field

; .page
;  * = $1200 ;BASIC Graphic, Sprite, Music, & Sound storage

;  The following 24 bytes are multiply defined...
;
; params = *

;  Circle drawing variables  (multiply defined).
;
; xcircl *=*+2  ;circle center, x coordinate
; ycircl *=*+2  ;circle center, y coordinate
; xradus *=*+2  ;x radius
; yradus *=*+2  ;y radius
; rotang *=*+4  ;rotation angle
; angbeg *=*+2  ;arc angle start
; angend *=*+2  ;arc angle end
; xrcos  *=*+2  ;x radius * cos(rotation angle)
; yrsin  *=*+2  ;y radius * sin(rotation angle)
; xrsin  *=*+2  ;x radius * sin(rotation angle)
; yrcos  *=*+2  ;y radius * cos(rotation angle)

; parend = *

;  Box drawing variables  (multiply defined).
;
;  *=params
; xcord1 *=*+2  ;point 1 x-coord.
; ycord1 *=*+2  ;point 1 y-coord.
; boxang *=*+2  ;rotation angle
; xcount *=*+2
; ycount *=*+2
; bxleng *=*+2  ;length of a side
; xcord2 *=*+2
; ycord2 *=*+2

; .page
;  Shape variables  (multiply defined).
;
;  *=params
;  *=*+1  ;placeholder
; keylen *=*+1
; keynxt *=*+1
; strsz  *=*+1  ;string len
; gettyp *=*+1  ;replace shape mode
; strptr *=*+1  ;string pos'n counter
; oldbyt *=*+1  ;old bit map byte
; newbyt *=*+1  ;new string or bit map byte
;  *=*+1  ;placeholder
; xsize  *=*+2  ;shape column length
; ysize  *=*+2  ;shape row length
; xsave  *=*+2  ;temp for column length
; stradr *=*+2  ;save shape string descriptor
; bitidx *=*+1  ;bit index into byte

;  General use parameters  (multiply defined).
;
;  *=params
; xcentr *=*+2
; ycentr *=*+2
; xdist1 *=*+2
; ydist1 *=*+2
; xdist2 *=*+2
; ydist2 *=*+2
; disend
;  *=*+2  ;placeholder
; colcnt *=*+1  ;char's col. counter
; rowcnt *=*+1
; strcnt *=*+1

; .page
;  General  graphic & sound  buffers & assignments
;
;  * = parend

;  General graphic storage (used by C128-type sprite routines in C65)

vwork                                                     ; graphics & sprite vars
xpos             !fill 2                                  ; current x position
ypos             !fill 2                                  ; current y position
xdest            !fill 2                                  ; x-coordinate destination
ydest            !fill 2                                  ; y-coordinate destination

numcnt           !fill 1                                  ; temp, usually coordinate type
vtemp1           !fill 1                                  ; used by sprite math stuff ????was base page
vtemp2           !fill 1                                  ; ????was base page
vtemp3           !fill 1                                  ; misc. graphic temp storage
vtemp4           !fill 1
vtemp5           !fill 1

; mvdflg *=*+1  ;flag if 10k hires allocated ???? this stuff was base page
; colsel *=*+1  ;current color selected
; multicolor_1 *=*+1
; multicolor_2 *=*+1
; foreground *=*+1
; scalem *=*+1  ;scale mode flag
; scale_x *=*+2  ;scale factor in x
; scale_y *=*+2  ;scale factor in y
; stopnb *=*+1  ;stop paint if not background/not same color
; fg_bg  *=*+1  ;packed foreground/background color nybbles
; fg_mc1 *=*+1  ;packed foreground/multicolor 1 color nybbles

; bitcnt *=*+1  ;temp for gshape
; width  *=*+1  ;double width flag
; filflg *=*+1  ;box fill flag
; circle_segment *=*+1  ;degrees per circle segment
; bitmsk *=*+1  ;temp for bit mask

; character_rom *=*+1  ;high byte of address of char rom for 'char' command
; upper_lower *=*+1  ;pointer to upper/lower case for char command
; upper_graphic *=*+1  ;   "       upper/graphic

;  DrawLine stuff
;
; xabs  *=*+2  ;16 bytes
; yabs  *=*+2
; xsgn  *=*+2
; ysgn  *=*+2
; fct  *=*+4
; errval *=*+2
; lesser *=*+1
; greatr *=*+1
; .page
;  Angle stuff (used by sprites)

angsgn           !fill 1                                  ; sign of angle
sinval           !fill 2                                  ; sine of value of angle
cosval           !fill 2                                  ; cosine of value of angle
; angcnt *=*+2  ;temps for angle distance routines


; Sprite stuff

savsiz           !fill 4                                  ; temp work locations for SSHAPE, SPRSAV, MOVSPR_TO
lesser
sprtmp_1         !fill 1                                  ; temp for SPRSAV
greatr
sprtmp_2         !fill 1

sprite_data      !fill 88                                 ; speed/direction tables for 8 sprites, 11 bytes each
;   move ang/dist move line
; offset= 0 b7=0+speed b7=1+speed
;  1 counter  counter lo
;  2 angle sign         hi
;  3,4 delta-X  dir+min/max
;  5,6 delta-Y  fct1
;  7,8 total-X  fct2
;  9,10 total-Y  error

init_as_0        = *-sprite_data-1

; vic_save *=*+21  ;copy of VIC reg's, used to update chip during retrace

; defmod *=*+1  ;for SPRDEF
; lincnt *=*+1  ; "
; sprite_number *=*+1  ; "

; .page
; Music stuff driving stereo SIDs, 3 voices each

voices           !fill 12                                 ; Voice counters (activity flags)  [910612] stereo
waveform         !fill 6                                  ; Waveforms for each voice   [910612] stereo

voice            !fill 1                                  ; Play note parameters
octave           !fill 1
sharp            !fill 1
dnote            !fill 1
tempo_rate       !fill 1                                  ; duration of whole note 4/4 time = 24/rate
pitch            !fill 2
ntime            !fill 2

filters1         !fill 4                                  ; Volume & Filter parameters   [910612] was 5
filters2         !fill 4                                  ; [910612] stereo
fltsav           !fill 4                                  ; temps
fltflg           !fill 1                                  ; temp

tonnum           !fill 1                                  ; Tune Envelope stuff
tonval           !fill 3

atktab           !fill 10                                 ; Tune Envelopes
sustab           !fill 10
wavtab           !fill 10
pulslw           !fill 10
pulshi           !fill 10

parcnt           !fill 1                                  ; temp: envelope
nibble           !fill 1                                  ; temp: envelope, filter

; .page
; SOUND command stuff

sound_voice      !fill 1
sound_time_lo    !fill 3+3                                ; [910612] stereo
sound_time_hi    !fill 3+3                                ; [910612] stereo
sound_max_lo     !fill 3+3                                ; [910612] stereo
sound_max_hi     !fill 3+3                                ; [910612] stereo
sound_min_lo     !fill 3+3                                ; [910612] stereo
sound_min_hi     !fill 3+3                                ; [910612] stereo
sound_direction  !fill 3+3                                ; [910612] stereo
sound_step_lo    !fill 3+3                                ; [910612] stereo
sound_step_hi    !fill 3+3                                ; [910612] stereo
sound_freq_lo    !fill 3+3                                ; [910612] stereo
sound_freq_hi    !fill 3+3                                ; [910612] stereo

;above must end before $1300
                 * = $1160
;below must end before $1170

temp_time_lo     !fill 1
temp_time_hi     !fill 1
temp_max_lo      !fill 1
temp_max_hi      !fill 1
temp_min_lo      !fill 1
temp_min_hi      !fill 1
temp_direction   !fill 1
temp_step_lo     !fill 1
temp_step_hi     !fill 1
temp_freq_lo     !fill 1
temp_freq_hi     !fill 1
temp_pulse_lo    !fill 1
temp_pulse_hi    !fill 1
temp_waveform    !fill 1

pot_temp_1       !fill 1                                  ; temporaries for 'POT' function
pot_temp_2       !fill 1

; .page
                 * = $1300

dosstr           !fill 256                                ; DOS input/output string buffer

; .page
                 * = $1f00                                ; Graphics Kernel Interface

GKI__parm1       !fill 1                                  ; ml interface parm values
GKI__parm2       !fill 1
GKI__parm3       !fill 1
GKI__parm4       !fill 1
GKI__parm5       !fill 1
GKI__parm6       !fill 1
GKI__parm7       !fill 1
GKI__parm8       !fill 1
GKI__parm9       !fill 1
GKI__parm10      !fill 1
GKI__parm11      !fill 1
GKI__parm12      !fill 1
GKI__parm13      !fill 1
GKI__parm14      !fill 1
GKI__parm15      !fill 1
GKI__parm16      !fill 1
GKI__parm17      !fill 1

GKI__subparm1    !fill 1                                  ; subroutine parm values
GKI__subparm2    !fill 1
GKI__subparm3    !fill 1
GKI__subparm4    !fill 1
GKI__subparm5    !fill 1

GKI__temp1       !fill 1                                  ; local variables within subroutines
GKI__temp2       !fill 1
GKI__temp3       !fill 1
GKI__temp4       !fill 1
GKI__temp5       !fill 1
GKI__temp6       !fill 1
GKI__temp7       !fill 1
GKI__temp8       !fill 1
GKI__temp9       !fill 1
GKI__temp10      !fill 1
GKI__temp11      !fill 1
GKI__temp12      !fill 1
GKI__temp13      !fill 1
GKI__temp14      !fill 1
GKI__temp15      !fill 1
GKI__temp16      !fill 1
GKI__temp17      !fill 1

;.end
; .page
; .subttl C65 Kernal Entry Points

; Addresses of OS parameters referenced by BASIC:

_6510_data_reg   = $01
_bank            = $02                                    ; reg's for Kernel xxx_FAR routines (used by SYS)
_pchi            = $03
_pclo            = $04
_s_reg           = $05
_a_reg           = $06
_x_reg           = $07
_y_reg           = $08
_z_reg           = $09

_vicIRQ          = $a0                                    ; VIC IRQ flag register at time of IRQ
_starting_addr   = $ac                                    ; address BLOAD loaded to
_sa              = $b9                                    ; I/O channel secondary address
_fa              = $ba                                    ; I/O channel device number
_ndx             = $d0                                    ; number of characters in keyboard buffer
_kyndx           = $d1                                    ; fkey active flag
_mode            = $d7                                    ; 40/80 mode
_graphm          = $d8                                    ; graphic mode switch (multi/hires/split)
_pnt             = $e0                                    ; Editor screen address at cursor

_screen_bottom   = $e4                                    ; these describe the current window
_screen_top      = $e5
_screen_left     = $e6
_screen_right    = $e7

_color           = $f1                                    ; text color      [910722]
_autoinsert      = $f6                                    ; enable/disable auto insert mode
_locks           = $f7                                    ; Editor keyboard locks     [910722]

_keyd            = $02b0                                  ; keyboard buffer     [910710]
;_split = $0a34  ;line to start split at

number_fkeys     = 16                                     ; max of 14 prog. fn. keys
_pky_lengths     = $1000                                  ; table of prog. fn. key sizes
_pky_buffer      = _pky_lengths+number_fkeys              ; actual buffer

_restart_vector  = $1100                                  ; Kernel restart vector
_pal_ntsc        = $1103                                  ; PAL=$ff, NTSC=$00 indicator    [910107]
_init_status     = $1104                                  ; msb set tells Kernel to let BASIC have IRQs
_default_drive   = $1106                                  ; system default disk drive
_expansion       = $1107                                  ; expansion RAM (# banks????)    [910107]
_sleep_counter   = $110c                                  ; binary frame counter maintained by Kernel  [910730]
_mouse_enable    = $1135                                  ; port# used by mouse (b7=port2, b6=port1, or both) [910107]
_mouse_pointer   = $1136                                  ; sprite pointer (sprite*2) by Kernel mouse driver "
_mouse_top       = $113b                                  ; margins for mouse pointer    "
_mouse_bottom    = $113c                                  ; "
_mouse_left      = $113d                                  ; "
_mouse_right     = $113e                                  ; "

; Addresses of I/O areas referenced by BASIC:

_red             = $d100                                  ; VIC palette (I/O block)
_green           = $d200
_blue            = $d300

; Addresses of Kernel entry points referenced by BASIC:

_print           = $e00c
_mouse           = $e01b                                  ; [910122]
_set_window      = $e02d
_palette_init    = $e027
_cursor          = $e030                                  ; [910228]
;_ldtb2 = $e033
;_ldtb1 = $e04c

_close_all       = $ff50                                  ; close all channels assigned to device .a
_go_64           = $ff53                                  ; C64 mode
_monitor         = $ff56                                  ; ML Monitor
_bootsys         = $ff59                                  ; Boot alternate OS     [910110]
_phoenix         = $ff5c                                  ; jump to 'post-BASIC initialize' routine
_lkupla          = $ff5f                                  ; find an available Logical Address
_lkupsa          = $ff62                                  ; find an available Secondary Address
_swapper         = $ff65                                  ; switch 80/40 column
_doakey          = $ff68                                  ; add/remove a definition from the p.f. key table
_setbank         = $ff6b                                  ; set bank for load/save/verify/open
_jsr_far         = $ff6e                                  ; call a subroutine in any bank
_jmp_far         = $ff71                                  ; jump to code in any bank
_lda_far         = $ff74                                  ; write a byte to any bank
_sta_far         = $ff77                                  ; read a byte from any bank
_cmp_far         = $ff7a                                  ; compare a byte to any bank
_primm           = $ff7d                                  ; print immediate

_setmsg          = $ff90
_readst          = $ffb7
_setlfs          = $ffba
_setnam          = $ffbd
_open            = $ffc0
_close           = $ffc3
_chkin           = $ffc6
_chkout          = $ffc9
_clrch           = $ffcc
_basin           = $ffcf
_bsout           = $ffd2
_loadsp          = $ffd5
_savesp          = $ffd8
_SetTime         = $ffdb
_ReadTime        = $ffde
_stop            = $ffe1
_getin           = $ffe4
_clall           = $ffe7
_screen_org      = $ffed
_plot            = $fff0

;.end
; .page
; .subttl C65 BASIC 10.0 Initilaization

; ***************************************************************************************************************
; ***************************************************************************************************************
;
;      Name:       patch.asm
;      Purpose:    Fixes
;      Created:    4th January 2020
;      Author:     Paul Robson (paul@robsons.org.uk)
;
; ***************************************************************************************************************
; ***************************************************************************************************************

; ***************************************************************************************************************
;
;				At present ACME does not support BRA opcode $83. BRL replaces this.
;
; ***************************************************************************************************************

!macro lbra addr {
	!byte $83
	!word (addr-*-2) & $FFFF
}

!macro lbcc addr {
	!byte $93
	!word (addr-*-2) & $FFFF
}

!macro lbcs addr {
	!byte $B3
	!word (addr-*-2) & $FFFF
}

!macro lbne addr {
	!byte $D3
	!word (addr-*-2) & $FFFF
}

!macro lbeq addr {
	!byte $F3
	!word (addr-*-2) & $FFFF
}

!macro lbpl addr {
	!byte $13
	!word (addr-*-2) & $FFFF
}

!macro lbmi addr {
	!byte $33
	!word (addr-*-2) & $FFFF
}

!macro lbvs addr {
	!byte $73
	!word (addr-*-2) & $FFFF
}

!macro lbvc addr {
	!byte $53
	!word (addr-*-2) & $FFFF
}
                 * = $2000                                 ;; @@0000 1
 ;; @@2000 1
basic                                                      ;; @@2000 1
                 jmp hard_reset                            ;; @@2000 1
                 jmp soft_reset                            ;; @@2003 1
                 jmp basic_irq                             ;; @@2006 1
                 jmp basic_nmi                            ; (removed)    [910523] audio ;; @@2009 1
 ;; @@200c 1
soft_reset                                                ; warm start BASIC... ;; @@200c 1
                 jsr release_channels                     ; restore default terminal I/O channels ;; @@200c 1
                 lda #doslfn                              ; restore reserved disk channel ;; @@200f 1
                 sec                                      ; not a real close ;; @@2011 1
                 jsr _close                                ;; @@2012 1
                 jsr Clear_DS                             ; zap DS$ just in case ;; @@2015 1
; (might have been in Monitor or building DS$) ;; @@2018 1
                 jsr init_sound_sprites                   ; init interrupt & dma stuff   [910523] ;; @@2018 1
                 jsr init_stack                           ; restore stack ;; @@201b 1
                 lda #1                                    ;; @@201e 1
                 tsb _init_status                         ; tell Kernel to give BASIC a call at IRQ time ;; @@2020 1
                 bra go_ready                             ; enable IRQ, print READY, and go MAIN ;; @@2023 1
 ;; @@2025 1
 ;; @@2025 1
hard_reset                                                 ;; @@2025 1
                 jsr init_vectors                         ; init vectors ;; @@2025 1
                 jsr init_storage                         ; init variables, voices,  & download RAM code ;; @@2028 1
                 jsr signon_message                       ; print initialization message ;; @@202b 1
 ;; @@202e 1
                 lda #0                                   ; init bank pointers   [900509] ;; @@202e 1
                 sta text_bank                             ;; @@2030 1
                 sta helper                               ; reset all LIST flags ;; @@2032 1
                 lda #1                                    ;; @@2034 1
                 sta var_bank                              ;; @@2036 1
                 lda #2                                    ;; @@2038 1
                 sta highlight_color                      ; set highlight color (2=red) ;; @@203a 1
                 ldx #<basic+3                             ;; @@203d 1
                 stx _restart_vector                      ; point system restart vector at warm start entry ;; @@203f 1
                 jsr init_stack                           ; initialize system stack pointer ;; @@2042 1
                 lda #1                                    ;; @@2045 1
                 tsb _init_status                         ; tell Kernel to give BASIC a call at IRQ time ;; @@2047 1
                 jsr ($8000)                              ; initialize graphics ;; @@204a 1
                 jsr _phoenix                             ; call cartridges, check out expansion card ;; @@204d 1
                 jsr autobootCSG                          ; attempt to boot program from disk ;; @@2050 1
 ;; @@2053 1
go_ready                                                   ;; @@2053 1
                 cli                                      ; enable IRQ ;; @@2053 1
                 +lbra ready                               ;; @@2054 1
 ;; @@2057 1
; .page ;; @@2057 1
init_storage                                               ;; @@2057 1
                 lda #76                                  ; 'jmp' opcode ;; @@2057 1
                 sta jmper                                 ;; @@2059 1
                 sta usrpok                                ;; @@205b 1
 ;; @@205e 1
                 lda #<errguf                             ; init USR vector to 'undef'd function'  [910226] FAB ;; @@205e 1
                 ldy #>errguf                              ;; @@2060 1
                 sta usrpok+1                              ;; @@2062 1
                 sty usrpok+2                              ;; @@2065 1
 ;; @@2068 1
                 lda #<flpint                             ; ???? why keep ;; @@2068 1
                 ldy #>flpint                              ;; @@206a 1
                 sta adray1                                ;; @@206c 1
                 sty adray1+1                              ;; @@206f 1
 ;; @@2072 1
                 lda #<givayf                             ; ???? why keep ;; @@2072 1
                 ldy #>givayf                              ;; @@2074 1
                 sta adray2                                ;; @@2076 1
                 sty adray2+1                              ;; @@2079 1
 ;; @@207c 1
; Download CHRGET (and INDSUB code????) to RAM ;; @@207c 1
; ;; @@207c 1
; ldx #endmov-chrget_pattern ;; @@207c 1
;1$ lda chrget_pattern-1,x ;; @@207c 1
; sta chrget-1,x ;; @@207c 1
; dex ;; @@207c 1
; bne 1$ ;; @@207c 1
 ;; @@207c 1
                 ldx #0                                    ;; @@207c 1
                 stx zero                                 ; zero constant ;; @@207e 1
                 stx zero+1                                ;; @@2081 1
                 stx zero+2                                ;; @@2084 1
                 stx bits                                 ; reset bit/byte shifter ;; @@2087 1
                 stx channl                               ; default channels ;; @@208a 1
                 stx runmod                               ; direct mode ;; @@208c 1
                 stx lastpt+1                              ;; @@208e 1
                 stx autinc                               ; turn off auto increment ;; @@2090 1
                 stx autinc+1                              ;; @@2092 1
                 stx rndx                                 ; zero-ing MSB will guarantee a legal value ;; @@2094 1
; stx dosfa  ;zero device number     [910429] ;; @@2097 1
 ;; @@2097 1
                 stx intval                               ; reset all BASIC IRQ stuff ;; @@2097 1
                 stx int_trip_flag                        ; (BASIC IRQ enabled in init_voices) ;; @@209a 1
                 stx int_trip_flag+1                       ;; @@209d 1
                 stx int_trip_flag+2                       ;; @@20a0 1
                 stx lightpen_xpos                         ;; @@20a3 1
                 stx lightpen_ypos                         ;; @@20a6 1
 ;; @@20a9 1
; stx mvdflg  ;flag '8k graphics screen not allocated' ;; @@20a9 1
; stx width  ;init to single-width lines ;; @@20a9 1
; stx scalem  ;turn off scaleing ;; @@20a9 1
; stx filflg ;; @@20a9 1
 ;; @@20a9 1
; inx   ;.x=1 ???? why init stack with $0101 ???? ;; @@20a9 1
; stx buf-3 ;; @@20a9 1
; stx buf-4 ;; @@20a9 1
 ;; @@20a9 1
; ldy #88   ;zero out sprite information area ;; @@20a9 1
;2$ sta sprite_data,y ;???? this is done later at init_as_0 ;; @@20a9 1
; dey ;; @@20a9 1
; bpl 2$ ;; @@20a9 1
 ;; @@20a9 1
; ldx #13 ;; @@20a9 1
; stx foreground  ;init bit map's fg color to light green ;; @@20a9 1
; ldx #1 ;; @@20a9 1
; stx multicolor_1 ;init mc1 to white ;; @@20a9 1
; ldx #2 ;; @@20a9 1
; stx multicolor_2 ;init mc2 to red ;; @@20a9 1
; jsr set_packed_color ;set up packed fg/bg and fg/mc1 bytes ;; @@20a9 1
 ;; @@20a9 1
                 ldx _default_drive                        ;; @@20a9 1
                 stx dosfa                                ; init device number to system default   [910429] ;; @@20ac 1
 ;; @@20af 1
                 ldx #$80                                 ; bank 0 with I/O???? ;; @@20af 1
                 stx current_bank                         ; set default bank for PEEK,POKE,BOOT,SYS,WAIT,BLOAD/SAVE ;; @@20b1 1
 ;; @@20b4 1
                 ldx #tempst                               ;; @@20b4 1
                 stx temppt                               ; init temp descriptor pointer ;; @@20b6 1
 ;; @@20b8 1
                 ldx #<baswrk                             ; set up bottom of bank 0 (text area) ;; @@20b8 1
                 ldy #>baswrk                              ;; @@20ba 1
                 stx txttab                                ;; @@20bc 1
                 sty txttab+1                              ;; @@20be 1
 ;; @@20c0 1
                 lda #<varbgn                             ; set up bottom of bank 1 (storage area) ;; @@20c0 1
                 ldy #>varbgn                              ;; @@20c2 1
                 sta vartab                                ;; @@20c4 1
                 sty vartab+1                              ;; @@20c6 1
 ;; @@20c8 1
                 lda #<bank_0_top                         ; set up top of bank 0 ;; @@20c8 1
                 ldy #>bank_0_top                          ;; @@20ca 1
                 sta max_mem_0                             ;; @@20cc 1
                 sty max_mem_0+1                           ;; @@20cf 1
 ;; @@20d2 1
                 lda #<bank_1_top                         ; set up  top of bank 1 ;; @@20d2 1
                 ldy #>bank_1_top                          ;; @@20d4 1
                 sta max_mem_1                             ;; @@20d6 1
                 sty max_mem_1+1                           ;; @@20d8 1
 ;; @@20da 1
                 lda #0                                   ; init text input buffer  (these are for autoboot) ;; @@20da 1
                 sta buf                                   ;; @@20dc 1
                 dec                                       ;; @@20df 1
                 sta curlin+1                             ; init line pointer ;; @@20e0 1
                 ldx #<buf_txtptr                         ; init txtptr ;; @@20e2 1
                 ldy #>buf_txtptr                          ;; @@20e4 1
                 stx txtptr                                ;; @@20e6 1
                 sty txtptr+1                              ;; @@20e8 1
 ;; @@20ea 1
; Set up sprite pointers ;; @@20ea 1
 ;; @@20ea 1
                 lda #sprite_base/64+7                     ;; @@20ea 1
                 ldy #7                                    ;; @@20ec 1
_local_1000_10   bbr7 _mode,_local_1000_20                 ;; @@20ee 1
                 sta sprite_ptrs_40,y                     ; 40 col screen ;; @@20f1 1
                 bra _local_1000_30                        ;; @@20f4 1
_local_1000_20   sta sprite_ptrs_80,y                     ; 80 col screen ;; @@20f6 1
_local_1000_30   dec                                       ;; @@20f9 1
                 dey                                       ;; @@20fa 1
                 bpl _local_1000_10                        ;; @@20fb 1
 ;; @@20fd 1
; Zero out sprite movement stuff and some VIC stuff too ;; @@20fd 1
 ;; @@20fd 1
                 lda #0                                    ;; @@20fd 1
                 ldx #init_as_0                            ;; @@20ff 1
_local_1000_40   sta sprite_data,x                         ;; @@2101 1
                 dex                                       ;; @@2104 1
                 bpl _local_1000_40                        ;; @@2105 1
 ;; @@2107 1
                 jsr init_sound_sprites                   ; init misc. interrupt & dma stuff ;; @@2107 1
 ;; @@210a 1
; lda #$d0  ;initialize pointers to character ROM ;; @@210a 1
; sta upper_graphic ;; @@210a 1
; lda #$d8 ;; @@210a 1
; sta upper_lower ;; @@210a 1
 ;; @@210a 1
                 +lbra init_text                          ; go to 'new' ;; @@210a 1
 ;; @@210d 1
; .page ;; @@210d 1
init_sound_sprites                                          ; [910523] ;; @@210d 2
;; init_voices   ;Initialize music stuff ;; @@210d 2
; bit _pal_ntsc  ;determine if PAL or NTSC system  [910724] ;; @@210d 2
; bmi 1$   ;...branch if PAL ;; @@210d 2
; lda #<beats_ntsc/4 ;set beat to quarter note (4/4 time = .5 sec) ;; @@210d 2
; ldy #>beats_ntsc/4 ;; @@210d 2
; bra 2$ ;; @@210d 2
;1$ lda #<beats_pal/4 ;; @@210d 2
; ldy #>beats_pal/4 ;; @@210d 2
;2$ sta ntime ;; @@210d 2
; sty ntime+1 ;; @@210d 2
; ;; @@210d 2
; lda #4   ;set default octave ;; @@210d 2
; sta octave ;; @@210d 2
; ;; @@210d 2
; lda #12   ;set default tempo    [910220] ;; @@210d 2
; sta tempo_rate  ; 12 makes whole note in 4/4 time last 2 seconds ;; @@210d 2
;---- ;; @@210d 2
;; jsr go_slow  ;      [910716] 4567R7A ;; @@210d 2
; lda #0   ;make sure all gates are off ;; @@210d 2
; sta sid1+4 ;; @@210d 2
; sta sid1+11 ;; @@210d 2
; sta sid1+18 ;; @@210d 2
; sta sid2+4 ;; @@210d 2
; sta sid2+11 ;; @@210d 2
; sta sid2+18 ;; @@210d 2
; sta filters1+2  ;set filters off, volume to max????  [910612] ;; @@210d 2
; sta filters2+2 ;; @@210d 2
; ;; @@210d 2
; lda #8 ;; @@210d 2
; sta sid1+24 ;; @@210d 2
; sta sid2+24 ;; @@210d 2
; sta filters1+3 ;; @@210d 2
; sta filters2+3  ;      [910612] ;; @@210d 2
;; sta filters+4  ;why?      [910612] ;; @@210d 2
;; jsr go_fast  ;      [910716] 4567R7A ;; @@210d 2
;---- ;; @@210d 2
; ldy #29   ;initialize music tables ;; @@210d 2
;10$ lda atkmus,y ;; @@210d 2
; sta atktab,y ;; @@210d 2
; dey ;; @@210d 2
; bpl 10$ ;; @@210d 2
; ;; @@210d 2
; ldx #9   ;initialize pulse widths ;; @@210d 2
;20$ lda pwhmus,x ;; @@210d 2
; sta pulshi,x ;; @@210d 2
; dex ;; @@210d 2
; bpl 20$ ;; @@210d 2
; ;; @@210d 2
; stx sound_time_hi ;turn all SOUND counters off (.X = $ff) ;; @@210d 2
; stx sound_time_hi+1 ;; @@210d 2
; stx sound_time_hi+2 ;; @@210d 2
; stx sound_time_hi+3 ;stereo SIDs     [910612] ;; @@210d 2
; stx sound_time_hi+4 ;; @@210d 2
; stx sound_time_hi+5 ;; @@210d 2
; stx voices+1  ;turn all PLAY counters off ;; @@210d 2
; stx voices+3 ;; @@210d 2
; stx voices+5 ;; @@210d 2
; stx voices+7  ;stereo SIDs     [910612] ;; @@210d 2
; stx voices+9 ;; @@210d 2
; stx voices+11 ;; @@210d 2
; ;; @@210d 2
; ldy #6-1  ;set default envelope (piano) for all voices (6) ;; @@210d 2
; sty voice ;; @@210d 2
;30$ ldx #0 ;; @@210d 2
; jsr set_envelope_1 ;; @@210d 2
; dec voice ;; @@210d 2
; bpl 30$ ;; @@210d 2
; inc voice  ;set default voice (0) ;; @@210d 2
;----- ;; @@210d 2
                 jsr Sound_CLR_1                          ; [910724] ;; @@210d 2
 ;; @@2110 2
                 lda #%11100111                           ; [910626] ;; @@2110 2
                 trb helper                               ; reset LIST/HELP/FIND flags ;; @@2112 2
                 tsb highlight_save                       ; mark saved color as invalid ;; @@2114 2
 ;; @@2117 2
                 lda #0                                   ; [910523] F018A ;; @@2117 2
                 ldx #12+12-1                             ; init DMA lists ;; @@2119 2
_local_1001_40   sta dma1_cmd,x                            ;; @@211b 2
                 dex                                       ;; @@211e 2
                 bpl _local_1001_40                        ;; @@211f 2
 ;; @@2121 2
; stop_sprites   ;Stop all moving sprites (a=0)   [910523] ;; @@2121 2
                 ldy #7                                   ; for sprites 0...7 ;; @@2121 2
_local_1001_50   ldx sproff,y                             ; get table offset ;; @@2123 2
                 sta sprite_data,x                        ; reset speed for this sprite ;; @@2126 2
                 dey                                       ;; @@2129 2
                 bpl _local_1001_50                       ; loop until done ;; @@212a 2
 ;; @@212c 2
                 sta vic+21                               ; Turn off all sprites    [910717] ;; @@212c 2
 ;; @@212f 2
                 sta irq_wrap_flag                        ; enable BASIC IRQ handler ;; @@212f 2
; sta nmi_wrap_flag ;enable BASIC NMI handler   [910523] ;; @@2132 2
                 rts                                      ; (removed)    [910826] ;; @@2132 2
 ;; @@2133 2
; .page ;; @@2133 2
signon_message                                             ;; @@2133 3
_local_1002_1    jsr _primm                                ;; @@2133 3
                 !text 147,18,028,"                     ",146,169  ;; @@2136 3
                 !text 5,9,"       THE COMMODORE C65 DEVELOPMENT SYSTEM",cr  ;; @@2150 3
                 !text 18,150,"                  ",146,169,cr  ;; @@217e 3
                 !text 18,158,"               ",146,169    ;; @@2195 3
                 !text 5,9,"   COPYRIGHT  1991  COMMODORE ELECTRONICS, LTD.",cr  ;; @@21a8 3
                 !text 18,030,"            ",146,169       ;; @@21da 3
                 !text 5,9,9,9,"    COPYRIGHT  1977  MICROSOFT",cr  ;; @@21ea 3
                 !text 18,154,"          ",146,169,cr      ;; @@220d 3
                 !text 18,156,"        ",146,169           ;; @@221c 3
                 !text 5,9,9," BASIC 10.0   V0.9B.911119    ALL RIGHTS RESERVED",cr,0  ;; @@2228 3
 ;; @@225e 3
                 rts                                       ;; @@225e 3
 ;; @@225f 3
; .page ;; @@225f 3
init_vectors                                               ;; @@225f 4
                 ldx #_local_1003_3-_local_1003_2-1        ;; @@225f 4
_local_1003_1    lda _local_1003_2,x                       ;; @@2261 4
                 sta vectors_begin,x                       ;; @@2264 4
                 dex                                       ;; @@2267 4
                 bpl _local_1003_1                         ;; @@2268 4
 ;; @@226a 4
                 rts                                       ;; @@226a 4
 ;; @@226b 4
 ;; @@226b 4
_local_1003_2    !word AutoScroll                         ; autoscroll vector ;; @@226b 4
                 !word n_esc_fn_vec                       ; escape function vector ;; @@226d 4
                 !word graphic_kernel                     ; graphic extension vector ;; @@226f 4
                 !word nerror,nmain,ncrnch,nqplop,ngone,neval ; traditional vectors ;; @@2271 4
                 !word nesclk,nescpr,nescex               ; escape command vectors ;; @@227d 4
_local_1003_3                                              ;; @@2283 4
 ;; @@2283 4
; .page ;; @@2283 4
;; CHRGET/CHRGOT code.  It is downloaded to RAM. ;; @@2283 4
;; ;; @@2283 4
;chrget_pattern ;; @@2283 4
; inw txtptr ;CHRGET entry ;; @@2283 4
; phz  ;CHRGOT entry (chrget+2) ;; @@2283 4
; phx ;; @@2283 4
; lda #0 ;; @@2283 4
; ldx #$f0 ;; @@2283 4
; ldy #0 ;; @@2283 4
; ldz #$f0 ;; @@2283 4
; map ;; @@2283 4
; ldy #0 ;; @@2283 4
; lda (txtptr),y ;; @@2283 4
; phy ;; @@2283 4
; pha ;; @@2283 4
; jsr _restore_sys ;; @@2283 4
; nop  ;unmap ;; @@2283 4
; pla ;; @@2283 4
; ply ;; @@2283 4
; plx ;; @@2283 4
; plz ;; @@2283 4
; ;; @@2283 4
; cmp #':' ;QNUM entry (chrget+27) ;; @@2283 4
; bcs _local_1003_2 ;; @@2283 4
; cmp #' ' ;; @@2283 4
; beq chrget_pattern ;; @@2283 4
; sec ;; @@2283 4
; sbc #'0' ;; @@2283 4
; sec ;; @@2283 4
; sbc #$d0 ;; @@2283 4
;_local_1003_2 rts  ;(42 bytes to here) ;; @@2283 4
; ;; @@2283 4
; ;; @@2283 4
; ;; @@2283 4
;; Constants which must be moved to RAM ;; @@2283 4
; ;; @@2283 4
; .byte   0,0,0 ;zero, of course! ;; @@2283 4
; ;; @@2283 4
;endmov   ;(45 bytes to here) ;; @@2283 4
 ;; @@2283 4
; .page ;; @@2283 4
; CHRGET/CHRGOT code. ;; @@2283 4
; ;; @@2283 4
 ;; @@2283 4
chrget           inw txtptr                               ; get next character from text ;; @@2283 5
chrgot           ldy #0                                   ; re-get current character from text ;; @@2285 5
                 jsr indtxt                               ; lda (txtptr),y from RAM0 ;; @@2287 5
qnum             cmp #' '                                  ;; @@228a 5
                 beq chrget                               ; skip spaces ;; @@228c 5
chrtst           cmp #':'                                 ; [910513] ;; @@228e 5
                 bcs _local_1004_10                       ; eol ;; @@2290 5
                 sec                                       ;; @@2292 5
                 sbc #'0'                                 ; alpha or numeric? ;; @@2293 5
                 sec                                       ;; @@2295 5
                 sbc #$d0                                  ;; @@2296 5
_local_1004_10   rts                                       ;; @@2298 5
 ;; @@2299 5
 ;; @@2299 5
;.end ;; @@2299 5
; .page ;; @@2299 5
; C65 BASIC Indirect Load Subroutines ;; @@2299 5
 ;; @@2299 5
 ;; @@2299 5
inddef                                                     ;; @@2299 6
                 lda #defpnt                               ;; @@2299 6
                 bra lda_far_ram1                          ;; @@229b 6
 ;; @@229d 6
indfrm                                                     ;; @@229d 6
                 lda #form                                 ;; @@229d 6
                 bra lda_far_ram1                          ;; @@229f 6
 ;; @@22a1 6
inddpt                                                     ;; @@22a1 6
                 lda #dscpnt                               ;; @@22a1 6
                 bra lda_far_ram1                          ;; @@22a3 6
 ;; @@22a5 6
;indhtr ;; @@22a5 6
; lda #hightr ;; @@22a5 6
; bra lda_far_ram0 ;; @@22a5 6
 ;; @@22a5 6
indhtr_ram1                                                ;; @@22a5 6
                 lda #hightr                               ;; @@22a5 6
                 bra lda_far_ram1                          ;; @@22a7 6
 ;; @@22a9 6
indfmo                                                     ;; @@22a9 6
                 lda #facmo                                ;; @@22a9 6
                 bra lda_far_ram1                          ;; @@22ab 6
 ;; @@22ad 6
indlow                                                     ;; @@22ad 6
                 lda #lowtr                                ;; @@22ad 6
                 bra lda_far_ram0                          ;; @@22af 6
 ;; @@22b1 6
indst1                                                     ;; @@22b1 6
                 lda #strng1                               ;; @@22b1 6
                 bra lda_far_ram0                          ;; @@22b3 6
 ;; @@22b5 6
indst1_ram1                                                ;; @@22b5 6
                 lda #strng1                               ;; @@22b5 6
                 bra lda_far_ram1                          ;; @@22b7 6
 ;; @@22b9 6
indgrb                                                     ;; @@22b9 6
                 lda #grbpnt                               ;; @@22b9 6
                 bra lda_far_ram1                          ;; @@22bb 6
 ;; @@22bd 6
indlow_ram1                                                ;; @@22bd 6
                 lda #lowtr                                ;; @@22bd 6
                 bra lda_far_ram1                          ;; @@22bf 6
 ;; @@22c1 6
indin1                                                     ;; @@22c1 6
                 lda #index1                               ;; @@22c1 6
                 bra lda_far_ram0                          ;; @@22c3 6
 ;; @@22c5 6
;indin2 ;; @@22c5 6
; lda #index2 ;; @@22c5 6
; bra lda_far_ram0 ;; @@22c5 6
 ;; @@22c5 6
indtxt                                                     ;; @@22c5 6
                 lda #txtptr                               ;; @@22c5 6
; bra lda_far_ram0 ;; @@22c7 6
 ;; @@22c7 6
; .page ;; @@22c7 6
; C65 BASIC Indirect Load Subroutines ;; @@22c7 6
 ;; @@22c7 6
lda_far_ram0                                               ;; @@22c7 6
                 phz                                      ; save registers ;; @@22c7 6
                 phx                                       ;; @@22c8 6
                 tax                                      ; pointer ;; @@22c9 6
                 ldz text_bank                            ; RAM0 ;; @@22ca 6
                 jsr _lda_far                             ; LDA (.x),Y from bank .z ;; @@22cd 6
                 plx                                       ;; @@22d0 6
                 plz                                       ;; @@22d1 6
                 and #$ff                                 ; set processor status per byte fetched ;; @@22d2 6
                 rts                                       ;; @@22d4 6
 ;; @@22d5 6
 ;; @@22d5 6
 ;; @@22d5 6
indin1_ram1                                                ;; @@22d5 6
                 lda #index1                               ;; @@22d5 6
; bra lda_far_ram1 ;; @@22d7 6
 ;; @@22d7 6
lda_far_ram1                                               ;; @@22d7 6
                 php                                      ; save .c ;; @@22d7 6
                 phz                                      ; save registers ;; @@22d8 6
                 phx                                       ;; @@22d9 6
                 tax                                      ; pointer ;; @@22da 6
                 ldz var_bank                             ; RAM1 ;; @@22db 6
                 lda 1,x                                  ; check to see if pointer points to "common" ;; @@22de 6
                 cmp #$20                                  ;; @@22e0 6
                 bcs _local_1005_10                       ; branch if not ;; @@22e2 6
                 ldz text_bank                            ; else select RAM0 ;; @@22e4 6
 ;; @@22e7 6
_local_1005_10   jsr _lda_far                             ; LDA (.x),Y from bank .z ;; @@22e7 6
                 plx                                       ;; @@22ea 6
                 plz                                       ;; @@22eb 6
                 plp                                      ; restore .c ;; @@22ec 6
                 and #$ff                                 ; set processor status per byte fetched ;; @@22ed 6
                 rts                                       ;; @@22ef 6
 ;; @@22f0 6
; .page ;; @@22f0 6
; C65 BASIC Indirect Save Subroutines ;; @@22f0 6
 ;; @@22f0 6
sta_far_ram1                                               ;; @@22f0 7
                 php                                      ; save registers ;; @@22f0 7
                 phz                                       ;; @@22f1 7
                 pha                                       ;; @@22f2 7
                 ldz var_bank                             ; RAM1 ;; @@22f3 7
                 lda 1,x                                  ; check to see if pointer points to "common" ;; @@22f6 7
                 cmp #$20                                  ;; @@22f8 7
                 bcs _local_1006_10                       ; branch if not ;; @@22fa 7
                 ldz text_bank                            ; else select RAM0 ;; @@22fc 7
 ;; @@22ff 7
_local_1006_10   pla                                       ;; @@22ff 7
                 jsr _sta_far                             ; STA (.x),Y to bank .z ;; @@2300 7
                 plz                                       ;; @@2303 7
                 plp                                       ;; @@2304 7
                 rts                                       ;; @@2305 7
 ;; @@2306 7
 ;; @@2306 7
sta_far_in1                                               ; [910624] ;; @@2306 8
                 ldx #index1                               ;; @@2306 8
                 bra sta_far_ram0                          ;; @@2308 8
 ;; @@230a 8
sta_far_txt                                                ;; @@230a 8
                 ldx #txtptr                               ;; @@230a 8
 ;; @@230c 8
sta_far_ram0                                               ;; @@230c 8
                 php                                      ; save registers ;; @@230c 8
                 phz                                       ;; @@230d 8
                 ldz text_bank                            ; RAM0 ;; @@230e 8
                 jsr _sta_far                             ; STA (.x),Y to bank .z ;; @@2311 8
                 plz                                       ;; @@2314 8
                 plp                                       ;; @@2315 8
                 rts                                       ;; @@2316 8
 ;; @@2317 8
 ;; @@2317 8
indcmp_in1                                                ; [910620] ;; @@2317 8
                 ldx #index1                               ;; @@2317 8
                 ldz text_bank                            ; RAM0 ;; @@2319 8
                 jmp _cmp_far                             ; STA (.x),Y to bank .z ;; @@231c 8
 ;; @@231f 8
;.end ;; @@231f 8
; .page ;; @@231f 8
; .subttl Crunch - Tokenization Routine ;; @@231f 8
 ;; @@231f 8
;        CRUNCH ;; @@231f 8
; ;; @@231f 8
;  Entry:  TXTPTR points to start of text to crunch ;; @@231f 8
;  Exit:   TXTPTR points to start of crunched text ;; @@231f 8
; ;; @@231f 8
;  Calls:  CHRGET ;; @@231f 8
;          CHRGOT ;; @@231f 8
;          RESER ;; @@231f 8
;          KLOOP ;; @@231f 8
;          REM ;; @@231f 8
;          DATA ;; @@231f 8
; ;; @@231f 8
;  CRUNCH collapses all reserved words into tokens.  It removes all graphic ;; @@231f 8
;  characters (characters with msb set) not in quoted strings, DATA or REM ;; @@231f 8
;  statements. ;; @@231f 8
; ;; @@231f 8
;  An escape token is implemented as follows: ;; @@231f 8
; ;; @@231f 8
; As each character on a line of text to be crunched is scanned, an ;; @@231f 8
; indirect jump is performed.  Anyone wishing to scan for their own ;; @@231f 8
; commands should grab off this vector, saving the return vector. ;; @@231f 8
; On entry, if the carry flag is set, it is still up for grabs. ;; @@231f 8
; The current text pointer is at TXTPTR.  If the escape routine ;; @@231f 8
; recognizes the command, it should: ;; @@231f 8
; ;; @@231f 8
;  ) put the length of the reserved word in .y ;; @@231f 8
;  ) put the desired 'second' token in .a ;; @@231f 8
;  ) clear the carry flag ;; @@231f 8
;  ) put type of token in x: 0==>command, ff==>function ;; @@231f 8
; ;; @@231f 8
; If it is not your command, leave .a and the carry flag intact. ;; @@231f 8
; NOTE:  The reserved word must be >= 2 characters long.  Exit through ;; @@231f 8
; the old vector (for daisy chaining).  If the carry flag is clear on ;; @@231f 8
; entry it means someone else before you recognized this command.  In ;; @@231f 8
; this case, just pass control through the old vector. ;; @@231f 8
 ;; @@231f 8
 ;; @@231f 8
crunch           jmp (icrnch)                              ;; @@231f 8
 ;; @@2322 8
 ;; @@2322 8
ncrnch           phw txtptr                               ; save old text pointer ;; @@2322 8
 ;; @@2325 8
crun05           jsr chrgot                                ;; @@2325 8
                 bra crun20                                ;; @@2328 8
 ;; @@232a 8
crun10           jsr chrget                                ;; @@232a 8
 ;; @@232d 8
 ;; @@232d 8
crun20           bcc crun10                               ; don't crunch numbers ;; @@232d 8
                 jmp (iesclk)                             ; give others a chance at this.  (carry is set) ;; @@232f 8
 ;; @@2332 8
nesclk                                                     ;; @@2332 8
                 +lbcc _local_1007_130                    ; carry clear if someone wanted it ;; @@2332 8
                 cmp #0                                   ; end of line? ;; @@2335 8
                 beq _local_1007_110                      ; yes ;; @@2337 8
                 cmp #':'                                 ; multi-stmt char? ;; @@2339 8
                 beq crun10                               ; yes ;; @@233b 8
                 cmp #'?'                                 ; print ('?') abreviation? ;; @@233d 8
                 bne _local_1007_20                       ; no ;; @@233f 8
                 lda #print_token                         ; yes- substitute print token ;; @@2341 8
                 bra _local_1007_90                        ;; @@2343 8
 ;; @@2345 8
_local_1007_20   cmp #$80                                 ; graphics? ;; @@2345 8
                 bcc _local_1007_30                       ; no ;; @@2347 8
                 cmp #pi                                  ; pi? (special case) ;; @@2349 8
                 beq crun10                               ; yes, leave alone ;; @@234b 8
                 ldy #1                                    ;; @@234d 8
                 jsr kloop                                ; crunch out graphics ;; @@234f 8
                 bra crun05                                ;; @@2352 8
 ;; @@2354 8
 ;; @@2354 8
_local_1007_30   cmp #'"'                                 ; quote string? ;; @@2354 8
                 bne _local_1007_50                       ; no- try escape token ;; @@2356 8
 ;; @@2358 8
_local_1007_40   jsr chrget                                ;; @@2358 8
                 cmp #0                                   ; end of line? ;; @@235b 8
                 beq _local_1007_110                      ; yes ;; @@235d 8
                 cmp #'"'                                 ; close quote? ;; @@235f 8
                 beq crun10                               ; yes ;; @@2361 8
                 bra _local_1007_40                       ; no, continue skipping characters ;; @@2363 8
 ;; @@2365 8
 ;; @@2365 8
; Crunch escape token ;; @@2365 8
 ;; @@2365 8
_local_1007_50   lda #>esc_command_list                   ; look for token in escape-command list ;; @@2365 8
                 ldy #<esc_command_list                    ;; @@2367 8
                 jsr reser                                 ;; @@2369 8
                 bcc _local_1007_60                       ; not found ;; @@236c 8
                 lda #first_esc_command_token+$80-1       ; set up for common escape routine ;; @@236e 8
                 ldx #0                                   ; ..flag 'cmd' type escape ;; @@2370 8
                 bra _local_1007_120                      ; ..and go to it. ;; @@2372 8
 ;; @@2374 8
_local_1007_60   lda #>esc_function_list                  ; look for token in escape-function list ;; @@2374 8
                 ldy #<esc_function_list                   ;; @@2376 8
                 jsr reser                                 ;; @@2378 8
                 bcc _local_1007_70                       ; not found ;; @@237b 8
                 lda #first_esc_function_token+$80-1      ; set up for common escape routine ;; @@237d 8
                 ldx #$ff                                 ; ..flag 'function' type escape ;; @@237f 8
                 bra _local_1007_120                      ; ..and go to it ;; @@2381 8
 ;; @@2383 8
_local_1007_70   lda #>keyword_list                       ; look for token in normal list ;; @@2383 8
                 ldy #<keyword_list                        ;; @@2385 8
                 jsr reser                                 ;; @@2387 8
                 bcc crun10                               ; not found ;; @@238a 8
                 cpy #0                                   ; anything to move? ;; @@238c 8
                 beq _local_1007_80                       ; no ;; @@238e 8
                 jsr kloop                                ; crunch it out ;; @@2390 8
_local_1007_80   lda count                                 ;; @@2393 8
 ;; @@2395 8
_local_1007_90   ldy #0                                    ;; @@2395 8
                 jsr sta_far_txt                          ; put token into text  (bleed-thru) ;; @@2397 8
                 cmp #rem_token                            ;; @@239a 8
                 beq _local_1007_100                       ;; @@239c 8
                 cmp #data_token                           ;; @@239e 8
                 bne crun10                                ;; @@23a0 8
                 jsr chrget                                ;; @@23a2 8
                 jsr data                                  ;; @@23a5 8
                 +lbra crun05                              ;; @@23a8 8
 ;; @@23ab 8
_local_1007_100  jsr chrget                                ;; @@23ab 8
                 jsr rem                                   ;; @@23ae 8
 ;; @@23b1 8
 ;; @@23b1 8
;  No other statements can follow a REM ;; @@23b1 8
 ;; @@23b1 8
_local_1007_110  ldx txtptr                                ;; @@23b1 8
                 pla                                       ;; @@23b3 8
                 sta txtptr+1                              ;; @@23b4 8
                 pla                                       ;; @@23b6 8
                 sta txtptr                                ;; @@23b7 8
                 sec                                      ; compute length of line ;; @@23b9 8
                 txa                                       ;; @@23ba 8
                 sbc txtptr                                ;; @@23bb 8
                 tay                                       ;; @@23bd 8
                 iny                                       ;; @@23be 8
                 rts                                       ;; @@23bf 8
 ;; @@23c0 8
 ;; @@23c0 8
; Crunch out old text, install an escape token ;; @@23c0 8
 ;; @@23c0 8
_local_1007_120  adc count                                ; make pointer into a token ;; @@23c0 8
_local_1007_130  pha                                      ; save second token ;; @@23c2 8
                 dey                                      ; waste (# of chars) - 1 ;; @@23c3 8
                 jsr kloop                                 ;; @@23c4 8
 ;; @@23c7 8
; See if this is function (x=ff) or command (x=0) ;; @@23c7 8
 ;; @@23c7 8
                 lda #esc_command_token                   ; assume command ;; @@23c7 8
                 inx                                       ;; @@23c9 8
                 bne _local_1007_140                      ; branch if command ;; @@23ca 8
                 lda #esc_function_token                  ; ..else get correct token ;; @@23cc 8
 ;; @@23ce 8
_local_1007_140  ldy #0                                    ;; @@23ce 8
                 jsr sta_far_txt                          ; install escape token... (bleed-thru) ;; @@23d0 8
                 iny                                       ;; @@23d3 8
                 pla                                       ;; @@23d4 8
                 jsr sta_far_txt                          ; ..and second token  (bleed-thru) ;; @@23d5 8
                 jsr chrget                               ; skip over token, ;; @@23d8 8
                 +lbra crun10                             ; ..and continue with line. ;; @@23db 8
 ;; @@23de 8
; .page ;; @@23de 8
;      KLOOP ;; @@23de 8
; ;; @@23de 8
;  Crunch loop.  Moves offset .y characters from txtptr to end of line. ;; @@23de 8
;  .x is preserved ;; @@23de 8
 ;; @@23de 8
kloop            clc                                      ; compute source address ;; @@23de 9
                 tya                                       ;; @@23df 9
                 adc txtptr                                ;; @@23e0 9
                 sta index1                                ;; @@23e2 9
                 lda txtptr+1                              ;; @@23e4 9
                 adc #0                                    ;; @@23e6 9
                 sta index1+1                              ;; @@23e8 9
                 ldy #$ff                                  ;; @@23ea 9
 ;; @@23ec 9
_local_1008_10   iny                                       ;; @@23ec 9
                 lda (index1),y                           ; move source..  ????assumes text in common area ;; @@23ed 9
                 sta (txtptr),y                           ; to destination offset ????assumes text in common area ;; @@23ef 9
                 bne _local_1008_10                       ; not end of line ;; @@23f1 9
                 rts                                       ;; @@23f3 9
 ;; @@23f4 9
; .page ;; @@23f4 9
;      RESER ;; @@23f4 9
; ;; @@23f4 9
;  Search reserved word list for a match ;; @@23f4 9
; ;; @@23f4 9
;  Entry:  (txtptr) is first char of word to match ;; @@23f4 9
;    (y,a) is start of table to check ;; @@23f4 9
; ;; @@23f4 9
;  Exit:   .y  length of word matched ;; @@23f4 9
;    .c  success/fail (set/clear) flag ;; @@23f4 9
;    count token value ;; @@23f4 9
 ;; @@23f4 9
reser            sta index1+1                              ;; @@23f4 10
                 sty index1                                ;; @@23f6 10
                 ldy #0                                    ;; @@23f8 10
                 sty count                                 ;; @@23fa 10
                 dey                                       ;; @@23fc 10
_local_1009_10   iny                                       ;; @@23fd 10
_local_1009_20   lda (txtptr),y                           ; assumes common memory ;; @@23fe 10
                 bmi _local_1009_70                       ; abrieviation    [900510] ;; @@2400 10
                 sec                                       ;; @@2402 10
                 sbc (index1),y                           ; does letter match? (ind.ok) ;; @@2403 10
                 beq _local_1009_10                       ; yes...continue ;; @@2405 10
                 cmp #$80                                 ; end of word? ;; @@2407 10
                 beq _local_1009_60                       ; yes...c set...done ;; @@2409 10
 ;; @@240b 10
 ;; @@240b 10
;  find next word ;; @@240b 10
 ;; @@240b 10
_local_1009_30   lda (index1),y                           ; ind.ok ;; @@240b 10
                 bmi _local_1009_40                       ; found end of current ;; @@240d 10
                 iny                                       ;; @@240f 10
                 bne _local_1009_30                        ;; @@2410 10
_local_1009_40   iny                                      ; start of next ;; @@2412 10
                 inc count                                ; value of token ;; @@2413 10
                 clc                                       ;; @@2415 10
                 tya                                       ;; @@2416 10
                 adc index1                                ;; @@2417 10
                 sta index1                                ;; @@2419 10
                 bcc _local_1009_50                        ;; @@241b 10
                 inc index1+1                              ;; @@241d 10
_local_1009_50   clc                                       ;; @@241f 10
                 ldy #0                                    ;; @@2420 10
                 lda (index1),y                           ; end of list? ind.ok ;; @@2422 10
                 bne _local_1009_20                       ; no ;; @@2424 10
 ;; @@2426 10
 ;; @@2426 10
;  yes...carry clear...fail ;; @@2426 10
 ;; @@2426 10
_local_1009_60   ora count                                ; .a=$80 if match ;; @@2426 10
                 sta count                                ; token is formed ;; @@2428 10
                 rts                                       ;; @@242a 10
 ;; @@242b 10
 ;; @@242b 10
; special case- last character is shifted (necessary for 'diR' compatibility) ;; @@242b 10
 ;; @@242b 10
_local_1009_70   sec                                      ; allow last chr to be shifted   [900510] ;; @@242b 10
                 sbc (index1),y                           ; does letter match? (ind.ok) ;; @@242c 10
                 beq _local_1009_80                       ; yes- end of word ;; @@242e 10
                 cmp #$80                                 ; end of word? ;; @@2430 10
                 beq _local_1009_60                       ; yes ;; @@2432 10
                 bne _local_1009_30                       ; no- next word ;; @@2434 10
 ;; @@2436 10
_local_1009_80   lda #$80                                 ; last chr is shifted & so is end of current word ;; @@2436 10
                 bra _local_1009_60                        ;; @@2438 10
 ;; @@243a 10
;.end ;; @@243a 10
; .page ;; @@243a 10
; .subttl Non-Escape Keyword List ;; @@243a 10
 ;; @@243a 10
keyword_list                                               ;; @@243a 11
                 !text "EN",'D'+$80                       ; $80 ;; @@243a 11
                 !text "FO",'R'+$80                       ; $81 ;; @@243d 11
                 !text "NEX",'T'+$80                      ; $82 ;; @@2440 11
                 !text "DAT",'A'+$80                      ; $83 ;; @@2444 11
                 !text "INPUT",'#'+$80                    ; $84 ;; @@2448 11
                 !text "INPU",'T'+$80                     ; $85 ;; @@244e 11
                 !text "DI",'M'+$80                       ; $86 ;; @@2453 11
                 !text "REA",'D'+$80                      ; $87 ;; @@2456 11
                 !text "LE",'T'+$80                       ; $88 ;; @@245a 11
                 !text "GOT",'O'+$80                      ; $89 ;; @@245d 11
                 !text "RU",'N'+$80                       ; $8A ;; @@2461 11
                 !text "I",'F'+$80                        ; $8B ;; @@2464 11
                 !text "RESTOR",'E'+$80                   ; $8C ;; @@2466 11
                 !text "GOSU",'B'+$80                     ; $8D ;; @@246d 11
                 !text "RETUR",'N'+$80                    ; $8E ;; @@2472 11
                 !text "RE",'M'+$80                       ; $8F ;; @@2478 11
                 !text "STO",'P'+$80                      ; $90 ;; @@247b 11
                 !text "O",'N'+$80                        ; $91 ;; @@247f 11
                 !text "WAI",'T'+$80                      ; $92 ;; @@2481 11
                 !text "LOA",'D'+$80                      ; $93 ;; @@2485 11
                 !text "SAV",'E'+$80                      ; $94 ;; @@2489 11
                 !text "VERIF",'Y'+$80                    ; $95 ;; @@248d 11
                 !text "DE",'F'+$80                       ; $96 ;; @@2493 11
                 !text "POK",'E'+$80                      ; $97 ;; @@2496 11
                 !text "PRINT",'#'+$80                    ; $98 ;; @@249a 11
                 !text "PRIN",'T'+$80                     ; $99 ;; @@24a0 11
                 !text "CON",'T'+$80                      ; $9A ;; @@24a5 11
                 !text "LIS",'T'+$80                      ; $9B ;; @@24a9 11
                 !text "CL",'R'+$80                       ; $9C ;; @@24ad 11
                 !text "CM",'D'+$80                       ; $9D ;; @@24b0 11
                 !text "SY",'S'+$80                       ; $9E ;; @@24b3 11
                 !text "OPE",'N'+$80                      ; $9F ;; @@24b6 11
                 !text "CLOS",'E'+$80                     ; $A0 ;; @@24ba 11
                 !text "GE",'T'+$80                       ; $A1 ;; @@24bf 11
                 !text "NE",'W'+$80                       ; $A2 ;; @@24c2 11
                 !text "TAB",'('+$80                      ; $A3 ;; @@24c5 11
                 !text "T",'O'+$80                        ; $A4 ;; @@24c9 11
                 !text "F",'N'+$80                        ; $A5 ;; @@24cb 11
                 !text "SPC",'('+$80                      ; $A6 ;; @@24cd 11
                 !text "THE",'N'+$80                      ; $A7 ;; @@24d1 11
                 !text "NO",'T'+$80                       ; $A8 ;; @@24d5 11
                 !text "STE",'P'+$80                      ; $A9 ;; @@24d8 11
                 !text '+'+$80                            ; $AA operators ;; @@24dc 11
                 !text '-'+$80                            ; $AB ;; @@24dd 11
                 !text '*'+$80                            ; $AC ;; @@24de 11
                 !text '/'+$80                            ; $AD ;; @@24df 11
                 !text '^'+$80                            ; $AE ;; @@24e0 11
                 !text "AN",'D'+$80                       ; $AF ;; @@24e1 11
                 !text "O",'R'+$80                        ; $B0 ;; @@24e4 11
                 !text '>'+$80                            ; $B1 ;; @@24e6 11
                 !text '='+$80                            ; $B2 ;; @@24e7 11
                 !text '<'+$80                            ; $B3 ;; @@24e8 11
                 !text "SG",'N'+$80                       ; $B4 first numeric function ;; @@24e9 11
                 !text "IN",'T'+$80                       ; $B5 ;; @@24ec 11
                 !text "AB",'S'+$80                       ; $B6 ;; @@24ef 11
                 !text "US",'R'+$80                       ; $B7 ;; @@24f2 11
                 !text "FR",'E'+$80                       ; $B8 ;; @@24f5 11
                 !text "PO",'S'+$80                       ; $B9 ;; @@24f8 11
                 !text "SQ",'R'+$80                       ; $BA ;; @@24fb 11
                 !text "RN",'D'+$80                       ; $BB ;; @@24fe 11
                 !text "LO",'G'+$80                       ; $BC ;; @@2501 11
                 !text "EX",'P'+$80                       ; $BD ;; @@2504 11
                 !text "CO",'S'+$80                       ; $BE ;; @@2507 11
                 !text "SI",'N'+$80                       ; $BF ;; @@250a 11
                 !text "TA",'N'+$80                       ; $C0 ;; @@250d 11
                 !text "AT",'N'+$80                       ; $C1 ;; @@2510 11
                 !text "PEE",'K'+$80                      ; $C2 ;; @@2513 11
                 !text "LE",'N'+$80                       ; $C3 ;; @@2517 11
                 !text "STR",'$'+$80                      ; $C4 ;; @@251a 11
                 !text "VA",'L'+$80                       ; $C5 ;; @@251e 11
                 !text "AS",'C'+$80                       ; $C6 last numeric function ;; @@2521 11
                 !text "CHR",'$'+$80                      ; $C7 last single-arg function ;; @@2524 11
                 !text "LEFT",'$'+$80                     ; $C8 ;; @@2528 11
                 !text "RIGHT",'$'+$80                    ; $C9 ;; @@252d 11
                 !text "MID",'$'+$80                      ; $CA ;; @@2533 11
                 !text "G",'O'+$80                        ; $CB ;; @@2537 11
; beginning of new C128 keywords------------ ;; @@2539 11
                 !text "RGRAPHI",'C'+$80                  ; $CC was 'rgr'   [910701] ;; @@2539 11
                 !text "RCOLO",'R'+$80                    ; $CD was 'rclr'   [910701] ;; @@2541 11
                 !text $80                                ; $CE null to skip over escape_function token ;; @@2547 11
                 !text "JO",'Y'+$80                       ; $CF ;; @@2548 11
                 !text "RPE",'N'+$80                      ; $D0 (was rdot in c128) ;; @@254b 11
                 !text "DE",'C'+$80                       ; $D1 ;; @@254f 11
                 !text "HEX",'$'+$80                      ; $D2 ;; @@2552 11
                 !text "ERR",'$'+$80                      ; $D3 ;; @@2556 11
                 !text "INST",'R'+$80                     ; $D4 last function ;; @@255a 11
 ;; @@255f 11
                 !text "ELS",'E'+$80                      ; $D5 ;; @@255f 11
                 !text "RESUM",'E'+$80                    ; $D6 ;; @@2563 11
                 !text "TRA",'P'+$80                      ; $D7 ;; @@2569 11
                 !text "TRO",'N'+$80                      ; $D8 ;; @@256d 11
                 !text "TROF",'F'+$80                     ; $D9 ;; @@2571 11
                 !text "SOUN",'D'+$80                     ; $DA ;; @@2576 11
                 !text "VO",'L'+$80                       ; $DB ;; @@257b 11
                 !text "AUT",'O'+$80                      ; $DC ;; @@257e 11
                 !text "PUDE",'F'+$80                     ; $DD ;; @@2582 11
                 !text "GRAPHI",'C'+$80                   ; $DE ;; @@2587 11
                 !text "PAIN",'T'+$80                     ; $DF ;; @@258e 11
                 !text "CHA",'R'+$80                      ; $E0 ;; @@2593 11
                 !text "BO",'X'+$80                       ; $E1 ;; @@2597 11
                 !text "CIRCL",'E'+$80                    ; $E2 ;; @@259a 11
                 !text "PAST",'E'+$80                     ; $E3 (was gshape in C128) ;; @@25a0 11
                 !text "CU",'T'+$80                       ; $E4 (was sshape in C128) ;; @@25a5 11
                 !text "LIN",'E'+$80                      ; $E5 (was draw in C128) ;; @@25a8 11
                 !text "LOCAT",'E'+$80                    ; $E6 ;; @@25ac 11
                 !text "COLO",'R'+$80                     ; $E7 ;; @@25b2 11
                 !text "SCNCL",'R'+$80                    ; $E8 ;; @@25b7 11
                 !text "SCAL",'E'+$80                     ; $E9 ;; @@25bd 11
                 !text "HEL",'P'+$80                      ; $EA ;; @@25c2 11
                 !text "D",'O'+$80                        ; $EB ;; @@25c6 11
                 !text "LOO",'P'+$80                      ; $EC ;; @@25c8 11
                 !text "EXI",'T'+$80                      ; $ED ;; @@25cc 11
                 !text "DI",'R'+$80                       ; $EE ;; @@25d0 11
                 !text "DSAV",'E'+$80                     ; $EF ;; @@25d3 11
                 !text "DLOA",'D'+$80                     ; $F0 ;; @@25d8 11
                 !text "HEADE",'R'+$80                    ; $F1 ;; @@25dd 11
                 !text "SCRATC",'H'+$80                   ; $F2 ;; @@25e3 11
                 !text "COLLEC",'T'+$80                   ; $F3 ;; @@25ea 11
                 !text "COP",'Y'+$80                      ; $F4 ;; @@25f1 11
                 !text "RENAM",'E'+$80                    ; $F5 ;; @@25f5 11
                 !text "BACKU",'P'+$80                    ; $F6 ;; @@25fb 11
                 !text "DELET",'E'+$80                    ; $F7 ;; @@2601 11
                 !text "RENUMBE",'R'+$80                  ; $F8 ;; @@2607 11
                 !text "KE",'Y'+$80                       ; $F9 ;; @@260f 11
                 !text "MONITO",'R'+$80                   ; $FA ;; @@2612 11
                 !text "USIN",'G'+$80                     ; $FB ;; @@2619 11
                 !text "UNTI",'L'+$80                     ; $FC ;; @@261e 11
                 !text "WHIL",'E'+$80                     ; $FD ;; @@2623 11
                 !text 0                                  ; $FE skip over the escape_command token ;; @@2628 11
 ;; @@2629 11
;.end ;; @@2629 11
 ;; @@2629 11
; .page ;; @@2629 11
; .subttl Escape Tokens and Keywords ;; @@2629 11
 ;; @@2629 11
; Escape Command Tokens ;; @@2629 11
 ;; @@2629 11
esc_command_list                                           ;; @@2629 11
                 !text "BAN",'K'+$80                      ; $02: set bank number ;; @@2629 11
                 !text "FILTE",'R'+$80                    ; $03: set up filter ;; @@262d 11
                 !text "PLA",'Y'+$80                      ; $04: play a tune ;; @@2633 11
                 !text "TEMP",'O'+$80                     ; $05: set rate for playing ;; @@2637 11
                 !text "MOVSP",'R'+$80                    ; $06: sprite position/movement ;; @@263c 11
                 !text "SPRIT",'E'+$80                    ; $07: turn on/set up sprite ;; @@2642 11
                 !text "SPRCOLO",'R'+$80                  ; $08: set sprite multicolor registers ;; @@2648 11
                 !text "RRE",'G'+$80                      ; $09: retreive register values after 'SYS' ;; @@2650 11
                 !text "ENVELOP",'E'+$80                  ; $0A: set up SID envelopes ;; @@2654 11
                 !text "SLEE",'P'+$80                     ; $0B: delay ;; @@265c 11
                 !text "CATALO",'G'+$80                   ; $0C: disk directory ;; @@2661 11
                 !text "DOPE",'N'+$80                     ; $0D: open a disk file ;; @@2668 11
                 !text "APPEN",'D'+$80                    ; $0E: open a disk file for appending ;; @@266d 11
                 !text "DCLOS",'E'+$80                    ; $0F: close a file opened w/ DOPEN ;; @@2673 11
                 !text "BSAV",'E'+$80                     ; $10: binary (non-program) save ;; @@2679 11
                 !text "BLOA",'D'+$80                     ; $11: binary load ;; @@267e 11
                 !text "RECOR",'D'+$80                    ; $12: ;; @@2683 11
                 !text "CONCA",'T'+$80                    ; $13: concatenate 2 files ;; @@2689 11
                 !text "DVERIF",'Y'+$80                   ; $14: verify a saved program ;; @@268f 11
                 !text "DCLEA",'R'+$80                    ; $15: re-initialize a drive ;; @@2696 11
                 !text "SPRSA",'V'+$80                    ; $16: sprite/string to sprite/string ;; @@269c 11
                 !text "COLLISIO",'N'+$80                 ; $17: set traps for sprite & light pen collisions ;; @@26a2 11
                 !text "BEGI",'N'+$80                     ; $18: mark start of a b-block ;; @@26ab 11
                 !text "BEN",'D'+$80                      ; $19: ..and its end, too! ;; @@26b0 11
                 !text "WINDO",'W'+$80                    ; $1A: set screen window ;; @@26b4 11
                 !text "BOO",'T'+$80                      ; $1B: load&run ML or autoboot a disk ;; @@26ba 11
                 !text "WIDT",'H'+$80                     ; $1C: single/double width drawing ;; @@26be 11
                 !text "SPRDE",'F'+$80                    ; $1D: define a sprite ;; @@26c3 11
                 !text "QUI",'T'+$80                      ; $1E: (UNIMPLEMENTED) ;; @@26c9 11
                 !text "DM",'A'+$80                       ; $1F: access memory ;; @@26cd 11
                 !text ' '+$80                            ; $20: POISON - space character ;; @@26d0 11
                 !text "DM",'A'+$80                       ; $21: access memory ;; @@26d1 11
                 !text ' '+$80                            ; $22: POISON - quote character ;; @@26d4 11
                 !text "DM",'A'+$80                       ; $23: access memory ;; @@26d5 11
                 !text "OF",'F'+$80                       ; $24: KEY OFF ;; @@26d8 11
                 !text "FAS",'T'+$80                      ; $25: go to 2 MHz. mode ;; @@26db 11
                 !text "SLO",'W'+$80                      ; $26: go to 1 MHz. mode ;; @@26df 11
                 !text "TYP",'E'+$80                      ; $27: type SEQ file ;; @@26e3 11
                 !text "BVERIF",'Y'+$80                   ; $28: verify a saved program ;; @@26e7 11
                 !text "ECTOR",'Y'+$80                    ; $29: dirECTORY ;; @@26ee 11
                 !text "ERAS",'E'+$80                     ; $2A: alias for scratch ;; @@26f4 11
                 !text "FIN",'D'+$80                      ; $2B: find string ;; @@26f9 11
                 !text "CHANG",'E'+$80                    ; $2C: change string ;; @@26fd 11
                 !text "SE",'T'+$80                       ; $2D: ;; @@2703 11
                 !text "SCREE",'N'+$80                    ; $2E: ;; @@2706 11
                 !text "POLYGO",'N'+$80                   ; $2F: ;; @@270c 11
                 !text "ELLIPS",'E'+$80                   ; $30: ;; @@2713 11
                 !text "VIEWPOR",'T'+$80                  ; $31: ;; @@271a 11
                 !text "GCOP",'Y'+$80                     ; $32: ;; @@2722 11
                 !text "PE",'N'+$80                       ; $33: ;; @@2727 11
                 !text "PALETT",'E'+$80                   ; $34: ;; @@272a 11
                 !text "DMOD",'E'+$80                     ; $35: ;; @@2731 11
                 !text "DPA",'T'+$80                      ; $36: ;; @@2736 11
                 !text "FORMA",'T'+$80                    ; $37: alias for HEADER command  [911017] ;; @@273a 11
                 !text "GENLOC",'K'+$80                   ; $38:     [910108] ;; @@2740 11
                 !text "FOREGROUN",'D'+$80                ; $39:     [910109] ;; @@2747 11
                 !text ' '+$80                            ; $3A: POISON - colon character  " ;; @@2751 11
                 !text "BACKGROUN",'D'+$80                ; $3B:     " ;; @@2752 11
                 !text "BORDE",'R'+$80                    ; $3C:     " ;; @@275c 11
                 !text "HIGHLIGH",'T'+$80                 ; $3D:     " ;; @@2762 11
                 !text "MOUS",'E'+$80                     ; $3E:     [910122] ;; @@276b 11
                 !text "RMOUS",'E'+$80                    ; $3F: return coordinates of mouse [910123] ;; @@2770 11
                 !text "DIS",'K'+$80                      ; $40:     [910123] ;; @@2776 11
                 !text "CURSO",'R'+$80                    ; $41:     [910228] ;; @@277a 11
                 !text "RCURSO",'R'+$80                   ; $42: return cursor position  [910228] ;; @@2780 11
                 !text "LOADIF",'F'+$80                   ; $43: load IFF picture from disk [910402] ;; @@2787 11
                 !text "SAVEIF",'F'+$80                   ; $44: save IFF picture to   disk [910402] ;; @@278e 11
                 !text "EDI",'T'+$80                      ; $45: Edit mode on/off   [910620] ;; @@2795 11
 ;; @@2799 11
                 !text 0                                  ; End marker ;; @@2799 11
;(don't forget to change last_command_token!) ;; @@279a 11
; .page ;; @@279a 11
; Escape Function Tokens ;; @@279a 11
 ;; @@279a 11
esc_function_list                                           ;; @@279a 11
                 !text "PO",'T'+$80                       ; $02: return paddle value ;; @@279a 11
                 !text "BUM",'P'+$80                      ; $03: read sprite collision ;; @@279d 11
                 !text "LPE",'N'+$80                      ; $04: read light pen value ;; @@27a1 11
                 !text "RSPPO",'S'+$80                    ; $05: read sprite position ;; @@27a5 11
                 !text "RSPRIT",'E'+$80                   ; $06: read sprite value ;; @@27ab 11
                 !text "RSPCOLO",'R'+$80                  ; $07: read sprite multicolor value ;; @@27b2 11
                 !text "XO",'R'+$80                       ; $08: exclusive or ;; @@27ba 11
                 !text "RWINDO",'W'+$80                   ; $09: read window size ;; @@27bd 11
                 !text "POINTE",'R'+$80                   ; $0a: return address of descriptor ;; @@27c4 11
                 !text "MO",'D'+$80                       ; $0b: modulus    [910402] ;; @@27cb 11
                 !text "PIXE",'L'+$80                     ; $0c: return BP data at pixel  [910820] ;; @@27ce 11
                 !text "RPALETT",'E'+$80                  ; $0d: return RGB component of color [910820] ;; @@27d3 11
                 !text 0                                   ;; @@27db 11
 ;; @@27dc 11
;.end ;; @@27dc 11
; .page ;; @@27dc 11
; .subttl Jump Table For Dispatch Routine ;; @@27dc 11
stmdsp                                                     ;; @@27dc 11
                 !word end-1                               ;; @@27dc 11
                 !word for-1                               ;; @@27de 11
                 !word next-1                              ;; @@27e0 11
                 !word data-1                              ;; @@27e2 11
                 !word inputn-1                            ;; @@27e4 11
                 !word input-1                             ;; @@27e6 11
                 !word dim-1                               ;; @@27e8 11
                 !word read-1                              ;; @@27ea 11
                 !word let-1                               ;; @@27ec 11
                 !word goto-1                              ;; @@27ee 11
                 !word run-1                               ;; @@27f0 11
                 !word if-1                                ;; @@27f2 11
                 !word restor-1                            ;; @@27f4 11
                 !word gosub-1                             ;; @@27f6 11
                 !word return-1                            ;; @@27f8 11
                 !word rem-1                               ;; @@27fa 11
                 !word stop-1                              ;; @@27fc 11
                 !word ongoto-1                            ;; @@27fe 11
                 !word wait-1                              ;; @@2800 11
                 !word load-1                              ;; @@2802 11
                 !word save-1                              ;; @@2804 11
                 !word verify-1                            ;; @@2806 11
                 !word def-1                               ;; @@2808 11
                 !word poke-1                              ;; @@280a 11
                 !word printn-1                            ;; @@280c 11
                 !word print-1                             ;; @@280e 11
                 !word cont-1                              ;; @@2810 11
                 !word list-1                              ;; @@2812 11
                 !word clear-1                             ;; @@2814 11
                 !word cmd-1                               ;; @@2816 11
                 !word sys-1                               ;; @@2818 11
                 !word open-1                              ;; @@281a 11
                 !word close-1                             ;; @@281c 11
                 !word get-1                               ;; @@281e 11
                 !word new-1                               ;; @@2820 11
 ;; @@2822 11
                 !word else-1                              ;; @@2822 11
                 !word resume-1                            ;; @@2824 11
                 !word trap-1                              ;; @@2826 11
                 !word tron-1                              ;; @@2828 11
                 !word troff-1                             ;; @@282a 11
                 !word sound-1                             ;; @@282c 11
                 !word volume-1                            ;; @@282e 11
                 !word auto-1                              ;; @@2830 11
                 !word puctrl-1                            ;; @@2832 11
                 !word graphic-1                           ;; @@2834 11
 ;; @@2836 11
                 !word C65__paint-1                        ;; @@2836 11
                 !word C65__char-1                         ;; @@2838 11
                 !word C65__box-1                          ;; @@283a 11
                 !word C65__circle-1                       ;; @@283c 11
                 !word C65__paste-1                       ; gshape ;; @@283e 11
                 !word C65__cut-1                         ; sshape ;; @@2840 11
                 !word C65__line-1                        ; draw ;; @@2842 11
 ;; @@2844 11
                 !word bad_command-1                      ; escape - SYSTEM - unimplemented command ;; @@2844 11
; .word  locate-1 ;; @@2846 11
 ;; @@2846 11
                 !word color-1                             ;; @@2846 11
                 !word scnclr-1                            ;; @@2848 11
 ;; @@284a 11
                 !word bad_command-1                      ; escape - SYSTEM - unimplemented command ;; @@284a 11
; .word  scale-1 ;; @@284c 11
 ;; @@284c 11
                 !word help-1                              ;; @@284c 11
                 !word do-1                                ;; @@284e 11
                 !word loop-1                              ;; @@2850 11
                 !word exit-1                              ;; @@2852 11
                 !word directory-1                         ;; @@2854 11
                 !word dsave-1                             ;; @@2856 11
                 !word dload-1                             ;; @@2858 11
                 !word header-1                            ;; @@285a 11
                 !word scratch-1                           ;; @@285c 11
                 !word collect-1                           ;; @@285e 11
                 !word dcopy-1                             ;; @@2860 11
                 !word rename-1                            ;; @@2862 11
                 !word backup-1                            ;; @@2864 11
                 !word delete-1                            ;; @@2866 11
                 !word renumber-1                          ;; @@2868 11
                 !word key-1                               ;; @@286a 11
                 !word _monitor-1                          ;; @@286c 11
                 !word bank-1                             ; escape ;; @@286e 11
                 !word filter-1                           ; escape ;; @@2870 11
                 !word play-1                             ; escape ;; @@2872 11
                 !word tempo-1                            ; escape ;; @@2874 11
 ;; @@2876 11
                 !word movspr-1                           ; escape ;; @@2876 11
                 !word sprite-1                           ; escape ;; @@2878 11
                 !word sprcolor-1                         ; escape ;; @@287a 11
 ;; @@287c 11
                 !word rreg-1                             ; escape ;; @@287c 11
                 !word envelope-1                         ; escape ;; @@287e 11
                 !word sleep-1                            ; escape ;; @@2880 11
                 !word directory-1                        ; escape ;; @@2882 11
                 !word dopen-1                            ; escape ;; @@2884 11
                 !word append-1                           ; escape ;; @@2886 11
                 !word dclose-1                           ; escape ;; @@2888 11
                 !word bsave-1                            ; escape ;; @@288a 11
                 !word bload-1                            ; escape ;; @@288c 11
                 !word record-1                           ; escape ;; @@288e 11
                 !word concat-1                           ; escape ;; @@2890 11
                 !word dverify-1                          ; escape ;; @@2892 11
                 !word dclear-1                           ; escape ;; @@2894 11
 ;; @@2896 11
                 !word sprsav-1                           ; escape ;; @@2896 11
                 !word collision-1                        ; escape ;; @@2898 11
 ;; @@289a 11
                 !word data-1                             ; escape - BEGIN ;; @@289a 11
                 !word data-1                             ; escape - BEND ;; @@289c 11
                 !word window-1                           ; escape ;; @@289e 11
                 !word boot-1                             ; escape ;; @@28a0 11
 ;; @@28a2 11
                 !word bad_command-1                       ;; @@28a2 11
; .word  set_width-1 ;escape - WIDTH ;; @@28a4 11
 ;; @@28a4 11
                 !word bad_command-1                       ;; @@28a4 11
; .word  sprdef-1  ;escape - Sprite Definition mode ;; @@28a6 11
 ;; @@28a6 11
                 !word bad_command-1                      ; escape - QUIT - unimplemented command ;; @@28a6 11
                 !word dma-1                              ; escape ;; @@28a8 11
                 !word 0                                  ; placeholder to skip over the space character ;; @@28aa 11
                 !word dma-1                              ; escape ;; @@28ac 11
                 !word 0                                  ; placeholder to skip over the quote character ;; @@28ae 11
                 !word dma-1                              ; escape ;; @@28b0 11
                 !word bad_command-1                      ; escape - OFF - unimplemented command ;; @@28b2 11
                 !word fast-1                             ; escape ;; @@28b4 11
                 !word slow-1                             ; escape ;; @@28b6 11
                 !word type-1                             ; escape (C65: type SEQ file) ;; @@28b8 11
                 !word bverify-1                          ; escape (C65: verify BINary file) ;; @@28ba 11
                 !word snerr-1                            ; escape (C65: kludge- dirECTORY) ;; @@28bc 11
                 !word scratch-1                          ; escape (C65: erase alias for scratch) ;; @@28be 11
                 !word find-1                             ; escape (C65: find BASIC text) ;; @@28c0 11
                 !word change-1                           ; escape (C65: change BASIC text) ;; @@28c2 11
 ;; @@28c4 11
                 !word C65__set-1                         ; escape (C65: multi-purpose command) ;; @@28c4 11
                 !word Screen-1                           ; escape (C65: SCREEN) ;; @@28c6 11
                 !word C65__polygon-1                     ; escape (C65: POLYGON) ;; @@28c8 11
                 !word C65__ellipse-1                     ; escape (C65: ELLIPSE) ;; @@28ca 11
                 !word C65__Viewport-1                    ; escape (C65: VIEWPORT) ;; @@28cc 11
                 !word C65__copy-1                        ; escape (C65: GCOPY) ;; @@28ce 11
                 !word C65__setpen-1                      ; escape (C65: PEN) ;; @@28d0 11
                 !word C65__setpalette-1                  ; escape (C65: PALETTE) ;; @@28d2 11
                 !word C65__setdmode-1                    ; escape (C65: DMODE) ;; @@28d4 11
                 !word C65__setdpat-1                     ; escape (C65: DPAT) ;; @@28d6 11
                 !word header-1                           ; format alias for header command [911017] ;; @@28d8 11
                 !word genlock-1                          ; [910108] ;; @@28da 11
 ;; @@28dc 11
stmdsp2                                                    ;; @@28dc 11
                 !word foreground-1                       ; this is the 128th command!  [910109] ;; @@28dc 11
                 !word 0                                  ; placeholder to skip over the colon character ;; @@28de 11
                 !word background-1                        ;; @@28e0 11
                 !word border-1                            ;; @@28e2 11
                 !word highlight-1                         ;; @@28e4 11
                 !word mouse-1                            ; [910122] ;; @@28e6 11
                 !word rmouse-1                           ; [910123] ;; @@28e8 11
                 !word disk-1                             ; [910123] ;; @@28ea 11
                 !word cursor-1                           ; [910228] ;; @@28ec 11
                 !word rcursor-1                          ; [910228] ;; @@28ee 11
                 !word loadiff-1                          ; [910402] ;; @@28f0 11
                 !word saveiff-1                          ; [910930] ;; @@28f2 11
                 !word edit-1                             ; [910620] ;; @@28f4 11
 ;; @@28f6 11
; .page ;; @@28f6 11
fundsp                                                     ;; @@28f6 11
                 !word sgn                                 ;; @@28f6 11
                 !word int                                 ;; @@28f8 11
                 !word abs                                 ;; @@28fa 11
                 !word usrpok                              ;; @@28fc 11
                 !word fre                                 ;; @@28fe 11
                 !word pos                                 ;; @@2900 11
                 !word sqr                                 ;; @@2902 11
                 !word rnd                                 ;; @@2904 11
                 !word log                                 ;; @@2906 11
                 !word exp                                 ;; @@2908 11
                 !word cos                                 ;; @@290a 11
                 !word sin                                 ;; @@290c 11
                 !word tan                                 ;; @@290e 11
                 !word atn                                 ;; @@2910 11
                 !word peek                                ;; @@2912 11
                 !word len                                 ;; @@2914 11
                 !word strd                                ;; @@2916 11
                 !word val                                 ;; @@2918 11
                 !word asc                                 ;; @@291a 11
                 !word chrd                                ;; @@291c 11
                 !word leftd                               ;; @@291e 11
                 !word rightd                              ;; @@2920 11
                 !word midd                                ;; @@2922 11
                 !word rgraphic                           ; [910701] ;; @@2924 11
                 !word rcolor                             ; [910701] ;; @@2926 11
                 !word 0                                  ; placeholder for escape function token ;; @@2928 11
                 !word joy                                 ;; @@292a 11
                 !word rpen                               ; was rdot     [910820] ;; @@292c 11
                 !word dcml                               ; dec ;; @@292e 11
                 !word hexd                                ;; @@2930 11
                 !word errd                                ;; @@2932 11
                 !word pot                                ; escape ;; @@2934 11
                 !word bump                               ; escape ;; @@2936 11
                 !word lpen                               ; escape ;; @@2938 11
                 !word rsppos                             ; escape ;; @@293a 11
                 !word rsprite                            ; escape ;; @@293c 11
                 !word rspcolor                           ; escape ;; @@293e 11
                 !word xor                                ; escape ;; @@2940 11
                 !word rwindow                            ; escape ;; @@2942 11
                 !word pointer                            ; escape ;; @@2944 11
                 !word mod                                ; escape c65     [910402] ;; @@2946 11
                 !word pixel                              ; escape c65     [910820] ;; @@2948 11
                 !word rpalette                           ; escape c65     [910820] ;; @@294a 11
 ;; @@294c 11
; .page ;; @@294c 11
optab            !text 121                                 ;; @@294c 11
                 !word faddt-1                             ;; @@294d 11
                 !text 121                                 ;; @@294f 11
                 !word fsubt-1                             ;; @@2950 11
                 !text 123                                 ;; @@2952 11
                 !word fmultt-1                            ;; @@2953 11
                 !text 123                                 ;; @@2955 11
                 !word fdivt-1                             ;; @@2956 11
                 !text 127                                 ;; @@2958 11
                 !word fpwrt-1                             ;; @@2959 11
                 !text 80                                  ;; @@295b 11
                 !word andop-1                             ;; @@295c 11
                 !text 70                                  ;; @@295e 11
                 !word orop-1                              ;; @@295f 11
negtab           !text 125                                 ;; @@2961 11
                 !word negop-1                             ;; @@2962 11
                 !text 90                                  ;; @@2964 11
                 !word notop-1                             ;; @@2965 11
ptdorl           !text 100                                 ;; @@2967 11
                 !word dorel-1                             ;; @@2968 11
 ;; @@296a 11
;.end ;; @@296a 11
; .page ;; @@296a 11
; .subttl  Keyword Equates ;; @@296a 11
 ;; @@296a 11
end_token        = $80                                    ; v2 commands ;; @@296a 11
for_token        = $81                                     ;; @@296a 11
next_token       = $82                                     ;; @@296a 11
data_token       = $83                                     ;; @@296a 11
input_token      = $84                                     ;; @@296a 11
goto_token       = $89                                     ;; @@296a 11
run_token        = $8a                                     ;; @@296a 11
restore_token    = $8c                                     ;; @@296a 11
gosub_token      = $8d                                     ;; @@296a 11
rem_token        = $8f                                     ;; @@296a 11
on_token         = $91                                     ;; @@296a 11
load_token       = $93                                     ;; @@296a 11
save_token       = $94                                     ;; @@296a 11
verify_token     = $95                                     ;; @@296a 11
def_token        = $96                                     ;; @@296a 11
print_token      = $99                                     ;; @@296a 11
clr_token        = $9c                                     ;; @@296a 11
sys_token        = $9e                                     ;; @@296a 11
open_token       = $9f                                     ;; @@296a 11
close_token      = $a0                                     ;; @@296a 11
new_token        = $a2                                     ;; @@296a 11
tab_token        = $a3                                     ;; @@296a 11
to_token         = $a4                                     ;; @@296a 11
fn_token         = $a5                                     ;; @@296a 11
spc_token        = $a6                                     ;; @@296a 11
then_token       = $a7                                     ;; @@296a 11
not_token        = $a8                                     ;; @@296a 11
step_token       = $a9                                     ;; @@296a 11
plus_token       = $aa                                    ; operators ;; @@296a 11
minus_token      = $ab                                     ;; @@296a 11
greater_token    = $b1                                     ;; @@296a 11
equal_token      = $b2                                     ;; @@296a 11
less_token       = $b3                                     ;; @@296a 11
first_function_token = $b4                                    ; v2 functions ;; @@296a 11
left_token       = $c8                                     ;; @@296a 11
mid_token        = $ca                                     ;; @@296a 11
go_token         = $cb                                    ; kludges ;; @@296a 11
rgraphic_token   = $cc                                    ; first new v7 token ;; @@296a 11
esc_function_token = $ce                                     ;; @@296a 11
err_token        = $d3                                     ;; @@296a 11
instr_token      = $d4                                     ;; @@296a 11
last_function_token = $d4                                     ;; @@296a 11
else_token       = $d5                                     ;; @@296a 11
resume_token     = $d6                                     ;; @@296a 11
trap_token       = $d7                                     ;; @@296a 11
color_token      = $e7                                     ;; @@296a 11
do_token         = $eb                                     ;; @@296a 11
loop_token       = $ec                                     ;; @@296a 11
key_token        = $f9                                     ;; @@296a 11
monitor_token    = $fa                                     ;; @@296a 11
using_token      = $fb                                     ;; @@296a 11
until_token      = $fc                                     ;; @@296a 11
while_token      = $fd                                     ;; @@296a 11
esc_command_token = $fe                                     ;; @@296a 11
; .page ;; @@296a 11
first_esc_command_token = $02                                     ;; @@296a 11
collision_token  = $17                                     ;; @@296a 11
begin_token      = $18                                     ;; @@296a 11
bend_token       = $19                                     ;; @@296a 11
off_token        = $24                                     ;; @@296a 11
ectory_token     = $29                                     ;; @@296a 11
set_token        = $2d                                     ;; @@296a 11
pic_token        = $37                                     ;; @@296a 11
disk_token       = $40                                     ;; @@296a 11
last_esc_command_token = $45                                    ; <<<< last_command_token ;; @@296a 11
 ;; @@296a 11
first_esc_function_token = $02                                     ;; @@296a 11
pointer_token    = $0a                                     ;; @@296a 11
last_esc_function_token = $0d                                    ; [910820] ;; @@296a 11
 ;; @@296a 11
; .page ;; @@296a 11
; .subttl Error Messages ;; @@296a 11
 ;; @@296a 11
ok_error_message                                           ;; @@296a 11
                 !text "O",'K'+$80                        ; 0 for ERR$ [910911] ;; @@296a 11
error_message_list                                           ;; @@296c 11
                 !text "TOO MANY FILE",'S'+$80            ; 1 ;; @@296c 11
                 !text "FILE OPE",'N'+$80                 ; 2 ;; @@297a 11
                 !text "FILE NOT OPE",'N'+$80             ; 3 ;; @@2983 11
                 !text "FILE NOT FOUN",'D'+$80            ; 4 ;; @@2990 11
                 !text "DEVICE NOT PRESEN",'T'+$80        ; 5 ;; @@299e 11
                 !text "NOT INPUT FIL",'E'+$80            ; 6 ;; @@29b0 11
                 !text "NOT OUTPUT FIL",'E'+$80           ; 7 ;; @@29be 11
                 !text "MISSING FILE NAM",'E'+$80         ; 8 ;; @@29cd 11
                 !text "ILLEGAL DEVICE NUMBE",'R'+$80     ; 9 ;; @@29de 11
                 !text "NEXT WITHOUT FO",'R'+$80          ; 10 ;; @@29f3 11
                 !text "SYNTA",'X'+$80                    ; 11 ;; @@2a03 11
                 !text "RETURN WITHOUT GOSU",'B'+$80      ; 12 ;; @@2a09 11
                 !text "OUT OF DAT",'A'+$80               ; 13 ;; @@2a1d 11
                 !text "ILLEGAL QUANTIT",'Y'+$80          ; 14 ;; @@2a28 11
                 !text "OVERFLO",'W'+$80                  ; 15 ;; @@2a38 11
                 !text "OUT OF MEMOR",'Y'+$80             ; 16 ;; @@2a40 11
                 !text "UNDEF",$27,"D STATEMEN",'T'+$80   ; 17 ;; @@2a4d 11
                 !text "BAD SUBSCRIP",'T'+$80             ; 18 ;; @@2a5e 11
                 !text "REDIM",$27,"D ARRA",'Y'+$80       ; 19 ;; @@2a6b 11
                 !text "DIVISION BY ZER",'O'+$80          ; 20 ;; @@2a78 11
                 !text "ILLEGAL DIREC",'T'+$80            ; 21 ;; @@2a88 11
                 !text "TYPE MISMATC",'H'+$80             ; 22 ;; @@2a96 11
                 !text "STRING TOO LON",'G'+$80           ; 23 ;; @@2aa3 11
                 !text "FILE DAT",'A'+$80                 ; 24 ;; @@2ab2 11
                 !text "FORMULA TOO COMPLE",'X'+$80       ; 25 ;; @@2abb 11
                 !text "CAN",$27,"T CONTINU",'E'+$80      ; 26 ;; @@2ace 11
                 !text "UNDEF'D FUNCTIO",'N'+$80          ; 27 ;; @@2adc 11
                 !text "VERIF",'Y'+$80                    ; 28 ;; @@2aec 11
                 !text "LOA",'D'+$80                      ; 29 ;; @@2af2 11
                 !text "BREA",'K'+$80                     ; 30 ???? null & space [910925] ;; @@2af6 11
                 !text "CAN'T RESUM",'E'+$80              ; 31 ;; @@2afb 11
                 !text "LOOP NOT FOUN",'D'+$80            ; 32 ;; @@2b07 11
                 !text "LOOP WITHOUT D",'O'+$80           ; 33 ;; @@2b15 11
                 !text "DIRECT MODE ONL",'Y'+$80          ; 34 ;; @@2b24 11
; .byte 'NO GRAPHICS ARE','A'+$80   ;35 ;; @@2b34 11
                 !text "SCREEN NOT OPE",'N'+$80           ; 35    [911001] ;; @@2b34 11
                 !text "BAD DIS",'K'+$80                  ; 36 ???? used for failed bootsys ;; @@2b43 11
                 !text "BEND NOT FOUN",'D'+$80            ; 37 ;; @@2b4b 11
                 !text "LINE NUMBER TOO LARG",'E'+$80     ; 38 ;; @@2b59 11
                 !text "UNRESOLVED REFERENC",'E'+$80      ; 39 ;; @@2b6e 11
                 !text "UNIMPLEMENTED COMMAN",'D'+$80     ; 40 ;; @@2b82 11
                 !text "FILE REA",'D'+$80                 ; 41 ;; @@2b97 11
                 !text "EDIT MOD",'E'+$80                 ; 42    [910620] ;; @@2ba0 11
 ;; @@2ba9 11
; .page ;; @@2ba9 11
; .subttl  Error Message Numbers ;; @@2ba9 11
 ;; @@2ba9 11
errtmf           = 1                                       ;; @@2ba9 11
errfno           = 3                                       ;; @@2ba9 11
errfnf           = 4                                       ;; @@2ba9 11
err_missing_fname = 8                                       ;; @@2ba9 11
err_illegal_device = 9                                       ;; @@2ba9 11
errnf            = 10                                      ;; @@2ba9 11
errsn            = 11                                      ;; @@2ba9 11
errrg            = 12                                      ;; @@2ba9 11
errod            = 13                                      ;; @@2ba9 11
errfc            = 14                                      ;; @@2ba9 11
errov            = 15                                      ;; @@2ba9 11
errom            = 16                                      ;; @@2ba9 11
errus            = 17                                      ;; @@2ba9 11
errbs            = 18                                      ;; @@2ba9 11
errdd            = 19                                      ;; @@2ba9 11
errdvo           = 20                                      ;; @@2ba9 11
errid            = 21                                      ;; @@2ba9 11
errtm            = 22                                      ;; @@2ba9 11
errls            = 23                                      ;; @@2ba9 11
errbd            = 24                                      ;; @@2ba9 11
errst            = 25                                      ;; @@2ba9 11
errcn            = 26                                      ;; @@2ba9 11
erruf            = 27                                      ;; @@2ba9 11
ervfy            = 28                                      ;; @@2ba9 11
erload           = 29                                      ;; @@2ba9 11
erbrk            = 30                                      ;; @@2ba9 11
errcr            = 31                                      ;; @@2ba9 11
errlnf           = 32                                      ;; @@2ba9 11
errlwd           = 33                                      ;; @@2ba9 11
erroid           = 34                                      ;; @@2ba9 11
errng            = 35                                      ;; @@2ba9 11
errbdk           = 36                                      ;; @@2ba9 11
err_no_bend      = 37                                      ;; @@2ba9 11
err_too_large    = 38                                      ;; @@2ba9 11
err_ref          = 39                                      ;; @@2ba9 11
err_bad_command  = 40                                      ;; @@2ba9 11
err_file_read    = 41                                      ;; @@2ba9 11
edit_mode_error  = 42                                     ; [910620] ;; @@2ba9 11
last_error_message = 42                                     ; # of last error msg ;; @@2ba9 11
 ;; @@2ba9 11
;.end ;; @@2ba9 11
; .page ;; @@2ba9 11
; .subttl Error message output ;; @@2ba9 11
 ;; @@2ba9 11
; Routine to translate error message # in .a ;; @@2ba9 11
; into address of string containing message in index2 ;; @@2ba9 11
 ;; @@2ba9 11
erstup           tax                                      ; error set up ;; @@2ba9 11
                 ldy #0                                   ; start with address of first error message ;; @@2baa 11
                 lda #<error_message_list                  ;; @@2bac 11
                 sta index2                                ;; @@2bae 11
                 lda #>error_message_list                  ;; @@2bb0 11
                 sta index2+1                              ;; @@2bb2 11
 ;; @@2bb4 11
_local_1010_1    dex                                       ;; @@2bb4 11
                 bmi _local_1010_4                        ; finished when .x decrements out ;; @@2bb5 11
 ;; @@2bb7 11
_local_1010_2    lda (index2),y                           ; look at msg, and find end (msb set) (ind.ok) ;; @@2bb7 11
                 inw index2                                ;; @@2bb9 11
                 and #$ff                                 ; was msb set? ;; @@2bbb 11
                 bpl _local_1010_2                        ; no, not end of message ;; @@2bbd 11
                 bra _local_1010_1                        ; yes, tick off another msg ;; @@2bbf 11
 ;; @@2bc1 11
_local_1010_4    rts                                       ;; @@2bc1 11
 ;; @@2bc2 11
;.end ;; @@2bc2 11
; .page ;; @@2bc2 11
; .subttl Execute Dispatcher ;; @@2bc2 11
 ;; @@2bc2 11
; Here for new statement. Character -> by txtptr is ':' or eol. The adr of ;; @@2bc2 11
; this loc is left on the stack when a statement is executed so that it can ;; @@2bc2 11
; merely do a rts when it is done. ;; @@2bc2 11
; Get char, exit via xeqcm3, and return to newstt. ;; @@2bc2 11
 ;; @@2bc2 11
xeqcm            jmp (igone)                               ;; @@2bc2 12
 ;; @@2bc5 12
; Check if there is an interrupt from VIC that needs to be serviced ;; @@2bc5 12
 ;; @@2bc5 12
ngone            bbr7 runmod,_local_1011_30               ; get off here if we are in direct mode ;; @@2bc5 12
                 lda intval                               ; check if there is an interrupt already in progress ;; @@2bc8 12
                 bmi _local_1011_30                       ; yes, don't go any further ;; @@2bcb 12
 ;; @@2bcd 12
                 ldx #2                                   ; check for 3 types of interrupts: s/s, s/b, & lp ;; @@2bcd 12
_local_1011_10   lda int_trip_flag,x                       ;; @@2bcf 12
                 beq _local_1011_20                       ; this wasn't set, go check next ;; @@2bd2 12
 ;; @@2bd4 12
                 lda #0                                    ;; @@2bd4 12
                 sta int_trip_flag,x                      ; reset this flag to show 'serviced' ;; @@2bd6 12
                 lda int_adr_lo,x                         ; install the trap address as linnum ;; @@2bd9 12
                 sta linnum                                ;; @@2bdc 12
                 lda int_adr_hi,x                          ;; @@2bde 12
                 sta linnum+1                              ;; @@2be1 12
                 phx                                      ; save counter & text pointer ;; @@2be3 12
                 phw txtptr                                ;; @@2be4 12
                 lda #$80                                 ; flag 'no other interrupt traps, please' ;; @@2be7 12
                 tsb intval                                ;; @@2be9 12
 ;; @@2bec 12
                 jsr chrget                               ; skip over 2nd byte of line number ;; @@2bec 12
                 jsr gosub_sub                            ; fake a 'gosub' from here, so trap rx can do a RETURN ;; @@2bef 12
                 jsr goto_1                                ;; @@2bf2 12
                 jsr newstt                                ;; @@2bf5 12
 ;; @@2bf8 12
                 lda #$80                                  ;; @@2bf8 12
                 trb intval                                ;; @@2bfa 12
                 pla                                       ;; @@2bfd 12
                 sta txtptr+1                              ;; @@2bfe 12
                 pla                                       ;; @@2c00 12
                 sta txtptr                                ;; @@2c01 12
                 plx                                       ;; @@2c03 12
 ;; @@2c04 12
_local_1011_20   dex                                       ;; @@2c04 12
                 bpl _local_1011_10                        ;; @@2c05 12
 ;; @@2c07 12
 ;; @@2c07 12
_local_1011_30   jsr chrget                               ; get statement type ;; @@2c07 12
xeqdir           jsr xeqcm3                                ;; @@2c0a 13
 ;; @@2c0d 13
newstt           jsr is_stop_key_down                      ;; @@2c0d 13
                 bbr7 runmod,_local_1012_10               ; branch if direct mode ;; @@2c10 13
 ;; @@2c13 13
; In run mode...save txtptr for CONTinue command ;; @@2c13 13
 ;; @@2c13 13
                 jsr tto                                  ; transfer txtptr to oldtxt ;; @@2c13 13
                 tsx                                       ;; @@2c16 13
                 stx oldstk                                ;; @@2c17 13
 ;; @@2c19 13
_local_1012_10   ldy #0                                    ;; @@2c19 13
                 jsr indtxt                               ; end of the line? ;; @@2c1b 13
                 +lbne morsts                             ; no...out of statement ;; @@2c1e 13
 ;; @@2c21 13
_local_1012_20   bit runmod                               ; in direct mode? ;; @@2c21 13
                 +lbpl ready                              ; yes, go to ready ;; @@2c23 13
                 ldy #2                                    ;; @@2c26 13
                 jsr indtxt                               ; end of text? ;; @@2c28 13
                 +lbeq ready                              ; yes...finished ;; @@2c2b 13
                 iny                                      ; y=3 ;; @@2c2e 13
                 jsr indtxt                               ; extract line# lo byte ;; @@2c2f 13
                 sta curlin                                ;; @@2c32 13
                 iny                                       ;; @@2c34 13
                 jsr indtxt                               ; extract line # hi byte ;; @@2c35 13
                 sta curlin+1                              ;; @@2c38 13
                 tya                                      ; y=4 ;; @@2c3a 13
                 clc                                       ;; @@2c3b 13
                 adc txtptr                               ; point @ character before line start ;; @@2c3c 13
                 sta txtptr                                ;; @@2c3e 13
                 bcc _local_1012_30                        ;; @@2c40 13
                 inc txtptr+1                              ;; @@2c42 13
_local_1012_30   +lbra xeqcm                              ; execute new line ;; @@2c44 13
 ;; @@2c47 13
 ;; @@2c47 13
 ;; @@2c47 13
tto              lda txtptr                                ;; @@2c47 14
                 ldy txtptr+1                              ;; @@2c49 14
                 sta oldtxt                                ;; @@2c4b 14
                 sty oldtxt+1                              ;; @@2c4e 14
xeqrts           rts                                       ;; @@2c51 14
 ;; @@2c52 14
; .page ;; @@2c52 14
; Set up for command processing and set processor address on stack. ;; @@2c52 14
; Exit via jmp to CHRGET ;; @@2c52 14
 ;; @@2c52 14
xeqcm3           beq xeqrts                               ; nothing here...null statement ;; @@2c52 14
                 bbr5 runmod,xeqcm2                       ; trcflg. branch if trace not enabled ;; @@2c54 14
                 bbr7 runmod,xeqcm2                       ; branch if direct mode- can't trace ;; @@2c57 14
 ;; @@2c5a 14
                 pha                                      ; save token ;; @@2c5a 14
                 lda #'['                                 ; print '[line-number]' ;; @@2c5b 14
                 jsr outch                                ; outdo ;; @@2c5d 14
                 jsr curprt                               ; print curlin ;; @@2c60 14
                 lda #']'                                  ;; @@2c63 14
                 jsr outch                                ; outdo ;; @@2c65 14
                 pla                                      ; restore token ;; @@2c68 14
 ;; @@2c69 14
 ;; @@2c69 14
xeqcm2           cmp #esc_command_token                   ; special case: escape token ;; @@2c69 14
                 beq xeqesc                                ;; @@2c6b 14
                 cmp #go_token                            ; special case: go to ;; @@2c6d 14
                 +lbeq go_without_to                       ;; @@2c6f 14
                 cmp #mid_token                           ; special case: mid$()= ;; @@2c72 14
                 beq xeqmid                                ;; @@2c74 14
 ;; @@2c76 14
; Command can be in the range END...NEW (old BASIC) & ELSE...MONITOR ;; @@2c76 14
; (new extensions).  Although there is a gap between these two blocks, ;; @@2c76 14
; it will be quickest & easiest to collapse them into one continuous block. ;; @@2c76 14
 ;; @@2c76 14
                 cmp #monitor_token+1                      ;; @@2c76 14
                 bcs snerr1                                ;; @@2c78 14
                 cmp #new_token+1                          ;; @@2c7a 14
                 bcc xeqcm4                               ; no need to collapse ;; @@2c7c 14
                 cmp #else_token                           ;; @@2c7e 14
                 bcc snerr1                                ;; @@2c80 14
                 sbc #else_token-new_token-1               ;; @@2c82 14
 ;; @@2c84 14
xeqcm4           sec                                      ; convert adjusted token into an index into a jump table. ;; @@2c84 14
                 sbc #end_token                            ;; @@2c85 14
                 +lbcc let                                ; it wasn't a token after all!  assume an assignment ;; @@2c87 14
 ;; @@2c8a 14
xeqcm5           asl                                      ; *2 to convert into word pointer ;; @@2c8a 14
                 tay                                       ;; @@2c8b 14
                 bcs _local_1013_10                       ; dispatch table 1 or 2?     [901212] ;; @@2c8c 14
                 lda stmdsp+1,y                           ; one ;; @@2c8e 14
                 pha                                       ;; @@2c91 14
                 lda stmdsp,y                              ;; @@2c92 14
                 bra _local_1013_20                        ;; @@2c95 14
 ;; @@2c97 14
_local_1013_10   lda stmdsp2+1,y                          ; two      [901212] ;; @@2c97 14
                 pha                                       ;; @@2c9a 14
                 lda stmdsp2,y                             ;; @@2c9b 14
 ;; @@2c9e 14
_local_1013_20   pha                                       ;; @@2c9e 14
                 jmp chrget                               ; execution will commence after chrget's RTS ;; @@2c9f 14
 ;; @@2ca2 14
 ;; @@2ca2 14
 ;; @@2ca2 14
xeqmid                                                    ; handle special case of MID$= (what we call a kludge) ;; @@2ca2 15
                 lda #>midwrk                             ; midd2-1 ;; @@2ca2 15
                 pha                                       ;; @@2ca4 15
                 lda #<midwrk                              ;; @@2ca5 15
                 pha                                       ;; @@2ca7 15
xeqchr                                                     ;; @@2ca8 15
                 jmp chrget                                ;; @@2ca8 15
 ;; @@2cab 15
 ;; @@2cab 15
 ;; @@2cab 15
 ;; @@2cab 15
xeqesc                                                    ; execute escape token ;; @@2cab 15
                 jsr chrget                               ; let's have us a look at the second char ;; @@2cab 15
                 beq snerr1                               ; oops, there wasn't any! ;; @@2cae 15
                 cmp #first_esc_command_token             ; is it one of our esc tokens? ;; @@2cb0 15
                 bcc _local_1014_1                        ; no, foreign. ;; @@2cb2 15
                 cmp #last_esc_command_token+1             ;; @@2cb4 15
                 bcs _local_1014_1                        ; foreign ;; @@2cb6 15
 ;; @@2cb8 15
; It's one of our own.  Convert to index into command dispatch table ;; @@2cb8 15
 ;; @@2cb8 15
                 adc #monitor_token-else_token+new_token-end_token-first_esc_command_token+2  ;; @@2cb8 15
                 bra xeqcm5                               ; always ;; @@2cba 15
 ;; @@2cbc 15
_local_1014_1    sec                                      ; set up flag for a trip into the users code ;; @@2cbc 15
                 jmp (iescex)                              ;; @@2cbd 15
 ;; @@2cc0 15
nescex           bcc xeqchr                               ; jmp chrget ;; @@2cc0 16
 ;; @@2cc2 16
snerr1           +lbra snerr                               ;; @@2cc2 16
 ;; @@2cc5 16
morsts           cmp #':'                                  ;; @@2cc5 16
                 +lbeq xeqcm                              ; if ':', continue statement ;; @@2cc7 16
                 bra snerr1                                ;; @@2cca 16
 ;; @@2ccc 16
; .page ;; @@2ccc 16
; STOP, STOP KEY, and END handlers ;; @@2ccc 16
; ;; @@2ccc 16
 ;; @@2ccc 16
is_stop_key_down                                           ;; @@2ccc 16
                 jsr _stop                                ; test stop key ;; @@2ccc 16
                 bne do_rts                               ; not down, exit ;; @@2ccf 16
 ;; @@2cd1 16
; ldy trapno+1  ;test if trap on????   removed [910925] ;; @@2cd1 16
; iny ;; @@2cd1 16
; beq stop_1  ;no, do a normal stop ;; @@2cd1 16
 ;; @@2cd1 16
 ;; @@2cd1 16
break_exit                                                ; STOP KEY:     [910104] ;; @@2cd1 16
_local_1015_10   jsr _stop                                ; wait for the user to release the key ;; @@2cd1 16
                 beq _local_1015_10                        ;; @@2cd4 16
                 ldx #erbrk                               ; take the vector thru error to ready ;; @@2cd6 16
                 +lbra error                               ;; @@2cd8 16
 ;; @@2cdb 16
 ;; @@2cdb 16
 ;; @@2cdb 16
stop             bcs stopc                                ; STOP: .c=1 ;; @@2cdb 17
 ;; @@2cdd 17
end              clc                                      ; END: .c=0 ;; @@2cdd 17
stopc            +lbne snerr                              ; error if args present   [910410] ;; @@2cde 17
 ;; @@2ce1 17
stop_1           bbr7 runmod,_local_1016_10               ; branch if direct mode ;; @@2ce1 17
                 jsr tto                                  ; transfer txtptr to oldtxt ;; @@2ce4 17
                 lda curlin                                ;; @@2ce7 17
                 ldy curlin+1                              ;; @@2ce9 17
                 sta oldlin                                ;; @@2ceb 17
                 sty oldlin+1                              ;; @@2cee 17
_local_1016_10   pla                                      ; .diris ;; @@2cf1 17
                 pla                                       ;; @@2cf2 17
                 +lbcc ready                              ; say 'ready' if END, say 'break' if STOP ;; @@2cf3 17
 ;; @@2cf6 17
 ;; @@2cf6 17
break            jsr release_channels                     ; make sure we're in text mode????  [910909] ;; @@2cf6 18
                 jsr RestoreTextScreen                     ;; @@2cf9 18
                 jsr highlight_text                       ; ????      [910624] ;; @@2cfc 18
                 jsr _primm                                ;; @@2cff 18
                 !text cr,"BREAK",0                        ;; @@2d02 18
                 +lbra errfin                             ; exit via 'in line #' ;; @@2d09 18
 ;; @@2d0c 18
do_rts           rts                                       ;; @@2d0c 18
 ;; @@2d0d 18
;.end ;; @@2d0d 18
; .page ;; @@2d0d 18
; .subttl Function Handler ;; @@2d0d 18
 ;; @@2d0d 18
; At this point, eval has determined that the token in a has to be a ;; @@2d0d 18
; function.  It must therefor be in the range SGN...MID$ (old BASIC), ;; @@2d0d 18
; or RGR...INSTR (new extensions).  We will collapse these two disjoint ;; @@2d0d 18
; blocks into one continuous range. ;; @@2d0d 18
; ;; @@2d0d 18
; On entry, we can assume the token is >= 'sgn' ;; @@2d0d 18
 ;; @@2d0d 18
isfun            cmp #esc_function_token                  ; is this an escape function? ;; @@2d0d 18
                 beq do_esc_fn                            ; yes ;; @@2d0f 18
                 cmp #last_function_token+1                ;; @@2d11 18
                 bcs snerr1                               ; no- must be syntax error ;; @@2d13 18
                 cmp #mid_token+1                          ;; @@2d15 18
                 bcc _local_1017_1                        ; no need to adjust ;; @@2d17 18
                 sbc #rgraphic_token-mid_token-1           ;; @@2d19 18
 ;; @@2d1b 18
_local_1017_1    pha                                      ; save token ;; @@2d1b 18
                 tax                                       ;; @@2d1c 18
                 jsr chrget                               ; set up for synchk. ;; @@2d1d 18
                 cpx #instr_token-1                       ; look for (adjusted) instr token ;; @@2d20 18
                 beq _local_1017_2                        ; yes ;; @@2d22 18
                 cpx #rgraphic_token-1                    ; look for rgraphic which now takes 2 args [910801] ;; @@2d24 18
                 +lbeq rgraphic                           ; yes ;; @@2d26 18
 ;; @@2d29 18
                 cpx #mid_token+1                          ;; @@2d29 18
                 bcs oknorm                               ; LEFT$,RIGHT$,MID$ require multiple args ;; @@2d2b 18
                 cpx #left_token                          ; is it past last single-arg function? ;; @@2d2d 18
                 bcc oknorm                               ; no, must be normal function ;; @@2d2f 18
 ;; @@2d31 18
 ;; @@2d31 18
; Most functions take a single argument.  The return address of these functions ;; @@2d31 18
; is CHKNUM, which ascertains that VALTYP=0 (numeric).  Normal functions which ;; @@2d31 18
; return string results (eg. CHR$) must pop off that return address and return ;; @@2d31 18
; directly to FRMEVL. ;; @@2d31 18
; ;; @@2d31 18
; The so called "funny" functions can take more than one argument, the first ;; @@2d31 18
; of which must be string and the second of which must be a number between 0 ;; @@2d31 18
; and 255.  The closed parenthesis must be checked and return is directly to ;; @@2d31 18
; FRMEVL with the text pointer pointing beyond the ")".  The pointer to the ;; @@2d31 18
; description of the string argument is stored on the stack underneath the ;; @@2d31 18
; value of the integer argument. ;; @@2d31 18
 ;; @@2d31 18
_local_1017_2    jsr chkopn                               ; check for an open parenthesis ;; @@2d31 18
                 jsr frmevl                               ; eat open paren and first argument ;; @@2d34 18
                 jsr chkcom                               ; two args so comma must delimit ;; @@2d37 18
                 jsr chkstr                               ; make sure first was string ;; @@2d3a 18
 ;; @@2d3d 18
                 pla                                      ; check token ;; @@2d3d 18
                 cmp #instr_token-1                       ; special case: INSTR() bails out here ;; @@2d3e 18
                 +lbeq instr                               ;; @@2d40 18
                 ldx facmo+1                              ; push address of string arg1 ;; @@2d43 18
                 phx                                       ;; @@2d45 18
                 ldx facmo                                 ;; @@2d46 18
                 phx                                       ;; @@2d48 18
                 pha                                      ; push token ;; @@2d49 18
                 jsr getbyt                               ; get arg2 ;; @@2d4a 18
                 pla                                      ; retrieve token ;; @@2d4d 18
                 phx                                      ; push value of arg2 ;; @@2d4e 18
                 bra fingo                                ; go set up to evaluate fn ;; @@2d4f 18
 ;; @@2d51 18
 ;; @@2d51 18
 ;; @@2d51 18
oknorm                                                     ;; @@2d51 19
                 jsr parchk                               ; check for open parens, evaluate argument ;; @@2d51 19
                 pla                                      ; restore token ;; @@2d54 19
 ;; @@2d55 19
fingo                                                      ;; @@2d55 19
                 sec                                      ; convert token to index into jump table ;; @@2d55 19
                 sbc #first_function_token                 ;; @@2d56 19
                 asl                                       ;; @@2d58 19
                 tay                                       ;; @@2d59 19
                 lda fundsp+1,y                            ;; @@2d5a 19
                 sta jmper+2                               ;; @@2d5d 19
                 lda fundsp,y                              ;; @@2d5f 19
                 sta jmper+1                               ;; @@2d62 19
                 jsr jmper                                ; dispatch ;; @@2d64 19
;string functions remove this ret addr ;; @@2d67 19
                 +lbra chknum                             ; check for "numeric-ness" and return ;; @@2d67 19
 ;; @@2d6a 19
; .page ;; @@2d6a 19
; Escape Function handler ;; @@2d6a 19
 ;; @@2d6a 19
do_esc_fn                                                  ;; @@2d6a 19
                 jsr chrget                               ; get second token ;; @@2d6a 19
                 +lbeq snerr                              ; error if no second token ;; @@2d6d 19
                 cmp #pointer_token                        ;; @@2d70 19
                 beq _local_1018_10                       ; skip pre-parse if 'POINTER()' ;; @@2d72 19
                 pha                                       ;; @@2d74 19
                 jsr chrget                               ; should be '(' ;; @@2d75 19
                 jsr chkopn                                ;; @@2d78 19
                 jsr frmevl                               ; evaluate first argument ;; @@2d7b 19
                 pla                                       ;; @@2d7e 19
_local_1018_10   cmp #first_esc_function_token            ; see if this esc fn is one of ours ;; @@2d7f 19
                 bcc foreign_esc_fn                       ; nope. ;; @@2d81 19
                 cmp #last_esc_function_token+1            ;; @@2d83 19
                 bcs foreign_esc_fn                       ; nope ;; @@2d85 19
 ;; @@2d87 19
; Convert to index into the function dispatch table ;; @@2d87 19
 ;; @@2d87 19
                 adc #last_function_token-first_esc_function_token-1  ;; @@2d87 19
                 bra fingo                                ; always ;; @@2d89 19
 ;; @@2d8b 19
 ;; @@2d8b 19
foreign_esc_fn                                             ;; @@2d8b 20
                 sec                                      ; flag 'up for grabs' ;; @@2d8b 20
                 jsr go_foreign_esc_fn                     ;; @@2d8c 20
n_esc_fn_vec                                               ;; @@2d8f 20
                 +lbcs snerr                              ; it's unwanted. off to the refuse pile ;; @@2d8f 20
                 +lbra chknum                              ;; @@2d92 20
 ;; @@2d95 20
go_foreign_esc_fn                                           ;; @@2d95 20
                 jmp (esc_fn_vec)                          ;; @@2d95 20
 ;; @@2d98 20
; .page ;; @@2d98 20
orop             ldy #255                                 ; must always complement ;; @@2d98 20
                 !text $2c                                 ;; @@2d9a 20
 ;; @@2d9b 20
andop            ldy #0                                    ;; @@2d9b 20
                 sty count                                ; operator ;; @@2d9d 20
                 jsr ayint                                ; (facmo&lo)=int value and check size ;; @@2d9f 20
                 lda facmo                                ; use Demorgan's Law on high ;; @@2da2 20
                 eor count                                 ;; @@2da4 20
                 sta integr                                ;; @@2da6 20
                 lda faclo                                ; and low ;; @@2da8 20
                 eor count                                 ;; @@2daa 20
                 sta integr+1                              ;; @@2dac 20
                 jsr movfa                                 ;; @@2dae 20
                 jsr ayint                                ; (facmo&lo)=int of arg ;; @@2db1 20
                 lda faclo                                 ;; @@2db4 20
                 eor count                                 ;; @@2db6 20
                 and integr+1                              ;; @@2db8 20
                 eor count                                ; finish out Demorgan ;; @@2dba 20
                 tay                                      ; save high ;; @@2dbc 20
                 lda facmo                                 ;; @@2dbd 20
                 eor count                                 ;; @@2dbf 20
                 and integr                                ;; @@2dc1 20
                 eor count                                 ;; @@2dc3 20
                 +lbra givayf                             ; float (a,y) and return to user ;; @@2dc5 20
 ;; @@2dc8 20
 ;; @@2dc8 20
 ;; @@2dc8 20
; Time to perform a relational operator. ;; @@2dc8 20
; (domask) contains the bits as to which relational operator it was. ;; @@2dc8 20
; Carry bit on = string compare. ;; @@2dc8 20
 ;; @@2dc8 20
 ;; @@2dc8 20
dorel            jsr chkval                               ; check for match ;; @@2dc8 20
                 bcs strcmp                               ; is it a string? ;; @@2dcb 20
                 lda argsgn                               ; pack argument for fcomp ;; @@2dcd 20
                 ora #$7f                                  ;; @@2dcf 20
                 and argho                                 ;; @@2dd1 20
                 sta argho                                 ;; @@2dd3 20
                 lda #<argexp                              ;; @@2dd5 20
                 ldy #>argexp                              ;; @@2dd7 20
                 jsr fcomp                                 ;; @@2dd9 20
                 tax                                       ;; @@2ddc 20
                 bra qcomp                                 ;; @@2ddd 20
 ;; @@2ddf 20
; .page ;; @@2ddf 20
strcmp           lda #0                                    ;; @@2ddf 20
                 sta valtyp                                ;; @@2de1 20
                 dec opmask                                ;; @@2de3 20
                 jsr frefac                               ; free the faclo string ;; @@2de5 20
                 sta dsctmp                               ; save it for later ;; @@2de8 20
                 stx dsctmp+1                              ;; @@2dea 20
                 sty dsctmp+2                              ;; @@2dec 20
                 lda argmo                                ; get pointer to other string ;; @@2dee 20
                 ldy argmo+1                               ;; @@2df0 20
                 jsr fretmp                               ; frees first desc pointer ;; @@2df2 20
                 stx argmo                                 ;; @@2df5 20
                 sty argmo+1                               ;; @@2df7 20
                 tax                                      ; copy count into x ;; @@2df9 20
                 sec                                       ;; @@2dfa 20
                 sbc dsctmp                               ; which is greater. if 0, all set up ;; @@2dfb 20
                 beq stasgn                               ; just put sign of difference away ;; @@2dfd 20
                 lda #1                                    ;; @@2dff 20
                 bcc stasgn                               ; sign is positive ;; @@2e01 20
                 ldx dsctmp                               ; length of fac is shorter ;; @@2e03 20
                 lda #$ff                                 ; get a minus one for negatives ;; @@2e05 20
stasgn           sta facsgn                               ; keep for later ;; @@2e07 20
                 ldy #255                                 ; set pointer to first string. (arg) ;; @@2e09 20
                 inx                                      ; to loop properly ;; @@2e0b 20
nxtcmp           iny                                       ;; @@2e0c 20
                 dex                                      ; any characters left to compare? ;; @@2e0d 20
                 bne getcmp                               ; not done yet ;; @@2e0e 20
                 ldx facsgn                               ; use sign of length difference ;; @@2e10 20
;since all characters are the same ;; @@2e12 20
qcomp            bmi docmp                                ; c is always set then ;; @@2e12 20
                 clc                                       ;; @@2e14 20
                 bra docmp                                ; always branch ;; @@2e15 20
 ;; @@2e17 20
; .page ;; @@2e17 20
getcmp           lda #argmo                                ;; @@2e17 20
                 jsr lda_far_ram1                         ; lda (argmo),y from RAM1 ;; @@2e19 20
                 pha                                       ;; @@2e1c 20
                 lda #dsctmp+1                             ;; @@2e1d 20
                 jsr lda_far_ram1                         ; lda (dsctmp+1),y from RAM1 ;; @@2e1f 20
                 sta syntmp                                ;; @@2e22 20
                 pla                                       ;; @@2e24 20
                 cmp syntmp                                ;; @@2e25 20
                 beq nxtcmp                                ;; @@2e27 20
                 ldx #$ff                                  ;; @@2e29 20
                 bcs docmp                                 ;; @@2e2b 20
                 ldx #1                                    ;; @@2e2d 20
 ;; @@2e2f 20
 ;; @@2e2f 20
 ;; @@2e2f 20
docmp                                                      ;; @@2e2f 20
                 inx                                      ; -1 to 1, 0 to 2, 1 to 4 ;; @@2e2f 20
                 txa                                       ;; @@2e30 20
                 rol                                       ;; @@2e31 20
                 and domask                                ;; @@2e32 20
                 beq _local_1019_10                        ;; @@2e34 20
                 lda #$ff                                 ; map 0 to 0, map all others to -1 ;; @@2e36 20
_local_1019_10   +lbra float                              ; float the one-byte result into FAC ;; @@2e38 20
 ;; @@2e3b 20
 ;; @@2e3b 20
;.end ;; @@2e3b 20
; .page ;; @@2e3b 20
; .subttl  Ready, Error, Main (CODE 0) ;; @@2e3b 20
 ;; @@2e3b 20
bad_command                                                ;; @@2e3b 21
                 ldx #err_bad_command                     ; unimplemented command ;; @@2e3b 21
                 !text $2c                                 ;; @@2e3d 21
 ;; @@2e3e 21
userr            ldx #errus                               ; undefined statement ;; @@2e3e 21
                 !text $2c                                 ;; @@2e40 21
 ;; @@2e41 21
omerr            ldx #errom                               ; out of memory ;; @@2e41 21
                 !text $2c                                 ;; @@2e43 21
 ;; @@2e44 21
doverr           ldx #errdvo                              ; division by zero ;; @@2e44 21
                 !text $2c                                 ;; @@2e46 21
 ;; @@2e47 21
overr            ldx #errov                               ; overflow ;; @@2e47 21
                 !text $2c                                 ;; @@2e49 21
 ;; @@2e4a 21
snerr            ldx #errsn                               ; syntax error ;; @@2e4a 21
                 !text $2c                                 ;; @@2e4c 21
 ;; @@2e4d 21
ready            ldx #$80                                 ; no error ;; @@2e4d 21
 ;; @@2e4f 21
error            jmp (ierror)                              ;; @@2e4f 21
 ;; @@2e52 21
nerror           txa                                       ;; @@2e52 21
                 +lbmi ready_1                            ; ...branch if no error (from 'ready') ;; @@2e53 21
                 stx errnum                               ; save error # for 'er' ;; @@2e56 21
                 bbr7 runmod,errisd                       ; branch if direct mode- always display error ;; @@2e59 21
 ;; @@2e5c 21
                 ldy #1                                   ; copy curlin to errlin, oldtxt to errtxt ;; @@2e5c 21
_local_1020_10   lda curlin,y                              ;; @@2e5e 21
                 sta errlin,y                             ; line# where error occurred ;; @@2e61 21
                 lda oldtxt,y                              ;; @@2e64 21
                 sta errtxt,y                             ; statement where error occured ;; @@2e67 21
                 dey                                       ;; @@2e6a 21
                 bpl _local_1020_10                        ;; @@2e6b 21
                 inc errtxt                               ; point to a token, not ':' for HELP ;; @@2e6d 21
                 bne _local_1020_20                        ;; @@2e70 21
                 inc errtxt+1                              ;; @@2e72 21
 ;; @@2e75 21
_local_1020_20   ldy trapno+1                             ; is trap set? ;; @@2e75 21
                 cpy #$ff                                  ;; @@2e78 21
                 beq errisd                               ; no ;; @@2e7a 21
                 sty linnum+1                              ;; @@2e7c 21
                 sty tmptrp                               ; save until a resume is executed ;; @@2e7e 21
                 ldy trapno                                ;; @@2e81 21
                 sty linnum                                ;; @@2e84 21
 ;; @@2e86 21
                 ldx #$ff                                  ;; @@2e86 21
                 stx trapno+1                             ; flag no more traps ;; @@2e88 21
                 ldx #tempst                              ; clear any accumulated string temps ;; @@2e8b 21
                 stx temppt                                ;; @@2e8d 21
                 ldx oldstk                                ;; @@2e8f 21
                 txs                                       ;; @@2e91 21
                 jsr luk4it                                ;; @@2e92 21
                 +lbra newstt                              ;; @@2e95 21
 ;; @@2e98 21
; .page ;; @@2e98 21
errisd           dex                                       ;; @@2e98 22
                 txa                                       ;; @@2e99 22
                 jsr erstup                               ; set up address of error msg in .a in index2 ;; @@2e9a 22
 ;; @@2e9d 22
                 bbs7 runmod,_local_1021_5                ; reset error line if direct mode error ;; @@2e9d 22
                 lda #$ff                                  ;; @@2ea0 22
                 sta errlin                               ;  ;; @@2ea2 22
                 sta errlin+1                              ;; @@2ea5 22
 ;; @@2ea8 22
_local_1021_5    jsr release_channels                     ; restore output to screen    [910909] ;; @@2ea8 22
                 jsr RestoreTextScreen                    ; make sure we're in text mode    [910404] ;; @@2eab 22
                 jsr init_stack                            ;; @@2eae 22
 ;; @@2eb1 22
_local_1021_10   jsr crdo                                 ; Print error message- start a new line with '?' ;; @@2eb1 22
                 jsr highlight_text                       ; use highlight color????    [910624] ;; @@2eb4 22
                 jsr outqst                                ;; @@2eb7 22
                 ldy #0                                    ;; @@2eba 22
_local_1021_20   lda (index2),y                           ; Read error msg from ROM  (ind.ok????) ;; @@2ebc 22
                 pha                                       ;; @@2ebe 22
                 and #$7f                                  ;; @@2ebf 22
                 jsr outch                                ; Print it ;; @@2ec1 22
                 iny                                       ;; @@2ec4 22
                 pla                                       ;; @@2ec5 22
                 bpl _local_1021_20                        ;; @@2ec6 22
                 ldx errnum                               ; retrieve error #     [910925] ;; @@2ec8 22
                 cpx #erbrk                                ;; @@2ecb 22
                 beq errfin                               ; skip 'error' crap if 'break' ;; @@2ecd 22
                 jsr _primm                                ;; @@2ecf 22
                 !text " ERROR",0                          ;; @@2ed2 22
 ;; @@2ed9 22
errfin           ldy curlin+1                             ; direct mode? ;; @@2ed9 23
                 iny                                       ;; @@2edb 23
                 beq _local_1022_10                       ; yes...no line # ;; @@2edc 23
                 jsr inprt                                 ;; @@2ede 23
_local_1022_10   jsr highlight_done                       ; restore normal text color????    [910624] ;; @@2ee1 23
 ;; @@2ee4 23
; .page ;; @@2ee4 23
ready_1                                                    ;; @@2ee4 24
                 lda #%10000000                            ;; @@2ee4 24
                 jsr _setmsg                              ; turn Kernel messages on ;; @@2ee6 24
                 lda #%11000000                            ;; @@2ee9 24
                 trb runmod                               ; turn run modes off, leave trace mode on???? ;; @@2eeb 24
 ;; @@2eed 24
ready_2                                                    ;; @@2eed 24
                 bbs4 runmod,_local_1023_10               ; print appropriate system prompt ;; @@2eed 24
                 jsr _primm                               ; Program mode: print 'ready.' ;; @@2ef0 24
                 !text cr,"READY.",cr,0                    ;; @@2ef3 24
                 bra main                                  ;; @@2efc 24
 ;; @@2efe 24
_local_1023_10   jsr _primm                               ; Edit mode: print 'ok.' ;; @@2efe 24
                 !text cr,"OK.",cr,0                       ;; @@2f01 24
 ;; @@2f07 24
 ;; @@2f07 24
main             jmp (imain)                              ; MAIN INPUT LOOP ;; @@2f07 25
 ;; @@2f0a 25
nmain            ldx #$ff                                 ; set direct mode flag ;; @@2f0a 25
                 stx curlin+1                              ;; @@2f0c 25
                 jsr InputLine                            ; get a line of input & buffer it ;; @@2f0e 25
 ;; @@2f11 25
execute_a_line                                            ; EXECUTE PLAIN TEXT IN BUFFER ;; @@2f11 25
                 stx txtptr                               ; init buffer pointer ;; @@2f11 25
                 sty txtptr+1                              ;; @@2f13 25
                 jsr chrget                               ; get first character of null-terminated string ;; @@2f15 25
                 tax                                       ;; @@2f18 25
                 beq main                                 ; got null input ;; @@2f19 25
                 bcc _local_1024_10                       ; got line number ;; @@2f1b 25
                 jsr crunch                               ; got text- tokenize buffer, ;; @@2f1d 25
                 jsr chrgot                               ; get first command (token), ;; @@2f20 25
                 +lbra xeqdir                             ; and execute it ;; @@2f23 25
 ;; @@2f26 25
;ADD or DELETE NEW LINE ;; @@2f26 25
_local_1024_10   jsr linget                               ; evaluate line number, put into into linnum ;; @@2f26 25
                 bbr4 runmod,_local_1024_20                ;; @@2f29 25
                 jsr edit_crunch                          ; if edit mode, find end of input   [910620] ;; @@2f2c 25
                 bra _local_1024_30                        ;; @@2f2f 25
 ;; @@2f31 25
_local_1024_20   jsr crunch                               ; tokenize rest of input if not edit mode ;; @@2f31 25
_local_1024_30   sty count                                ; save length ;; @@2f34 25
                 jsr FindLine                             ; locate line in program ;; @@2f36 25
                 +lbcc nodel                              ; not found, go insert line into program ;; @@2f39 25
; else delete current line and insert this one ;; @@2f3c 25
; .page ;; @@2f3c 25
; Test: IF new line is longer than the line it replaces, ;; @@2f3c 25
;  THEN IF there isn't enough room in memory to add this new line, ;; @@2f3c 25
;   THEN out-of-memory error ;; @@2f3c 25
; ;; @@2f3c 25
; Before this fix, the old line was deleted BEFORE testing if the new line fit. ;; @@2f3c 25
; ;; @@2f3c 25
; N.B.: I am assuming that lines cannot be greater than 255 chars, as is the ;; @@2f3c 25
; case where the line was entered "normally", that is, using LINGET.  The only ;; @@2f3c 25
; consequence of this assumption is that lines > 255 will fall prey to the ;; @@2f3c 25
; pre-fix problem mentioned above. ;; @@2f3c 25
 ;; @@2f3c 25
                 ldy #0                                    ;; @@2f3c 25
                 jsr indlow                               ; get lsb of the next line's starting address ;; @@2f3e 25
                 sec                                       ;; @@2f41 25
                 sbc lowtr                                ; subtract lsb of this line's starting address ;; @@2f42 25
                 sec                                      ; ignore borrow (gives abs. value) ;; @@2f44 25
                 sbc #4                                   ; allow for link & line number ;; @@2f45 25
                 sbc count                                ; compare with new length ;; @@2f47 25
                 bcs _local_1024_2                        ; new line is shorter, no problem ;; @@2f49 25
                 neg                                      ; convert to positive delta ;; @@2f4b 25
 ;; @@2f4c 25
                 ldy text_top+1                           ; get msb of end of text (.c=0) ;; @@2f4c 25
                 adc text_top                             ; add our calculated delta to end of text ;; @@2f4e 25
                 bcc _local_1024_1                         ;; @@2f50 25
                 iny                                       ;; @@2f52 25
_local_1024_1    cpy max_mem_0+1                           ;; @@2f53 25
                 bcc _local_1024_2                        ; result is less than top-of-memory: ok ;; @@2f56 25
                 +lbne omerr                              ; msb >  top, overflow ;; @@2f58 25
                 cmp max_mem_0                            ; msb's the same, test lsb's ;; @@2f5b 25
                 +lbcs omerr                              ; lsb >= top, overflow ;; @@2f5e 25
 ;; @@2f61 25
; Using DMA device to move text downwards (to delete or replace a line)... ;; @@2f61 25
; ;; @@2f61 25
; lowtr     = destination ;; @@2f61 25
; (lowtr)    = pointer to source (via link bytes of line to be removed) ;; @@2f61 25
; text_top-(lowtr) = number of bytes to move (text_top points to old top of text) ;; @@2f61 25
; new text_top     = text_top -( (lowtr)-lowtr ) ;; @@2f61 25
 ;; @@2f61 25
_local_1024_2    lda lowtr                                ; set up DMA destination ;; @@2f61 25
                 sta dma1_dest_lo                          ;; @@2f63 25
                 lda lowtr+1                               ;; @@2f66 25
                 sta dma1_dest_hi                          ;; @@2f68 25
                 ldy #0                                    ;; @@2f6b 25
                 jsr indlow                               ; set up DMA source (& delta) ;; @@2f6d 25
                 sta dma1_src_lo                           ;; @@2f70 25
                 sec                                       ;; @@2f73 25
                 sbc lowtr                                 ;; @@2f74 25
                 sta index1                               ; (delta lo) ;; @@2f76 25
                 iny                                       ;; @@2f78 25
                 jsr indlow                                ;; @@2f79 25
                 sta dma1_src_hi                           ;; @@2f7c 25
                 sbc lowtr+1                               ;; @@2f7f 25
                 sta index1+1                             ; (delta hi) ;; @@2f81 25
                 sec                                       ;; @@2f83 25
                 lda text_top                             ; set up DMA count ;; @@2f84 25
                 sbc dma1_src_lo                           ;; @@2f86 25
                 sta dma1_cnt_lo                           ;; @@2f89 25
                 lda text_top+1                            ;; @@2f8c 25
                 sbc dma1_src_hi                           ;; @@2f8e 25
                 sta dma1_cnt_hi                           ;; @@2f91 25
 ;; @@2f94 25
                 lda text_bank                             ;; @@2f94 25
; and #%00001111  ;      [910102] ;; @@2f96 25
; and #%01111111  ;      [910520] F018A ;; @@2f96 25
                 sta dma1_src_bank                         ;; @@2f96 25
                 sta dma1_dest_bank                        ;; @@2f99 25
 ;; @@2f9c 25
                 lda #0                                    ;; @@2f9c 25
                 sta dma1_cmd                             ; dma command (copy, source=start) ;; @@2f9e 25
                 sta dma1_subcmd                          ; [910520] F018A ;; @@2fa1 25
                 sta dma_ctlr+2                           ; dma_list bank ;; @@2fa4 25
 ;; @@2fa7 25
                 ldx #>dma1_cmd                           ; dma_list ;; @@2fa7 25
                 lda #<dma1_cmd                            ;; @@2fa9 25
                 stx dma_ctlr+1                           ; dma_list hi ;; @@2fab 25
                 sta dma_ctlr                             ; dma_list lo & trigger ;; @@2fae 25
 ;; @@2fb1 25
                 sec                                      ; calculate & set new text_top ;; @@2fb1 25
                 lda text_top                              ;; @@2fb2 25
                 sbc index1                                ;; @@2fb4 25
                 sta text_top                             ; lo ;; @@2fb6 25
                 lda text_top+1                            ;; @@2fb8 25
                 sbc index1+1                              ;; @@2fba 25
                 sta text_top+1                           ; hi ;; @@2fbc 25
;fall into routine to insert new line (if any) ;; @@2fbe 25
 ;; @@2fbe 25
; .page ;; @@2fbe 25
nodel            jsr init_stack                           ; 'clearc' removed since text changes don't require trashing variables ;; @@2fbe 26
                 jsr link_program                         ; fix links ;; @@2fc1 26
                 jsr error_clear                          ; clear HELP/error flag, assuming he fixed whatever caused current error, if any ;; @@2fc4 26
 ;; @@2fc7 26
                 ldy #0                                    ;; @@2fc7 26
                 lda (txtptr),y                           ; delete line? ("common") ;; @@2fc9 26
                 +lbeq main                               ; yes ;; @@2fcb 26
 ;; @@2fce 26
_local_1025_5    clc                                      ; no...something to insert ;; @@2fce 26
                 ldy text_top+1                            ;; @@2fcf 26
                 lda text_top                              ;; @@2fd1 26
                 sty hightr+1                             ; top of block to move (old text_top) ;; @@2fd3 26
                 sta hightr                                ;; @@2fd5 26
                 adc count                                ; number of characters in line to be inserted ;; @@2fd7 26
                 bcc _local_1025_1                         ;; @@2fd9 26
                 iny                                       ;; @@2fdb 26
_local_1025_1    clc                                       ;; @@2fdc 26
                 adc #4                                   ; plus link and line # ;; @@2fdd 26
                 bcc _local_1025_2                        ; gives us destination of move (new text_top) ;; @@2fdf 26
                 iny                                       ;; @@2fe1 26
 ;; @@2fe2 26
_local_1025_2    sta highds                               ; destination of top ;; @@2fe2 26
                 sty highds+1                              ;; @@2fe4 26
                 cpy max_mem_0+1                          ; make sure new top doesn't crash into top of available ram ;; @@2fe6 26
                 bcc _local_1025_4                        ; ok ;; @@2fe9 26
                 +lbne omerr                              ; out of memory, don't insert ;; @@2feb 26
                 cmp max_mem_0                             ;; @@2fee 26
                 +lbcs omerr                              ; out of memory, don't insert ;; @@2ff1 26
 ;; @@2ff4 26
_local_1025_4    sta text_top                             ; set new top of text ;; @@2ff4 26
                 sty text_top+1                            ;; @@2ff6 26
                 sec                                      ; compute number of things to move up ;; @@2ff8 26
                 lda hightr                                ;; @@2ff9 26
                 sbc lowtr                                ; (old top) - (adr where new line goes) ;; @@2ffb 26
                 tay                                      ; lowtr was setup previously by FindLine call ;; @@2ffd 26
                 lda hightr+1                              ;; @@2ffe 26
                 sbc lowtr+1                               ;; @@3000 26
                 tax                                       ;; @@3002 26
 ;; @@3003 26
; Using DMA device to copy data upwards... ;; @@3003 26
; ;; @@3003 26
; (hightr)   = source  (old top) ;; @@3003 26
; (highds)   = destination (new top) ;; @@3003 26
; .y, .x     = number of bytes to move ;; @@3003 26
; (lowtr)    = where to insert new line (starting with link bytes) ;; @@3003 26
 ;; @@3003 26
                 dew hightr                               ; (text_top-1) points to actual last byte ;; @@3003 26
                 dew highds                                ;; @@3005 26
 ;; @@3007 26
; lda dma_ctlr+3  ;dma controller version    [910520] F018A ;; @@3007 26
; and #1 ;; @@3007 26
; beq _local_1025_10   ; F018    removed [910808] F018B ;; @@3007 26
                 lda #%00110000                           ; F018A, B ;; @@3007 26
_local_1025_10   sta dma1_cmd                             ; command=copy, source=endpt   [910102] ;; @@3009 26
                 sty dma1_cnt_lo                          ; count ;; @@300c 26
                 stx dma1_cnt_hi                           ;; @@300f 26
                 tya                                       ;; @@3012 26
                 ora dma1_cnt_hi                           ;; @@3013 26
                 beq _local_1025_70                       ; special case= nothing to move???? should not happen ;; @@3016 26
 ;; @@3018 26
                 lda hightr                                ;; @@3018 26
                 ldy hightr+1                              ;; @@301a 26
                 sta dma1_src_lo                          ; source ;; @@301c 26
                 sty dma1_src_hi                           ;; @@301f 26
                 lda highds                                ;; @@3022 26
                 ldy highds+1                              ;; @@3024 26
                 sta dma1_dest_lo                         ; destination ;; @@3026 26
                 sty dma1_dest_hi                          ;; @@3029 26
                 lda text_bank                            ; [910520] F018A ;; @@302c 26
; ldx dma1_cmd  ;version?    removed [910808] F018B ;; @@302e 26
; bne _local_1025_20   ; F018A ;; @@302e 26
; and #%00001111  ;      [910102] ;; @@302e 26
; ora #%01000000  ;(copy source=endpoint)    [910102] ;; @@302e 26
_local_1025_20   sta dma1_src_bank                        ; banks ;; @@302e 26
                 sta dma1_dest_bank                        ;; @@3031 26
                 lda #0                                    ;; @@3034 26
                 sta dma1_subcmd                          ; [910520] F018A ;; @@3036 26
                 sta dma_ctlr+2                           ; dma_list bank ;; @@3039 26
                 ldx #>dma1_cmd                           ; dma_list ;; @@303c 26
                 lda #<dma1_cmd                            ;; @@303e 26
                 stx dma_ctlr+1                           ; dma_list hi ;; @@3040 26
                 sta dma_ctlr                             ; dma_list lo & trigger ;; @@3043 26
 ;; @@3046 26
; Make links non-null to fool 'chead' ;; @@3046 26
 ;; @@3046 26
_local_1025_70   ldy #0                                    ;; @@3046 26
                 lda #1                                    ;; @@3048 26
                 ldx #lowtr                                ;; @@304a 26
                 jsr sta_far_ram0                         ; sta (lowtr),y  y=0 (bleed-thru) ;; @@304c 26
                 iny                                       ;; @@304f 26
                 jsr sta_far_ram0                         ; sta (lowtr),y  y=1 (bleed-thru) ;; @@3050 26
 ;; @@3053 26
; Put line number in text ;; @@3053 26
 ;; @@3053 26
                 iny                                       ;; @@3053 26
                 lda linnum                                ;; @@3054 26
                 jsr sta_far_ram0                         ; sta (lowtr),y  y=2 (bleed-thru) ;; @@3056 26
                 iny                                       ;; @@3059 26
                 lda linnum+1                              ;; @@305a 26
                 jsr sta_far_ram0                         ; sta (lowtr),y  y=3 (bleed-thru) ;; @@305c 26
 ;; @@305f 26
; Advance 'lowtr' to start of line (past link bytes & line #) ;; @@305f 26
 ;; @@305f 26
                 clc                                       ;; @@305f 26
                 lda lowtr                                 ;; @@3060 26
                 adc #4                                    ;; @@3062 26
                 sta lowtr                                 ;; @@3064 26
                 bcc _local_1025_80                        ;; @@3066 26
                 inc lowtr+1                               ;; @@3068 26
 ;; @@306a 26
 ;; @@306a 26
; Block move line to text ;; @@306a 26
 ;; @@306a 26
_local_1025_80   ldy count                                ; use dma ???? [910925] ;; @@306a 26
                 dey                                       ;; @@306c 26
 ;; @@306d 26
_local_1025_90   lda (txtptr),y                           ; (from common area) ;; @@306d 26
                 jsr sta_far_ram0                         ; sta (lowtr),y   (bleed-thru) ;; @@306f 26
                 dey                                       ;; @@3072 26
                 cpy #$ff                                  ;; @@3073 26
                 bne _local_1025_90                        ;; @@3075 26
 ;; @@3077 26
; beq _local_1025_90   ;special case= nothing to move???? should not happen ;; @@3077 26
; lda #0   ; F018A, B ;; @@3077 26
; sta dma1_cmd  ;command=copy, source=start ;; @@3077 26
; sty dma1_cnt_lo  ;count ;; @@3077 26
; sta dma1_cnt_hi ;; @@3077 26
; ;; @@3077 26
; lda txtptr ;; @@3077 26
; ldy txtptr+1 ;; @@3077 26
; sta dma1_src_lo  ;source ;; @@3077 26
; sty dma1_src_hi ;; @@3077 26
; lda lowtr ;; @@3077 26
; ldy lowtr+1 ;; @@3077 26
; sta dma1_dest_lo ;destination ;; @@3077 26
; sty dma1_dest_hi ;; @@3077 26
; lda text_bank  ;banks ;; @@3077 26
; sta dma1_dest_bank ;; @@3077 26
; lda #sys_bank  ;???? ;; @@3077 26
; sta dma1_src_bank ;; @@3077 26
; sta dma1_subcmd  ;      [910520] F018A ;; @@3077 26
; sta dma_ctlr+2  ;dma_list bank ;; @@3077 26
; ldx #>dma1_cmd  ;dma_list ;; @@3077 26
; lda #<dma1_cmd ;; @@3077 26
; stx dma_ctlr+1  ;dma_list hi ;; @@3077 26
; sta dma_ctlr  ;dma_list lo & trigger ;; @@3077 26
;_local_1025_90 ;; @@3077 26
                 jsr link_program                          ;; @@3077 26
                 jsr reset_txtptr                         ; set up txtptr (was jsr runc) ;; @@307a 26
 ;; @@307d 26
; Test if AUTO in effect ;; @@307d 26
 ;; @@307d 26
                 lda autinc                               ; if in auto mode, increment val <> 0 ;; @@307d 26
                 ora autinc+1                              ;; @@307f 26
                 beq _local_1025_120                      ; not in ;; @@3081 26
 ;; @@3083 26
                 lda linnum                               ; yes, construct new line number ;; @@3083 26
                 clc                                       ;; @@3085 26
                 adc autinc                                ;; @@3086 26
                 sta facho+1                               ;; @@3088 26
                 lda linnum+1                              ;; @@308a 26
                 adc autinc+1                              ;; @@308c 26
                 bcs _local_1025_120                      ; no auto if wrapped ;; @@308e 26
                 cmp #$fa                                 ; test if # >= 64000 ;; @@3090 26
                 bcs _local_1025_120                      ; no auto if so. ;; @@3092 26
                 sta facho                                 ;; @@3094 26
                 ldx #$90                                  ;; @@3096 26
                 sec                                       ;; @@3098 26
                 jsr floatc                               ; float it ;; @@3099 26
                 jsr fout                                 ; make it into a string ;; @@309c 26
 ;; @@309f 26
                 sei                                      ; [910710] ;; @@309f 26
                 ldx #0                                   ; move string into kbd buffer ;; @@30a0 26
_local_1025_100  lda fbuffr+1,x                           ; copy number formed into buffer, ignoring leading space ;; @@30a2 26
                 beq _local_1025_110                      ; a null marks end ;; @@30a5 26
                 sta _keyd,x                               ;; @@30a7 26
                 inx                                       ;; @@30aa 26
                 bne _local_1025_100                      ; always ;; @@30ab 26
 ;; @@30ad 26
_local_1025_110  lda #29                                  ; cursor right ;; @@30ad 26
                 sta _keyd,x                               ;; @@30af 26
                 inx                                       ;; @@30b2 26
                 stx _ndx                                  ;; @@30b3 26
                 cli                                      ; [910710] ;; @@30b5 26
 ;; @@30b6 26
_local_1025_120  +lbra main                                ;; @@30b6 26
 ;; @@30b9 26
 ;; @@30b9 26
; .page ;; @@30b9 26
link_program                                               ;; @@30b9 27
                 lda txttab                                ;; @@30b9 27
                 ldy txttab+1                              ;; @@30bb 27
                 sta index                                 ;; @@30bd 27
                 sty index+1                               ;; @@30bf 27
                 clc                                       ;; @@30c1 27
 ;; @@30c2 27
chead            ldy #0                                    ;; @@30c2 27
                 jsr indin1                               ; lda (index),y .. check for null link ;; @@30c4 27
                 bne _local_1026_10                        ;; @@30c7 27
                 iny                                       ;; @@30c9 27
                 jsr indin1                               ; lda (index),y ;; @@30ca 27
                 beq lnkrts                                ;; @@30cd 27
 ;; @@30cf 27
_local_1026_10   ldy #3                                   ; [900524] ;; @@30cf 27
_local_1026_20   iny                                      ; ???? very expensive loop ???? ;; @@30d1 27
                 cpy #254                                  ;; @@30d2 27
                 bcs link_error                           ; failsafe- program is mangled  [910103] ;; @@30d4 27
                 jsr indin1                               ; lda (index),y ;; @@30d6 27
                 bne _local_1026_20                        ;; @@30d9 27
                 iny                                       ;; @@30db 27
                 tya                                       ;; @@30dc 27
                 adc index                                 ;; @@30dd 27
                 pha                                       ;; @@30df 27
                 ldy #0                                    ;; @@30e0 27
                 ldx #index                                ;; @@30e2 27
                 jsr sta_far_ram0                         ; sta (index),y   (bleed-thru) ;; @@30e4 27
                 tya                                       ;; @@30e7 27
                 adc index+1                               ;; @@30e8 27
                 iny                                       ;; @@30ea 27
                 jsr sta_far_ram0                         ; sta (index),y   (bleed-thru) ;; @@30eb 27
                 plx                                       ;; @@30ee 27
                 stx index                                 ;; @@30ef 27
                 sta index+1                               ;; @@30f1 27
                 bra chead                                ; always ;; @@30f3 27
 ;; @@30f5 27
 ;; @@30f5 27
link_error                                                ; [910103] ;; @@30f5 28
                 jsr highlight_text                       ; [911119] ;; @@30f5 28
                 jsr _primm                                ;; @@30f8 28
                 !text cr,"?PROGRAM MANGLED",cr,0          ;; @@30fb 28
                 jsr highlight_done                       ; [911119] ;; @@310e 28
 ;; @@3111 28
 ;; @@3111 28
lnkrts           rts                                       ;; @@3111 28
 ;; @@3112 28
; .page ;; @@3112 28
; Function to get a line one character at a time from the input ;; @@3112 28
; channel and build it in the input buffer. ;; @@3112 28
; ;; @@3112 28
 ;; @@3112 28
PromptedInput                                             ; qinlin. ;; @@3112 28
                 lda channl                               ; entry for things line INPUT, wanting a prompt ;; @@3112 28
                 bne InputLine                            ; prompt only if terminal ;; @@3114 28
                 jsr outqst                               ; yes- print '? ' ;; @@3116 28
                 jsr realsp                                ;; @@3119 28
 ;; @@311c 28
 ;; @@311c 28
InputLine                                                 ; inlin. ;; @@311c 28
                 ldx #0                                   ; read & buffer data until 'return' or buffer full ;; @@311c 28
_local_1027_10   jsr inchr                                ; get a character ;; @@311e 28
                 cmp #0                                    ;; @@3121 28
                 beq _local_1027_20                        ;; @@3123 28
                 cmp #cr                                  ; a carriage return? ;; @@3125 28
                 beq _local_1027_20                       ; yes...done build ;; @@3127 28
 ;; @@3129 28
                 sta buf,x                                ; no...buffer it ;; @@3129 28
                 inx                                       ;; @@312c 28
                 cpx #buflen                              ; buffer full? ;; @@312d 28
                 bcc _local_1027_10                       ; no...continue ;; @@312f 28
                 +lbra errlen                             ; yes...string too long error ;; @@3131 28
 ;; @@3134 28
 ;; @@3134 28
_local_1027_20   lda #0                                   ; fininl.  terminate input with a null ;; @@3134 28
                 sta buf,x                                 ;; @@3136 28
                 ldx #<buf_txtptr                         ; set up pointer to start of buffer-1 (for chrget) ;; @@3139 28
                 ldy #>buf_txtptr                          ;; @@313b 28
                 lda channl                               ; print 'return' only if terminal ;; @@313d 28
                 +lbeq crdo                                ;; @@313f 28
                 rts                                       ;; @@3142 28
 ;; @@3143 28
;.end ;; @@3143 28
; .page ;; @@3143 28
; .subttl Runtime Stack Routines ;; @@3143 28
 ;; @@3143 28
; Find a specific token in the run-time stack. token to be found is in srchtk. ;; @@3143 28
; ;; @@3143 28
; If called by 'for' or 'next', scan entries in stack, looking for a specific ;; @@3143 28
; 'for-variable' (in (forpnt)).  If found, (fndpnt) will point to it, and z is ;; @@3143 28
; set.  Otherwise, (fndpnt) will point to either: ;; @@3143 28
;  1) the non-for token ;; @@3143 28
;  2) bottom-of-stack ;; @@3143 28
; ;; @@3143 28
; Special case: 'next' with no argument will match first 'for' entry on stack ;; @@3143 28
; found, if any.  This case is signaled by a (forpnt) with a msb of $ff (an ;; @@3143 28
; impossible value). ;; @@3143 28
; ;; @@3143 28
; All other calls to search will result in either: ;; @@3143 28
;  1) (success) z = 1, (fndpnt) = address ;; @@3143 28
;  2) (failure) z = 0 ;; @@3143 28
 ;; @@3143 28
 ;; @@3143 28
; Set up temporary pointer with current top of stack ;; @@3143 28
 ;; @@3143 28
search           sta srchtk                               ; save token to search for ;; @@3143 29
                 jsr movtos                               ; tos => fndpnt ;; @@3145 29
 ;; @@3148 29
 ;; @@3148 29
; Test if pointer is at bottom of stack.  If so, the item was not found. ;; @@3148 29
 ;; @@3148 29
_local_1028_5    lda fndpnt                                ;; @@3148 29
                 cmp #<stkbot                              ;; @@314a 29
                 bne _local_1028_10                       ; (fndpnt) <> bottom, ok ;; @@314c 29
                 lda fndpnt+1                             ; lsb's the same, test msb's ;; @@314e 29
                 cmp #>stkbot                              ;; @@3150 29
                 beq _local_1028_98                       ; stack empty, rts ;; @@3152 29
 ;; @@3154 29
_local_1028_10   ldy #0                                    ;; @@3154 29
                 lda srchtk                               ; what are we looking for? ;; @@3156 29
                 cmp #for_token                           ; 'for' tokens are special cases ;; @@3158 29
                 bne _local_1028_20                        ;; @@315a 29
 ;; @@315c 29
; Looking for a 'for' token.  If next token examined is not a 'for' token, ;; @@315c 29
; return with z = 0.  Otherwise, check the pointer to its 'for' variable. ;; @@315c 29
; If the variable pointer = (forpnt) or if (forpnt) = $FFxx, return with z=1. ;; @@315c 29
; Otherwise, set up x with length of a 'for' entry, and use the usual ;; @@315c 29
; mechanisim for examining the next entry. ;; @@315c 29
 ;; @@315c 29
                 cmp (fndpnt),y                           ; indirect ok- looking at runtime stack???? ;; @@315c 29
                 bne _local_1028_99                       ; not 'for', do rts with z = 0 ;; @@315e 29
                 ldy #2                                   ; point to msb of 'for' variable ;; @@3160 29
                 lda forpnt+1                              ;; @@3162 29
                 cmp #$ff                                  ;; @@3164 29
                 beq _local_1028_99                       ; do rts with z = 1 ;; @@3166 29
                 cmp (fndpnt),y                            ;; @@3168 29
                 bne _local_1028_15                       ; not right variable, keep looking. ;; @@316a 29
                 dey                                       ;; @@316c 29
                 lda forpnt                               ; test lsb ;; @@316d 29
                 cmp (fndpnt),y                            ;; @@316f 29
                 beq _local_1028_99                       ; a hit! rts with z = 1 ;; @@3171 29
 ;; @@3173 29
_local_1028_15   ldx #lenfor                               ;; @@3173 29
                 bra _local_1028_30                       ; keep looking ;; @@3175 29
 ;; @@3177 29
_local_1028_20   lda (fndpnt),y                            ;; @@3177 29
                 cmp srchtk                               ; is this the correct type of entry? ;; @@3179 29
                 beq _local_1028_99                       ; rts with z = 1 ;; @@317b 29
 ;; @@317d 29
; The entry on top of the run-time stack is not the entry we are looking for. ;; @@317d 29
; Find out what is there, and advance temp. pointer past it. ;; @@317d 29
 ;; @@317d 29
                 ldx #lenfor                              ; is it a 'for' entry? ;; @@317d 29
                 cmp #for_token                            ;; @@317f 29
                 beq _local_1028_30                        ;; @@3181 29
                 ldx #5                                   ; must be gosub or do by default ;; @@3183 29
 ;; @@3185 29
_local_1028_30   txa                                       ;; @@3185 29
                 clc                                       ;; @@3186 29
                 adc fndpnt                                ;; @@3187 29
                 sta fndpnt                                ;; @@3189 29
                 bcc _local_1028_5                         ;; @@318b 29
                 inc fndpnt+1                              ;; @@318d 29
                 bra _local_1028_5                        ; always ;; @@318f 29
 ;; @@3191 29
_local_1028_98   ldy #1                                   ; clear z flag ;; @@3191 29
_local_1028_99   rts                                       ;; @@3193 29
 ;; @@3194 29
; .page ;; @@3194 29
; GETSTK ;; @@3194 29
; ;; @@3194 29
; Add (.A) elements to top of run-time stack.  Error if result exceeds tos. ;; @@3194 29
 ;; @@3194 29
getstk           eor #$ff                                 ; make value 2's comp. ;; @@3194 30
                 sec                                       ;; @@3196 30
                 adc tos                                   ;; @@3197 30
                 sta tos                                   ;; @@3199 30
                 ldy tos+1                                 ;; @@319b 30
                 bcs _local_1029_10                        ;; @@319d 30
                 dey                                       ;; @@319f 30
_local_1029_10   sty tos+1                                 ;; @@31a0 30
                 cpy #>stktop                              ;; @@31a2 30
                 +lbcc omerr                               ;; @@31a4 30
                 bne _local_1029_20                        ;; @@31a7 30
                 cmp tos                                   ;; @@31a9 30
                 +lbcc omerr                               ;; @@31ab 30
_local_1029_20   rts                                       ;; @@31ae 30
 ;; @@31af 30
; .page ;; @@31af 30
; (a,y) is a certain address.  REASON makes sure it is less than (fretop). ;; @@31af 30
 ;; @@31af 30
reason           cpy fretop+1                              ;; @@31af 31
                 bcc _local_1030_4                         ;; @@31b1 31
                 bne _local_1030_1                        ; go garbage collect ;; @@31b3 31
                 cmp fretop                                ;; @@31b5 31
                 bcc _local_1030_4                         ;; @@31b7 31
 ;; @@31b9 31
_local_1030_1    pha                                       ;; @@31b9 31
                 ldx #9                                   ; if tempf2 has zero in between ;; @@31ba 31
                 tya                                       ;; @@31bc 31
 ;; @@31bd 31
_local_1030_2    pha                                       ;; @@31bd 31
                 lda highds-1,x                           ; save highds on stack ;; @@31be 31
                 dex                                       ;; @@31c0 31
                 bpl _local_1030_2                        ; put 8 of them on stack ;; @@31c1 31
                 jsr garba2                               ; go garbage collect ;; @@31c3 31
                 ldx #$f7                                  ;; @@31c6 31
 ;; @@31c8 31
_local_1030_3    pla                                       ;; @@31c8 31
                 sta highds+9,x                           ; restore after garbage collect ;; @@31c9 31
                 inx                                       ;; @@31cb 31
                 bmi _local_1030_3                         ;; @@31cc 31
                 ply                                       ;; @@31ce 31
                 pla                                      ; restore .a and .y ;; @@31cf 31
                 cpy fretop+1                             ; compare highs ;; @@31d0 31
                 bcc _local_1030_4                         ;; @@31d2 31
                 +lbne omerr                              ; higher is bad ;; @@31d4 31
                 cmp fretop                               ; compare the lows ;; @@31d7 31
                 +lbcs omerr                               ;; @@31d9 31
_local_1030_4    rts                                       ;; @@31dc 31
 ;; @@31dd 31
; .page ;; @@31dd 31
 ;; @@31dd 31
;  Utilities involved in the operation of the BASIC run-time stack. ;; @@31dd 31
 ;; @@31dd 31
 ;; @@31dd 31
; Move top-of-stack pointer to (fndpnt) ;; @@31dd 31
 ;; @@31dd 31
movtos           lda tos                                   ;; @@31dd 32
                 sta fndpnt                                ;; @@31df 32
                 lda tos+1                                 ;; @@31e1 32
                 sta fndpnt+1                              ;; @@31e3 32
                 rts                                       ;; @@31e5 32
 ;; @@31e6 32
 ;; @@31e6 32
 ;; @@31e6 32
; move (fndpnt) to (tos) ;; @@31e6 32
 ;; @@31e6 32
movfnd           lda fndpnt                                ;; @@31e6 32
                 sta tos                                   ;; @@31e8 32
                 lda fndpnt+1                              ;; @@31ea 32
                 sta tos+1                                 ;; @@31ec 32
                 rts                                       ;; @@31ee 32
 ;; @@31ef 32
; Reduce size of run-time stack by (y).  No error checking performed! ;; @@31ef 32
 ;; @@31ef 32
rlsstk           tya                                       ;; @@31ef 32
                 clc                                       ;; @@31f0 32
                 adc tos                                   ;; @@31f1 32
                 sta tos                                   ;; @@31f3 32
                 bcc _local_1031_10                        ;; @@31f5 32
                 inc tos+1                                 ;; @@31f7 32
_local_1031_10   rts                                       ;; @@31f9 32
 ;; @@31fa 32
;.end ;; @@31fa 32
; .page ;; @@31fa 32
; .subttl FindLine ;; @@31fa 32
 ;; @@31fa 32
; FindLine ;; @@31fa 32
; Searches the program text for the line whose number is passed in "linnum". ;; @@31fa 32
; There are two possible returns: ;; @@31fa 32
; ;; @@31fa 32
; 1) carry set. ;; @@31fa 32
;  Line found.  (lowtr) points to the link bytes of line sought. ;; @@31fa 32
; ;; @@31fa 32
; 2) carry clear. ;; @@31fa 32
;  Line not found.  (lowtr) points to the link bytes of the next ;; @@31fa 32
;  line greater than the one sought. ;; @@31fa 32
 ;; @@31fa 32
FindLine                                                   ;; @@31fa 33
                 lda txttab                               ; init pointer to beginning of program ;; @@31fa 33
                 ldx txttab+1                              ;; @@31fc 33
 ;; @@31fe 33
FindLink                                                   ;; @@31fe 33
                 sta lowtr                                ; current position in program ;; @@31fe 33
                 stx lowtr+1                               ;; @@3200 33
                 ldy #1                                    ;; @@3202 33
                 jsr indlow                               ; end of program (null link)? ;; @@3204 33
                 beq _local_1032_3                        ; yes, exit with .c=0 (not found) ;; @@3207 33
                 iny                                       ;; @@3209 33
                 iny                                       ;; @@320a 33
                 jsr indlow                               ; get line number of this line (high byte first) ;; @@320b 33
; sta syntmp ;; @@320e 33
; lda linnum+1 ;is this the line we're looking for? ;; @@320e 33
; cmp syntmp ;; @@320e 33
; bcc _local_1032_4  ; no- too high, so the line does not exist, exit ;; @@320e 33
; beq _local_1032_1 ;; @@320e 33
; dey  ; no- too low, so get link to next line ;; @@320e 33
; bra _local_1032_2 ;; @@320e 33
                 cmp linnum+1                             ; is this the line we're looking for?   [910925] ;; @@320e 33
                 beq _local_1032_1                        ; maybe ;; @@3210 33
                 bcs _local_1032_3                        ; no- too high, so the line does not exist, exit with .c=0 ;; @@3212 33
                 dey                                      ; no- too low, so get link to next line ;; @@3214 33
                 bra _local_1032_2                         ;; @@3215 33
 ;; @@3217 33
_local_1032_1    dey                                      ; maybe- have to check low byte ;; @@3217 33
                 jsr indlow                                ;; @@3218 33
; sta syntmp ;; @@321b 33
; lda linnum ;; @@321b 33
; cmp syntmp ;; @@321b 33
; bcc _local_1032_4  ; no- too high, exit ;; @@321b 33
; beq _local_1032_4  ; yes- got it, exit ;; @@321b 33
                 cmp linnum                               ; is this the line we're looking for?   [910925] ;; @@321b 33
                 beq _local_1032_4                        ; yes- got it, exit with .c=1 ;; @@321d 33
                 bcs _local_1032_3                        ; no- too high, so the line does not exist, exit with .c=0 ;; @@321f 33
 ;; @@3221 33
_local_1032_2    dey                                      ; get link to next line ;; @@3221 33
                 jsr indlow                                ;; @@3222 33
                 tax                                       ;; @@3225 33
                 dey                                       ;; @@3226 33
                 jsr indlow                                ;; @@3227 33
                 bra FindLink                             ; continue looking ;; @@322a 33
 ;; @@322c 33
 ;; @@322c 33
_local_1032_3    clc                                      ; exit, line not found (.c=0) ;; @@322c 33
_local_1032_4    rts                                      ; exit, line found (.c=1) ;; @@322d 33
 ;; @@322e 33
;.end ;; @@322e 33
; .page ;; @@322e 33
; .subttl LinGet ;; @@322e 33
 ;; @@322e 33
; LINGET  Reads a line # from the current txtptr position ;; @@322e 33
;   and stores it in linnum  (valid range is 0-63999). ;; @@322e 33
; ;; @@322e 33
;   On exit txtptr is pointing to the terminating char ;; @@322e 33
;   which is in .a with condition codes set. ;; @@322e 33
;   Endchr will be =0 if no digit input, else >0.  Use it ;; @@322e 33
;   to distinguish between line # 0 & null input. ;; @@322e 33
 ;; @@322e 33
linget           ldx #0                                   ; enter with CHRGET flags set ;; @@322e 34
                 stx endchr                               ; flags line # input ;; @@3230 34
                 stx linnum                               ; init line # to 0 ;; @@3232 34
                 stx linnum+1                              ;; @@3234 34
 ;; @@3236 34
_local_1033_10   bcs _local_1033_40                       ; it's not a digit, do rts ;; @@3236 34
_local_1033_15   inc endchr                               ; indicate line # input ;; @@3238 34
                 sbc #$2f                                 ; '0'-1 since .c=0 ;; @@323a 34
                 sta charac                               ; save for later ;; @@323c 34
                 lda linnum+1                              ;; @@323e 34
                 sta index                                 ;; @@3240 34
                 cmp #25                                  ; line number will be < 64000? ;; @@3242 34
                 bcc _local_1033_20                       ; yes, continue ;; @@3244 34
                 bbs1 helper,_local_1033_40               ; no, if called by AutoScroll it's okay ;; @@3246 34
                 +lbra snerr                              ; else syntax error ;; @@3249 34
 ;; @@324c 34
_local_1033_20   lda linnum                                ;; @@324c 34
                 asl                                      ; multiply by 10 ;; @@324e 34
                 rol index                                 ;; @@324f 34
                 asl                                       ;; @@3251 34
                 rol index                                 ;; @@3252 34
                 adc linnum                                ;; @@3254 34
                 sta linnum                                ;; @@3256 34
                 lda index                                 ;; @@3258 34
                 adc linnum+1                              ;; @@325a 34
                 sta linnum+1                              ;; @@325c 34
                 asl linnum                                ;; @@325e 34
                 rol linnum+1                              ;; @@3260 34
                 lda linnum                                ;; @@3262 34
                 adc charac                               ; add in digit ;; @@3264 34
                 sta linnum                                ;; @@3266 34
                 bcc _local_1033_30                        ;; @@3268 34
                 inc linnum+1                              ;; @@326a 34
_local_1033_30                                             ;; @@326c 34
; jsr chrget  ;ALLOW SPACES to terminate number  [910620] ;; @@326c 34
; bra _local_1033_10 ;; @@326c 34
                 inw txtptr                               ; get next character from text ;; @@326c 34
                 ldy #0                                   ; re-get current character from text ;; @@326e 34
                 jsr indtxt                               ; lda (txtptr),y from RAM0 ;; @@3270 34
                 cmp #' '                                 ; space=eol    [910708] ;; @@3273 34
                 beq _local_1033_50                        ;; @@3275 34
                 cmp #':'                                 ;  ;; @@3277 34
                 bcs _local_1033_40                       ; eol ;; @@3279 34
                 sec                                       ;; @@327b 34
                 sbc #'0'                                 ; alpha or numeric? ;; @@327c 34
                 sec                                       ;; @@327e 34
                 sbc #$d0                                  ;; @@327f 34
                 bcc _local_1033_15                       ; numeric ;; @@3281 34
_local_1033_40   rts                                      ; exit ;; @@3283 34
 ;; @@3284 34
_local_1033_50   jsr chargt                               ; terminating character is a space, eat it just this once ;; @@3284 34
                 +lbra chrtst                             ; return with flags set appropriately (esp. for 'range') ;; @@3287 34
 ;; @@328a 34
;.end ;; @@328a 34
; .page ;; @@328a 34
; .subttl LIST ;; @@328a 34
 ;; @@328a 34
list             rmb7 helper                              ; clear 'help' flag for p1line ;; @@328a 35
 ;; @@328c 35
; Determine which form of LIST we have... ;; @@328c 35
 ;; @@328c 35
                 +lbeq list_memory                        ; branch if terminator (no parameter) ;; @@328c 35
                 +lbcc list_memory                        ; branch if a number (assume range parameter) ;; @@328f 35
                 cmp #minus_token                          ;; @@3292 35
                 +lbeq list_memory                        ; branch if a dash (assume range parameter) ;; @@3294 35
 ;; @@3297 35
 ;; @@3297 35
; LIST command is of the form  LIST filename [,U#] [,D#] ;; @@3297 35
 ;; @@3297 35
list_file                                                  ;; @@3297 35
                 lda #$e6                                 ; parse:  filename [,U#] [,D#] ;; @@3297 35
                 jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 ) ;; @@3299 35
                 jsr chk1                                 ; check parameters ;; @@329c 35
                 lda #0                                    ;; @@329f 35
                 sta dossa                                ; setup as dload would (0 = load channel) ;; @@32a1 35
                 jsr find_la                              ; find an available la to use (cannot use reserved one) ;; @@32a4 35
                 ldy #fopn                                 ;; @@32a7 35
                 ldx #4                                    ;; @@32a9 35
                 jsr open_file                            ; open the file ;; @@32ab 35
                 bcs list_err                             ; exit if error ;; @@32ae 35
 ;; @@32b0 35
                 ldx dosla                                 ;; @@32b0 35
                 jsr _chkin                               ; get input channel ;; @@32b3 35
                 bcs list_err                             ; exit if bad?? ;; @@32b6 35
                 jsr _basin                               ; waste 'load address' ;; @@32b8 35
                 jsr _basin                                ;; @@32bb 35
 ;; @@32be 35
_local_1034_10   jsr _basin                               ; get link bytes ;; @@32be 35
                 sta dosstr                                ;; @@32c1 35
                 jsr _basin                                ;; @@32c4 35
                 sta dosstr+1                              ;; @@32c7 35
                 ora dosstr                                ;; @@32ca 35
                 beq list_exit                            ; done if null pointer ;; @@32cd 35
                 jsr _readst                               ;; @@32cf 35
                 bne list_exit                            ; done if eof or bad status ;; @@32d2 35
; ???? assumes serial bus ;; @@32d4 35
                 lda #>dosstr                             ; point p1line's pointer at our line buffer ;; @@32d4 35
                 ldx #<dosstr                              ;; @@32d6 35
                 sta lowtr+1                               ;; @@32d8 35
                 stx lowtr                                 ;; @@32da 35
 ;; @@32dc 35
                 ldx #2                                    ;; @@32dc 35
                 jsr _basin                               ; read line into buffer ;; @@32de 35
                 sta dosstr,x                              ;; @@32e1 35
                 inx                                       ;; @@32e4 35
                 jsr _basin                               ; 2-byte line # ;; @@32e5 35
                 sta dosstr,x                              ;; @@32e8 35
                 inx                                       ;; @@32eb 35
_local_1034_20   cpx #255                                 ; check buffer (buflen????) ;; @@32ec 35
                 +lbcs errlen                             ; 'too long' error ;; @@32ee 35
                 jsr _basin                                ;; @@32f1 35
                 sta dosstr,x                              ;; @@32f4 35
                 inx                                       ;; @@32f7 35
                 tay                                      ; save char ;; @@32f8 35
                 jsr _readst                              ; check channel status (serial bus????) ;; @@32f9 35
                 bne list_exit                            ; exit if eof or error ;; @@32fc 35
                 jsr _stop                                 ;; @@32fe 35
                 beq list_exit                            ; exit if stop key down ;; @@3301 35
                 tya                                       ;; @@3303 35
                 bne _local_1034_20                       ; loop until eol ;; @@3304 35
 ;; @@3306 35
                 jsr dcato                                ; get output channel ;; @@3306 35
                 jsr crdo                                 ; start new line ;; @@3309 35
                 ldx dosstr+2                             ; get line # ;; @@330c 35
                 lda dosstr+3                              ;; @@330f 35
                 jsr p1line                               ; print line #, space, and the line of code ;; @@3312 35
                 jsr _clrch                                ;; @@3315 35
                 ldx dosla                                 ;; @@3318 35
                 jsr _chkin                               ; get input channel ;; @@331b 35
                 bcc _local_1034_10                       ; [900730] ;; @@331e 35
 ;; @@3320 35
list_exit                                                  ;; @@3320 36
                 jsr dcato                                ; flush last line with a <cr> ;; @@3320 36
                 jsr crdo                                 ; flush current line ;; @@3323 36
                 clc                                      ; no errors    [910404] ;; @@3326 36
list_err                                                   ;; @@3327 36
                 php                                      ; save error status   [910404] ;; @@3327 36
                 pha                                       ;; @@3328 36
                 jsr release_channels                     ; release cmd channel, restore terminal ;; @@3329 36
                 lda dosla                                 ;; @@332c 36
; bra close_out  ;    removed [900725] ;; @@332f 36
                 clc                                      ; a real close   new [910404] ;; @@332f 36
                 jsr _close                                ;; @@3330 36
                 pla                                      ; pop error status, if any ;; @@3333 36
                 plp                                       ;; @@3334 36
                 +lbra exit_disk_op                        ;; @@3335 36
 ;; @@3338 36
; .page ;; @@3338 36
; LIST command is of the form  LIST [range] ;; @@3338 36
 ;; @@3338 36
list_memory                                                ;; @@3338 36
                 jsr range                                ; set up line range ;; @@3338 36
 ;; @@333b 36
_local_1035_10   ldy #1                                    ;; @@333b 36
                 jsr indlow                               ; get ms byte of line to list's pointer ;; @@333d 36
                 bne _local_1035_20                       ; ok if not zero, but.. ;; @@3340 36
                 dey                                       ;; @@3342 36
                 jsr indlow                                ;; @@3343 36
                 +lbeq crdo                               ; ..if ls byte is also zero, we're done ;; @@3346 36
 ;; @@3349 36
_local_1035_20   jsr is_stop_key_down                      ;; @@3349 36
                 jsr crdo                                 ; new line ;; @@334c 36
                 ldy #2                                    ;; @@334f 36
                 jsr indlow                               ; get ms byte of line number ;; @@3351 36
                 tax                                       ;; @@3354 36
                 iny                                       ;; @@3355 36
                 jsr indlow                               ; get ls byte ;; @@3356 36
 ;; @@3359 36
                 cmp linnum+1                             ; test if we are past the last line requested ;; @@3359 36
                 bne _local_1035_30                        ;; @@335b 36
                 cpx linnum                                ;; @@335d 36
                 beq _local_1035_40                        ;; @@335f 36
_local_1035_30   +lbcs crdo                               ; next line is > last line requested, exit ;; @@3361 36
_local_1035_40   jsr p1line                               ; print line #, space, and the line of code ;; @@3364 36
                 ldy #0                                   ; move 'pointer to next line' into (lowtr) ;; @@3367 36
                 jsr indlow                                ;; @@3369 36
                 tax                                       ;; @@336c 36
                 iny                                       ;; @@336d 36
                 jsr indlow                                ;; @@336e 36
                 stx lowtr                                 ;; @@3371 36
                 sta lowtr+1                               ;; @@3373 36
                 bra _local_1035_10                        ;; @@3375 36
 ;; @@3377 36
; .page ;; @@3377 36
;****************************************************** ;; @@3377 36
; P1LINE Print 1 line of BASIC text ;; @@3377 36
; ;; @@3377 36
; Entry: (a,x) contains line number low,high ;; @@3377 36
;  (lowtr) points to beginning of line ;; @@3377 36
; ;; @@3377 36
; next-line   line-num  BASIC text......  null ;; @@3377 36
; lo    hi    lo    hi  byte byte...byte   00 ;; @@3377 36
;        ^           ^     ^ ;; @@3377 36
;    (lowtr)        .A    .X ;; @@3377 36
;****************************************************** ;; @@3377 36
 ;; @@3377 36
p1line           bbr4 runmod,_local_1036_10               ; [910620] ;; @@3377 37
                 +lbra edit_p1line                        ; handle things differently for plain text ;; @@337a 37
 ;; @@337d 37
_local_1036_10   ldy #3                                    ;; @@337d 37
                 sty lstpnt                                ;; @@337f 37
                 sty dores                                ; reset quote-switch ;; @@3381 37
                 jsr linprt                               ; print line number ;; @@3383 37
                 lda #' '                                 ; print a space ;; @@3386 37
 ;; @@3388 37
p1l010           ldy lstpnt                                ;; @@3388 38
                 and #$7f                                  ;; @@338a 38
 ;; @@338c 38
p1l015           cmp #':'                                 ; end-of-stmt?     [900516] ;; @@338c 38
                 bne _local_1037_5                        ; no ;; @@338e 38
                 bbr7 helper,_local_1037_5                ; yes, but skip e-o-s check if not HELP... ;; @@3390 38
                 bbs7 dores,_local_1037_5                 ; or ':' is inside quotes ;; @@3393 38
                 jsr highlight_done                       ; yes, restore normal text color ;; @@3396 38
                 lda #':'                                  ;; @@3399 38
 ;; @@339b 38
_local_1037_5    jsr outch                                ; outdo ;; @@339b 38
                 cmp #'"'                                 ; if quote character, toggle quote-switch ;; @@339e 38
                 bne _local_1037_10                        ;; @@33a0 38
                 lda dores                                 ;; @@33a2 38
                 eor #$ff                                  ;; @@33a4 38
                 sta dores                                 ;; @@33a6 38
 ;; @@33a8 38
_local_1037_10   iny                                      ; point to next character (should never wrap) ;; @@33a8 38
                 bbs0 helper,_local_1037_15               ; branch if highlighting tokens ;; @@33a9 38
                 bbs5 helper,_local_1037_15               ; branch if called by FIND/CHANGE ;; @@33ac 38
                 bbr7 helper,_local_1037_20               ; branch if called by LIST or HELP satisfied ;; @@33af 38
_local_1037_15   jsr helpsb                                ;; @@33b2 38
 ;; @@33b5 38
_local_1037_20   jsr indlow                                ;; @@33b5 38
                 +lbeq highlight_done                     ; finished when trailing null is found ;; @@33b8 38
                 jmp (iqplop)                             ; usually points to nqplop ;; @@33bb 38
 ;; @@33be 38
; .page ;; @@33be 38
nqplop                                                    ; <<<<<<< vector entry ;; @@33be 39
                 bpl p1l015                               ; not a token, just print character ;; @@33be 39
                 bbs7 dores,p1l015                        ; branch if inside quotes, print chr as is ;; @@33c0 39
 ;; @@33c3 39
;  At this point, we know we're talking token.  Scan the token text ;; @@33c3 39
;  list until the correct text is found, and print that text. ;; @@33c3 39
 ;; @@33c3 39
                 sta token_saver                          ; save token for REM check   [910626] ;; @@33c3 39
                 cmp #esc_command_token                   ; is this an escape token? ;; @@33c5 39
                 beq print_esc_cmd                        ; yes- escape command ;; @@33c7 39
                 cmp #esc_function_token                   ;; @@33c9 39
                 beq print_esc_fn                         ; yes- escape function ;; @@33cb 39
                 cmp #pi                                   ;; @@33cd 39
                 beq p1l015                               ; no- pi is >$80, but should be printed 'as is' ;; @@33cf 39
                 tax                                       ;; @@33d1 39
                 sty lstpnt                               ; no- use the token as index into ROM keyword list ;; @@33d2 39
                 lda #>keyword_list                        ;; @@33d4 39
                 ldy #<keyword_list                        ;; @@33d6 39
 ;; @@33d8 39
; Scan list pointed to by (y,a) for token in (x), and print token's text ;; @@33d8 39
 ;; @@33d8 39
p1l026           sta index1+1                             ; index1 points to token text list in ROM ;; @@33d8 39
                 sty index1                                ;; @@33da 39
                 ldy #0                                   ; begin scanning lists for this token's text ;; @@33dc 39
                 dex                                       ;; @@33de 39
                 bpl p1l070                               ; what luck! it's the first one ;; @@33df 39
 ;; @@33e1 39
_local_1038_10   inw index1                               ; scan text until next command found ;; @@33e1 39
                 lda (index1),y                           ; ind.ok (ROM) ;; @@33e3 39
                 bpl _local_1038_10                       ; loop until terminal char (msb=1) ;; @@33e5 39
                 dex                                      ; is next text the one we want? ;; @@33e7 39
                 bmi _local_1038_10                       ; no, keep scanning ;; @@33e8 39
                 inw index1                               ; yes, point to first character ;; @@33ea 39
 ;; @@33ec 39
                 bbr3 helper,p1l070                       ; found text for this token, is it REM?  [910626] ;; @@33ec 39
                 lda token_saver                          ; [910628] ;; @@33ef 39
                 cmp #rem_token                            ;; @@33f1 39
                 beq p1l071                               ; yes, and REM highlighting is enabled ;; @@33f3 39
 ;; @@33f5 39
p1l070                                                    ; found text for this token ;; @@33f5 40
                 bbr4 helper,p1l072                       ; branch if not highlighting tokens ;; @@33f5 40
                 lda (index1),y                           ; peek at first character ;; @@33f8 40
                 bmi p1l010                               ; branch if operator (1-byte, msb=1) ;; @@33fa 40
                 smb0 helper                              ; else begin highlight ;; @@33fc 40
p1l071           jsr highlight_text                        ;; @@33fe 40
 ;; @@3401 40
p1l072           lda (index1),y                           ; get char from ROM table ;; @@3401 40
                 bmi p1l010                               ; msb=1=last char this token, contine line ;; @@3403 40
                 jsr outch                                ; else print it ;; @@3405 40
                 iny                                       ;; @@3408 40
                 bra p1l072                                ;; @@3409 40
 ;; @@340b 40
; .page ;; @@340b 40
; Print Escape Command ;; @@340b 40
 ;; @@340b 40
print_esc_cmd                                              ;; @@340b 40
                 tax                                      ; save type (cmd) in case it is a foreign esc token ;; @@340b 40
                 iny                                       ;; @@340c 40
                 jsr indlow                               ; look at second token ;; @@340d 40
                 +lbeq p1l015                             ; none?  print funny character ;; @@3410 40
                 sty lstpnt                                ;; @@3413 40
                 cmp #first_esc_command_token             ; is this one of ours? ;; @@3415 40
                 bcc print_foreign_esc                    ; nope ;; @@3417 40
                 cmp #last_esc_command_token+1             ;; @@3419 40
                 bcs print_foreign_esc                    ; nope ;; @@341b 40
                 adc #$80-first_esc_command_token         ; yes- make a pointer p1l will be proud of ;; @@341d 40
                 tax                                       ;; @@341f 40
                 ldy #<esc_command_list                    ;; @@3420 40
                 lda #>esc_command_list                    ;; @@3422 40
                 bra p1l026                               ; go scan list and print it ;; @@3424 40
 ;; @@3426 40
 ;; @@3426 40
 ;; @@3426 40
; Print Escape Function ;; @@3426 40
 ;; @@3426 40
print_esc_fn                                               ;; @@3426 40
                 tax                                      ; save type (function) in case it's a foreign esc token ;; @@3426 40
                 iny                                       ;; @@3427 40
                 jsr indlow                               ; look at second token ;; @@3428 40
                 +lbeq p1l015                             ; none?  print funny character ;; @@342b 40
                 sty lstpnt                                ;; @@342e 40
                 cmp #first_esc_function_token            ; is this one of ours? ;; @@3430 40
                 bcc print_foreign_esc                    ; nope ;; @@3432 40
                 cmp #last_esc_function_token+1            ;; @@3434 40
                 bcs print_foreign_esc                    ; nope ;; @@3436 40
                 adc #$80-first_esc_function_token        ; yes- make a pointer p1l will be proud of ;; @@3438 40
                 tax                                       ;; @@343a 40
                 ldy #<esc_function_list                   ;; @@343b 40
                 lda #>esc_function_list                   ;; @@343d 40
                 bra p1l026                               ; go scan list and print it ;; @@343f 40
 ;; @@3441 40
; .page ;; @@3441 40
; The token to be printed is an escape token which is NOT recognized by BASIC. ;; @@3441 40
; We will jump through the indirect chain and see if anyone claims this token. ;; @@3441 40
; ;; @@3441 40
; At this point: ;; @@3441 40
; .C = 1 to signal 'unclaimed' ;; @@3441 40
; .X = type (0==>command, ff==>function) ;; @@3441 40
; .A = second token character ;; @@3441 40
; ;; @@3441 40
; If anyone claims this token, they should: ;; @@3441 40
; ;; @@3441 40
; > Clear .C to flag 'taken' ;; @@3441 40
; > Point (INDEX1) at the string to be printed (with msb of last char set) ;; @@3441 40
; > Note: string to print MUST be in RAM-0! ;; @@3441 40
 ;; @@3441 40
print_foreign_esc                                           ;; @@3441 40
                 cpx #esc_command_token                    ;; @@3441 40
                 bne _local_1039_1                         ;; @@3443 40
                 ldx #0                                    ;; @@3445 40
                 !text $2c                                 ;; @@3447 40
 ;; @@3448 40
_local_1039_1    ldx #$ff                                  ;; @@3448 40
                 sec                                       ;; @@344a 40
                 jmp (iescpr)                              ;; @@344b 40
 ;; @@344e 40
nescpr           +lbcs p1l015                             ; no takers, print a funny graphic character ;; @@344e 41
                 ldy #0                                    ;; @@3451 41
                 bra p1l070                                ;; @@3453 41
 ;; @@3455 41
 ;; @@3455 41
;.end ;; @@3455 41
; .page ;; @@3455 41
; .subttl NEW  CLR ;; @@3455 41
; ;; @@3455 41
; The NEW command clears the program text as well as variable space. ;; @@3455 41
; ;; @@3455 41
 ;; @@3455 41
new              beq init_text                            ; Erase program in memory ;; @@3455 41
                 cmp #restore_token                       ; Restore an erased program?    [910103] ;; @@3457 41
                 +lbne snerr                              ; no- syntax error    [910410] ;; @@3459 41
                 jsr chkeos                               ; yes- eat token, error if not eos  [910429] ;; @@345c 41
                 lda txttab                               ; "seed" first link to fool 'chead' ;; @@345f 41
                 ldx txttab+1                              ;; @@3461 41
                 sta index                                 ;; @@3463 41
                 stx index+1                               ;; @@3465 41
                 lda #0                                    ;; @@3467 41
                 ldy #1                                    ;; @@3469 41
                 ldx #index                                ;; @@346b 41
                 jsr sta_far_ram0                         ; clear msb  (bleed-thru) ;; @@346d 41
                 dey                                       ;; @@3470 41
                 inc                                       ;; @@3471 41
                 jsr sta_far_ram0                         ; set lsb   (bleed-thru) ;; @@3472 41
                 +lbra renumber                           ; make renumber check it for us (not 100%) & relink ;; @@3475 41
 ;; @@3478 41
 ;; @@3478 41
init_text                                                  ;; @@3478 41
                 lda txttab                               ; find the bottom of basic text ;; @@3478 41
                 ldx txttab+1                              ;; @@347a 41
                 sta index                                 ;; @@347c 41
                 stx index+1                               ;; @@347e 41
                 dew index                                ; (the absolute bottom) ;; @@3480 41
 ;; @@3482 41
                 lda #0                                    ;; @@3482 41
                 tay                                       ;; @@3484 41
                 ldx #index                                ;; @@3485 41
                 jsr sta_far_ram0                         ; clear bottom     (bleed-thru) ;; @@3487 41
                 iny                                       ;; @@348a 41
                 jsr sta_far_ram0                         ; clear first link bytes    (bleed-thru) ;; @@348b 41
                 iny                                       ;; @@348e 41
                 jsr sta_far_ram0                         ; (bleed-thru) ;; @@348f 41
                 clc                                       ;; @@3492 41
                 lda txttab                                ;; @@3493 41
                 adc #2                                    ;; @@3495 41
                 sta text_top                             ; set up (text_top), the end of text ;; @@3497 41
                 lda txttab+1                              ;; @@3499 41
                 adc #0                                    ;; @@349b 41
                 sta text_top+1                            ;; @@349d 41
 ;; @@349f 41
                 rmb5 runmod                              ; trcflg. reset trace flag ;; @@349f 41
 ;; @@34a1 41
 ;; @@34a1 41
runc             jsr reset_txtptr                         ; load (txtptr) with (txttab)-1 ;; @@34a1 41
                 bra clearc                               ; "CLR" to clear vars    [910410] ;; @@34a4 41
 ;; @@34a6 41
; .page ;; @@34a6 41
; CLeaR Routines ;; @@34a6 41
; ;; @@34a6 41
 ;; @@34a6 41
; Special forms of CLR command: ;; @@34a6 41
; ;; @@34a6 41
; CLR ERR$ Clears program error status, useful in TRAP handlers which ;; @@34a6 41
;   have resolved an error & wish to RESUME with a clean status. ;; @@34a6 41
; ;; @@34a6 41
; CLR DS$  Clears the currently buffered DS,DS$ messages.  The next ;; @@34a6 41
;   use of DS or DS$ will make BASIC re a new message from DOS. ;; @@34a6 41
 ;; @@34a6 41
clear            beq clearc                               ; branch if no args    [910410] ;; @@34a6 41
 ;; @@34a8 41
                 cmp #err_token                           ; CLR ERR$ ;; @@34a8 41
                 bne _local_1040_10                       ; no ;; @@34aa 41
                 jsr chkeos                               ; yes- eat token & error if not eos ;; @@34ac 41
                 +lbra error_clear                        ; and go clear ERR$ ;; @@34af 41
 ;; @@34b2 41
_local_1040_10   cmp #'D'                                 ; CLR DS$     [910717] ;; @@34b2 41
                 bne _local_1040_20                       ; no- error ;; @@34b4 41
                 jsr chrget                                ;; @@34b6 41
                 cmp #'S'                                  ;; @@34b9 41
                 bne _local_1040_20                        ;; @@34bb 41
                 jsr chrget                                ;; @@34bd 41
                 cmp #'$'                                  ;; @@34c0 41
_local_1040_20   +lbne snerr                              ; no- error ;; @@34c2 41
                 jsr chkeos                                ;; @@34c5 41
                 +lbra Clear_DS                           ; yes- clear current DS$ ;; @@34c8 41
 ;; @@34cb 41
; .page ;; @@34cb 41
; Clearc is a subroutine which initializes the variable and array space by ;; @@34cb 41
; resetting STREND (the end of array storage).  It falls into INIT_STACK, ;; @@34cb 41
; which resets the stack. ;; @@34cb 41
 ;; @@34cb 41
clearc           jsr _clall                               ; close all files ;; @@34cb 42
                 ldy #0                                    ;; @@34ce 42
                 sty dsdesc                               ; flag 'no DS$ string' ;; @@34d0 42
                 dey                                      ; (y=$ff) ;; @@34d2 42
                 sty trapno+1                             ; flag no current trap line ;; @@34d3 42
                 sty errlin                               ; reset last error pointers ;; @@34d6 42
                 sty errlin+1                              ;; @@34d9 42
                 sty errnum                                ;; @@34dc 42
 ;; @@34df 42
                 lda max_mem_1                            ; clear string space ;; @@34df 42
                 ldy max_mem_1+1                           ;; @@34e1 42
                 sta fretop                                ;; @@34e3 42
                 sty fretop+1                              ;; @@34e5 42
 ;; @@34e7 42
                 lda #<stkbot                             ; empty run-time stack ;; @@34e7 42
                 ldy #>stkbot                              ;; @@34e9 42
                 sta tos                                   ;; @@34eb 42
                 sty tos+1                                 ;; @@34ed 42
 ;; @@34ef 42
                 lda vartab                                ;; @@34ef 42
                 ldy vartab+1                              ;; @@34f1 42
                 sta arytab                               ; this will delete all variables, ;; @@34f3 42
                 sty arytab+1                              ;; @@34f5 42
                 sta strend                               ; ..and arrays ;; @@34f7 42
                 sty strend+1                              ;; @@34f9 42
 ;; @@34fb 42
                 ldx #pumony-puchrs                       ; reset print using chars ;; @@34fb 42
_local_1041_1    lda pudefs,x                              ;; @@34fd 42
                 sta puchrs,x                              ;; @@3500 42
                 dex                                       ;; @@3503 42
                 bpl _local_1041_1                         ;; @@3504 42
 ;; @@3506 42
fload            jsr restore__1                           ; reset pointer for DATA statements ;; @@3506 43
 ;; @@3509 43
; .page ;; @@3509 43
; INIT_STACK Routine (formerly STKINI) ;; @@3509 43
; ;; @@3509 43
;   Init_Stack resets the stack pointer.  String temporaries are freed up, ;; @@3509 43
;   SUBFLG is reset, continuing is prohibited. ;; @@3509 43
 ;; @@3509 43
init_stack                                                 ;; @@3509 43
                 ply                                      ; pop return address ;; @@3509 43
                 pla                                       ;; @@350a 43
                 ldx #stkend-257                          ; reset system stack pointer ;; @@350b 43
                 txs                                       ;; @@350d 43
                 pha                                      ; push return address ;; @@350e 43
                 phy                                       ;; @@350f 43
                 ldx #tempst                              ; reset string temporaries ;; @@3510 43
                 stx temppt                                ;; @@3512 43
                 lda #0                                    ;; @@3514 43
                 sta subflg                               ; allow subscripted & integer vars ;; @@3516 43
                 sta oldtxt+1                             ; disallow continuing ;; @@3518 43
                 sta bits                                 ; reset math bit/byte flag ;; @@351b 43
 ;; @@351e 43
stkrts           rts                                       ;; @@351e 43
 ;; @@351f 43
 ;; @@351f 43
 ;; @@351f 43
reset_txtptr                                               ;; @@351f 43
                 clc                                      ; load (txtptr) with (txttab)-1 ;; @@351f 43
                 lda txttab                                ;; @@3520 43
                 adc #$ff                                  ;; @@3522 43
                 sta txtptr                                ;; @@3524 43
                 lda txttab+1                              ;; @@3526 43
                 adc #$ff                                  ;; @@3528 43
                 sta txtptr+1                             ; set up text pointers ;; @@352a 43
                 rts                                       ;; @@352c 43
 ;; @@352d 43
;.end ;; @@352d 43
; .page ;; @@352d 43
; .subttl RETURN ;; @@352d 43
;********************************************************************* ;; @@352d 43
; RETURN Routine ;; @@352d 43
; ;; @@352d 43
; Restores the line number and text pointer from the stack, and ;; @@352d 43
; eliminates all the FOR entries in front of the GOSUB entry. ;; @@352d 43
; ;; @@352d 43
;********************************************************************* ;; @@352d 43
 ;; @@352d 43
return                                                     ;; @@352d 43
 ;; @@352d 43
; Ok, pay attention: we got here by a pseudo-jsr which left a return to NEWSTT ;; @@352d 43
; on the stack for us to return to.  There is also a return to NEWSTT left on ;; @@352d 43
; the stack from the GOSUB we are returning from.  This is true UNLESS we got ;; @@352d 43
; here on a sprite collision, in which case we still have the NEWSUB return ;; @@352d 43
; recently left by our current call, but the second return goes back to the ;; @@352d 43
; trapping mechanism.  The bottom line is: we have an extra return address on ;; @@352d 43
; the stack, which we have to get rid of before leaving. ;; @@352d 43
 ;; @@352d 43
                 pla                                      ; mea culpa, mea culpa, mea culpa ;; @@352d 43
                 pla                                       ;; @@352e 43
                 lda #gosub_token                          ;; @@352f 43
                 jsr search                               ; look for GOSUB on runtime stack ;; @@3531 43
                 beq ret010                               ; found ;; @@3534 43
                 ldx #errrg                               ; else error ;; @@3536 43
                 +lbra error                               ;; @@3538 43
 ;; @@353b 43
ret010           jsr movfnd                               ; (fndpnt) => (tos) ;; @@353b 43
                 ldy #lengos                               ;; @@353e 43
                 jsr rlsstk                               ; effectivly pop GOSUB off run-time stack ;; @@3540 43
; dey ;; @@3543 43
; lda (fndpnt),y ;; @@3543 43
; sta txtptr+1 ;; @@3543 43
; dey ;; @@3543 43
; lda (fndpnt),y ;; @@3543 43
; sta txtptr ;; @@3543 43
; dey ;; @@3543 43
; lda (fndpnt),y ;; @@3543 43
                 jsr retpat                               ; 01/18/84 patch: correct RETURN to GOSUB from direct mode ;; @@3543 43
; lda (fndpnt),y ;; @@3546 43
; sta curlin ;jump to DATA to waste rest of stmt (in case of ON..GOSUB) ;; @@3546 43
                 bra data                                  ;; @@3546 43
 ;; @@3548 43
;.end ;; @@3548 43
; .page ;; @@3548 43
; .subttl DATA ;; @@3548 43
 ;; @@3548 43
data                                                       ;; @@3548 43
                 jsr datan                                ; skip to end of statement- offset in .y ;; @@3548 43
addon            tya                                       ;; @@354b 43
                 clc                                       ;; @@354c 43
                 adc txtptr                               ; add offset to end to txtptr ;; @@354d 43
                 sta txtptr                                ;; @@354f 43
                 bcc remrts                                ;; @@3551 43
                 inc txtptr+1                              ;; @@3553 43
remrts           rts                                      ; NEWSTT rts addr is still there ;; @@3555 43
 ;; @@3556 43
 ;; @@3556 43
 ;; @@3556 43
rem              jsr remn                                 ; skip rest of statement ;; @@3556 43
                 bra addon                                ; will always branch ;; @@3559 43
 ;; @@355b 43
 ;; @@355b 43
datan            ldx #':'                                 ; DATA terminates on ":" and null ;; @@355b 43
                 !text $2c                                 ;; @@355d 43
 ;; @@355e 43
remn             ldx #0                                   ; REM terminates on null only ;; @@355e 43
                 stx charac                               ; preserve terminator ;; @@3560 43
                 ldy #0                                   ; this makes charac=0 after swap ;; @@3562 43
                 sty endchr                                ;; @@3564 43
 ;; @@3566 43
_local_1042_10   lda endchr                                ;; @@3566 43
                 ldx charac                                ;; @@3568 43
                 sta charac                                ;; @@356a 43
                 stx endchr                                ;; @@356c 43
_local_1042_20   jsr indtxt                                ;; @@356e 43
                 beq remrts                               ; null always terminates ;; @@3571 43
                 cmp endchr                               ; is it some another terminator? ;; @@3573 43
                 beq remrts                               ; yes, it's finished ;; @@3575 43
                 iny                                      ; progress to next character ;; @@3577 43
                 cmp #'"'                                 ; is it a quote? ;; @@3578 43
                 bne _local_1042_20                       ; no, just continue ;; @@357a 43
                 beq _local_1042_10                       ; yes, time to change ;; @@357c 43
 ;; @@357e 43
;.end ;; @@357e 43
; .page ;; @@357e 43
; .subttl IF  THEN  ELSE ;; @@357e 43
 ;; @@357e 43
;**************************************************************** ;; @@357e 43
;* ;; @@357e 43
;* IF Statment ;; @@357e 43
;* ;; @@357e 43
;* IF exp {GOTO line#  | THEN {line# | statements | b-block} } ;; @@357e 43
;*  [:ELSE {line# | statements | b-block} ] ;; @@357e 43
;* ;; @@357e 43
;* B-block ;; @@357e 43
;* ;; @@357e 43
;* BEGIN : [statement(s) on one or more lines] : BEND ;; @@357e 43
;* ;; @@357e 43
;**************************************************************** ;; @@357e 43
 ;; @@357e 43
if               jsr frmevl                               ; evaluate the conditional expression ;; @@357e 44
                 jsr chrgot                               ; re-get current character ;; @@3581 44
                 cmp #goto_token                          ; is terminating character a GOTO? ;; @@3584 44
                 beq _local_1043_10                       ; yes ;; @@3586 44
                 lda #then_token                          ; no, it must be THEN ;; @@3588 44
                 jsr synchr                                ;; @@358a 44
 ;; @@358d 44
_local_1043_10   lda facexp                               ; test truth value of argument ;; @@358d 44
                 bne if_true                              ; branch if true ;; @@358f 44
 ;; @@3591 44
if_false                                                   ;; @@3591 45
                 jsr chrgot                               ; is there a b-block? ;; @@3591 45
                 cmp #esc_command_token                    ;; @@3594 45
                 bne _local_1044_20                       ; no, must be an escape command ;; @@3596 45
                 iny                                      ; might be, look at escape token ;; @@3598 45
                 jsr indtxt                                ;; @@3599 45
                 cmp #begin_token                          ;; @@359c 45
                 bne _local_1044_20                       ; branch if not ;; @@359e 45
                 jsr find_bend                            ; skip to end of b-block ;; @@35a0 45
 ;; @@35a3 45
_local_1044_20   jsr data                                 ; may be 'else' clause. first skip over 'then' clause.. ;; @@35a3 45
                 ldy #0                                    ;; @@35a6 45
                 jsr indtxt                               ; ..and see if end of stmt or end of line ;; @@35a8 45
                 beq rem                                  ; end of line, no 'else'. go to next line ;; @@35ab 45
                 jsr chrget                               ; another statement on this line.. is it 'else'? ;; @@35ad 45
                 cmp #else_token                           ;; @@35b0 45
                 bne _local_1044_20                       ; no, keep looking on this line ;; @@35b2 45
                 jsr chrget                               ; yes! skip over token and execute clause (below) ;; @@35b4 45
 ;; @@35b7 45
if_true          jsr chrgot                                ;; @@35b7 46
                 beq _local_1045_20                       ; branch if end of statement ;; @@35ba 46
                 bcs _local_1045_10                       ; branch if not a number ;; @@35bc 46
                 +lbra goto                               ; here if of the form 'THEN line#' ;; @@35be 46
 ;; @@35c1 46
_local_1045_10   cmp #esc_command_token                   ; is this the beginning of a b-block? ;; @@35c1 46
                 bne _local_1045_20                       ; no, must be an escape command ;; @@35c3 46
                 iny                                      ; might be, look at escape token ;; @@35c5 46
                 jsr indtxt                                ;; @@35c6 46
                 cmp #begin_token                          ;; @@35c9 46
                 bne _local_1045_20                        ;; @@35cb 46
                 jsr chrget                               ; skip over 'BEGIN' if so... ;; @@35cd 46
                 jsr chrget                               ; ..and the second token, as well. ;; @@35d0 46
 ;; @@35d3 46
_local_1045_20   jsr chrgot                               ; get back original character, & set up flags ;; @@35d3 46
                 +lbra xeqcm3                             ; ..and go execute whatever it is ;; @@35d6 46
 ;; @@35d9 46
; .page ;; @@35d9 46
find_bend                                                 ; ... subroutine to find end of current b-block ;; @@35d9 47
                 jsr chrget                                ;; @@35d9 47
                 bne _local_1046_20                        ;; @@35dc 47
 ;; @@35de 47
; End of statement.. set up next ;; @@35de 47
 ;; @@35de 47
_local_1046_10   cmp #':'                                 ; is this EOL? ;; @@35de 47
                 beq find_bend                            ; no, keep looking ;; @@35e0 47
 ;; @@35e2 47
_local_1046_15   bbr7 runmod,_local_1046_99               ; EOL: branch if direct mode, 'block terminator not found' error ;; @@35e2 47
 ;; @@35e5 47
                 ldy #2                                    ;; @@35e5 47
                 jsr indtxt                               ; end of text? ;; @@35e7 47
                 beq _local_1046_99                       ; yes, msb of next stmt pointer = 0. error ;; @@35ea 47
 ;; @@35ec 47
                 iny                                       ;; @@35ec 47
                 jsr indtxt                                ;; @@35ed 47
                 sta curlin                               ; set up next line of text ;; @@35f0 47
                 iny                                       ;; @@35f2 47
                 jsr indtxt                                ;; @@35f3 47
                 sta curlin+1                              ;; @@35f6 47
                 tya                                       ;; @@35f8 47
                 clc                                       ;; @@35f9 47
                 adc txtptr                                ;; @@35fa 47
                 sta txtptr                                ;; @@35fc 47
                 bcc find_bend                             ;; @@35fe 47
                 inc txtptr+1                              ;; @@3600 47
                 bra find_bend                            ; always ;; @@3602 47
 ;; @@3604 47
_local_1046_20   cmp #'"'                                  ;; @@3604 47
                 bne _local_1046_30                        ;; @@3606 47
                 jsr un_quote                             ; look for terminating quote, or EOL ;; @@3608 47
                 beq _local_1046_10                       ; EOL or ':' after closing quote ;; @@360b 47
                 bne find_bend                            ; ..else normal char, keep looking ;; @@360d 47
 ;; @@360f 47
_local_1046_30   cmp #rem_token                           ; REM? ;; @@360f 47
                 bne _local_1046_35                       ; no ;; @@3611 47
                 jsr rem                                  ; yes, trash this line ;; @@3613 47
                 bra _local_1046_15                       ; and go test for end of text ;; @@3616 47
 ;; @@3618 47
_local_1046_35   cmp #esc_command_token                   ; is this a BEND? ;; @@3618 47
                 bne find_bend                            ; can't be, has to be an escape ;; @@361a 47
 ;; @@361c 47
                 jsr chrget                               ; skip over esc token ;; @@361c 47
                 cmp #bend_token                           ;; @@361f 47
                 beq _local_1046_40                       ; this is what we came for, bye! ;; @@3621 47
 ;; @@3623 47
                 cmp #begin_token                         ; not a BEND. is it a BEGIN? ;; @@3623 47
                 bne find_bend                            ; it's just a normal, stick-in-the-mud char. keep looking. ;; @@3625 47
 ;; @@3627 47
                 jsr find_bend                            ; oh-oh, recursion. Dr. Ja-Ja warned me about this. ;; @@3627 47
                 bra find_bend                             ;; @@362a 47
 ;; @@362c 47
_local_1046_40   rts                                       ;; @@362c 47
 ;; @@362d 47
_local_1046_99   ldx #err_no_bend                          ;; @@362d 47
                 +lbra error                               ;; @@362f 47
 ;; @@3632 47
un_quote                                                  ; txtptr points to a '"'. look for closing '"', or EOL ;; @@3632 48
                 ldy #0                                    ;; @@3632 48
_local_1047_10   inw txtptr                                ;; @@3634 48
                 jsr indtxt                                ;; @@3636 48
                 beq _local_1047_30                       ; EOL, get out here with .z set and a '00' in .a ;; @@3639 48
                 cmp #'"'                                  ;; @@363b 48
                 bne _local_1047_10                       ; keep looking until quote ;; @@363d 48
                 jmp chrget                               ; got closing quote, get byte after quote, set flags ;; @@363f 48
 ;; @@3642 48
_local_1047_30   rts                                       ;; @@3642 48
 ;; @@3643 48
; .page ;; @@3643 48
 ;; @@3643 48
else             cmp #esc_command_token                   ; is this of the form "ELSE b-block"? ;; @@3643 49
                 bne _local_1048_10                       ; no, must be an escape command ;; @@3645 49
                 iny                                      ; might be, look at escape token ;; @@3647 49
                 jsr indtxt                                ;; @@3648 49
                 cmp #begin_token                          ;; @@364b 49
                 bne _local_1048_10                       ; no, justa plain-old "ELSE statement" ;; @@364d 49
                 jsr find_bend                            ; yes, it is a b-block. skip over the b-block. ;; @@364f 49
_local_1048_10   +lbra rem                                 ;; @@3652 49
 ;; @@3655 49
 ;; @@3655 49
;.end ;; @@3655 49
; .page ;; @@3655 49
; .subttl ON...GOTO  ON...GOSUB ;; @@3655 49
 ;; @@3655 49
;********************************************************* ;; @@3655 49
;* ON expression {GOTO | GOSUB} line_number ;; @@3655 49
;********************************************************* ;; @@3655 49
ongoto                                                     ;; @@3655 50
                 jsr getbyt                               ; get & save GOTO/GOSUB ;; @@3655 50
                 pha                                       ;; @@3658 50
                 cmp #goto_token                          ; GOTO? ;; @@3659 50
                 beq _local_1049_1                        ; yes ;; @@365b 50
                 cmp #gosub_token                         ; GOSUB? ;; @@365d 50
                 +lbne snerr                              ; no, syntax error ;; @@365f 50
 ;; @@3662 50
_local_1049_1    dec faclo                                 ;; @@3662 50
                 bne _local_1049_2                        ; skip another line number ;; @@3664 50
                 pla                                      ; get dispatch character ;; @@3666 50
                 +lbra xeqcm2                              ;; @@3667 50
 ;; @@366a 50
_local_1049_2    jsr chrget                               ; advance and set codes ;; @@366a 50
                 jsr linget                               ; read next line ;; @@366d 50
                 cmp #','                                 ; is it a "comma"? ;; @@3670 50
                 beq _local_1049_1                         ;; @@3672 50
                 pla                                      ; remove stack entry (token) ;; @@3674 50
                 rts                                      ; either end of line or syntax error ;; @@3675 50
 ;; @@3676 50
;.end ;; @@3676 50
; .page ;; @@3676 50
; .subttl LET ;; @@3676 50
 ;; @@3676 50
;**************************************************************** ;; @@3676 50
;* ;; @@3676 50
;*  [LET] variable = expression ;; @@3676 50
;* ;; @@3676 50
;**************************************************************** ;; @@3676 50
 ;; @@3676 50
let              jsr ptrget                               ; get pntr to variable into "varpnt" ;; @@3676 51
                 sta forpnt                               ; preserve pointer ;; @@3679 51
                 sty forpnt+1                              ;; @@367b 51
                 lda #equal_token                          ;; @@367d 51
                 jsr synchr                               ; "=" is necessary ;; @@367f 51
 ;; @@3682 51
                 lda intflg                               ; save type for later ;; @@3682 51
                 pha                                       ;; @@3684 51
                 lda valtyp                               ; retain the variable's value type too ;; @@3685 51
                 pha                                       ;; @@3687 51
 ;; @@3688 51
                 jsr frmevl                               ; get value of formula into FAC ;; @@3688 51
                 pla                                       ;; @@368b 51
                 rol                                      ; carry set for string, off for numeric ;; @@368c 51
                 jsr chkval                               ; make sure VALTYP matches carry ;; @@368d 51
;and set zero flag for numeric ;; @@3690 51
                 bne copstr                               ; if numeric, copy it ;; @@3690 51
                 pla                                      ; get number type ;; @@3692 51
 ;; @@3693 51
qintgr           bpl copflt                               ; store a floating point number ;; @@3693 51
                 jsr round                                ; round integer ;; @@3695 51
                 jsr ayint                                ; make two-byte number ;; @@3698 51
                 ldy #0                                    ;; @@369b 51
                 lda facmo                                ; get high ;; @@369d 51
                 phx                                       ;; @@369f 51
                 ldx #forpnt                               ;; @@36a0 51
                 jsr sta_far_ram1 ;sta (forpnt),y         ; store it ;; @@36a2 51
                 iny                                       ;; @@36a5 51
                 lda faclo                                ; get low ;; @@36a6 51
                 jsr sta_far_ram1                         ; sta (forpnt),y ;; @@36a8 51
                 plx                                       ;; @@36ab 51
                 rts                                       ;; @@36ac 51
 ;; @@36ad 51
 ;; @@36ad 51
 ;; @@36ad 51
copflt           ldx forpnt                                ;; @@36ad 51
                 ldy forpnt+1                              ;; @@36af 51
                 +lbra movmf_ram1                         ; put number @forpnt in var bank ;; @@36b1 51
 ;; @@36b4 51
 ;; @@36b4 51
 ;; @@36b4 51
copstr           pla                                      ; if string, no INTFLG ;; @@36b4 51
 ;; @@36b5 51
inpcom           ldy forpnt+1                             ; TI$? ;; @@36b5 51
                 cpy #>zero                               ; (only TI$ can be this on assign) ;; @@36b7 51
                 +lbeq Set_TI_String                      ; yes ;; @@36b9 51
                 bra getspt                               ; no ;; @@36bc 51
 ;; @@36be 51
; .page ;; @@36be 51
dskx1            pla                                       ;; @@36be 51
                 iny                                       ;; @@36bf 51
 ;; @@36c0 51
dskx2            cmp fretop+1                              ;; @@36c0 51
                 bcc _local_1050_20                        ;; @@36c2 51
                 bne _local_1050_10                        ;; @@36c4 51
                 dey                                       ;; @@36c6 51
                 jsr indfmo                                ;; @@36c7 51
                 cmp fretop                                ;; @@36ca 51
                 bcc _local_1050_20                        ;; @@36cc 51
 ;; @@36ce 51
_local_1050_10   ldy faclo                                ; qvaria ;; @@36ce 51
                 cpy vartab+1                             ; if (vartab) > (facmo), don't copy ;; @@36d0 51
                 bcc _local_1050_20                        ;; @@36d2 51
                 bne copy                                 ; it is less ;; @@36d4 51
                 lda facmo                                 ;; @@36d6 51
                 cmp vartab                               ; compare low orders ;; @@36d8 51
                 bcs copy                                  ;; @@36da 51
 ;; @@36dc 51
_local_1050_20   lda facmo                                ; dntcpy ;; @@36dc 51
                 ldy facmo+1                               ;; @@36de 51
                 bra copyc                                 ;; @@36e0 51
 ;; @@36e2 51
; .page ;; @@36e2 51
getspt           ldy #2                                   ; get pntr to descriptor ;; @@36e2 52
                 jsr indfmo                                ;; @@36e4 52
                 cmp dsdesc+2                             ; check for DS$ hi ;; @@36e7 52
                 bne dskx2                                ; nope ;; @@36e9 52
                 pha                                       ;; @@36eb 52
                 dey                                       ;; @@36ec 52
                 jsr indfmo                                ;; @@36ed 52
                 cmp dsdesc+1                             ; check for DS$ lo ;; @@36f0 52
                 bne dskx1                                ; nope ;; @@36f2 52
                 lda dsdesc                               ; check if len=0 ;; @@36f4 52
                 beq dskx1                                ; yup ;; @@36f6 52
                 pla                                      ; fall through to copy ;; @@36f8 52
 ;; @@36f9 52
 ;; @@36f9 52
copy             ldy #0                                    ;; @@36f9 52
                 jsr indfmo                                ;; @@36fb 52
                 jsr strini                               ; get room to copy string into ;; @@36fe 52
                 lda dscpnt                               ; get pointer to old descriptor, so ;; @@3701 52
                 ldy dscpnt+1                              ;; @@3703 52
                 sta strng1                               ; movins can find string ;; @@3705 52
                 sty strng1+1                              ;; @@3707 52
                 jsr movins                               ; copy it ;; @@3709 52
 ;; @@370c 52
                 lda strng1                               ; fix to free get strings ;; @@370c 52
                 ldy strng1+1                              ;; @@370e 52
                 jsr fretms                               ; free the string, if it is a temp ;; @@3710 52
 ;; @@3713 52
                 lda #<dsctmp                              ;; @@3713 52
                 ldy #>dsctmp                              ;; @@3715 52
 ;; @@3717 52
copyc            sta dscpnt                                ;; @@3717 52
                 sty dscpnt+1                              ;; @@3719 52
                 sta index                                ; index points to new descriptor ;; @@371b 52
                 sty index+1                               ;; @@371d 52
                 jsr fretms                                ;; @@371f 52
 ;; @@3722 52
; .page ;; @@3722 52
;   Fix the strings by flagging the old string as garbage and the new ;; @@3722 52
;   string by pointing it to its new descriptor. ;; @@3722 52
 ;; @@3722 52
                 jsr stradj                               ; set up new string ;; @@3722 52
                 bcc _local_1051_10                       ; leave it alone ;; @@3725 52
                 ldy #0                                    ;; @@3727 52
                 lda forpnt                               ; put in backwards link ;; @@3729 52
                 phx                                       ;; @@372b 52
                 ldx #index                                ;; @@372c 52
                 jsr sta_far_ram1                          ;; @@372e 52
                 iny                                       ;; @@3731 52
                 lda forpnt+1                              ;; @@3732 52
                 jsr sta_far_ram1                          ;; @@3734 52
                 plx                                       ;; @@3737 52
 ;; @@3738 52
_local_1051_10   lda forpnt                               ; fix old string ;; @@3738 52
                 sta index                                 ;; @@373a 52
                 lda forpnt+1                              ;; @@373c 52
                 sta index+1                               ;; @@373e 52
                 jsr stradj                               ; point to old string ;; @@3740 52
                 bcc _local_1051_20                       ; in text do not fix ;; @@3743 52
                 dey                                      ; restore y ;; @@3745 52
                 phx                                       ;; @@3746 52
                 ldx #index                                ;; @@3747 52
                 lda #$ff                                 ; garbage flag ;; @@3749 52
                 jsr sta_far_ram1                          ;; @@374b 52
                 dey                                       ;; @@374e 52
                 pla                                      ; (was txa) ;; @@374f 52
                 pha                                       ;; @@3750 52
                 jsr sta_far_ram1                         ; store length ;; @@3751 52
                 plx                                       ;; @@3754 52
 ;; @@3755 52
_local_1051_20   ldy #2                                   ; set the descriptor ;; @@3755 52
                 phx                                       ;; @@3757 52
                 ldx #forpnt                               ;; @@3758 52
_local_1051_30   lda #dscpnt                               ;; @@375a 52
                 jsr lda_far_ram1                         ; lda (dscpnt),y from RAM1 ;; @@375c 52
                 jsr sta_far_ram1                         ; sta (forpnt),y to   RAM1 ;; @@375f 52
                 dey                                       ;; @@3762 52
                 bpl _local_1051_30                        ;; @@3763 52
                 plx                                       ;; @@3765 52
                 rts                                       ;; @@3766 52
 ;; @@3767 52
; .page ;; @@3767 52
;   STRADJ takes the pointer index which points to a descriptor and ;; @@3767 52
;   indexes to the desciptor's string data.  If the string is not in ;; @@3767 52
;   string space (no action to take) we return with carry clear, else ;; @@3767 52
;   we return with the pointer set to the link bytes in the string, the ;; @@3767 52
;   length in .a and the carry set. ;; @@3767 52
 ;; @@3767 52
stradj           ldy #0                                    ;; @@3767 53
                 jsr indin1_ram1                          ; push length on stack ;; @@3769 53
                 pha                                       ;; @@376c 53
                 beq _local_1052_50                       ; if length=0 do nothing ;; @@376d 53
                 iny                                       ;; @@376f 53
                 jsr indin1_ram1                          ; get low byte (into .x) ;; @@3770 53
                 tax                                       ;; @@3773 53
                 iny                                       ;; @@3774 53
                 jsr indin1_ram1                          ; get high byte ;; @@3775 53
                 cmp max_mem_1+1                           ;; @@3778 53
                 bcc _local_1052_10                       ; ok ;; @@377a 53
                 bne _local_1052_50                       ; if above top of memory ;; @@377c 53
                 cpx max_mem_1                            ; msb the same, test lsb ;; @@377e 53
                 bcs _local_1052_50                       ; if above top of memory ;; @@3780 53
 ;; @@3782 53
_local_1052_10   cmp fretop+1                              ;; @@3782 53
                 bcc _local_1052_50                       ; if below fretop ;; @@3784 53
                 bne _local_1052_20                        ;; @@3786 53
                 cpx fretop                                ;; @@3788 53
                 bcc _local_1052_50                       ; if below fretop ;; @@378a 53
 ;; @@378c 53
_local_1052_20   cmp dsdesc+2                              ;; @@378c 53
                 bne _local_1052_30                       ; fix ;; @@378e 53
                 cpx dsdesc+1                              ;; @@3790 53
                 beq _local_1052_50                        ;; @@3792 53
 ;; @@3794 53
_local_1052_30   stx index                                ; ok set pointer ;; @@3794 53
                 sta index+1                               ;; @@3796 53
                 pla                                      ; get back length ;; @@3798 53
                 tax                                      ; into x also ;; @@3799 53
                 clc                                       ;; @@379a 53
                 adc index                                 ;; @@379b 53
                 sta index                                 ;; @@379d 53
                 bcc _local_1052_40                        ;; @@379f 53
                 inc index+1                               ;; @@37a1 53
_local_1052_40   sec                                      ; carry set ;; @@37a3 53
                 rts                                       ;; @@37a4 53
 ;; @@37a5 53
_local_1052_50   pla                                      ; clean up stack ;; @@37a5 53
                 clc                                       ;; @@37a6 53
                 rts                                       ;; @@37a7 53
 ;; @@37a8 53
;.end ;; @@37a8 53
; .page ;; @@37a8 53
; .subttl PRINT  PRINT#  CMD ;; @@37a8 53
 ;; @@37a8 53
;*********************************************************** ;; @@37a8 53
;* ;; @@37a8 53
;* PRINT   PRINT#   CMD ;; @@37a8 53
;* ;; @@37a8 53
;********************************************************** ;; @@37a8 53
 ;; @@37a8 53
printn           jsr cmd                                  ; docmd ;; @@37a8 54
                 +lbra release_channels                   ; restore terminal ;; @@37ab 54
 ;; @@37ae 54
 ;; @@37ae 54
cmd              jsr getbyt                                ;; @@37ae 54
                 beq _local_1053_10                        ;; @@37b1 54
                 lda #','                                 ; comma? ;; @@37b3 54
                 jsr synchr                                ;; @@37b5 54
 ;; @@37b8 54
_local_1053_10   php                                      ; save stat (beq=eof) ;; @@37b8 54
                 pha                                      ; save char ;; @@37b9 54
                 stx channl                               ; channel to output on ;; @@37ba 54
                 jsr coout                                 ;; @@37bc 54
                 pla                                      ; get char back ;; @@37bf 54
                 plp                                      ; get stat back ;; @@37c0 54
                 bra print                                 ;; @@37c1 54
 ;; @@37c3 54
 ;; @@37c3 54
strdon           jsr strprt                                ;; @@37c3 55
 ;; @@37c6 55
newchr           jsr chrgot                               ; reget last character ;; @@37c6 55
 ;; @@37c9 55
print            beq crdo                                 ; terminator only, so print crlf ;; @@37c9 55
                 cmp #using_token                          ;; @@37cb 55
                 +lbeq using                               ;; @@37cd 55
 ;; @@37d0 55
 ;; @@37d0 55
 ;; @@37d0 55
printc           beq prtrts  ;here after seeing TAB(x) or "," or " ; " in which case ;; @@37d0 55
;a terminator does not mean a crlf but just RTS ;; @@37d2 55
                 cmp #tab_token                           ; TAB function? ;; @@37d2 55
                 beq taber                                ; yes (c=1) ;; @@37d4 55
                 cmp #spc_token                           ; space function? ;; @@37d6 55
                 clc                                      ; clear carry ;; @@37d8 55
                 beq taber                                ; yes (c=0) ;; @@37d9 55
                 cmp #','                                 ; comma? ;; @@37db 55
                 beq comprt                               ; yes ;; @@37dd 55
                 cmp #';'                                 ; a semicolon? ;; @@37df 55
                 beq notabr                               ; yes ;; @@37e1 55
 ;; @@37e3 55
                 jsr frmevl                               ; evaluate the formula ;; @@37e3 55
                 bbs7 valtyp,strdon                       ; branch if a string ;; @@37e6 55
                 jsr fout                                  ;; @@37e9 55
                 jsr strlit                               ; build descriptor ;; @@37ec 55
                 jsr strprt                               ; print the number ;; @@37ef 55
                 jsr outspc                               ; print a space ;; @@37f2 55
                 bra newchr                               ; always goes ;; @@37f5 55
 ;; @@37f7 55
 ;; @@37f7 55
 ;; @@37f7 55
crdo             lda #cr                                   ;; @@37f7 55
                 jsr outch                                ; outdo ;; @@37f9 55
 ;; @@37fc 55
crfin            bbr7 channl,prtrts                        ;; @@37fc 55
                 lda #lf                                   ;; @@37ff 55
                 jsr outch                                ; outdo ;; @@3801 55
; eor #$ff  ;???? ;; @@3804 55
 ;; @@3804 55
prtrts           rts                                       ;; @@3804 55
 ;; @@3805 55
 ;; @@3805 55
 ;; @@3805 55
comprt           sec                                       ;; @@3805 55
                 jsr _plot                                ; get tab position in x ;; @@3806 55
                 tya                                       ;; @@3809 55
                 sec                                       ;; @@380a 55
morco1           sbc #column_width                         ;; @@380b 55
                 bcs morco1                                ;; @@380d 55
                 eor #$ff                                  ;; @@380f 55
                 adc #1                                    ;; @@3811 55
                 bne aspac                                 ;; @@3813 55
 ;; @@3815 55
taber            php                                      ; remember if SPC(c=0) or TAB(c=1) function ;; @@3815 55
                 sec                                       ;; @@3816 55
                 jsr _plot                                ; read tab position ;; @@3817 55
                 sty trmpos                                ;; @@381a 55
                 jsr gtbytc                               ; get value into accx ;; @@381c 55
                 cmp #')'                                  ;; @@381f 55
                 +lbne snerr                               ;; @@3821 55
                 plp                                       ;; @@3824 55
                 bcc xspac                                 ;; @@3825 55
                 txa                                       ;; @@3827 55
                 sbc trmpos                                ;; @@3828 55
                 bcc notabr                               ; negative, don't print any ;; @@382a 55
aspac            tax                                       ;; @@382c 55
xspac            inx                                       ;; @@382d 55
xspac2           dex                                       ;; @@382e 55
                 bne xspac1                                ;; @@382f 55
 ;; @@3831 55
 ;; @@3831 55
notabr           jsr chrget                               ; reget last character ;; @@3831 55
                 bra printc                               ; don't call crdo ;; @@3834 55
 ;; @@3836 55
 ;; @@3836 55
xspac1           jsr outspc                                ;; @@3836 55
                 bne xspac2                                ;; @@3839 55
 ;; @@383b 55
; .page ;; @@383b 55
; STROUT Routine ;; @@383b 55
; ;; @@383b 55
; Print the string pointed to by .x.  It must end with a null byte. ;; @@383b 55
 ;; @@383b 55
strout           jsr strlit                               ; get a string literal ;; @@383b 55
 ;; @@383e 55
strprt           jsr frefac                               ; return temp pointer ;; @@383e 55
                 tax                                      ; put count into counter ;; @@3841 55
                 ldy #0                                    ;; @@3842 55
                 inx                                      ; move one ahead ;; @@3844 55
strpr2           dex                                       ;; @@3845 55
                 beq prtrts                               ; all done ;; @@3846 55
                 jsr indin1_ram1                          ; lda (index),y ;; @@3848 55
                 jsr outch                                ; outdo ;; @@384b 55
                 iny                                       ;; @@384e 55
                 cmp #cr                                   ;; @@384f 55
                 bne strpr2                                ;; @@3851 55
                 jsr crfin                                ; type rest of carriage return ;; @@3853 55
                 bra strpr2                               ; and on and on ;; @@3856 55
 ;; @@3858 55
outspc           lda channl                               ; if terminal print skip chr., else print space ;; @@3858 55
                 bne realsp                                ;; @@385a 55
                 lda #29                                  ; CBM cursor right (non-destructive skip char) ;; @@385c 55
                 !text $2c                                 ;; @@385e 55
 ;; @@385f 55
realsp           lda #' '                                 ; space ;; @@385f 55
                 !text $2c                                 ;; @@3861 55
 ;; @@3862 55
outqst           lda #'?'                                  ;; @@3862 55
 ;; @@3864 55
;outdo ;; @@3864 55
                 jmp outch                                ; output char in .a ;; @@3864 55
; and #$ff ;???? ;; @@3867 55
; rts ;; @@3867 55
 ;; @@3867 55
;.end ;; @@3867 55
; .page ;; @@3867 55
; .subttl INPUT  GET  READ  LINPUT ;; @@3867 55
 ;; @@3867 55
get              jsr errdir                               ; direct mode illegal ;; @@3867 55
                 sta z_p_temp_1                           ; flag to distinguish between GET and GETKEY ;; @@386a 55
 ;; @@386c 55
                 cmp #'#'                                 ; is it GET# ? ;; @@386c 55
                 beq getn                                 ; yes ;; @@386e 55
                 cmp #key_token                           ; is it GETKEY ? ;; @@3870 55
                 bne gettty                               ; no, must be plain GET ;; @@3872 55
                 jsr chrget                               ; yes, skip over KEY token ;; @@3874 55
                 bra gettty                                ;; @@3877 55
 ;; @@3879 55
 ;; @@3879 55
getn             jsr chrget                               ; GET# move up to next byte ;; @@3879 55
                 jsr getbyt                               ; get channel into x ;; @@387c 55
                 lda #','                                 ; comma? ;; @@387f 55
                 jsr synchr                                ;; @@3881 55
                 stx channl                                ;; @@3884 55
                 jsr coin                                 ; chkin ;; @@3886 55
 ;; @@3889 55
 ;; @@3889 55
gettty                                                    ; GET ;; @@3889 55
                 ldx #<buf+1                              ; point to 0 ;; @@3889 55
                 ldy #>buf                                 ;; @@388b 55
                 lda #0                                   ; to stuff and to point ;; @@388d 55
                 sta buf+1                                ; zero it ;; @@388f 55
                 lda #$40                                 ; turn on v-bit ;; @@3892 55
                 jsr inpco1                               ; do the get ;; @@3894 55
                 ldx channl                                ;; @@3897 55
                 bne release_channels                     ; restore terminal channels ;; @@3899 55
                 rts                                       ;; @@389b 55
 ;; @@389c 55
; .page ;; @@389c 55
linputn                                                   ; input line from channel into a string var ;; @@389c 55
                 jsr chrget                               ; (eat input# token) ;; @@389c 55
                 smb7 op                                   ;; @@389f 55
                 !text $2c                                 ;; @@38a1 55
 ;; @@38a2 55
inputn           rmb7 op                                  ; flag INPUT# vs. LINPUT# ;; @@38a2 55
                 jsr getbyt                               ; get channel number ;; @@38a4 55
                 lda #','                                 ; a comma? ;; @@38a7 55
                 jsr synchr                                ;; @@38a9 55
                 stx channl                                ;; @@38ac 55
                 jsr coin                                 ; chkin ;; @@38ae 55
                 jsr notqti                               ; do input to variables ;; @@38b1 55
 ;; @@38b4 55
 ;; @@38b4 55
release_channels                                          ; iodone, iorele. ;; @@38b4 55
                 jsr _clrch                               ; clear I/O channels ;; @@38b4 55
; ldx #0   ;restore normal terminal channels ;; @@38b7 55
                 sta channl                               ; (was stx)     [910909] ;; @@38b7 55
                 rts                                       ;; @@38b9 55
 ;; @@38ba 55
 ;; @@38ba 55
linput                                                    ; input line from console into a string var ;; @@38ba 55
                 jsr chrget                               ; (eat input token) ;; @@38ba 55
                 smb7 op                                   ;; @@38bd 55
                 !text $2c                                 ;; @@38bf 55
 ;; @@38c0 55
input            rmb7 op                                  ; flag INPUT vs. LINPUT ;; @@38c0 55
                 cmp #'"'                                 ; a quote? ;; @@38c2 55
                 bne notqti                               ; no message ;; @@38c4 55
                 jsr strtxt                               ; literalize the string in text ;; @@38c6 55
 ;; @@38c9 55
                 jsr chrgot                               ; looking for prompt string terminator  [910219] ;; @@38c9 55
                 cmp #','                                  ;; @@38cc 55
                 bne _local_1054_10                        ;; @@38ce 55
                 sta buf_txtptr                           ; is comma- supress '?' after prompt  [910219] ;; @@38d0 55
                 jsr chrget                               ; eat comma ;; @@38d3 55
                 jsr strprt                               ; print prompt ;; @@38d6 55
                 jsr errdir                               ; error if direct mode ;; @@38d9 55
                 jsr InputLine                            ; get first item ;; @@38dc 55
                 bra getagn1                              ; see if there's more to do ;; @@38df 55
 ;; @@38e1 55
_local_1054_10   lda #';'                                 ; must end in semicolon ;; @@38e1 55
                 jsr synchr                                ;; @@38e3 55
                 jsr strprt                               ; print prompt ;; @@38e6 55
 ;; @@38e9 55
notqti           jsr errdir                               ; use common routine since def direct ;; @@38e9 56
                 lda #','                                 ; get comma ;; @@38ec 56
                 sta buf_txtptr                           ; (data reader expects buffer to start with terminator) ;; @@38ee 56
 ;; @@38f1 56
getagn           jsr PromptedInput                        ; type "?" and input a line of text ;; @@38f1 56
getagn1          lda channl                                ;; @@38f4 56
                 beq _local_1055_10                        ;; @@38f6 56
                 jsr _readst                              ; get status byte ;; @@38f8 56
; and #2   ; (assumes serial bus????)  [910618] eoi ok ;; @@38fb 56
                 and #%10000111                           ; serial: err if dnp, r/w timeout errors ;; @@38fb 56
                 beq _local_1055_10                       ; a-ok rs232: err if brk, ovr, frm, par errors ;; @@38fd 56
                 jsr release_channels                     ; bad, close channel ;; @@38ff 56
                 +lbra data                               ; skip rest of input ;; @@3902 56
 ;; @@3905 56
_local_1055_10   lda buf                                  ; bufful. get anything? ;; @@3905 56
                 bne inpcon                               ; yes- process input ;; @@3908 56
; lda channl  ;didn't get anything.  is this keyboard? [901212] ;; @@390a 56
; bne getagn  ; no- keep looking for data ???? ;; @@390a 56
                 jsr datan                                ; skip to end of statement ;; @@390a 56
                 +lbra addon                               ;; @@390d 56
 ;; @@3910 56
; .page ;; @@3910 56
read             rmb7 op                                  ; flag READ vs. LREAD    [910102] ;; @@3910 57
                 ldx datptr                               ; get last data location ;; @@3912 57
                 ldy datptr+1                              ;; @@3914 57
                 lda #$98                                 ; initiator= read ;; @@3916 57
                 !text $2c                                 ;; @@3918 57
 ;; @@3919 57
inpcon           lda #0                                   ; initiator= input ;; @@3919 57
inpco1           sta input_flag                           ; $98=read, $40=get, $00=input ;; @@391b 57
 ;; @@391d 57
; In the processing of DATA and READ statements, one pointer points to the data ;; @@391d 57
; (i.e., the numbers being fetched) and another points to the list of variables. ;; @@391d 57
; ;; @@391d 57
; The pointer into the data always starts pointing to a terminator- a ",", ":", or EOL. ;; @@391d 57
; At this point TXTPTR points to list of variables and (x,y) points to data or input line. ;; @@391d 57
 ;; @@391d 57
                 stx inpptr                               ; pointer to data ;; @@391d 57
                 sty inpptr+1                              ;; @@391f 57
 ;; @@3921 57
inloop           jsr ptrget                               ; get a pointer to the variable ;; @@3921 57
                 sta forpnt                               ; store its address ;; @@3924 57
                 sty forpnt+1                              ;; @@3926 57
 ;; @@3928 57
                 ldx #1                                    ;; @@3928 57
_local_1056_1    lda txtptr,x                             ; move variable list pointer to 'vartxt' ;; @@392a 57
                 sta vartxt,x                              ;; @@392c 57
                 lda inpptr,x                             ; move data line pointer to 'txtptr' ;; @@392e 57
                 sta txtptr,x                              ;; @@3930 57
                 dex                                       ;; @@3932 57
                 bpl _local_1056_1                         ;; @@3933 57
 ;; @@3935 57
                 jsr chrgot                               ; get first data byte ;; @@3935 57
                 bne datbk1                               ; not null, so we got something ;; @@3938 57
                 bit input_flag                           ; READ($98), GET($40), or INPUT($00)? ;; @@393a 57
                 bvc qdata                                ; branch if READ or INPUT ;; @@393c 57
                 lda z_p_temp_1                           ; GET or GETKEY? ;; @@393e 57
                 cmp #key_token                            ;; @@3940 57
                 bne _local_1056_3                        ; branch if GET ;; @@3942 57
 ;; @@3944 57
_local_1056_2    jsr cgetl                                ; GETKEY ;; @@3944 57
                 tax                                      ; test if null ;; @@3947 57
                 beq _local_1056_2                        ; it is null, keep scanning ;; @@3948 57
                 bne _local_1056_4                        ; got a key, go put it in var ;; @@394a 57
 ;; @@394c 57
_local_1056_3    jsr cgetl                                ; get a key if pressed, otherwise gets a zero ;; @@394c 57
_local_1056_4    sta buf                                   ;; @@394f 57
                 ldx #<buf_txtptr                          ;; @@3952 57
                 ldy #>buf_txtptr                          ;; @@3954 57
                 bra datbk                                 ;; @@3956 57
 ;; @@3958 57
; .page ;; @@3958 57
qdata            +lbmi datlop                             ; branch if READ ;; @@3958 58
                 lda channl                               ; else it's INPUT ;; @@395b 58
                 bne _local_1057_10                        ;; @@395d 58
                 jsr outqst                               ; console input, so display '? ' prompt ;; @@395f 58
 ;; @@3962 58
_local_1057_10   jsr PromptedInput                        ; get another line ;; @@3962 58
 ;; @@3965 58
datbk            stx txtptr                               ; set for CHRGET ;; @@3965 59
                 sty txtptr+1                              ;; @@3967 59
 ;; @@3969 59
datbk1           bbr7 op,_local_1058_1                    ; no chrgot if LINPUT (want leading spaces) [910513] ;; @@3969 59
                 jsr chargt                                ;; @@396c 59
                 jsr chrtst                                ;; @@396f 59
                 bra _local_1058_2                         ;; @@3972 59
 ;; @@3974 59
_local_1058_1    jsr chrget                               ; get next data byte ;; @@3974 59
_local_1058_2    bbr7 valtyp,_local_1058_50               ; get value type, input a number if numeric ;; @@3977 59
                 bbr6 input_flag,_local_1058_10           ; branch if not get, set quote ;; @@397a 59
                 inx                                       ;; @@397d 59
                 stx txtptr                                ;; @@397e 59
_local_1058_5    lda #0                                   ; [901212] ;; @@3980 59
                 sta charac                                ;; @@3982 59
                 bra _local_1058_20                        ;; @@3984 59
 ;; @@3986 59
_local_1058_10   bbs7 op,_local_1058_5                    ; no terminators if LINPUT or LREAD  [901212] ;; @@3986 59
                 sta charac                               ; setqut.  assume quoted string ;; @@3989 59
                 cmp #'"'                                 ; terminators ok? ;; @@398b 59
                 beq _local_1058_30                       ; yes (sets .c) ;; @@398d 59
                 lda #':'                                 ; set terminators to ":" and... ;; @@398f 59
                 sta charac                                ;; @@3991 59
                 lda #','                                 ; ...comma ;; @@3993 59
 ;; @@3995 59
_local_1058_20   clc                                      ; resetc ;; @@3995 59
_local_1058_30   sta endchr                               ; nowget ;; @@3996 59
                 lda txtptr                                ;; @@3998 59
                 ldy txtptr+1                              ;; @@399a 59
                 adc #0                                   ; .c is set properly above ;; @@399c 59
                 bcc _local_1058_40                        ;; @@399e 59
                 iny                                       ;; @@39a0 59
_local_1058_40   jsr strlt2                               ; make a string descriptor for the value & copy if needed ;; @@39a1 59
                 jsr st2txt                               ; copy strng2 to txtptr (st-2-txt... get it?) ;; @@39a4 59
                 jsr inpcom                               ; do assignment ;; @@39a7 59
                 bra _local_1058_60                        ;; @@39aa 59
 ;; @@39ac 59
_local_1058_50   bbs7 op,_local_1058_100                  ; error if LINPUT (string input only)  [901212] ;; @@39ac 59
                 ldx #0                                   ; numins. flag 'text bank' (0) ;; @@39af 59
                 jsr fin                                   ;; @@39b1 59
                 lda intflg                               ; set codes on flags ;; @@39b4 59
                 jsr qintgr                               ; go decide on float ;; @@39b6 59
 ;; @@39b9 59
_local_1058_60   jsr chrgot                               ; strdn2. read last character ;; @@39b9 59
                 beq trmok                                ; ":" or EOL is ok ;; @@39bc 59
                 cmp #','                                 ; a comma? ;; @@39be 59
                 beq trmok                                 ;; @@39c0 59
 ;; @@39c2 59
                 lda input_flag                           ; is this get, read, or input? ;; @@39c2 59
                 beq _local_1058_110                      ; input ;; @@39c4 59
                 bmi _local_1058_100                      ; read ;; @@39c6 59
                 ldx channl                               ; get. if not kbd, go use 'bad file data error' ;; @@39c8 59
                 bne _local_1058_120                       ;; @@39ca 59
 ;; @@39cc 59
_local_1058_100  ldx #errtm                               ; tmerr. 'get from kbd' or 'read' saw a bad type ;; @@39cc 59
                 bra _local_1058_130                      ; always ;; @@39ce 59
 ;; @@39d0 59
_local_1058_110  lda channl                                ;; @@39d0 59
                 beq _local_1058_200                      ; do again if keybd input ;; @@39d2 59
_local_1058_120  ldx #errbd                               ; input saw bad file data ;; @@39d4 59
_local_1058_130  +lbra error                               ;; @@39d6 59
 ;; @@39d9 59
 ;; @@39d9 59
_local_1058_200  jsr highlight_text                       ; [911119] ;; @@39d9 59
                 jsr _primm                                ;; @@39dc 59
                 !text "?REDO FROM START",cr,0             ;; @@39df 59
                 jsr highlight_done                       ; [911119] ;; @@39f1 59
 ;; @@39f4 59
ott              lda oldtxt                                ;; @@39f4 60
                 ldy oldtxt+1                              ;; @@39f7 60
                 sta txtptr                               ; put user back to beginning of input ;; @@39fa 60
                 sty txtptr+1                              ;; @@39fc 60
                 rts                                       ;; @@39fe 60
 ;; @@39ff 60
 ;; @@39ff 60
 ;; @@39ff 60
trmok            ldx #1                                    ;; @@39ff 60
_local_1059_1    lda txtptr,x                              ;; @@3a01 60
                 sta inpptr,x                             ; save for more reads ;; @@3a03 60
                 lda vartxt,x                              ;; @@3a05 60
                 sta txtptr,x                             ; point to variable list ;; @@3a07 60
                 dex                                       ;; @@3a09 60
                 bpl _local_1059_1                         ;; @@3a0a 60
 ;; @@3a0c 60
                 jsr chrgot                               ; look at last vartab character ;; @@3a0c 60
                 beq _local_1059_2                        ; that's the end of the list ;; @@3a0f 60
                 jsr chkcom                               ; not end. check for comma ;; @@3a11 60
                 +lbra inloop                              ;; @@3a14 60
 ;; @@3a17 60
_local_1059_2    lda inpptr                               ; put away a new data pntr name ;; @@3a17 60
                 ldy inpptr+1                              ;; @@3a19 60
                 bbr7 input_flag,_local_1059_3             ;; @@3a1b 60
                 sta datptr                                ;; @@3a1e 60
                 sty datptr+1                              ;; @@3a20 60
                 rts                                       ;; @@3a22 60
 ;; @@3a23 60
_local_1059_3    ldy #0                                   ; last data chr could have been ',' or ':' but should be null ;; @@3a23 60
                 lda #inpptr                               ;; @@3a25 60
                 jsr lda_far_ram0                          ;; @@3a27 60
                 beq _local_1059_4                        ; it is null ;; @@3a2a 60
                 lda channl                               ; if not terminal, no type ;; @@3a2c 60
                 bne _local_1059_4                         ;; @@3a2e 60
 ;; @@3a30 60
                 jsr highlight_text                       ; [911119] ;; @@3a30 60
                 jsr _primm                                ;; @@3a33 60
                 !text "?EXTRA IGNORED", cr,0              ;; @@3a36 60
                 jsr highlight_done                       ; [911119] ;; @@3a46 60
 ;; @@3a49 60
_local_1059_4    rts                                      ; do next statement ;; @@3a49 60
 ;; @@3a4a 60
; .page ;; @@3a4a 60
; DATLOP Routine Subroutine to find data. ;; @@3a4a 60
; ;; @@3a4a 60
; The search is made by using the execution code for data to skip over ;; @@3a4a 60
; statements, the start word of each statement is compared with "data_token". ;; @@3a4a 60
; Each new line number is stored in "datlin" so that if any error occurs while ;; @@3a4a 60
; reading data the error message can give the line number of the bad data. ;; @@3a4a 60
 ;; @@3a4a 60
datlop           jsr datan                                ; skip some text ;; @@3a4a 61
                 iny                                       ;; @@3a4d 61
                 tax                                      ; end of line? ;; @@3a4e 61
                 bne _local_1060_10                       ; no ;; @@3a4f 61
                 ldx #errod                               ; yes, "no data" error ;; @@3a51 61
                 iny                                       ;; @@3a53 61
                 jsr indtxt                                ;; @@3a54 61
                 +lbeq error                               ;; @@3a57 61
 ;; @@3a5a 61
                 iny                                       ;; @@3a5a 61
                 jsr indtxt                               ; get high byte of line number ;; @@3a5b 61
                 sta datlin                                ;; @@3a5e 61
                 iny                                       ;; @@3a60 61
                 jsr indtxt                               ; get low byte ;; @@3a61 61
                 iny                                       ;; @@3a64 61
                 sta datlin+1                              ;; @@3a65 61
 ;; @@3a67 61
_local_1060_10   jsr addon                                ; nowlin.  txtptr+.y ;; @@3a67 61
                 jsr chrgot                               ; span blanks ;; @@3a6a 61
                 tax                                      ; used later ;; @@3a6d 61
                 cpx #data_token                          ; is it a DATA statement? ;; @@3a6e 61
                 bne datlop                               ; not quite right, keep looking ;; @@3a70 61
                 +lbra datbk1                             ; this is the one ;; @@3a72 61
 ;; @@3a75 61
 ;; @@3a75 61
;.end ;; @@3a75 61
; .page ;; @@3a75 61
; .subttl NEXT ;; @@3a75 61
 ;; @@3a75 61
; Next routine ;; @@3a75 61
; ;; @@3a75 61
; 'FOR' entry on the stack has the following format: ;; @@3a75 61
; ;; @@3a75 61
; Low address ;; @@3a75 61
;  token (for_token) 1 byte ;; @@3a75 61
;  a pointer to the loop variable 2 bytes ;; @@3a75 61
;  the step 5 bytes ;; @@3a75 61
;  a byte reflecting the sign of the incr. 2 bytes ;; @@3a75 61
;  the upper value (packed) 5 bytes ;; @@3a75 61
;  the line number of the FOR statement 2 bytes ;; @@3a75 61
;  a text pointer into the FOR statement 2 bytes ;; @@3a75 61
; High address ;; @@3a75 61
; ;; @@3a75 61
; (total 16 bytes) ;; @@3a75 61
 ;; @@3a75 61
next             bne _local_1061_10                       ; hop if 'next' variable given ;; @@3a75 62
                 ldy #$ff                                 ; flag no specific 'for' variable ;; @@3a77 62
                 bra _local_1061_20                       ; always ;; @@3a79 62
 ;; @@3a7b 62
_local_1061_5    ldy #lenfor                              ; done, clean up stack ;; @@3a7b 62
                 jsr rlsstk                               ; release (y) items from stack ;; @@3a7d 62
                 jsr chrgot                                ;; @@3a80 62
                 cmp #','                                 ; ie., NEXT j,k ;; @@3a83 62
                 bne _local_1061_45                        ;; @@3a85 62
                 jsr chrget                                ;; @@3a87 62
 ;; @@3a8a 62
_local_1061_10   jsr ptrget                               ; get pointer to variable in (a,y) ;; @@3a8a 62
                 sta forpnt                                ;; @@3a8d 62
 ;; @@3a8f 62
_local_1061_20   sty forpnt+1                              ;; @@3a8f 62
                 lda #for_token                            ;; @@3a91 62
                 jsr search                               ; look for FOR entry in run-time stack ;; @@3a93 62
                 beq _local_1061_30                       ; branch if found ;; @@3a96 62
                 ldx #errnf                               ; otherwise 'error, not found' ;; @@3a98 62
                 +lbra error                               ;; @@3a9a 62
 ;; @@3a9d 62
 ;; @@3a9d 62
; Set up to move STEP value to FAC ;; @@3a9d 62
 ;; @@3a9d 62
_local_1061_30   jsr movfnd                               ; (fndpnt) => (tos) ;; @@3a9d 62
                 lda fndpnt                                ;; @@3aa0 62
                 clc                                       ;; @@3aa2 62
                 adc #3                                   ; offset to step value ;; @@3aa3 62
                 ldy fndpnt+1                              ;; @@3aa5 62
                 bcc _local_1061_35                        ;; @@3aa7 62
                 iny                                       ;; @@3aa9 62
 ;; @@3aaa 62
_local_1061_35   jsr movfm                                ; actually "move from ROM", but sys stack is in "common" ;; @@3aaa 62
                 ldy #8                                   ; MOVFM doesn't move sign.  Get it ;; @@3aad 62
                 lda (fndpnt),y                            ;; @@3aaf 62
                 sta facsgn                                ;; @@3ab1 62
 ;; @@3ab3 62
; Get pointer to FOR variable ;; @@3ab3 62
 ;; @@3ab3 62
                 ldy #1                                    ;; @@3ab3 62
                 lda (fndpnt),y                           ; get lsb ;; @@3ab5 62
                 pha                                       ;; @@3ab7 62
                 tax                                       ;; @@3ab8 62
                 iny                                       ;; @@3ab9 62
                 lda (fndpnt),y                           ; get msb ;; @@3aba 62
                 pha                                       ;; @@3abc 62
                 tay                                      ; msb in y ;; @@3abd 62
                 txa                                      ; lsb in a ;; @@3abe 62
                 jsr fadd                                 ; add STEP value to FOR variable (fadd gets from bank 1) ;; @@3abf 62
                 ply                                      ; msb in y ;; @@3ac2 62
                 plx                                      ; lsb in x ;; @@3ac3 62
                 jsr movmf_ram1                           ; put result back into FOR variable in var bank ;; @@3ac4 62
 ;; @@3ac7 62
; Make (a,y) point at TO value in stack ;; @@3ac7 62
 ;; @@3ac7 62
                 lda fndpnt                                ;; @@3ac7 62
                 clc                                       ;; @@3ac9 62
                 adc #9                                    ;; @@3aca 62
                 ldy fndpnt+1                              ;; @@3acc 62
                 bcc _local_1061_40                        ;; @@3ace 62
                 iny                                       ;; @@3ad0 62
 ;; @@3ad1 62
; Test if loop done ;; @@3ad1 62
 ;; @@3ad1 62
_local_1061_40                                             ;; @@3ad1 62
; sta sw_rom_ram0 ;???? ;; @@3ad1 62
                 jsr fcomp                                ; compare FAC to value pointed to by (a,y) ;; @@3ad1 62
                 ldy #8                                    ;; @@3ad4 62
                 sec                                       ;; @@3ad6 62
                 sbc (fndpnt),y                           ; (common area????) ;; @@3ad7 62
                 beq _local_1061_5                        ; branch taken if done ;; @@3ad9 62
 ;; @@3adb 62
                 ldy #17                                  ; not done, set pointers to re-execute loop ;; @@3adb 62
                 lda (fndpnt),y                           ; (common area????) ;; @@3add 62
                 sta txtptr                                ;; @@3adf 62
                 dey                                       ;; @@3ae1 62
                 lda (fndpnt),y                            ;; @@3ae2 62
                 sta txtptr+1                              ;; @@3ae4 62
                 dey                                       ;; @@3ae6 62
                 lda (fndpnt),y                            ;; @@3ae7 62
                 sta curlin+1                              ;; @@3ae9 62
                 dey                                       ;; @@3aeb 62
                 lda (fndpnt),y                            ;; @@3aec 62
                 sta curlin                                ;; @@3aee 62
_local_1061_45   rts                                       ;; @@3af0 62
 ;; @@3af1 62
;.end ;; @@3af1 62
; .page ;; @@3af1 62
; .subttl DIM ;; @@3af1 62
 ;; @@3af1 62
; The DIMension code sets DIMFLG and then falls into the variable search ;; @@3af1 62
; routine, which looks at DIMFLG at 3 different points: ;; @@3af1 62
; ;; @@3af1 62
; 1) If an entry is found, DIMFLG being on indicates a ;; @@3af1 62
;    doubly-defined variable. ;; @@3af1 62
; 2) When a new entry is being built, DIMFLG being on indicates ;; @@3af1 62
;    the indices should be used for the size of each index. ;; @@3af1 62
;    Otherwise the default of ten is used. ;; @@3af1 62
; 3) When the build entry code finishes, indexing will be done ;; @@3af1 62
;    only if DIMFLG is off. ;; @@3af1 62
 ;; @@3af1 62
 ;; @@3af1 62
dim3             jsr chkcom                               ; must be a comma ;; @@3af1 63
 ;; @@3af4 63
dim              tax                                      ; make .x non-zero (.a must be non-zero to work correctly) ;; @@3af4 63
                 jsr ptrgt1                                ;; @@3af5 63
                 jsr chrgot                               ; get last character ;; @@3af8 63
                 bne dim3                                  ;; @@3afb 63
                 rts                                       ;; @@3afd 63
 ;; @@3afe 63
;.end ;; @@3afe 63
; .page ;; @@3afe 63
; .subttl SYS ;; @@3afe 63
 ;; @@3afe 63
sys              jsr getwrd                               ; convert arg to integer value ;; @@3afe 63
                 lda linnum                               ; set up arg's for call to 'long jsr' ;; @@3b01 63
                 sta _pclo                                 ;; @@3b03 63
                 lda linnum+1                              ;; @@3b05 63
                 sta _pchi                                 ;; @@3b07 63
                 lda current_bank                          ;; @@3b09 63
                 sta _bank                                 ;; @@3b0c 63
 ;; @@3b0e 63
                 jsr optbyt                               ; (optional) .A reg arg ;; @@3b0e 63
                 bcc _local_1062_10                        ;; @@3b11 63
                 stx _a_reg                                ;; @@3b13 63
 ;; @@3b15 63
_local_1062_10   jsr optbyt                               ; (optional) .X reg arg ;; @@3b15 63
                 bcc _local_1062_20                        ;; @@3b18 63
                 stx _x_reg                                ;; @@3b1a 63
 ;; @@3b1c 63
_local_1062_20   jsr optbyt                               ; (optional) .Y reg arg ;; @@3b1c 63
                 bcc _local_1062_30                        ;; @@3b1f 63
                 stx _y_reg                                ;; @@3b21 63
 ;; @@3b23 63
_local_1062_25   jsr optbyt                               ; (optional) .Z reg arg ;; @@3b23 63
                 bcc _local_1062_30                        ;; @@3b26 63
                 stx _z_reg                                ;; @@3b28 63
 ;; @@3b2a 63
_local_1062_30   jsr optbyt                               ; (optional) .S reg arg ;; @@3b2a 63
                 bcc _local_1062_40                        ;; @@3b2d 63
                 stx _s_reg                                ;; @@3b2f 63
 ;; @@3b31 63
_local_1062_40   jmp _jsr_far                             ; far, far away ;; @@3b31 63
;If returns, Kernel will update _reg's for us ;; @@3b34 63
 ;; @@3b34 63
;.end ;; @@3b34 63
; .page ;; @@3b34 63
; .subttl DMA ;; @@3b34 63
 ;; @@3b34 63
; DMA - Set up for DMA operation (FETCH/STASH/SWAP) ;; @@3b34 63
; ;; @@3b34 63
;  Syntax:  DMA  command,length,source(l/h/b),destination(l/h/b)[,subcmd,mod(l/h)] [,...] ;; @@3b34 63
 ;; @@3b34 63
 ;; @@3b34 63
dma                                                       ; params are not longer optional-  [910520] F018A ;; @@3b34 64
                 jsr getbyt                               ; get command ;; @@3b34 64
_local_1063_1    bcc _local_1063_10                        ;; @@3b37 64
                 txa                                      ; [910102] ;; @@3b39 64
                 and #%00000100                           ;  ;; @@3b3a 64
                 +lbne fcerr                              ; (disallow chained DMA lists) ;; @@3b3c 64
                 stx dma2_cmd                              ;; @@3b3f 64
 ;; @@3b42 64
_local_1063_10   jsr comwrd                               ; get length ;; @@3b42 64
; bcc _local_1063_20 ;; @@3b45 64
                 sty dma2_cnt_lo                           ;; @@3b45 64
                 sta dma2_cnt_hi                           ;; @@3b48 64
 ;; @@3b4b 64
_local_1063_20   jsr comwrd                               ; get source address & bank ;; @@3b4b 64
; bcc _local_1063_30 ;; @@3b4e 64
                 sty dma2_src_lo                           ;; @@3b4e 64
                 sta dma2_src_hi                           ;; @@3b51 64
_local_1063_30   jsr combyt                                ;; @@3b54 64
; bcc _local_1063_40 ;; @@3b57 64
                 stx dma2_src_bank                         ;; @@3b57 64
 ;; @@3b5a 64
_local_1063_40   jsr comwrd                               ; get destination address & bank ;; @@3b5a 64
; bcc _local_1063_50 ;; @@3b5d 64
                 sty dma2_dest_lo                          ;; @@3b5d 64
                 sta dma2_dest_hi                          ;; @@3b60 64
_local_1063_50   jsr combyt                                ;; @@3b63 64
; bcc _local_1063_60 ;; @@3b66 64
                 stx dma2_dest_bank                        ;; @@3b66 64
 ;; @@3b69 64
_local_1063_60   jsr optzer                               ; get subcmd, default=0    [910520] F018A ;; @@3b69 64
; bcc _local_1063_65 ;; @@3b6c 64
                 stx dma2_subcmd                           ;; @@3b6c 64
 ;; @@3b6f 64
_local_1063_65   jsr optzer                               ; get mod lo/hi, default=0   [910102] ;; @@3b6f 64
; bcc _local_1063_70 ;; @@3b72 64
                 stx dma2_mod_lo                           ;; @@3b72 64
_local_1063_70   jsr optzer                                ;; @@3b75 64
; bcc _local_1063_80 ;; @@3b78 64
                 stx dma2_mod_hi                           ;; @@3b78 64
 ;; @@3b7b 64
_local_1063_80   ldy #0                                   ; dma_list (bank 0) ;; @@3b7b 64
                 ldx #>dma2_cmd                            ;; @@3b7d 64
                 lda #<dma2_cmd                            ;; @@3b7f 64
                 sty dma_ctlr+2                           ; dma_list bank ;; @@3b81 64
                 stx dma_ctlr+1                           ; dma_list hi ;; @@3b84 64
                 sta dma_ctlr                             ; dma_list lo & trigger ;; @@3b87 64
_local_1063_85   bit dma_ctlr+3                           ; check status (in case IRQ enabled)  [910103] ;; @@3b8a 64
                 bmi _local_1063_85                       ; busy ;; @@3b8d 64
 ;; @@3b8f 64
                 jsr chrgot                               ; eol? ;; @@3b8f 64
                 beq _local_1063_90                       ; yes ;; @@3b92 64
                 jsr optbyt                               ; no- continue after getting comma & next cmd byte ;; @@3b94 64
                 bra _local_1063_1                         ;; @@3b97 64
 ;; @@3b99 64
_local_1063_90   rts                                       ;; @@3b99 64
 ;; @@3b9a 64
;.end ;; @@3b9a 64
; .page ;; @@3b9a 64
; .subttl  TRON  TROFF ;; @@3b9a 64
 ;; @@3b9a 64
 ;; @@3b9a 64
tron                                                      ; trace mode on ;; @@3b9a 65
                 smb5 runmod                              ; trcflg ;; @@3b9a 65
                 rts                                       ;; @@3b9c 65
 ;; @@3b9d 65
 ;; @@3b9d 65
troff                                                     ; trace mode off ;; @@3b9d 65
                 rmb5 runmod                              ; trcflg ;; @@3b9d 65
                 rts                                       ;; @@3b9f 65
 ;; @@3ba0 65
 ;; @@3ba0 65
;.end ;; @@3ba0 65
; .page ;; @@3ba0 65
; .subttl  RREG ;; @@3ba0 65
 ;; @@3ba0 65
; RREG - Return values of 6502 registers following a SYS call. ;; @@3ba0 65
; ;; @@3ba0 65
; Syntax : RREG [.A variable [,[.X[...Z] variable] [,[.S variable] ]]] ;; @@3ba0 65
 ;; @@3ba0 65
rreg             lda #0                                    ;; @@3ba0 65
                 sta count                                 ;; @@3ba2 65
 ;; @@3ba4 65
_local_1064_10   jsr chrgot                                ;; @@3ba4 65
                 beq _local_1064_50                       ; reached end of statement- done ;; @@3ba7 65
                 cmp #','                                 ; skip this arg? ;; @@3ba9 65
                 beq _local_1064_30                       ; branch if so ;; @@3bab 65
                 jsr ptrget                               ; get pointer to target variable ;; @@3bad 65
                 sta forpnt                               ; a little bit of set up so we can share LET code ;; @@3bb0 65
                 sty forpnt+1                              ;; @@3bb2 65
                 lda valtyp                               ; what kind of variable name did ptrget find? ;; @@3bb4 65
                 +lbne chkerr                             ; type mismatch error if string ;; @@3bb6 65
 ;; @@3bb9 65
                 ldy count                                ; which register's value are we looking for? ;; @@3bb9 65
                 lda _a_reg,y                             ; .A, .X, .Y, & .Z are contiguious ;; @@3bbb 65
                 cpy #4                                    ;; @@3bbe 65
                 bne _local_1064_20                        ;; @@3bc0 65
                 lda _s_reg                               ; but .S isn't ;; @@3bc2 65
 ;; @@3bc4 65
_local_1064_20   tay                                      ; low byte in .Y ;; @@3bc4 65
                 lda #0                                   ; high byte of zero ;; @@3bc5 65
                 jsr givayf                               ; go float it ;; @@3bc7 65
                 lda intflg                               ; set conditions for type of var (int/float) ;; @@3bca 65
                 jsr qintgr                               ; ..and use part of LET to do the work ;; @@3bcc 65
 ;; @@3bcf 65
_local_1064_30   inc count                                ; 5 registers to do ;; @@3bcf 65
                 lda count                                 ;; @@3bd1 65
                 cmp #5                                    ;; @@3bd3 65
                 bcs _local_1064_50                        ;; @@3bd5 65
                 jsr chrgot                               ; was this e-o-statement? ;; @@3bd7 65
                 beq _local_1064_50                        ;; @@3bda 65
                 jsr chrget                               ; not e-o-s, skip over comma, ;; @@3bdc 65
                 bne _local_1064_10                       ; ..and go do next ;; @@3bdf 65
 ;; @@3be1 65
_local_1064_50   rts                                       ;; @@3be1 65
 ;; @@3be2 65
;.end ;; @@3be2 65
; .page ;; @@3be2 65
; .subttl MID$ ;; @@3be2 65
 ;; @@3be2 65
; Alternate use of the MID$ function, as the target of an assignment. ;; @@3be2 65
; ;; @@3be2 65
; MID$(string_var,starting_position [,length]) = string_expression ;; @@3be2 65
 ;; @@3be2 65
midd2                                                      ;; @@3be2 66
midwrk           =midd2-1                                  ;; @@3be2 66
 ;; @@3be2 66
                 jsr chkopn                               ; check for '(' ;; @@3be2 66
                 jsr ptrget                               ; get pointer to descriptor of string-var ;; @@3be5 66
                 sta forpnt                               ; store for later use ;; @@3be8 66
                 sty forpnt+1                              ;; @@3bea 66
                 jsr chkstr                               ; check if string ;; @@3bec 66
 ;; @@3bef 66
                 jsr combyt                               ; look for comma, followed by 1 byte starting address ;; @@3bef 66
                 dex                                      ; adjust starting addr ;; @@3bf2 66
                 stx hulp                                 ; store    " " ;; @@3bf3 66
 ;; @@3bf5 66
                 cmp #')'                                 ; finished? ;; @@3bf5 66
                 beq _local_1065_10                       ; branch if so (use default length) ;; @@3bf7 66
                 jsr combyt                               ; ..else get length ;; @@3bf9 66
                 !text $2c                                 ;; @@3bfc 66
 ;; @@3bfd 66
_local_1065_10   ldx #$ff                                 ; default length ;; @@3bfd 66
                 stx z_p_temp_1                            ;; @@3bff 66
                 jsr chkcls                               ; look for ')' ;; @@3c01 66
                 lda #equal_token                         ; look for '=' ;; @@3c04 66
                 jsr synchr                                ;; @@3c06 66
                 jsr frmevl                               ; bring on the source! ;; @@3c09 66
                 jsr chkstr                               ; nothing funny ;; @@3c0c 66
 ;; @@3c0f 66
                 ldy #2                                   ; get string descriptors ;; @@3c0f 66
_local_1065_20   lda #forpnt                              ; target ;; @@3c11 66
                 jsr lda_far_ram1                         ; lda (forpnt),y ;; @@3c13 66
                 sta str1,y                                ;; @@3c16 66
                 jsr indfmo                               ; source ;; @@3c19 66
                 sta str2,y                                ;; @@3c1c 66
                 dey                                       ;; @@3c1f 66
                 bpl _local_1065_20                        ;; @@3c20 66
 ;; @@3c22 66
; Test for target string in text was removed-  all strings are copied to ;; @@3c22 66
; string RAM when they are created. ;; @@3c22 66
 ;; @@3c22 66
                 sec                                      ; adjust pointer to source string so that the same ;; @@3c22 66
                 lda str2+1                               ; ..index can load & save ;; @@3c23 66
                 sbc hulp                                  ;; @@3c25 66
                 sta str2+1                                ;; @@3c27 66
                 bcs _local_1065_30                        ;; @@3c29 66
                 dec str2+2                                ;; @@3c2b 66
 ;; @@3c2d 66
_local_1065_30   lda z_p_temp_1                           ; get specified length (or default) ;; @@3c2d 66
                 cmp str2                                 ; compare with length of source ;; @@3c2f 66
                 bcc _local_1065_40                       ; ok if less, ;; @@3c31 66
                 lda str2                                 ; ..else use length of source ;; @@3c33 66
_local_1065_40   tax                                       ;; @@3c35 66
                 beq _local_1065_80                       ; done if length=0 ;; @@3c36 66
                 clc                                       ;; @@3c38 66
                 adc hulp                                 ; add length to starting posn. ;; @@3c39 66
                 +lbcs fcerr                              ; illegal quantity error if > 256 ;; @@3c3b 66
                 cmp str1                                  ;; @@3c3e 66
                 bcc _local_1065_60                        ;; @@3c40 66
                 +lbne fcerr                              ; ...or if > target length ;; @@3c42 66
 ;; @@3c45 66
_local_1065_60   ldy hulp                                 ; get adjusted starting address ;; @@3c45 66
_local_1065_70   phx                                       ;; @@3c47 66
                 ldx #str1+1                               ;; @@3c48 66
                 lda #str2+1                               ;; @@3c4a 66
                 jsr lda_far_ram1                         ; fetch from string bank ;; @@3c4c 66
                 jsr sta_far_ram1                         ; this is what it's all about ;; @@3c4f 66
                 iny                                       ;; @@3c52 66
                 plx                                       ;; @@3c53 66
                 dex                                       ;; @@3c54 66
                 bne _local_1065_70                       ; keep going for specified length ;; @@3c55 66
 ;; @@3c57 66
_local_1065_80   +lbra frefac                             ; free up temp. string, rts ;; @@3c57 66
 ;; @@3c5a 66
;.end ;; @@3c5a 66
 ;; @@3c5a 66
; .page ;; @@3c5a 66
; .subttl  AUTO ;; @@3c5a 66
 ;; @@3c5a 66
; AUTO Increment ;; @@3c5a 66
;   Syntax :    auto {line-number} (line-number = 0 means turn off) ;; @@3c5a 66
 ;; @@3c5a 66
auto                                                       ;; @@3c5a 67
                 jsr errind                                ;; @@3c5a 67
                 jsr linget                                ;; @@3c5d 67
                 lda linnum                                ;; @@3c60 67
                 sta autinc                                ;; @@3c62 67
                 lda linnum+1                              ;; @@3c64 67
                 sta autinc+1                              ;; @@3c66 67
                 rts                                       ;; @@3c68 67
 ;; @@3c69 67
;.end ;; @@3c69 67
; .page ;; @@3c69 67
; .subttl  HELP ;; @@3c69 67
 ;; @@3c69 67
help             ldx errnum                               ; check for error status ;; @@3c69 67
                 inx                                       ;; @@3c6c 67
                 beq _local_1066_1                        ; exit if there is no current error ;; @@3c6d 67
                 lda errlin                                ;; @@3c6f 67
                 ldy errlin+1                              ;; @@3c72 67
                 sta linnum                                ;; @@3c75 67
                 sty linnum+1                              ;; @@3c77 67
                 jsr FindLine                             ; find the beginning of line with error ;; @@3c79 67
                 bcc _local_1066_1                        ; exit if line not found? ;; @@3c7c 67
 ;; @@3c7e 67
                 jsr crdo                                 ; begin a new line ;; @@3c7e 67
                 ldx linnum                                ;; @@3c81 67
                 lda linnum+1                              ;; @@3c83 67
                 ldz helper                                ;; @@3c85 67
                 rmb4 helper                              ; temporarily disable token highlighting ;; @@3c88 67
                 smb7 helper                              ; set 'help' flag for P1LINE ;; @@3c8a 67
                 jsr p1line                               ; display line & highlight error ;; @@3c8c 67
                 stz helper                                ;; @@3c8f 67
_local_1066_1    rmb7 helper                              ; reset 'help' flag ;; @@3c91 67
                 +lbra crdo                               ; and return to caller ;; @@3c93 67
 ;; @@3c96 67
 ;; @@3c96 67
 ;; @@3c96 67
helpsb                                                    ; logic to highlight error or find string ;; @@3c96 68
                 bbs4 helper,highlight_done               ; branch if highlighting tokens ;; @@3c96 68
                 bbs5 helper,_local_1067_10               ; branch if FIND ;; @@3c99 68
 ;; @@3c9c 68
                 ldx lowtr+1                              ; has P1LINE reached code in error? ;; @@3c9c 68
                 tya                                       ;; @@3c9e 68
                 clc                                       ;; @@3c9f 68
                 adc lowtr                                ; add character pointer to line pointer... ;; @@3ca0 68
                 bcc _local_1067_1                         ;; @@3ca2 68
                 inx                                       ;; @@3ca4 68
_local_1067_1    cpx errtxt+1                             ; and compare to error pointer ;; @@3ca5 68
                 bne _local_1067_3                        ; not there ;; @@3ca8 68
                 cmp errtxt                                ;; @@3caa 68
                 bcs highlight_text                       ; we're there- begin highlighting ;; @@3cad 68
_local_1067_3    rts                                       ;; @@3caf 68
 ;; @@3cb0 68
 ;; @@3cb0 68
_local_1067_10   cpy fndpnt                               ; at first character of find string? ;; @@3cb0 68
                 bcc _local_1067_30                       ; before it ;; @@3cb2 68
                 lda find_count                            ;; @@3cb4 68
                 beq _local_1067_30                       ; past it ;; @@3cb7 68
                 bmi _local_1067_40                       ; at last character ;; @@3cb9 68
                 cmp fstr1+2                               ;; @@3cbb 68
                 bcc _local_1067_20                       ; in middle of string ;; @@3cbd 68
                 jsr highlight_text                       ; at first char- start highlight ;; @@3cbf 68
_local_1067_20   dec find_count                           ; one less character to highlight ;; @@3cc2 68
                 beq _local_1067_20                       ; special case- ;; @@3cc5 68
;make it negative for next time around ;; @@3cc7 68
_local_1067_30   rts                                       ;; @@3cc7 68
 ;; @@3cc8 68
_local_1067_40   inc find_count                           ; make it zero ;; @@3cc8 68
 ;; @@3ccb 68
 ;; @@3ccb 68
highlight_done                                            ; nasty kludge to colorize error or found text ;; @@3ccb 69
                 lda highlight_save                        ;; @@3ccb 69
                 bmi _local_1068_10                       ; (unless it's already normal) ;; @@3cce 69
                 sta _color                               ; restore normal color ;; @@3cd0 69
                 ora #$80                                  ;; @@3cd2 69
                 sta highlight_save                       ; mark highlight_save invalid ;; @@3cd4 69
                 rmb7 helper                              ; remove HELP flag ;; @@3cd7 69
                 rmb1 helper                              ; remove token flag ;; @@3cd9 69
_local_1068_10   rts                                       ;; @@3cdb 69
 ;; @@3cdc 69
 ;; @@3cdc 69
highlight_text                                            ; nasty kludge to colorize error or found text ;; @@3cdc 70
                 bit highlight_save                        ;; @@3cdc 70
                 bpl _local_1069_10                       ; (unless it's already highlighted) ;; @@3cdf 70
                 lda _color                               ; save current (normal) color ;; @@3ce1 70
                 sta highlight_save                       ; msb=0 to mark highlight_save valid ;; @@3ce3 70
                 lda highlight_color                       ;; @@3ce6 70
                 sta _color                               ; change color to highlight ;; @@3ce9 70
_local_1069_10   rts                                       ;; @@3ceb 70
 ;; @@3cec 70
;.end ;; @@3cec 70
; .page ;; @@3cec 70
; .subttl  GOSUB  GOTO ;; @@3cec 70
 ;; @@3cec 70
; GOSUB-  Push text pointer, line #, & gosub token on stack: ;; @@3cec 70
; ;; @@3cec 70
;  (bottom) highest memory ;; @@3cec 70
;=========================================================== ;; @@3cec 70
;  txtptr+1 address of next statement ;; @@3cec 70
;  txtptr ;; @@3cec 70
;  ======== ;; @@3cec 70
;  curlin+1 current line number ;; @@3cec 70
;  curlin ;; @@3cec 70
;  ======== ;; @@3cec 70
;  'gosub' token <== (tos) top of stack pointer ;; @@3cec 70
;=========================================================== ;; @@3cec 70
;  (top of stack) lowest memory ;; @@3cec 70
 ;; @@3cec 70
 ;; @@3cec 70
gosub            bbs4 runmod,edit_err                     ; [910620] ;; @@3cec 71
                 jsr gosub_sub                             ;; @@3cef 71
                 jsr chrgot                               ; get character and set carry for linget ;; @@3cf2 71
                 jsr goto                                  ;; @@3cf5 71
                 +lbra newstt                              ;; @@3cf8 71
 ;; @@3cfb 71
; .page ;; @@3cfb 71
goto             bbs4 runmod,edit_err                     ; [910620] ;; @@3cfb 71
                 jsr linget                               ; pick up the line number in LINNUM ;; @@3cfe 71
                 lda endchr                               ; test if linget found any number ;; @@3d01 71
                 +lbeq snerr                              ; no number error ;; @@3d03 71
 ;; @@3d06 71
goto_1           jsr remn                                 ; jump to end of line (entry for interrupt code) ;; @@3d06 71
                 sec                                       ;; @@3d09 71
                 lda curlin                                ;; @@3d0a 71
                 sbc linnum                                ;; @@3d0c 71
                 lda curlin+1                              ;; @@3d0e 71
                 sbc linnum+1                              ;; @@3d10 71
                 bcs luk4it                                ;; @@3d12 71
                 tya                                       ;; @@3d14 71
                 sec                                       ;; @@3d15 71
                 adc txtptr                                ;; @@3d16 71
                 ldx txtptr+1                              ;; @@3d18 71
                 bcc lukall                                ;; @@3d1a 71
                 inx                                       ;; @@3d1c 71
                 bra lukall                               ; always goes ;; @@3d1d 71
 ;; @@3d1f 71
 ;; @@3d1f 71
luk4it           lda txttab                                ;; @@3d1f 71
                 ldx txttab+1                              ;; @@3d21 71
 ;; @@3d23 71
lukall           jsr FindLink                             ; (a,x) are all set up ;; @@3d23 71
                 +lbcc userr                              ; undefined statement error ;; @@3d26 71
                 lda lowtr                                 ;; @@3d29 71
                 sbc #1                                    ;; @@3d2b 71
                 sta txtptr                                ;; @@3d2d 71
                 lda lowtr+1                               ;; @@3d2f 71
                 sbc #0                                    ;; @@3d31 71
                 sta txtptr+1                              ;; @@3d33 71
                 bbr7 runmod,setexc                       ; branch if in direct mode ;; @@3d35 71
                 rts                                       ;; @@3d38 71
 ;; @@3d39 71
 ;; @@3d39 71
 ;; @@3d39 71
gosub_sub                                                  ;; @@3d39 71
                 lda #lengos                              ; free up necessary space on stack ;; @@3d39 71
                 jsr getstk                               ; make sure there is room ;; @@3d3b 71
                 ldy #lengos-1                             ;; @@3d3e 71
                 lda txtptr+1                             ; push on the text pointer ;; @@3d40 71
                 sta (tos),y                              ; (common area) ;; @@3d42 71
                 dey                                       ;; @@3d44 71
                 lda txtptr                                ;; @@3d45 71
                 sta (tos),y                              ; (common area) ;; @@3d47 71
                 dey                                       ;; @@3d49 71
                 lda curlin+1                             ; push on the current line number ;; @@3d4a 71
                 sta (tos),y                              ; (common area) ;; @@3d4c 71
                 dey                                       ;; @@3d4e 71
                 lda curlin                                ;; @@3d4f 71
                 sta (tos),y                              ; (common area) ;; @@3d51 71
                 dey                                       ;; @@3d53 71
                 lda #gosub_token                         ; (a) was smashed by GETSTK ;; @@3d54 71
                 sta (tos),y                              ; (common area) ;; @@3d56 71
                 rts                                       ;; @@3d58 71
 ;; @@3d59 71
 ;; @@3d59 71
edit_err                                                   ;; @@3d59 71
                 ldx #edit_mode_error                     ; [910620] ;; @@3d59 71
                 +lbra error                               ;; @@3d5b 71
 ;; @@3d5e 71
;.end ;; @@3d5e 71
; .page ;; @@3d5e 71
; .subttl  GO  GO64 ;; @@3d5e 71
 ;; @@3d5e 71
go_without_to                                              ;; @@3d5e 71
                 jsr chrget                               ; what is next character? ;; @@3d5e 71
                 cmp #to_token                            ; ..is it GO TO? ;; @@3d61 71
                 bne _local_1070_1                         ;; @@3d63 71
                 jsr chrget                               ; ..yes, set up for goto ;; @@3d65 71
                 bra goto                                 ; ..bye! ;; @@3d68 71
 ;; @@3d6a 71
_local_1070_1    jsr getbyt                               ; is it GO 64? ;; @@3d6a 71
                 cpx #64                                   ;; @@3d6d 71
                 +lbne snerr                              ; ...no, error ;; @@3d6f 71
 ;; @@3d72 71
; The user wants to go to C64 mode. ;; @@3d72 71
 ;; @@3d72 71
_local_1070_2    jsr are_you_sure                          ;; @@3d72 71
                 bne cont_rts                             ; must have had second thoughts. never mind ;; @@3d75 71
; jsr put_io_in_map ;; @@3d77 71
                 jmp _go_64                                ;; @@3d77 71
 ;; @@3d7a 71
 ;; @@3d7a 71
;.end ;; @@3d7a 71
; .page ;; @@3d7a 71
; .subttl  CONTINUE ;; @@3d7a 71
;********************************************************** ;; @@3d7a 71
;* ;; @@3d7a 71
;* CONTINUE Execution after STOP/END ;; @@3d7a 71
;* ;; @@3d7a 71
;********************************************************** ;; @@3d7a 71
 ;; @@3d7a 71
cont             bne cont_rts                             ; make sure there is a terminator ;; @@3d7a 72
                 bbs4 runmod,edit_err                     ; [910620] ;; @@3d7c 72
                 bbs7 runmod,cont_rts                     ; if in run-mode just rts ;; @@3d7f 72
 ;; @@3d82 72
                 ldx #errcn                               ; continue error. ;; @@3d82 72
                 ldy oldtxt+1                             ; a stored txtptr of zero set up by INIT_STACK ;; @@3d84 72
                 +lbeq error                              ; indicates there is nothing to continue ;; @@3d87 72
 ;; @@3d8a 72
                 lda oldtxt                               ; STOP, END, typing crlf to INPUT, and STOP key ;; @@3d8a 72
                 sta txtptr                                ;; @@3d8d 72
                 sty txtptr+1                              ;; @@3d8f 72
                 lda oldlin                                ;; @@3d91 72
                 ldy oldlin+1                              ;; @@3d94 72
                 sta curlin                                ;; @@3d97 72
                 sty curlin+1                              ;; @@3d99 72
 ;; @@3d9b 72
setexc           smb7 runmod                              ; set up run mode ;; @@3d9b 72
                 lda #0                                    ;; @@3d9d 72
                 sta autinc                               ; turn auto increment off ;; @@3d9f 72
                 sta autinc+1                              ;; @@3da1 72
                 sta intval                               ; enable & reset collision-trapping mechanism ;; @@3da3 72
                 sta _autoinsert                          ; disable auto-insert mode ????? ;; @@3da6 72
 ;; @@3da8 72
                 ldx #2                                   ; turn off all interrupt trip flags ;; @@3da8 72
_local_1071_10   sta int_trip_flag,x                       ;; @@3daa 72
                 dex                                       ;; @@3dad 72
                 bpl _local_1071_10                        ;; @@3dae 72
 ;; @@3db0 72
                 jsr _setmsg                              ; turn kernel messages off & rts ;; @@3db0 72
 ;; @@3db3 72
cont_rts                                                   ;; @@3db3 73
                 rts                                       ;; @@3db3 73
 ;; @@3db4 73
;.end ;; @@3db4 73
; .page ;; @@3db4 73
; .subttl  RUN ;; @@3db4 73
;*********************************************************** ;; @@3db4 73
;* ;; @@3db4 73
;* RUN Command ;; @@3db4 73
;* ;; @@3db4 73
;* RUN [line_number] ;; @@3db4 73
;* RUN filename [[ON] Ddrive_number[,Uunit_number]] ;; @@3db4 73
;* ;; @@3db4 73
;* Entry:  RUN_A_PROGRAM sets up, links, and executes ;; @@3db4 73
;*  a program previously loaded into RAM. ;; @@3db4 73
;* ;; @@3db4 73
;*********************************************************** ;; @@3db4 73
 ;; @@3db4 73
run              bbs4 runmod,edit_err                     ; [910620] ;; @@3db4 73
                 beq run__10                              ; branch if no arguments ;; @@3db7 73
                 bcc run__20                              ; branch if number (i.e., RUN line_number) ;; @@3db9 73
 ;; @@3dbb 73
 ;; @@3dbb 73
; Here if of the form "RUN file_name" ;; @@3dbb 73
 ;; @@3dbb 73
                 smb6 runmod                              ; set flag for load not to go to ready ;; @@3dbb 73
                 jsr dload                                ; use DLOAD's parser, and load the program ;; @@3dbd 73
                 +lbcs erexit                             ; if problem loading   [900801] ;; @@3dc0 73
 ;; @@3dc3 73
run_a_program                                              ;; @@3dc3 73
                 jsr crdo                                 ; [911010] ;; @@3dc3 73
                 jsr fix_links                            ; re-link the program ;; @@3dc6 73
                 jsr setexc                               ; set various run modes ;; @@3dc9 73
                 jsr runc                                  ;; @@3dcc 73
                 +lbra newstt                             ; start executing ;; @@3dcf 73
 ;; @@3dd2 73
 ;; @@3dd2 73
; Here if of the form "RUN" ;; @@3dd2 73
 ;; @@3dd2 73
run__10          jsr setexc                               ; set various run codes ;; @@3dd2 73
                 +lbra runc                               ; ..and start executing ;; @@3dd5 73
 ;; @@3dd8 73
 ;; @@3dd8 73
; Here if of the form "RUN line_number" ;; @@3dd8 73
 ;; @@3dd8 73
run__20          jsr clearc                               ; first trash all variables ;; @@3dd8 73
                 jsr chrgot                                ;; @@3ddb 73
                 jsr goto                                 ; set up to execute from new line number ;; @@3dde 73
                 jsr setexc                               ; ..and do a little housekeeping, ;; @@3de1 73
                 +lbra newstt                             ; ..otherwise it's business as usual ;; @@3de4 73
 ;; @@3de7 73
;.end ;; @@3de7 73
; .page ;; @@3de7 73
; .subttl  RESTORE ;; @@3de7 73
;********************************************************************* ;; @@3de7 73
;* ;; @@3de7 73
;* RESTORE Command ;; @@3de7 73
;* ;; @@3de7 73
;* Reset pointers to next DATA statement.  Allows optional argument ;; @@3de7 73
;* specifying a specific line number, otherwise the default is the ;; @@3de7 73
;* beginning of text area. ;; @@3de7 73
;* ;; @@3de7 73
;********************************************************************* ;; @@3de7 73
 ;; @@3de7 73
restor                                                     ;; @@3de7 73
                 beq restore__1                           ; branch if no argument...use default ;; @@3de7 73
                 jsr getwrd                               ; get 2 byte argument (???? no check for real number means a var legal) ;; @@3de9 73
                 sty linnum                                ;; @@3dec 73
                 sta linnum+1                              ;; @@3dee 73
                 jsr FindLine                             ; get pointer to specified line ;; @@3df0 73
                 +lbcc userr                              ; error if not found ;; @@3df3 73
 ;; @@3df6 73
                 lda lowtr                                ; decrement 2 byte pointer, and save it ;; @@3df6 73
                 ldy lowtr+1                               ;; @@3df8 73
                 bra restore__2                           ; always ;; @@3dfa 73
 ;; @@3dfc 73
 ;; @@3dfc 73
restore__1                                                ; entry from FLOAD ;; @@3dfc 73
                 sec                                       ;; @@3dfc 73
                 lda txttab                                ;; @@3dfd 73
                 ldy txttab+1                              ;; @@3dff 73
 ;; @@3e01 73
restore__2                                                 ;; @@3e01 73
                 sbc #1                                    ;; @@3e01 73
                 bcs _local_1072_1                         ;; @@3e03 73
                 dey                                       ;; @@3e05 73
_local_1072_1    sta datptr                                ;; @@3e06 73
                 sty datptr+1                              ;; @@3e08 73
                 rts                                       ;; @@3e0a 73
 ;; @@3e0b 73
;.end ;; @@3e0b 73
; .page ;; @@3e0b 73
; .subttl  RENUMBER ;; @@3e0b 73
;*********************************************************************** ;; @@3e0b 73
; ;; @@3e0b 73
; RENUMBER Command ;; @@3e0b 73
; ;; @@3e0b 73
; Syntax:  RENUMBER [n1 [,[n2] ,n3]] ;; @@3e0b 73
; ;; @@3e0b 73
;  n1 = new start line number, default 10 ;; @@3e0b 73
;  n2 = line increment, default 10 ;; @@3e0b 73
;  n3 = start line, default first ;; @@3e0b 73
; ;; @@3e0b 73
; - Syntax error may occur for missing commas or bad line numbers. ;; @@3e0b 73
; - Illegal quantity error for line increment of 0 or for bad range. ;; @@3e0b 73
; - Overflow error if increment wraps line number during renumber, ;; @@3e0b 73
;  line number too large error if renumbering would force line ;; @@3e0b 73
;  numbers greater than 63999. ;; @@3e0b 73
; - Out of memory error if the renumbered program would be too large. ;; @@3e0b 73
; - Unresolved reference error if an imbedded line number references ;; @@3e0b 73
;  a line which does not exist. ;; @@3e0b 73
; ;; @@3e0b 73
; Otherwise returns to "ready" mode upon completion. ;; @@3e0b 73
; ;; @@3e0b 73
;*********************************************************************** ;; @@3e0b 73
 ;; @@3e0b 73
 ;; @@3e0b 73
; Before any data is changed in any way, two preliminary passes are ;; @@3e0b 73
; made to insure no errors would occur during the actual renumbering ;; @@3e0b 73
; process (as detailed below). ;; @@3e0b 73
; ;; @@3e0b 73
; Pass 1 makes sure that the renumbered program would have no line ;; @@3e0b 73
; numbers greater than 63999 (nothing is actually renumbered; the ;; @@3e0b 73
; statement table is not modified). ;; @@3e0b 73
; ;; @@3e0b 73
; Pass 2 checks if the renumbered program would be too long and also ;; @@3e0b 73
; checks for non-existant line number destinations. ;; @@3e0b 73
; ;; @@3e0b 73
; Pass 3 examines the entire statement table first for imbedded line ;; @@3e0b 73
; numbers (branches) to fix. This is done by looking for keywords (GOTO, ;; @@3e0b 73
; GOSUB, THEN, RUN) which are usually followed by line numbers. The old ;; @@3e0b 73
; line number is mapped to a new value and the string representing the ;; @@3e0b 73
; new branch label replaces the original text. ;; @@3e0b 73
; ;; @@3e0b 73
; Pass 4 then replaces the statement number bytes by their final values. ;; @@3e0b 73
; and the table is relinked. ;; @@3e0b 73
 ;; @@3e0b 73
 ;; @@3e0b 73
testwd                                                     ;; @@3e0b 74
                 !text goto_token,run_token,gosub_token,then_token  ;; @@3e0b 74
                 !text restore_token,resume_token,trap_token,else_token  ;; @@3e0f 74
 ;; @@3e13 74
renumber                                                   ;; @@3e13 74
                 jsr errind                               ; allowed only in direct mode ;; @@3e13 74
 ;; @@3e16 74
; Set up default values for n1, n2, and n3 ;; @@3e16 74
 ;; @@3e16 74
                 lda #0                                   ; line #10... ;; @@3e16 74
                 ldx #10                                   ;; @@3e18 74
                 stx renum_tmp_1                          ; default renum origin (n1) ;; @@3e1a 74
                 sta renum_tmp_1+1                         ;; @@3e1d 74
                 stx renum_tmp_2                          ; default increment (n2) ;; @@3e20 74
                 sta renum_tmp_2+1                         ;; @@3e23 74
                 sta hightr                               ; default start line # (n3) ;; @@3e26 74
                 sta hightr+1                              ;; @@3e28 74
 ;; @@3e2a 74
                 jsr chrgot                               ; any parameters? ;; @@3e2a 74
                 beq ren_pass_1                           ; no... ;; @@3e2d 74
 ;; @@3e2f 74
 ;; @@3e2f 74
; Check for new starting line number (n1) ;; @@3e2f 74
 ;; @@3e2f 74
                 jsr linget                               ; check for a number ;; @@3e2f 74
                 lda endchr                               ; was there one? ;; @@3e32 74
                 beq renum_10                             ; no...use default ;; @@3e34 74
                 lda linnum                                ;; @@3e36 74
                 ldx linnum+1                              ;; @@3e38 74
                 sta renum_tmp_1                           ;; @@3e3a 74
                 stx renum_tmp_1+1                         ;; @@3e3d 74
 ;; @@3e40 74
; Check for new increment ;; @@3e40 74
 ;; @@3e40 74
renum_10                                                   ;; @@3e40 74
                 jsr optwrd                               ; an increment given? ;; @@3e40 74
                 bcc renum_30                             ; no...use default ;; @@3e43 74
 ;; @@3e45 74
                 sty renum_tmp_2                           ;; @@3e45 74
                 sta renum_tmp_2+1                         ;; @@3e48 74
                 ora renum_tmp_2                          ; increment must be >0 ;; @@3e4b 74
                 +lbeq fcerr                              ; illegal quantity error ;; @@3e4e 74
 ;; @@3e51 74
; Check for starting line number ;; @@3e51 74
 ;; @@3e51 74
renum_30                                                   ;; @@3e51 74
                 jsr optwrd                               ; starting line number given? ;; @@3e51 74
                 bcc ren_pass_1                           ; no... ;; @@3e54 74
 ;; @@3e56 74
                 sty hightr                                ;; @@3e56 74
                 sty linnum                                ;; @@3e58 74
                 sta hightr+1                              ;; @@3e5a 74
                 sta linnum+1                              ;; @@3e5c 74
                 jsr FindLine                             ; test for illegal renumber range ;; @@3e5e 74
                 lda lowtr                                ; (n1 must be >= n3) ;; @@3e61 74
                 ldx lowtr+1                               ;; @@3e63 74
                 sta highds                               ; pointer to first statement to renumber ;; @@3e65 74
                 stx highds+1                              ;; @@3e67 74
                 lda renum_tmp_1                           ;; @@3e69 74
                 ldx renum_tmp_1+1                         ;; @@3e6c 74
                 sta linnum                                ;; @@3e6f 74
                 stx linnum+1                              ;; @@3e71 74
                 jsr FindLine                             ; lowtr = ptr to 1st stmt to be overlapped ;; @@3e73 74
                 sec                                       ;; @@3e76 74
                 lda lowtr                                ; can't be smaller ;; @@3e77 74
                 sbc highds                                ;; @@3e79 74
                 lda lowtr+1                               ;; @@3e7b 74
                 sbc highds+1                              ;; @@3e7d 74
                 +lbcc fcerr                              ; bad... ;; @@3e7f 74
 ;; @@3e82 74
; .page ;; @@3e82 74
;*********************************************************************** ;; @@3e82 74
;**************  R E N U M B E R    P A S S    O N E  ****************** ;; @@3e82 74
;*********************************************************************** ;; @@3e82 74
 ;; @@3e82 74
; Pass 1 makes sure that the renumbered program will not have any line numbers ;; @@3e82 74
; greater than 63999 (however, nothing is actually renumbered in this pass). ;; @@3e82 74
 ;; @@3e82 74
ren_pass_1                                                 ;; @@3e82 74
                 jsr tto                                  ; save txtptr for restoration when done ;; @@3e82 74
                 jsr n1_reset                             ; put n1 in FAC, reset txtptr ;; @@3e85 74
                 jsr chargt                               ; skip low link ;; @@3e88 74
                 iny                                      ; (.y=1) ;; @@3e8b 74
                 jsr indtxt                               ; skip high link ;; @@3e8c 74
                 beq ren_pass_2                           ; end of program => begin pass 2 (assumes txttab > 0) ;; @@3e8f 74
 ;; @@3e91 74
r_pass1_10                                                 ;; @@3e91 74
                 iny                                      ; (.y=2) ;; @@3e91 74
                 jsr indtxt                               ; line number low ;; @@3e92 74
                 sec                                       ;; @@3e95 74
                 sbc hightr                               ; in line range which is to be renumbered? ;; @@3e96 74
                 iny                                      ; (.y=3) ;; @@3e98 74
                 jsr indtxt                               ; line number high ;; @@3e99 74
                 sbc hightr+1                              ;; @@3e9c 74
                 bcs r_pass1_20                           ; yes => fake renumbering ;; @@3e9e 74
                 jsr set_next                             ; goto next line ;; @@3ea0 74
                 bne r_pass1_10                           ; if z=0 then not end-of-text => keep going ;; @@3ea3 74
                 beq ren_pass_2                           ; else end ;; @@3ea5 74
 ;; @@3ea7 74
r_pass1_20                                                 ;; @@3ea7 74
                 jsr set_next                             ; goto next line ;; @@3ea7 74
                 beq ren_pass_2                           ; if z=1 then end-of-text => exit ;; @@3eaa 74
                 jsr new_num                              ; create next line number ;; @@3eac 74
                 bcs r_pass1_30                           ; if c=1 then it wrapped => error ;; @@3eaf 74
                 cmp #>63999                              ; can't have lines > 63999 ;; @@3eb1 74
                 bcc r_pass1_20                           ; if c=0 then ok ;; @@3eb3 74
 ;; @@3eb5 74
r_pass1_30                                                ; renumbering will generate an illegal line # ;; @@3eb5 74
                 ldx #err_too_large                       ; 'line number too large' error ;; @@3eb5 74
                 +lbra error                               ;; @@3eb7 74
 ;; @@3eba 74
set_next                                                   ;; @@3eba 74
                 ldy #0                                   ; set for next BASIC line ;; @@3eba 74
                 jsr indtxt                               ; low link ;; @@3ebc 74
                 tax                                       ;; @@3ebf 74
                 iny                                      ; (.y=1) ;; @@3ec0 74
                 jsr indtxt                               ; high link ;; @@3ec1 74
                 beq set_end                              ; if z=1 then end of program => exit ;; @@3ec4 74
                 stx txtptr                                ;; @@3ec6 74
                 sta txtptr+1                              ;; @@3ec8 74
set_end          rts                                       ;; @@3eca 74
 ;; @@3ecb 74
; .page ;; @@3ecb 74
;*********************************************************************** ;; @@3ecb 74
;**************  R E N U M B E R    P A S S    T W O  ****************** ;; @@3ecb 74
;*********************************************************************** ;; @@3ecb 74
 ;; @@3ecb 74
; Pass 2 checks if the renumbered program will be too long and also ;; @@3ecb 74
; checks for non-existant line number destinations. ;; @@3ecb 74
 ;; @@3ecb 74
ren_pass_2                                                 ;; @@3ecb 74
                 bbr4 runmod,_local_1073_10               ; skip pass two and three if plain text (edit mode) [910620] ;; @@3ecb 74
                 jsr n1_reset                             ; yes- just setup up starting line # and reset txtptr ;; @@3ece 74
                 bra ren_pass_4                           ; then renumber just the text's line numbers ;; @@3ed1 74
 ;; @@3ed3 74
_local_1073_10   lda #$01                                 ; set flag for 'pass 2' ;; @@3ed3 74
                 sta z_p_temp_1                            ;; @@3ed5 74
                 lda text_top                             ; copy top-of-text pointer for later use ;; @@3ed7 74
                 ldx text_top+1                           ; (we don't want to change original here) ;; @@3ed9 74
                 sta fndpnt                                ;; @@3edb 74
                 stx fndpnt+1                              ;; @@3edd 74
                 jsr imbed_lines                          ; search for imbedded lines (but don't change) ;; @@3edf 74
 ;; @@3ee2 74
 ;; @@3ee2 74
 ;; @@3ee2 74
;*********************************************************************** ;; @@3ee2 74
;************  R E N U M B E R    P A S S    T H R E E  **************** ;; @@3ee2 74
;*********************************************************************** ;; @@3ee2 74
 ;; @@3ee2 74
; Pass 3 actually renumbers the imbedded destination line numbers ;; @@3ee2 74
; which follow goto, gosub, trap, etc. ;; @@3ee2 74
 ;; @@3ee2 74
ren_pass_3                                                 ;; @@3ee2 75
                 dec z_p_temp_1                           ; z_p_temp_1 = 0 (for pass 3) ;; @@3ee2 75
                 jsr imbed_lines                          ; search for and update imbedded line #'s ;; @@3ee4 75
 ;; @@3ee7 75
; .page ;; @@3ee7 75
;*********************************************************************** ;; @@3ee7 75
;*************  R E N U M B E R    P A S S    F O U R  ***************** ;; @@3ee7 75
;*********************************************************************** ;; @@3ee7 75
 ;; @@3ee7 75
; Pass 4 actually renumbers the program line numbers & exits ;; @@3ee7 75
 ;; @@3ee7 75
ren_pass_4                                                 ;; @@3ee7 75
                 jsr chargt_x2                            ; skip link ;; @@3ee7 75
                 beq renumber_exit                        ; null link=> end-of-text, exit (assumes txttab > 0) ;; @@3eea 75
                 jsr chargt                               ; not null... ;; @@3eec 75
                 sta linnum                               ; if line# >= start#, replace with facho ;; @@3eef 75
                 iny                                       ;; @@3ef1 75
                 jsr indtxt                                ;; @@3ef2 75
                 sec                                       ;; @@3ef5 75
                 sbc hightr+1                              ;; @@3ef6 75
                 bcc r_pass4_20                           ; no, let alone ;; @@3ef8 75
                 bne r_pass4_10                           ; yes, replace ;; @@3efa 75
                 lda linnum                                ;; @@3efc 75
                 sbc hightr                                ;; @@3efe 75
                 bcc r_pass4_20                           ; no, let alone ;; @@3f00 75
 ;; @@3f02 75
r_pass4_10                                                 ;; @@3f02 75
                 lda facho                                 ;; @@3f02 75
; phx ;; @@3f04 75
                 jsr sta_far_txt                          ; sta (txtptr),y  hi  (bleed-thru) ;; @@3f04 75
                 dey                                       ;; @@3f07 75
                 lda facho+1                               ;; @@3f08 75
                 jsr sta_far_txt                          ; sta (txtptr),y  lo (bleed-thru) ;; @@3f0a 75
; plx ;; @@3f0d 75
                 jsr chargt                               ; skip past 2nd byte of line# ;; @@3f0d 75
                 jsr line_inc                             ; incr line# and scan to eol ;; @@3f10 75
                 bra ren_pass_4                           ; always... ;; @@3f13 75
 ;; @@3f15 75
r_pass4_20                                                 ;; @@3f15 75
                 jsr chargt                               ; skip past line# ;; @@3f15 75
                 jsr scan_thru                            ; scan to eol ;; @@3f18 75
                 bra ren_pass_4                           ; always... ;; @@3f1b 75
 ;; @@3f1d 75
 ;; @@3f1d 75
renumber_exit                                              ;; @@3f1d 75
                 jsr fix_links                            ; patch things up: relink & set eot ;; @@3f1d 75
 ;; @@3f20 75
direct_mode_exit                                           ;; @@3f20 75
                 jsr ott                                  ; restore txtptr for next command in buffer ;; @@3f20 75
                 lda #0                                   ; but disallow continuing ;; @@3f23 75
                 sta oldtxt+1                              ;; @@3f25 75
                 rts                                       ;; @@3f28 75
 ;; @@3f29 75
; .page ;; @@3f29 75
;*********************************************************************** ;; @@3f29 75
;*************  R E N U M B E R   S U B R O U T I N E S  *************** ;; @@3f29 75
;*********************************************************************** ;; @@3f29 75
 ;; @@3f29 75
; Look for imbedded line #'s (after GOTO, GOSUB, etc.) ;; @@3f29 75
; but only change them in pass 3 (ie. z_p_temp_1 = 0) ;; @@3f29 75
 ;; @@3f29 75
imbed_lines                                                ;; @@3f29 75
                 jsr reset_txtptr                         ; start at first line: load (txtptr) with (txttab)-1 ;; @@3f29 75
 ;; @@3f2c 75
next_line                                                  ;; @@3f2c 75
                 jsr chargt_x2                            ; skip link (assumes txttab > 0) ;; @@3f2c 75
                 +lbeq n1_reset                           ; null link: put current line # in fac, reset txtptr, exit ;; @@3f2f 75
                 jsr chargt                               ; line number ;; @@3f32 75
                 sta forpnt                               ; save in case there is an error ;; @@3f35 75
                 jsr chargt                                ;; @@3f37 75
                 sta forpnt+1                              ;; @@3f3a 75
 ;; @@3f3c 75
next_char                                                  ;; @@3f3c 75
                 jsr chargt                               ; first character in the line ;; @@3f3c 75
 ;; @@3f3f 75
chk_quote                                                  ;; @@3f3f 75
                 cmp #'"'                                 ; opening double quote? ;; @@3f3f 75
                 bne not_quote                            ; no... ;; @@3f41 75
_local_1074_20   jsr chargt                               ; scan line ;; @@3f43 75
                 beq next_line                            ; end... ;; @@3f46 75
                 cmp #'"'                                 ; close double quote ;; @@3f48 75
                 bne _local_1074_20                       ; no... continue ;; @@3f4a 75
                 bra next_char                            ; yes... resume renumber ;; @@3f4c 75
 ;; @@3f4e 75
not_quote                                                  ;; @@3f4e 76
                 tax                                      ; end of line? ;; @@3f4e 76
                 beq next_line                            ; yes... ;; @@3f4f 76
                 bpl next_char                            ; not a token... ;; @@3f51 76
 ;; @@3f53 76
                 ldx #8                                   ; check special token list ;; @@3f53 76
_local_1075_30   cmp testwd-1,x                            ;; @@3f55 76
                 beq iline_10                             ; a match... ;; @@3f58 76
                 dex                                       ;; @@3f5a 76
                 bne _local_1075_30                       ; continue until zero ;; @@3f5b 76
 ;; @@3f5d 76
                 cmp #go_token                            ; wasn't in the token list. check for 'go to' ;; @@3f5d 76
                 bne chk_escape                           ; not 'go', go check for 'collision' *c128 fix* ;; @@3f5f 76
hop_1            jsr chrget                               ; got a 'go', look for 'to' ;; @@3f61 77
                 beq next_line                            ; end of line, abort ;; @@3f64 77
                 cmp #to_token                             ;; @@3f66 77
                 beq iline_10                             ; got it! go to fix number routine ;; @@3f68 77
                 bra next_char                            ; no 'to', keep looking ;; @@3f6a 77
 ;; @@3f6c 77
; Look for 'COLLISION'.  This is an escape command. *c128 fix* ????????? ;; @@3f6c 77
 ;; @@3f6c 77
chk_escape                                                 ;; @@3f6c 77
                 cmp #esc_command_token                    ;; @@3f6c 77
                 bne next_char                             ;; @@3f6e 77
                 jsr chrget                                ;; @@3f70 77
                 beq hop_1                                ; end of line ,abort ;; @@3f73 77
                 cmp #collision_token                      ;; @@3f75 77
                 bne next_char                             ;; @@3f77 77
_local_1076_40   jsr chrget                               ; got it! skip over first argument ;; @@3f79 77
                 beq hop_1                                ; end of line, abort ;; @@3f7c 77
                 cmp #','                                  ;; @@3f7e 77
                 bne _local_1076_40                       ; not there yet ;; @@3f80 77
 ;; @@3f82 77
 ;; @@3f82 77
iline_10                                                   ;; @@3f82 78
                 lda txtptr                               ; save current txtptr ;; @@3f82 78
                 sta oldlin                                ;; @@3f84 78
                 lda txtptr+1                              ;; @@3f87 78
                 sta oldlin+1                              ;; @@3f89 78
                 jsr chrget                                ;; @@3f8c 78
                 bcs chk_quote                            ; not a #... ;; @@3f8f 78
                 jsr linget                               ; get line # from text ;; @@3f91 78
                 jsr form_line                            ; replace if this line # > n3 ;; @@3f94 78
                 lda oldlin                               ; restore old txtptr ;; @@3f97 78
                 sta txtptr                                ;; @@3f9a 78
                 lda oldlin+1                              ;; @@3f9c 78
                 sta txtptr+1                              ;; @@3f9f 78
 ;; @@3fa1 78
                 jsr chrget                               ; skip over leading spaces ;; @@3fa1 78
                 dew txtptr                               ; then backup (txtptr) by 1 ;; @@3fa4 78
                 ldx #$ff                                  ;; @@3fa6 78
                 lda z_p_temp_1                           ; if this is pass2 then don't actually change ;; @@3fa8 78
                 beq p3code                               ; if z=1 then pass3 => ok to change ;; @@3faa 78
                 jsr p2code                               ; renumber 'pass two': trial run to see if enough room ;; @@3fac 78
                 jsr chrgot                               ; re-get last character from BASIC text & rts ;; @@3faf 78
 ;; @@3fb2 78
iline_20                                                   ;; @@3fb2 78
                 cmp #','                                 ; comma from 'on'? ;; @@3fb2 78
                 beq iline_10                             ; it is... ;; @@3fb4 78
                 bra chk_quote                            ; no... ;; @@3fb6 78
 ;; @@3fb8 78
; .page ;; @@3fb8 78
;*********** This part of imbed_lines executed in pass 2 only ********** ;; @@3fb8 78
 ;; @@3fb8 78
p2code                                                    ; updates text_top without actually changing lines ;; @@3fb8 78
                 inx                                       ;; @@3fb8 78
                 lda fbuffr+1,x                           ; get character from number ;; @@3fb9 78
                 beq _local_1077_20                       ; end of number ;; @@3fbc 78
                 jsr chrget                               ; get digit from old number ;; @@3fbe 78
                 bcc p2code                               ; digit...move on ;; @@3fc1 78
 ;; @@3fc3 78
_local_1077_10   inw fndpnt                                ;; @@3fc3 78
                 sec                                      ; have we run out of memory (theoretically)? ;; @@3fc5 78
                 lda fndpnt                               ; (compare with limit-of-memory pointer) ;; @@3fc6 78
                 sbc max_mem_0                             ;; @@3fc8 78
                 lda fndpnt+1                              ;; @@3fcb 78
                 sbc max_mem_0+1                           ;; @@3fcd 78
                 +lbcs omerr                              ; yes- out of memory error ;; @@3fd0 78
                 inx                                      ; no - next... ;; @@3fd3 78
                 lda fbuffr+1,x                            ;; @@3fd4 78
                 bne _local_1077_10                        ;; @@3fd7 78
_local_1077_15   rts                                      ; no more ;; @@3fd9 78
 ;; @@3fda 78
_local_1077_20   jsr chrget                                ;; @@3fda 78
                 bcs _local_1077_15                       ; old stuff after # is other char ;; @@3fdd 78
                 dew fndpnt                               ; digit...move down ;; @@3fdf 78
                 bra _local_1077_20                       ; still digits... ;; @@3fe1 78
 ;; @@3fe3 78
; .page ;; @@3fe3 78
;*********** This part of imbed_lines executed in pass 3 only ********** ;; @@3fe3 78
 ;; @@3fe3 78
p3code                                                     ;; @@3fe3 79
                 inx                                       ;; @@3fe3 79
                 lda fbuffr+1,x                           ; get character from number ;; @@3fe4 79
                 beq _local_1078_30                       ; end of number ;; @@3fe7 79
 ;; @@3fe9 79
                 pha                                      ; save digit from new number ;; @@3fe9 79
                 jsr chargt                               ; get digit from old number ;; @@3fea 79
                 cmp #':'                                 ; command terminator or letter? ;; @@3fed 79
                 bcs _local_1078_10                        ;; @@3fef 79
                 cmp #' '                                 ; space? (fix for goto10 :rem) ;; @@3ff1 79
                 beq _local_1078_10                        ;; @@3ff3 79
                 sec                                       ;; @@3ff5 79
                 sbc #'0'                                 ; number? ;; @@3ff6 79
                 sec                                       ;; @@3ff8 79
                 sbc #$d0                                  ;; @@3ff9 79
                 bcc _local_1078_20                       ; digit...move on ;; @@3ffb 79
 ;; @@3ffd 79
_local_1078_10   jsr move_init                            ; other char...move up ;; @@3ffd 79
                 jsr moveup                                ;; @@4000 79
                 inw text_top                              ;; @@4003 79
 ;; @@4005 79
_local_1078_20   pla                                       ;; @@4005 79
                 phx                                       ;; @@4006 79
                 ldy #0                                    ;; @@4007 79
                 jsr sta_far_txt                          ; put new digit in new number (bleed-thru) ;; @@4009 79
                 plx                                       ;; @@400c 79
                 bra p3code                                ;; @@400d 79
 ;; @@400f 79
 ;; @@400f 79
_local_1078_30   jsr chrget                                ;; @@400f 79
                 bcs iline_20                             ; old stuff after # is other char ;; @@4012 79
 ;; @@4014 79
_local_1078_40   jsr move_init                            ; digit...move down ;; @@4014 79
                 jsr movedown                              ;; @@4017 79
                 dew text_top                              ;; @@401a 79
                 jsr chrgot                                ;; @@401c 79
                 bcc _local_1078_40                       ; still digits... ;; @@401f 79
 ;; @@4021 79
                 bra iline_20                             ; branch always ;; @@4021 79
 ;; @@4023 79
; .page ;; @@4023 79
;*************************** FORM_LINE ********************************* ;; @@4023 79
 ;; @@4023 79
; Remaps the destination line if it is greater than n3 ;; @@4023 79
 ;; @@4023 79
form_line                                                  ;; @@4023 80
                 jsr n1_reset                              ;; @@4023 80
find_it                                                    ;; @@4026 80
                 jsr chargt_x2                            ; new line, skip over link ;; @@4026 80
                 bne _local_1079_70                       ; if we get to end-of-text without finding the ;; @@4029 80
                 ldx #err_ref                             ; line # then 'unresolved reference' error ;; @@402b 80
                 lda forpnt                                ;; @@402d 80
                 sta curlin                               ; fake error routine into saying 'in line xxxxx' ;; @@402f 80
                 lda forpnt+1                              ;; @@4031 80
                 sta curlin+1                              ;; @@4033 80
                 +lbra error                               ;; @@4035 80
 ;; @@4038 80
_local_1079_70   jsr chargt                               ; get line number low ;; @@4038 80
                 sta highds                               ; highds = current line# in loop ;; @@403b 80
                 cmp linnum                                ;; @@403d 80
                 bne _local_1079_100                       ;; @@403f 80
                 jsr chargt                               ; get line number high ;; @@4041 80
                 sta highds+1                              ;; @@4044 80
                 cmp linnum+1                              ;; @@4046 80
                 bne _local_1079_110                       ;; @@4048 80
                 sec                                      ; if linnum < start#, no remapping ;; @@404a 80
                 sbc hightr+1                              ;; @@404b 80
                 bcc _local_1079_80                        ;; @@404d 80
                 bne _local_1079_90                        ;; @@404f 80
                 lda linnum                                ;; @@4051 80
                 sbc hightr                                ;; @@4053 80
                 bcs _local_1079_90                        ;; @@4055 80
 ;; @@4057 80
_local_1079_80   lda linnum                               ; use same line# ;; @@4057 80
                 sta facho+1                               ;; @@4059 80
                 lda linnum+1                              ;; @@405b 80
                 sta facho                                 ;; @@405d 80
 ;; @@405f 80
_local_1079_90   ldx #$90                                 ; make replacement string ;; @@405f 80
                 sec                                       ;; @@4061 80
                 jsr floatc                                ;; @@4062 80
                 +lbra fout                                ;; @@4065 80
 ;; @@4068 80
 ;; @@4068 80
_local_1079_100  jsr chargt                                ;; @@4068 80
                 sta highds+1                             ; (** 01/27/84 fix) ;; @@406b 80
 ;; @@406d 80
_local_1079_110  jsr line_add                             ; scan to end of line ;; @@406d 80
                 bra find_it                              ; always ;; @@4070 80
 ;; @@4072 80
; .page ;; @@4072 80
;*************************** N1_RESET ********************************** ;; @@4072 80
 ;; @@4072 80
; Copies n1 (new renumber origin) into facho & sets (txtptr) = (txttab)-1 ;; @@4072 80
 ;; @@4072 80
n1_reset                                                   ;; @@4072 81
                 lda renum_tmp_1                           ;; @@4072 81
                 sta facho+1                               ;; @@4075 81
                 lda renum_tmp_1+1                         ;; @@4077 81
                 sta facho                                 ;; @@407a 81
                 +lbra reset_txtptr                        ;; @@407c 81
 ;; @@407f 81
 ;; @@407f 81
;*************************** LINE_ADD ********************************** ;; @@407f 81
 ;; @@407f 81
; Adds n2 (new line increment) to line number stored in facho if the ;; @@407f 81
; current line number (highds) >= n3 (line to start renumbering with). ;; @@407f 81
; The line is then scanned. ;; @@407f 81
 ;; @@407f 81
line_add                                                   ;; @@407f 81
                 lda highds                               ; if line# >= start# then incr new# ;; @@407f 81
                 sec                                       ;; @@4081 81
                 sbc hightr                                ;; @@4082 81
                 lda highds+1                              ;; @@4084 81
                 sbc hightr+1                              ;; @@4086 81
                 bcc scan_thru                             ;; @@4088 81
 ;; @@408a 81
line_inc                                                   ;; @@408a 81
                 jsr new_num                               ;; @@408a 81
 ;; @@408d 81
scan_thru                                                  ;; @@408d 81
                 jsr chargt                               ; scan to end of line ;; @@408d 81
                 bne scan_thru                             ;; @@4090 81
                 rts                                       ;; @@4092 81
 ;; @@4093 81
 ;; @@4093 81
;**************************** NEW_NUM ********************************** ;; @@4093 81
 ;; @@4093 81
; Adds n2 (the new line increment) to the line number stored in facho. ;; @@4093 81
 ;; @@4093 81
new_num                                                    ;; @@4093 81
                 lda facho+1                              ; increment new line# ;; @@4093 81
                 clc                                       ;; @@4095 81
                 adc renum_tmp_2                           ;; @@4096 81
                 sta facho+1                               ;; @@4099 81
                 lda facho                                 ;; @@409b 81
                 adc renum_tmp_2+1                         ;; @@409d 81
                 sta facho                                 ;; @@40a0 81
                 rts                                       ;; @@40a2 81
 ;; @@40a3 81
 ;; @@40a3 81
;********************** CHARGT & CHARGT_X2 ***************************** ;; @@40a3 81
 ;; @@40a3 81
; Chargt simulates chrget but doesn't ignore spaces & carry has no ;; @@40a3 81
; significance.  Chargt_x2 executes chargt twice. ;; @@40a3 81
; Used by Renumber, Find/Change, etc. ;; @@40a3 81
 ;; @@40a3 81
chargt_x2                                                  ;; @@40a3 81
                 inw txtptr                               ; jsr chargt ;; @@40a3 81
chargt                                                     ;; @@40a5 81
                 ldy #0                                   ; increment txtptr ;; @@40a5 81
                 inw txtptr                                ;; @@40a7 81
                 +lbra indtxt                              ;; @@40a9 81
 ;; @@40ac 81
; .page ;; @@40ac 81
;*********************************************************************** ;; @@40ac 81
;************************* MEMORY MOVE ROUTINES ************************ ;; @@40ac 81
;*********************************************************************** ;; @@40ac 81
 ;; @@40ac 81
;****************************** MOVEINIT ******************************* ;; @@40ac 81
 ;; @@40ac 81
; Setup for Renumber memory move. ;; @@40ac 81
 ;; @@40ac 81
move_init                                                  ;; @@40ac 81
                 lda txtptr                               ; index1 = txtptr ;; @@40ac 81
                 sta index1                                ;; @@40ae 81
                 lda txtptr+1                              ;; @@40b0 81
                 sta index1+1                              ;; @@40b2 81
 ;; @@40b4 81
                 lda text_top                             ; index2 = text_top ;; @@40b4 81
                 sta index2                                ;; @@40b6 81
                 lda text_top+1                            ;; @@40b8 81
                 sta index2+1                              ;; @@40ba 81
 ;; @@40bc 81
                 lda #1                                   ; move 1 character ;; @@40bc 81
                 sta count                                ; lo ;; @@40be 81
                 dec                                       ;; @@40c0 81
                 sta argmo                                ; hi ;; @@40c1 81
 ;; @@40c3 81
                 rts                                       ;; @@40c3 81
 ;; @@40c4 81
; .page ;; @@40c4 81
;****************************** MOVEDOWN ******************************* ;; @@40c4 81
 ;; @@40c4 81
; Move block of BASIC text from INDEX1+COUNT to INDEX2 down to INDEX1. ;; @@40c4 81
; Used by commands Renumber, Find/Change. ;; @@40c4 81
 ;; @@40c4 81
movedown                                                   ;; @@40c4 81
                 sec                                      ; set up DMA list:   [900524] ;; @@40c4 81
                 lda index2                                ;; @@40c5 81
                 sbc index1                                ;; @@40c7 81
                 sta dma1_cnt_lo                          ; cnt = index2-index1-count ;; @@40c9 81
                 lda index2+1                              ;; @@40cc 81
                 sbc index1+1                              ;; @@40ce 81
                 sta dma1_cnt_hi                           ;; @@40d0 81
                 sec                                       ;; @@40d3 81
                 lda dma1_cnt_lo                           ;; @@40d4 81
                 sbc count                                ; lo ;; @@40d7 81
                 sta dma1_cnt_lo                           ;; @@40d9 81
                 lda dma1_cnt_hi                           ;; @@40dc 81
                 sbc argmo                                ; hi ;; @@40df 81
                 sta dma1_cnt_hi                           ;; @@40e1 81
 ;; @@40e4 81
                 clc                                       ;; @@40e4 81
                 lda index1                                ;; @@40e5 81
                 sta dma1_dest_lo                         ; dest = index1 ;; @@40e7 81
                 adc count                                 ;; @@40ea 81
                 sta dma1_src_lo                          ; src = index1+count ;; @@40ec 81
                 lda index1+1                              ;; @@40ef 81
                 sta dma1_dest_hi                          ;; @@40f1 81
                 adc argmo                                 ;; @@40f4 81
                 sta dma1_src_hi                           ;; @@40f6 81
 ;; @@40f9 81
                 lda text_bank                            ; bank = BASIC text bank ;; @@40f9 81
; and #%00001111  ;      [910520] F018A ;; @@40fb 81
                 sta dma1_src_bank                         ;; @@40fb 81
                 sta dma1_dest_bank                        ;; @@40fe 81
 ;; @@4101 81
execute_DMA1                                              ; [910620] Edit ;; @@4101 81
                 lda #0                                    ;; @@4101 81
                 sta dma1_cmd                             ; command = copy from startpoint ;; @@4103 81
                 sta dma1_subcmd                          ; [910520] F018A ;; @@4106 81
 ;; @@4109 81
                 sta dma_ctlr+2                           ; dma_list bank ;; @@4109 81
                 lda #>dma1_cmd                            ;; @@410c 81
                 sta dma_ctlr+1                           ; dma_list hi ;; @@410e 81
                 lda #<dma1_cmd                            ;; @@4111 81
                 sta dma_ctlr                             ; dma_list lo & trigger ;; @@4113 81
                 rts                                       ;; @@4116 81
 ;; @@4117 81
; .page ;; @@4117 81
;******************************* MOVEUP ******************************** ;; @@4117 81
 ;; @@4117 81
; Move block of BASIC text from INDEX1 to INDEX2 up to INDEX2+COUNT. ;; @@4117 81
; Used by commands Renumber, Find/Change. ;; @@4117 81
 ;; @@4117 81
moveup                                                     ;; @@4117 81
                 sec                                      ; set up DMA list:   [900524] ;; @@4117 81
                 lda index2                                ;; @@4118 81
                 sbc index1                                ;; @@411a 81
                 sta dma1_cnt_lo                          ; cnt = index2-index1 ;; @@411c 81
                 lda index2+1                              ;; @@411f 81
                 sbc index1+1                              ;; @@4121 81
                 sta dma1_cnt_hi                           ;; @@4123 81
 ;; @@4126 81
                 dew index2                               ; (index2 = text_top = end+1) ;; @@4126 81
                 clc                                       ;; @@4128 81
                 lda index2                                ;; @@4129 81
                 sta dma1_src_lo                          ; src = index2 ;; @@412b 81
                 adc count                                 ;; @@412e 81
                 sta dma1_dest_lo                         ; dest = index2+count ;; @@4130 81
                 lda index2+1                              ;; @@4133 81
                 sta dma1_src_hi                           ;; @@4135 81
                 adc argmo                                 ;; @@4138 81
                 sta dma1_dest_hi                          ;; @@413a 81
 ;; @@413d 81
; lda dma_ctlr+3  ;dma controller version    [910520] F018A ;; @@413d 81
; and #1 ;; @@413d 81
; beq _local_1080_10   ; F018    removed [910808] F018B ;; @@413d 81
                 lda #%00110000                           ; F018A,B ;; @@413d 81
_local_1080_10   sta dma1_cmd                             ; command=copy, source=start   [910102] ;; @@413f 81
; php ;; @@4142 81
                 lda text_bank                            ; bank = BASIC text bank   [910520] F018A ;; @@4142 81
; plp   ;version?    removed [910808] F018B ;; @@4144 81
; bne _local_1080_20   ; F018A ;; @@4144 81
; and #%00001111  ; F018     [910102] ;; @@4144 81
; ora #%01000000  ;(copy source=endpoint)    [910102] ;; @@4144 81
_local_1080_20   sta dma1_src_bank                        ; banks ;; @@4144 81
                 sta dma1_dest_bank                        ;; @@4147 81
 ;; @@414a 81
                 lda #0                                   ; [910219] ;; @@414a 81
; sta dma1_cmd  ; command = copy, source=endpoint ;; @@414c 81
                 sta dma1_subcmd                          ; [910520] F018A ;; @@414c 81
; dec a   ;      [910219] ;; @@414f 81
                 sta dma_ctlr+2                           ; dma_list bank ;; @@414f 81
                 ldy #>dma1_cmd                           ; dma_list ;; @@4152 81
                 lda #<dma1_cmd                            ;; @@4154 81
                 sty dma_ctlr+1                           ; dma_list hi ;; @@4156 81
                 sta dma_ctlr                             ; dma_list lo & trigger ;; @@4159 81
                 rts                                       ;; @@415c 81
 ;; @@415d 81
;.end ;; @@415d 81
; .page ;; @@415d 81
; .subttl  FOR ;; @@415d 81
; FOR ;; @@415d 81
; ;; @@415d 81
; Push the following information on the run-time stack: ;; @@415d 81
; ;; @@415d 81
; (bottom)   highest memory ;; @@415d 81
; ========================= ;; @@415d 81
;  txtptr    address of next statement ;; @@415d 81
;  txtptr+1 ;; @@415d 81
;  ======== ;; @@415d 81
;  curlin+1  current line number ;; @@415d 81
;  curlin ;; @@415d 81
;  ======== ;; @@415d 81
;  to lo ;; @@415d 81
;  to mo ;; @@415d 81
;  to moh    'to' value ;; @@415d 81
;  to ho ;; @@415d 81
;  to exp ;; @@415d 81
;  ======== ;; @@415d 81
;  step sign ;; @@415d 81
;  step lo ;; @@415d 81
;  step mo ;; @@415d 81
;  step moh  'step' value ;; @@415d 81
;  step ho ;; @@415d 81
;  step exp ;; @@415d 81
;  ======== ;; @@415d 81
;  forpnt+1  'for' variable pointer ;; @@415d 81
;  forpnt ;; @@415d 81
;  ======== ;; @@415d 81
;  'for' token       <== (tos) top of stack pointer ;; @@415d 81
; ============================ ;; @@415d 81
; (top of stack)  lowest memory ;; @@415d 81
 ;; @@415d 81
 ;; @@415d 81
for              lda #$80                                  ;; @@415d 82
                 sta subflg                               ; no arrays(), no integers% ;; @@415f 82
                 jsr let                                  ; get & set FOR variables ;; @@4161 82
                 lda #for_token                           ; set up for call to see if ;; @@4164 82
                 jsr search                               ; ..this 'for' variable is unique ;; @@4166 82
                 beq _local_1081_10                       ; branch if not ;; @@4169 82
 ;; @@416b 82
; If the variable is not unique, (fndpnt) will point to last occurance ;; @@416b 82
; in stack, and we will reset the stack to that point.  Otherwise we ;; @@416b 82
; will adjust the pointer by 'lenfor' and start from that point. ;; @@416b 82
 ;; @@416b 82
                 lda #lenfor                               ;; @@416b 82
                 jsr getstk                               ; updates stack pointer, error if overflow ;; @@416d 82
                 jsr movtos                               ; (tos) => (fndpnt) ;; @@4170 82
 ;; @@4173 82
_local_1081_10   jsr movfnd                               ; (fndpnt) => (tos)   (redundant for new entries) ;; @@4173 82
                 jsr datan                                ; find address of next statement ;; @@4176 82
                 tya                                      ; offset from (txtptr) in y ;; @@4179 82
                 ldy #lenfor-1                             ;; @@417a 82
 ;; @@417c 82
                 clc                                      ; Push address of next statement on stack ;; @@417c 82
                 adc txtptr                                ;; @@417d 82
                 sta (tos),y                              ; (common area) ;; @@417f 82
                 lda txtptr+1                              ;; @@4181 82
                 adc #0                                    ;; @@4183 82
                 dey                                       ;; @@4185 82
                 sta (tos),y                              ; (common area) ;; @@4186 82
 ;; @@4188 82
                 lda curlin+1                             ; Push current line number on stack ;; @@4188 82
                 dey                                       ;; @@418a 82
                 sta (tos),y                              ; (common area) ;; @@418b 82
                 lda curlin                                ;; @@418d 82
                 dey                                       ;; @@418f 82
                 sta (tos),y                              ; (common area) ;; @@4190 82
 ;; @@4192 82
                 lda #to_token                            ; Look for TO, must appear ;; @@4192 82
                 jsr synchr                                ;; @@4194 82
                 jsr chknum                               ; get TO value ;; @@4197 82
                 jsr frmnum                                ;; @@419a 82
                 lda facsgn                                ;; @@419d 82
                 ora #$7f                                  ;; @@419f 82
                 and facho                                 ;; @@41a1 82
                 sta facho                                 ;; @@41a3 82
 ;; @@41a5 82
                 ldx #4                                    ;; @@41a5 82
                 ldy #lenfor-5                             ;; @@41a7 82
_local_1081_20   lda facexp,x                             ; Push faclo,mo,moh,ho,exp ;; @@41a9 82
                 sta (tos),y                              ; (common area) ;; @@41ab 82
                 dex                                       ;; @@41ad 82
                 dey                                       ;; @@41ae 82
                 bpl _local_1081_20                        ;; @@41af 82
 ;; @@41b1 82
                 lda #<fone                               ; Push STEP value ;; @@41b1 82
                 ldy #>fone                               ; (point to default 'one' in ROM) ;; @@41b3 82
                 jsr movfm                                 ;; @@41b5 82
                 jsr chrgot                                ;; @@41b8 82
                 cmp #step_token                           ;; @@41bb 82
                 bne _local_1081_30                       ; branch if no step given ;; @@41bd 82
                 jsr chrget                                ;; @@41bf 82
                 jsr frmnum                                ;; @@41c2 82
 ;; @@41c5 82
_local_1081_30   jsr sign                                  ;; @@41c5 82
                 pha                                      ; save sign for a moment ;; @@41c8 82
                 jsr round                                 ;; @@41c9 82
                 pla                                       ;; @@41cc 82
 ;; @@41cd 82
                 ldy #lenfor-10                            ;; @@41cd 82
                 ldx #5                                    ;; @@41cf 82
_local_1081_40   sta (tos),y                              ; (common area) ;; @@41d1 82
                 lda facexp-1,x                            ;; @@41d3 82
                 dey                                       ;; @@41d5 82
                 dex                                       ;; @@41d6 82
                 bpl _local_1081_40                        ;; @@41d7 82
 ;; @@41d9 82
                 lda forpnt+1                             ; Finally push pointer to 'for' variable, & 'for' token ;; @@41d9 82
                 sta (tos),y                              ; (common area) ;; @@41db 82
                 lda forpnt                                ;; @@41dd 82
                 dey                                       ;; @@41df 82
                 sta (tos),y                              ; (common area) ;; @@41e0 82
                 lda #for_token                            ;; @@41e2 82
                 dey                                       ;; @@41e4 82
                 sta (tos),y                              ; (common area) ;; @@41e5 82
                 rts                                       ;; @@41e7 82
 ;; @@41e8 82
;.end ;; @@41e8 82
; .page ;; @@41e8 82
; .subttl  DELETE ;; @@41e8 82
 ;; @@41e8 82
; Delete a range of source   -or-   Delete a disk file ;; @@41e8 82
; ;; @@41e8 82
; Syntax: DELETE from# - to# (same range parameters as LIST) ;; @@41e8 82
;  DELETE "filename" (same parameters as SCRATCH) ;; @@41e8 82
 ;; @@41e8 82
; Determine which form of DELETE we have... ;; @@41e8 82
 ;; @@41e8 82
delete           bcc delete_line                          ; branch if a number (assume range parameter) ;; @@41e8 83
                 cmp #minus_token                          ;; @@41ea 83
                 beq delete_line                          ; branch if a dash (assume range parameter) ;; @@41ec 83
                 +lbra scratch                            ; branch if string (assume filename or U#) ;; @@41ee 83
 ;; @@41f1 83
delete_line                                                ;; @@41f1 83
                 jsr errind                               ; direct mode only command ;; @@41f1 83
                 jsr chrgot                               ; requires line# or range, no default ;; @@41f4 83
                 +lbeq snerr                              ; error, none given ;; @@41f7 83
 ;; @@41fa 83
                 jsr range                                ; parse range, find starting line, ptr to ending line ;; @@41fa 83
                 lda lowtr                                 ;; @@41fd 83
                 ldx lowtr+1                               ;; @@41ff 83
                 sta index1                               ; (destination) ;; @@4201 83
                 stx index1+1                              ;; @@4203 83
 ;; @@4205 83
                 jsr FindLine                             ; find ending line ;; @@4205 83
                 bcc _local_1082_20                       ; branch if not found ;; @@4208 83
                 ldy #1                                    ;; @@420a 83
                 jsr indlow                               ; if eot, use this ptr.  else, need ptr to next ;; @@420c 83
                 dey                                       ;; @@420f 83
                 tax                                      ; save it in case of swap ;; @@4210 83
                 bne _local_1082_10                       ; branch if not eot (end-of-text) ;; @@4211 83
                 jsr indlow                                ;; @@4213 83
                 beq _local_1082_20                       ; branch if eot (null link bytes) ;; @@4216 83
 ;; @@4218 83
_local_1082_10   jsr indlow                                ;; @@4218 83
                 sta lowtr                                ; (source) ;; @@421b 83
                 stx lowtr+1                               ;; @@421d 83
 ;; @@421f 83
_local_1082_20   lda lowtr                                ; check that start <= end ;; @@421f 83
                 sec                                       ;; @@4221 83
                 sbc index1                               ; calculate delta ;; @@4222 83
                 sta count                                ; (count) ;; @@4224 83
                 lda lowtr+1                              ; (does not catch case where ;; @@4226 83
                 sbc index1+1                             ; start>end when end=start+1, ;; @@4228 83
                 sta argmo                                ; but it does no harm) ;; @@422a 83
                 ora count                                 ;; @@422c 83
                 beq fix_links                            ; all done- nothing to move!? ;; @@422e 83
                 +lbcc snerr                              ; error- bad range (start > end) ;; @@4230 83
 ;; @@4233 83
                 lda text_top                             ; setup for common DMA move routine: [900530] ;; @@4233 83
                 ldx text_top+1                            ;; @@4235 83
                 sta index2                               ; index2 = top ;; @@4237 83
                 stx index2+1                             ; index1 = destination ;; @@4239 83
; count  = delta ;; @@423b 83
 ;; @@423b 83
                 jsr movedown                             ; delete the text, then relink & exit ;; @@423b 83
 ;; @@423e 83
 ;; @@423e 83
 ;; @@423e 83
fix_links                                                 ; <<<<<<<<<<<<<<<<<<<<<<<<<<< entry from renumber ;; @@423e 84
 ;; @@423e 84
                 jsr link_program                         ; relink program ;; @@423e 84
                 lda index1                                ;; @@4241 84
                 ldx index1+1                              ;; @@4243 84
                 clc                                       ;; @@4245 84
                 adc #2                                    ;; @@4246 84
                 bcc _local_1083_10                        ;; @@4248 84
                 inx                                       ;; @@424a 84
_local_1083_10   sta text_top                             ; set eot pointer ;; @@424b 84
                 stx text_top+1                            ;; @@424d 84
                 rts                                      ; C128-04 fix: was 'jmp ready' (FAB) ;; @@424f 84
 ;; @@4250 84
; .page ;; @@4250 84
;******************************** ;; @@4250 84
;* ;; @@4250 84
;*    Input Range Parameters ;; @@4250 84
;* ;; @@4250 84
;******************************** ;; @@4250 84
 ;; @@4250 84
range            beq _local_1084_10                       ; a terminator from chrgot? ;; @@4250 85
                 bcc _local_1084_10                       ; a number? ;; @@4252 85
                 cmp #minus_token                         ; a dash? ;; @@4254 85
                 bne _local_1084_40   ;if it's not a dash, error (C128-03 fix ; FAB) ;; @@4256 85
                 ldy #1                                    ;; @@4258 85
                 jsr indtxt                               ; let's peek, and see what follows the dash! ;; @@425a 85
                 beq _local_1084_40                       ; uh-oh! it's of the form 'delete -' - error ;; @@425d 85
                 cmp #':'                                 ; the other terminator ;; @@425f 85
                 beq _local_1084_40                       ; ..still bad ;; @@4261 85
                 sec                                      ; set up for linget ;; @@4263 85
 ;; @@4264 85
_local_1084_10   jsr linget                               ; get first # ;; @@4264 85
                 jsr FindLine                             ; find it & set ptrs ;; @@4267 85
                 jsr chrgot                               ; get last char ;; @@426a 85
                 beq _local_1084_20                       ; skip done ;; @@426d 85
                 cmp #minus_token                         ; a dash? ;; @@426f 85
                 bne _local_1084_40                       ; no- syntax error ;; @@4271 85
                 jsr chrget                               ; yes- skip dash ;; @@4273 85
                 jsr linget                               ; get second # ;; @@4276 85
                 bne _local_1084_40                       ; error- wasn't a number ;; @@4279 85
 ;; @@427b 85
_local_1084_20   lda endchr                               ; was a # input? ;; @@427b 85
                 bne _local_1084_30                       ; yes ;; @@427d 85
                 lda #$ff                                 ; no - make max ;; @@427f 85
                 sta linnum                                ;; @@4281 85
                 sta linnum+1                              ;; @@4283 85
_local_1084_30   rts                                       ;; @@4285 85
 ;; @@4286 85
 ;; @@4286 85
_local_1084_40   +lbra snerr                              ; syntax error ;; @@4286 85
 ;; @@4289 85
;.end ;; @@4289 85
; .page ;; @@4289 85
; .subttl  FIND  CHANGE ;; @@4289 85
 ;; @@4289 85
; FIND   "string"                    [,line_range] ;; @@4289 85
; CHANGE "oldstring" TO "newstring"  [,line_range] ;; @@4289 85
; ;; @@4289 85
; where <"> delimiter can be any character, but only ;; @@4289 85
; double-quotes will prevent tokenization of strings. ;; @@4289 85
; ;; @@4289 85
; N.B.: I am assuming that lines cannot be greater than 255 chars, as is ;; @@4289 85
; the case where the line was entered "normally", that is, using LINGET. ;; @@4289 85
 ;; @@4289 85
find                                                       ;; @@4289 86
                 rmb7 op                                  ; FIND flag ;; @@4289 86
                 !text $2c                                 ;; @@428b 86
 ;; @@428c 86
change                                                     ;; @@428c 86
                 smb7 op                                  ; CHANGE flag ;; @@428c 86
                 rmb6 op                                  ; reset change-all mode ;; @@428e 86
                 jsr errind                               ; report error if not in direct mode ;; @@4290 86
 ;; @@4293 86
                 jsr chrgot                               ; get delimeter ;; @@4293 86
                 ldx #0                                   ; evaluate string args ;; @@4296 86
                 jsr delimit_string                       ; string1 ;; @@4298 86
                 lda fstr1+2                               ;; @@429b 86
                 +lbeq fcerr                              ; error if string1 null ;; @@429d 86
                 bbr7 op,_local_1085_10                   ; branch if no string2 ;; @@42a0 86
                 jsr chrget                               ; pick up required 'to' token ;; @@42a3 86
                 cmp #to_token                             ;; @@42a6 86
                 +lbne snerr                              ; error if missing ;; @@42a8 86
                 jsr chrget                                ;; @@42ab 86
                 +lbeq snerr                              ; error if eol ;; @@42ae 86
                 ldx #3                                    ;; @@42b1 86
                 jsr delimit_string                       ; string2 ;; @@42b3 86
 ;; @@42b6 86
_local_1085_10   jsr chrget                               ; line number range given? ;; @@42b6 86
                 beq _local_1085_20                       ; no, eol ;; @@42b9 86
                 jsr chkcom                               ; yes, pick up required comma ;; @@42bb 86
_local_1085_20   jsr range                                ; set up line number range (lowtr,linnum) ;; @@42be 86
                 jsr tto                                  ; save txtptr for restoration when done ;; @@42c1 86
                 rmb7 helper                              ; clear 'help' flag for 'p1line' ;; @@42c4 86
                 lda helper                                ;; @@42c6 86
                 pha                                       ;; @@42c8 86
                 rmb4 helper                              ; temporarily disable token highlighting ;; @@42c9 86
                 smb5 helper                              ; set   'find' flag for 'p1line' ;; @@42cb 86
                 bra find_loop_1                          ; begin ;; @@42cd 86
 ;; @@42cf 86
; .page ;; @@42cf 86
find_loop                                                  ;; @@42cf 87
                 ldy #0                                   ; move to next line (copy link bytes to lowtr) ;; @@42cf 87
                 jsr indlow                                ;; @@42d1 87
                 tax                                       ;; @@42d4 87
                 iny                                       ;; @@42d5 87
                 jsr indlow                                ;; @@42d6 87
                 stx lowtr                                 ;; @@42d9 87
                 sta lowtr+1                               ;; @@42db 87
 ;; @@42dd 87
find_loop_1                                                ;; @@42dd 87
                 ldy #1                                    ;; @@42dd 87
                 jsr indlow                               ; check link ;; @@42df 87
                 bne _local_1086_10                       ; not null- continue ;; @@42e2 87
                 dey                                       ;; @@42e4 87
                 jsr indlow                                ;; @@42e5 87
                 +lbeq find_exit                          ; null- exit ;; @@42e8 87
 ;; @@42eb 87
_local_1086_10   ldy #2                                    ;; @@42eb 87
                 jsr indlow                               ; check line number ;; @@42ed 87
                 tax                                       ;; @@42f0 87
                 iny                                       ;; @@42f1 87
                 jsr indlow                                ;; @@42f2 87
                 cmp linnum+1                              ;; @@42f5 87
                 bne _local_1086_20                        ;; @@42f7 87
                 cpx linnum                                ;; @@42f9 87
                 beq _local_1086_30                       ; line is <= last line requested, continue ;; @@42fb 87
_local_1086_20   +lbcs find_exit                          ; line is >  last line requested, exit ;; @@42fd 87
 ;; @@4300 87
_local_1086_30   ldx #3                                   ; set initial position - 1 (past link & line#) ;; @@4300 87
                 stx fndpnt                                ;; @@4302 87
 ;; @@4304 87
; .page ;; @@4304 87
find_loop_2                                                ;; @@4304 88
                 jsr _stop                                ; check stop key ;; @@4304 88
                 +lbeq find_break                         ; exit if down ;; @@4307 88
 ;; @@430a 88
                 ldx fndpnt                               ; duh, where are we? ;; @@430a 88
                 clc                                       ;; @@430c 88
                 txa                                      ; program: ;; @@430d 88
                 adc lowtr                                ; txtptr = line start + position in line ;; @@430e 88
                 sta txtptr                                ;; @@4310 88
                 lda #0                                    ;; @@4312 88
                 adc lowtr+1                               ;; @@4314 88
                 sta txtptr+1                             ; search string: ;; @@4316 88
                 ldz #0                                   ; at the beginning ;; @@4318 88
 ;; @@431a 88
_local_1087_40   jsr chargt                               ; get next character from text ;; @@431a 88
                 beq find_loop                            ; eol (no match this line) ;; @@431d 88
                 inx                                      ; bump pointer to next character ;; @@431f 88
                 cmp (fstr1),z                            ; character match?  ind okay- buffer ;; @@4320 88
                 bne _local_1087_40                       ; no ;; @@4322 88
                 stx fndpnt                               ; yes- save next position ;; @@4324 88
 ;; @@4326 88
_local_1087_50   inz                                      ; bump position in search string ;; @@4326 88
                 cpz fstr1+2                              ; string match? ;; @@4327 88
                 bcs print_line                           ; yes ;; @@4329 88
                 jsr chargt                                ;; @@432b 88
                 beq find_loop                            ; no- eol ;; @@432e 88
                 cmp (fstr1),z                            ; ind okay- buffer ;; @@4330 88
                 bne find_loop_2                          ; no- rewind to beginning of search string ;; @@4332 88
                 beq _local_1087_50                       ; maybe- still more chars to compare ;; @@4334 88
 ;; @@4336 88
 ;; @@4336 88
; Print the line of text at LOWTR, highlighting the section of code ;; @@4336 88
; beginning at LOWTR+FNDPNT and running for FIND_COUNT characters. ;; @@4336 88
 ;; @@4336 88
print_line                                                 ;; @@4336 89
                 jsr crdo                                 ; get a new display line ;; @@4336 89
                 lda fstr1+2                              ; length of string to highlight ;; @@4339 89
                 sta find_count                            ;; @@433b 89
                 ldy #2                                    ;; @@433e 89
                 jsr indlow                               ; get ms byte of line number ;; @@4340 89
                 tax                                       ;; @@4343 89
                 iny                                       ;; @@4344 89
                 jsr indlow                               ; get ls byte ;; @@4345 89
                 jsr p1line                               ; print #, space, and the line of code ;; @@4348 89
                 bbr7 op,find_loop_2                      ; Find op? branch if so and continue search ;; @@434b 89
 ;; @@434e 89
; .page ;; @@434e 89
; Change operation ;; @@434e 89
; Query the user and replace string1 with string2 if he wants to. ;; @@434e 89
; Options are  'Y' (yes),  '*' (do all),  'CR' (quit),  anything else means no. ;; @@434e 89
 ;; @@434e 89
change_line                                                ;; @@434e 89
                 bbs6 op,_local_1088_100                  ; branch if change-all mode set ;; @@434e 89
                 jsr _primm                               ; prompt & get response ;; @@4351 89
                 !text cr," CHANGE? ",0                    ;; @@4354 89
                 jsr response_get                          ;; @@435f 89
                 cmp #'Y'                                  ;; @@4362 89
                 beq _local_1088_100                      ; yes, change it ;; @@4364 89
                 cmp #cr                                   ;; @@4366 89
                 +lbeq find_exit                          ; cr only, abort entire operation ;; @@4368 89
                 cmp #'*'                                  ;; @@436b 89
                 bne find_loop_2                          ; *, change all.  else don't change ;; @@436d 89
                 smb6 op                                   ;; @@436f 89
 ;; @@4371 89
; Replace string1 with string2.  Requires moving text up/down beginning at ;; @@4371 89
; LOWTR+FNDPNT+(LEN(string1)-LEN(string2)) through TEXT_TOP and copying ;; @@4371 89
; string1 into text beginning at LOWTR+FNDPNT for LEN(string2) characters. ;; @@4371 89
 ;; @@4371 89
_local_1088_100  lda text_top                             ; setup upper address of text to move (index2) ;; @@4371 89
                 sta index2                                ;; @@4373 89
                 lda text_top+1                           ; TEXT_TOP ;; @@4375 89
                 sta index2+1                              ;; @@4377 89
 ;; @@4379 89
                 clc                                      ; setup lower address of text to move (index1) ;; @@4379 89
                 lda fndpnt                                ;; @@437a 89
                 adc lowtr                                 ;; @@437c 89
                 sta index1                               ; LOWTR+FNDPNT ;; @@437e 89
                 lda #0                                    ;; @@4380 89
                 sta argmo                                ; count hi ;; @@4382 89
                 adc lowtr+1                               ;; @@4384 89
                 sta index1+1                              ;; @@4386 89
 ;; @@4388 89
                 sec                                      ; calc number of chars to insert/delete ;; @@4388 89
                 lda fstr1+2                              ; LEN(string1)-LEN(string2) ;; @@4389 89
                 sbc fstr2+2                               ;; @@438b 89
                 beq _local_1088_20                       ; branch if string1 = string2 (no move) ;; @@438d 89
                 bpl _local_1088_10                       ; branch if string1 > string2 (delete) ;; @@438f 89
; else      string1 < string2 (insert) ;; @@4391 89
 ;; @@4391 89
                 neg                                      ; Move memory up to make room for larger string2 ;; @@4391 89
                 sta count                                 ;; @@4392 89
                 ldy #0                                   ; first check for line too long ;; @@4394 89
                 jsr indlow                                ;; @@4396 89
                 adc count                                 ;; @@4399 89
                 taz                                       ;; @@439b 89
                 iny                                       ;; @@439c 89
                 jsr indlow                               ; (link+#chr)-line_sa must be <256 ;; @@439d 89
                 adc #0                                    ;; @@43a0 89
                 tay                                       ;; @@43a2 89
                 sec                                       ;; @@43a3 89
                 tza                                       ;; @@43a4 89
                 sbc lowtr                                 ;; @@43a5 89
                 tya                                       ;; @@43a7 89
                 sbc lowtr+1                               ;; @@43a8 89
                 +lbne errlen                             ; error, line > 255 characters ;; @@43aa 89
 ;; @@43ad 89
                 clc                                      ; now check for sufficient memory ;; @@43ad 89
                 ldy text_top+1                            ;; @@43ae 89
                 lda count                                 ;; @@43b0 89
                 adc text_top                              ;; @@43b2 89
                 bcc _local_1088_1                         ;; @@43b4 89
                 iny                                       ;; @@43b6 89
_local_1088_1    cpy max_mem_0+1                           ;; @@43b7 89
                 bcc _local_1088_2                        ; result is less than top-of-memory: ok ;; @@43ba 89
                 +lbne omerr                              ; msb >  top, overflow ;; @@43bc 89
                 cmp max_mem_0                            ; msb's the same, test lsb's ;; @@43bf 89
                 +lbcs omerr                              ; lsb >= top, overflow ;; @@43c2 89
_local_1088_2    sta text_top                              ;; @@43c5 89
                 sty text_top+1                           ; set new top of text pointer ;; @@43c7 89
                 jsr moveup                               ; make room ;; @@43c9 89
                 bra _local_1088_20                       ; go copy string2 into area ;; @@43cc 89
 ;; @@43ce 89
_local_1088_10   sta count                                ; Move memory down for smaller string2 ;; @@43ce 89
                 ldy text_top+1                            ;; @@43d0 89
                 lda text_top                              ;; @@43d2 89
                 sec                                       ;; @@43d4 89
                 sbc count                                 ;; @@43d5 89
                 bcs _local_1088_11                        ;; @@43d7 89
                 dey                                       ;; @@43d9 89
_local_1088_11   sta text_top                              ;; @@43da 89
                 sty text_top+1                           ; set new top of text pointer ;; @@43dc 89
                 jsr movedown                             ; squish out excess space ;; @@43de 89
 ;; @@43e1 89
_local_1088_20   lda fstr2+2                              ; Copy string2 into text ;; @@43e1 89
                 beq _local_1088_40                       ; branch if null, nothing to copy ;; @@43e3 89
                 sta find_count                           ; how many characters to copy ;; @@43e5 89
                 ldx #lowtr                                ;; @@43e8 89
                 ldy fndpnt                               ; index into text ;; @@43ea 89
                 ldz #0                                   ; index into string2 ;; @@43ec 89
_local_1088_30   lda (fstr2),z                            ; ind okay- buffer ;; @@43ee 89
                 jsr sta_far_ram0                         ; do the copy ;; @@43f0 89
                 iny                                       ;; @@43f3 89
                 inz                                       ;; @@43f4 89
                 dec find_count                            ;; @@43f5 89
                 bne _local_1088_30                        ;; @@43f8 89
 ;; @@43fa 89
_local_1088_40   jsr link_program                         ; relink program ;; @@43fa 89
                 clc                                       ;; @@43fd 89
                 lda fndpnt                               ; place find position after new text ;; @@43fe 89
                 adc fstr2+2                               ;; @@4400 89
                 dec                                       ;; @@4402 89
                 sta fndpnt                                ;; @@4403 89
                 +lbra find_loop_2                        ; and resume searching ;; @@4405 89
 ;; @@4408 89
; .page ;; @@4408 89
find_exit                                                  ;; @@4408 90
                 jsr crdo                                 ; normal exit ;; @@4408 90
                 pla                                       ;; @@440b 90
                 sta helper                               ; restore token highlight status ;; @@440c 90
                 rmb5 helper                              ; remove 'find' flag ;; @@440e 90
                 +lbra direct_mode_exit                   ; done ;; @@4410 90
 ;; @@4413 90
 ;; @@4413 90
 ;; @@4413 90
find_omerr                                                ; out of memory ;; @@4413 90
                 ldx #errom                                ;; @@4413 90
                 !text $2c                                 ;; @@4415 90
find_errlen                                               ; string too long ;; @@4416 90
                 ldx #errls                                ;; @@4416 90
                 sec                                       ;; @@4418 90
                 !text $89                                 ;; @@4419 90
find_break                                                ; stop key break ;; @@441a 90
                 clc                                       ;; @@441a 90
                 pla                                       ;; @@441b 90
                 sta helper                               ; restore token highlight status ;; @@441c 90
                 rmb5 helper                              ; remove 'find' flag ;; @@441e 90
                 +lbcc break_exit                         ; [910925] ;; @@4420 90
                 +lbra error                               ;; @@4423 90
 ;; @@4426 90
 ;; @@4426 90
delimit_string                                            ; command is in buffer, .x = ptr to strptr ;; @@4426 90
                 sta match                                ; delimiter character ;; @@4426 90
                 lda txtptr                               ; point to first character in string ;; @@4428 90
                 inc                                      ; (never wraps- string in input buffer) ;; @@442a 90
                 sta fstr1,x                              ; set pointer to string data ;; @@442b 90
                 lda txtptr+1                              ;; @@442d 90
                 sta fstr1+1,x                             ;; @@442f 90
                 lda #$ff                                 ; set string length ;; @@4431 90
                 sta fstr1+2,x                             ;; @@4433 90
 ;; @@4435 90
_local_1089_10   inc fstr1+2,x                             ;; @@4435 90
                 jsr chargt                               ; build string ;; @@4437 90
                 +lbeq snerr                              ; error if eol encountered inside string ;; @@443a 90
                 cmp match                                 ;; @@443d 90
                 bne _local_1089_10                       ; continue until matching delimiter found ;; @@443f 90
                 rts                                       ;; @@4441 90
 ;; @@4442 90
;.end ;; @@4442 90
; .page ;; @@4442 90
; .subttl  PUDEF ;; @@4442 90
 ;; @@4442 90
puctrl           jsr frmstr                               ; do frmevl,frestr. return with a=len, index=~string ;; @@4442 91
                 tay                                       ;; @@4445 91
                 dey                                       ;; @@4446 91
                 cpy #4                                    ;; @@4447 91
                 +lbcs fcerr                              ; len > 4 is illegal value error ;; @@4449 91
 ;; @@444c 91
_local_1090_1    jsr indin1_ram1                          ; lda (index),y ;; @@444c 91
                 sta puchrs,y                              ;; @@444f 91
                 dey                                       ;; @@4452 91
                 bpl _local_1090_1                         ;; @@4453 91
                 rts                                       ;; @@4455 91
 ;; @@4456 91
;.end ;; @@4456 91
; .page ;; @@4456 91
; .subttl  TRAP ;; @@4456 91
 ;; @@4456 91
trap                                                       ;; @@4456 92
; jsr errdir ;why not????      [910925] ;; @@4456 92
                 jsr chrgot                               ; if no #, means 'turn off trap' ;; @@4456 92
                 beq _local_1091_10                        ;; @@4459 92
                 jsr getwrd                                ;; @@445b 92
                 sty trapno                                ;; @@445e 92
                 !text $2c                                 ;; @@4461 92
 ;; @@4462 92
_local_1091_10   lda #$ff                                 ; flag no trap ;; @@4462 92
                 sta trapno+1                              ;; @@4464 92
                 rts                                       ;; @@4467 92
 ;; @@4468 92
;.end ;; @@4468 92
 ;; @@4468 92
; .page ;; @@4468 92
; .subttl  RESUME ;; @@4468 92
 ;; @@4468 92
; RESUME command ;; @@4468 92
; ;; @@4468 92
; Used to resume execution following a TRAPped error. ;; @@4468 92
; ;; @@4468 92
; Syntax: RESUME [line_number | NEXT] ;; @@4468 92
; ;; @@4468 92
; Can take the following forms: ;; @@4468 92
; ;; @@4468 92
; RESUME   :resume executing at the statement which caused ;; @@4468 92
;     the error. ;; @@4468 92
; RESUME NEXT  :resume execution at the statement FOLLOWING ;; @@4468 92
;     the statement which caused the error. ;; @@4468 92
; RESUME line_number :resume at the specified line number. ;; @@4468 92
 ;; @@4468 92
 ;; @@4468 92
resume           jsr errdir                               ; no direct mode ;; @@4468 93
                 ldx errlin+1                             ; is there an error to resume from? ;; @@446b 93
                 inx                                       ;; @@446e 93
                 beq rescnt                               ; can't resume! ;; @@446f 93
                 jsr chrgot                               ; look for arguments ;; @@4471 93
                 beq resswp                               ; no arg's...restart err'd line ;; @@4474 93
                 bcc _local_1092_3                        ; numeric argument ;; @@4476 93
                 cmp #next_token                          ; only other choice is 'next' ;; @@4478 93
                 +lbne snerr                              ; if not, syntax error ;; @@447a 93
 ;; @@447d 93
                 jsr resswp                               ; resume execution with next stm't ;; @@447d 93
                 ldy #0                                    ;; @@4480 93
                 jsr indtxt                                ;; @@4482 93
                 bne _local_1092_2                        ; must be a ':' ;; @@4485 93
                 iny                                      ; must be a null,get next line ;; @@4487 93
                 jsr indtxt                               ; make sure its not end-of-text ;; @@4488 93
                 bne _local_1092_1                         ;; @@448b 93
                 iny                                       ;; @@448d 93
                 jsr indtxt                                ;; @@448e 93
                 +lbeq ready                              ; 2 nulls, eot. bye! ;; @@4491 93
 ;; @@4494 93
_local_1092_1    ldy #3                                   ; new line, update pointers ;; @@4494 93
                 jsr indtxt                                ;; @@4496 93
                 sta curlin                                ;; @@4499 93
                 iny                                       ;; @@449b 93
                 jsr indtxt                                ;; @@449c 93
                 sta curlin+1                              ;; @@449f 93
                 tya                                       ;; @@44a1 93
                 clc                                       ;; @@44a2 93
                 adc txtptr                                ;; @@44a3 93
                 sta txtptr                                ;; @@44a5 93
                 bcc _local_1092_2                         ;; @@44a7 93
                 inc txtptr+1                              ;; @@44a9 93
_local_1092_2    jsr chrget                               ; skip over this character, into body of statement ;; @@44ab 93
                 +lbra data                               ; advance until null or ':', then rts ;; @@44ae 93
 ;; @@44b1 93
 ;; @@44b1 93
_local_1092_3    jsr getwrd                               ; resnum. numeric argument ;; @@44b1 93
                 sta linnum+1                              ;; @@44b4 93
                 jsr resend                                ;; @@44b6 93
                 +lbra luk4it                              ;; @@44b9 93
 ;; @@44bc 93
 ;; @@44bc 93
resswp           lda errtxt                               ; backup one so chrget will work ;; @@44bc 94
                 bne _local_1093_10                        ;; @@44bf 94
                 dec errtxt+1                              ;; @@44c1 94
_local_1093_10   dec errtxt                                ;; @@44c4 94
 ;; @@44c7 94
                 ldx #1                                    ;; @@44c7 94
_local_1093_20   lda errlin,x                             ; restore line# ;; @@44c9 94
                 sta curlin,x                              ;; @@44cc 94
                 lda errtxt,x                             ; restore text pointer to statement ;; @@44ce 94
                 sta txtptr,x                              ;; @@44d1 94
                 dex                                       ;; @@44d3 94
                 bpl _local_1093_20                        ;; @@44d4 94
 ;; @@44d6 94
 ;; @@44d6 94
resend           ldx tmptrp                               ; restore trap line to allow traps again ;; @@44d6 95
                 stx trapno+1                              ;; @@44d9 95
error_clear                                                ;; @@44dc 95
                 ldx #$ff                                  ;; @@44dc 95
                 stx errnum                               ; reset error status- he's saying he's fixed it ;; @@44de 95
                 stx errlin                                ;; @@44e1 95
                 stx errlin+1                             ; flag 'no further resumes until next error' ;; @@44e4 95
                 rts                                       ;; @@44e7 95
 ;; @@44e8 95
 ;; @@44e8 95
rescnt           ldx #errcr                                ;; @@44e8 95
                 +lbra error                               ;; @@44ea 95
 ;; @@44ed 95
;.end ;; @@44ed 95
; .page ;; @@44ed 95
; .subttl  DO  LOOP  UNTIL  WHILE  EXIT ;; @@44ed 95
 ;; @@44ed 95
do               ldy #1                                    ;; @@44ed 95
_local_1094_1    lda txtptr,y                             ; save current pointers for stack entry ;; @@44ef 95
                 sta tmptxt,y                              ;; @@44f2 95
                 lda curlin,y                              ;; @@44f5 95
                 sta tmplin,y                              ;; @@44f8 95
                 dey                                       ;; @@44fb 95
                 bpl _local_1094_1                         ;; @@44fc 95
 ;; @@44fe 95
                 jsr chrgot                               ; look for 'while' or 'until' ;; @@44fe 95
                 beq doyes                                ; unconditional ;; @@4501 95
                 cmp #until_token                          ;; @@4503 95
                 beq do10                                  ;; @@4505 95
                 cmp #while_token                          ;; @@4507 95
                 bne snrjmp                                ;; @@4509 95
 ;; @@450b 95
 ;; @@450b 95
;  Here for WHILE ;; @@450b 95
 ;; @@450b 95
                 jsr frmjmp                                ;; @@450b 95
                 lda facexp                                ;; @@450e 95
                 bne doyes                                ; conditional evaluated true ;; @@4510 95
 ;; @@4512 95
dono             jsr chrgot                                ;; @@4512 96
                 bra fnd010                               ; advance to end of block, do rts ;; @@4515 96
 ;; @@4517 96
 ;; @@4517 96
;  Here for UNTIL ;; @@4517 96
 ;; @@4517 96
do10             jsr frmjmp                                ;; @@4517 96
                 lda facexp                                ;; @@451a 96
                 bne dono                                  ;; @@451c 96
 ;; @@451e 96
doyes            lda #5                                   ; 'do' needs 5 bytes on the run-time stack ;; @@451e 96
                 jsr getstk                                ;; @@4520 96
                 ldy #4                                   ; ..now stuff those 5 bytes! ;; @@4523 96
                 lda tmptxt+1                              ;; @@4525 96
                 sta (tos),y                              ; (common area) ;; @@4528 96
                 dey                                       ;; @@452a 96
                 lda tmptxt                                ;; @@452b 96
                 sta (tos),y                              ; (common area) ;; @@452e 96
                 dey                                       ;; @@4530 96
                 lda tmplin+1                              ;; @@4531 96
                 sta (tos),y                              ; (common area) ;; @@4534 96
                 dey                                       ;; @@4536 96
                 lda tmplin                                ;; @@4537 96
                 sta (tos),y                              ; (common area) ;; @@453a 96
                 dey                                       ;; @@453c 96
                 lda #do_token                             ;; @@453d 96
                 sta (tos),y                              ; (common area) ;; @@453f 96
                 rts                                       ;; @@4541 96
 ;; @@4542 96
 ;; @@4542 96
;  Here for EXIT ;; @@4542 96
 ;; @@4542 96
exit             jsr popdgo                               ; pop do entry off stack ;; @@4542 96
                 jsr chrgot                                ;; @@4545 96
                 beq fnd010                                ;; @@4548 96
snrjmp           +lbra snerr                               ;; @@454a 96
 ;; @@454d 96
 ;; @@454d 96
 ;; @@454d 96
;  Find end of current block ;; @@454d 96
 ;; @@454d 96
fndend           jsr chrget                                ;; @@454d 96
 ;; @@4550 96
fnd010           beq _local_1095_20                       ; end of statement ;; @@4550 96
                 cmp #loop_token                           ;; @@4552 96
                 +lbeq data                               ; a hit!  read to end of statement, rts ;; @@4554 96
                 cmp #'"'                                 ; quote ;; @@4557 96
                 beq _local_1095_10                        ;; @@4559 96
                 cmp #do_token                             ;; @@455b 96
                 bne fndend                               ; keep looking ;; @@455d 96
                 jsr fndend                               ; recursivly ;; @@455f 96
                 bra dono                                 ; do a chrgot, go to fnd010 ;; @@4562 96
 ;; @@4564 96
 ;; @@4564 96
_local_1095_10   jsr un_quote                             ; look for terminating quote, or end of statement ;; @@4564 96
                 bne fndend                               ; character after quote wasn't terminator, keep going ;; @@4567 96
 ;; @@4569 96
_local_1095_20   cmp #':'                                 ; end of line or end of stmt? ;; @@4569 96
                 beq fndend                               ; just stmt, keep going ;; @@456b 96
                 bbr7 runmod,fnderr                       ; if direct mode, not found error ;; @@456d 96
                 ldy #2                                    ;; @@4570 96
                 jsr indtxt                               ; end of text? ;; @@4572 96
                 beq fnderr                               ; 'fraid so ;; @@4575 96
                 iny                                      ; y=3 ;; @@4577 96
                 jsr indtxt                               ; update pointers ;; @@4578 96
                 sta curlin                                ;; @@457b 96
                 iny                                       ;; @@457d 96
                 jsr indtxt                                ;; @@457e 96
                 sta curlin+1                              ;; @@4581 96
                 tya                                       ;; @@4583 96
                 clc                                       ;; @@4584 96
                 adc txtptr                                ;; @@4585 96
                 sta txtptr                                ;; @@4587 96
                 bcc fndend                                ;; @@4589 96
                 inc txtptr+1                              ;; @@458b 96
                 bra fndend                                ;; @@458d 96
 ;; @@458f 96
; .page ;; @@458f 96
loop             beq popngo                               ; no conditionals, just do it ;; @@458f 97
                 cmp #while_token                          ;; @@4591 97
                 beq loop10                                ;; @@4593 97
                 cmp #until_token                          ;; @@4595 97
                 bne snrjmp                                ;; @@4597 97
 ;; @@4599 97
;  Here for UNTIL ;; @@4599 97
 ;; @@4599 97
                 jsr frmjmp                                ;; @@4599 97
                 lda facexp                                ;; @@459c 97
                 beq popngo                               ; false, do it again! ;; @@459e 97
 ;; @@45a0 97
popdgo           lda #do_token                            ; pop, but don't go ;; @@45a0 97
                 jsr search                                ;; @@45a2 97
                 bne poperr                               ; branch if not found ;; @@45a5 97
                 jsr movfnd                                ;; @@45a7 97
                 ldy #5                                    ;; @@45aa 97
                 +lbra rlsstk                              ;; @@45ac 97
 ;; @@45af 97
 ;; @@45af 97
fnderr                                                     ;; @@45af 97
                 lda tmplin                               ; loop not found error: must make curlin match oldtxt ;; @@45af 97
                 ldx tmplin+1                              ;; @@45b2 97
                 sta curlin                                ;; @@45b5 97
                 stx curlin+1                              ;; @@45b7 97
 ;; @@45b9 97
                 ldx #errlnf                               ;; @@45b9 97
                 !text $2c                                 ;; @@45bb 97
poperr                                                     ;; @@45bc 97
                 ldx #errlwd                              ; loop without do ;; @@45bc 97
                 +lbra error                               ;; @@45be 97
 ;; @@45c1 97
 ;; @@45c1 97
 ;; @@45c1 97
;  Here for WHILE ;; @@45c1 97
 ;; @@45c1 97
loop10                                                     ;; @@45c1 97
                 jsr frmjmp                                ;; @@45c1 97
                 beq popdgo                               ; false, exit ;; @@45c4 97
popngo                                                     ;; @@45c6 97
                 bsr popdgo                                ;; @@45c6 97
; dey ;; @@45c9 97
; lda (fndpnt),y ;restore pointers ;; @@45c9 97
; sta txtptr+1 ;; @@45c9 97
; dey ;; @@45c9 97
; lda (fndpnt),y ;; @@45c9 97
; sta txtptr ;; @@45c9 97
; dey ;; @@45c9 97
; lda (fndpnt),y ;; @@45c9 97
                 jsr retpat                               ; (** 01/18/84 fixes 'loop' to a direct mode 'do') ;; @@45c9 97
; lda (fndpnt),y ;; @@45cc 97
; sta curlin ;; @@45cc 97
                 +lbra do                                  ;; @@45cc 97
 ;; @@45cf 97
frmjmp                                                     ;; @@45cf 97
                 jsr chrget                                ;; @@45cf 97
                 +lbra frmevl                              ;; @@45d2 97
 ;; @@45d5 97
;.end ;; @@45d5 97
; .page ;; @@45d5 97
; .subttl  KEY ;; @@45d5 97
 ;; @@45d5 97
;************************************************************** ;; @@45d5 97
; ;; @@45d5 97
;   KEY  Programmable Key Functions    [900725] ;; @@45d5 97
; ;; @@45d5 97
;************************************************************** ;; @@45d5 97
 ;; @@45d5 97
key              beq Key_List                             ; KEY ? yes- no args ;; @@45d5 97
 ;; @@45d7 97
_local_1096_1    ldx _kyndx                               ; is function key buffered? ;; @@45d7 97
                 bne _local_1096_1                        ; yes- hang until IRQ finishes processing it ???? ;; @@45d9 97
 ;; @@45db 97
                 cmp #on_token                            ; KEY ON ? ;; @@45db 97
                 bne _local_1096_10                        ;; @@45dd 97
                 rmb5 _locks                              ; yes- reset Editor's lock bit ;; @@45df 97
                 bra _local_1096_30                       ; exit ;; @@45e1 97
 ;; @@45e3 97
_local_1096_10   cmp #load_token                          ; KEY LOAD <filename>[,D#,U#] ;; @@45e3 97
                 +lbeq Key_load                            ;; @@45e5 97
 ;; @@45e8 97
                 cmp #save_token                          ; KEY SAVE <filename>[,D#,U#] ;; @@45e8 97
                 +lbeq Key_Save                            ;; @@45ea 97
 ;; @@45ed 97
                 cmp #restore_token                       ; KEY RESTORE ?      [910925] ;; @@45ed 97
                 bne _local_1096_20                       ; no ;; @@45ef 97
                 rmb5 _locks                              ; yes- reset Editor's lock bit (enable keys) ;; @@45f1 97
                 jsr key_restore                          ; init key definitions ;; @@45f3 97
                 bra _local_1096_30                       ; exit ;; @@45f6 97
 ;; @@45f8 97
_local_1096_20   cmp #esc_command_token                   ; KEY OFF ? ;; @@45f8 97
                 +lbne Key_Change                         ; no- must be new key definition ;; @@45fa 97
                 jsr chrget                                ;; @@45fd 97
                 cmp #off_token                            ;; @@4600 97
                 +lbne snerr                              ; no- bad syntax ;; @@4602 97
                 smb5 _locks                              ; yes- set Editor's lock bit ;; @@4605 97
_local_1096_30   +lbra chrget                             ; exit ;; @@4607 97
 ;; @@460a 97
; .page ;; @@460a 97
;************************************************************** ;; @@460a 97
; ;; @@460a 97
;   Key_List  List all function key definitions ;; @@460a 97
; ;; @@460a 97
;************************************************************** ;; @@460a 97
 ;; @@460a 97
Key_List                                                   ;; @@460a 98
                 ldx #0                                   ; display all key definitions ;; @@460a 98
                 ldy #0                                    ;; @@460c 98
 ;; @@460e 98
lstky1           inx                                      ; get key number = 1-16 ;; @@460e 98
                 lda _pky_lengths-1,x                     ; get key size ;; @@460f 98
                 beq lstest                               ; skip if key not defined ;; @@4612 98
                 sta keysiz                               ; save size ;; @@4614 98
                 stx z_p_temp_1                           ; save key number ;; @@4616 98
 ;; @@4618 98
                 phy                                       ;; @@4618 98
                 ldx #3                                    ;; @@4619 98
_local_1097_20   lda preamb,x                             ; print key preamble: ;; @@461b 98
                 jsr _bsout                                ;; @@461e 98
                 dex                                      ; 'KEY ' ;; @@4621 98
                 bpl _local_1097_20                        ;; @@4622 98
                 ldx z_p_temp_1                           ; key number ;; @@4624 98
                 lda #0                                    ;; @@4626 98
                 jsr linprt                                ;; @@4628 98
                 lda #','                                  ;; @@462b 98
                 jsr _bsout                               ; comma ;; @@462d 98
 ;; @@4630 98
                 ply                                       ;; @@4630 98
                 ldx #7                                   ; (length of 'keydat' string) ;; @@4631 98
lsloop           lda _pky_buffer,y                        ; print key definition ;; @@4633 99
                 iny                                       ;; @@4636 99
                 pha                                      ; save character ;; @@4637 99
                 phx                                      ; save position in output string ;; @@4638 99
 ;; @@4639 99
                 ldx #4                                   ; check for special (non-printable) characters ;; @@4639 99
_local_1098_50   cmp keychr-1,x                            ;; @@463b 99
                 beq list_special                         ; yes, display it as 'CHR$(...)' ;; @@463e 99
                 dex                                       ;; @@4640 99
                 bne _local_1098_50                        ;; @@4641 99
 ;; @@4643 99
                 plx                                      ; restore position ;; @@4643 99
                 cpx #8                                    ;; @@4644 99
                 bcc _local_1098_60                       ; 1st time thru- display leading quote ;; @@4646 99
                 bne _local_1098_70                       ; previous was a character- no additions needed ;; @@4648 99
                 lda #'+'                                 ; add since previous was quote or return ;; @@464a 99
                 jsr _bsout                                ;; @@464c 99
_local_1098_60   lda #'"'                                  ;; @@464f 99
                 jsr _bsout                               ; add leading quote ;; @@4651 99
_local_1098_70   pla                                      ; restore character ;; @@4654 99
                 jsr _bsout                               ; display it ;; @@4655 99
                 ldx #9                                   ; mark normal character ;; @@4658 99
 ;; @@465a 99
lstnd            dec keysiz                                ;; @@465a 100
                 bne lsloop                               ; loop to end of definition ;; @@465c 100
                 cpx #9                                    ;; @@465e 100
                 bcc _local_1099_10                       ; skip if previous not normal character ;; @@4660 100
                 lda #'"'                                  ;; @@4662 100
                 jsr _bsout                               ; add ending quote ;; @@4664 100
 ;; @@4667 100
_local_1099_10   lda #$8d                                  ;; @@4667 100
                 jsr _bsout                               ; add ending return (shifted) ;; @@4669 100
 ;; @@466c 100
                 ldx z_p_temp_1                           ; key number ;; @@466c 100
lstest           cpx #number_fkeys                         ;; @@466e 101
                 bne lstky1                               ; ...loop until done all keys ;; @@4670 101
                 rts                                       ;; @@4672 101
 ;; @@4673 101
 ;; @@4673 101
list_special                                               ;; @@4673 101
                 plx                                      ; restore .x ;; @@4673 101
_local_1100_10   lda keydat-3,x                           ; display something like  ' "+CHR$( ' ;; @@4674 101
                 jsr _bsout                                ;; @@4677 101
                 dex                                       ;; @@467a 101
                 cpx #3                                    ;; @@467b 101
                 bcs _local_1100_10                        ;; @@467d 101
                 pla                                      ; restore character ;; @@467f 101
                 jsr prtdec                               ; display decimal value of chr in .a ;; @@4680 101
                 lda #')'                                 ; finish off with closing paren. ;; @@4683 101
                 jsr _bsout                                ;; @@4685 101
                 ldx #8                                   ; mark end of special ;; @@4688 101
                 bra lstnd                                ; ..always ;; @@468a 101
 ;; @@468c 101
 ;; @@468c 101
preamb           !text " YEK"                             ; key preamble ;; @@468c 102
 ;; @@4690 102
keydat           !text "($RHC+",$22                       ; chr$( string ;; @@4690 102
 ;; @@4697 102
keychr           !text cr,$8d,$22,esc                     ; special KEY chars- return, sft-return, quote, esc ;; @@4697 102
 ;; @@469b 102
; .page ;; @@469b 102
;************************************************************************ ;; @@469b 102
; ;; @@469b 102
;   Key_Change  Add, Delete or Change function key definition ;; @@469b 102
; ;; @@469b 102
;************************************************************************ ;; @@469b 102
 ;; @@469b 102
Key_Change                                                 ;; @@469b 102
                 jsr getbyt                               ; get key number (1-16) ;; @@469b 102
                 stx z_p_temp_1                           ; save key number     [910925] ;; @@469e 102
                 dex                                       ;; @@46a0 102
                 cpx #number_fkeys                         ;; @@46a1 102
                 +lbcs fcerr                              ; exit - key number invalid ;; @@46a3 102
 ;; @@46a6 102
; stx z_p_temp_1 ;save key number ;; @@46a6 102
                 jsr chkcom                               ; look for comma ;; @@46a6 102
                 jsr frmstr                               ; do frmevl, frestr. returns len in .a, addr in 'index' ;; @@46a9 102
                 tay                                      ; set up for call to do-a-key ;; @@46ac 102
                 lda #1                                   ; tell do-a-key that string is in bank 1 ;; @@46ad 102
                 sta index+2                               ;; @@46af 102
                 lda #index                               ; now .A points to (adr lo, adr hi, bank #) ;; @@46b1 102
                 ldx z_p_temp_1                            ;; @@46b3 102
; inx         [910925] ;; @@46b5 102
key_restore                                                ;; @@46b5 102
; jsr put_io_in_map ;; @@46b5 102
                 jsr _doakey                              ; re-define the key ;; @@46b5 102
                 +lbcs omerr                              ; bad return (.c=1) ;; @@46b8 102
                 rts                                      ; ok return  (.c=0) ;; @@46bb 102
 ;; @@46bc 102
; .page ;; @@46bc 102
;************************************************************************ ;; @@46bc 102
;   Key_Load  Load function key definitions (from disk)   [900725] ;; @@46bc 102
;************************************************************************ ;; @@46bc 102
 ;; @@46bc 102
Key_load                                                   ;; @@46bc 102
                 jsr GetLoadChannel                       ; get a channel      [911001] ;; @@46bc 102
                 ldy #>_pky_lengths                        ;; @@46bf 102
                 lda #<_pky_lengths                        ;; @@46c1 102
                 jsr LoadBlock                            ; load it ;; @@46c3 102
                 +lbra list_err                           ; release channel, close file, return to main ;; @@46c6 102
 ;; @@46c9 102
 ;; @@46c9 102
GetLoadChannel                                            ; Used by KeyLoad and SpriteLoad    [911001] ;; @@46c9 102
                 jsr chrget                               ; eat LOAD token ;; @@46c9 102
                 lda #$e6                                 ; parse:  filename [,U#] [,D#] ;; @@46cc 102
                 jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 ) ;; @@46ce 102
                 jsr chk1                                 ; check parameters ;; @@46d1 102
                 lda #0                                    ;; @@46d4 102
                 sta dossa                                ; setup as dload would (0 = load channel) ;; @@46d6 102
                 jsr find_la                              ; find an unused LA to use (cannot use reserved one) ;; @@46d9 102
                 ldy #fopn                                 ;; @@46dc 102
                 ldx #4                                    ;; @@46de 102
                 jsr open_file                            ; open the file ;; @@46e0 102
                 bcs LoadEOF                              ; exit if problem ;; @@46e3 102
                 ldx dosla                                 ;; @@46e5 102
                 jsr _chkin                               ; get input channel ;; @@46e8 102
                 bcs LoadEOF                              ; exit if bad?? ;; @@46eb 102
                 jsr _basin                               ; waste dummy load address ;; @@46ed 102
                 jsr _basin                                ;; @@46f0 102
                 jsr _readst                              ; prevent corruption if there's a problem ;; @@46f3 102
                 bne LoadERR                              ; exit if problem ;; @@46f6 102
                 clc                                       ;; @@46f8 102
                 rts                                       ;; @@46f9 102
 ;; @@46fa 102
; .page ;; @@46fa 102
LoadBlock                                                  ;; @@46fa 102
                 sta highds                               ; where to put data ;; @@46fa 102
                 sty highds+1                              ;; @@46fc 102
LoadBlockNext                                              ;; @@46fe 102
                 ldy #0                                    ;; @@46fe 102
_local_1101_10   jsr _basin                               ; read definitions ;; @@4700 102
                 sta (highds),y                            ;; @@4703 102
                 jsr _readst                              ; check channel status ;; @@4705 102
                 bne LoadEOF                              ; exit if eof or error ;; @@4708 102
                 jsr _stop                                 ;; @@470a 102
                 beq LoadEOF                              ; exit if stop key down ;; @@470d 102
                 iny                                       ;; @@470f 102
                 bne _local_1101_10                       ; continue up to 1 page maximum ;; @@4710 102
                 clc                                      ; indicate "more" ;; @@4712 102
                 rts                                       ;; @@4713 102
 ;; @@4714 102
 ;; @@4714 102
LoadERR                                                    ;; @@4714 103
                 ldx #erload                              ; Load Error ;; @@4714 103
                 sec                                       ;; @@4716 103
                 !text $89                                 ;; @@4717 103
 ;; @@4718 103
LoadEOF                                                    ;; @@4718 103
                 clc                                       ;; @@4718 103
                 +lbra list_err                           ; release channel, close file, return to main ;; @@4719 103
 ;; @@471c 103
; .page ;; @@471c 103
;************************************************************************ ;; @@471c 103
;   Key_Save  Save function key definitions (from disk)   [900725] ;; @@471c 103
;************************************************************************ ;; @@471c 103
 ;; @@471c 103
Key_Save                                                   ;; @@471c 103
                 jsr GetSaveChannel                       ; [910930] ;; @@471c 103
                 lda #highds                              ; set starting & ending addresses ;; @@471f 103
                 ldy #>_pky_lengths                       ; start address & pointer to it ;; @@4721 103
                 ldx #<_pky_lengths                        ;; @@4723 103
                 sty highds+1                              ;; @@4725 103
                 stx highds                                ;; @@4727 103
                 iny                                      ; end address = start address + 256 + 1 ;; @@4729 103
                 inx                                       ;; @@472a 103
                 +lbra savenb                             ; [910925] ;; @@472b 103
; jsr _savesp  ;save it ;; @@472e 103
;; clc   ; return no error  ????why not  [910404] ;; @@472e 103
; bra exit_disk_op ; but if direct mode print DOS error  [910404] ;; @@472e 103
 ;; @@472e 103
 ;; @@472e 103
 ;; @@472e 103
GetSaveChannel                                            ; Used by KeySave and SpriteSave    [910930] ;; @@472e 103
                 jsr chrget                               ; eat SAVE token ;; @@472e 103
                 lda #$66                                 ; parse:  filename [,U#] [,D#] ;; @@4731 103
                 jsr dosprs                               ; parse options ;; @@4733 103
                 jsr chk2                                 ; check required parameters ;; @@4736 103
 ;; @@4739 103
                 ldy #fopn                                ; DOS table offset ;; @@4739 103
                 lda #4                                   ; length ;; @@473b 103
                 jsr sendp                                 ;; @@473d 103
                 lda #sys_bank                            ; set banks ???? buffer in system bank ???? ;; @@4740 103
                 ldx #sys_bank                             ;; @@4742 103
                 jmp _setbank                              ;; @@4744 103
 ;; @@4747 103
;.end ;; @@4747 103
; .page ;; @@4747 103
; .subttl  BANK ;; @@4747 103
 ;; @@4747 103
;************************************************************************ ;; @@4747 103
;*  Set Memory Bank for PEEK,POKE,WAIT,BLOAD,BSAVE and SYS,BOOT Commands ;; @@4747 103
;* ;; @@4747 103
;*  Syntax: BANK DATA  n  for PEEK,POKE,WAIT,BLOAD,BSAVE ;; @@4747 103
;*  BANK SYS  [a,x,y,z] for SYS,BOOT Commands ;; @@4747 103
;* ;; @@4747 103
;* where   n=  %11111111  to access I/O area (System MAP) ;; @@4747 103
;*      %0xxxxxxx to use physical bank n ;; @@4747 103
;* ;; @@4747 103
;* or      a,x,y,z  describe precise configuration for MAPper ;; @@4747 103
;*    if omitted, the System MAP is to be used. ;; @@4747 103
;* ;; @@4747 103
;* The DATA option is to access data,  i.e., LDA/STA_far ;; @@4747 103
;* The SYS  option is to execute code, i.e., JMP/JSR_far ;; @@4747 103
;* ;; @@4747 103
;*  Idea: BANK SCREEN n  when REC is finalized???? ;; @@4747 103
;************************************************************************ ;; @@4747 103
 ;; @@4747 103
bank             jsr getbyt                               ; get bank number in .x ;; @@4747 103
                 stx current_bank                          ;; @@474a 103
                 rts                                       ;; @@474d 103
 ;; @@474e 103
 ;; @@474e 103
;.end ;; @@474e 103
; .page ;; @@474e 103
; .subttl  PLAY ;; @@474e 103
 ;; @@474e 103
; C65 Music Interpreter ;; @@474e 103
; ;; @@474e 103
; Syntax : PLAY "music_string" ;; @@474e 103
; ;; @@474e 103
; Where : music_string is a string of characters composed of: ;; @@474e 103
; ;; @@474e 103
; A..G   : notes ;; @@474e 103
; W,H,Q,I,S : set note lengths to whole,half,quarter,eighth,sixteenth ;; @@474e 103
; U   : set volume level   (0-9) ;; @@474e 103
; O   : set octave    (0-6) ;; @@474e 103
; T   : set current envelope  (0-9) ;; @@474e 103
; V   : select voice to play  (1-6: 1-3 right, 4-6 left) ;; @@474e 103
; X   : filter    (0-1: 0=off, 1=on) ;; @@474e 103
; M   : measure ;; @@474e 103
; R   : rest ;; @@474e 103
; .   : dot ;; @@474e 103
; #   : sharp ;; @@474e 103
; $   : flat ;; @@474e 103
 ;; @@474e 103
 ;; @@474e 103
play             jsr frmstr                               ; frmevl,frestr,return w/ .A=len, (index)=>string ;; @@474e 103
; sta sw_rom_ram0  ;???? ;; @@4751 103
                 sta z_p_temp_1                           ; save number of characters ;; @@4751 103
                 jsr clear_play_flags                     ; set 'dot' and 'sharp' to 0. return with Acc=0 ;; @@4753 103
                 sta hulp                                 ; zero counter ;; @@4756 103
 ;; @@4758 103
_local_1102_10   ldy hulp                                  ;; @@4758 103
                 cpy z_p_temp_1                            ;; @@475a 103
                 beq play_rts                             ; done! ;; @@475c 103
                 jsr indin1_ram1                           ;; @@475e 103
                 jsr play_one_character                    ;; @@4761 103
                 inc hulp                                  ;; @@4764 103
                 bne _local_1102_10                       ; always ;; @@4766 103
play_rts                                                   ;; @@4768 104
                 rts                                       ;; @@4768 104
 ;; @@4769 104
; .page ;; @@4769 104
play_one_character                                           ;; @@4769 104
                 cmp #' '                                 ; spaces are a 'no-op' ;; @@4769 104
                 beq play_rts                              ;; @@476b 104
 ;; @@476d 104
_local_1103_5    cmp #'A'                                 ; note name a-g? ;; @@476d 104
                 bcc _local_1103_10                        ;; @@476f 104
                 cmp #'H'                                  ;; @@4771 104
                 +lbcc play_note                          ; yes...play it ;; @@4773 104
 ;; @@4776 104
_local_1103_10   ldx #4                                   ; test for notes,'w,h,q,i,s' ;; @@4776 104
_local_1103_20   cmp notes,x                               ;; @@4778 104
                 +lbeq set_note_length                     ;; @@477b 104
                 dex                                       ;; @@477e 104
                 bpl _local_1103_20                        ;; @@477f 104
 ;; @@4781 104
                 cmp #'R'                                 ; rest? ;; @@4781 104
                 +lbeq play_rest                           ;; @@4783 104
                 cmp #'.'                                 ; dotted note? ;; @@4786 104
                 +lbeq play_dot                            ;; @@4788 104
 ;; @@478b 104
                 ldx #5                                   ; test for v,o,t,x,u,m commands ;; @@478b 104
_local_1103_30   cmp mutabl,x                              ;; @@478d 104
                 +lbeq play_command                        ;; @@4790 104
                 dex                                       ;; @@4793 104
                 bpl _local_1103_30                       ; test all 5 characters in table ;; @@4794 104
 ;; @@4796 104
                 cmp #'#'                                 ; sharp? ;; @@4796 104
                 +lbeq play_sharp                          ;; @@4798 104
                 cmp #'$'                                 ; flat? ;; @@479b 104
                 +lbeq play_flat                           ;; @@479d 104
 ;; @@47a0 104
; .page ;; @@47a0 104
; Must be a digit here for Octave, Voice, envelope (T), filter (X), or volume (U) ;; @@47a0 104
 ;; @@47a0 104
                 sec                                       ;; @@47a0 104
                 sbc #'0'                                 ; mask nybble ;; @@47a1 104
                 cmp #10                                  ; must be in range 0..9 ;; @@47a3 104
                 +lbcs play_bad_value                      ;; @@47a5 104
 ;; @@47a8 104
                 asl flag                                 ; octave, voice, envelope, filter, or volume? ;; @@47a8 104
                 bcs set_voice                             ;; @@47ab 104
                 asl flag                                 ; octave, envelope, filter, or volume? ;; @@47ad 104
                 bcs set_octave                            ;; @@47b0 104
                 asl flag                                 ; envelope, filter, or volume? ;; @@47b2 104
                 bcs set_envelope                          ;; @@47b5 104
                 asl flag                                 ; filter or volume? ;; @@47b7 104
                 bcc set_volume                            ;; @@47ba 104
 ;; @@47bc 104
set_filter                                                 ;; @@47bc 105
                 jsr wait_for_all_quiet                   ; [910722] ;; @@47bc 105
                 cmp #2                                    ;; @@47bf 105
                 +lbcs play_bad_value                     ; value too large ;; @@47c1 105
                 lsr                                      ; .c=on/off ;; @@47c4 105
                 ldy voice                                ; 0-5 ;; @@47c5 105
                 ldx filter_offset,y                      ; 0 0 0 4 4 4 ;; @@47c8 105
                 lda filters1+2,x                         ; get current filter data for this SID  [910612] ;; @@47cb 105
                 ora vbits,y                              ; update filter voice bit ;; @@47ce 105
                 bcs _local_1104_20                       ; branch to turn filter on ;; @@47d1 105
                 eor vbits,y                              ; else, turn filter off   [910612] ;; @@47d3 105
 ;; @@47d6 105
_local_1104_20   sta filters1+2,x                          ;; @@47d6 105
; lda filters1+3,x ;why????     [910612] ;; @@47d9 105
; sta filters1+4,x ;save new filter-type/volume ;; @@47d9 105
 ;; @@47d9 105
; jsr put_io_in_map ;; @@47d9 105
                 lda SID_offset,y                         ; get hardware offset for current voice ;; @@47d9 105
                 and #$f0                                 ; $00 or $20 ;; @@47dc 105
                 tay                                       ;; @@47de 105
; jsr go_slow  ;      [910716] 4567R7A ;; @@47df 105
                 ldz #3                                    ;; @@47df 105
_local_1104_30   lda filters1,x                           ; update the hardware ;; @@47e1 105
                 sta sid1+21,y                             ;; @@47e4 105
                 inx                                       ;; @@47e7 105
                 iny                                       ;; @@47e8 105
                 dez                                       ;; @@47e9 105
                 bpl _local_1104_30                        ;; @@47ea 105
; jsr go_fast  ;      [910716] 4567R7A ;; @@47ec 105
                 bra clear_flag                           ; always ;; @@47ec 105
 ;; @@47ee 105
; .page ;; @@47ee 105
set_voice                                                  ;; @@47ee 106
                 dec                                       ;; @@47ee 106
                 cmp #6                                   ; stereo SIDs: 0-2=right, 3-5=left  [910612] ;; @@47ef 106
                 +lbcs play_bad_value                      ;; @@47f1 106
                 sta voice                                ; 0-5 ;; @@47f4 106
                 bra clear_flag                           ; always ;; @@47f7 106
 ;; @@47f9 106
 ;; @@47f9 106
set_octave                                                 ;; @@47f9 106
                 cmp #7                                    ;; @@47f9 106
                 +lbcs play_bad_value                     ; too big octave ;; @@47fb 106
                 sta octave                               ; set octave ;; @@47fe 106
                 bra clear_flag                           ; always ;; @@4801 106
 ;; @@4803 106
 ;; @@4803 106
set_envelope                                               ;; @@4803 106
                 jsr wait_for_quiet                       ; [910626] ;; @@4803 106
                 tax                                       ;; @@4806 106
set_envelope_1                                            ; entry for initialization code ;; @@4807 106
; jsr put_io_in_map ;; @@4807 106
                 ldy voice                                 ;; @@4807 106
                 lda wavtab,x                              ;; @@480a 106
                 sta waveform,y                           ; set waveform ;; @@480d 106
                 lda SID_offset,y                         ; get hardware offset for this voice ;; @@4810 106
                 tay                                       ;; @@4813 106
; jsr go_slow  ;      [910716] 4567R7A ;; @@4814 106
                 lda atktab,x                              ;; @@4814 106
                 sta sid1+5,y                             ; set attack/decay ;; @@4817 106
                 lda sustab,x                              ;; @@481a 106
                 sta sid1+6,y                             ; set sustain/release ;; @@481d 106
                 lda pulslw,x                              ;; @@4820 106
                 sta sid1+2,y                             ; set pulse width - low byte ;; @@4823 106
                 lda pulshi,x                              ;; @@4826 106
                 sta sid1+3,y                             ; set pulse width - high byte ;; @@4829 106
; jsr go_fast  ;      [910716] 4567R7A ;; @@482c 106
                 bra clear_flag                            ;; @@482c 106
 ;; @@482e 106
; .page ;; @@482e 106
set_volume                                                 ;; @@482e 106
                 jsr wait_for_all_quiet                   ; [910626] ;; @@482e 106
                 tax                                       ;; @@4831 106
                 ldy voice                                ; [910612] ;; @@4832 106
                 lda filter_offset,y                      ; get filter offset for this voice ;; @@4835 106
                 tay                                       ;; @@4838 106
                 lda filters1+3,y                         ; get mode/volume for this SID ;; @@4839 106
                 and #$f0                                 ; mask out old volume ;; @@483c 106
                 ora voltab,x                             ; add new volume ;; @@483e 106
                 sta filters1+3,y                         ; save for filter change ;; @@4841 106
; lda filters1+4,y ;get current filter-type/volume ????why  [910612] ;; @@4844 106
; and #$f0 ;; @@4844 106
; ora voltab,x ;; @@4844 106
                 tax                                       ;; @@4844 106
                 ldy voice                                 ;; @@4845 106
                 lda SID_offset,y                         ; get hardware offset for current voice ;; @@4848 106
                 and #$f0                                 ; $00 or $20 ;; @@484b 106
                 tay                                       ;; @@484d 106
; jsr go_slow  ;      [910716] 4567R7A ;; @@484e 106
                 stx sid1+24,y                            ; set new volume ;; @@484e 106
; jsr go_fast  ;      [910716] 4567R7A ;; @@4851 106
;fall into clear_flag ;; @@4851 106
; .page ;; @@4851 106
clear_flag                                                 ;; @@4851 106
                 lda #0                                    ;; @@4851 106
                 sta flag                                  ;; @@4853 106
                 rts                                       ;; @@4856 106
 ;; @@4857 106
 ;; @@4857 106
go_fast                                                    ;; @@4857 106
                 lda sid_speed_flag                        ;; @@4857 106
                 tsb vic+49                                ;; @@4859 106
                 rts                                       ;; @@485c 106
 ;; @@485d 106
 ;; @@485d 106
go_slow                                                    ;; @@485d 106
                 pha                                       ;; @@485d 106
                 lda #$40                                  ;; @@485e 106
                 and vic+49                                ;; @@4860 106
                 trb vic+49                                ;; @@4863 106
                 sta sid_speed_flag                        ;; @@4866 106
                 pla                                       ;; @@4868 106
                 rts                                       ;; @@4869 106
 ;; @@486a 106
 ;; @@486a 106
wait_for_quiet                                            ; Wait for current voice to be quiet  [910626] ;; @@486a 106
                 ldy voice                                 ;; @@486a 106
                 ldx times2,y                             ; voice*2 ;; @@486d 106
_local_1105_10   bit voices+1,x                           ; test if voice is active   [910617] ;; @@4870 106
                 bpl _local_1105_10                       ; loop until inactive (IRQ) ;; @@4873 106
                 rts                                       ;; @@4875 106
 ;; @@4876 106
 ;; @@4876 106
wait_for_all_quiet                                          ; Wait for all voices on this SID to be quiet [910626] ;; @@4876 107
                 ldy #3                                    ;; @@4876 107
                 ldx voice                                 ;; @@4878 107
                 cpx #3                                   ; determine left/right SID ;; @@487b 107
                 bcs _local_1106_10                        ;; @@487d 107
                 ldy #0                                    ;; @@487f 107
_local_1106_10   ldz #3                                   ; for each of 3 voices ;; @@4881 107
_local_1106_20   ldx times2,y                              ;; @@4883 107
_local_1106_30   bit voices+1,x                           ; wait for voice to be inactive (IRQ) ;; @@4886 107
                 bpl _local_1106_30                        ;; @@4889 107
                 iny                                      ; next voice ;; @@488b 107
                 dez                                       ;; @@488c 107
                 bne _local_1106_20                       ; until done 3 voices ;; @@488d 107
                 rts                                       ;; @@488f 107
 ;; @@4890 107
; .page ;; @@4890 107
play_bad_value                                             ;; @@4890 108
                 jsr clear_flag                            ;; @@4890 108
                 +lbra fcerr                              ; illegal quantity ;; @@4893 108
 ;; @@4896 108
play_dot                                                   ;; @@4896 108
                 sta dnote                                 ;; @@4896 108
                 rts                                       ;; @@4899 108
 ;; @@489a 108
 ;; @@489a 108
 ;; @@489a 108
set_note_length                                            ;; @@489a 108
; ldy #<beats  ;found note (.x), divide beats accordingly ;; @@489a 108
; sty ntime ;; @@489a 108
; ldy #>beats ;; @@489a 108
; sty ntime+1 ;; @@489a 108
 ;; @@489a 108
                 bit _pal_ntsc                            ; determine if PAL or NTSC system  [910724] ;; @@489a 108
                 bmi _local_1107_1                        ; ...branch if PAL ;; @@489d 108
                 ldz #<beats_ntsc                         ; (whole note 4/4 time = 2 sec) ;; @@489f 108
                 ldy #>beats_ntsc                          ;; @@48a1 108
                 bra _local_1107_2                         ;; @@48a3 108
_local_1107_1    ldz #<beats_pal                           ;; @@48a5 108
                 ldy #>beats_pal                           ;; @@48a7 108
_local_1107_2    stz ntime                                 ;; @@48a9 108
                 sty ntime+1                               ;; @@48ac 108
 ;; @@48af 108
_local_1107_10   dex                                       ;; @@48af 108
                 bmi _local_1107_20                       ; finished dividing, exit ;; @@48b0 108
                 lsr ntime+1                               ;; @@48b2 108
                 ror ntime                                 ;; @@48b5 108
                 bra _local_1107_10                        ;; @@48b8 108
 ;; @@48ba 108
_local_1107_20   rts                                       ;; @@48ba 108
 ;; @@48bb 108
; .page ;; @@48bb 108
play_note                                                  ;; @@48bb 109
                 sec                                       ;; @@48bb 109
                 sbc #'A'                                  ;; @@48bc 109
                 tax                                       ;; @@48be 109
                 lda scalen,x                             ; note #0-11 ;; @@48bf 109
                 tax                                       ;; @@48c2 109
                 lda #6                                    ;; @@48c3 109
                 sec                                       ;; @@48c5 109
                 sbc octave                                ;; @@48c6 109
                 tay                                       ;; @@48c9 109
                 txa                                       ;; @@48ca 109
                 clc                                       ;; @@48cb 109
                 adc sharp                                 ;; @@48cc 109
                 bpl _local_1108_10                       ; added sharp or nat ;; @@48cf 109
                 lda #11                                  ; underflow ;; @@48d1 109
                 iny                                      ; bump octave down ;; @@48d3 109
_local_1108_10   cmp #12                                  ; overflow? ;; @@48d4 109
                 bcc _local_1108_20                       ; no... ;; @@48d6 109
                 lda #0                                    ;; @@48d8 109
                 dey                                      ; bump octave up ;; @@48da 109
_local_1108_20   tax                                       ;; @@48db 109
                 lda scalel,x                              ;; @@48dc 109
                 sta pitch                                 ;; @@48df 109
 ;; @@48e2 109
                 bit _pal_ntsc                            ; determine if PAL or NTSC system ;; @@48e2 109
                 bmi _local_1108_25                       ; ...branch if PAL ;; @@48e5 109
                 lda scaleh,x                             ; continue as before patch ;; @@48e7 109
                 bra _local_1108_30                        ;; @@48ea 109
 ;; @@48ec 109
_local_1108_25   lda scalelp,x                            ; load from PAL tables ;; @@48ec 109
                 sta pitch                                 ;; @@48ef 109
                 lda scalehp,x                             ;; @@48f2 109
 ;; @@48f5 109
_local_1108_30   dey                                       ;; @@48f5 109
                 bmi play_note_1                          ; go play note ;; @@48f6 109
                 lsr                                       ;; @@48f8 109
                 ror pitch                                 ;; @@48f9 109
                 bra _local_1108_30                        ;; @@48fc 109
 ;; @@48fe 109
; .page ;; @@48fe 109
play_command                                               ;; @@48fe 110
                 cmp #'M'                                 ; measure? ;; @@48fe 110
                 beq _local_1109_10                        ;; @@4900 110
 ;; @@4902 110
                 lda rbits,x                              ; all others, set flag for next number ;; @@4902 110
                 sta flag                                  ;; @@4905 110
                 rts                                       ;; @@4908 110
 ;; @@4909 110
; Wait for msb of all 3 voice counters to underflow ;; @@4909 110
 ;; @@4909 110
;_local_1109_10 ldy #5 ;; @@4909 110
;_local_1109_20 lda voices,y ;; @@4909 110
; bpl _local_1109_20 ;; @@4909 110
; dey ;; @@4909 110
; dey ;; @@4909 110
; bpl _local_1109_20 ;; @@4909 110
; rts ;; @@4909 110
 ;; @@4909 110
_local_1109_10   ldy #5                                   ; [910626] ;; @@4909 110
_local_1109_20   ldx times2,y                              ;; @@490b 110
_local_1109_30   bit voices+1,x                           ; wait for voice to be inactive (IRQ) ;; @@490e 110
                 bpl _local_1109_30                        ;; @@4911 110
                 dey                                      ; next voice ;; @@4913 110
                 bpl _local_1109_20                       ; until done 6 voices ;; @@4914 110
                 rts                                       ;; @@4916 110
 ;; @@4917 110
 ;; @@4917 110
 ;; @@4917 110
play_sharp                                                 ;; @@4917 111
                 lda #1                                    ;; @@4917 111
                 !text $2c                                 ;; @@4919 111
play_flat                                                  ;; @@491a 111
                 lda #$ff                                  ;; @@491a 111
                 sta sharp                                 ;; @@491c 111
                 rts                                       ;; @@491f 111
 ;; @@4920 111
; .page ;; @@4920 111
play_note_1                                               ; play a note ;; @@4920 111
                 sta pitch+1                               ;; @@4920 111
                 lda #0                                   ; flag 'not rest' ;; @@4923 111
                 !text $2c                                ; hop ;; @@4925 111
play_rest                                                  ;; @@4926 111
                 lda #$ff                                 ; flag 'rest' ;; @@4926 111
                 pha                                      ; save flag ;; @@4928 111
                 ldx voice                                 ;; @@4929 111
                 ldy times2,x                             ; y=x*2 ;; @@492c 111
_local_1110_10   lda voices+1,y                           ; test if there is a note playing ;; @@492f 111
                 bpl _local_1110_10                       ; and loop if so ;; @@4932 111
 ;; @@4934 111
                 sei                                       ;; @@4934 111
                 lda ntime                                ; load counter for current length ;; @@4935 111
                 sta voices,y                              ;; @@4938 111
                 lda ntime+1                               ;; @@493b 111
                 sta voices+1,y                            ;; @@493e 111
                 lda dnote                                ; test if this is a dotted note ;; @@4941 111
                 beq _local_1110_20                       ; no ;; @@4944 111
                 lda ntime+1                               ;; @@4946 111
                 lsr                                      ; duration is 1.5 x current length ;; @@4949 111
                 pha                                       ;; @@494a 111
                 lda ntime                                 ;; @@494b 111
                 ror                                       ;; @@494e 111
                 clc                                       ;; @@494f 111
                 adc voices,y                              ;; @@4950 111
                 sta voices,y                              ;; @@4953 111
                 pla                                       ;; @@4956 111
                 adc voices+1,y                            ;; @@4957 111
                 sta voices+1,y                            ;; @@495a 111
 ;; @@495d 111
_local_1110_20   pla                                      ; test if this is a rest ;; @@495d 111
                 bmi _local_1110_30                       ; and branch if so- clear play flags and exit [910722] ;; @@495e 111
 ;; @@4960 111
; jsr put_io_in_map ;; @@4960 111
; jsr go_slow  ;      [910716] 4567R7A ;; @@4960 111
                 ldy SID_offset,x                         ; get offset to voice hardware ;; @@4960 111
                 lda pitch                                 ;; @@4963 111
                 sta sid1,y                                ;; @@4966 111
                 lda pitch+1                               ;; @@4969 111
                 sta sid1+1,y                              ;; @@496c 111
                 lda #$08                                 ; reset this voice ;; @@496f 111
                 sta sid1+4,y                              ;; @@4971 111
                 lda waveform,x                           ; and finally, turn on gate ;; @@4974 111
                 sta sid1+4,y                              ;; @@4977 111
; jsr go_fast  ;      [910716] 4567R7A ;; @@497a 111
_local_1110_30   cli                                       ;; @@497a 111
 ;; @@497b 111
; .page ;; @@497b 111
clear_play_flags                                           ;; @@497b 112
                 lda #0                                    ;; @@497b 112
                 sta sharp                                ; clear flags ;; @@497d 112
                 sta dnote                                 ;; @@4980 112
                 cli                                       ;; @@4983 112
                 rts                                       ;; @@4984 112
 ;; @@4985 112
 ;; @@4985 112
tempo            jsr getbyt                               ; duration of whole note 4/4 time = 24/rate ;; @@4985 112
                 txa                                       ;; @@4988 112
                 +lbeq fcerr                              ; can't be zero- illegal quantity error ;; @@4989 112
                 stx tempo_rate                            ;; @@498c 112
                 rts                                       ;; @@498f 112
 ;; @@4990 112
; .page ;; @@4990 112
times2           !text 0,2,4,6,8,10                       ; [910612] stereo ;; @@4990 112
 ;; @@4996 112
notes            !text "WHQIS"                            ; sixteenth,eigth,quarter,half,and whole notes ;; @@4996 112
 ;; @@499b 112
mutabl           !text "VOTXUM"                           ; voice,octave,envelope,filter,volume,& measure ;; @@499b 112
 ;; @@49a1 112
scalen           !text 9,11,0,2,4,5,7                     ; a,b,c,d,e,f,g ;; @@49a1 112
 ;; @@49a8 112
scalel           !text $0f,$0c,$46,$bf,$7d,$83            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (NTSC, octave 6) ;; @@49a8 112
                 !text $d6,$7a,$73,$c8,$7c,$97            ; [910729] ;; @@49ae 112
 ;; @@49b4 112
scaleh           !text $43,$47,$4b,$4f,$54,$59            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (NTSC, octave 6) ;; @@49b4 112
                 !text $5e,$64,$6a,$70,$77,$7e            ; [910729] ;; @@49ba 112
 ;; @@49c0 112
scalelp          !text $87,$8b,$cc,$4e,$14,$24            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (PAL,  octave 6) ;; @@49c0 112
                 !text $80,$2d,$32,$91,$52,$7a            ; [910729] ;; @@49c6 112
 ;; @@49cc 112
scalehp          !text $43,$47,$4b,$50,$55,$5a            ; c,c#,d,d#,e,f,f#,g,g#,a,a#,b (PAL,  octave 6) ;; @@49cc 112
                 !text $5f,$65,$6b,$71,$78,$7f            ; [910729] ;; @@49d2 112
 ;; @@49d8 112
;  Music envelope tables, default values downloaded to RAM: ;; @@49d8 112
; ;; @@49d8 112
; 0: piano   1: accordion    2: calliope  3: drum     4: flute ;; @@49d8 112
; 5: guitar  6: harpsichord  7: organ     8: trumpet  9: xylophone ;; @@49d8 112
 ;; @@49d8 112
;  Attack/decay rates ;; @@49d8 112
 ;; @@49d8 112
atkmus           !text $09,$c0,$00,$05,$94,$09,$09,$09,$89,$09  ;; @@49d8 112
 ;; @@49e2 112
;  Sustain/release rates ;; @@49e2 112
 ;; @@49e2 112
susmus           !text $00,$c0,$f0,$50,$40,$21,$00,$90,$41,$00  ;; @@49e2 112
 ;; @@49ec 112
;  Waveform table ;; @@49ec 112
 ;; @@49ec 112
wavmus           !text $41,$21,$11,$81,$11,$21,$41,$41,$41,$11  ;; @@49ec 112
 ;; @@49f6 112
;  Pulse width hi table ;; @@49f6 112
 ;; @@49f6 112
pwhmus           !text $06,$00,$00,$00,$00,$00,$02,$08,$02,$00  ;; @@49f6 112
 ;; @@4a00 112
;  Offset tables ;; @@4a00 112
 ;; @@4a00 112
SID_offset                                                 ;; @@4a00 112
                 !text $00,$07,$0e,$20,$27,$2e            ; [910612] stereo ;; @@4a00 112
filter_offset                                              ;; @@4a06 112
                 !text 0,0,0,4,4,4                         ;; @@4a06 112
 ;; @@4a0c 112
;  Volume levels ;; @@4a0c 112
 ;; @@4a0c 112
voltab           !text 0,1,3,5,7,8,10,12,14,15             ;; @@4a0c 112
 ;; @@4a16 112
;.end ;; @@4a16 112
; .page ;; @@4a16 112
; .subttl  FILTER ;; @@4a16 112
 ;; @@4a16 112
;****************************************************************** ;; @@4a16 112
; ;; @@4a16 112
;  FILTER  sid, freq, lp, bp, hp, res   --  set values for filter ;; @@4a16 112
; ;; @@4a16 112
;     sid =  right (1), left (2) ;; @@4a16 112
;          freq =  filter frequency (0-1023) ;; @@4a16 112
;            lp =  low pass filter on (1) or off (0) ;; @@4a16 112
;            bp =  band pass filter on (1) or off (0) ;; @@4a16 112
;            hp =  high pass filter on (1) or off (0) ;; @@4a16 112
;           res =  resonance (0-15) ;; @@4a16 112
; ;; @@4a16 112
;****************************************************************** ;; @@4a16 112
 ;; @@4a16 112
filter           jsr getbyt                               ; get left/right SID    [910612] ;; @@4a16 112
                 dex                                       ;; @@4a19 112
                 cpx #2                                    ;; @@4a1a 112
                 +lbcs fcerr                               ;; @@4a1c 112
                 lda filter_offset+2,x                    ; get filter offset for specified SID ;; @@4a1f 112
                 sta z_p_temp_1                            ;; @@4a22 112
                 tax                                       ;; @@4a24 112
 ;; @@4a25 112
                 ldy #0                                    ;; @@4a25 112
_local_1111_10   lda filters1,x                           ; save current voice's filter params ;; @@4a27 112
                 sta fltsav,y                              ;; @@4a2a 112
                 inx                                       ;; @@4a2d 112
                 iny                                       ;; @@4a2e 112
                 cpy #4                                    ;; @@4a2f 112
                 bcc _local_1111_10                        ;; @@4a31 112
 ;; @@4a33 112
                 jsr optwrd                               ; get filter frequency ;; @@4a33 112
                 bcc _local_1111_20                       ; skip if no value given ;; @@4a36 112
                 cmp #8                                   ; test m.s. byte ;; @@4a38 112
                 +lbcs fcerr                              ; error if > 2047 ;; @@4a3a 112
                 sty fltsav                               ; save lower byte ;; @@4a3d 112
 ;; @@4a40 112
; Idea: shift lower 3 bits of upper byte into lower byte, forming bits 10-3 ;; @@4a40 112
 ;; @@4a40 112
                 sty fltsav+1                              ;; @@4a40 112
                 lsr                                       ;; @@4a43 112
                 ror fltsav+1                              ;; @@4a44 112
                 lsr                                       ;; @@4a47 112
                 ror fltsav+1                             ; save upper 7 bits (10-3) ;; @@4a48 112
                 lsr                                       ;; @@4a4b 112
                 ror fltsav+1                              ;; @@4a4c 112
 ;; @@4a4f 112
_local_1111_20   lda #$10                                 ; start at type=LP ;; @@4a4f 112
                 sta fltflg                                ;; @@4a51 112
                 lda fltsav                                ;; @@4a54 112
 ;; @@4a57 112
_local_1111_30   jsr optbyt                               ; get filter types (LP,BP,HP) ;; @@4a57 112
                 bcc _local_1111_50                       ; skip if no value input ;; @@4a5a 112
                 cpx #1                                   ; (set .c: 0=0, 1=1) ;; @@4a5c 112
                 bcc _local_1111_35                        ;; @@4a5e 112
                 beq _local_1111_35                        ;; @@4a60 112
                 +lbra fcerr                              ; error if >1 ;; @@4a62 112
 ;; @@4a65 112
_local_1111_35   lda fltsav+3                             ; get filter flags byte ;; @@4a65 112
                 ora fltflg                               ; set filter on ;; @@4a68 112
                 bcs _local_1111_40                       ; skip if it should be on ;; @@4a6b 112
                 eor fltflg                               ; turn filter off ;; @@4a6d 112
_local_1111_40   sta fltsav+3                             ; save value ;; @@4a70 112
 ;; @@4a73 112
_local_1111_50   asl fltflg                               ; shift for next filter ;; @@4a73 112
                 bpl _local_1111_30                       ; loop 3 times ;; @@4a76 112
 ;; @@4a78 112
                 jsr optbyt                               ; get resonance value ;; @@4a78 112
                 bcc _local_1111_70                       ; skip if no value given ;; @@4a7b 112
; cpx #16 ;; @@4a7d 112
; bcs fcerr  ;error if >15 ;; @@4a7d 112
                 jsr chknyb                               ; [910930] ;; @@4a7d 112
                 txa                                       ;; @@4a80 112
                 asl                                      ; shift to upper nibble ;; @@4a81 112
                 asl                                       ;; @@4a82 112
                 asl                                       ;; @@4a83 112
                 asl                                       ;; @@4a84 112
                 sta nibble                                ;; @@4a85 112
                 lda fltsav+2                             ; get current value ;; @@4a88 112
                 and #$0f                                 ; mask it out ;; @@4a8b 112
                 ora nibble                               ; add new value ;; @@4a8d 112
                 sta fltsav+2                             ; save it ;; @@4a90 112
 ;; @@4a93 112
_local_1111_70   ldx z_p_temp_1                           ; hardware offset for this voice's filter [910612] ;; @@4a93 112
                 ldy #0                                    ;; @@4a95 112
_local_1111_80   lda fltsav,y                             ; copy new filter params to hardware ;; @@4a97 112
                 sta filters1,x                            ;; @@4a9a 112
                 inx                                       ;; @@4a9d 112
                 iny                                       ;; @@4a9e 112
                 cpy #4                                    ;; @@4a9f 112
                 bcc _local_1111_80                        ;; @@4aa1 112
                 rts                                       ;; @@4aa3 112
 ;; @@4aa4 112
;.end ;; @@4aa4 112
; .page ;; @@4aa4 112
; .subttl  ENVELOPE ;; @@4aa4 112
 ;; @@4aa4 112
;**************************************************************** ;; @@4aa4 112
; ;; @@4aa4 112
;  ENVELOPE n, attack, decay, sustain, release, waveform, pulse width ;; @@4aa4 112
;        set music envelope ;; @@4aa4 112
;                n = envelope number (0-9) ;; @@4aa4 112
;            wave  =   0 : triangle waveform ;; @@4aa4 112
;                      1 : sawtooth waveform ;; @@4aa4 112
;                      2 : pulse waveform ;; @@4aa4 112
;                      3 : noise waveform ;; @@4aa4 112
;                      4 : ring modulation ;; @@4aa4 112
;            pulse = pulse width if pulse waveform is selected (0-4095) ;; @@4aa4 112
; ;; @@4aa4 112
;****************************************************************** ;; @@4aa4 112
 ;; @@4aa4 112
envelope                                                   ;; @@4aa4 113
                 jsr getbyt                               ; get envelope number ;; @@4aa4 113
                 cpx #10                                   ;; @@4aa7 113
                 +lbcs fcerr                              ; exit - invalid tone number ;; @@4aa9 113
                 stx tonnum                               ; save number ;; @@4aac 113
                 lda atktab,x                             ; get attack/decay rates ;; @@4aaf 113
                 sta tonval                                ;; @@4ab2 113
                 lda sustab,x                             ; get sustain/release rates ;; @@4ab5 113
                 sta tonval+1                              ;; @@4ab8 113
                 lda wavtab,x                             ; get waveform and filter ;; @@4abb 113
                 sta tonval+2                              ;; @@4abe 113
 ;; @@4ac1 113
                 ldx #0                                    ;; @@4ac1 113
_local_1112_20   stx parcnt                                ;; @@4ac3 113
                 jsr optbyt                               ; get parameter - attack or sustain ;; @@4ac6 113
                 bcc _local_1112_30                       ; skip if no input ;; @@4ac9 113
                 txa                                       ;; @@4acb 113
                 asl                                       ;; @@4acc 113
                 asl                                      ; shift to upper nibble ;; @@4acd 113
                 asl                                       ;; @@4ace 113
                 asl                                       ;; @@4acf 113
                 sta nibble                               ; save it ;; @@4ad0 113
                 ldx parcnt                                ;; @@4ad3 113
                 lda tonval,x                             ; get current value ;; @@4ad6 113
                 and #$0f                                 ; mask it out ;; @@4ad9 113
                 ora nibble                               ; add new value ;; @@4adb 113
                 sta tonval,x                             ; save it ;; @@4ade 113
 ;; @@4ae1 113
_local_1112_30   jsr optbyt                               ; get decay or release rate ;; @@4ae1 113
                 bcc _local_1112_40                       ; skip if no input ;; @@4ae4 113
                 txa                                       ;; @@4ae6 113
                 and #$0f                                 ; use only lower nibble ;; @@4ae7 113
                 sta nibble                               ; save it ;; @@4ae9 113
                 ldx parcnt                                ;; @@4aec 113
                 lda tonval,x                             ; get current value ;; @@4aef 113
                 and #$f0                                 ; mask it out ;; @@4af2 113
                 ora nibble                               ; add new value ;; @@4af4 113
                 sta tonval,x                             ; save it ;; @@4af7 113
 ;; @@4afa 113
_local_1112_40   ldx parcnt                                ;; @@4afa 113
                 inx                                       ;; @@4afd 113
                 cpx #1                                    ;; @@4afe 113
                 beq _local_1112_20                       ; loop to do sustain/release rates ;; @@4b00 113
                 jsr optbyt                               ; get waveform ;; @@4b02 113
                 bcc _local_1112_90                       ; skip if no value ;; @@4b05 113
                 lda #$15                                 ; assume ring modulation ;; @@4b07 113
                 cpx #4                                    ;; @@4b09 113
                 beq _local_1112_80                       ; skip if correct ;; @@4b0b 113
                 +lbcs fcerr                              ; error if >4 ;; @@4b0d 113
                 lda sbits+4,x                            ; get waveform bit ;; @@4b10 113
                 ora #1                                   ; set gate bit ;; @@4b13 113
 ;; @@4b15 113
_local_1112_80   sta tonval+2                             ; save waveform ;; @@4b15 113
 ;; @@4b18 113
_local_1112_90   jsr optwrd                               ; is there a pulse width arg? ;; @@4b18 113
                 bcc _local_1112_110                      ; nope, done ;; @@4b1b 113
 ;; @@4b1d 113
                 tax                                      ; save msb ;; @@4b1d 113
                 lda tonval+2                             ; get waveform ;; @@4b1e 113
                 and #$40                                  ;; @@4b21 113
                 beq _local_1112_110                      ; skip if not pulse waveform ;; @@4b23 113
                 txa                                       ;; @@4b25 113
                 ldx tonnum                               ; get envelope number ;; @@4b26 113
                 sta pulshi,x                             ; save high byte of pulse width ;; @@4b29 113
                 tya                                       ;; @@4b2c 113
                 sta pulslw,x                             ; save low byte ;; @@4b2d 113
 ;; @@4b30 113
_local_1112_110  ldx tonnum                                ;; @@4b30 113
                 lda tonval                               ; set inputted values ;; @@4b33 113
                 sta atktab,x                              ;; @@4b36 113
                 lda tonval+1                              ;; @@4b39 113
                 sta sustab,x                              ;; @@4b3c 113
                 lda tonval+2                              ;; @@4b3f 113
                 sta wavtab,x                              ;; @@4b42 113
volrts                                                     ;; @@4b45 114
                 rts                                       ;; @@4b45 114
 ;; @@4b46 114
;.end ;; @@4b46 114
; .page ;; @@4b46 114
; .subttl  VOLUME ;; @@4b46 114
 ;; @@4b46 114
;*************************************************************** ;; @@4b46 114
;* ;; @@4b46 114
;*  VOLUME - set volume of SID chips ;; @@4b46 114
;* ;; @@4b46 114
;* Syntax : VOLUME [right] [,left] ;; @@4b46 114
;* ;; @@4b46 114
;* Where  : vol in 0..15 ;; @@4b46 114
;* ;; @@4b46 114
;*************************************************************** ;; @@4b46 114
 ;; @@4b46 114
volume           +lbeq snerr                              ; stereo parameters    [910612] ;; @@4b46 114
                 cmp #','                                  ;; @@4b49 114
                 beq _local_1113_10                       ; left volume only ;; @@4b4b 114
; jsr getbyt  ;right volume in .x ;; @@4b4d 114
; cpx #16 ;; @@4b4d 114
; bcs fcerr  ;too large ;; @@4b4d 114
                 jsr getnyb                               ; [910930] ;; @@4b4d 114
                 stx z_p_temp_1                           ; a temp (sorry fred) ;; @@4b50 114
 ;; @@4b52 114
; The way this is done must work with 'PLAY' without too much conflict. ;; @@4b52 114
; So, along with setting the SID 'volume' reg, we'll also set up PLAY's ;; @@4b52 114
; record of current volume as well. ;; @@4b52 114
 ;; @@4b52 114
                 lda filters1+3                            ;; @@4b52 114
                 and #$f0                                  ;; @@4b55 114
                 ora z_p_temp_1                            ;; @@4b57 114
                 sta filters1+3                            ;; @@4b59 114
 ;; @@4b5c 114
; lda filters1+4  ;???? why     [910612] ;; @@4b5c 114
; and #$f0 ;; @@4b5c 114
; ora z_p_temp_1 ;; @@4b5c 114
; sta filters1+4 ;; @@4b5c 114
 ;; @@4b5c 114
; jsr put_io_in_map ;; @@4b5c 114
; jsr go_slow  ;      [910716] 4567R7A ;; @@4b5c 114
                 sta sid1+24                               ;; @@4b5c 114
; jsr go_fast  ;      [910716] 4567R7A ;; @@4b5f 114
                 jsr chrgot                                ;; @@4b5f 114
                 beq volrts                                ;; @@4b62 114
 ;; @@4b64 114
_local_1113_10   jsr optbyt                               ; get optional left parameter   [910612] ;; @@4b64 114
                 +lbcc snerr                              ; comma but no value not given?? ;; @@4b67 114
                 jsr chknyb                               ; [910930] ;; @@4b6a 114
; cpx #16 ;; @@4b6d 114
; bcs fcerr  ;too large ;; @@4b6d 114
                 stx z_p_temp_1                           ; a temp (sorry fred) ;; @@4b6d 114
 ;; @@4b6f 114
                 lda filters2+3                            ;; @@4b6f 114
                 and #$f0                                  ;; @@4b72 114
                 ora z_p_temp_1                            ;; @@4b74 114
                 sta filters2+3                            ;; @@4b76 114
 ;; @@4b79 114
; lda filters2+4  ;???? why     [910612] ;; @@4b79 114
; and #$f0 ;; @@4b79 114
; ora z_p_temp_1 ;; @@4b79 114
; sta filters2+4 ;; @@4b79 114
 ;; @@4b79 114
; jsr put_io_in_map ;; @@4b79 114
; jsr go_slow  ;      [910716] 4567R7A ;; @@4b79 114
                 sta sid2+24                               ;; @@4b79 114
; jsr go_fast  ;      [910716] 4567R7A ;; @@4b7c 114
                 rts                                       ;; @@4b7c 114
 ;; @@4b7d 114
;.end ;; @@4b7d 114
; .page ;; @@4b7d 114
; .subttl  SOUND ;; @@4b7d 114
 ;; @@4b7d 114
;***************************************************************************** ;; @@4b7d 114
;* ;; @@4b7d 114
;*  SOUND - Produce sound effects ;; @@4b7d 114
;* ;; @@4b7d 114
;* Syntax : SOUND v, f, d [,[dir] [,[m] [,[s] [,[w] [,p] ]]]] ;; @@4b7d 114
;* ;; @@4b7d 114
;* Where : v   = voice    (1..6) ;; @@4b7d 114
;*  f   = frequency    (0..65535) ;; @@4b7d 114
;*  d   = duration    (0..32767 jiffys) ;; @@4b7d 114
;*  dir = step direction  (0(up) ,1(down) or 2(oscillate)) default=0 ;; @@4b7d 114
;*  m   = minimum frequency  (if sweep is used) (0..65535) default=0 ;; @@4b7d 114
;*  s   = step value for effects  (0..32767) default=0 ;; @@4b7d 114
;*  w   = waveform  (0=triangle,1=saw,2=square,3=noise) default=2 ;; @@4b7d 114
;*  p   = pulse width  (0..4095) default=2048 (50% duty cycle) ;; @@4b7d 114
;* ;; @@4b7d 114
;***************************************************************************** ;; @@4b7d 114
 ;; @@4b7d 114
sound            cmp #clr_token                           ; SOUND CLR: init sound/music environment [910717] ;; @@4b7d 115
                 +lbeq Sound_CLR                          ; yes ;; @@4b7f 115
 ;; @@4b82 115
                 jsr getbyt                               ; get voice number in .X ;; @@4b82 115
                 dex                                      ; adjust 1..3 to 0..2 ;; @@4b85 115
                 cpx #6                                   ; [910612] ;; @@4b86 115
_local_1114_98   +lbcs fcerr                              ; illegal value ;; @@4b88 115
 ;; @@4b8b 115
_local_1114_10   stx sound_voice                           ;; @@4b8b 115
 ;; @@4b8e 115
; Get frequency ;; @@4b8e 115
 ;; @@4b8e 115
                 jsr comwrd                               ; eat comma, get frequency in y,a ;; @@4b8e 115
                 sty temp_max_lo                          ; save our copy of max, also set up as current ;; @@4b91 115
                 sta temp_max_hi                           ;; @@4b94 115
                 sty temp_freq_lo                          ;; @@4b97 115
                 sta temp_freq_hi                          ;; @@4b9a 115
 ;; @@4b9d 115
; Get duration ;; @@4b9d 115
 ;; @@4b9d 115
                 jsr comwrd                               ; eat comma, get number of jiffys to play ;; @@4b9d 115
                 cmp #$80                                  ;; @@4ba0 115
                 bcs _local_1114_98                        ;; @@4ba2 115
                 sty temp_time_lo                          ;; @@4ba4 115
                 sta temp_time_hi                          ;; @@4ba7 115
 ;; @@4baa 115
; Get sweep direction ;; @@4baa 115
 ;; @@4baa 115
                 jsr optzer                               ; get optional sweep (default = 0, up) ;; @@4baa 115
                 cpx #3                                    ;; @@4bad 115
                 bcs _local_1114_98                        ;; @@4baf 115
                 txa                                       ;; @@4bb1 115
                 sta temp_direction                        ;; @@4bb2 115
                 and #1                                   ; set .Z if sweep up or oscillate ;; @@4bb5 115
                 php                                      ; save .Z for step (below) ;; @@4bb7 115
 ;; @@4bb8 115
; Get minimum frequency value (sweep lo) ;; @@4bb8 115
 ;; @@4bb8 115
                 jsr optwrd                                ;; @@4bb8 115
                 sty temp_min_lo                           ;; @@4bbb 115
                 sta temp_min_hi                           ;; @@4bbe 115
 ;; @@4bc1 115
; Get step value for sweep ;; @@4bc1 115
 ;; @@4bc1 115
                 jsr optwrd                               ; get optional step, default is zero ;; @@4bc1 115
                 plp                                      ; get flags from direction ;; @@4bc4 115
                 beq _local_1114_75                       ; branch if 'up' or oscillate ;; @@4bc5 115
                 pha                                      ; if 'down', make step 2's complement ;; @@4bc7 115
                 tya                                       ;; @@4bc8 115
                 eor #$ff                                  ;; @@4bc9 115
                 clc                                       ;; @@4bcb 115
                 adc #1                                    ;; @@4bcc 115
                 tay                                       ;; @@4bce 115
                 pla                                       ;; @@4bcf 115
                 eor #$ff                                  ;; @@4bd0 115
                 adc #0                                    ;; @@4bd2 115
_local_1114_75   sta temp_step_hi                          ;; @@4bd4 115
                 tya                                       ;; @@4bd7 115
                 sta temp_step_lo                          ;; @@4bd8 115
 ;; @@4bdb 115
; Get waveform ;; @@4bdb 115
 ;; @@4bdb 115
                 ldx #2                                   ; get waveform. default is square (2) ;; @@4bdb 115
                 jsr optbyt                                ;; @@4bdd 115
                 cpx #4                                    ;; @@4be0 115
                 bcs _local_1114_98                       ; illegal value ;; @@4be2 115
                 lda sbits+4,x                            ; get bit pattern for selected waveform ;; @@4be4 115
                 ora #1                                   ; add in the gate bit ;; @@4be7 115
                 sta temp_waveform                         ;; @@4be9 115
 ;; @@4bec 115
; Get pulse width ;; @@4bec 115
 ;; @@4bec 115
                 jsr optwrd                               ; get optional pulse width in y,a ;; @@4bec 115
                 bcs _local_1114_80                        ;; @@4bef 115
                 lda #8                                   ; no arg's given, use default pulse width ;; @@4bf1 115
                 ldy #0                                    ;; @@4bf3 115
_local_1114_80   cmp #16                                   ;; @@4bf5 115
                 bcs _local_1114_98                        ;; @@4bf7 115
                 sty temp_pulse_lo                         ;; @@4bf9 115
                 sta temp_pulse_hi                         ;; @@4bfc 115
 ;; @@4bff 115
; All arg's in, time to get to work ;; @@4bff 115
 ;; @@4bff 115
                 lda temp_time_lo                          ;; @@4bff 115
                 ora temp_time_hi                          ;; @@4c02 115
                 beq _local_1114_100                      ; special case: time=0 means 'kill it NOW' ;; @@4c05 115
 ;; @@4c07 115
; Wait for all current uses of this voice to time out ;; @@4c07 115
 ;; @@4c07 115
                 ldx sound_voice                          ; first test 'PLAY' ;; @@4c07 115
                 txa                                      ; make an index into PLAY's tables ;; @@4c0a 115
                 asl                                       ;; @@4c0b 115
                 tay                                       ;; @@4c0c 115
_local_1114_60   lda voices+1,y                            ;; @@4c0d 115
                 bpl _local_1114_60                        ;; @@4c10 115
 ;; @@4c12 115
_local_1114_70   lda sound_time_hi,x                      ; now test 'SOUND' ;; @@4c12 115
                 bpl _local_1114_70                        ;; @@4c15 115
 ;; @@4c17 115
; All clear, now set up for current effect ;; @@4c17 115
 ;; @@4c17 115
                 ldy #0                                   ; download max freq l&h, min freq l&h, ;; @@4c17 115
_local_1114_90   lda temp_max_lo,y                        ; ..sweep direction, step value l&h, & freq l&h ;; @@4c19 115
                 sta sound_max_lo,x                        ;; @@4c1c 115
                 inx                                       ;; @@4c1f 115
                 inx                                       ;; @@4c20 115
                 inx                                       ;; @@4c21 115
                 inx                                      ; [910612] stereo ;; @@4c22 115
                 inx                                       ;; @@4c23 115
                 inx                                       ;; @@4c24 115
                 iny                                       ;; @@4c25 115
                 cpy #9                                    ;; @@4c26 115
                 bcc _local_1114_90                        ;; @@4c28 115
 ;; @@4c2a 115
; Now set up SID ;; @@4c2a 115
 ;; @@4c2a 115
                 ldx sound_voice                           ;; @@4c2a 115
                 ldy SID_offset,x                         ; get index to SID voices ;; @@4c2d 115
; jsr put_io_in_map ;; @@4c30 115
; jsr go_slow  ;      [910716] 4567R7A ;; @@4c30 115
 ;; @@4c30 115
                 lda #$08                                 ; turn off SID gate ;; @@4c30 115
                 sta sid1+4,y                              ;; @@4c32 115
 ;; @@4c35 115
                 lda #0                                   ; set up attack & decay, ;; @@4c35 115
                 sta sid1+5,y                              ;; @@4c37 115
                 lda #$f0                                 ; ..and sustain & release ;; @@4c3a 115
                 sta sid1+6,y                              ;; @@4c3c 115
 ;; @@4c3f 115
                 ldx #0                                   ; set up freq (l&h), pulse width (l&h), & waveform ;; @@4c3f 115
_local_1114_95   lda temp_freq_lo,x                        ;; @@4c41 115
                 sta sid1,y                                ;; @@4c44 115
                 iny                                       ;; @@4c47 115
                 inx                                       ;; @@4c48 115
                 cpx #5                                    ;; @@4c49 115
                 bne _local_1114_95                        ;; @@4c4b 115
; jsr go_fast  ;      [910716] 4567R7A ;; @@4c4d 115
 ;; @@4c4d 115
; Now set up time to play ;; @@4c4d 115
 ;; @@4c4d 115
_local_1114_100  ldx sound_voice                           ;; @@4c4d 115
                 ldy temp_time_lo                          ;; @@4c50 115
                 lda temp_time_hi                          ;; @@4c53 115
 ;; @@4c56 115
                 sei                                       ;; @@4c56 115
                 sta sound_time_hi,x                       ;; @@4c57 115
                 tya                                       ;; @@4c5a 115
                 sta sound_time_lo,x                       ;; @@4c5b 115
                 cli                                       ;; @@4c5e 115
 ;; @@4c5f 115
                 rts                                       ;; @@4c5f 115
 ;; @@4c60 115
;.end ;; @@4c60 115
; .page ;; @@4c60 115
; .subttl  WINDOW ;; @@4c60 115
 ;; @@4c60 115
;**************************************************************** ;; @@4c60 115
;* ;; @@4c60 115
;*  WINDOW Command ;; @@4c60 115
;* ;; @@4c60 115
;*  Syntax : WINDOW upper-left col, upper-left row, ;; @@4c60 115
;*      lower-left col, lower-right row [,clear] ;; @@4c60 115
;* ;; @@4c60 115
;*  Where  :  0 <= row <= 24 ;; @@4c60 115
;*       0 <= column <= (80/40) ;; @@4c60 115
;*       clear : 0 (no) or 1 (yes) ;; @@4c60 115
;* ;; @@4c60 115
;**************************************************************** ;; @@4c60 115
 ;; @@4c60 115
window           jsr getbyt                               ; get u.l. col ;; @@4c60 116
                 cpx #80                                   ;; @@4c63 116
                 bbr7 _mode,_local_1115_10                 ;; @@4c65 116
                 cpx #40                                   ;; @@4c68 116
_local_1115_10   bcs _local_1115_98                        ;; @@4c6a 116
                 stx window_temp                           ;; @@4c6c 116
 ;; @@4c6f 116
                 jsr combyt                               ; get u.l. row ;; @@4c6f 116
                 cpx #25                                   ;; @@4c72 116
                 bcs _local_1115_98                        ;; @@4c74 116
                 stx window_temp+1                         ;; @@4c76 116
 ;; @@4c79 116
                 jsr combyt                               ; get l.r. column ;; @@4c79 116
                 cpx #80                                   ;; @@4c7c 116
                 bbr7 _mode,_local_1115_20                 ;; @@4c7e 116
                 cpx #40                                   ;; @@4c81 116
_local_1115_20   bcs _local_1115_98                        ;; @@4c83 116
                 stx window_temp+2                         ;; @@4c85 116
                 cpx window_temp                          ; can't be less than u.l. column ;; @@4c88 116
                 bcc _local_1115_98                        ;; @@4c8b 116
 ;; @@4c8d 116
                 jsr combyt                               ; get l.r. row ;; @@4c8d 116
                 cpx #25                                   ;; @@4c90 116
                 bcs _local_1115_98                        ;; @@4c92 116
                 stx window_temp+3                         ;; @@4c94 116
                 cpx window_temp+1                        ; can't be less than u.l. row ;; @@4c97 116
                 bcc _local_1115_98                        ;; @@4c9a 116
 ;; @@4c9c 116
                 jsr optzer                               ; get optional clear flag ;; @@4c9c 116
                 cpx #2                                    ;; @@4c9f 116
                 bcs _local_1115_98                        ;; @@4ca1 116
                 phx                                       ;; @@4ca3 116
 ;; @@4ca4 116
                 ldx window_temp                           ;; @@4ca4 116
                 lda window_temp+1                         ;; @@4ca7 116
                 clc                                       ;; @@4caa 116
                 jsr _set_window                           ;; @@4cab 116
 ;; @@4cae 116
                 ldx window_temp+2                         ;; @@4cae 116
                 lda window_temp+3                         ;; @@4cb1 116
                 sec                                       ;; @@4cb4 116
                 jsr _set_window                           ;; @@4cb5 116
 ;; @@4cb8 116
                 ldx #19                                  ; assume 'home', not 'cls' ;; @@4cb8 116
                 pla                                       ;; @@4cba 116
                 beq _local_1115_30                        ;; @@4cbb 116
                 ldx #147                                  ;; @@4cbd 116
_local_1115_30   txa                                       ;; @@4cbf 116
                 jmp _bsout                                ;; @@4cc0 116
 ;; @@4cc3 116
_local_1115_98   +lbra fcerr                              ; illegal value error ;; @@4cc3 116
 ;; @@4cc6 116
;.end ;; @@4cc6 116
; .page ;; @@4cc6 116
; .subttl  FAST  SLOW ;; @@4cc6 116
 ;; @@4cc6 116
;*********************************************************************** ;; @@4cc6 116
; ;; @@4cc6 116
;    FAST - put the system in FAST (4 MHz?) mode. ;; @@4cc6 116
; ;; @@4cc6 116
;*********************************************************************** ;; @@4cc6 116
 ;; @@4cc6 116
fast                                                       ;; @@4cc6 117
                 +lbne snerr                              ; no args      [910410] ;; @@4cc6 117
; jsr put_io_in_map ;; @@4cc9 117
                 lda #%01000000                            ;; @@4cc9 117
                 tsb vic+49                               ; set FAST (4MHz?) mode ;; @@4ccb 117
                 rts                                       ;; @@4cce 117
 ;; @@4ccf 117
 ;; @@4ccf 117
 ;; @@4ccf 117
;*********************************************************************** ;; @@4ccf 117
; ;; @@4ccf 117
;    SLOW - put the system in SLOW (1 MHz) mode. ;; @@4ccf 117
; ;; @@4ccf 117
;*********************************************************************** ;; @@4ccf 117
 ;; @@4ccf 117
slow                                                       ;; @@4ccf 117
                 +lbne snerr                              ; no args      [910410] ;; @@4ccf 117
; jsr put_io_in_map ;; @@4cd2 117
                 lda #%01000000                            ;; @@4cd2 117
                 trb vic+49                                ;; @@4cd4 117
                 rts                                       ;; @@4cd7 117
 ;; @@4cd8 117
;.end ;; @@4cd8 117
; .page ;; @@4cd8 117
; .subttl Check Value Types ;; @@4cd8 117
 ;; @@4cd8 117
; These routines check for certain VALTYP.   (c) is not preserved. ;; @@4cd8 117
 ;; @@4cd8 117
 ;; @@4cd8 117
 ;; @@4cd8 117
frmnum           jsr frmevl                                ;; @@4cd8 117
 ;; @@4cdb 117
chknum           clc                                       ;; @@4cdb 117
                 !text $89                                 ;; @@4cdc 117
 ;; @@4cdd 117
chkstr           sec                                       ;; @@4cdd 117
 ;; @@4cde 117
chkval                                                     ;; @@4cde 117
; bbs7 valtyp,docstr ;cannot do this- return status +/-/= needed! ;; @@4cde 117
                 bit valtyp                                ;; @@4cde 117
                 bmi docstr                                ;; @@4ce0 117
                 bcs chkerr                                ;; @@4ce2 117
chkok            rts                                       ;; @@4ce4 117
 ;; @@4ce5 117
docstr           bcs chkok                                 ;; @@4ce5 117
 ;; @@4ce7 117
chkerr           ldx #errtm                                ;; @@4ce7 117
                 !text $2c                                 ;; @@4ce9 117
 ;; @@4cea 117
sterr            ldx #errst                                ;; @@4cea 117
                 +lbra error                               ;; @@4cec 117
 ;; @@4cef 117
;.end ;; @@4cef 117
; .page ;; @@4cef 117
; .subttl Formula Evaluator ;; @@4cef 117
 ;; @@4cef 117
; Formula Evaluator Routine ;; @@4cef 117
; ;; @@4cef 117
; The formula evaluator starts with (txtptr) pointing to the first character ;; @@4cef 117
; in the formula.  At the end (txtptr) points to the terminator. ;; @@4cef 117
; The result is left in the FAC.  On return (a) does not reflect the terminator. ;; @@4cef 117
; ;; @@4cef 117
; The formula evaluator uses the operator (optab) to determine precedence and ;; @@4cef 117
; dispatch addresses for each operator. ;; @@4cef 117
; A temporary result on the stack has the following format: ;; @@4cef 117
; ;; @@4cef 117
;     * The address of the operator routine. ;; @@4cef 117
;     * The floating point temporary result. ;; @@4cef 117
;     * The precedence of the operator. ;; @@4cef 117
 ;; @@4cef 117
 ;; @@4cef 117
frmevl           dew txtptr                               ; txtptr points to 1st char. in formula ;; @@4cef 117
                 ldx #0                                   ; dummy precedence = 0 ;; @@4cf1 117
                 !text $89                                 ;; @@4cf3 117
 ;; @@4cf4 117
lpoper           pha                                      ; save precedence ;; @@4cf4 117
                 phx                                       ;; @@4cf5 117
                 tsx                                      ; confirm enough system stack available (recursive calls) ;; @@4cf6 117
                 cpx #<sysstk+44                          ; bottom of stack + room for error handling ;; @@4cf7 117
                 bcc sterr                                ; formula too complex ;; @@4cf9 117
                 jsr eval                                  ;; @@4cfb 117
                 lda #0                                    ;; @@4cfe 117
                 sta opmask                                ;; @@4d00 117
 ;; @@4d02 117
tstop            jsr chrgot                               ; last char ;; @@4d02 117
loprel           sec                                      ; prepare to subtract ;; @@4d05 117
                 sbc #greater_token                       ; is current character a relation? ;; @@4d06 117
                 bcc endrel                               ; no, relations all through ;; @@4d08 117
                 cmp #less_token-greater_token+1           ;; @@4d0a 117
                 bcs endrel                               ; really relational?  no, just big ;; @@4d0c 117
                 cmp #1                                   ; reset carry for zero only ;; @@4d0e 117
                 rol                                      ; 0 to 1, 1 to 2, 2 to 4 ;; @@4d10 117
                 eor #1                                    ;; @@4d11 117
                 eor opmask                               ; bring in the old bits ;; @@4d13 117
                 cmp opmask                               ; make sure that the new mask is bigger ;; @@4d15 117
                 +lbcc snerr                              ; syntax error, because two of the same ;; @@4d17 117
                 sta opmask                               ; save mask ;; @@4d1a 117
                 jsr chrget                                ;; @@4d1c 117
                 bra loprel                               ; get the next candidate ;; @@4d1f 117
 ;; @@4d21 117
; .page ;; @@4d21 117
endrel           ldx opmask                               ; were there any? ;; @@4d21 117
                 bne finrel                               ; yes, handle as special op ;; @@4d23 117
                 +lbcs qop                                ; not an operator ;; @@4d25 117
                 adc #greater_token-plus_token             ;; @@4d28 117
                 +lbcc qop                                ; not an operator ;; @@4d2a 117
                 adc valtyp                               ; (c)=1 ;; @@4d2d 117
                 +lbeq cat                                ; only if (a)=0 and VALTYP=$FF (a string) ;; @@4d2f 117
 ;; @@4d32 117
                 adc #$ff                                 ; get back original (a) ;; @@4d32 117
                 sta index1                                ;; @@4d34 117
                 asl                                      ; multiply by two ;; @@4d36 117
                 adc index1                               ; by three ;; @@4d37 117
                 tay                                      ; set up for later ;; @@4d39 117
 ;; @@4d3a 117
qprec            pla                                      ; get previous precedence ;; @@4d3a 117
                 cmp optab,y                              ; is old precedence greater or equal? ;; @@4d3b 117
                 bcs qchnum                               ; yes, go operate ;; @@4d3e 117
                 jsr chknum                               ; can't be string here ;; @@4d40 117
 ;; @@4d43 117
doprec           pha                                      ; save old precedence ;; @@4d43 117
 ;; @@4d44 117
negprc           jsr dopre1                               ; save a return for op ;; @@4d44 117
                 pla                                      ; pull off previous precedence ;; @@4d47 117
                 ldy opptr                                ; get pointer to op ;; @@4d48 117
                 bpl qprec1                               ; that's a real operator ;; @@4d4a 117
                 tax                                      ; done? ;; @@4d4c 117
                 beq qopgo                                ; done! ;; @@4d4d 117
                 bra pulstk                                ;; @@4d4f 117
 ;; @@4d51 117
; .page ;; @@4d51 117
finrel           lsr valtyp                               ; get value type into (c) ;; @@4d51 117
                 txa                                       ;; @@4d53 117
                 rol                                      ; put VALTYP into low order bit of mask ;; @@4d54 117
                 dew txtptr                               ; decrement text pointer ;; @@4d55 117
                 ldy #ptdorl-optab                        ; make (y) point at operator entry ;; @@4d57 117
                 sta opmask                               ; save the operation mask ;; @@4d59 117
                 bra qprec                                ; branch always ;; @@4d5b 117
 ;; @@4d5d 117
 ;; @@4d5d 117
qprec1                                                    ; note b7(VALTYP)=0 so CHKNUM call is ok ;; @@4d5d 117
                 cmp optab,y                              ; last precedence is greater? ;; @@4d5d 117
                 bcs pulstk                               ; yes, go operate ;; @@4d60 117
                 bcc doprec                               ; no, save argument and get other operand ;; @@4d62 117
 ;; @@4d64 117
 ;; @@4d64 117
dopre1           lda optab+2,y                             ;; @@4d64 117
                 pha                                      ; disp addr goes on stack ;; @@4d67 117
                 lda optab+1,y                             ;; @@4d68 117
                 pha                                       ;; @@4d6b 117
                 jsr pushf1                               ; save FAC on stack unpacked, precedence in (x) ;; @@4d6c 117
                 lda opmask                               ; (a) may be mask for rel ;; @@4d6f 117
                 bra lpoper                                ;; @@4d71 117
 ;; @@4d73 117
; .page ;; @@4d73 117
pushf1                                                    ; save FAC on stack unpacked ;; @@4d73 117
                 pla                                      ; first grab return address off stack ;; @@4d73 117
                 sta index1                                ;; @@4d74 117
                 pla                                       ;; @@4d76 117
                 sta index1+1                              ;; @@4d77 117
                 inw index1                                ;; @@4d79 117
 ;; @@4d7b 117
                 ldx optab,y                              ; precedence ;; @@4d7b 117
                 ldy facsgn                                ;; @@4d7e 117
                 phy                                       ;; @@4d80 117
                 jsr round                                ; put rounded FAC on stack ;; @@4d81 117
                 lda faclo                                 ;; @@4d84 117
                 pha                                       ;; @@4d86 117
                 lda facmo                                 ;; @@4d87 117
                 pha                                       ;; @@4d89 117
                 lda facmoh                                ;; @@4d8a 117
                 pha                                       ;; @@4d8c 117
                 lda facho                                 ;; @@4d8d 117
                 pha                                       ;; @@4d8f 117
                 lda facexp                                ;; @@4d90 117
                 pha                                       ;; @@4d92 117
                 jmp (index1)                             ; return ;; @@4d93 117
 ;; @@4d96 117
 ;; @@4d96 117
pullf1                                                    ; retrieve FAC from stack unpacked  [910402] ;; @@4d96 117
                 pla                                      ; first grab return address off stack ;; @@4d96 117
                 sta index1                                ;; @@4d97 117
                 pla                                       ;; @@4d99 117
                 sta index1+1                              ;; @@4d9a 117
                 inw index1                                ;; @@4d9c 117
 ;; @@4d9e 117
                 lda #0                                   ; it's been rounded ;; @@4d9e 117
                 sta facov                                 ;; @@4da0 117
                 pla                                       ;; @@4da2 117
                 sta facexp                                ;; @@4da3 117
                 pla                                       ;; @@4da5 117
                 sta facho                                 ;; @@4da6 117
                 pla                                       ;; @@4da8 117
                 sta facmoh                                ;; @@4da9 117
                 pla                                       ;; @@4dab 117
                 sta facmo                                 ;; @@4dac 117
                 pla                                       ;; @@4dae 117
                 sta faclo                                 ;; @@4daf 117
                 pla                                       ;; @@4db1 117
                 sta facsgn                                ;; @@4db2 117
                 jmp (index1)                             ; return ;; @@4db4 117
 ;; @@4db7 117
; .page ;; @@4db7 117
qop              ldy #255                                  ;; @@4db7 117
                 pla                                      ; get high precedence of last op ;; @@4db9 117
qopgo            beq qoprts                               ; done! ;; @@4dba 117
 ;; @@4dbc 117
qchnum           cmp #100                                 ; relational operator? ;; @@4dbc 117
                 beq unpstk                               ; yes, don't check operand ;; @@4dbe 117
                 jsr chknum                               ; must be number ;; @@4dc0 117
 ;; @@4dc3 117
unpstk           sty opptr                                ; save operator's pointer for next time ;; @@4dc3 117
pulstk           pla                                      ; get mask for rel op if it is one ;; @@4dc5 117
                 lsr                                      ; setup .c for dorel's chkval ;; @@4dc6 117
                 sta domask                               ; save for "docmp" ;; @@4dc7 117
                 pla                                      ; unpack stack into arg ;; @@4dc9 117
                 sta argexp                                ;; @@4dca 117
                 pla                                       ;; @@4dcc 117
                 sta argho                                 ;; @@4dcd 117
                 pla                                       ;; @@4dcf 117
                 sta argmoh                                ;; @@4dd0 117
                 pla                                       ;; @@4dd2 117
                 sta argmo                                 ;; @@4dd3 117
                 pla                                       ;; @@4dd5 117
                 sta arglo                                 ;; @@4dd6 117
                 pla                                       ;; @@4dd8 117
                 sta argsgn                                ;; @@4dd9 117
                 eor facsgn                               ; get probable result sign ;; @@4ddb 117
                 sta arisgn                               ; sign used by add, sub, mul, div ;; @@4ddd 117
 ;; @@4ddf 117
qoprts           lda facexp                               ; get it and set codes ;; @@4ddf 117
                 rts                                      ; return ;; @@4de1 117
; .page ;; @@4de2 117
eval             jmp (ieval)                               ;; @@4de2 117
 ;; @@4de5 117
neval            lda #0                                   ; assume numeric ;; @@4de5 117
                 sta valtyp                                ;; @@4de7 117
 ;; @@4de9 117
eval0            jsr chrget                               ; get a character ;; @@4de9 117
                 bcs eval2                                 ;; @@4dec 117
eval1            ldx #0                                   ; flag 'bank 0' (text bank) ;; @@4dee 117
                 +lbra fin                                ; it is a number ;; @@4df0 117
 ;; @@4df3 117
eval2            jsr isletc                               ; variable name? ;; @@4df3 117
                 bcs is_variable                          ; yes. ;; @@4df6 117
                 cmp #pi                                  ; pi? ;; @@4df8 117
                 bne qdot                                  ;; @@4dfa 117
                 lda #<pival                               ;; @@4dfc 117
                 ldy #>pival                               ;; @@4dfe 117
                 jsr movfm                                ; put value in for p1. ;; @@4e00 117
                 jmp chrget                                ;; @@4e03 117
 ;; @@4e06 117
 ;; @@4e06 117
qdot             cmp #'.'                                 ; constant? ;; @@4e06 117
                 beq eval1                                 ;; @@4e08 117
                 cmp #minus_token                         ; negation? ;; @@4e0a 117
                 beq domin                                ; yes. ;; @@4e0c 117
                 cmp #plus_token                           ;; @@4e0e 117
                 beq eval0                                 ;; @@4e10 117
                 cmp #'"'                                 ; string? ;; @@4e12 117
                 bne eval3                                 ;; @@4e14 117
 ;; @@4e16 117
strtxt           lda txtptr                                ;; @@4e16 117
                 ldy txtptr+1                              ;; @@4e18 117
                 adc #0                                   ; c=1 ;; @@4e1a 117
                 bcc strtx2                                ;; @@4e1c 117
                 iny                                       ;; @@4e1e 117
strtx2           jsr strlit                               ; process string ;; @@4e1f 117
 ;; @@4e22 117
st2txt           ldx strng2                                ;; @@4e22 117
                 ldy strng2+1                              ;; @@4e24 117
                 stx txtptr                                ;; @@4e26 117
                 sty txtptr+1                              ;; @@4e28 117
                 rts                                       ;; @@4e2a 117
 ;; @@4e2b 117
; .page ;; @@4e2b 117
eval3            cmp #not_token                           ; not? ;; @@4e2b 117
                 bne eval4                                 ;; @@4e2d 117
                 ldy #24                                   ;; @@4e2f 117
                 bne gonprc                               ; branch always ;; @@4e31 117
 ;; @@4e33 117
 ;; @@4e33 117
notop            jsr ayint                                ; integerize ;; @@4e33 117
                 lda faclo                                ; get argument ;; @@4e36 117
                 eor #$ff                                  ;; @@4e38 117
                 tay                                       ;; @@4e3a 117
                 lda facmo                                 ;; @@4e3b 117
                 eor #$ff                                  ;; @@4e3d 117
 ;; @@4e3f 117
givayf           jsr stoint                               ; integer to float routine ;; @@4e3f 117
                 +lbra floats                              ;; @@4e42 117
 ;; @@4e45 117
 ;; @@4e45 117
eval4            cmp #fn_token                            ; user defined function? ;; @@4e45 117
                 +lbeq fndoer                             ; yes ;; @@4e47 117
                 cmp #first_function_token                ; function name? ;; @@4e4a 117
                 +lbcs isfun                              ; yes ;; @@4e4c 117
; (functions are the highest numbered ;; @@4e4f 117
; tokens so no need to check further) ;; @@4e4f 117
; .page ;; @@4e4f 117
parchk           jsr chkopn                               ; only thing left is formula in parens ;; @@4e4f 117
                 jsr frmevl                               ; a formula in parens ;; @@4e52 117
 ;; @@4e55 117
chkcls           lda #')'                                 ; close paren? ;; @@4e55 117
                 !text $2c                                 ;; @@4e57 117
 ;; @@4e58 117
chkopn           lda #'('                                 ; open paren? ;; @@4e58 117
                 !text $2c                                 ;; @@4e5a 117
 ;; @@4e5b 117
chkcom           lda #','                                 ; comma? ;; @@4e5b 117
 ;; @@4e5d 117
 ;; @@4e5d 117
; SYNCHR looks at the current character to make sure it is the specific ;; @@4e5d 117
; thing loaded into (a) just before the call to SYNCHR.  If not, it calls ;; @@4e5d 117
; the "syntax error" routine.  Otherwise it gobbles the next char and returns. ;; @@4e5d 117
; ;; @@4e5d 117
; (a)=new char and TXTPTR is advanced by CHRGET. ;; @@4e5d 117
 ;; @@4e5d 117
 ;; @@4e5d 117
synchr           ldy #0                                    ;; @@4e5d 117
                 sta syntmp                                ;; @@4e5f 117
                 jsr indtxt                                ;; @@4e61 117
                 cmp syntmp                                ;; @@4e64 117
                 +lbne snerr                               ;; @@4e66 117
                 jmp chrget                               ; ok ;; @@4e69 117
 ;; @@4e6c 117
 ;; @@4e6c 117
 ;; @@4e6c 117
domin                                                      ;; @@4e6c 117
_local_1116_10   =negtab-optab                            ; negoff ;; @@4e6c 117
                 ldy #_local_1116_10                      ; precedence below '-' ;; @@4e6c 117
 ;; @@4e6e 117
gonprc           pla                                      ; get rid of rts addr. ;; @@4e6e 118
                 pla                                       ;; @@4e6f 118
                 +lbra negprc                             ; do negation ;; @@4e70 118
 ;; @@4e73 118
;.end ;; @@4e73 118
; .page ;; @@4e73 118
; .subttl Variable Assignment ;; @@4e73 118
 ;; @@4e73 118
is_variable                                                ;; @@4e73 118
                 jsr ptrget                               ; parse variable name, put name in varnam ;; @@4e73 118
 ;; @@4e76 118
isvret           sta facmo                                ; save pointer to variable ;; @@4e76 118
                 sty facmo+1                               ;; @@4e78 118
                 ldx varnam                                ;; @@4e7a 118
                 ldy varnam+1                              ;; @@4e7c 118
                 lda valtyp                                ;; @@4e7e 118
                 beq is_numeric                           ; branch if numeric ;; @@4e80 118
 ;; @@4e82 118
                 lda #0                                    ;; @@4e82 118
                 sta facov                                 ;; @@4e84 118
                 cpx #'T'                                 ; TI$ is a special case. look for it ;; @@4e86 118
                 bne isvds                                ; no- go test for DS$ ;; @@4e88 118
                 cpy #'I'+$80                             ; shifted I? ;; @@4e8a 118
                 bne ds_rts                               ; no- and it's not DS$ either ;; @@4e8c 118
 ;; @@4e8e 118
; Variable name is TI$.  To see if this is 'the' TI$ and not an ;; @@4e8e 118
; array TI$(), test to see if it has a pointer to the zero in "ROM". ;; @@4e8e 118
; If it is an array item, its pointer will be to a real value, or ;; @@4e8e 118
; a real zero.  If it isn't an array item, its pointer will point ;; @@4e8e 118
; to a dummy zero in "ROM". ;; @@4e8e 118
 ;; @@4e8e 118
                 lda facmo+1                               ;; @@4e8e 118
                 cmp #>zero                                ;; @@4e90 118
                 bne ds_rts                               ; not TI$, not DS$ ;; @@4e92 118
                 lda facmo                                 ;; @@4e94 118
                 cmp #<zero                                ;; @@4e96 118
                 bne ds_rts                                ;; @@4e98 118
                 +lbra Get_TI_String                      ; the one and only TI$ ;; @@4e9a 118
 ;; @@4e9d 118
; .page ;; @@4e9d 118
isvds            cpx #'D'                                 ; is this DS$? ;; @@4e9d 118
                 bne ds_rts                               ; no ;; @@4e9f 118
                 cpy #'S'+$80                             ; shifted S? ;; @@4ea1 118
                 bne ds_rts                               ; no ;; @@4ea3 118
 ;; @@4ea5 118
                 jsr Check_DS                             ; yes- check DS$ allocation, ;; @@4ea5 118
;  and get it if not in memory ;; @@4ea8 118
                 ldy #$ff                                  ;; @@4ea8 118
_local_1117_10   iny                                      ; copy DS$ to a temp. ;; @@4eaa 118
                 lda #dsdesc+1                            ; must first determine how big it is ;; @@4eab 118
                 jsr lda_far_ram1                         ; lda (dsdesc+1),y ;; @@4ead 118
                 bne _local_1117_10                       ; loop until terminating null found ;; @@4eb0 118
 ;; @@4eb2 118
                 tya                                      ; length of string required ;; @@4eb2 118
                 jsr strini                               ; get temp. string space & descriptor ;; @@4eb3 118
                 tay                                       ;; @@4eb6 118
                 beq _local_1117_30                       ; (don't bother copying if length is 0) ;; @@4eb7 118
 ;; @@4eb9 118
                 phx                                       ;; @@4eb9 118
 ;; @@4eba 118
                 ldx #dsctmp+1                            ; ???? was ldx #frespc ;; @@4eba 118
_local_1117_20   lda #dsdesc+1                            ; copy DS$ into temp ;; @@4ebc 118
                 dey                                       ;; @@4ebe 118
                 jsr lda_far_ram1                         ; lda (dsdesc+1),y ;; @@4ebf 118
                 jsr sta_far_ram1                         ; sta (dsctmp+1),y ;; @@4ec2 118
                 tya                                       ;; @@4ec5 118
                 bne _local_1117_20                        ;; @@4ec6 118
                 plx                                       ;; @@4ec8 118
                 lda dsdesc                               ; a=length     [901014] FAB ;; @@4ec9 118
                 jsr mvdone                               ; ???? (does nothing on C128 - bug or oversight?) ;; @@4ecb 118
 ;; @@4ece 118
_local_1117_30   +lbra putnew                              ;; @@4ece 118
 ;; @@4ed1 118
ds_rts           rts                                       ;; @@4ed1 119
 ;; @@4ed2 119
; .page ;; @@4ed2 119
is_numeric                                                 ;; @@4ed2 119
                 bbr7 intflg,is_floating                  ; branch if not an integer ;; @@4ed2 119
                 ldy #0                                    ;; @@4ed5 119
                 jsr indfmo                               ; fetch high ;; @@4ed7 119
                 tax                                       ;; @@4eda 119
                 iny                                       ;; @@4edb 119
                 jsr indfmo                               ; fetch low ;; @@4edc 119
                 tay                                      ; put low in y ;; @@4edf 119
                 txa                                      ; get high in a ;; @@4ee0 119
                 +lbra givayf                             ; float and return ;; @@4ee1 119
 ;; @@4ee4 119
 ;; @@4ee4 119
; Screen out TI, ST, ER, and EL, and assign values to them.  First test ;; @@4ee4 119
; if the pointer points to "ROM" zero.  If not, it can't be any of the above. ;; @@4ee4 119
 ;; @@4ee4 119
is_floating                                                ;; @@4ee4 119
                 lda facmo+1                               ;; @@4ee4 119
                 cmp #>zero                                ;; @@4ee6 119
                 bne gomovf                               ; not TI, etc. ;; @@4ee8 119
                 lda facmo                                 ;; @@4eea 119
                 cmp #<zero                                ;; @@4eec 119
                 bne gomovf                               ; not TI, etc. ;; @@4eee 119
 ;; @@4ef0 119
; .page ;; @@4ef0 119
; The pointer does point to the ROM zero.  Now it is necessary to ;; @@4ef0 119
; examine the actual variable name case by case. ;; @@4ef0 119
 ;; @@4ef0 119
                 cpx #'T'                                 ; TI? ;; @@4ef0 119
                 bne qstatv                               ; no ;; @@4ef2 119
                 cpy #'I'                                  ;; @@4ef4 119
                 bne gomovf                               ; no, and it can't be ST either ;; @@4ef6 119
                 +lbeq Get_TI                              ;; @@4ef8 119
 ;; @@4efb 119
 ;; @@4efb 119
qstatv           cpx #'S'                                 ; ST? ;; @@4efb 119
                 bne qdsav                                ; no, go test DS ;; @@4efd 119
                 cpy #'T'                                  ;; @@4eff 119
                 bne gomovf                                ;; @@4f01 119
                 jsr _readst                              ; (???? system bank for rs232 st) ;; @@4f03 119
                 +lbra float                               ;; @@4f06 119
 ;; @@4f09 119
 ;; @@4f09 119
qdsav            cpx #'D'                                 ; DS? ;; @@4f09 119
                 bne qerlin                               ; no, go test ER & EL ;; @@4f0b 119
                 cpy #'S'                                  ;; @@4f0d 119
                 bne gomovf                                ;; @@4f0f 119
 ;; @@4f11 119
; Get disk status - make the first two characters of DS$ string into a number. ;; @@4f11 119
 ;; @@4f11 119
                 jsr Check_DS                             ; get a DS$ string if one doesn't exist already ;; @@4f11 119
                 ldy #0                                    ;; @@4f14 119
                 lda #dsdesc+1                             ;; @@4f16 119
                 jsr lda_far_ram1                         ; lda (dsdesc+1),y ;; @@4f18 119
                 and #$0f                                  ;; @@4f1b 119
                 asl                                       ;; @@4f1d 119
                 sta garbfl                                ;; @@4f1e 119
                 asl                                       ;; @@4f20 119
                 asl                                       ;; @@4f21 119
                 adc garbfl                                ;; @@4f22 119
                 sta garbfl                                ;; @@4f24 119
                 iny                                       ;; @@4f26 119
                 lda #dsdesc+1                             ;; @@4f27 119
                 jsr lda_far_ram1                         ; lda (dsdesc+1),y ;; @@4f29 119
                 and #$0f                                  ;; @@4f2c 119
                 adc garbfl                                ;; @@4f2e 119
                 +lbra float                               ;; @@4f30 119
 ;; @@4f33 119
 ;; @@4f33 119
qerlin           cpx #'E'                                 ; ER or EL? ;; @@4f33 119
                 bne gomovf                                ;; @@4f35 119
                 cpy #'R'                                  ;; @@4f37 119
                 beq qnumer                                ;; @@4f39 119
                 cpy #'L'                                  ;; @@4f3b 119
                 bne gomovf                                ;; @@4f3d 119
 ;; @@4f3f 119
                 lda errlin+1                             ; want EL (last error line #) ;; @@4f3f 119
                 ldy errlin                                ;; @@4f42 119
                 +lbra nosflt                              ;; @@4f45 119
 ;; @@4f48 119
qnumer           lda errnum                               ; want ER (number of last error) ;; @@4f48 119
                 +lbra float                               ;; @@4f4b 119
 ;; @@4f4e 119
; .page ;; @@4f4e 119
gomovf           lda facmo                                 ;; @@4f4e 119
                 ldy facmo+1                               ;; @@4f50 119
 ;; @@4f52 119
movfrm           sta index1                               ; move value from RAM ;; @@4f52 119
                 sty index1+1                              ;; @@4f54 119
 ;; @@4f56 119
                 ldy #0                                    ;; @@4f56 119
                 jsr indin1_ram1                           ;; @@4f58 119
                 sta facexp                                ;; @@4f5b 119
                 sty facov                                 ;; @@4f5d 119
 ;; @@4f5f 119
                 iny                                      ; (1) ;; @@4f5f 119
                 jsr indin1_ram1                           ;; @@4f60 119
                 sta facsgn                                ;; @@4f63 119
                 ora #$80                                  ;; @@4f65 119
                 sta facho                                 ;; @@4f67 119
 ;; @@4f69 119
                 iny                                      ; (2) ;; @@4f69 119
                 jsr indin1_ram1                           ;; @@4f6a 119
                 sta facmoh                                ;; @@4f6d 119
 ;; @@4f6f 119
                 iny                                      ; (3) ;; @@4f6f 119
                 jsr indin1_ram1                           ;; @@4f70 119
                 sta facmo                                 ;; @@4f73 119
 ;; @@4f75 119
                 iny                                      ; (4) ;; @@4f75 119
                 jsr indin1_ram1                           ;; @@4f76 119
                 sta faclo                                 ;; @@4f79 119
                 rts                                       ;; @@4f7b 119
 ;; @@4f7c 119
;.end ;; @@4f7c 119
; .page ;; @@4f7c 119
; .subttl Variable Search ;; @@4f7c 119
 ;; @@4f7c 119
;  Read the variable name at the current text position and put a pointer ;; @@4f7c 119
;  to its value in VARPNT.   TXTPTR points to the terminating character. ;; @@4f7c 119
;  Note that evaluating subscripts in a variable name can cause recursive ;; @@4f7c 119
;  calls to PTRGET, so all values must be stored on the stack. ;; @@4f7c 119
 ;; @@4f7c 119
ptrget           ldx #0                                    ;; @@4f7c 119
                 jsr chrgot                                ;; @@4f7e 119
ptrgt1           stx dimflg                               ; store flag away ;; @@4f81 119
ptrgt2           sta varnam                                ;; @@4f83 119
                 jsr chrgot                               ; get current character ;; @@4f85 119
                 jsr isletc                               ; check for a letter ;; @@4f88 119
                 +lbcc snerr                              ; not a letter ;; @@4f8b 119
 ;; @@4f8e 119
                 ldx #0                                   ; assume no second character ;; @@4f8e 119
                 stx valtyp                               ; default is numeric ;; @@4f90 119
                 stx intflg                               ; assume floating ;; @@4f92 119
                 jsr chrget                               ; get following character ;; @@4f94 119
                 bcc _local_1118_10                       ; branch if numeric ;; @@4f97 119
                 jsr isletc                               ; is it alpha? ;; @@4f99 119
                 bcc _local_1118_30                       ; no, no second character. branch ;; @@4f9c 119
_local_1118_10   tax                                      ; issec. save second character of name ;; @@4f9e 119
 ;; @@4f9f 119
_local_1118_20   jsr chrget                               ; skip over remainder of name. we only care about 2 chars. ;; @@4f9f 119
                 bcc _local_1118_20                       ; ..eat numbers, ;; @@4fa2 119
                 jsr isletc                                ;; @@4fa4 119
                 bcs _local_1118_20                       ; ..and alphas, too! ;; @@4fa7 119
 ;; @@4fa9 119
_local_1118_30   cmp #'$'                                 ; nosec. is this a string? ;; @@4fa9 119
                 bne _local_1118_40                       ; if not, VALTYP = 0 ;; @@4fab 119
                 lda #$ff                                  ;; @@4fad 119
                 sta valtyp                               ; ..else, flag 'string' ;; @@4faf 119
                 bra _local_1118_50                        ;; @@4fb1 119
 ;; @@4fb3 119
_local_1118_40   cmp #'%'                                 ; notstr. isn't string. is it integer? ;; @@4fb3 119
                 bne _local_1118_60                       ; branch if not ;; @@4fb5 119
                 lda subflg                                ;; @@4fb7 119
; bne snerr ; syntax error if integers disabled ;; @@4fb9 119
                 +lbne chkerr                             ; integers disallowed- type mismatch error  [910114] ;; @@4fb9 119
                 lda #$80                                 ; flag integer by turning on both high bits ;; @@4fbc 119
                 sta intflg                                ;; @@4fbe 119
                 tsb varnam                                ;; @@4fc0 119
 ;; @@4fc2 119
_local_1118_50   txa                                      ; turnon. turn on msb of second character ;; @@4fc2 119
                 ora #$80                                  ;; @@4fc3 119
                 tax                                       ;; @@4fc5 119
                 jsr chrget                               ; get character after $ or % ;; @@4fc6 119
 ;; @@4fc9 119
_local_1118_60   stx varnam+1                             ; strnam. store away second character ;; @@4fc9 119
                 sec                                       ;; @@4fcb 119
                 ora subflg                               ; add flag whether to allow arrays ;; @@4fcc 119
                 sbc #'('                                  ;; @@4fce 119
                 +lbeq is_array                           ; note: won't match if SUBFLG set ;; @@4fd0 119
 ;; @@4fd3 119
                 ldy #0                                    ;; @@4fd3 119
                 sty subflg                               ; allow subscripts again ;; @@4fd5 119
                 lda vartab                               ; place to start search ;; @@4fd7 119
                 ldx vartab+1                              ;; @@4fd9 119
 ;; @@4fdb 119
_local_1118_70   stx lowtr+1                              ; stxfnd. ;; @@4fdb 119
_local_1118_80   sta lowtr                                 ;; @@4fdd 119
                 cpx arytab+1                             ; at end of table yet? ;; @@4fdf 119
                 bne _local_1118_90                        ;; @@4fe1 119
                 cmp arytab                                ;; @@4fe3 119
                 beq notfns                               ; yes, we couldn't find it ;; @@4fe5 119
 ;; @@4fe7 119
_local_1118_90   jsr indlow_ram1                          ; lda (lowtr),y ;; @@4fe7 119
                 cmp varnam                               ; compare high orders ;; @@4fea 119
                 bne _local_1118_100                       ;; @@4fec 119
                 iny                                       ;; @@4fee 119
                 jsr indlow_ram1                           ;; @@4fef 119
                 cmp varnam+1                             ; and the low part? ;; @@4ff2 119
                 +lbeq finptr                             ; !!that's it!! ;; @@4ff4 119
 ;; @@4ff7 119
                 dey                                       ;; @@4ff7 119
_local_1118_100  clc                                       ;; @@4ff8 119
                 lda lowtr                                 ;; @@4ff9 119
                 adc #7                                   ; makes no difference among types ;; @@4ffb 119
                 bcc _local_1118_80                        ;; @@4ffd 119
                 inx                                       ;; @@4fff 119
                 bra _local_1118_70                       ; branch always ;; @@5000 119
 ;; @@5002 119
 ;; @@5002 119
 ;; @@5002 119
 ;; @@5002 119
; Test for a letter: (c)=0 not a letter ;; @@5002 119
;   (c)=1 a letter ;; @@5002 119
 ;; @@5002 119
isletc           cmp #'A'                                  ;; @@5002 120
                 bcc _local_1119_1                        ; if less than "a", return ;; @@5004 120
                 sbc #'Z'+1                               ; $5a + 1 ;; @@5006 120
                 sec                                       ;; @@5008 120
                 sbc #$a5                                 ; reset carry if (a) .gt. "z". ;; @@5009 120
_local_1119_1    rts                                       ;; @@500b 120
 ;; @@500c 120
 ;; @@500c 120
notfns           tsx                                      ; check who's calling???? ;; @@500c 121
                 lda $102,x                               ; sniff processor stack ;; @@500d 121
                 cmp #>pointer_ret                         ;; @@5010 121
                 beq ldzr                                 ; special case if called by pointer function ;; @@5012 121
 ;; @@5014 121
_local_1120_20   = isvret-1                                ;; @@5014 121
                 cmp #>_local_1120_20                     ; is eval calling???? ;; @@5014 121
                 bne notevl                               ; no, carry on ;; @@5016 121
 ;; @@5018 121
ldzr             lda #<zero                               ; set up pointer to simulated zero ;; @@5018 122
                 ldy #>zero                                ;; @@501a 122
                 rts                                      ; for strings or numeric ;; @@501c 122
 ;; @@501d 122
 ;; @@501d 122
qst001           cpy #'I'+$80                             ; we know first is T, is second <shift>I (TI$)? ;; @@501d 122
                 beq ldzr                                  ;; @@501f 122
                 cpy #'I'                                 ; or I (TI)? ;; @@5021 122
                 bne varok                                 ;; @@5023 122
                 beq gobadv                                ;; @@5025 122
 ;; @@5027 122
 ;; @@5027 122
qst004           cpy #'S'+$80                             ; check for DS$ ;; @@5027 122
                 beq gobadv                                ;; @@5029 122
                 cpy #'S'                                 ; check for DS ;; @@502b 122
                 bne varok                                 ;; @@502d 122
                 beq gobadv                                ;; @@502f 122
 ;; @@5031 122
 ;; @@5031 122
qst002           cpy #'T'                                 ; check for ST ;; @@5031 122
                 bne varok                                 ;; @@5033 122
                 beq gobadv                                ;; @@5035 122
 ;; @@5037 122
 ;; @@5037 122
qst003           cpy #'R'                                 ; check for ER ;; @@5037 122
                 beq gobadv                                ;; @@5039 122
                 cpy #'L'                                 ; check for EL ;; @@503b 122
                 bne varok                                 ;; @@503d 122
 ;; @@503f 122
 ;; @@503f 122
gobadv           +lbra snerr                               ;; @@503f 122
 ;; @@5042 122
 ;; @@5042 122
 ;; @@5042 122
notevl           lda varnam                                ;; @@5042 122
                 ldy varnam+1                              ;; @@5044 122
                 cmp #'T'                                 ; screen out TI ;; @@5046 122
                 beq qst001                                ;; @@5048 122
                 cmp #'S'                                 ; ...and ST ;; @@504a 122
                 beq qst002                                ;; @@504c 122
                 cmp #'E'                                 ; ...and ER and EL ;; @@504e 122
                 beq qst003                                ;; @@5050 122
                 cmp #'D'                                 ; ...and DS ;; @@5052 122
                 beq qst004                                ;; @@5054 122
 ;; @@5056 122
 ;; @@5056 122
varok            lda arytab                                ;; @@5056 122
                 ldy arytab+1                              ;; @@5058 122
                 sta lowtr                                 ;; @@505a 122
                 sty lowtr+1                               ;; @@505c 122
                 lda strend                                ;; @@505e 122
                 ldy strend+1                              ;; @@5060 122
                 sta hightr                                ;; @@5062 122
                 sty hightr+1                              ;; @@5064 122
                 clc                                       ;; @@5066 122
                 adc #7                                    ;; @@5067 122
                 bcc _local_1121_10                       ; not even ;; @@5069 122
                 iny                                       ;; @@506b 122
 ;; @@506c 122
_local_1121_10   sta highds                                ;; @@506c 122
                 sty highds+1                              ;; @@506e 122
                 jsr bltu                                  ;; @@5070 122
                 lda highds                                ;; @@5073 122
                 ldy highds+1                              ;; @@5075 122
                 iny                                       ;; @@5077 122
                 sta arytab                                ;; @@5078 122
                 sty arytab+1                              ;; @@507a 122
 ;; @@507c 122
 ;; @@507c 122
; Scan thru array entries for string arrays.  If any are found it will be ;; @@507c 122
; necessary to adjust the back-links of the strings in that array, since ;; @@507c 122
; the array descriptor block itself was moved. ;; @@507c 122
 ;; @@507c 122
                 sta arypnt                               ; set pointer to arrays ;; @@507c 122
                 sty arypnt+1                              ;; @@507e 122
 ;; @@5080 122
aryva2           lda arypnt                                ;; @@5080 123
                 ldx arypnt+1                              ;; @@5082 123
 ;; @@5084 123
aryva3           cpx strend+1                             ; end of arrays? ;; @@5084 123
                 bne aryvgo                                ;; @@5086 123
                 cmp strend                                ;; @@5088 123
                 beq arydon                               ; ...finished ;; @@508a 123
 ;; @@508c 123
 ;; @@508c 123
aryvgo           sta index1                                ;; @@508c 123
                 stx index1+1                              ;; @@508e 123
                 ldy #0                                    ;; @@5090 123
                 jsr indin1_ram1                          ; look at array name ;; @@5092 123
                 tax                                       ;; @@5095 123
                 iny                                       ;; @@5096 123
                 jsr indin1_ram1                          ; name 2nd char ;; @@5097 123
                 php                                      ; save status reg ;; @@509a 123
                 iny                                       ;; @@509b 123
                 jsr indin1_ram1                          ; point to offset to next array ;; @@509c 123
                 adc arypnt                                ;; @@509f 123
                 sta arypnt                               ; save start of next array in arypnt ;; @@50a1 123
                 iny                                       ;; @@50a3 123
                 jsr indin1_ram1                           ;; @@50a4 123
                 adc arypnt+1                              ;; @@50a7 123
                 sta arypnt+1                              ;; @@50a9 123
                 plp                                      ; restore status ;; @@50ab 123
                 bpl aryva2                               ; not a string type ;; @@50ac 123
                 txa                                       ;; @@50ae 123
                 bmi aryva2                               ; not a string array ;; @@50af 123
                 iny                                      ; ok we have a string array ;; @@50b1 123
                 jsr indin1_ram1                          ; get number of dimensions ;; @@50b2 123
                 ldy #0                                    ;; @@50b5 123
                 asl                                      ; move index to ptr to 1st string (add 2*number of dims + 5) ;; @@50b7 123
                 adc #5                                    ;; @@50b8 123
                 adc index1                                ;; @@50ba 123
                 sta index1                                ;; @@50bc 123
                 bcc aryget                                ;; @@50be 123
                 inc index1+1                              ;; @@50c0 123
 ;; @@50c2 123
aryget           ldx index1+1                              ;; @@50c2 123
                 cpx arypnt+1                             ; done with this array? ;; @@50c4 123
                 bne _local_1122_10                        ;; @@50c6 123
                 cmp arypnt                                ;; @@50c8 123
                 beq aryva3                               ; yes ;; @@50ca 123
 ;; @@50cc 123
_local_1122_10   ldy #0                                   ; process string pointer ;; @@50cc 123
                 jsr indin1_ram1                          ; get length of string ;; @@50ce 123
                 beq dvarts                               ; skip if null string ;; @@50d1 123
                 sta syntmp                                ;; @@50d3 123
                 iny                                       ;; @@50d5 123
                 jsr indin1_ram1                          ; get lo byte of string ptr ;; @@50d6 123
                 clc                                       ;; @@50d9 123
                 adc syntmp                               ; and add string length ;; @@50da 123
                 sta hightr                                ;; @@50dc 123
                 iny                                       ;; @@50de 123
                 jsr indin1_ram1                          ; get hi byte of string ptr ;; @@50df 123
                 adc #0                                   ; adjust high byte ;; @@50e2 123
                 sta hightr+1                              ;; @@50e4 123
 ;; @@50e6 123
; Fix backwards pointer by adding move length to it. ;; @@50e6 123
 ;; @@50e6 123
                 phx                                       ;; @@50e6 123
                 ldx #hightr                               ;; @@50e7 123
                 ldy #0                                    ;; @@50e9 123
                 jsr indhtr_ram1                          ; lda (hightr),y ;; @@50eb 123
                 adc #7                                   ; carry clear (careful!) ;; @@50ee 123
                 jsr sta_far_ram1                         ; sta (hightr),y ;; @@50f0 123
                 iny                                       ;; @@50f3 123
                 jsr indhtr_ram1                          ; lda (hightr),y ;; @@50f4 123
                 adc #0                                    ;; @@50f7 123
                 jsr sta_far_ram1                         ; sta (hightr),y ;; @@50f9 123
                 plx                                      ; done with this string ;; @@50fc 123
 ;; @@50fd 123
; Fix the next string in the array ;; @@50fd 123
 ;; @@50fd 123
dvarts           lda #strsiz                               ;; @@50fd 124
                 clc                                       ;; @@50ff 124
                 adc index1                                ;; @@5100 124
                 sta index1                                ;; @@5102 124
                 bcc aryget                                ;; @@5104 124
                 inc index1+1                              ;; @@5106 124
                 bra aryget                               ; branch always ;; @@5108 124
 ;; @@510a 124
 ;; @@510a 124
arydon           phx                                       ;; @@510a 124
                 ldx #lowtr                                ;; @@510b 124
                 ldy #0                                    ;; @@510d 124
                 lda varnam                                ;; @@510f 124
                 jsr sta_far_ram1                         ; sta (lowtr),y ;; @@5111 124
                 iny                                      ; .y=1 ;; @@5114 124
                 lda varnam+1                              ;; @@5115 124
                 jsr sta_far_ram1                         ; sta (lowtr),y ;; @@5117 124
                 lda #0                                    ;; @@511a 124
_local_1123_10   iny                                       ;; @@511c 124
                 jsr sta_far_ram1                         ; sta (lowtr),y ;; @@511d 124
                 cpy #6                                    ;; @@5120 124
                 bne _local_1123_10                        ;; @@5122 124
                 plx                                       ;; @@5124 124
 ;; @@5125 124
finptr           lda lowtr                                 ;; @@5125 125
                 clc                                       ;; @@5127 125
                 adc #2                                    ;; @@5128 125
                 ldy lowtr+1                               ;; @@512a 125
                 bcc _local_1124_10                        ;; @@512c 125
                 iny                                       ;; @@512e 125
_local_1124_10   sta varpnt                                ;; @@512f 125
                 sty varpnt+1                              ;; @@5131 125
                 rts                                       ;; @@5133 125
 ;; @@5134 125
 ;; @@5134 125
 ;; @@5134 125
 ;; @@5134 125
bltu             jsr reason                                ;; @@5134 126
                 sta strend                                ;; @@5137 126
                 sty strend+1                              ;; @@5139 126
                 sec                                       ;; @@513b 126
                 lda hightr                                ;; @@513c 126
                 sbc lowtr                                 ;; @@513e 126
                 sta index                                 ;; @@5140 126
                 tay                                       ;; @@5142 126
                 lda hightr+1                              ;; @@5143 126
                 sbc lowtr+1                               ;; @@5145 126
                 tax                                       ;; @@5147 126
                 inx                                       ;; @@5148 126
                 tya                                       ;; @@5149 126
                 beq decblt                                ;; @@514a 126
                 lda hightr                                ;; @@514c 126
                 sec                                       ;; @@514e 126
                 sbc index                                 ;; @@514f 126
                 sta hightr                                ;; @@5151 126
                 bcs _local_1125_10                        ;; @@5153 126
                 dec hightr+1                              ;; @@5155 126
                 sec                                       ;; @@5157 126
_local_1125_10   lda highds                                ;; @@5158 126
                 sbc index                                 ;; @@515a 126
                 sta highds                                ;; @@515c 126
                 bcs moren1                                ;; @@515e 126
                 dec highds+1                              ;; @@5160 126
                 bcc moren1                                ;; @@5162 126
 ;; @@5164 126
bltlp            jsr indhtr_ram1                          ; lda (hightr),y ;; @@5164 127
                 phx                                       ;; @@5167 127
                 ldx #highds                               ;; @@5168 127
                 jsr sta_far_ram1                         ; sta (highds),y ;; @@516a 127
                 plx                                       ;; @@516d 127
 ;; @@516e 127
moren1           dey                                       ;; @@516e 127
                 bne bltlp                                 ;; @@516f 127
                 jsr indhtr_ram1                          ; lda (hightr),y ;; @@5171 127
                 phx                                       ;; @@5174 127
                 ldx #highds                               ;; @@5175 127
                 jsr sta_far_ram1                         ; sta (highds),y ;; @@5177 127
                 plx                                       ;; @@517a 127
 ;; @@517b 127
decblt           dec hightr+1                              ;; @@517b 127
                 dec highds+1                              ;; @@517d 127
                 dex                                       ;; @@517f 127
                 bne moren1                                ;; @@5180 127
                 rts                                       ;; @@5182 127
 ;; @@5183 127
;.end ;; @@5183 127
; .page ;; @@5183 127
; .subttl Array Routines ;; @@5183 127
 ;; @@5183 127
; The format of arrays in core: ;; @@5183 127
; ;; @@5183 127
; Descriptor: low  byte = first character ;; @@5183 127
;   high byte = second character (msb is string flag) ;; @@5183 127
; Length of array in memory in bytes (includes everything). ;; @@5183 127
; Number of dimensions. ;; @@5183 127
; For each dimension starting with the first a list (2 bytes each) ;; @@5183 127
; of the max indice+1. ;; @@5183 127
; The values. ;; @@5183 127
 ;; @@5183 127
 ;; @@5183 127
is_array                                                   ;; @@5183 127
                 lda dimflg                                ;; @@5183 127
                 ora intflg                                ;; @@5185 127
                 pha                                      ; save DIMFLG for recursion ;; @@5187 127
                 lda valtyp                                ;; @@5188 127
                 pha                                      ; save VALTYP for recursion ;; @@518a 127
                 ldy #0                                   ; set number of dimensions to zero ;; @@518b 127
 ;; @@518d 127
_local_1126_10   phy                                      ; save number of dims ;; @@518d 127
                 lda varnam+1                              ;; @@518e 127
                 pha                                       ;; @@5190 127
                 lda varnam                                ;; @@5191 127
                 pha                                      ; save looks ;; @@5193 127
                 jsr intidx                               ; evaluate indice into facmo&lo ;; @@5194 127
                 pla                                       ;; @@5197 127
                 sta varnam                                ;; @@5198 127
                 pla                                       ;; @@519a 127
                 sta varnam+1                             ; get back all...we're home ;; @@519b 127
                 ply                                      ; (# of units) ;; @@519d 127
                 tsx                                       ;; @@519e 127
                 lda 258,x                                 ;; @@519f 127
                 pha                                      ; push DIMFLG and VALTYP further ;; @@51a2 127
                 lda 257,x                                 ;; @@51a3 127
                 pha                                       ;; @@51a6 127
                 lda indice                               ; put indice onto stack ;; @@51a7 127
                 sta 258,x                                ; under DIMFLG and VALTYP ;; @@51a9 127
                 lda indice+1                              ;; @@51ac 127
                 sta 257,x                                 ;; @@51ae 127
                 iny                                      ; y counts # of subscripts ;; @@51b1 127
                 sty count                                ; protect y from chrget ;; @@51b2 127
                 jsr chrgot                               ; get terminating character ;; @@51b4 127
                 ldy count                                 ;; @@51b7 127
                 cmp #','                                 ; more subscripts? ;; @@51b9 127
                 beq _local_1126_10                       ; yes ;; @@51bb 127
 ;; @@51bd 127
 ;; @@51bd 127
                 jsr chkcls                               ; must be closed paren ;; @@51bd 127
                 pla                                       ;; @@51c0 127
                 sta valtyp                               ; get VALTYP and ;; @@51c1 127
                 pla                                       ;; @@51c3 127
                 sta intflg                                ;; @@51c4 127
                 and #$7f                                  ;; @@51c6 127
                 sta dimflg                               ; DIMFLG off stack ;; @@51c8 127
                 ldx arytab                               ; place to start search ;; @@51ca 127
                 lda arytab+1                              ;; @@51cc 127
 ;; @@51ce 127
 ;; @@51ce 127
_local_1126_20   stx lowtr                                 ;; @@51ce 127
                 sta lowtr+1                               ;; @@51d0 127
                 cmp strend+1                             ; end of arrays? ;; @@51d2 127
                 bne _local_1126_30                        ;; @@51d4 127
                 cpx strend                                ;; @@51d6 127
                 beq notfdd                               ; a fine thing! no array! ;; @@51d8 127
 ;; @@51da 127
_local_1126_30   ldy #0                                    ;; @@51da 127
                 jsr indlow_ram1                          ; get high of name from array bank (ram1) ;; @@51dc 127
                 iny                                       ;; @@51df 127
                 cmp varnam                               ; compare high orders. ;; @@51e0 127
                 bne _local_1126_40                       ; no way is it this. get the bite outta here ;; @@51e2 127
                 jsr indlow_ram1                           ;; @@51e4 127
                 cmp varnam+1                             ; low orders? ;; @@51e7 127
                 beq gotary                               ; well here it is ;; @@51e9 127
 ;; @@51eb 127
_local_1126_40   iny                                       ;; @@51eb 127
                 jsr indlow_ram1                          ; get length ;; @@51ec 127
                 clc                                       ;; @@51ef 127
                 adc lowtr                                 ;; @@51f0 127
                 tax                                       ;; @@51f2 127
                 iny                                       ;; @@51f3 127
                 jsr indlow_ram1                           ;; @@51f4 127
                 adc lowtr+1                               ;; @@51f7 127
                 bcc _local_1126_20                       ; always branches ;; @@51f9 127
 ;; @@51fb 127
 ;; @@51fb 127
bserr            ldx #errbs                               ; get bad sub error number ;; @@51fb 128
                 !text $2c                                 ;; @@51fd 128
 ;; @@51fe 128
fcerr            ldx #errfc                               ; too big. Illegal Quantity error ;; @@51fe 128
                 +lbra error                               ;; @@5200 128
 ;; @@5203 128
 ;; @@5203 128
 ;; @@5203 128
gotary           ldx #errdd                               ; perhaps a "re-dimension" error ;; @@5203 128
                 lda dimflg                               ; test the DIMFLG ;; @@5205 128
                 +lbne error                               ;; @@5207 128
                 jsr fmaptr                                ;; @@520a 128
                 ldy #4                                    ;; @@520d 128
                 jsr indlow_ram1                           ;; @@520f 128
                 sta syntmp                                ;; @@5212 128
                 lda count                                ; get number of dims input. ;; @@5214 128
                 cmp syntmp                               ; # of dims the same? ;; @@5216 128
                 bne bserr                                ; same so get definition. ;; @@5218 128
                 +lbra getdef                              ;; @@521a 128
 ;; @@521d 128
; .page ;; @@521d 128
; Come here when variable is not found in the array table to build an entry. ;; @@521d 128
; ;; @@521d 128
; Put down the descriptor. ;; @@521d 128
; Setup number of dimensions. ;; @@521d 128
; Make sure there is room for the new entry. ;; @@521d 128
; Remember VARPNT. ;; @@521d 128
; Tally=4. ;; @@521d 128
; Skip two locs for later fill in of size. ;; @@521d 128
; LOOP: Get an indice. ;; @@521d 128
;  Put down number+1 and increment VARPTR. ;; @@521d 128
;  Tally=tally*number+1 ;; @@521d 128
;  Decrement number of dims. ;; @@521d 128
;  Bne LOOP ;; @@521d 128
; Call REASON with (a,b) reflecting last loc of variable. ;; @@521d 128
; Update STREND ;; @@521d 128
; Zero all. ;; @@521d 128
; Make tally include maxdims and descriptor. ;; @@521d 128
; Put down tally ;; @@521d 128
; If called by dimension, return. ;; @@521d 128
;  Else index into the variable as if it were found on the initial search. ;; @@521d 128
 ;; @@521d 128
notfdd                                                     ;; @@521d 128
                 jsr fmaptr                               ; form ARYPNT ;; @@521d 128
                 jsr reason                                ;; @@5220 128
                 ldy #0                                    ;; @@5223 128
                 sty curtol+1                              ;; @@5225 128
                 ldx #5                                    ;; @@5227 128
                 lda varnam                                ;; @@5229 128
                 php                                       ;; @@522b 128
                 phx                                       ;; @@522c 128
                 ldx #lowtr                               ; point to string/array bank ;; @@522d 128
                 jsr sta_far_ram1                         ; sta (lowtr),y ;; @@522f 128
                 plx                                       ;; @@5232 128
                 plp                                       ;; @@5233 128
                 bpl _local_1127_10                        ;; @@5234 128
                 dex                                       ;; @@5236 128
 ;; @@5237 128
_local_1127_10   iny                                      ; notflt. ;; @@5237 128
                 lda varnam+1                              ;; @@5238 128
                 php                                       ;; @@523a 128
                 phx                                       ;; @@523b 128
                 ldx #lowtr                               ; point to string/array bank ;; @@523c 128
                 jsr sta_far_ram1                         ; sta (lowtr),y ;; @@523e 128
                 plx                                       ;; @@5241 128
                 plp                                       ;; @@5242 128
                 bpl _local_1127_20                        ;; @@5243 128
                 dex                                       ;; @@5245 128
                 dex                                       ;; @@5246 128
 ;; @@5247 128
_local_1127_20   stx curtol                                ;; @@5247 128
                 lda count                                ; save number of dimensions ;; @@5249 128
                 iny                                       ;; @@524b 128
                 iny                                       ;; @@524c 128
                 iny                                       ;; @@524d 128
                 ldx #lowtr                               ; point to string/array bank ;; @@524e 128
                 jsr sta_far_ram1                         ; sta (lowtr),y ;; @@5250 128
 ;; @@5253 128
_local_1127_30   ldx #11                                  ; loppta. default size ;; @@5253 128
                 lda #0                                    ;; @@5255 128
                 bbr6 dimflg,_local_1127_40               ; not in a dim statement ;; @@5257 128
                 pla                                      ; get low order of indice ;; @@525a 128
                 clc                                       ;; @@525b 128
                 adc #1                                    ;; @@525c 128
                 tax                                       ;; @@525e 128
                 pla                                      ; get high order of indice ;; @@525f 128
                 adc #0                                    ;; @@5260 128
 ;; @@5262 128
_local_1127_40   iny                                      ; notdim. ;; @@5262 128
                 phx                                       ;; @@5263 128
                 ldx #lowtr                                ;; @@5264 128
                 jsr sta_far_ram1 ;sta (lowtr),y          ; store high part of indice ;; @@5266 128
                 plx                                       ;; @@5269 128
                 iny                                       ;; @@526a 128
                 txa                                       ;; @@526b 128
                 phx                                       ;; @@526c 128
                 ldx #lowtr                                ;; @@526d 128
                 jsr sta_far_ram1 ;sta (lowtr),y          ; store low part of indice ;; @@526f 128
                 plx                                       ;; @@5272 128
                 jsr umult                                ; (a,x)+(curtol)*(lowtr,y) ;; @@5273 128
                 stx curtol                               ; save new tally ;; @@5276 128
                 sta curtol+1                              ;; @@5278 128
                 ldy index                                 ;; @@527a 128
                 dec count                                ; any more indices left? ;; @@527c 128
                 bne _local_1127_30                       ; yes ;; @@527e 128
                 adc arypnt+1                              ;; @@5280 128
                 +lbcs omerr                              ; overflow ;; @@5282 128
                 sta arypnt+1                             ; compute where to zero ;; @@5285 128
                 tay                                       ;; @@5287 128
                 txa                                       ;; @@5288 128
                 adc arypnt                                ;; @@5289 128
                 bcc _local_1127_50                        ;; @@528b 128
                 iny                                       ;; @@528d 128
                 +lbeq omerr                               ;; @@528e 128
 ;; @@5291 128
_local_1127_50   jsr reason                               ; grease.  get room ;; @@5291 128
                 sta strend                                ;; @@5294 128
                 sty strend+1                             ; new end of storage ;; @@5296 128
                 lda #0                                   ; storing (a) is faster than clear ;; @@5298 128
                 inc curtol+1                              ;; @@529a 128
                 ldy curtol                                ;; @@529c 128
                 beq _local_1127_70                        ;; @@529e 128
 ;; @@52a0 128
_local_1127_60   dey                                      ; zero out new entry ;; @@52a0 128
                 php                                       ;; @@52a1 128
                 phx                                       ;; @@52a2 128
                 ldx #arypnt                               ;; @@52a3 128
                 jsr sta_far_ram1                         ; sta (arypnt),y ;; @@52a5 128
                 plx                                       ;; @@52a8 128
                 plp                                       ;; @@52a9 128
                 bne _local_1127_60                       ; no. continue ;; @@52aa 128
 ;; @@52ac 128
_local_1127_70   dec arypnt+1                             ; deccur. ;; @@52ac 128
                 dec curtol+1                              ;; @@52ae 128
                 bne _local_1127_60                       ; do another block ;; @@52b0 128
                 inc arypnt+1                             ; bump back up. will use later ;; @@52b2 128
                 sec                                       ;; @@52b4 128
                 lda strend                               ; restore (a) ;; @@52b5 128
                 sbc lowtr                                ; determine length ;; @@52b7 128
                 ldy #2                                    ;; @@52b9 128
                 phx                                       ;; @@52bb 128
                 ldx #lowtr                                ;; @@52bc 128
                 jsr sta_far_ram1 ;sta (lowtr),y          ; low ;; @@52be 128
                 lda strend+1                              ;; @@52c1 128
                 iny                                       ;; @@52c3 128
                 sbc lowtr+1                               ;; @@52c4 128
                 jsr sta_far_ram1 ;sta (lowtr),y          ; high ;; @@52c6 128
                 plx                                       ;; @@52c9 128
                 lda dimflg                               ; quit here if this is a DIM statement ;; @@52ca 128
                 bne dimrts                               ; bye! ;; @@52cc 128
                 iny                                       ;; @@52ce 128
 ;; @@52cf 128
 ;; @@52cf 128
; At this point (LOWTR,y) points beyond the size to the number of dimensions. ;; @@52cf 128
; Strategy: ;; @@52cf 128
;  NUMDIM = number of dimensions ;; @@52cf 128
;  curtol = 0 ;; @@52cf 128
;  INLPNM: Get a new indice ;; @@52cf 128
;   Make sure indice is not too big ;; @@52cf 128
;   Multiply CURTOL by CURMAX ;; @@52cf 128
;   Add indice to CURTOL ;; @@52cf 128
;   NUMDIM=NUMDIM-1 ;; @@52cf 128
;   bne INLPNM ;; @@52cf 128
;  Use (CURTOL)*4 as offset ;; @@52cf 128
 ;; @@52cf 128
 ;; @@52cf 128
getdef           jsr indlow_ram1                          ; get # of dim's from string bank ;; @@52cf 129
                 sta count                                ; save a counter ;; @@52d2 129
                 lda #0                                   ; zero (curtol) ;; @@52d4 129
                 sta curtol                                ;; @@52d6 129
 ;; @@52d8 129
inlpnm           sta curtol+1                              ;; @@52d8 129
                 plx                                      ; get low indice ;; @@52da 129
                 stx indice                                ;; @@52db 129
                 iny                                       ;; @@52dd 129
                 jsr indlow_ram1                           ;; @@52de 129
                 sta syntmp                                ;; @@52e1 129
                 pla                                      ; and the high part ;; @@52e3 129
                 sta indice+1                              ;; @@52e4 129
                 cmp syntmp                               ; compare with max indice ;; @@52e6 129
                 bcc inlpn2                                ;; @@52e8 129
                 bne bserr7                               ; if greater, "bad subscript" error ;; @@52ea 129
                 iny                                       ;; @@52ec 129
                 jsr indlow_ram1                           ;; @@52ed 129
                 sta syntmp                                ;; @@52f0 129
                 cpx syntmp                                ;; @@52f2 129
                 bcc inlpn1                                ;; @@52f4 129
 ;; @@52f6 129
bserr7           +lbra bserr                               ;; @@52f6 129
 ;; @@52f9 129
 ;; @@52f9 129
inlpn2           iny                                       ;; @@52f9 129
inlpn1           lda curtol+1                             ; don't multiply if curtol=0 ;; @@52fa 129
                 ora curtol                                ;; @@52fc 129
                 clc                                      ; prepare to get indice back ;; @@52fe 129
                 beq _local_1128_10                       ; get high part of indice back ;; @@52ff 129
                 jsr umult                                ; multiply (curtol) by (5&6,lowtr) ;; @@5301 129
                 txa                                       ;; @@5304 129
                 adc indice                               ; add in (indice) ;; @@5305 129
                 tax                                       ;; @@5307 129
                 tya                                       ;; @@5308 129
                 ldy index1                                ;; @@5309 129
 ;; @@530b 129
_local_1128_10   adc indice+1                              ;; @@530b 129
                 stx curtol                                ;; @@530d 129
                 dec count                                ; any more? ;; @@530f 129
                 bne inlpnm                               ; yes ;; @@5311 129
                 sta curtol+1                              ;; @@5313 129
                 ldx #5                                    ;; @@5315 129
                 lda varnam                                ;; @@5317 129
                 bpl _local_1128_20                        ;; @@5319 129
                 dex                                       ;; @@531b 129
_local_1128_20   lda varnam+1                              ;; @@531c 129
                 bpl _local_1128_30                        ;; @@531e 129
                 dex                                       ;; @@5320 129
                 dex                                       ;; @@5321 129
_local_1128_30   stx addend                                ;; @@5322 129
                 lda #0                                    ;; @@5324 129
                 jsr umultd                               ; on rts, a & y = hi. x = lo. ;; @@5326 129
                 txa                                       ;; @@5329 129
                 adc arypnt                                ;; @@532a 129
                 sta varpnt                                ;; @@532c 129
                 tya                                       ;; @@532e 129
                 adc arypnt+1                              ;; @@532f 129
                 sta varpnt+1                              ;; @@5331 129
                 tay                                       ;; @@5333 129
                 lda varpnt                                ;; @@5334 129
dimrts           rts                                       ;; @@5336 130
 ;; @@5337 130
; .page ;; @@5337 130
; Integer arithmetic routines. ;; @@5337 130
; ;; @@5337 130
; Two byte unsigned integer multiply. ;; @@5337 130
; This is for multiply dimensioned arrays. ;; @@5337 130
; (a,b)=(curtol)*(5&6,x). ;; @@5337 130
 ;; @@5337 130
umult                                                      ;; @@5337 130
                 sty index                                 ;; @@5337 130
                 jsr indlow_ram1                           ;; @@5339 130
                 sta addend                               ; low, then high ;; @@533c 130
                 dey                                       ;; @@533e 130
                 jsr indlow_ram1                          ; put (5&6,lowtr) in faster memory ;; @@533f 130
 ;; @@5342 130
umultd           sta addend+1                              ;; @@5342 130
                 lda #16                                   ;; @@5344 130
                 sta deccnt                                ;; @@5346 130
                 ldx #0                                   ; clear the accs ;; @@5348 130
                 ldy #0                                   ; result initially zero ;; @@534a 130
 ;; @@534c 130
umultc           txa                                       ;; @@534c 130
                 asl                                      ; multiply by two ;; @@534d 130
                 tax                                       ;; @@534e 130
                 tya                                       ;; @@534f 130
                 rol                                       ;; @@5350 130
                 tay                                       ;; @@5351 130
                 +lbcs omerr                              ; to much! ;; @@5352 130
                 asl curtol                                ;; @@5355 130
                 rol curtol+1                              ;; @@5357 130
                 bcc umlcnt                               ; nothing in this position to multiply ;; @@5359 130
                 clc                                       ;; @@535b 130
                 txa                                       ;; @@535c 130
                 adc addend                                ;; @@535d 130
                 tax                                       ;; @@535f 130
                 tya                                       ;; @@5360 130
                 adc addend+1                              ;; @@5361 130
                 tay                                       ;; @@5363 130
                 +lbcs omerr                              ; man, just too much! ;; @@5364 130
 ;; @@5367 130
umlcnt           dec deccnt                               ; done? ;; @@5367 130
                 bne umultc                               ; keep it up ;; @@5369 130
                 rts                                      ; yes, all done ;; @@536b 130
 ;; @@536c 130
 ;; @@536c 130
fmaptr           lda count                                 ;; @@536c 130
                 asl                                       ;; @@536e 130
                 adc #5                                   ; point to entries. ((c) cleared by asl) ;; @@536f 130
                 adc lowtr                                 ;; @@5371 130
                 ldy lowtr+1                               ;; @@5373 130
                 bcc _local_1129_1                         ;; @@5375 130
                 iny                                       ;; @@5377 130
_local_1129_1    sta arypnt                                ;; @@5378 130
                 sty arypnt+1                              ;; @@537a 130
                 rts                                       ;; @@537c 130
 ;; @@537d 130
;.end ;; @@537d 130
; .page ;; @@537d 130
; .subttl  TIME functions ;; @@537d 130
 ;; @@537d 130
; TI$="hh:mm:ss.t" Allows optional colons to delimit parameters and ;; @@537d 130
;   allows input to be abbrieviated (eg., TI$="h:mm" or ;; @@537d 130
;   even TI$=""), defaulting to "00" for unspecified ;; @@537d 130
;   parameters.  24-hour clock (00:00:00.0 to 23:59:59.9). ;; @@537d 130
;   901010 F.Bowen ;; @@537d 130
 ;; @@537d 130
Set_TI_String                                              ;; @@537d 131
                 jsr frefac                               ; we won't need it ;; @@537d 131
                 sta count                                ; save length ;; @@5380 131
 ;; @@5382 131
                 ldy #0                                   ; our pointer into TI$ assignment ;; @@5382 131
                 sty time                                 ; default time to zero, in case it's not fully specified ;; @@5384 131
                 sty time+1                                ;; @@5386 131
                 sty time+2                                ;; @@5388 131
                 sty time+3                                ;; @@538a 131
 ;; @@538c 131
                 ldx #3                                   ; parameter pointer (3=hr,2=min,1=sec,0=tenths) ;; @@538c 131
_local_1130_10   jsr GetTimeDigit                         ; get first digit, convert to BCD ;; @@538e 131
                 bcs _local_1130_20                       ; colon or eos ;; @@5391 131
                 sta time,x                                ;; @@5393 131
                 jsr GetTimeDigit                         ; get second digit, convert to BCD ;; @@5395 131
                 bcs _local_1130_20                       ; colon or eos ;; @@5398 131
 ;; @@539a 131
                 asl time,x                               ; move first digit to msd ;; @@539a 131
                 asl time,x                                ;; @@539c 131
                 asl time,x                                ;; @@539e 131
                 asl time,x                                ;; @@53a0 131
                 ora time,x                               ; combine with second digit ;; @@53a2 131
                 sta time,x                               ; now we have a time element of packed BCD ;; @@53a4 131
 ;; @@53a6 131
_local_1130_20   lda time,x                                ;; @@53a6 131
                 cmp MaxTimeValues,x                      ; check for parameter too big ;; @@53a8 131
                 +lbcs fcerr                              ; hr>23, min>59, sec>59, tenths>9 ;; @@53ab 131
 ;; @@53ae 131
                 dex                                      ; check if done ;; @@53ae 131
                 bmi _local_1130_30                       ; yes- all parameters accounted for ;; @@53af 131
                 cpy count                                 ;; @@53b1 131
                 bcs _local_1130_40                       ; yes- end of string ;; @@53b3 131
 ;; @@53b5 131
                 jsr indin1_ram1                          ; check for optional colon (or period)   [910103] ;; @@53b5 131
                 cmp #':'                                  ;; @@53b8 131
                 beq _local_1130_25                        ;; @@53ba 131
                 cmp #'.'                                  ;; @@53bc 131
                 bne _local_1130_10                       ; not there ;; @@53be 131
_local_1130_25   iny                                      ; it's there- skip over it ;; @@53c0 131
 ;; @@53c1 131
                 bra _local_1130_10                       ; loop until done ;; @@53c1 131
 ;; @@53c3 131
 ;; @@53c3 131
_local_1130_30   cpy count                                ; done ;; @@53c3 131
                 +lbcc errlen                             ; error if string too long ;; @@53c5 131
 ;; @@53c8 131
_local_1130_40   ldz time                                 ; tenths  0-9 ;; @@53c8 131
                 lda time+1                               ; seconds 0-59 ;; @@53cb 131
                 ldx time+2                               ; minutes 0-59 ;; @@53cd 131
                 ldy time+3                               ; hours  0-23 ;; @@53cf 131
                 jmp _SetTime                             ; Go set time & exit ;; @@53d1 131
 ;; @@53d4 131
; .page ;; @@53d4 131
; Get an ASCII digit, make sure it's in range 0-9 or a colon. ;; @@53d4 131
; if no digit to get, default to '0' ;; @@53d4 131
; ;; @@53d4 131
; exit with .c=0 if okay  (.A contains BCD) ;; @@53d4 131
;    .c=1 if colon or eos (.A invalid) ;; @@53d4 131
 ;; @@53d4 131
GetTimeDigit                                               ;; @@53d4 132
                 lda #0                                   ; default to '0' ;; @@53d4 132
                 cpy count                                 ;; @@53d6 132
                 bcs _local_1131_10                       ; exit if at end of string (carry set) ;; @@53d8 132
 ;; @@53da 132
                 jsr indin1_ram1                          ; else get a character from string ;; @@53da 132
                 iny                                      ; point to next character ;; @@53dd 132
                 cmp #'.'                                 ; [910103] ;; @@53de 132
                 beq _local_1131_10                       ; terminator (period) (carry set) ;; @@53e0 132
                 cmp #'0'                                 ; check character, only 0-9 allowed ;; @@53e2 132
                 +lbcc fcerr                              ; too small ;; @@53e4 132
                 cmp #':'                                  ;; @@53e7 132
                 bcc _local_1131_10                       ; just right  (carry clear) ;; @@53e9 132
                 +lbne fcerr                              ; too big ;; @@53eb 132
; falls through if colon (carry set) ;; @@53ee 132
 ;; @@53ee 132
_local_1131_10   and #$0f                                 ; make BCD ;; @@53ee 132
                 rts                                       ;; @@53f0 132
 ;; @@53f1 132
 ;; @@53f1 132
 ;; @@53f1 132
MaxTimeValues                                              ;; @@53f1 133
                 !text $10,$60,$60,$24                    ; t,s,m,h in packed BCD ;; @@53f1 133
 ;; @@53f5 133
; .page ;; @@53f5 133
; x$=TI$  Return a string of the form "hh:mm:ss.t", including colons. ;; @@53f5 133
 ;; @@53f5 133
Get_TI_String                                              ;; @@53f5 133
                 jsr ReadSystemClock                      ; get time as packed BCD ;; @@53f5 133
 ;; @@53f8 133
                 lda #10                                  ; get string space for 10 characters ;; @@53f8 133
                 jsr strspa                                ;; @@53fa 133
                 tay                                      ; length ;; @@53fd 133
                 dey                                      ; index ;; @@53fe 133
 ;; @@53ff 133
                 lda time                                 ; build TI$ string in 'fbuffr' ;; @@53ff 133
                 ora #'0'                                 ; (build string backwards, from last chr to first) ;; @@5401 133
                 ldx #dsctmp+1                             ;; @@5403 133
                 jsr sta_far_ram1                         ; put tenths (special case- only 1 digit) ;; @@5405 133
                 dey                                       ;; @@5408 133
                 lda #'.'                                  ;; @@5409 133
                 jsr sta_far_ram1                         ; put period (special case)   [910103] ;; @@540b 133
                 dey                                       ;; @@540e 133
                 ldx #1                                    ;; @@540f 133
                 bra _local_1132_20                        ;; @@5411 133
 ;; @@5413 133
_local_1132_10   phx                                      ; element pointer (1=secs, 2=mins, 3=hrs) ;; @@5413 133
                 ldx #dsctmp+1                             ;; @@5414 133
                 lda #':'                                  ;; @@5416 133
                 jsr sta_far_ram1                         ; put colon ;; @@5418 133
                 dey                                       ;; @@541b 133
                 plx                                       ;; @@541c 133
 ;; @@541d 133
_local_1132_20   lda time,x                                ;; @@541d 133
                 taz                                       ;; @@541f 133
                 and #$0f                                 ; do lsd first, since we're working backwards ;; @@5420 133
                 ora #'0'                                  ;; @@5422 133
                 phx                                       ;; @@5424 133
                 ldx #dsctmp+1                             ;; @@5425 133
                 jsr sta_far_ram1                         ; put lsd ;; @@5427 133
                 dey                                       ;; @@542a 133
                 tza                                      ; then do msd ;; @@542b 133
                 lsr                                       ;; @@542c 133
                 lsr                                       ;; @@542d 133
                 lsr                                       ;; @@542e 133
                 lsr                                       ;; @@542f 133
                 ora #'0'                                  ;; @@5430 133
                 jsr sta_far_ram1                         ; put msd ;; @@5432 133
                 plx                                       ;; @@5435 133
                 inx                                      ; next packed element ;; @@5436 133
                 dey                                       ;; @@5437 133
                 bpl _local_1132_10                       ; loop until done ;; @@5438 133
 ;; @@543a 133
                 lda #10                                  ; length ;; @@543a 133
                 jsr mvdone                               ; update frespc ???? ;; @@543c 133
                 +lbra putnew                             ; make descriptor in dsctmp real ;; @@543f 133
 ;; @@5442 133
; .page ;; @@5442 133
; TI. Convert 24-hour TOD into tenths of seconds.  901010 F.Bowen ;; @@5442 133
 ;; @@5442 133
Get_TI                                                     ;; @@5442 134
                 jsr ReadSystemClock                      ; glance at the clock, get time as h:m:s:t ;; @@5442 134
                 stz faclo                                ; init accumulator with tenths (0-9, so nothing to convert) ;; @@5445 134
                 ldz #0                                    ;; @@5447 134
                 stz facmo                                 ;; @@5449 134
                 stz facmoh                                ;; @@544b 134
 ;; @@544d 134
                 ldx #3                                   ; convert time (BCD) to tenths of seconds (binary) since midnight ;; @@544d 134
_local_1133_10   jsr TimeMultiply                          ;; @@544f 134
                 clc                                       ;; @@5452 134
                 adc faclo                                 ;; @@5453 134
                 sta faclo                                 ;; @@5455 134
                 lda product+1                             ;; @@5457 134
                 adc facmo                                 ;; @@5459 134
                 sta facmo                                 ;; @@545b 134
                 lda product+2                             ;; @@545d 134
                 adc facmoh                                ;; @@545f 134
                 sta facmoh                               ; (can't overflow since 23:59:59:9 -> 863999 ($0D2EFF) ;; @@5461 134
                 dex                                       ;; @@5463 134
                 bne _local_1133_10                       ; next factor ;; @@5464 134
 ;; @@5466 134
                 lda #0                                   ; float value in FAC ;; @@5466 134
                 sta facho                                ; zero msb, facov, facsgn ;; @@5468 134
                 ldx #160                                 ; set facov for time ;; @@546a 134
                 sec                                      ; normal fac ;; @@546c 134
                 +lbra floatb                             ; do it ;; @@546d 134
 ;; @@5470 134
 ;; @@5470 134
 ;; @@5470 134
ReadSystemClock                                            ;; @@5470 135
                 jsr _ReadTime                            ; get packed BCD, y=hrs, x=min, a=sec, z=tenths ;; @@5470 135
; (assumes system clock was set properly!) ;; @@5473 135
                 stz time                                 ; tenths  0-9 ;; @@5473 135
                 sta time+1                               ; seconds  0-59 ;; @@5475 135
                 stx time+2                               ; minutes  0-59 ;; @@5477 135
                 sty time+3                               ; hours  0-59 ;; @@5479 135
                 rts                                       ;; @@547b 135
 ;; @@547c 135
; .page ;; @@547c 135
; Unsigned Integer Multiply: Time * Factor  -> Tenths_of_Seconds ;; @@547c 135
;     A   *  (B,C)  ->      (D,E,F) ;; @@547c 135
 ;; @@547c 135
TimeMultiply                                               ;; @@547c 135
                 lda time,x                               ; convert packed BCD to binary ;; @@547c 135
                 and #$0f                                  ;; @@547e 135
                 sta facho                                 ;; @@5480 135
                 lda time,x                               ; 10x = 8x + 2x ;; @@5482 135
                 and #$f0                                  ;; @@5484 135
                 lsr                                      ; msd x 8 ;; @@5486 135
                 sta time,x                                ;; @@5487 135
                 lsr                                       ;; @@5489 135
                 lsr                                      ; msd x 2 ;; @@548a 135
                 clc                                       ;; @@548b 135
                 adc facho                                ; lsd ;; @@548c 135
                 adc time,x                                ;; @@548e 135
                 sta time,x                               ; can't overflow ($99->153) ;; @@5490 135
 ;; @@5492 135
                 txa                                      ; make a word pointer from byte pointer ;; @@5492 135
                 asl                                       ;; @@5493 135
                 tay                                       ;; @@5494 135
                 lda TimeFactor-2,y                       ; multiplicand = TimeFactor,y  (2 bytes) ;; @@5495 135
                 sta multiplicand                         ; multiplier = Time,x x (1 byte) ;; @@5498 135
                 lda TimeFactor-1,y                       ; ----------- ;; @@549a 135
                 sta multiplicand+1                        ;; @@549d 135
                 lda #0                                   ; product lo   (3 bytes) ;; @@549f 135
                 sta product+1                            ; mid ;; @@54a1 135
                 sta product+2                            ; hi ;; @@54a3 135
 ;; @@54a5 135
                 ldy #16                                  ; 16-bit multiplicand ;; @@54a5 135
_local_1134_10   asl                                       ;; @@54a7 135
                 row product+1                             ;; @@54a8 135
                 row multiplicand                         ; multiplier * multiplicand -> product ;; @@54ab 135
                 bcc _local_1134_20                        ;; @@54ae 135
                 clc                                       ;; @@54b0 135
                 adc time,x                                ;; @@54b1 135
                 bcc _local_1134_20                        ;; @@54b3 135
                 inw product+1                            ; (does no error check, since using time factors ;; @@54b5 135
_local_1134_20   dey                                      ; in ROM and maximum time multiplier of 59 there ;; @@54b7 135
                 bne _local_1134_10                       ; is no danger of overflow) ;; @@54b8 135
 ;; @@54ba 135
; sta product ;; @@54ba 135
                 rts                                      ; (.X is preserved) ;; @@54ba 135
 ;; @@54bb 135
 ;; @@54bb 135
TimeFactor                                                 ;; @@54bb 136
                 !word 10                                 ; tenths per second  (max    59*10 =    590 ($0024E) ;; @@54bb 136
                 !word 600                                ; per minute  (max   59*600 =  35400 ($08A48) ;; @@54bd 136
                 !word 36000                              ; per hour    (max 23*36000 = 828000 ($CA260) ;; @@54bf 136
 ;; @@54c1 136
; .page ;; @@54c1 136
; .subttl  SLEEP ;; @@54c1 136
 ;; @@54c1 136
;******************************************************************************* ;; @@54c1 136
;* ;; @@54c1 136
;* SLEEP Command - Postpone all activity for a specified number of seconds ;; @@54c1 136
;* ;; @@54c1 136
;* Syntax:  SLEEP n ;; @@54c1 136
;* ;; @@54c1 136
;* Where n is the number of seconds to remain inactive, ;; @@54c1 136
;* expressed as a positive value < 65536. ;; @@54c1 136
;* ;; @@54c1 136
;******************************************************************************* ;; @@54c1 136
 ;; @@54c1 136
sleep            jsr getwrd                               ; get argument in (y,a) ;; @@54c1 136
 ;; @@54c4 136
; Multiply # of seconds to sleep by 60.  This will be the number of 'jiffies' ;; @@54c4 136
; to hibernate.  Store this value in 3 consecutive locations the kernel will ;; @@54c4 136
; decrement as a 24-bit binary value, and wait for an underflow. ;; @@54c4 136
; ;; @@54c4 136
; ldx #0   ;THIS CODE REPLACED    [910730] ;; @@54c4 136
; php ;; @@54c4 136
; sei   ;silence, please! ;; @@54c4 136
; sty _sleep_counter ;; @@54c4 136
; sta _sleep_counter+1 ;; @@54c4 136
; stx _sleep_counter+2 ;sleep_counter = n ;; @@54c4 136
; ;; @@54c4 136
; jsr sleep_times_2 ;sleep_counter = 2n ;; @@54c4 136
; jsr add_xay_to_sleep ;sleep_counter = 3n ;; @@54c4 136
; jsr sleep_times_4 ;sleep_counter = 12n ;; @@54c4 136
; ;; @@54c4 136
; ldy _sleep_counter ;; @@54c4 136
; lda _sleep_counter+1 ;; @@54c4 136
; ldx _sleep_counter+2 ;(xay) = 12n ;; @@54c4 136
; ;; @@54c4 136
; jsr sleep_times_4 ;sleep_counter = 48n ;; @@54c4 136
; jsr add_xay_to_sleep ;sleep_counter = 60n !!!!! ;; @@54c4 136
; ;; @@54c4 136
; plp ;; @@54c4 136
; ;; @@54c4 136
;1$ jsr is_stop_key_down ;; @@54c4 136
; ldx _sleep_counter+2 ;; @@54c4 136
; inx   ;underflow? ;; @@54c4 136
; bne 1$   ;no, loop ;; @@54c4 136
; rts ;; @@54c4 136
; ;; @@54c4 136
; ;; @@54c4 136
;sleep_times_4 ;; @@54c4 136
; jsr sleep_times_2 ;; @@54c4 136
;sleep_times_2 ;; @@54c4 136
; asl _sleep_counter ;; @@54c4 136
; rol _sleep_counter+1 ;; @@54c4 136
; rol _sleep_counter+2 ;; @@54c4 136
; rts ;; @@54c4 136
; ;; @@54c4 136
;add_xay_to_sleep ;; @@54c4 136
; pha ;; @@54c4 136
; tya ;; @@54c4 136
; adc _sleep_counter ;; @@54c4 136
; sta _sleep_counter ;; @@54c4 136
; pla ;; @@54c4 136
; adc _sleep_counter+1 ;; @@54c4 136
; sta _sleep_counter+1 ;; @@54c4 136
; txa ;; @@54c4 136
; adc _sleep_counter+2 ;; @@54c4 136
; sta _sleep_counter+2 ;; @@54c4 136
; rts ;; @@54c4 136
 ;; @@54c4 136
; .page ;; @@54c4 136
; SLEEP is now based upon the system hardware TOD clock (same one used by TI$).  This ;; @@54c4 136
; makes it accurate, something it was not when it was based upon the frame rate. ;; @@54c4 136
 ;; @@54c4 136
                 sty time                                 ; Number of seconds to "sleep"   [910730] new ;; @@54c4 136
                 sta time+1                                ;; @@54c6 136
 ;; @@54c8 136
_local_1135_10   jsr _ReadTime                            ; Get current time ;; @@54c8 136
                 stz time+2                               ; tenths ;; @@54cb 136
                 sta time+3                               ; seconds ;; @@54cd 136
 ;; @@54cf 136
_local_1135_20   jsr is_stop_key_down                     ; Allow user to abort ;; @@54cf 136
                 jsr _ReadTime                            ; Wait for seconds to increment ;; @@54d2 136
                 cmp time+3                                ;; @@54d5 136
                 beq _local_1135_20                        ;; @@54d7 136
                 sta time+3                                ;; @@54d9 136
 ;; @@54db 136
_local_1135_30   jsr _ReadTime                            ; Wait for tenths to increment ;; @@54db 136
                 cpz time+2                                ;; @@54de 136
                 bne _local_1135_30                        ;; @@54e0 136
 ;; @@54e2 136
                 dew time                                 ; Decrement sleep period 1 second ;; @@54e2 136
                 bne _local_1135_20                       ; Loop until sleep period over ;; @@54e4 136
 ;; @@54e6 136
                 rts                                       ;; @@54e6 136
 ;; @@54e7 136
;.end ;; @@54e7 136
; .page ;; @@54e7 136
; .subttl  WAIT ;; @@54e7 136
 ;; @@54e7 136
; WAIT<location>,<mask1>[,<mask2>] statement waits until the contents of ;; @@54e7 136
; <location> is nonzero when XORed with mask2 and then ANDed with mask1. ;; @@54e7 136
; If mask2 is not present, it is assumed to be zero. ;; @@54e7 136
 ;; @@54e7 136
wait             jsr getnum                               ; get required mask1 ;; @@54e7 137
                 stx andmsk                                ;; @@54ea 137
                 ldx #0                                    ;; @@54ec 137
                 jsr chrgot                                ;; @@54ee 137
                 beq _local_1136_10                        ;; @@54f1 137
                 jsr combyt                               ; get optional mask2 ;; @@54f3 137
_local_1136_10   stx eormsk                                ;; @@54f6 137
 ;; @@54f8 137
                 phz                                       ;; @@54f8 137
                 ldz current_bank                         ; set up bank number for fetch ;; @@54f9 137
                 ldx #poker                               ; ..and address ;; @@54fc 137
                 ldy #0                                   ; ..and index ;; @@54fe 137
 ;; @@5500 137
_local_1136_15   bit current_bank                          ;; @@5500 137
                 bmi _local_1136_20                       ; NOMAP? ;; @@5503 137
                 jsr _lda_far                             ; lda (poker),y ;; @@5505 137
                 !text $2c                                 ;; @@5508 137
 ;; @@5509 137
_local_1136_20   lda (poker),y                             ;; @@5509 137
                 eor eormsk                                ;; @@550b 137
                 and andmsk                                ;; @@550d 137
                 beq _local_1136_15                        ;; @@550f 137
                 plz                                       ;; @@5511 137
                 rts                                      ; got a nonzero ;; @@5512 137
 ;; @@5513 137
;.end ;; @@5513 137
; .page ;; @@5513 137
; .subttl  FRE ;; @@5513 137
 ;; @@5513 137
;***************************************************************************** ;; @@5513 137
; FRE(n) Function ;; @@5513 137
; ;; @@5513 137
; Where: n=0 returns amount of free RAM in bank 0. This is the area ;; @@5513 137
;  between top of text (TEXT_TOP) and top of RAM (MAX_MEM_0). ;; @@5513 137
; ;; @@5513 137
;  n=1 returns amount of free ram in bank 1. This is the area ;; @@5513 137
;  between top of arrays (STREND) and bottom of strings (FRETOP). ;; @@5513 137
; ;; @@5513 137
;  n=2 returns the amount (???? presence) of expansion RAM. ;; @@5513 137
; ;; @@5513 137
;***************************************************************************** ;; @@5513 137
 ;; @@5513 137
fre              jsr conint                               ; get integer argument in .x ;; @@5513 138
                 cpx #1                                   ; which bank? ;; @@5516 138
                 beq _local_1137_20                       ; go do bank one ;; @@5518 138
                 cpx #2                                   ; go do expansion banks   [910107] ;; @@551a 138
                 beq _local_1137_30                       ; else it must be bank zero ;; @@551c 138
                 +lbcs fcerr                              ; any other is unpleasant to talk about ;; @@551e 138
 ;; @@5521 138
                 sec                                      ; FRE(text_bank) ;; @@5521 138
                 lda max_mem_0                             ;; @@5522 138
                 sbc text_top                              ;; @@5525 138
                 tay                                      ; set up result for nosflt ;; @@5527 138
                 lda max_mem_0+1                           ;; @@5528 138
                 sbc text_top+1                            ;; @@552b 138
                 bra _local_1137_40                       ; assumes text_top < max_mem ;; @@552d 138
 ;; @@552f 138
 ;; @@552f 138
_local_1137_20   jsr garba2                               ; FRE(var_bank) do garbage collect first ;; @@552f 138
                 sec                                       ;; @@5532 138
                 lda fretop                                ;; @@5533 138
                 sbc strend                                ;; @@5535 138
                 tay                                       ;; @@5537 138
                 lda fretop+1                              ;; @@5538 138
                 sbc strend+1                              ;; @@553a 138
                 bra _local_1137_40                        ;; @@553c 138
 ;; @@553e 138
_local_1137_30   ldy _expansion                           ; FRE(expansion banks)    [910107] ;; @@553e 138
                 lda #0                                    ;; @@5541 138
 ;; @@5543 138
_local_1137_40   +lbra nosflt                             ; go float the number (y,a)=(lo,hi) ;; @@5543 138
 ;; @@5546 138
;.end ;; @@5546 138
; .page ;; @@5546 138
; .subttl  VAL ;; @@5546 138
 ;; @@5546 138
; The VAL function takes a string and turns it into a number by interpreting ;; @@5546 138
; the PETSCII digits etc.  Except for the problem that a terminator must be ;; @@5546 138
; supplied by replacing the character beyond the string, VAL is merely a call ;; @@5546 138
; to floating point input (FIN). ;; @@5546 138
 ;; @@5546 138
val              jsr len1                                 ; get length ;; @@5546 139
                 +lbeq zerofc                             ; return 0 if len=0 ;; @@5549 139
 ;; @@554c 139
; Use text to fp number code by faking a new text poiner ;; @@554c 139
 ;; @@554c 139
val_1            clc                                      ; ///jump table entry.  convert PETSCII to floating point ;; @@554c 139
                 adc index1                                ;; @@554d 139
                 sta strng2                               ; add length to index1 and put in strng2 ;; @@554f 139
                 lda index1+1                              ;; @@5551 139
                 adc #0                                    ;; @@5553 139
                 sta strng2+1                              ;; @@5555 139
 ;; @@5557 139
                 ldy #0                                    ;; @@5557 139
                 lda #strng2                               ;; @@5559 139
                 jsr lda_far_ram1                         ; replace character after string with $00 (fake EOL) ;; @@555b 139
                 pha                                      ; save old character ;; @@555e 139
                 tya                                      ; (.A=0) ;; @@555f 139
                 ldx #strng2                               ;; @@5560 139
                 jsr sta_far_ram1 ;sta (strng2),y         ; ..and put in null ;; @@5562 139
                 jsr fin_chrget_2                         ; get character pointed to and set flags.(sorta like chrgot) ;; @@5565 139
                 ldx #1                                   ; flag 'bank 1' ;; @@5568 139
                 jsr fin                                  ; go do evaluation ;; @@556a 139
                 pla                                      ; get saved character ;; @@556d 139
                 phx                                       ;; @@556e 139
                 ldx #strng2                               ;; @@556f 139
                 ldy #0                                    ;; @@5571 139
                 jsr sta_far_ram1 ;sta (strng2),y         ; restore zeroed-out character ;; @@5573 139
                 plx                                       ;; @@5576 139
                 rts                                       ;; @@5577 139
 ;; @@5578 139
;.end ;; @@5578 139
; .page ;; @@5578 139
; .subttl  DEC ;; @@5578 139
 ;; @@5578 139
; DEC convert a hex string representing a 2-byte integer into decimal. ;; @@5578 139
 ;; @@5578 139
dcml             jsr len1                                 ; find length of string ;; @@5578 139
                 sta index2                               ; len ret. in a ;; @@557b 139
                 ldy #0                                    ;; @@557d 139
                 sty index2+1                             ; zero char counter ;; @@557f 139
                 sty strng2+1                             ; zero out value ;; @@5581 139
                 sty strng2                                ;; @@5583 139
 ;; @@5585 139
_local_1138_10   cpy index2                               ; evaluated all characters? ;; @@5585 139
                 beq _local_1138_50                       ; branch if so ;; @@5587 139
                 jsr indin1_ram1                          ; get next character from string ;; @@5589 139
                 iny                                       ;; @@558c 139
                 cmp #' '                                 ; ignore spaces ;; @@558d 139
                 beq _local_1138_10                        ;; @@558f 139
                 inc index2+1                              ;; @@5591 139
                 ldx index2+1                              ;; @@5593 139
                 cpx #5                                    ;; @@5595 139
                 bcs decbad                               ; can't have more than 4 characters ;; @@5597 139
 ;; @@5599 139
                 cmp #'0'                                  ;; @@5599 139
                 bcc decbad                               ; bad if < 0 ;; @@559b 139
                 cmp #':'                                 ; '9'+1 ;; @@559d 139
                 bcc _local_1138_30                       ; ok if  = 0-9 ;; @@559f 139
                 cmp #'A'                                  ;; @@55a1 139
                 bcc decbad                               ; bad if > 9  and < A ;; @@55a3 139
                 cmp #'G'                                  ;; @@55a5 139
                 bcs decbad                               ; bad if > F ;; @@55a7 139
 ;; @@55a9 139
                 sbc #7                                   ; adjust if A-F  (.c is clr) ;; @@55a9 139
_local_1138_30   sbc #$2f                                 ; adjust to $00..$0f (.c is set) ;; @@55ab 139
                 asl                                      ; shift low nibble to high ;; @@55ad 139
                 asl                                       ;; @@55ae 139
                 asl                                       ;; @@55af 139
                 asl                                       ;; @@55b0 139
 ;; @@55b1 139
                 ldx #4                                   ; mult. old val. by 16, add new ;; @@55b1 139
_local_1138_40   asl                                       ;; @@55b3 139
                 rol strng2                                ;; @@55b4 139
                 rol strng2+1                              ;; @@55b6 139
                 dex                                       ;; @@55b8 139
                 bne _local_1138_40                        ;; @@55b9 139
                 bra _local_1138_10                        ;; @@55bb 139
 ;; @@55bd 139
_local_1138_50   ldy strng2                               ; get lsb of value, ;; @@55bd 139
                 lda strng2+1                             ; & msb, ;; @@55bf 139
                 +lbra nosflt                             ; go float 2 byte unsigned integer ;; @@55c1 139
 ;; @@55c4 139
 ;; @@55c4 139
decbad                                                     ;; @@55c4 140
                 +lbra fcerr                              ; illegal qty error ;; @@55c4 140
 ;; @@55c7 140
;.end ;; @@55c7 140
; .page ;; @@55c7 140
; .subttl  PEEK  POKE ;; @@55c7 140
 ;; @@55c7 140
 ;; @@55c7 140
peek             phw poker                                ; ..also happens to be LINNUM!   [910911] ;; @@55c7 140
                 jsr chknum                                ;; @@55ca 140
                 jsr getadr                                ;; @@55cd 140
                 ldy #0                                   ; index ;; @@55d0 140
                 bit current_bank                          ;; @@55d2 140
                 bmi _local_1139_10                       ; NOMAP? ;; @@55d5 140
 ;; @@55d7 140
                 phz                                       ;; @@55d7 140
                 ldz current_bank                         ; set up bank number for Kernel's fetch ;; @@55d8 140
                 ldx #poker                               ; ..and address ;; @@55db 140
                 jsr _lda_far                             ; lda (poker),y ;; @@55dd 140
                 plz                                       ;; @@55e0 140
                 !text $2c                                 ;; @@55e1 140
 ;; @@55e2 140
_local_1139_10   lda (poker),y                             ;; @@55e2 140
                 tay                                      ; get byte into .y ;; @@55e4 140
                 pla                                       ;; @@55e5 140
                 sta poker+1                              ; restore linnum ;; @@55e6 140
                 pla                                       ;; @@55e8 140
                 sta poker                                 ;; @@55e9 140
                 +lbra sngflt                             ; float it ;; @@55eb 140
 ;; @@55ee 140
; .page ;; @@55ee 140
poke             jsr getnum                                ;; @@55ee 141
_local_1140_1    txa                                      ; set up value to store for Kernel 'stash' routine ;; @@55f1 141
                 ldy #0                                   ; ..and index ;; @@55f2 141
                 sei                                      ; to allow poking IRQ vector, etc.  [910612] ;; @@55f4 141
                 bit current_bank                          ;; @@55f5 141
                 bmi _local_1140_10                       ; (anything >1Meg means NOMAP) ;; @@55f8 141
 ;; @@55fa 141
                 phz                                       ;; @@55fa 141
                 ldx #poker                               ; ..and address ;; @@55fb 141
                 ldz current_bank                         ; ..finally, get the bank number ;; @@55fd 141
                 jsr _sta_far                             ; sta (poker),y ;; @@5600 141
                 plz                                       ;; @@5603 141
                 !text $2c                                 ;; @@5604 141
 ;; @@5605 141
_local_1140_10   sta (poker),y                            ; NoMap ;; @@5605 141
 ;; @@5607 141
_local_1140_20   jsr chrgot                               ; eol? ;; @@5607 141
                 beq _local_1140_30                       ; yes ;; @@560a 141
                 inw poker                                ; no- increment address ;; @@560c 141
; lda poker  ; check for segment wrap (FFFF->0000) [910911] ;; @@560e 141
; ora poker+1 ;; @@560e 141
                 +lbeq omerr                              ; [910916] ;; @@560e 141
                 jsr optbyt                               ; & get next [,byte] ;; @@5611 141
                 bcs _local_1140_1                         ;; @@5614 141
 ;; @@5616 141
_local_1140_30   cli                                      ; [910612] ;; @@5616 141
                 rts                                       ;; @@5617 141
 ;; @@5618 141
 ;; @@5618 141
;.end ;; @@5618 141
; .page ;; @@5618 141
; .subttl  ERR$ ;; @@5618 141
 ;; @@5618 141
errd             jsr sign                                 ; get sign ;; @@5618 142
                 bmi _local_1141_1                        ; (allow err$(er) when er=-1) ;; @@561b 142
                 jsr conint                               ; get integer arg in x ;; @@561d 142
                 dex                                       ;; @@5620 142
                 txa                                      ; error # (0 to max-1) ;; @@5621 142
                 cmp #last_error_message                  ; check range ;; @@5622 142
                 bcc _local_1141_2                        ; ok ;; @@5624 142
                 ldx #0                                   ; too high, return null ;; @@5626 142
                 !text $2c                                 ;; @@5628 142
 ;; @@5629 142
_local_1141_1    ldx #2                                   ; no error, return "ok"    [910911] ;; @@5629 142
                 lda #<ok_error_message                    ;; @@562b 142
                 ldy #>ok_error_message                    ;; @@562d 142
                 sta index2                                ;; @@562f 142
                 sty index2+1                              ;; @@5631 142
                 bra _local_1141_30                       ; pass it ;; @@5633 142
 ;; @@5635 142
_local_1141_2    jsr erstup                               ; look up the error, set up a pointer to it ;; @@5635 142
                 ldy #$ff                                 ; determine how long it is ;; @@5638 142
                 ldx #0                                    ;; @@563a 142
_local_1141_10   inx                                      ; count printing characters ;; @@563c 142
_local_1141_20   iny                                       ;; @@563d 142
                 lda (index2),y                           ; (rom: ind.ok) ;; @@563e 142
                 bmi _local_1141_30                       ; msb set means last ;; @@5640 142
                 cmp #' '                                  ;; @@5642 142
                 bcc _local_1141_20                       ; don't count non-printers ;; @@5644 142
                 bra _local_1141_10                       ; count all others ;; @@5646 142
 ;; @@5648 142
_local_1141_30   txa                                      ; message length ;; @@5648 142
                 jsr strspa                               ; get space ;; @@5649 142
                 tax                                       ;; @@564c 142
                 beq _local_1141_50                       ; null ;; @@564d 142
 ;; @@564f 142
; sta sw_rom_ram1  ;set up string bank???? ;; @@564f 142
                 ldx #0                                    ;; @@564f 142
                 ldy #$ff                                  ;; @@5651 142
_local_1141_40   iny                                      ; copy message into memory ;; @@5653 142
                 lda (index2),y                           ; (rom: ind.ok) ;; @@5654 142
                 cmp #' '                                  ;; @@5656 142
                 bcc _local_1141_40                       ; skip non-printers ;; @@5658 142
 ;; @@565a 142
                 pha                                       ;; @@565a 142
                 and #$7f                                  ;; @@565b 142
                 phy                                      ; swap x&y ;; @@565d 142
                 phx                                       ;; @@565e 142
                 ply                                       ;; @@565f 142
                 ldx #dsctmp+1                             ;; @@5660 142
                 jsr sta_far_ram1                         ; sta (dsctmp+1),y to RAM1 ;; @@5662 142
                 phy                                      ; swap x&y ;; @@5665 142
                 plx                                       ;; @@5666 142
                 ply                                       ;; @@5667 142
                 inx                                       ;; @@5668 142
                 pla                                      ; test if msb was set ;; @@5669 142
                 bpl _local_1141_40                        ;; @@566a 142
 ;; @@566c 142
_local_1141_50   +lbra chrd1                              ; pla,pla,jmp putnew ;; @@566c 142
 ;; @@566f 142
 ;; @@566f 142
;.end ;; @@566f 142
; .page ;; @@566f 142
; .subttl  HEX$ ;; @@566f 142
 ;; @@566f 142
hexd             jsr chknum                                ;; @@566f 143
                 phw poker                                ; save linnum    [910911] ;; @@5672 143
                 jsr getadr                               ; 2 byte val in (poker) ;; @@5675 143
                 lda #4                                    ;; @@5678 143
                 jsr strspa                                ;; @@567a 143
                 ldy #0                                    ;; @@567d 143
                 lda poker+1                               ;; @@567f 143
                 jsr hexit                                 ;; @@5681 143
                 lda poker                                 ;; @@5684 143
                 jsr hexit                                 ;; @@5686 143
                 pla                                      ; restore linnum ;; @@5689 143
                 sta poker+1                               ;; @@568a 143
                 pla                                       ;; @@568c 143
                 sta poker                                 ;; @@568d 143
                 +lbra chrd1                              ; pla,pla,jmp putnew ;; @@568f 143
 ;; @@5692 143
hexit            pha                                       ;; @@5692 143
                 lsr                                       ;; @@5693 143
                 lsr                                       ;; @@5694 143
                 lsr                                       ;; @@5695 143
                 lsr                                       ;; @@5696 143
                 jsr dohex                                 ;; @@5697 143
                 pla                                       ;; @@569a 143
 ;; @@569b 143
dohex            and #$0f                                  ;; @@569b 143
                 cmp #$0a                                  ;; @@569d 143
                 bcc _local_1142_1                         ;; @@569f 143
                 adc #6                                    ;; @@56a1 143
_local_1142_1    adc #'0'                                  ;; @@56a3 143
                 phx                                       ;; @@56a5 143
                 ldx #dsctmp+1                             ;; @@56a6 143
                 jsr sta_far_ram1                         ; sta (dsctmp+1),y ;; @@56a8 143
                 plx                                       ;; @@56ab 143
                 iny                                       ;; @@56ac 143
                 rts                                       ;; @@56ad 143
 ;; @@56ae 143
;.end ;; @@56ae 143
; .page ;; @@56ae 143
; .subttl  JOY ;; @@56ae 143
 ;; @@56ae 143
;************************************************************* ;; @@56ae 143
; JOY (n)  -- Return joystick status ;; @@56ae 143
; ;; @@56ae 143
; where: n =  1  return position of joystick-1 ;; @@56ae 143
;       2  return position of joystick-2 ;; @@56ae 143
; ;; @@56ae 143
; result:      0  no direction, no button ;; @@56ae 143
;       1-8    direction (see below), no button ;; @@56ae 143
;       128 no direction, button ;; @@56ae 143
;       129-136 direction & button  128 + [1...8] ;; @@56ae 143
; ;; @@56ae 143
; button--->  128        1 ;; @@56ae 143
;       8     2 ;; @@56ae 143
; stick--->  7           3 ;; @@56ae 143
;       6     4 ;; @@56ae 143
;          5 ;; @@56ae 143
; ;; @@56ae 143
;************************************************************* ;; @@56ae 143
 ;; @@56ae 143
joy              jsr conint                               ; get 1 byte arg in x ;; @@56ae 144
                 dex                                       ;; @@56b1 144
                 cpx #2                                   ; make sure arg. is valid ;; @@56b2 144
                 +lbcs fcerr                              ; >1, error ;; @@56b4 144
 ;; @@56b7 144
                 txa                                       ;; @@56b7 144
                 eor #1                                   ; invert to match legends on case ;; @@56b8 144
                 tax                                       ;; @@56ba 144
                 php                                      ; save status ;; @@56bb 144
 ;; @@56bc 144
; jsr put_io_in_map ;; @@56bc 144
                 sei                                      ; disable IRQ to inhibit kybd ;; @@56bc 144
                 lda d1pra                                 ;; @@56bd 144
                 pha                                      ; save kybd output lines ;; @@56c0 144
                 ldy #$ff                                  ;; @@56c1 144
                 sty d1pra                                ; set to not read any kybd inputs ;; @@56c3 144
 ;; @@56c6 144
_local_1143_10   lda d1pra,x                              ; read joystick values ;; @@56c6 144
                 cmp d1pra,x                              ; debounce ;; @@56c9 144
                 bne _local_1143_10                        ;; @@56cc 144
 ;; @@56ce 144
                 tax                                      ; save joystick values ;; @@56ce 144
                 pla                                       ;; @@56cf 144
                 sta d1pra                                ; reset kybd output lines ;; @@56d0 144
                 txa                                      ; restore joystick values ;; @@56d3 144
                 plp                                      ; restore status ;; @@56d4 144
                 and #$0f                                 ; test which direction ;; @@56d5 144
                 tay                                       ;; @@56d7 144
                 lda joytab-5,y                           ; get direction indicator ;; @@56d8 144
                 tay                                      ; save direction : 0-8 ;; @@56db 144
                 txa                                      ; restore joystick value ;; @@56dc 144
                 and #$10                                 ; test if button triggered ;; @@56dd 144
                 bne _local_1143_20                       ; skip if not ;; @@56df 144
                 tya                                       ;; @@56e1 144
                 ora #$80                                 ; show trigger depressed ;; @@56e2 144
                 tay                                       ;; @@56e4 144
_local_1143_20   +lbra sngflt                             ; float 1 byte arg in y. ;; @@56e5 144
 ;; @@56e8 144
joytab           !text 4,2,3,0,6,8,7,0,5,1,0               ;; @@56e8 145
 ;; @@56f3 145
;.end ;; @@56f3 145
; .page ;; @@56f3 145
; .subttl  POT  LPEN ;; @@56f3 145
 ;; @@56f3 145
;*********************************************************** ;; @@56f3 145
; POT(n)  --  Read paddles ;; @@56f3 145
; ;; @@56f3 145
;    n = 1 : paddle-1 - X-position ;; @@56f3 145
;  2 : paddle-1 - Y-position ;; @@56f3 145
;  3 : paddle-2 - X-position ;; @@56f3 145
;  4 : paddle-2 - Y-position ;; @@56f3 145
; ;; @@56f3 145
;     result >= 256 --  trigger set ;; @@56f3 145
;*********************************************************** ;; @@56f3 145
 ;; @@56f3 145
pot              jsr chkcls                               ; look for closing paren ;; @@56f3 145
                 jsr conint                               ; get 1-byte arg in .x ;; @@56f6 145
                 dex                                       ;; @@56f9 145
                 cpx #4                                    ;; @@56fa 145
                 +lbcs fcerr                              ; value error ;; @@56fc 145
 ;; @@56ff 145
; jsr put_io_in_map ;; @@56ff 145
                 txa                                      ; convert arg (0-3) into paddle enables ;; @@56ff 145
                 lsr                                      ; .c= X/Y   .a= port 1/2 ;; @@5700 145
                 tax                                       ;; @@5701 145
                 lda sbits+6,x                             ;; @@5702 145
                 tax                                      ; (CIA paddle port, $40/$80) ;; @@5705 145
                 lda #0                                    ;; @@5706 145
                 rol                                       ;; @@5708 145
                 tay                                      ; (SID x/y offset,  $00/$01) ;; @@5709 145
 ;; @@570a 145
                 stx pot_temp_1                           ; save which port ;; @@570a 145
                 php                                      ; save IRQ enable while we ;; @@570d 145
                 sei                                      ; disable IRQ to inhibit keyboard scan ;; @@570e 145
                 lda d1pra                                 ;; @@570f 145
                 pha                                      ; save kybd output lines ;; @@5712 145
                 stx d1pra                                ; turn on correct paddle ;; @@5713 145
 ;; @@5716 145
                 jsr go_slow                               ;; @@5716 145
                 ldx #0                                    ;; @@5719 145
_local_1144_30   inx                                      ; delay to let pot be read by SID ;; @@571b 145
                 bne _local_1144_30                        ;; @@571c 145
 ;; @@571e 145
_local_1144_40   lda sid1+25,y                            ; read pot ;; @@571e 145
                 cmp sid1+25,y                            ; debounce ;; @@5721 145
                 bne _local_1144_40                        ;; @@5724 145
                 sta pot_temp_2                           ; save pot value ;; @@5726 145
                 jsr go_fast                               ;; @@5729 145
 ;; @@572c 145
                 ldx #0                                   ; set index to d1pra ;; @@572c 145
                 bit pot_temp_1                           ; test if pot-0,1 or pot-2,3 ;; @@572e 145
                 bmi _local_1144_50                       ; skip if pot 2,3 ;; @@5731 145
                 inx                                      ; index to d1prb ;; @@5733 145
_local_1144_50   lda #04                                  ; use joy line-2 ;; @@5734 145
                 dey                                      ; test if pot-x or pot-y ;; @@5736 145
                 bmi _local_1144_60                       ; skip if pot-x ;; @@5737 145
                 asl                                      ; use joy line-3 ;; @@5739 145
_local_1144_60   ldy #$ff                                  ;; @@573a 145
                 sty d1pra                                ; disable keybd inputs ;; @@573c 145
                 iny                                      ; set to zero for no trigger ;; @@573f 145
                 and d1pra,x                              ; test if trigger set ;; @@5740 145
                 bne _local_1144_70                       ; skip if not trigger ;; @@5743 145
                 iny                                      ; return value >255 for trigger ;; @@5745 145
_local_1144_70   pla                                       ;; @@5746 145
                 sta d1pra                                ; restore keybd lines ;; @@5747 145
                 tya                                       ;; @@574a 145
                 ldy pot_temp_2                           ; restore pot value ;; @@574b 145
                 plp                                      ; restore status ;; @@574e 145
                 +lbra nosflt                             ; output 2-byte result ;; @@574f 145
 ;; @@5752 145
; .page ;; @@5752 145
;************************************************************* ;; @@5752 145
;  LPEN(n)  --  Read light pen ;; @@5752 145
; ;; @@5752 145
; n = 0 x position ;; @@5752 145
;     1 y position ;; @@5752 145
;************************************************************* ;; @@5752 145
 ;; @@5752 145
lpen             jsr chkcls                               ; look for closing parens ;; @@5752 146
                 jsr conint                               ; get 1 byte arg in .X ;; @@5755 146
; dex   ;convert [1-2] to [0-1] ;; @@5758 146
                 cpx #2                                    ;; @@5758 146
                 +lbcs fcerr                              ; bad value ;; @@575a 146
 ;; @@575d 146
                 lda #0                                    ;; @@575d 146
                 sei                                       ;; @@575f 146
                 ldy lightpen_xpos,x                      ; get latched light pen value (a=msb, y=lsb) ;; @@5760 146
                 sta lightpen_xpos,x                      ; reset to zero (????preserve last latched position) ;; @@5763 146
                 cli                                       ;; @@5766 146
                 cpx #0                                    ;; @@5767 146
                 bne _local_1145_10                       ; done if y position ;; @@5769 146
                 tya                                       ;; @@576b 146
                 asl                                      ; else multiply *2 to get correct x position ;; @@576c 146
                 tay                                      ; lsb ;; @@576d 146
                 lda #0                                    ;; @@576e 146
                 rol                                      ; msb ;; @@5770 146
_local_1145_10   +lbra nosflt                             ; float it (y,a) ;; @@5771 146
 ;; @@5774 146
 ;; @@5774 146
;.end ;; @@5774 146
; .page ;; @@5774 146
; .subttl  POINTER ;; @@5774 146
 ;; @@5774 146
;****************************************************************** ;; @@5774 146
; ;; @@5774 146
; POINTER(var_name) - Return address of descriptor for var_name ;; @@5774 146
; ;; @@5774 146
;****************************************************************** ;; @@5774 146
 ;; @@5774 146
pointer          jsr chrget                               ; skip over escape token ;; @@5774 147
                 jsr chkopn                               ; test for open paren ;; @@5777 147
                 jsr isletc                               ; test if character follows parens ;; @@577a 147
                 +lbcc snerr                              ; ...syntax error if not. ;; @@577d 147
                 jsr ptrget                               ; look for this varname in table ;; @@5780 147
 ;; @@5783 147
pointer_ret      =*-1                                      ;; @@5783 147
                 tax                                       ;; @@5783 147
                 phy                                       ;; @@5784 147
                 jsr chkcls                               ; look for closing paren ;; @@5785 147
                 txa                                       ;; @@5788 147
                 tay                                       ;; @@5789 147
                 pla                                       ;; @@578a 147
                 cmp #>zero                               ; is this a dummy pointer? ;; @@578b 147
                 bne _local_1146_10                        ;; @@578d 147
                 lda #0                                   ; if so, return 0 ;; @@578f 147
                 tay                                       ;; @@5791 147
_local_1146_10   +lbra nosflt                              ;; @@5792 147
 ;; @@5795 147
;.end ;; @@5795 147
; .page ;; @@5795 147
; .subttl  XOR ;; @@5795 147
 ;; @@5795 147
;************************************************************** ;; @@5795 147
;* ;; @@5795 147
;*   XOR - Exclusive-or two 16 bit arguments ;; @@5795 147
;* ;; @@5795 147
;* Syntax : XOR (arg1, arg2) ;; @@5795 147
;* ;; @@5795 147
;************************************************************** ;; @@5795 147
 ;; @@5795 147
xor              phw poker                                ; protect the poker value (could be in use)  [910911] ;; @@5795 148
                 jsr chknum                                ;; @@5798 148
                 jsr getadr                               ; get first arg ;; @@579b 148
                 pha                                      ; save MSB ;; @@579e 148
                 phy                                      ; save LSB ;; @@579f 148
 ;; @@57a0 148
                 jsr comwrd                               ; check for comma, get word ;; @@57a0 148
                 jsr chkcls                               ; check for closing parens ;; @@57a3 148
 ;; @@57a6 148
                 pla                                       ;; @@57a6 148
                 eor poker                                ; xor LSB (comwrd left a copy of its arg in POKER) ;; @@57a7 148
                 tay                                       ;; @@57a9 148
                 pla                                       ;; @@57aa 148
                 eor poker+1                              ; ..and MSB ;; @@57ab 148
                 jsr nosflt                               ; ..and go float 'em ;; @@57ad 148
 ;; @@57b0 148
                 pla                                       ;; @@57b0 148
                 sta poker+1                               ;; @@57b1 148
                 pla                                       ;; @@57b3 148
                 sta poker                                 ;; @@57b4 148
                 rts                                       ;; @@57b6 148
 ;; @@57b7 148
;.end ;; @@57b7 148
; .page ;; @@57b7 148
; .subttl  MOD ;; @@57b7 148
 ;; @@57b7 148
;************************************************************** ;; @@57b7 148
;* ;; @@57b7 148
;* MOD  -  Modulus of a number ;; @@57b7 148
;* ;; @@57b7 148
;* Syntax : MOD (number, range) ;; @@57b7 148
;*      910402 FAB ;; @@57b7 148
;************************************************************** ;; @@57b7 148
 ;; @@57b7 148
; Calculate   MOD = NUMBER-RANGE*INT(NUMBER/RANGE) ;; @@57b7 148
 ;; @@57b7 148
mod              jsr chknum                               ; 1st arg in FAC1 (number) ;; @@57b7 148
                 jsr pushf1                               ; save two copies of it for later ;; @@57ba 148
                 jsr pushf1                                ;; @@57bd 148
                 jsr chkcom                               ; check for comma ;; @@57c0 148
                 jsr frmnum                               ; 2nd arg in FAC1 (range) ;; @@57c3 148
                 jsr chkcls                               ; check for closing paren ;; @@57c6 148
 ;; @@57c9 148
                 jsr movaf                                ; save range in FAC2 ;; @@57c9 148
                 jsr pullf1                               ; get back number in FAC1 ;; @@57cc 148
                 ldx #5                                   ; swap FAC1 and FAC2 ;; @@57cf 148
_local_1147_10   lda facexp,x                              ;; @@57d1 148
                 ldy argexp,x                              ;; @@57d3 148
                 sta argexp,x                              ;; @@57d5 148
                 sty facexp,x                              ;; @@57d7 148
                 dex                                       ;; @@57d9 148
                 bpl _local_1147_10                        ;; @@57da 148
                 jsr pushf1                               ; save one copy of range for later ;; @@57dc 148
 ;; @@57df 148
                 jsr fdivt_c65                            ; number/range ;; @@57df 148
                 jsr int                                  ; INT(number/range) ;; @@57e2 148
                 jsr movaf                                ; round & move to FAC2 ;; @@57e5 148
                 jsr pullf1                               ; retrieve arg2 (range) ;; @@57e8 148
                 jsr fmultt_c65                           ; range*INT(number/range) ;; @@57eb 148
                 jsr negop                                ; -range*INT(number/range) ;; @@57ee 148
                 jsr movaf                                ; move to FAC2 ;; @@57f1 148
                 jsr pullf1                               ; retrieve arg1 (number) ;; @@57f4 148
                 +lbra faddt_c65                          ; number-range*INT(number/range) ;; @@57f7 148
 ;; @@57fa 148
 ;; @@57fa 148
;.end ;; @@57fa 148
; .page ;; @@57fa 148
; .subttl  RWINDOW ;; @@57fa 148
 ;; @@57fa 148
;****************************************************************************** ;; @@57fa 148
; ;; @@57fa 148
; RWINDOW  - Returns information about the current console display environment. ;; @@57fa 148
; ;; @@57fa 148
;   Syntax : RWINDOW (n) ;; @@57fa 148
; ;; @@57fa 148
;   Where: n=0 : number of lines in the current window ;; @@57fa 148
;   =1 : number of rows in the current window ;; @@57fa 148
;   =2 : returns either 40 or 80, depending on the ;; @@57fa 148
;   current console device ;; @@57fa 148
; ;; @@57fa 148
;****************************************************************************** ;; @@57fa 148
 ;; @@57fa 148
rwindow          jsr chkcls                                ;; @@57fa 149
                 jsr conint                                ;; @@57fd 149
                 cpx #2                                    ;; @@5800 149
                 beq _local_1148_50                       ; return current console ;; @@5802 149
                 +lbcs fcerr                               ;; @@5804 149
 ;; @@5807 149
                 cpx #0                                    ;; @@5807 149
                 bne _local_1148_10                        ;; @@5809 149
 ;; @@580b 149
                 lda _screen_bottom                        ;; @@580b 149
                 sec                                       ;; @@580d 149
                 sbc _screen_top                           ;; @@580e 149
                 bra _local_1148_60                       ; always ;; @@5810 149
 ;; @@5812 149
_local_1148_10   lda _screen_right                         ;; @@5812 149
                 sec                                       ;; @@5814 149
                 sbc _screen_left                          ;; @@5815 149
                 bra _local_1148_60                       ; always ;; @@5817 149
 ;; @@5819 149
 ;; @@5819 149
_local_1148_50   lda #80                                  ; assume 80 col ;; @@5819 149
                 bbr7 _mode,_local_1148_60                 ;; @@581b 149
                 lsr                                       ;; @@581e 149
_local_1148_60   tay                                       ;; @@581f 149
                 +lbra sngflt                             ; float 1 byte arg in .Y ;; @@5820 149
 ;; @@5823 149
;.end ;; @@5823 149
; .page ;; @@5823 149
; .subttl  RND ;; @@5823 149
 ;; @@5823 149
;    Random Number Function  RND(x) ;; @@5823 149
; ;; @@5823 149
;  x=0 ==> generate a random number based on hardware clock & noisy POT lines ;; @@5823 149
;  x<0 ==> seed a reproducable, pseudo-random number generator ;; @@5823 149
;  x>0 ==> generate a reproducable pseudo-random # based upon seed value above ;; @@5823 149
 ;; @@5823 149
 ;; @@5823 149
rnd              jsr sign                                 ; get sign into .a ;; @@5823 150
 ;; @@5826 150
rnd_0            bmi _local_1149_20                       ; /// entry from jump table ;; @@5826 150
                 bne _local_1149_10                        ;; @@5828 150
 ;; @@582a 150
 ;; @@582a 150
; Get value from hardware ;; @@582a 150
 ;; @@582a 150
                 jsr go_slow                              ; Use CIA#1 timer B & SID#2 pot X & Y for seeds  [910314] ;; @@582a 150
                 lda sid2+25                              ; go slow to read POT-X ;; @@582d 150
                 asl                                       ;; @@5830 150
                 asl                                       ;; @@5831 150
                 asl                                       ;; @@5832 150
                 asl                                       ;; @@5833 150
                 ora sid2+26                              ; and POT-Y ;; @@5834 150
                 eor vic+18                               ; ???? should be okay- we're in Slow mode ;; @@5837 150
                 sta facmoh                                ;; @@583a 150
                 jsr go_fast                              ; restore speed ;; @@583c 150
                 lda d1pra+6                              ; timer B is free-running ;; @@583f 150
                 sta facmo                                 ;; @@5842 150
                 lda d1pra+7                               ;; @@5844 150
                 sta faclo                                 ;; @@5847 150
                 eor facho                                 ;; @@5849 150
                 adc facmoh                                ;; @@584b 150
                 eor facmo                                 ;; @@584d 150
                 adc faclo                                 ;; @@584f 150
                 sta facho                                 ;; @@5851 150
                 bra _local_1149_30                        ;; @@5853 150
 ;; @@5855 150
; .page ;; @@5855 150
_local_1149_10   lda #<rndx                               ; get last one into FAC ;; @@5855 150
                 ldy #>rndx                                ;; @@5857 150
                 jsr movfm                                 ;; @@5859 150
                 lda #<rmulc                               ;; @@585c 150
                 ldy #>rmulc                              ; FAC was zero.  restore last one ;; @@585e 150
                 jsr rommlt                               ; multiply by random constant ;; @@5860 150
                 lda #<raddc                               ;; @@5863 150
                 ldy #>raddc                               ;; @@5865 150
                 jsr romadd                               ; add random constant ;; @@5867 150
 ;; @@586a 150
_local_1149_20   ldx faclo                                 ;; @@586a 150
                 lda facho                                 ;; @@586c 150
                 sta faclo                                 ;; @@586e 150
                 stx facho                                ; reverse hi and lo ;; @@5870 150
                 ldx facmoh                                ;; @@5872 150
                 lda facmo                                 ;; @@5874 150
                 sta facmoh                                ;; @@5876 150
                 stx facmo                                 ;; @@5878 150
 ;; @@587a 150
_local_1149_30   lda #0                                   ; strnex.  make number positive ;; @@587a 150
                 sta facsgn                                ;; @@587c 150
                 lda facexp                               ; put exp where it will ;; @@587e 150
                 sta facov                                ; be shifted in by normal ;; @@5880 150
                 lda #$80                                  ;; @@5882 150
                 sta facexp                               ; make result between 0 and 1 ;; @@5884 150
                 jsr normal                               ; normalize ;; @@5886 150
                 ldx #<rndx                                ;; @@5889 150
                 ldy #>rndx                                ;; @@588b 150
                 +lbra movmf                              ; put new one into memory ;; @@588d 150
 ;; @@5890 150
rmulc            !text 152,53,68,122,0                     ;; @@5890 151
raddc            !text 104,40,177,70,0                     ;; @@5895 151
 ;; @@589a 151
;.end ;; @@589a 151
; .page ;; @@589a 151
; .subttl Math Package (CODE12) ;; @@589a 151
 ;; @@589a 151
n32768           !text $90,$80,0,0,0                       ;; @@589a 151
 ;; @@589f 151
 ;; @@589f 151
flpint           jsr ayint                                 ;; @@589f 151
                 lda facmo                                 ;; @@58a2 151
                 ldy  faclo                                ;; @@58a4 151
                 rts                                       ;; @@58a6 151
 ;; @@58a7 151
 ;; @@58a7 151
intidx           jsr chrget                                ;; @@58a7 151
                 jsr frmevl                               ; get a number ;; @@58aa 151
 ;; @@58ad 151
 ;; @@58ad 151
posint           jsr chknum                                ;; @@58ad 151
                 lda facsgn                                ;; @@58b0 151
                 bmi nonono                               ; if negative, blow him out ;; @@58b2 151
 ;; @@58b4 151
 ;; @@58b4 151
ayint            lda facexp                                ;; @@58b4 151
                 cmp #$90                                 ; FAC > 32767? ;; @@58b6 151
                 bcc qintgo                                ;; @@58b8 151
                 lda #<n32768                             ; get address of -32768 ;; @@58ba 151
                 ldy #>n32768                              ;; @@58bc 151
                 jsr fcomp                                ; see if FAC=((x)) ;; @@58be 151
 ;; @@58c1 151
nonono           +lbne fcerr                              ; no, FAC is too big ;; @@58c1 151
qintgo           +lbra qint                               ; go shove it ;; @@58c4 151
; .page ;; @@58c7 151
 ;; @@58c7 151
; Float an unsigned double byte integer ;; @@58c7 151
; Entry:  MSB in (a), LSB in (y) ;; @@58c7 151
 ;; @@58c7 151
nosflt           jsr stoint                                ;; @@58c7 151
                 sec                                      ; sign is positive ;; @@58ca 151
                 +lbra floatc                              ;; @@58cb 151
 ;; @@58ce 151
 ;; @@58ce 151
 ;; @@58ce 151
pos              sec                                       ;; @@58ce 151
                 jsr _plot                                ; get tab pos in .y ;; @@58cf 151
 ;; @@58d2 151
sngflt           lda #0                                    ;; @@58d2 151
                 +lbra givayf                             ; float it ;; @@58d4 151
 ;; @@58d7 151
 ;; @@58d7 151
 ;; @@58d7 151
stoint           ldx #0                                   ; move int to fac & compute proper exponents ;; @@58d7 151
                 stx valtyp                                ;; @@58d9 151
                 sta facho                                 ;; @@58db 151
                 sty facho+1                               ;; @@58dd 151
                 ldx #$90                                  ;; @@58df 151
storts           rts                                       ;; @@58e1 151
 ;; @@58e2 151
 ;; @@58e2 151
 ;; @@58e2 151
; See if we are in direct mode, and complain if so. ;; @@58e2 151
 ;; @@58e2 151
errdir           bbs7 runmod,storts                       ; goto error if not in run mode ;; @@58e2 151
 ;; @@58e5 151
                 ldx #errid                               ; input direct error code ;; @@58e5 151
                 !text $2c                                 ;; @@58e7 151
 ;; @@58e8 151
errguf           ldx #erruf                                ;; @@58e8 151
                 +lbra error                               ;; @@58ea 151
 ;; @@58ed 151
 ;; @@58ed 151
errind           bbr7 runmod,storts                       ; goto error if not in direct mode ;; @@58ed 151
                 ldx #erroid                               ;; @@58f0 151
                 +lbra error                               ;; @@58f2 151
 ;; @@58f5 151
;.end ;; @@58f5 151
; .page ;; @@58f5 151
; .subttl User Defined Function ;; @@58f5 151
 ;; @@58f5 151
; User Defined Function Code ;; @@58f5 151
; ;; @@58f5 151
; Note only single arguments are allowed to functions, and functions must ;; @@58f5 151
; be of the single line form: ;; @@58f5 151
; ;; @@58f5 151
;  DEF FNA(x)=x~2 + x-2 ;; @@58f5 151
; ;; @@58f5 151
; No strings may be involved with these functions. ;; @@58f5 151
; ;; @@58f5 151
; Idea: create a simple variable entry whose first character has the MSB set. ;; @@58f5 151
; The value will be: ;; @@58f5 151
; ;; @@58f5 151
;  A text pointer to the formula ;; @@58f5 151
;  A pointer to the argument variable ;; @@58f5 151
 ;; @@58f5 151
def              jsr getfnm                               ; get a pointer to the function ;; @@58f5 151
                 jsr errdir                                ;; @@58f8 151
                 jsr chkopn                               ; must have a ( ;; @@58fb 151
                 lda #$80                                  ;; @@58fe 151
                 sta subflg                               ; prohibit subscripted & integer variables ;; @@5900 151
                 jsr ptrget                               ; get pointer to argument ;; @@5902 151
                 jsr chknum                               ; is it a number? ;; @@5905 151
                 jsr chkcls                               ; must have ) ;; @@5908 151
                 lda #equal_token                         ; followed by = ;; @@590b 151
                 jsr synchr                                ;; @@590d 151
                 pha                                       ;; @@5910 151
                 lda varpnt+1                              ;; @@5911 151
                 pha                                       ;; @@5913 151
                 lda varpnt                                ;; @@5914 151
                 pha                                       ;; @@5916 151
                 lda txtptr+1                              ;; @@5917 151
                 pha                                       ;; @@5919 151
                 lda txtptr                                ;; @@591a 151
                 pha                                       ;; @@591c 151
                 jsr data                                  ;; @@591d 151
                 bra deffin                                ;; @@5920 151
 ;; @@5922 151
; .page ;; @@5922 151
; Subroutine to get a pointer to a function name ;; @@5922 151
 ;; @@5922 151
getfnm           lda #fn_token                            ; must start with fn ;; @@5922 151
                 jsr synchr                                ;; @@5924 151
                 ora #$80                                 ; put function bit on ;; @@5927 151
                 sta subflg                               ; (disallows array & integer variables) ;; @@5929 151
                 jsr ptrgt2                               ; get pointer to function or create anew ;; @@592b 151
                 sta defpnt                                ;; @@592e 151
                 sty defpnt+1                              ;; @@5930 151
                 +lbra chknum                             ; make sure it's not a string, and return ;; @@5932 151
 ;; @@5935 151
 ;; @@5935 151
fndoer           jsr getfnm                               ; get the function's name ;; @@5935 151
                 lda defpnt+1                              ;; @@5938 151
                 pha                                       ;; @@593a 151
                 lda defpnt                                ;; @@593b 151
                 pha                                       ;; @@593d 151
                 jsr parchk                               ; evaluate parameter ;; @@593e 151
                 jsr chknum                                ;; @@5941 151
                 pla                                       ;; @@5944 151
                 sta defpnt                                ;; @@5945 151
                 pla                                       ;; @@5947 151
                 sta defpnt+1                              ;; @@5948 151
                 ldy #2                                    ;; @@594a 151
                 jsr inddef                               ; get pointer to the variable ;; @@594c 151
                 sta varpnt                               ; save variable pointer ;; @@594f 151
                 tax                                       ;; @@5951 151
                 iny                                       ;; @@5952 151
                 jsr inddef                                ;; @@5953 151
                 beq errguf                                ;; @@5956 151
                 sta varpnt+1                              ;; @@5958 151
                 iny                                      ; since def uses only 4 ;; @@595a 151
 ;; @@595b 151
; .page ;; @@595b 151
defstf           lda #varpnt                               ;; @@595b 151
                 jsr lda_far_ram1                          ;; @@595d 151
                 pha                                      ; push it all on the stack, since we might be recursing ;; @@5960 151
                 dey                                       ;; @@5961 151
                 bpl defstf                                ;; @@5962 151
                 ldy varpnt+1                              ;; @@5964 151
 ;; @@5966 151
                 jsr movmf_ram1                           ; put current FAC into our argument variable ;; @@5966 151
                 lda txtptr+1                             ; save variable pointer ;; @@5969 151
                 pha                                       ;; @@596b 151
                 lda txtptr                                ;; @@596c 151
                 pha                                       ;; @@596e 151
                 jsr inddef                               ; get pointer to function ;; @@596f 151
                 sta txtptr                                ;; @@5972 151
                 iny                                       ;; @@5974 151
                 jsr inddef                                ;; @@5975 151
                 sta txtptr+1                              ;; @@5978 151
                 lda varpnt+1                             ; save variable pointer ;; @@597a 151
                 pha                                       ;; @@597c 151
                 lda varpnt                                ;; @@597d 151
                 pha                                       ;; @@597f 151
                 jsr frmnum                               ; evaluate variable, and check numeric ;; @@5980 151
                 pla                                       ;; @@5983 151
                 sta defpnt                                ;; @@5984 151
                 pla                                       ;; @@5986 151
                 sta defpnt+1                              ;; @@5987 151
                 jsr chrgot                                ;; @@5989 151
                 +lbne snerr                              ; it didn't terminate, syntax error ;; @@598c 151
 ;; @@598f 151
                 pla                                      ; restore text pointer ;; @@598f 151
                 sta txtptr                                ;; @@5990 151
                 pla                                       ;; @@5992 151
                 sta txtptr+1                              ;; @@5993 151
 ;; @@5995 151
deffin           ldy #0                                    ;; @@5995 151
_local_1150_1    pla                                      ; get old arg value off stack, ;; @@5997 151
                 phx                                       ;; @@5998 151
                 ldx #defpnt                               ;; @@5999 151
                 jsr sta_far_ram1 ;sta (defpnt),y         ; and put it back in variable ;; @@599b 151
                 plx                                       ;; @@599e 151
                 iny                                       ;; @@599f 151
                 cpy #5                                    ;; @@59a0 151
                 bne _local_1150_1                         ;; @@59a2 151
                 rts                                       ;; @@59a4 151
 ;; @@59a5 151
;.end ;; @@59a5 151
; .page ;; @@59a5 151
; .subttl MID$  LEFT$  RIGHT$  ASC  STR$  LEN ;; @@59a5 151
 ;; @@59a5 151
; The STR$() function takes a number and gives a string with ;; @@59a5 151
; the characters the output of the number would have given. ;; @@59a5 151
 ;; @@59a5 151
strd             jsr chknum                               ; arg has to be numeric ;; @@59a5 152
                 ldy #0                                    ;; @@59a8 152
                 jsr foutc                                ; do its output ;; @@59aa 152
                 pla                                       ;; @@59ad 152
                 pla                                       ;; @@59ae 152
 ;; @@59af 152
timstr           lda #<lofbuf                              ;; @@59af 152
                 ldy #>lofbuf                              ;; @@59b1 152
                 +lbra strlit                              ;; @@59b3 152
 ;; @@59b6 152
 ;; @@59b6 152
; CHR$() creates a string which contains as its only character the PETSCII ;; @@59b6 152
; equivalent of the integer argument (#) which must be < 256. ;; @@59b6 152
 ;; @@59b6 152
chrd             jsr conint                               ; get integer in range ;; @@59b6 152
                 phx                                       ;; @@59b9 152
                 lda #1                                   ; one-character string ;; @@59ba 152
                 jsr strspa                               ; get space for string ;; @@59bc 152
                 ldy #0                                    ;; @@59bf 152
                 pla                                       ;; @@59c1 152
; phx   ;set up string bank ;; @@59c2 152
                 ldx #dsctmp+1                             ;; @@59c2 152
                 jsr sta_far_ram1                         ; sta (dsctmp+1),y ;; @@59c4 152
; plx ;; @@59c7 152
 ;; @@59c7 152
chrd1            pla                                      ; get rid of "chknum" return address ;; @@59c7 152
                 pla                                       ;; @@59c8 152
                 +lbra putnew                             ; setup FAC to point to desc ;; @@59c9 152
; .page ;; @@59cc 152
 ;; @@59cc 152
; The following is the LEFT$($,#) function.  It takes the leftmost # characters ;; @@59cc 152
; of the string.  If # > len of the string, it returns the whole string. ;; @@59cc 152
 ;; @@59cc 152
leftd            jsr pream                                ; test parameters ;; @@59cc 152
                 pha                                      ; # arg ;; @@59cf 152
                 jsr inddpt                               ; string len ;; @@59d0 152
                 sta syntmp                                ;; @@59d3 152
                 pla                                       ;; @@59d5 152
                 cmp syntmp                                ;; @@59d6 152
                 tya                                      ; that's all there is to LEFT$ ;; @@59d8 152
 ;; @@59d9 152
rleft            bcc _local_1151_1                         ;; @@59d9 152
                 jsr inddpt                                ;; @@59db 152
                 tax                                      ; put length into x ;; @@59de 152
                 tya                                      ; zero (a), the offset ;; @@59df 152
_local_1151_1    pha                                      ; save offset ;; @@59e0 152
rleft2           txa                                       ;; @@59e1 153
rleft3           pha                                      ; save length ;; @@59e2 153
                 jsr strspa                               ; get space ;; @@59e3 153
                 lda dscpnt                                ;; @@59e6 153
                 ldy dscpnt+1                              ;; @@59e8 153
                 jsr fretmp                                ;; @@59ea 153
                 ply                                       ;; @@59ed 153
                 pla                                       ;; @@59ee 153
                 clc                                       ;; @@59ef 153
                 adc index                                ; compute where to copy ;; @@59f0 153
                 sta index                                 ;; @@59f2 153
                 bcc _local_1152_1                         ;; @@59f4 153
                 inc index+1                               ;; @@59f6 153
_local_1152_1    tya                                       ;; @@59f8 153
                 jsr movdo                                ; go move it ;; @@59f9 153
                 +lbra putnew                              ;; @@59fc 153
 ;; @@59ff 153
 ;; @@59ff 153
 ;; @@59ff 153
rightd           jsr pream                                 ;; @@59ff 154
                 pha                                       ;; @@5a02 154
                 jsr inddpt                                ;; @@5a03 154
                 sta syntmp                                ;; @@5a06 154
                 pla                                       ;; @@5a08 154
                 clc                                      ; (length des'd)-(length)-1 ;; @@5a09 154
                 sbc syntmp                                ;; @@5a0a 154
                 eor #$ff                                 ; negate ;; @@5a0c 154
                 bra rleft                                 ;; @@5a0e 154
 ;; @@5a10 154
 ;; @@5a10 154
; MID$($,#) returns string with chars from # position onward. If # > LEN($) ;; @@5a10 154
; then return null string.  MID($,#,#) returns string with characters from ;; @@5a10 154
; # position for #2 characters.  If #2 goes past end of string return as much ;; @@5a10 154
; as possible. ;; @@5a10 154
 ;; @@5a10 154
midd             lda #255                                 ; default ;; @@5a10 154
                 sta faclo                                ; save for later compare ;; @@5a12 154
                 jsr chrgot                               ; get current character ;; @@5a14 154
                 cmp #')'                                 ; is it a right paren )? ;; @@5a17 154
                 beq _local_1153_1                        ; no third paren. ;; @@5a19 154
; jsr chkcom  ;must have comma ;; @@5a1b 154
; jsr getbyt  ;get the length into "faclo" ;; @@5a1b 154
                 jsr combyt                               ; [910820] ;; @@5a1b 154
 ;; @@5a1e 154
_local_1153_1    jsr pream                                ; check it out ;; @@5a1e 154
                 +lbeq fcerr                              ; illegal qty error ;; @@5a21 154
                 dex                                      ; compute offset ;; @@5a24 154
                 phx                                       ;; @@5a25 154
                 phx                                      ; preserve a while (2 copies) ;; @@5a26 154
                 ldx #0                                    ;; @@5a27 154
                 jsr inddpt                               ; get length of what's left ;; @@5a29 154
                 sta syntmp                                ;; @@5a2c 154
                 pla                                       ;; @@5a2e 154
                 clc                                       ;; @@5a2f 154
                 sbc syntmp                                ;; @@5a30 154
                 bcs rleft2                               ; give null string ;; @@5a32 154
                 eor #$ff                                 ; in sub c was 0 so just complement ;; @@5a34 154
                 cmp faclo                                ; greater than what's desired ;; @@5a36 154
                 bcc rleft3                               ; no, just copy that much ;; @@5a38 154
                 lda faclo                                ; get length of what's desired ;; @@5a3a 154
                 bcs rleft3                               ; copy it ;; @@5a3c 154
 ;; @@5a3e 154
 ;; @@5a3e 154
 ;; @@5a3e 154
 ;; @@5a3e 154
; Common routine used by RIGHT$, LEFT$, MID$, for parameter chk and setup. ;; @@5a3e 154
 ;; @@5a3e 154
pream            jsr chkcls                               ; param list should end ;; @@5a3e 155
                 ply                                       ;; @@5a41 155
                 pla                                       ;; @@5a42 155
                 sta jmper+1                              ; get return address ;; @@5a43 155
                 pla                                      ; get rid of fingo's jsr ret addr ;; @@5a45 155
                 pla                                       ;; @@5a46 155
                 plx                                      ; get length ;; @@5a47 155
                 pla                                       ;; @@5a48 155
                 sta dscpnt                                ;; @@5a49 155
                 pla                                       ;; @@5a4b 155
                 sta dscpnt+1                              ;; @@5a4c 155
                 lda jmper+1                               ;; @@5a4e 155
                 pha                                       ;; @@5a50 155
                 phy                                       ;; @@5a51 155
                 ldy #0                                    ;; @@5a52 155
                 txa                                       ;; @@5a54 155
                 rts                                       ;; @@5a55 155
 ;; @@5a56 155
 ;; @@5a56 155
 ;; @@5a56 155
; The function LEN$() returns the length of the string passed as an argument. ;; @@5a56 155
 ;; @@5a56 155
len              bsr len1                                  ;; @@5a56 155
                 +lbra sngflt                              ;; @@5a59 155
 ;; @@5a5c 155
len1             jsr frestr                               ; free up string ;; @@5a5c 155
                 ldx #0                                    ;; @@5a5f 155
                 stx valtyp                               ; force numeric ;; @@5a61 155
                 tay                                      ; set condition codes ;; @@5a63 155
                 rts                                      ; done ;; @@5a64 155
 ;; @@5a65 155
 ;; @@5a65 155
 ;; @@5a65 155
 ;; @@5a65 155
 ;; @@5a65 155
; The following is the ASC$() function.  It returns an integer which is the ;; @@5a65 155
; decimal equivalent of the PETSCII string argument. ;; @@5a65 155
 ;; @@5a65 155
asc              jsr len1                                  ;; @@5a65 155
                 beq _local_1154_1                        ; it was null (zero length) ;; @@5a68 155
                 ldy #0                                    ;; @@5a6a 155
                 jsr indin1_ram1                          ; get 1st character ;; @@5a6c 155
                 tay                                       ;; @@5a6f 155
_local_1154_1    +lbra sngflt                              ;; @@5a70 155
 ;; @@5a73 155
;.end ;; @@5a73 155
; .page ;; @@5a73 155
; .subttl String Routines ;; @@5a73 155
 ;; @@5a73 155
 ;; @@5a73 155
 ;; @@5a73 155
; STRINI gets string space for the creation of a string and creates ;; @@5a73 155
; a descriptor for it in DSCTMP. ;; @@5a73 155
 ;; @@5a73 155
strini                                                     ;; @@5a73 156
                 ldx facmo                                ; get facmo to store in dscpnt ;; @@5a73 156
                 ldy facmo+1                               ;; @@5a75 156
                 stx dscpnt                               ; retain the descriptor pointer ;; @@5a77 156
                 sty dscpnt+1                              ;; @@5a79 156
 ;; @@5a7b 156
strspa           jsr getspa                               ; get string space ;; @@5a7b 156
                 stx dsctmp+1                             ; save location ;; @@5a7e 156
                 sty dsctmp+2                              ;; @@5a80 156
                 sta dsctmp                               ; save length ;; @@5a82 156
                 rts                                      ; done ;; @@5a84 156
 ;; @@5a85 156
; .page ;; @@5a85 156
; STRLT2 takes the string literal whose first character is pointed to by ;; @@5a85 156
; (xreg)+1 and builds a descriptor for it.  The descriptor is initially ;; @@5a85 156
; built in DSCTMP, but PUTNEW transfers it into a temporary and leaves a ;; @@5a85 156
; pointer to the temporary in FACMO & FACLO.  The characters other than the ;; @@5a85 156
; zero that terminates the string should be set up in CHARAC and ENDCHR. ;; @@5a85 156
; If the terminator is a quote, the quote is skipped over.  Leading quotes ;; @@5a85 156
; should be skipped before call.  On return, the character after the string ;; @@5a85 156
; literal is pointed to by (strng2). ;; @@5a85 156
 ;; @@5a85 156
 ;; @@5a85 156
strlit           ldx #'"'                                 ; assume string ends on quote ;; @@5a85 156
                 stx charac                                ;; @@5a87 156
                 stx endchr                                ;; @@5a89 156
 ;; @@5a8b 156
strlt2           sta strng1                               ; save pointer to string ;; @@5a8b 156
                 sty strng1+1                              ;; @@5a8d 156
                 sta dsctmp+1                             ; in case no strcpy ;; @@5a8f 156
                 sty dsctmp+2                              ;; @@5a91 156
 ;; @@5a93 156
                 ldy #255                                 ; initialize character count ;; @@5a93 156
strget           iny                                       ;; @@5a95 156
                 jsr indst1                               ; get character ;; @@5a96 156
                 beq _local_1155_20                       ; if zero ;; @@5a99 156
                 cmp charac                               ; this terminator? ;; @@5a9b 156
                 beq _local_1155_10                       ; yes ;; @@5a9d 156
                 cmp endchr                                ;; @@5a9f 156
                 bne strget                               ; look further ;; @@5aa1 156
 ;; @@5aa3 156
_local_1155_10   cmp #'"'                                 ; strfin.  quote? ;; @@5aa3 156
                 beq _local_1155_30                        ;; @@5aa5 156
 ;; @@5aa7 156
_local_1155_20   clc                                       ;; @@5aa7 156
_local_1155_30   sty dsctmp                               ; no, back up. retain count ;; @@5aa8 156
                 tya                                       ;; @@5aaa 156
                 adc strng1                               ; wishing to set (txtptr) ;; @@5aab 156
                 sta strng2                                ;; @@5aad 156
                 ldx strng1+1                              ;; @@5aaf 156
                 bcc _local_1155_40                        ;; @@5ab1 156
                 inx                                       ;; @@5ab3 156
_local_1155_40   stx strng2+1                              ;; @@5ab4 156
                 tya                                       ;; @@5ab6 156
 ;; @@5ab7 156
; .page ;; @@5ab7 156
strlit_1                                                  ; //// entry from SPRSAV ;; @@5ab7 157
                 jsr strini                                ;; @@5ab7 157
                 tay                                       ;; @@5aba 157
                 beq putnew                               ; length=0, don't bother copying ;; @@5abb 157
                 pha                                      ; save length ;; @@5abd 157
                 phx                                       ;; @@5abe 157
                 ldx #frespc                               ;; @@5abf 157
_local_1156_10   dey                                       ;; @@5ac1 157
                 jsr indst1                               ; lda (strng1),y in bank 0 ;; @@5ac2 157
                 jsr sta_far_ram1                         ; sta (frespc),y in bank 1 ;; @@5ac5 157
                 tya                                       ;; @@5ac8 157
                 bne _local_1156_10                        ;; @@5ac9 157
                 plx                                       ;; @@5acb 157
                 pla                                      ; restore length ;; @@5acc 157
                 jsr mvdone                               ; finish up by updating frespc ;; @@5acd 157
 ;; @@5ad0 157
; .page ;; @@5ad0 157
; Some string function is returning a result in DSCTMP.  Set up a temp ;; @@5ad0 157
; descriptor with DSCTMP in it.  Put a pointer to the descriptor in FACMO&LO ;; @@5ad0 157
; and flag the result as a string type. ;; @@5ad0 157
 ;; @@5ad0 157
putnew           ldx temppt                               ; pointer to first free temp ;; @@5ad0 158
                 cpx #tempst+strsiz+strsiz+strsiz          ;; @@5ad2 158
                 +lbeq sterr                              ; string temporary error ;; @@5ad4 158
 ;; @@5ad7 158
                 lda dsctmp                               ; length ;; @@5ad7 158
                 sta 0,x                                   ;; @@5ad9 158
                 lda dsctmp+1                             ; pointer to string lo ;; @@5adb 158
                 sta 1,x                                   ;; @@5add 158
                 lda dsctmp+2                             ; hi ;; @@5adf 158
                 sta 2,x                                   ;; @@5ae1 158
 ;; @@5ae3 158
                 ldy #0                                   ; pointer to temp. descriptor ;; @@5ae3 158
                 stx facmo                                ; lo ;; @@5ae5 158
                 sty facmo+1                              ; hi ;; @@5ae7 158
                 sty facov                                 ;; @@5ae9 158
                 dey                                      ; ($ff) ;; @@5aeb 158
                 sty valtyp                               ; type is string ;; @@5aec 158
                 stx lastpt                               ; set pointer to last-used temp ;; @@5aee 158
 ;; @@5af0 158
                 inx                                       ;; @@5af0 158
                 inx                                       ;; @@5af1 158
                 inx                                      ; point further ;; @@5af2 158
                 stx temppt                               ; save pointer to next temp, if any ;; @@5af3 158
                 rts                                      ; all done ;; @@5af5 158
 ;; @@5af6 158
; .page ;; @@5af6 158
; The following routine concatenates two strings.  At this point, the FAC ;; @@5af6 158
; contains the first one and (txtptr) points to the + sign. ;; @@5af6 158
 ;; @@5af6 158
cat              lda faclo                                ; push high order onto stack ;; @@5af6 158
                 pha                                       ;; @@5af8 158
                 lda facmo                                ; and the low ;; @@5af9 158
                 pha                                       ;; @@5afb 158
                 jsr eval                                 ; can come back here since operator is known ;; @@5afc 158
                 jsr chkstr                               ; must be string ;; @@5aff 158
                 pla                                       ;; @@5b02 158
                 sta strng1                               ; get high order of old descriptor ;; @@5b03 158
                 pla                                       ;; @@5b05 158
                 sta strng1+1                              ;; @@5b06 158
                 ldy #0                                    ;; @@5b08 158
                 jsr indst1_ram1                          ; get length of old string ;; @@5b0a 158
                 sta syntmp                                ;; @@5b0d 158
                 jsr indfmo                                ;; @@5b0f 158
                 clc                                       ;; @@5b12 158
                 adc syntmp                                ;; @@5b13 158
                 +lbcs errlen                             ; result >255, error "long string" ;; @@5b15 158
 ;; @@5b18 158
                 jsr strini                               ; sizeok.  initialize string ;; @@5b18 158
                 jsr movins                               ; move it ;; @@5b1b 158
                 lda dscpnt                               ; get pointer to second ;; @@5b1e 158
                 ldy dscpnt+1                              ;; @@5b20 158
                 jsr fretmp                               ; free it ;; @@5b22 158
                 jsr movdo                                ; move second string ;; @@5b25 158
                 lda strng1                                ;; @@5b28 158
                 ldy strng1+1                              ;; @@5b2a 158
                 jsr fretmp                                ;; @@5b2c 158
                 jsr putnew                                ;; @@5b2f 158
                 +lbra tstop                              ; "cat" reenters frmevl from tstop ;; @@5b32 158
 ;; @@5b35 158
; .page ;; @@5b35 158
movins           ldy #0                                   ; get address of string ;; @@5b35 158
                 jsr indst1_ram1                           ;; @@5b37 158
                 pha                                       ;; @@5b3a 158
                 iny                                       ;; @@5b3b 158
                 jsr indst1_ram1                           ;; @@5b3c 158
                 tax                                       ;; @@5b3f 158
                 iny                                       ;; @@5b40 158
                 jsr indst1_ram1                           ;; @@5b41 158
                 tay                                       ;; @@5b44 158
                 pla                                       ;; @@5b45 158
 ;; @@5b46 158
movstr           stx index                                ; adr in (x,y), len in a ;; @@5b46 158
                 sty index+1                               ;; @@5b48 158
 ;; @@5b4a 158
movdo            tay                                       ;; @@5b4a 158
                 beq mvdone                                ;; @@5b4b 158
 ;; @@5b4d 158
                 pha                                       ;; @@5b4d 158
                 phx                                       ;; @@5b4e 158
                 ldx #frespc                               ;; @@5b4f 158
_local_1157_10   dey                                       ;; @@5b51 158
                 jsr indin1_ram1                           ;; @@5b52 158
                 jsr sta_far_ram1                         ; sta (frespc),y ;; @@5b55 158
                 tya                                       ;; @@5b58 158
                 bne _local_1157_10                        ;; @@5b59 158
                 plx                                       ;; @@5b5b 158
                 pla                                       ;; @@5b5c 158
 ;; @@5b5d 158
mvdone           clc                                      ; update frespc pointer ;; @@5b5d 159
                 adc frespc                                ;; @@5b5e 159
                 sta frespc                                ;; @@5b60 159
                 bcc _local_1158_10                        ;; @@5b62 159
                 inc frespc+1                              ;; @@5b64 159
_local_1158_10   rts                                       ;; @@5b66 159
 ;; @@5b67 159
; .page ;; @@5b67 159
; FRETMP is passed a string descriptor pntr in (a,y).  A check is made to see ;; @@5b67 159
; if the string descriptor points to the last temporary descriptor allocated by ;; @@5b67 159
; putnew.  If so, the temporary is freed up by the updating of (temppt).  If a ;; @@5b67 159
; string is freed up, a further check sees if it was the last one created and if ;; @@5b67 159
; so, (fretop) is updated to reflect the fact that the space is no longer in use. ;; @@5b67 159
; The address of the actual string is returned in (x,y) and its length in (a). ;; @@5b67 159
 ;; @@5b67 159
frmstr           jsr frmevl                                ;; @@5b67 160
 ;; @@5b6a 160
frestr           jsr chkstr                               ; make sure it's a string ;; @@5b6a 160
frefac           lda facmo                                ; free up string pointed to by FAC ;; @@5b6d 160
                 ldy facmo+1                               ;; @@5b6f 160
fretmp           sta index                                ; get length for later ;; @@5b71 160
                 sty index+1                               ;; @@5b73 160
                 jsr fretms                               ; check desc. if last ;; @@5b75 160
                 bne _local_1159_30                       ; one then scratch it ;; @@5b78 160
                 jsr stradj                               ; index points to link ;; @@5b7a 160
                 bcc _local_1159_30                       ; literal no fix ;; @@5b7d 160
 ;; @@5b7f 160
                 phx                                      ; .x=length ;; @@5b7f 160
                 dey                                      ; .y=1 ;; @@5b80 160
                 ldx #index                                ;; @@5b81 160
                 lda #$ff                                 ; flag string as garbage ;; @@5b83 160
                 jsr sta_far_ram1                         ; sta (index),y ;; @@5b85 160
                 pla                                       ;; @@5b88 160
                 pha                                      ; get length, but leave copy on stack ;; @@5b89 160
                 dey                                       ;; @@5b8a 160
                 ldx #index                                ;; @@5b8b 160
                 jsr sta_far_ram1 ;sta (index),y          ; put in length ;; @@5b8d 160
 ;; @@5b90 160
                 eor #$ff                                 ; put index back ;; @@5b90 160
                 sec                                      ; to first byte ;; @@5b92 160
                 adc index                                 ;; @@5b93 160
                 ldy index+1                               ;; @@5b95 160
                 bcs _local_1159_10                        ;; @@5b97 160
                 dey                                       ;; @@5b99 160
_local_1159_10   sta index                                 ;; @@5b9a 160
                 sty index+1                               ;; @@5b9c 160
 ;; @@5b9e 160
                 tax                                      ; lo into x ;; @@5b9e 160
                 pla                                      ; pull length from stack ;; @@5b9f 160
                 cpy fretop+1                             ; = to fretop? ;; @@5ba0 160
                 bne frerts                                ;; @@5ba2 160
                 cpx fretop                                ;; @@5ba4 160
                 bne frerts                                ;; @@5ba6 160
 ;; @@5ba8 160
; .page ;; @@5ba8 160
; The string was the last one put into string space.  Save garbage ;; @@5ba8 160
; collection some time by freeing up. (length + 2) ;; @@5ba8 160
 ;; @@5ba8 160
                 pha                                      ; save length on stack ;; @@5ba8 160
                 sec                                      ; plus one ;; @@5ba9 160
                 adc fretop                                ;; @@5baa 160
                 sta fretop                                ;; @@5bac 160
                 bcc _local_1159_20                        ;; @@5bae 160
                 inc fretop+1                              ;; @@5bb0 160
_local_1159_20   inw fretop                               ; + one more ;; @@5bb2 160
                 pla                                      ; pull length off stack ;; @@5bb4 160
                 rts                                       ;; @@5bb5 160
 ;; @@5bb6 160
 ;; @@5bb6 160
_local_1159_30   ldy #0                                   ; set up x,y,a and index ;; @@5bb6 160
                 jsr indin1_ram1                          ; length ;; @@5bb8 160
                 pha                                      ; on stack ;; @@5bbb 160
                 iny                                       ;; @@5bbc 160
                 jsr indin1_ram1                          ; pointer lo ;; @@5bbd 160
                 tax                                       ;; @@5bc0 160
                 iny                                       ;; @@5bc1 160
                 jsr indin1_ram1                          ; pointer hi ;; @@5bc2 160
                 tay                                       ;; @@5bc5 160
                 stx index                                 ;; @@5bc6 160
                 sty index+1                               ;; @@5bc8 160
                 pla                                      ; get back length ;; @@5bca 160
                 rts                                       ;; @@5bcb 160
 ;; @@5bcc 160
 ;; @@5bcc 160
 ;; @@5bcc 160
fretms           cpy lastpt+1                             ; last entry to temp? ;; @@5bcc 161
                 bne frerts                                ;; @@5bce 161
                 cmp lastpt                                ;; @@5bd0 161
                 bne frerts                                ;; @@5bd2 161
                 sta temppt                                ;; @@5bd4 161
                 sbc #strsiz                              ; point to lst one ;; @@5bd6 161
                 sta lastpt                               ; update temp pointer ;; @@5bd8 161
                 ldy #0                                   ; also clears zflg so we do rest of fretmp ;; @@5bda 161
frerts           rts                                      ; all done ;; @@5bdc 161
 ;; @@5bdd 161
;.end ;; @@5bdd 161
; .page ;; @@5bdd 161
; .subttl Garbage Collection ;; @@5bdd 161
 ;; @@5bdd 161
;  Get space for a string, perhaps forcing garbage collection. ;; @@5bdd 161
; ;; @@5bdd 161
;  Entry:  a = # of chars ;; @@5bdd 161
;  Exit:   (x,y) pointer to space, otherwise ;; @@5bdd 161
;          blows off to 'out of string space' error ;; @@5bdd 161
;          (also preserves .a and sets frespc= y,x = -> at space.) ;; @@5bdd 161
 ;; @@5bdd 161
 ;; @@5bdd 161
getspa           lsr garbfl                               ; signal no garbage collection yet ;; @@5bdd 161
 ;; @@5bdf 161
tryag2           tax                                      ; save in x also ;; @@5bdf 161
                 beq getrts                               ; length of 0 no go... ;; @@5be0 161
                 pha                                      ; save a (length) on stack ;; @@5be2 161
                 lda fretop                               ; lo byte ;; @@5be3 161
                 sec                                      ; for subtract ;; @@5be5 161
                 sbc #2                                   ; minus 2 (link bytes) ;; @@5be6 161
                 ldy fretop+1                              ;; @@5be8 161
                 bcs _local_1160_10                        ;; @@5bea 161
                 dey                                       ;; @@5bec 161
_local_1160_10   sta index1                               ; save for later ;; @@5bed 161
                 sty index1+1                              ;; @@5bef 161
                 txa                                       ;; @@5bf1 161
                 eor #$ff                                  ;; @@5bf2 161
                 sec                                       ;; @@5bf4 161
                 adc index1                                ;; @@5bf5 161
                 bcs _local_1160_20                        ;; @@5bf7 161
                 dey                                       ;; @@5bf9 161
_local_1160_20   cpy strend+1                              ;; @@5bfa 161
                 bcc garbag                                ;; @@5bfc 161
                 bne strfre                                ;; @@5bfe 161
                 cmp strend                                ;; @@5c00 161
                 bcc garbag                               ; clean up ;; @@5c02 161
 ;; @@5c04 161
; .page ;; @@5c04 161
strfre           sta frespc                                ;; @@5c04 162
                 sty frespc+1                              ;; @@5c06 162
                 ldy #1                                   ; flag string as garbage ;; @@5c08 162
                 lda #$ff                                  ;; @@5c0a 162
                 phx                                      ; set up string bank ;; @@5c0c 162
                 ldx #index1                               ;; @@5c0d 162
                 jsr sta_far_ram1 ;sta (index1),y         ; flag ;; @@5c0f 162
                 plx                                       ;; @@5c12 162
                 dey                                       ;; @@5c13 162
                 pla                                      ; length ;; @@5c14 162
                 phx                                      ; set up string bank ;; @@5c15 162
                 ldx #index1                               ;; @@5c16 162
                 jsr sta_far_ram1 ;sta (index1),y         ; length ;; @@5c18 162
                 plx                                       ;; @@5c1b 162
                 ldx frespc                                ;; @@5c1c 162
                 ldy frespc+1                              ;; @@5c1e 162
                 stx fretop                                ;; @@5c20 162
                 sty fretop+1                             ; save new (fretop) ;; @@5c22 162
getrts           rts                                       ;; @@5c24 162
 ;; @@5c25 162
 ;; @@5c25 162
garbag           lda garbfl                                ;; @@5c25 162
                 +lbmi omerr                              ; if out of memory ;; @@5c27 162
                 jsr garba2                                ;; @@5c2a 162
                 sec                                       ;; @@5c2d 162
                 ror garbfl                                ;; @@5c2e 162
                 pla                                      ; get back string length ;; @@5c30 162
                 bra tryag2                               ; always branches ;; @@5c31 162
 ;; @@5c33 162
 ;; @@5c33 162
; .page ;; @@5c33 162
; Routine looks for and squashes out any unused string space it finds, thus ;; @@5c33 162
; returning the space for future use by the string routines.  GARBA2 is called ;; @@5c33 162
; only when BASIC needs space or the FRE() function is used. ;; @@5c33 162
 ;; @@5c33 162
 ;; @@5c33 162
garba2           ldx temppt                               ; ptr to temp. strings ;; @@5c33 162
_local_1161_10   cpx #tempst                              ; any out there? ;; @@5c35 162
                 beq _local_1161_20                       ; none ;; @@5c37 162
                 jsr slr1                                 ; setup ptr (tempf2) to temp. string's bkptr ;; @@5c39 162
                 beq _local_1161_10                       ; (skip if null string!) ;; @@5c3c 162
                 txa                                      ; .x = lsb of ptr to descriptor ;; @@5c3e 162
                 phx                                      ; set up string bank ;; @@5c3f 162
                 ldx #tempf2                               ;; @@5c40 162
                 ldy #0                                    ;; @@5c42 162
                 jsr sta_far_ram1 ;(tempf2),y             ; place backpointer on string to temp. descr ;; @@5c44 162
                 tya                                      ; .a = msb of ptr (0) ;; @@5c47 162
                 iny                                       ;; @@5c48 162
                 jsr sta_far_ram1                         ; (tempf2),y ;; @@5c49 162
                 plx                                       ;; @@5c4c 162
                 bra _local_1161_10                       ; always ;; @@5c4d 162
 ;; @@5c4f 162
 ;; @@5c4f 162
_local_1161_20   ldy #0                                   ; set up flag ;; @@5c4f 162
                 sty highds                                ;; @@5c51 162
                 ldx max_mem_1                             ;; @@5c53 162
                 ldy max_mem_1+1                           ;; @@5c55 162
                 stx grbtop                               ; set both pointers ;; @@5c57 162
                 stx grbpnt                                ;; @@5c59 162
                 stx frespc                                ;; @@5c5b 162
                 sty grbtop+1                              ;; @@5c5d 162
                 sty grbpnt+1                              ;; @@5c5f 162
                 sty frespc+1                              ;; @@5c61 162
                 txa                                       ;; @@5c63 162
 ;; @@5c64 162
; .page ;; @@5c64 162
; do while (grbpnt <= fretop) ;; @@5c64 162
 ;; @@5c64 162
gloop            jsr chkgrb                               ; check garbage string ;; @@5c64 163
                 bne _local_1162_2                        ; if not garbage ;; @@5c67 163
 ;; @@5c69 163
_local_1162_1    dey                                      ; back up to length ;; @@5c69 163
                 jsr indgrb                                ;; @@5c6a 163
                 jsr movpnt                               ; move grbpnt to next ;; @@5c6d 163
                 sec                                       ;; @@5c70 163
                 ror highds                               ; indicate garbage string found ;; @@5c71 163
                 bra gloop                                ; always ;; @@5c73 163
 ;; @@5c75 163
_local_1162_2    bit highds                                ;; @@5c75 163
                 bpl _local_1162_30                       ; if garbage string not found ;; @@5c77 163
                 ldx #0                                    ;; @@5c79 163
                 stx highds                               ; clear indicator ;; @@5c7b 163
 ;; @@5c7d 163
                 lda #2                                   ; skip pointers past ;; @@5c7d 163
 ;; @@5c7f 163
; Move a string over garbage ;; @@5c7f 163
 ;; @@5c7f 163
_local_1162_5    phx                                       ;; @@5c7f 163
                 ldx #grbtop                               ;; @@5c80 163
                 ldy #1                                   ; move the link bytes ;; @@5c82 163
                 jsr indgrb                                ;; @@5c84 163
                 jsr sta_far_ram1                         ; sta (grbtop),y ;; @@5c87 163
                 dey                                       ;; @@5c8a 163
                 jsr indgrb                                ;; @@5c8b 163
                 jsr sta_far_ram1                         ; sta (grbtop),y ;; @@5c8e 163
                 plx                                       ;; @@5c91 163
 ;; @@5c92 163
                 jsr indin1_ram1                           ;; @@5c92 163
                 tax                                       ;; @@5c95 163
                 jsr movtop                               ; move top pointer ;; @@5c96 163
                 sta frespc                               ; save in frespc ;; @@5c99 163
                 sty frespc+1                              ;; @@5c9b 163
                 txa                                       ;; @@5c9d 163
                 jsr movpnt                               ; move grbpnt ;; @@5c9e 163
                 txa                                      ; put length-1 in .y ;; @@5ca1 163
                 tay                                       ;; @@5ca2 163
 ;; @@5ca3 163
_local_1162_10   dey                                       ;; @@5ca3 163
                 jsr indgrb                                ;; @@5ca4 163
                 phx                                       ;; @@5ca7 163
                 ldx #grbtop                               ;; @@5ca8 163
                 jsr sta_far_ram1                         ; sta (grbtop),y ;; @@5caa 163
                 plx                                       ;; @@5cad 163
                 dex                                       ;; @@5cae 163
                 bne _local_1162_10                        ;; @@5caf 163
 ;; @@5cb1 163
                 ldy #2                                   ; fix the descriptor ;; @@5cb1 163
                 phx                                       ;; @@5cb3 163
                 ldx #index1                               ;; @@5cb4 163
_local_1162_20   lda grbtop-1,y                            ;; @@5cb6 163
                 jsr sta_far_ram1                         ; sta (index1),y ;; @@5cb9 163
                 dey                                       ;; @@5cbc 163
                 bne _local_1162_20                        ;; @@5cbd 163
                 plx                                       ;; @@5cbf 163
 ;; @@5cc0 163
                 lda grbpnt                               ; check pointer ;; @@5cc0 163
                 ldy grbpnt+1                              ;; @@5cc2 163
                 jsr chkgrb                               ; check garbage string ;; @@5cc4 163
                 beq _local_1162_1                        ; if garbage found ;; @@5cc7 163
                 bne _local_1162_5                        ; always ;; @@5cc9 163
 ;; @@5ccb 163
_local_1162_30   ldy #0                                   ; skip over good strings ;; @@5ccb 163
                 jsr indin1_ram1                           ;; @@5ccd 163
                 tax                                       ;; @@5cd0 163
                 jsr movtop                                ;; @@5cd1 163
                 sta frespc                                ;; @@5cd4 163
                 sty frespc+1                              ;; @@5cd6 163
                 txa                                       ;; @@5cd8 163
                 jsr movpnt                                ;; @@5cd9 163
                 bra gloop                                 ;; @@5cdc 163
 ;; @@5cde 163
; .page ;; @@5cde 163
; Subroutines used for garbage collection. ;; @@5cde 163
; ;; @@5cde 163
;  Compare for (y,a) = fretop. ;; @@5cde 163
; Entry  (y,a) = address of current string descriptor. ;; @@5cde 163
; Exits to caller if (y,a) = fretop, else z flag set if garbage string. ;; @@5cde 163
;      z flag clear if not garbage string. ;; @@5cde 163
; In either case pointers are setup for next loop and string movement. ;; @@5cde 163
; If carry clear (y,a) <= fretop ;; @@5cde 163
 ;; @@5cde 163
 ;; @@5cde 163
chkgrb           cpy fretop+1                             ; end of strings? ;; @@5cde 164
                 bcc _local_1163_50                        ;; @@5ce0 164
                 bne _local_1163_10                       ; if not equal ;; @@5ce2 164
                 cmp fretop                                ;; @@5ce4 164
                 beq _local_1163_50                        ;; @@5ce6 164
                 bcc _local_1163_50                        ;; @@5ce8 164
 ;; @@5cea 164
_local_1163_10   bit highds                               ; check flag ;; @@5cea 164
                 bmi _local_1163_20                       ; if empty string found ;; @@5cec 164
                 lda #2                                   ; skip pointers past ;; @@5cee 164
                 jsr movtop                               ; move top pointer ;; @@5cf0 164
 ;; @@5cf3 164
_local_1163_20   lda #2                                   ; skip pointers past ;; @@5cf3 164
                 jsr movpnt                               ; move pointers ;; @@5cf5 164
                 ldy #1                                    ;; @@5cf8 164
                 jsr indgrb                               ; garbage? ;; @@5cfa 164
                 cmp #$ff                                  ;; @@5cfd 164
                 beq _local_1163_40                       ; yes ;; @@5cff 164
 ;; @@5d01 164
_local_1163_30   jsr indgrb                               ; to link bytes ;; @@5d01 164
                 sta index1,y                              ;; @@5d04 164
                 dey                                       ;; @@5d07 164
                 bpl _local_1163_30                       ; if two bytes not moved ;; @@5d08 164
_local_1163_40   rts                                       ;; @@5d0a 164
 ;; @@5d0b 164
 ;; @@5d0b 164
_local_1163_50   ldx temppt                               ; ptr to temp. strings ;; @@5d0b 164
 ;; @@5d0d 164
_local_1163_60   cpx #tempst                              ; any out there? ;; @@5d0d 164
                 beq _local_1163_70                       ; no ;; @@5d0f 164
                 jsr slr1                                 ; setup ptr (tempf2) to temp. string's bkptr. ;; @@5d11 164
                 beq _local_1163_60                       ; (skip if null string!) ;; @@5d14 164
                 phx                                       ;; @@5d16 164
                 ldx #tempf2                               ;; @@5d17 164
                 ldy #0                                   ; .a = string length ;; @@5d19 164
                 jsr sta_far_ram1 ;sta (tempf2),y         ; remove backpointer built at garba2 ;; @@5d1b 164
                 iny                                       ;; @@5d1e 164
                 lda #$ff                                  ;; @@5d1f 164
                 jsr sta_far_ram1 ;sta (tempf2),y         ; and mark as garbage ;; @@5d21 164
                 plx                                       ;; @@5d24 164
                 bra _local_1163_60                       ; always ;; @@5d25 164
 ;; @@5d27 164
_local_1163_70   pla                                      ; throw away return address ;; @@5d27 164
                 pla                                       ;; @@5d28 164
                 lda frespc                               ; fix fretop and frespc ;; @@5d29 164
                 ldy frespc+1                              ;; @@5d2b 164
                 sta fretop                                ;; @@5d2d 164
                 sty fretop+1                              ;; @@5d2f 164
                 rts                                       ;; @@5d31 164
 ;; @@5d32 164
; .page ;; @@5d32 164
movpnt           eor #$ff                                 ; comp and add ;; @@5d32 165
                 sec                                       ;; @@5d34 165
                 adc grbpnt                                ;; @@5d35 165
                 ldy grbpnt+1                              ;; @@5d37 165
                 bcs _local_1164_1                         ;; @@5d39 165
                 dey                                       ;; @@5d3b 165
_local_1164_1    sta grbpnt                                ;; @@5d3c 165
                 sty grbpnt+1                              ;; @@5d3e 165
                 rts                                       ;; @@5d40 165
 ;; @@5d41 165
 ;; @@5d41 165
 ;; @@5d41 165
movtop           eor #$ff                                 ; comp and add ;; @@5d41 166
                 sec                                       ;; @@5d43 166
                 adc grbtop                                ;; @@5d44 166
                 ldy grbtop+1                              ;; @@5d46 166
                 bcs _local_1165_1                         ;; @@5d48 166
                 dey                                       ;; @@5d4a 166
_local_1165_1    sta grbtop                                ;; @@5d4b 166
                 sty grbtop+1                              ;; @@5d4d 166
                 rts                                       ;; @@5d4f 166
 ;; @@5d50 166
 ;; @@5d50 166
 ;; @@5d50 166
slr1             dex                                      ; .x = ptr to temp. string descriptor ;; @@5d50 167
                 lda 0,x                                  ; msb of ptr to string ;; @@5d51 167
                 sta tempf2+1                              ;; @@5d53 167
                 dex                                       ;; @@5d55 167
                 lda 0,x                                  ; lsb of ptr to string ;; @@5d56 167
                 sta tempf2                                ;; @@5d58 167
                 dex                                       ;; @@5d5a 167
                 lda 0,x                                  ; string length ;; @@5d5b 167
                 pha                                      ; save for later test ;; @@5d5d 167
                 clc                                       ;; @@5d5e 167
                 adc tempf2                               ; want ptr to string's backpointer ;; @@5d5f 167
                 sta tempf2                                ;; @@5d61 167
                 bcc _local_1166_1                         ;; @@5d63 167
                 inc tempf2+1                              ;; @@5d65 167
_local_1166_1    pla   ;.a=len & set z flag               ; .x=next desc. ptr ;; @@5d67 167
                 rts                                       ;; @@5d68 167
 ;; @@5d69 167
;.end ;; @@5d69 167
; .page ;; @@5d69 167
; .subttl  Floating Point Math Package (CODE17) ;; @@5d69 167
 ;; @@5d69 167
gtbytc           jsr chrget                                ;; @@5d69 168
 ;; @@5d6c 168
getbyt           jsr frmnum                               ; read formula into FAC ;; @@5d6c 168
 ;; @@5d6f 168
conint           jsr posint                               ; convert the FAC to a single byte int ;; @@5d6f 168
                 ldx facmo                                 ;; @@5d72 168
                 +lbne fcerr                              ; result must be <= 255 ;; @@5d74 168
                 ldx faclo                                 ;; @@5d77 168
                 jmp chrgot                               ; set condition codes on terminator ;; @@5d79 168
 ;; @@5d7c 168
 ;; @@5d7c 168
getnum                                                    ; get 2-byte value in y,a: check for a comma, get 1 byte val in x ;; @@5d7c 168
                 jsr frmnum                               ; get address ;; @@5d7c 168
                 jsr getadr                               ; get that location ;; @@5d7f 168
 ;; @@5d82 168
combyt                                                    ; check for a comma, get a 1 byte value in x ;; @@5d82 168
                 jsr chkcom                               ; check for comma ;; @@5d82 168
                 bra getbyt                               ; get something to store and return ;; @@5d85 168
 ;; @@5d87 168
 ;; @@5d87 168
comwrd           jsr chkcom                                ;; @@5d87 168
 ;; @@5d8a 168
getwrd           jsr frmnum                               ; get an unsigned 2-byte value in y,a ;; @@5d8a 168
 ;; @@5d8d 168
getadr           lda facsgn                               ; for this entry, value can't be < 0 ;; @@5d8d 168
                 +lbmi fcerr                              ; function call error ;; @@5d8f 168
 ;; @@5d92 168
getsad                                                    ; get a signed 2-byte value in (y,a), ///entry from sprcor ;; @@5d92 168
                 lda facexp                               ; examine exponent ;; @@5d92 168
                 cmp #145                                  ;; @@5d94 168
                 +lbcs fcerr                              ; function call error ;; @@5d96 168
                 jsr qint                                 ; integerize it ;; @@5d99 168
                 lda facmo                                 ;; @@5d9c 168
                 ldy facmo+1                               ;; @@5d9e 168
                 sty poker                                 ;; @@5da0 168
                 sta poker+1                               ;; @@5da2 168
                 rts                                      ; it's all done ;; @@5da4 168
 ;; @@5da5 168
;.end ;; @@5da5 168
; .page ;; @@5da5 168
; .subttl Floating Point Math Package (CODE18) ;; @@5da5 168
 ;; @@5da5 168
; Floating Point Math Package configuration: ;; @@5da5 168
; ;; @@5da5 168
; Throughout the math package the floating point format is as follows: ;; @@5da5 168
; ;; @@5da5 168
; the sign of the first bit of the mantissa. ;; @@5da5 168
; the mantissa is 24 bits long. ;; @@5da5 168
; the binary point is to the left of the msb. ;; @@5da5 168
; number = mantissa * 2 ~ exponent. ;; @@5da5 168
; the mantissa is positive with a 1 assumed to be where the sign bit is. ;; @@5da5 168
; the sign of the exponent is the first bit of the exponent. ;; @@5da5 168
; the exponent is stored in excess $80, i.e., with a bias of +$80. ;; @@5da5 168
; so, the exponent is a signed 8 bit number with $80 added to it. ;; @@5da5 168
; an exponent of zero means the number is zero. ;; @@5da5 168
; the other bytes may not be assumed to be zero. ;; @@5da5 168
; to keep the same number in the fac while shifting, ;; @@5da5 168
; to shift right, exp:=exp+1. ;; @@5da5 168
; to shift left,  exp:=exp-1. ;; @@5da5 168
; ;; @@5da5 168
; In memory the number looks like this: ;; @@5da5 168
; the exponent as a signed number +$80. ;; @@5da5 168
; the sign bit in 7, bits 2-8 of mantissa are bits 6-0. ;; @@5da5 168
;  remember bit 1 of mantissa is always a one. ;; @@5da5 168
; bits 9-16 of the mantissa. ;; @@5da5 168
; bits 17-24 of the mantisa. ;; @@5da5 168
; ;; @@5da5 168
; Arithmetic routine calling conventions: ;; @@5da5 168
; ;; @@5da5 168
;   For one-argument functions: ;; @@5da5 168
; the argument is in the fac. ;; @@5da5 168
; the result is left in the fac. ;; @@5da5 168
;   For two-argument operations: ;; @@5da5 168
; the first argument is in arg (argexp,ho,mo,lo and argsgn). ;; @@5da5 168
;       the second argument is in the fac. ;; @@5da5 168
; the result is left in the fac. ;; @@5da5 168
; ;; @@5da5 168
; The "t" entry points to the two argument operations have both arguments setup ;; @@5da5 168
; in the respective registers. Before calling arg may have been popped off the ;; @@5da5 168
; stack and into arg, for example. The other entry point assumes (xreg) points ;; @@5da5 168
; to the argument somewhere in memory. it is unpacked into arg by "conupk". ;; @@5da5 168
; ;; @@5da5 168
; On the stack, the sgn is pushed on first, the lo,mo,ho, and finally exp. ;; @@5da5 168
; Note all things are kept unpacked in arg, fac and on the stack. ;; @@5da5 168
; ;; @@5da5 168
; It is only when something is stored away that it is packed to four bytes, ;; @@5da5 168
; the unpacked format has a sn byte reflecting the sign of the ho turned on. ;; @@5da5 168
; The exp is the same as stored format. This is done for speed of operation. ;; @@5da5 168
; .page ;; @@5da5 168
 ;; @@5da5 168
fsub             jsr conupk                                ;; @@5da5 168
 ;; @@5da8 168
fsubt            lda facsgn                                ;; @@5da8 168
                 eor #$ff                                 ; complement it ;; @@5daa 168
                 sta facsgn                                ;; @@5dac 168
                 eor argsgn                               ; complement arisgn ;; @@5dae 168
                 sta arisgn                                ;; @@5db0 168
                 lda facexp                               ; set codes on facexp ;; @@5db2 168
                 bra faddt                                ; (y)=argexp ;; @@5db4 168
 ;; @@5db6 168
fadd5            jsr shiftr                               ; do a long shift ;; @@5db6 168
                 bcc fadd4                                ; continue with addition ;; @@5db9 168
 ;; @@5dbb 168
fadd             jsr conupk                                ;; @@5dbb 168
faddt            +lbeq movfa                              ; if fac=0, result is in arg ;; @@5dbe 168
                 ldx facov                                 ;; @@5dc1 168
                 stx oldov                                 ;; @@5dc3 168
                 ldx #argexp                              ; default is shift argument ;; @@5dc5 168
                 lda argexp                               ; if arg=0, fac is result ;; @@5dc7 168
 ;; @@5dc9 168
faddc            tay                                      ; also copy (a) into (y) ;; @@5dc9 168
                 +lbeq zerrts                             ; return ;; @@5dca 168
                 sec                                       ;; @@5dcd 168
                 sbc facexp                                ;; @@5dce 168
                 beq fadd4                                ; no shifting ;; @@5dd0 168
                 bcc fadda                                ; branch if argexp < facexp ;; @@5dd2 168
                 sty facexp                               ; resulting exponent ;; @@5dd4 168
                 ldy argsgn                               ; since arg is bigger, its ;; @@5dd6 168
                 sty facsgn                               ; sign is sign of result ;; @@5dd8 168
                 eor #$ff                                 ; shift a negative number of palces ;; @@5dda 168
                 adc #0                                   ; complete negation, w/ c=1 ;; @@5ddc 168
                 ldy #0                                   ; zero oldov ;; @@5dde 168
                 sty oldov                                 ;; @@5de0 168
                 ldx #fac                                 ; shift the FAC instead ;; @@5de2 168
                 bra fadd1                                 ;; @@5de4 168
 ;; @@5de6 168
fadda            ldy #0                                    ;; @@5de6 168
                 sty facov                                 ;; @@5de8 168
 ;; @@5dea 168
fadd1            cmp #$f9                                 ; for speed and necessity.  gets most likely case to ;; @@5dea 168
;SHIFTR fastest and allows shifting of neg nums by QUINT ;; @@5dec 168
                 bmi fadd5                                ; shift big ;; @@5dec 168
                 tay                                       ;; @@5dee 168
                 lda facov                                ; set facov ;; @@5def 168
                 lsr 1,x                                  ; gets 0 in the MSB ;; @@5df1 168
                 jsr rolshf                               ; do the rolling ;; @@5df3 168
 ;; @@5df6 168
fadd4            bbr7 arisgn,fadd2                        ; get resulting sign and if positive, add. carry is clear ;; @@5df6 168
                 ldy #facexp                               ;; @@5df9 168
                 cpx #argexp                              ; fac is bigger ;; @@5dfb 168
                 beq _local_1167_10                        ;; @@5dfd 168
                 ldy #argexp                              ; arg is bigger ;; @@5dff 168
 ;; @@5e01 168
_local_1167_10   sec                                      ; subit. ;; @@5e01 168
                 eor #$ff                                  ;; @@5e02 168
                 adc oldov                                 ;; @@5e04 168
                 sta facov                                 ;; @@5e06 168
                 lda 4,y                                   ;; @@5e08 168
                 sbc 4,x                                   ;; @@5e0b 168
                 sta faclo                                 ;; @@5e0d 168
                 lda 3,y                                   ;; @@5e0f 168
                 sbc 3,x                                   ;; @@5e12 168
                 sta facmo                                 ;; @@5e14 168
                 lda 2,y                                   ;; @@5e16 168
                 sbc 2,x                                   ;; @@5e19 168
                 sta facmoh                                ;; @@5e1b 168
                 lda 1,y                                   ;; @@5e1d 168
                 sbc 1,x                                   ;; @@5e20 168
                 sta facho                                 ;; @@5e22 168
 ;; @@5e24 168
fadflt           bcs normal                               ; here if signs differ. if carry, FAC is set ok ;; @@5e24 169
                 jsr negfac                               ; negate (FAC) ;; @@5e26 169
 ;; @@5e29 169
normal           ldy #0                                    ;; @@5e29 169
                 tya                                       ;; @@5e2b 169
                 clc                                       ;; @@5e2c 169
 ;; @@5e2d 169
_local_1168_10   ldx facho                                 ;; @@5e2d 169
                 bne norm1                                 ;; @@5e2f 169
                 ldx facho+1                              ; shift 8 bits at a time for speed ;; @@5e31 169
                 stx facho                                 ;; @@5e33 169
                 ldx facmoh+1                              ;; @@5e35 169
                 stx facmoh                                ;; @@5e37 169
                 ldx facmo+1                               ;; @@5e39 169
                 stx facmo                                 ;; @@5e3b 169
                 ldx facov                                 ;; @@5e3d 169
                 stx faclo                                 ;; @@5e3f 169
                 sty facov                                 ;; @@5e41 169
                 adc #8                                    ;; @@5e43 169
                 cmp #32                                   ;; @@5e45 169
                 bne _local_1168_10                        ;; @@5e47 169
 ;; @@5e49 169
zerofc           lda #0                                   ; not needed by NORMAL, but by others ;; @@5e49 170
zerof1           sta facexp                               ; number must be zero ;; @@5e4b 170
zeroml           sta facsgn                               ; make sign positive ;; @@5e4d 170
zerrts           rts                                      ; all done ;; @@5e4f 170
 ;; @@5e50 170
 ;; @@5e50 170
fadd2            adc oldov                                 ;; @@5e50 170
                 sta facov                                 ;; @@5e52 170
                 lda faclo                                 ;; @@5e54 170
                 adc arglo                                 ;; @@5e56 170
                 sta faclo                                 ;; @@5e58 170
                 lda facmo                                 ;; @@5e5a 170
                 adc argmo                                 ;; @@5e5c 170
                 sta facmo                                 ;; @@5e5e 170
                 lda facmoh                                ;; @@5e60 170
                 adc argmoh                                ;; @@5e62 170
                 sta facmoh                                ;; @@5e64 170
                 lda facho                                 ;; @@5e66 170
                 adc argho                                 ;; @@5e68 170
                 sta facho                                 ;; @@5e6a 170
                 bra squeez                               ; go round if signs same ;; @@5e6c 170
 ;; @@5e6e 170
 ;; @@5e6e 170
norm2            adc #1                                   ; decrement shift counter ;; @@5e6e 170
                 asl facov                                ; shift all left one bit ;; @@5e70 170
                 rol faclo                                 ;; @@5e72 170
                 rol facmo                                 ;; @@5e74 170
                 rol facmoh                                ;; @@5e76 170
                 rol facho                                 ;; @@5e78 170
 ;; @@5e7a 170
norm1            bpl norm2                                ; if msb=0 shift again ;; @@5e7a 170
                 sec                                       ;; @@5e7c 170
                 sbc facexp                                ;; @@5e7d 170
                 bcs zerofc                                ;; @@5e7f 170
                 eor #$ff                                  ;; @@5e81 170
                 adc #1                                   ; complement ;; @@5e83 170
                 sta facexp                                ;; @@5e85 170
 ;; @@5e87 170
squeez           bcc rndrts                               ; bits to shift? ;; @@5e87 170
rndshf           inc facexp                                ;; @@5e89 170
                 +lbeq overr                               ;; @@5e8b 170
                 ror facho                                 ;; @@5e8e 170
                 ror facmoh                                ;; @@5e90 170
                 ror facmo                                 ;; @@5e92 170
                 ror faclo                                 ;; @@5e94 170
                 ror facov                                 ;; @@5e96 170
rndrts           rts                                      ; all done adding ;; @@5e98 170
 ;; @@5e99 170
 ;; @@5e99 170
negfac           lda facsgn                                ;; @@5e99 170
                 eor #$ff                                 ; complement FAC entirely ;; @@5e9b 170
                 sta facsgn                                ;; @@5e9d 170
 ;; @@5e9f 170
negfch           lda facho                                 ;; @@5e9f 170
                 eor #$ff                                 ; complement just the number ;; @@5ea1 170
                 sta facho                                 ;; @@5ea3 170
                 lda facmoh                                ;; @@5ea5 170
                 eor #$ff                                  ;; @@5ea7 170
                 sta facmoh                                ;; @@5ea9 170
                 lda facmo                                 ;; @@5eab 170
                 eor #$ff                                  ;; @@5ead 170
                 sta facmo                                 ;; @@5eaf 170
                 lda faclo                                 ;; @@5eb1 170
                 eor #$ff                                  ;; @@5eb3 170
                 sta faclo                                 ;; @@5eb5 170
                 lda facov                                 ;; @@5eb7 170
                 eor #$ff                                  ;; @@5eb9 170
                 sta facov                                 ;; @@5ebb 170
                 inc facov                                 ;; @@5ebd 170
                 bne incfrt                                ;; @@5ebf 170
 ;; @@5ec1 170
incfac           inc faclo                                 ;; @@5ec1 170
                 bne incfrt                                ;; @@5ec3 170
                 inc facmo                                 ;; @@5ec5 170
                 bne incfrt                               ; if no carry, return ;; @@5ec7 170
                 inc facmoh                                ;; @@5ec9 170
                 bne incfrt                                ;; @@5ecb 170
                 inc facho                                ; carry complement ;; @@5ecd 170
incfrt           rts                                       ;; @@5ecf 170
 ;; @@5ed0 170
 ;; @@5ed0 170
; SHIFTR shifts (x+1:x+3) (-a) bits right.  Shifts bits to start with ;; @@5ed0 170
; if possible. ;; @@5ed0 170
 ;; @@5ed0 170
mulshf           ldx #resho-1                             ; entry point for multiplier ;; @@5ed0 170
shftr2           ldy 4,x                                  ; shift bits first ;; @@5ed2 170
                 sty facov                                 ;; @@5ed4 170
                 ldy 3,x                                   ;; @@5ed6 170
                 sty 4,x                                   ;; @@5ed8 170
                 ldy 2,x                                  ; get mo ;; @@5eda 170
                 sty 3,x                                  ; store lo ;; @@5edc 170
                 ldy 1,x                                  ; get ho ;; @@5ede 170
                 sty 2,x                                  ; store mo ;; @@5ee0 170
                 ldy bits                                  ;; @@5ee2 170
                 sty 1,x                                  ; store ho ;; @@5ee5 170
 ;; @@5ee7 170
shiftr           adc #8                                    ;; @@5ee7 170
                 bmi shftr2                                ;; @@5ee9 170
                 beq shftr2                                ;; @@5eeb 170
                 sbc #8                                   ; c can be either 1,0 and it works! ;; @@5eed 170
                 tay                                       ;; @@5eef 170
                 lda facov                                 ;; @@5ef0 170
                 bcs shftrt                               ; equiv to beq here ;; @@5ef2 170
 ;; @@5ef4 170
shftr3           asl 1,x                                   ;; @@5ef4 170
                 bcc _local_1169_10                        ;; @@5ef6 170
                 inc 1,x                                   ;; @@5ef8 170
_local_1169_10   ror 1,x                                   ;; @@5efa 170
                 ror 1,x                                  ; yes, two of them ;; @@5efc 170
 ;; @@5efe 170
rolshf           ror 2,x                                   ;; @@5efe 171
                 ror 3,x                                   ;; @@5f00 171
                 ror 4,x                                  ; one more time ;; @@5f02 171
                 ror                                       ;; @@5f04 171
                 iny                                       ;; @@5f05 171
                 bne shftr3                               ; $$$ (most expensive!!!) ;; @@5f06 171
 ;; @@5f08 171
shftrt           clc                                      ; clear output of FACOV ;; @@5f08 171
                 rts                                       ;; @@5f09 171
 ;; @@5f0a 171
;.end ;; @@5f0a 171
; .page ;; @@5f0a 171
; .subttl Floating Point Math Package (CODE19) ;; @@5f0a 171
 ;; @@5f0a 171
; Constants used by LOG, EXP, TRIG, and others. ;; @@5f0a 171
 ;; @@5f0a 171
fr4              !text 127,0,0,0,0                        ; 1/4 ;; @@5f0a 171
neghlf           !text 128,128,0,0,0                      ; -0.5 ;; @@5f0f 171
fhalf            !text 128,0,0,0,0                        ; 0.5 ;; @@5f14 171
tenc             !text 132,32,0,0,0                       ; 10.0 ;; @@5f19 171
pival            !text 130,73,15,218,161                  ; pi ;; @@5f1e 171
pi2              !text 129,73,15,218,162                  ; pi/2 ;; @@5f23 171
twopi            !text 131,73,15,218,162                  ; pi*2 ;; @@5f28 171
 ;; @@5f2d 171
n0999            !text $9b,$3e,$bc,$1f,$fd                 ;; @@5f2d 171
n9999            !text $9e,$6e,$6b,$27,$fd                 ;; @@5f32 171
nmil             !text $9e,$6e,$6b,$28,$00                 ;; @@5f37 171
 ;; @@5f3c 171
foutbl                                                    ; powers of 10 ;; @@5f3c 171
                 !text 250,10,31,0                        ; -100,000,000 ;; @@5f3c 171
                 !text 0,152,150,128                      ; 10,000,000 ;; @@5f40 171
                 !text 255,240,189,192                    ; -1,000,000 ;; @@5f44 171
                 !text 0,1,134,160                        ; 100,000 ;; @@5f48 171
                 !text 255,255,216,240                    ; -10,000 ;; @@5f4c 171
                 !text 0,0,3,232                          ; 1,000 ;; @@5f50 171
                 !text 255,255,255,156                    ; -100 ;; @@5f54 171
                 !text 0,0,0,10                           ; 10 ;; @@5f58 171
                 !text 255,255,255,255                    ; -1 ;; @@5f5c 171
fdcend                                                     ;; @@5f60 171
 ;; @@5f60 171
; .byte @377,@337,@012,@200 ;-2,160,000 for time converter removed [901014] ;; @@5f60 171
; .byte @000,@003,@113,@300 ;   216,000 ;; @@5f60 171
; .byte @377,@377,@163,@140 ;   -36,000 ;; @@5f60 171
; .byte @000,@000,@016,@020 ;     3,600 ;; @@5f60 171
; .byte @377,@377,@375,@250 ;      -600 ;; @@5f60 171
; .byte @000,@000,@000,@074 ;        60 ;; @@5f60 171
;timend ;; @@5f60 171
 ;; @@5f60 171
logcn2           !text 3                                  ; degree-1 ;; @@5f60 171
                 !text 127,94,86,203,121                  ; 0.43425594188 ;; @@5f61 171
                 !text 128,19,155,11,100                  ; 0.57658454134 ;; @@5f66 171
                 !text 128,118,56,147,22                  ; 0.96180075921 ;; @@5f6b 171
                 !text 130,56,170,59,32                   ; 2.8853900728 ;; @@5f70 171
 ;; @@5f75 171
expcon           !text 7                                  ; degree-1 ;; @@5f75 171
                 !text 113,52,88,62,86                    ; 0.000021498763697 ;; @@5f76 171
                 !text 116,22,126,179,27                  ; 0.00014352314036 ;; @@5f7b 171
                 !text 119,47,238,227,133                 ; 0.0013422634824 ;; @@5f80 171
                 !text 122,29,132,28,42                   ; 0.0096140170199 ;; @@5f85 171
                 !text 124,99,89,88,10                    ; 0.055505126860 ;; @@5f8a 171
                 !text 126,117,253,231,198                ; 0.24022638462 ;; @@5f8f 171
                 !text 128,49,114,24,16                   ; 0.69314718600 ;; @@5f94 171
fone             !text 129,0,0,0,0                        ; 1.0 ;; @@5f99 171
 ;; @@5f9e 171
logeb2           !text 129,56,170,59,41                   ; log(e) base 2 ;; @@5f9e 171
sqr05            !text 128,53,4,243,52                    ; 0.707106781 sqr(0.5) ;; @@5fa3 171
sqr20            !text 129,53,4,243,52                    ; 1.41421356 sqr(2.0) ;; @@5fa8 171
log2             !text 128,49,114,23,248                  ; 0.693147181 ln(2) ;; @@5fad 171
 ;; @@5fb2 171
 ;; @@5fb2 171
sincon           !text 5                                  ; degree-1 trig ;; @@5fb2 171
                 !text 132,230,26,45,27                    ;; @@5fb3 171
                 !text 134,40,7,251,248                    ;; @@5fb8 171
                 !text 135,153,104,137,1                   ;; @@5fbd 171
                 !text 135,35,53,223,225                   ;; @@5fc2 171
                 !text 134,165,93,231,40                   ;; @@5fc7 171
                 !text 131,73,15,218,162                   ;; @@5fcc 171
 ;; @@5fd1 171
atncon           !text 11                                 ; degree-1 ;; @@5fd1 171
                 !text 118,179,131,189,211                 ;; @@5fd2 171
                 !text 121,30,244,166,245                  ;; @@5fd7 171
                 !text 123,131,252,176,16                  ;; @@5fdc 171
                 !text 124,12,31,103,202                   ;; @@5fe1 171
                 !text 124,222,83,203,193                  ;; @@5fe6 171
                 !text 125,20,100,112,76                   ;; @@5feb 171
                 !text 125,183,234,81,122                  ;; @@5ff0 171
                 !text 125,99,48,136,126                   ;; @@5ff5 171
                 !text 126,146,68,153,58                   ;; @@5ffa 171
                 !text 126,76,204,145,199                  ;; @@5fff 171
                 !text 127,170,170,170,19                  ;; @@6004 171
                 !text 129,0,0,0,0                         ;; @@6009 171
 ;; @@600e 171
; .page ;; @@600e 171
; Natural Log Function ;; @@600e 171
; ;; @@600e 171
; Calculation is by   LN(f*2^n) = (n+LOG2(f))*LN(2) ;; @@600e 171
; An approximation polynomial is used to calculate LOG2(f). ;; @@600e 171
 ;; @@600e 171
 ;; @@600e 171
log              jsr sign                                 ; is it positive? ;; @@600e 171
                 +lbeq fcerr                              ; can't tolerate neg or zero ;; @@6011 171
 ;; @@6014 171
                 lda facexp                               ; get exponent into (a) ;; @@6014 171
                 sbc #$7f                                 ; remove bias (carry is off) ;; @@6016 171
                 pha                                      ; save exponent a while ;; @@6018 171
                 lda #$80                                  ;; @@6019 171
                 sta facexp                               ; result is FAC in range (0.5,1) ;; @@601b 171
                 lda #<sqr05                              ; get pointer to sqr(0.5) ;; @@601d 171
                 ldy #>sqr05                               ;; @@601f 171
                 jsr romadd                                ;; @@6021 171
                 lda #<sqr20                               ;; @@6024 171
                 ldy #>sqr20                               ;; @@6026 171
                 jsr romdiv                                ;; @@6028 171
                 lda #<fone                                ;; @@602b 171
                 ldy #>fone                                ;; @@602d 171
                 jsr romsub                                ;; @@602f 171
                 lda #<logcn2                              ;; @@6032 171
                 ldy #>logcn2                              ;; @@6034 171
                 jsr polyx                                ; evaluate approximation polynomial ;; @@6036 171
                 lda #<neghlf                             ; add in last constant ;; @@6039 171
                 ldy #>neghlf                              ;; @@603b 171
                 jsr romadd                                ;; @@603d 171
                 pla                                      ; get exponent back ;; @@6040 171
                 jsr finlog                                ;; @@6041 171
                 lda #<log2                               ; multiply result by ln(2) ;; @@6044 171
                 ldy #>log2                                ;; @@6046 171
 ;; @@6048 171
 ;; @@6048 171
rommlt           jsr romupk                                ;; @@6048 171
                 bra fmultt                               ; multiply together ;; @@604b 171
 ;; @@604d 171
 ;; @@604d 171
faddh            lda #<fhalf                               ;; @@604d 171
                 ldy #>fhalf                               ;; @@604f 171
 ;; @@6051 171
romadd           jsr romupk                                ;; @@6051 171
                 +lbra faddt                               ;; @@6054 171
 ;; @@6057 171
 ;; @@6057 171
romsub           jsr romupk                                ;; @@6057 171
                 +lbra fsubt                               ;; @@605a 171
 ;; @@605d 171
 ;; @@605d 171
romdiv           jsr romupk                                ;; @@605d 171
                 +lbra fdivt                               ;; @@6060 171
 ;; @@6063 171
; .page ;; @@6063 171
; Multiplication        FAC = ARG*FAC ;; @@6063 171
 ;; @@6063 171
fmultt_c65                                                ; [910402] ;; @@6063 171
                 lda argsgn                                ;; @@6063 171
                 eor facsgn                                ;; @@6065 171
                 sta arisgn                               ; resultant sign ;; @@6067 171
                 ldx facexp                               ; set signs on thing to multiply ;; @@6069 171
                 bra fmultt                               ; go multiply ;; @@606b 171
 ;; @@606d 171
fmult            jsr conupk                               ; unpack the constant into arg for use ;; @@606d 171
 ;; @@6070 171
fmultt           beq multrt                               ; if FAC=0, return.  FAC is set ;; @@6070 171
                 jsr muldiv                               ; fix up the exponents ;; @@6072 171
                 lda #0                                   ; to clear result ;; @@6075 171
                 sta resho                                 ;; @@6077 171
                 sta resmoh                                ;; @@6079 171
                 sta resmo                                 ;; @@607b 171
                 sta reslo                                 ;; @@607d 171
                 lda facov                                 ;; @@607f 171
                 jsr mltpl1                               ; *** THIS fixes the DBL-0 bug without causing other grief!  C128-04 FAB ;; @@6081 171
                 lda faclo                                ; multiply arg by faclo ;; @@6084 171
                 jsr mltply                                ;; @@6086 171
                 lda facmo                                ; multiply arg by facmo ;; @@6089 171
                 jsr mltply                                ;; @@608b 171
                 lda facmoh                                ;; @@608e 171
                 jsr mltpl1                               ; *** THIS fixes the DBL-0 bug without causing other grief!  C128-04 FAB ;; @@6090 171
                 lda facho                                ; multiply arg by facho ;; @@6093 171
                 jsr mltpl1                                ;; @@6095 171
                 +lbra movfr                              ; move result into FAC ;; @@6098 171
 ;; @@609b 171
; .page ;; @@609b 171
mltply           +lbeq mulshf                             ; normalize result and return. shift result right 1 byte.  exits with .c=0 ;; @@609b 171
mltpl1           lsr                                       ;; @@609e 171
                 ora #$80                                 ; will flag end of shifting ;; @@609f 171
 ;; @@60a1 171
_local_1170_10   tay                                       ;; @@60a1 171
                 bcc _local_1170_20                       ; if mult bit=0, just shift ;; @@60a2 171
                 clc                                       ;; @@60a4 171
                 lda reslo                                 ;; @@60a5 171
                 adc arglo                                 ;; @@60a7 171
                 sta reslo                                 ;; @@60a9 171
                 lda resmo                                 ;; @@60ab 171
                 adc argmo                                 ;; @@60ad 171
                 sta resmo                                 ;; @@60af 171
                 lda resmoh                                ;; @@60b1 171
                 adc argmoh                                ;; @@60b3 171
                 sta resmoh                                ;; @@60b5 171
                 lda resho                                 ;; @@60b7 171
                 adc argho                                 ;; @@60b9 171
                 sta resho                                 ;; @@60bb 171
 ;; @@60bd 171
_local_1170_20   ror resho                                 ;; @@60bd 171
                 ror resmoh                                ;; @@60bf 171
                 ror resmo                                 ;; @@60c1 171
                 ror reslo                                 ;; @@60c3 171
                 ror facov                                ; save for rounding ;; @@60c5 171
                 tya                                       ;; @@60c7 171
                 lsr                                      ; clear msb so we get a closer to 0 ;; @@60c8 171
                 bne _local_1170_10                       ; slow as a turtle ;; @@60c9 171
 ;; @@60cb 171
multrt           rts                                       ;; @@60cb 172
 ;; @@60cc 172
; .page ;; @@60cc 172
; Unpack a ROM constant into the FAC ;; @@60cc 172
 ;; @@60cc 172
romupk           sta index1                                ;; @@60cc 172
                 sty index1+1                              ;; @@60ce 172
                 ldy #4                                    ;; @@60d0 172
                 lda (index1),y                           ; it's in ROM, so ok to use ind ;; @@60d2 172
                 sta arglo                                 ;; @@60d4 172
                 dey                                       ;; @@60d6 172
                 lda (index1),y                            ;; @@60d7 172
                 sta argmo                                 ;; @@60d9 172
                 dey                                       ;; @@60db 172
                 lda (index1),y                            ;; @@60dc 172
                 sta argmoh                                ;; @@60de 172
                 dey                                       ;; @@60e0 172
                 lda (index1),y                            ;; @@60e1 172
                 sta argsgn                                ;; @@60e3 172
                 eor facsgn                                ;; @@60e5 172
                 sta arisgn                                ;; @@60e7 172
                 lda argsgn                                ;; @@60e9 172
                 ora #$80                                  ;; @@60eb 172
                 sta argho                                 ;; @@60ed 172
                 dey                                       ;; @@60ef 172
                 lda (index1),y                            ;; @@60f0 172
                 sta argexp                                ;; @@60f2 172
                 lda facexp                               ; sets code of facexp ;; @@60f4 172
                 rts                                       ;; @@60f6 172
 ;; @@60f7 172
; .page ;; @@60f7 172
; Unpack a RAM constant into the FAC ;; @@60f7 172
 ;; @@60f7 172
conupk           sta index1                                ;; @@60f7 172
                 sty index1+1                              ;; @@60f9 172
 ;; @@60fb 172
; lda mmu_config_reg ;; @@60fb 172
; pha   ;preserve caller's memory config???? ;; @@60fb 172
 ;; @@60fb 172
                 ldy #4                                    ;; @@60fb 172
                 jsr indin1_ram1                           ;; @@60fd 172
                 sta arglo                                 ;; @@6100 172
                 dey                                       ;; @@6102 172
                 jsr indin1_ram1                           ;; @@6103 172
                 sta argmo                                 ;; @@6106 172
                 dey                                       ;; @@6108 172
                 jsr indin1_ram1                           ;; @@6109 172
                 sta argmoh                                ;; @@610c 172
                 dey                                       ;; @@610e 172
                 jsr indin1_ram1                           ;; @@610f 172
                 sta argsgn                                ;; @@6112 172
                 eor facsgn                                ;; @@6114 172
                 sta arisgn                                ;; @@6116 172
                 lda argsgn                                ;; @@6118 172
                 ora #$80                                  ;; @@611a 172
                 sta argho                                 ;; @@611c 172
                 dey                                       ;; @@611e 172
                 jsr indin1_ram1                           ;; @@611f 172
                 sta argexp                                ;; @@6122 172
 ;; @@6124 172
; pla ;; @@6124 172
; sta mmu_config_reg ;restore caller's memory config???? ;; @@6124 172
 ;; @@6124 172
                 lda facexp                               ; set codes of facexp ;; @@6124 172
                 rts                                       ;; @@6126 172
 ;; @@6127 172
; .page ;; @@6127 172
; Check special cases and add exponents for FMULT, FDIV ;; @@6127 172
 ;; @@6127 172
muldiv                                                     ;; @@6127 172
                 lda argexp                               ; exp of arg=0? ;; @@6127 172
mldexp           beq zeremv                               ; so we get zero exponent ;; @@6129 172
                 clc                                       ;; @@612b 172
                 adc facexp                               ; result is in (a) ;; @@612c 172
                 bcc _local_1171_10                       ; find (c) xor (n) ;; @@612e 172
                 +lbmi overr                              ; overflow if bits match ;; @@6130 172
                 clc                                       ;; @@6133 172
                 !text $2c                                 ;; @@6134 172
 ;; @@6135 172
_local_1171_10   bpl zeremv                               ; underflow ;; @@6135 172
                 adc #$80                                 ; add bias ;; @@6137 172
                 sta facexp                                ;; @@6139 172
                 +lbeq zeroml                             ; zero the rest of it ;; @@613b 172
                 lda arisgn                                ;; @@613e 172
                 sta facsgn                               ; arisgn is result's sign ;; @@6140 172
                 rts                                      ; done ;; @@6142 172
 ;; @@6143 172
 ;; @@6143 172
mldvex           lda facsgn                               ; get sign ;; @@6143 173
                 eor #$ff                                 ; complement it ;; @@6145 173
                 +lbmi overr                               ;; @@6147 173
 ;; @@614a 173
zeremv           pla                                      ; get addr off stack ;; @@614a 173
                 pla                                       ;; @@614b 173
                 +lbra zerofc                             ; underflow ;; @@614c 173
 ;; @@614f 173
; .page ;; @@614f 173
; Multiply FAC by 10 ;; @@614f 173
 ;; @@614f 173
mul10            jsr movaf                                ; copy FAC into ARG ;; @@614f 173
                 tax                                       ;; @@6152 173
                 beq mul10r                               ; if (FAC)=0, got answer ;; @@6153 173
                 clc                                       ;; @@6155 173
                 adc #2                                   ; augment exp by 2 ;; @@6156 173
                 +lbcs overr                              ; overflow ;; @@6158 173
 ;; @@615b 173
finml6           ldx #0                                    ;; @@615b 173
                 stx arisgn                               ; signs are same ;; @@615d 173
                 jsr faddc                                ; add together ;; @@615f 173
                 inc facexp                               ; multiply by two ;; @@6162 173
                 +lbeq overr                              ; overflow ;; @@6164 173
 ;; @@6167 173
mul10r           rts                                       ;; @@6167 173
 ;; @@6168 173
; .page ;; @@6168 173
div10            jsr movaf                                ; move FAC to ARG ;; @@6168 173
                 lda #<tenc                                ;; @@616b 173
                 ldy #>tenc                               ; point to constant of 10.0 ;; @@616d 173
                 ldx #0                                   ; signs are both positive ;; @@616f 173
 ;; @@6171 173
fdivf            stx arisgn                                ;; @@6171 173
                 jsr movfm                                ; put it into FAC ;; @@6173 173
                 bra fdivt                                 ;; @@6176 173
 ;; @@6178 173
fdivt_c65                                                 ; [910402] ;; @@6178 173
                 lda argsgn                                ;; @@6178 173
                 eor facsgn                                ;; @@617a 173
                 sta arisgn                               ; resultant sign ;; @@617c 173
                 ldx facexp                               ; set signs on thing to divide ;; @@617e 173
                 bra fdivt                                ; go divide ;; @@6180 173
 ;; @@6182 173
fdiv             jsr conupk                               ; unpack constant ;; @@6182 173
fdivt            +lbeq doverr                             ; can't divide by zero ;; @@6185 173
                 jsr round                                ; take FACOV into account in FAC ;; @@6188 173
                 lda #0                                   ; negate facexp ;; @@618b 173
                 sec                                       ;; @@618d 173
                 sbc facexp                                ;; @@618e 173
                 sta facexp                                ;; @@6190 173
                 jsr muldiv                               ; fix up exponents ;; @@6192 173
                 inc facexp                               ; scale it right ;; @@6195 173
                 +lbeq overr                              ; overflow ;; @@6197 173
                 ldx #$fc                                 ; set up procedure ;; @@619a 173
                 lda #1                                    ;; @@619c 173
 ;; @@619e 173
; .page ;; @@619e 173
divide                                                    ; this is the best code in the whole pile ;; @@619e 173
                 ldy argho                                ; see what relation holds ;; @@619e 173
                 cpy facho                                 ;; @@61a0 173
                 bne savquo                               ; (c)=0,1. n(c=0)=0. ;; @@61a2 173
                 ldy argmoh                                ;; @@61a4 173
                 cpy facmoh                                ;; @@61a6 173
                 bne savquo                                ;; @@61a8 173
                 ldy argmo                                 ;; @@61aa 173
                 cpy facmo                                 ;; @@61ac 173
                 bne savquo                                ;; @@61ae 173
                 ldy arglo                                 ;; @@61b0 173
                 cpy faclo                                 ;; @@61b2 173
 ;; @@61b4 173
savquo           php                                       ;; @@61b4 173
                 rol                                      ; save result ;; @@61b5 173
                 bcc qshft                                ; if not done, continue ;; @@61b6 173
                 inx                                       ;; @@61b8 173
                 sta reslo,x                               ;; @@61b9 173
                 beq ld100                                 ;; @@61bb 173
                 bpl divnrm                               ; note this req 1 no ram then access ;; @@61bd 173
                 lda #1                                    ;; @@61bf 173
 ;; @@61c1 173
qshft            plp                                      ; return condition codes ;; @@61c1 173
                 bcs divsub                               ; FAC <= ARG ;; @@61c2 173
 ;; @@61c4 173
shfarg           asl arglo                                ; shift ARG one place left ;; @@61c4 173
                 rol argmo                                 ;; @@61c6 173
                 rol argmoh                                ;; @@61c8 173
                 rol argho                                 ;; @@61ca 173
                 bcs savquo                               ; save a result of one for this position and divide ;; @@61cc 173
                 bmi divide                               ; if msb on, go decide whether to sub ;; @@61ce 173
                 bpl savquo                                ;; @@61d0 173
 ;; @@61d2 173
; .page ;; @@61d2 173
divsub           tay                                      ; notice c must be on here ;; @@61d2 173
                 lda arglo                                 ;; @@61d3 173
                 sbc faclo                                 ;; @@61d5 173
                 sta arglo                                 ;; @@61d7 173
                 lda argmo                                 ;; @@61d9 173
                 sbc facmo                                 ;; @@61db 173
                 sta argmo                                 ;; @@61dd 173
                 lda argmoh                                ;; @@61df 173
                 sbc facmoh                                ;; @@61e1 173
                 sta argmoh                                ;; @@61e3 173
                 lda argho                                 ;; @@61e5 173
                 sbc facho                                 ;; @@61e7 173
                 sta argho                                 ;; @@61e9 173
                 tya                                       ;; @@61eb 173
                 bra shfarg                                ;; @@61ec 173
 ;; @@61ee 173
 ;; @@61ee 173
 ;; @@61ee 173
ld100            lda #$40                                 ; only want two more bits ;; @@61ee 173
                 bra qshft                                ; always branches ;; @@61f0 173
 ;; @@61f2 173
 ;; @@61f2 173
 ;; @@61f2 173
divnrm           asl                                      ; get last two bits into MSB and B6 ;; @@61f2 173
                 asl                                       ;; @@61f3 173
                 asl                                       ;; @@61f4 173
                 asl                                       ;; @@61f5 173
                 asl                                       ;; @@61f6 173
                 asl                                       ;; @@61f7 173
                 sta facov                                 ;; @@61f8 173
                 plp                                       ;; @@61fa 173
 ;; @@61fb 173
 ;; @@61fb 173
; .page ;; @@61fb 173
movfr            lda resho                                ; move result to FAC ;; @@61fb 173
                 sta facho                                 ;; @@61fd 173
                 lda resmoh                                ;; @@61ff 173
                 sta facmoh                                ;; @@6201 173
                 lda resmo                                 ;; @@6203 173
                 sta facmo                                 ;; @@6205 173
                 lda reslo                                ; move lo and sign ;; @@6207 173
                 sta faclo                                 ;; @@6209 173
                 +lbra normal                             ; all done ;; @@620b 173
 ;; @@620e 173
 ;; @@620e 173
 ;; @@620e 173
movfm            sta index1                               ; move memory into FAC from ROM (unpacked) ;; @@620e 173
                 sty index1+1                              ;; @@6210 173
                 ldy #4                                    ;; @@6212 173
                 lda (index1),y                            ;; @@6214 173
                 sta faclo                                 ;; @@6216 173
                 dey                                       ;; @@6218 173
                 lda (index1),y                            ;; @@6219 173
                 sta facmo                                 ;; @@621b 173
                 dey                                       ;; @@621d 173
                 lda (index1),y                            ;; @@621e 173
                 sta facmoh                                ;; @@6220 173
                 dey                                       ;; @@6222 173
                 lda (index1),y                            ;; @@6223 173
                 sta facsgn                                ;; @@6225 173
                 ora #$80                                  ;; @@6227 173
                 sta facho                                 ;; @@6229 173
                 dey                                       ;; @@622b 173
                 lda (index1),y                            ;; @@622c 173
                 sta facexp                                ;; @@622e 173
                 sty facov                                 ;; @@6230 173
                 rts                                       ;; @@6232 173
 ;; @@6233 173
; .page ;; @@6233 173
; Move number from FAC to memory ;; @@6233 173
 ;; @@6233 173
mov2f            ldx #tempf2                              ; move from FAC to temp FAC2 ;; @@6233 173
                 !text $2c                                 ;; @@6235 173
 ;; @@6236 173
mov1f            ldx #tempf1                              ; move from FAC to temp FAC1 ;; @@6236 173
 ;; @@6238 173
                 ldy #0                                    ;; @@6238 173
movmf            jsr round                                 ;; @@623a 173
                 stx index1                                ;; @@623d 173
                 sty index1+1                              ;; @@623f 173
                 ldy #4                                    ;; @@6241 173
                 lda faclo                                 ;; @@6243 173
                 sta (index),y                            ; BasePage ;; @@6245 173
                 dey                                       ;; @@6247 173
                 lda facmo                                 ;; @@6248 173
                 sta (index),y                            ; BasePage ;; @@624a 173
                 dey                                       ;; @@624c 173
                 lda facmoh                                ;; @@624d 173
                 sta (index),y                            ; BasePage ;; @@624f 173
                 dey                                       ;; @@6251 173
                 lda facsgn                               ; include sign in ho ;; @@6252 173
                 ora #$7f                                  ;; @@6254 173
                 and facho                                 ;; @@6256 173
                 sta (index),y                            ; BasePage ;; @@6258 173
                 dey                                       ;; @@625a 173
                 lda facexp                                ;; @@625b 173
                 sta (index),y                            ; BasePage ;; @@625d 173
                 sty facov                                ; zero it since rounded ;; @@625f 173
                 rts                                      ; (y)=0 ;; @@6261 173
 ;; @@6262 173
; .page ;; @@6262 173
movmf_ram1                                                 ;; @@6262 173
                 jsr round                                 ;; @@6262 173
                 stx index1                                ;; @@6265 173
                 sty index1+1                              ;; @@6267 173
                 phx                                       ;; @@6269 173
                 ldx #index                                ;; @@626a 173
                 ldy #4                                    ;; @@626c 173
                 lda faclo                                 ;; @@626e 173
                 jsr sta_far_ram1                         ; sta (index),y ;; @@6270 173
                 dey                                       ;; @@6273 173
                 lda facmo                                 ;; @@6274 173
                 jsr sta_far_ram1                         ; sta (index),y ;; @@6276 173
                 dey                                       ;; @@6279 173
                 lda facmoh                                ;; @@627a 173
                 jsr sta_far_ram1                         ; sta (index),y ;; @@627c 173
                 dey                                       ;; @@627f 173
                 lda facsgn                               ; include sign in ho ;; @@6280 173
                 ora #$7f                                  ;; @@6282 173
                 and facho                                 ;; @@6284 173
                 jsr sta_far_ram1                         ; sta (index),y ;; @@6286 173
                 dey                                       ;; @@6289 173
                 lda facexp                                ;; @@628a 173
                 jsr sta_far_ram1                         ; sta (index),y ;; @@628c 173
                 sty facov                                ; zero it since rounded ;; @@628f 173
                 plx                                       ;; @@6291 173
                 rts                                      ; (y)=0 ;; @@6292 173
 ;; @@6293 173
; .page ;; @@6293 173
movfa            lda argsgn                                ;; @@6293 173
 ;; @@6295 173
movfa1           sta facsgn                                ;; @@6295 173
 ;; @@6297 173
                 ldx #5                                    ;; @@6297 173
_local_1172_1    lda argexp-1,x                            ;; @@6299 173
                 sta facexp-1,x                            ;; @@629b 173
                 dex                                       ;; @@629d 173
                 bne _local_1172_1                         ;; @@629e 173
                 stx facov                                 ;; @@62a0 173
                 rts                                       ;; @@62a2 173
 ;; @@62a3 173
 ;; @@62a3 173
movaf            jsr round                                 ;; @@62a3 174
 ;; @@62a6 174
movef            ldx #6                                    ;; @@62a6 174
_local_1173_1    lda facexp-1,x                            ;; @@62a8 174
                 sta argexp-1,x                            ;; @@62aa 174
                 dex                                       ;; @@62ac 174
                 bne _local_1173_1                         ;; @@62ad 174
                 stx facov                                ; zero it since rounded ;; @@62af 174
movrts           rts                                       ;; @@62b1 175
 ;; @@62b2 175
 ;; @@62b2 175
; .page ;; @@62b2 175
round            lda facexp                               ; zero? ;; @@62b2 175
                 beq movrts                               ; yes, done rounding ;; @@62b4 175
                 asl facov                                ; round? ;; @@62b6 175
                 bcc movrts                               ; no, msb off ;; @@62b8 175
 ;; @@62ba 175
incrnd           jsr incfac                               ; yes, add one to lsb(FAC) /// entry from EXP ;; @@62ba 175
;note .c=1 since incfac doesn't touch .c ;; @@62bd 175
                 +lbeq rndshf                             ; carry:   squeeze msb in and rts ;; @@62bd 175
                 rts                                      ; no carry: rts now ;; @@62c0 175
 ;; @@62c1 175
 ;; @@62c1 175
 ;; @@62c1 175
; Put sign in FAC into (a). ;; @@62c1 175
 ;; @@62c1 175
sign             lda facexp                                ;; @@62c1 175
                 beq signrt                               ; if number is zero, so is result ;; @@62c3 175
 ;; @@62c5 175
fcsign           lda facsgn                                ;; @@62c5 175
fcomps           rol                                       ;; @@62c7 175
                 lda #$ff                                 ; assume negative ;; @@62c8 175
                 bcs signrt                                ;; @@62ca 175
                 lda #1                                   ; get +1 ;; @@62cc 175
signrt           rts                                       ;; @@62ce 175
 ;; @@62cf 175
 ;; @@62cf 175
; .page ;; @@62cf 175
; SGN function ;; @@62cf 175
 ;; @@62cf 175
sgn              jsr sign                                  ;; @@62cf 175
 ;; @@62d2 175
;float the signed integer in accb ;; @@62d2 175
float            sta facho                                ; put (accb) in high order ;; @@62d2 175
                 lda #0                                    ;; @@62d4 175
                 sta facho+1                               ;; @@62d6 175
                 ldx #$88                                 ; get the exponent ;; @@62d8 175
;float the signed number in FAC ;; @@62da 175
 ;; @@62da 175
 ;; @@62da 175
floats           lda facho                                 ;; @@62da 175
                 eor #$ff                                  ;; @@62dc 175
                 rol                                      ; get comp of sign in carry ;; @@62de 175
floatc           lda #0                                   ; zero (a) but not carry ;; @@62df 175
                 sta faclo                                 ;; @@62e1 175
                 sta facmo                                 ;; @@62e3 175
 ;; @@62e5 175
floatb           stx facexp                                ;; @@62e5 175
                 sta facov                                 ;; @@62e7 175
                 sta facsgn                                ;; @@62e9 175
                 +lbra fadflt                              ;; @@62eb 175
 ;; @@62ee 175
 ;; @@62ee 175
 ;; @@62ee 175
 ;; @@62ee 175
; Absolute value of FAC ;; @@62ee 175
 ;; @@62ee 175
abs              lsr facsgn                                ;; @@62ee 175
                 rts                                       ;; @@62f0 175
 ;; @@62f1 175
 ;; @@62f1 175
; .page ;; @@62f1 175
; Compare two numbers: ;; @@62f1 175
; ;; @@62f1 175
; a=1  if  ARG < FAC ;; @@62f1 175
; a=0  if  ARG = FAC ;; @@62f1 175
; a=-1 if  ARG > FAC ;; @@62f1 175
 ;; @@62f1 175
fcomp            sta index2                                ;; @@62f1 175
                 sty index2+1                              ;; @@62f3 175
                 ldy #0                                    ;; @@62f5 175
                 lda (index2),y                           ; has argexp ;; @@62f7 175
                 iny                                      ; bump pointer up ;; @@62f9 175
                 tax                                      ; save a in x and reset codes ;; @@62fa 175
                 beq sign                                  ;; @@62fb 175
                 lda (index2),y                            ;; @@62fd 175
                 eor facsgn                               ; signs the same ;; @@62ff 175
                 bmi fcsign                               ; signs differ so result is ;; @@6301 175
                 cpx facexp                               ; sign of FAC again ;; @@6303 175
                 bne _local_1174_10                        ;; @@6305 175
 ;; @@6307 175
                 lda (index2),y                            ;; @@6307 175
                 ora #$80                                  ;; @@6309 175
                 cmp facho                                 ;; @@630b 175
                 bne _local_1174_10                        ;; @@630d 175
                 iny                                       ;; @@630f 175
                 lda (index2),y                            ;; @@6310 175
                 cmp facmoh                                ;; @@6312 175
                 bne _local_1174_10                        ;; @@6314 175
                 iny                                       ;; @@6316 175
                 lda (index2),y                            ;; @@6317 175
                 cmp facmo                                 ;; @@6319 175
                 bne _local_1174_10                        ;; @@631b 175
                 iny                                       ;; @@631d 175
                 lda #$7f                                  ;; @@631e 175
                 cmp facov                                 ;; @@6320 175
                 lda (index2),y                            ;; @@6322 175
                 sbc faclo                                ; get zero if equal ;; @@6324 175
                 beq qintrt                               ; rts ;; @@6326 175
 ;; @@6328 175
_local_1174_10   lda facsgn                                ;; @@6328 175
                 bcc _local_1174_20                        ;; @@632a 175
                 eor #$ff                                  ;; @@632c 175
_local_1174_20   bra fcomps                               ; a part of sign sets up (a) ;; @@632e 175
 ;; @@6330 175
;.end ;; @@6330 175
; .page ;; @@6330 175
; .subttl Floating Point Math Package (CODE21) ;; @@6330 175
 ;; @@6330 175
; Quick Greatest Integer Function ;; @@6330 175
; ;; @@6330 175
; Leaves INT(FAC) in FACHO&MO&LO signed ;; @@6330 175
; Assumes FAC < 2~23 =8388608 ;; @@6330 175
 ;; @@6330 175
qint             lda facexp                                ;; @@6330 176
                 beq clrfac                               ; if zero, got it ;; @@6332 176
                 sec                                       ;; @@6334 176
                 sbc #$a0                                 ; get number of places to shift ;; @@6335 176
 ;; @@6337 176
                 bbr7 facsgn,_local_1175_10                ;; @@6337 176
 ;; @@633a 176
                 tax                                       ;; @@633a 176
                 lda #$ff                                  ;; @@633b 176
                 sta bits                                 ; put $ff in when shftr shifts bytes ;; @@633d 176
                 jsr negfch                               ; truly negate quantity in FAC ;; @@6340 176
                 txa                                       ;; @@6343 176
 ;; @@6344 176
_local_1175_10   ldx #fac                                  ;; @@6344 176
                 cmp #$f9                                  ;; @@6346 176
                 bpl qint1                                ; if number of places > 7 shift 1 place at a time ;; @@6348 176
                 jsr shiftr                               ; start shifting bytes, then bits ;; @@634a 176
                 sty bits                                 ; zero bits since adder wants zero ;; @@634d 176
qintrt           rts                                       ;; @@6350 177
 ;; @@6351 177
 ;; @@6351 177
qint1            tay                                      ; put count in counter ;; @@6351 177
                 lda facsgn                                ;; @@6352 177
                 and #$80                                 ; get sign bit ;; @@6354 177
                 lsr facho                                ; save first shifted byte ;; @@6356 177
                 ora facho                                 ;; @@6358 177
                 sta facho                                 ;; @@635a 177
                 jsr rolshf                               ; shift the rest ;; @@635c 177
                 sty bits                                 ; zero (bits) ;; @@635f 177
                 rts                                       ;; @@6362 177
 ;; @@6363 177
 ;; @@6363 177
; .page ;; @@6363 177
; Greatest Integer Function ;; @@6363 177
 ;; @@6363 177
int              lda facexp                                ;; @@6363 177
                 cmp #$a0                                  ;; @@6365 177
                 bcs intrts                               ; forget it ;; @@6367 177
                 jsr round                                ; round FAC per FACOV (fixes the  INT(.9+.1) -> 0  Microsoft bug.  FAB) ;; @@6369 177
                 jsr qint                                 ; INT(FAC) ;; @@636c 177
                 sty facov                                ; clr overflow byte ;; @@636f 177
                 lda facsgn                                ;; @@6371 177
                 sty facsgn                               ; make FAC look positive ;; @@6373 177
                 eor #$80                                 ; get complement of sign in carry ;; @@6375 177
                 rol                                       ;; @@6377 177
                 lda #$a0                                 ; @230+8 ;; @@6378 177
                 sta facexp                                ;; @@637a 177
                 lda faclo                                 ;; @@637c 177
                 sta integr                                ;; @@637e 177
                 +lbra fadflt                              ;; @@6380 177
 ;; @@6383 177
 ;; @@6383 177
clrfac           sta facho                                ; make it really zero ;; @@6383 177
                 sta facmoh                                ;; @@6385 177
                 sta facmo                                 ;; @@6387 177
                 sta faclo                                 ;; @@6389 177
                 tay                                       ;; @@638b 177
intrts           rts                                       ;; @@638c 177
 ;; @@638d 177
; .page ;; @@638d 177
; Floating Point Input Routine. ;; @@638d 177
; ;; @@638d 177
; Number input is left in FAC.  At entry (TXTPTR) points to the first character ;; @@638d 177
; in a text buffer.  The first character is also in (a).  FIN packs the digits ;; @@638d 177
; into the FAC as an integer and keeps track of where the decimal point is. ;; @@638d 177
; (DPTFLG) tells whether a dp has been seen.  (DECCNT) is the number of digits ;; @@638d 177
; after the dp.  At the end (DECCNT) and the exponent are used to determine how ;; @@638d 177
; many times to multiply or divide by ten to get the correct number. ;; @@638d 177
 ;; @@638d 177
 ;; @@638d 177
fin              stx fin_bank                             ; save bank number where string is stored ;; @@638d 177
 ;; @@6390 177
                 ldy #0                                   ; zero facsgn, sgnflg ;; @@6390 177
                 ldx #$0a                                 ; zero exp and ho (and moh) ;; @@6392 177
_local_1176_10   sty deccnt,x                             ; zero mo and lo ;; @@6394 177
                 dex                                      ; zero tenexp and expsgn ;; @@6396 177
                 bpl _local_1176_10                       ; zero deccnt, dptflg ;; @@6397 177
 ;; @@6399 177
                 bcc findgq                               ; flags still set from chrget ;; @@6399 177
                 cmp #'-'                                 ; a negative sign? ;; @@639b 177
                 bne qplus                                ; no, try plus sign ;; @@639d 177
                 stx sgnflg                               ; it's negative. (x=@377) ;; @@639f 177
                 bra finc                                 ; always branches ;; @@63a1 177
 ;; @@63a3 177
; .page ;; @@63a3 177
qplus            cmp #'+'                                 ; plus sign? ;; @@63a3 178
                 bne fin1                                 ; yes, skip it ;; @@63a5 178
 ;; @@63a7 178
finc             jsr fin_chrget                            ;; @@63a7 178
 ;; @@63aa 178
findgq           bcc findig                                ;; @@63aa 178
 ;; @@63ac 178
fin1             cmp #'.'                                 ; the dp? ;; @@63ac 178
                 beq findp                                ; no kidding ;; @@63ae 178
                 cmp #'E'                                 ; exponent follows ;; @@63b0 178
                 bne fine                                 ; no ;; @@63b2 178
 ;; @@63b4 178
                 jsr fin_chrget                           ; yes, get another, to check sign of exponent ;; @@63b4 178
                 bcc fnedg1                               ; is it a digit. (easier than backing up pointer) ;; @@63b7 178
                 cmp #minus_token                         ; minus? ;; @@63b9 178
                 beq finec1                               ; negate ;; @@63bb 178
                 cmp #'-'                                 ; minus sign? ;; @@63bd 178
                 beq finec1                                ;; @@63bf 178
                 cmp #plus_token                          ; plus? ;; @@63c1 178
                 beq finec                                 ;; @@63c3 178
                 cmp #'+'                                 ; plus sign? ;; @@63c5 178
                 beq finec                                 ;; @@63c7 178
                 bra finec2                                ;; @@63c9 178
 ;; @@63cb 178
finec1           ror expsgn                               ; turn it on ;; @@63cb 178
 ;; @@63cd 178
finec            jsr fin_chrget                           ; get another ;; @@63cd 178
 ;; @@63d0 178
fnedg1           bcc finedg                               ; it is a digit ;; @@63d0 178
finec2           bbr7 expsgn,fine                          ;; @@63d2 178
                 lda #0                                    ;; @@63d5 178
                 sec                                       ;; @@63d7 178
                 sbc tenexp                                ;; @@63d8 178
                 bra fine1                                 ;; @@63da 178
 ;; @@63dc 178
findp            ror dptflg                                ;; @@63dc 178
                 bbr6 dptflg,finc                          ;; @@63de 178
 ;; @@63e1 178
fine             lda tenexp                                ;; @@63e1 178
fine1            sec                                       ;; @@63e3 178
                 sbc deccnt                               ; get number of places to shift ;; @@63e4 178
                 sta tenexp                                ;; @@63e6 178
                 beq finqng                               ; negate? ;; @@63e8 178
                 bpl finmul                               ; positive, so multiply ;; @@63ea 178
 ;; @@63ec 178
findiv           jsr div10                                 ;; @@63ec 178
                 inc tenexp                               ; done? ;; @@63ef 178
                 bne findiv                               ; no ;; @@63f1 178
                 bra finqng                               ; yes ;; @@63f3 178
 ;; @@63f5 178
 ;; @@63f5 178
finmul           jsr mul10                                 ;; @@63f5 178
                 dec tenexp                               ; done? ;; @@63f8 178
                 bne finmul                               ; no ;; @@63fa 178
finqng           lda sgnflg                                ;; @@63fc 178
                 +lbmi negop                              ; if negative, negate and return ;; @@63fe 178
                 rts                                      ; if positive, return ;; @@6401 178
 ;; @@6402 178
 ;; @@6402 178
 ;; @@6402 178
findig           pha                                       ;; @@6402 178
                 bbr7 dptflg,_local_1177_10                ;; @@6403 178
                 inc deccnt                                ;; @@6406 178
_local_1177_10   jsr mul10                                 ;; @@6408 178
                 pla                                      ; get it back ;; @@640b 178
                 sec                                       ;; @@640c 178
                 sbc #'0'                                  ;; @@640d 178
                 jsr finlog                               ; add it in ;; @@640f 178
                 bra finc                                  ;; @@6412 178
 ;; @@6414 178
 ;; @@6414 178
 ;; @@6414 178
finlog           pha                                       ;; @@6414 179
                 jsr movaf                                ; save it for later ;; @@6415 179
                 pla                                       ;; @@6418 179
                 jsr float                                ; float the value in (a) ;; @@6419 179
 ;; @@641c 179
faddt_c65                                                 ; [910402] ;; @@641c 179
                 lda argsgn                                ;; @@641c 179
                 eor facsgn                                ;; @@641e 179
                 sta arisgn                               ; resultant sign ;; @@6420 179
                 ldx facexp                               ; set signs on thing to add ;; @@6422 179
                 +lbra faddt                              ; add together and return ;; @@6424 179
 ;; @@6427 179
; .page ;; @@6427 179
; Pack in the next digit of the exponent. ;; @@6427 179
; Multiply the old exp by 10 and add in the next digit. ;; @@6427 179
; (note: does not check for exp overflow) ;; @@6427 179
 ;; @@6427 179
finedg           lda tenexp                               ; get exp so far ;; @@6427 179
                 cmp #10                                  ; will result be >= 100? ;; @@6429 179
                 bcc _local_1178_5                         ;; @@642b 179
                 lda #100                                  ;; @@642d 179
                 bbs7 expsgn,_local_1178_30               ; if neg exp, no chk for overr ;; @@642f 179
                 +lbra overr                               ;; @@6432 179
 ;; @@6435 179
_local_1178_5    asl                                      ; max is 120 ;; @@6435 179
                 asl                                      ; mult by 2 twice ;; @@6436 179
                 clc                                      ; possible shift out of high ;; @@6437 179
                 adc tenexp                               ; like multiplying by five ;; @@6438 179
                 asl                                      ; and now by ten ;; @@643a 179
                 clc                                       ;; @@643b 179
                 ldy #0                                    ;; @@643c 179
                 sta syntmp                                ;; @@643e 179
 ;; @@6440 179
                 lda fin_bank                             ; text or string bank? ;; @@6440 179
                 bne _local_1178_10                        ;; @@6443 179
                 jsr indtxt                               ; text ;; @@6445 179
                 bra _local_1178_20                        ;; @@6448 179
_local_1178_10   jsr indin1_ram1                          ; string ;; @@644a 179
 ;; @@644d 179
_local_1178_20   adc syntmp                                ;; @@644d 179
                 sec                                       ;; @@644f 179
                 sbc #'0'                                  ;; @@6450 179
_local_1178_30   sta tenexp                               ; save result ;; @@6452 179
                 +lbra finec                               ;; @@6454 179
 ;; @@6457 179
; .page ;; @@6457 179
; Get a character from either text or string area, and set the flags ;; @@6457 179
; in the manner performed by CHRGET. ;; @@6457 179
 ;; @@6457 179
fin_chrget                                                 ;; @@6457 180
                 lda fin_bank                             ; text or string bank? ;; @@6457 180
                 +lbeq chrget                             ; get byte from text bank via normal CHRGET mechanism ;; @@645a 180
 ;; @@645d 180
fin_chrget_1                                              ; get byte from string bank via modified CHRGET mechanism ;; @@645d 180
                 inw index1                                ;; @@645d 180
fin_chrget_2                                               ;; @@645f 180
                 ldy #0                                    ;; @@645f 180
                 jsr indin1_ram1                           ;; @@6461 180
                 cmp #':'                                  ;; @@6464 180
                 bcs _local_1179_10                        ;; @@6466 180
                 cmp #' '                                  ;; @@6468 180
                 beq fin_chrget_1                         ; skip over spaces ;; @@646a 180
                 sec                                       ;; @@646c 180
                 sbc #'0'                                 ; set up .c as CHRGET would ;; @@646d 180
                 sec                                       ;; @@646f 180
                 sbc #$d0                                  ;; @@6470 180
_local_1179_10   rts                                       ;; @@6472 180
 ;; @@6473 180
;.end ;; @@6473 180
; .page ;; @@6473 180
; .subttl Floating Point Math Package (CODE22,23) ;; @@6473 180
 ;; @@6473 180
inprt            jsr _primm                                ;; @@6473 181
                 !text " IN ",0                            ;; @@6476 181
 ;; @@647b 181
curprt           lda curlin+1                              ;; @@647b 181
                 ldx curlin                                ;; @@647d 181
 ;; @@647f 181
linprt           sta facho                                 ;; @@647f 181
                 stx facho+1                               ;; @@6481 181
                 ldx #$90                                 ; exponent of 16 ;; @@6483 181
                 sec                                      ; number is positive ;; @@6485 181
                 jsr floatc                                ;; @@6486 181
                 jsr foutc                                 ;; @@6489 181
                 +lbra strout                             ; print and return ;; @@648c 181
 ;; @@648f 181
 ;; @@648f 181
fout             ldy #1                                    ;; @@648f 181
foutc            lda #' '                                 ; if positive, print space ;; @@6491 181
                 bbr7 facsgn,_local_1180_10                ;; @@6493 181
                 lda #'-'                                 ; if neg ;; @@6496 181
_local_1180_10   sta fbuffr-1,y                           ; store the character ;; @@6498 181
                 sta facsgn                               ; make FAC pos for QINT ;; @@649b 181
                 sty fbufpt                               ; save for later ;; @@649d 181
                 iny                                       ;; @@649f 181
                 lda #'0'                                 ; get zero to type if FAC=0 ;; @@64a0 181
                 ldx facexp                                ;; @@64a2 181
                 +lbeq fout19                              ;; @@64a4 181
 ;; @@64a7 181
                 lda #0                                    ;; @@64a7 181
                 cpx #$80                                 ; is number < 1? ;; @@64a9 181
                 beq _local_1180_20                       ; no ;; @@64ab 181
                 bcs _local_1180_30                        ;; @@64ad 181
 ;; @@64af 181
_local_1180_20   lda #<nmil                               ; mult by 10~6 ;; @@64af 181
                 ldy #>nmil                                ;; @@64b1 181
                 jsr rommlt                                ;; @@64b3 181
                 lda #$f7                                  ;; @@64b6 181
_local_1180_30   sta deccnt                               ; save count or zero it ;; @@64b8 181
 ;; @@64ba 181
_local_1180_40   lda #<n9999                               ;; @@64ba 181
                 ldy #>n9999                               ;; @@64bc 181
                 jsr fcomp                                ; is number > 999999.499 or 999999999.5? ;; @@64be 181
                 beq _local_1180_100                      ; go to biggies ;; @@64c1 181
                 bpl _local_1180_70                       ; yes, make it smaller ;; @@64c3 181
 ;; @@64c5 181
_local_1180_50   lda #<n0999                               ;; @@64c5 181
                 ldy #>n0999                               ;; @@64c7 181
                 jsr fcomp                                ; is number > 99999.9499 or 99999999.90625? ;; @@64c9 181
                 beq _local_1180_60                        ;; @@64cc 181
                 bpl _local_1180_80                       ; yes. done multiplying ;; @@64ce 181
 ;; @@64d0 181
_local_1180_60   jsr mul10                                ; make it bigger ;; @@64d0 181
                 dec deccnt                                ;; @@64d3 181
                 bne _local_1180_50                       ; see if that does it (this always goes) ;; @@64d5 181
 ;; @@64d7 181
_local_1180_70   jsr div10                                ; make it smaller ;; @@64d7 181
                 inc deccnt                                ;; @@64da 181
                 bne _local_1180_40                       ; see if that does it (this always goes) ;; @@64dc 181
 ;; @@64de 181
_local_1180_80   jsr faddh                                ; add a half to round up ;; @@64de 181
 ;; @@64e1 181
 ;; @@64e1 181
_local_1180_100  jsr qint                                 ; biggies. ;; @@64e1 181
                 ldx #1                                   ; decimal point count ;; @@64e4 181
                 lda deccnt                                ;; @@64e6 181
                 clc                                       ;; @@64e8 181
                 adc #$0a                                 ; should number be printed in E notation?  (ie, is number .lt. .01?) ;; @@64e9 181
                 bmi _local_1180_110                      ; yes ;; @@64eb 181
                 cmp #$0b                                 ; is it > 999999 or 9999999999? ;; @@64ed 181
                 bcs _local_1180_120                      ; yes, use E notation ;; @@64ef 181
                 adc #$ff                                 ; number of places before decimal point ;; @@64f1 181
                 tax                                      ; put into accx ;; @@64f3 181
                 lda #2                                   ; no E notation ;; @@64f4 181
_local_1180_110  sec                                       ;; @@64f6 181
 ;; @@64f7 181
_local_1180_120  sbc #2                                   ; effectively add 5 to orig exp ;; @@64f7 181
                 sta tenexp                               ; that is the exponent to print ;; @@64f9 181
                 stx deccnt                               ; number of decimal places ;; @@64fb 181
                 txa                                       ;; @@64fd 181
                 beq _local_1180_130                       ;; @@64fe 181
                 bpl _local_1180_150                      ; some places before dec pnt ;; @@6500 181
 ;; @@6502 181
_local_1180_130  ldy fbufpt                               ; get pointer to output ;; @@6502 181
                 lda #'.'                                 ; put in "." ;; @@6504 181
                 iny                                       ;; @@6506 181
                 sta fbuffr-1,y                            ;; @@6507 181
                 txa                                       ;; @@650a 181
                 beq _local_1180_140                       ;; @@650b 181
                 lda #'0'                                 ; get the ensuing zero ;; @@650d 181
                 iny                                       ;; @@650f 181
                 sta fbuffr-1,y                            ;; @@6510 181
 ;; @@6513 181
_local_1180_140  sty fbufpt                               ; save it for later ;; @@6513 181
 ;; @@6515 181
_local_1180_150  ldy #0                                    ;; @@6515 181
 ;; @@6517 181
foutim           ldx #$80                                 ; first pass through, accb has msb set ;; @@6517 182
fout2            lda faclo                                 ;; @@6519 182
                 clc                                       ;; @@651b 182
                 adc foutbl+3,y                            ;; @@651c 182
                 sta faclo                                 ;; @@651f 182
                 lda facmo                                 ;; @@6521 182
                 adc foutbl+2,y                            ;; @@6523 182
                 sta facmo                                 ;; @@6526 182
                 lda facmoh                                ;; @@6528 182
                 adc foutbl+1,y                            ;; @@652a 182
                 sta facmoh                                ;; @@652d 182
                 lda facho                                 ;; @@652f 182
                 adc foutbl,y                              ;; @@6531 182
                 sta facho                                 ;; @@6534 182
                 inx                                      ; it was done yet another time ;; @@6536 182
                 bcs _local_1181_20                        ;; @@6537 182
                 bpl fout2                                 ;; @@6539 182
                 bmi _local_1181_30                        ;; @@653b 182
 ;; @@653d 182
_local_1181_20   bmi fout2                                 ;; @@653d 182
_local_1181_30   txa                                       ;; @@653f 182
                 bcc _local_1181_40                       ; can use (a) as is ;; @@6540 182
                 eor #$ff                                 ; find 11.(a) ;; @@6542 182
                 adc #10                                  ; c is still on to complete negation, and will always be on after ;; @@6544 182
 ;; @@6546 182
_local_1181_40   adc #'0'-1                               ; get a character to print ;; @@6546 182
                 iny                                       ;; @@6548 182
                 iny                                       ;; @@6549 182
                 iny                                       ;; @@654a 182
                 iny                                       ;; @@654b 182
                 sty fdecpt                                ;; @@654c 182
                 ldy fbufpt                                ;; @@654e 182
                 iny                                      ; point to place to store output ;; @@6550 182
                 tax                                       ;; @@6551 182
                 and #$7f                                 ; get rid of msb ;; @@6552 182
                 sta fbuffr-1,y                            ;; @@6554 182
                 dec deccnt                                ;; @@6557 182
                 bne _local_1181_50                       ; not time for dp yet ;; @@6559 182
                 lda #'.'                                  ;; @@655b 182
                 iny                                       ;; @@655d 182
                 sta fbuffr-1,y                           ; store dp ;; @@655e 182
 ;; @@6561 182
_local_1181_50   sty fbufpt                               ; store pointer for later ;; @@6561 182
                 ldy fdecpt                                ;; @@6563 182
                 txa                                      ; complement accb ;; @@6565 182
                 eor #$ff                                 ; complement acca ;; @@6566 182
                 and #$80                                 ; save only msb ;; @@6568 182
                 tax                                       ;; @@656a 182
                 cpy #fdcend-foutbl                        ;; @@656b 182
; beq _local_1181_60  ;for time converter ????   removed [901014] ;; @@656d 182
; cpy #timend-foutbl ;; @@656d 182
                 bne fout2                                ; continue with output ;; @@656d 182
 ;; @@656f 182
_local_1181_60   ldy fbufpt                               ; get back output pointer ;; @@656f 182
_local_1181_70   lda fbuffr-1,y                           ; remove trailing blanks ;; @@6571 182
                 dey                                       ;; @@6574 182
                 cmp #'0'                                  ;; @@6575 182
                 beq _local_1181_70                        ;; @@6577 182
                 cmp #'.'                                  ;; @@6579 182
                 beq _local_1181_80                       ; ran into dp,  stop ;; @@657b 182
                 iny                                      ; something else, save it ;; @@657d 182
 ;; @@657e 182
_local_1181_80   lda #'+'                                  ;; @@657e 182
                 ldx tenexp                                ;; @@6580 182
                 beq fout17                               ; no exponent to output ;; @@6582 182
                 bpl _local_1181_90                        ;; @@6584 182
                 lda #0                                    ;; @@6586 182
                 sec                                       ;; @@6588 182
                 sbc tenexp                                ;; @@6589 182
                 tax                                       ;; @@658b 182
                 lda #'-'                                 ; exponent is negative ;; @@658c 182
 ;; @@658e 182
_local_1181_90   sta fbuffr+1,y                           ; store sign of exponent ;; @@658e 182
                 lda #'E'                                  ;; @@6591 182
                 sta fbuffr,y                             ; store the 'E' character ;; @@6593 182
                 txa                                       ;; @@6596 182
 ;; @@6597 182
                 ldx #'0'-1                                ;; @@6597 182
                 sec                                       ;; @@6599 182
_local_1181_100  inx                                      ; move closer to output value ;; @@659a 182
                 sbc #10                                  ; subtract 10 ;; @@659b 182
                 bcs _local_1181_100                      ; not negative yet ;; @@659d 182
 ;; @@659f 182
                 adc #'9'+1                               ; get second output character ;; @@659f 182
                 sta fbuffr+3,y                           ; store high digit ;; @@65a1 182
                 txa                                       ;; @@65a4 182
                 sta fbuffr+2,y                           ; store low digit ;; @@65a5 182
                 lda #0                                   ; put in terminator ;; @@65a8 182
                 sta fbuffr+4,y                            ;; @@65aa 182
                 bra fout20                               ; return ;; @@65ad 182
 ;; @@65af 182
 ;; @@65af 182
fout19           sta fbuffr-1,y                           ; store the character ;; @@65af 183
fout17           lda #0                                   ; store the terminator ;; @@65b2 183
                 sta fbuffr,y                              ;; @@65b4 183
 ;; @@65b7 183
fout20           lda #<fbuffr                              ;; @@65b7 183
                 ldy #>fbuffr                              ;; @@65b9 183
                 rts                                      ; all done ;; @@65bb 183
 ;; @@65bc 183
; .page ;; @@65bc 183
; Exponentiation and Square Root Functions. ;; @@65bc 183
; ;; @@65bc 183
; square root function - sqr(a) ;; @@65bc 183
; use sqr(x) = x^.5 ;; @@65bc 183
 ;; @@65bc 183
sqr              jsr movaf                                ; move FAC into ARG ;; @@65bc 183
                 lda #<fhalf                               ;; @@65bf 183
                 ldy #>fhalf                               ;; @@65c1 183
 ;; @@65c3 183
fpwr             jsr movfm                                ; put memory into FAC    ARG^MEM ;; @@65c3 183
 ;; @@65c6 183
 ;; @@65c6 183
; Last thing fetched is facexp into accx. ;; @@65c6 183
; ;; @@65c6 183
; Exponentiation --- x^y. ;; @@65c6 183
; n.b. 0^0=1 ;; @@65c6 183
; First check if y=0, and if so the result is one. ;; @@65c6 183
; Next  check if x=0, and if so the result is zero. ;; @@65c6 183
; Then  check if x>0: ;; @@65c6 183
; if not check that y is an integer. ;; @@65c6 183
; if so negate x, so that lg doesn't give fcerr. ;; @@65c6 183
; If x is negative and y is odd, negate the result returned by exp. ;; @@65c6 183
; To compute the result use x^y = EXP((y*LOG(x)) ;; @@65c6 183
 ;; @@65c6 183
 ;; @@65c6 183
fpwrt            beq exp                                  ; if FAC=0, just exponentiate that  ARG^FAC ;; @@65c6 183
                 lda argexp                               ; is x=0? ;; @@65c8 183
                 +lbeq zerof1                             ; zero FAC ;; @@65ca 183
 ;; @@65cd 183
                 ldx #<tempf3                             ; save it for later in a temp ;; @@65cd 183
                 ldy #>tempf3                              ;; @@65cf 183
                 jsr movmf                                ; FAC->MEM ;; @@65d1 183
 ;; @@65d4 183
                 lda argsgn                               ; note y=0 already. that's good, in case no one calls int. ;; @@65d4 183
                 bpl _local_1182_10                       ; no problems if x>0 ;; @@65d6 183
                 jsr int                                  ; integerize the FAC ;; @@65d8 183
                 lda #<tempf3                             ; get addr of comperand ;; @@65db 183
                 ldy #>tempf3                              ;; @@65dd 183
                 jsr fcomp                                ; equal? ;; @@65df 183
                 bne _local_1182_10                       ; leave x neg. log will blow him out ;; @@65e2 183
;a=-1 and y is irrelavant ;; @@65e4 183
                 tya                                      ; negative x. make positive ;; @@65e4 183
                 ldy integr                               ; get evenness ;; @@65e5 183
 ;; @@65e7 183
_local_1182_10   jsr movfa1                               ; alternate entry point.    ARG->FAC ;; @@65e7 183
                 phy                                      ; save evenness for later ;; @@65ea 183
                 jsr log                                  ; find log ;; @@65eb 183
                 lda #<tempf3                             ; multiply FAC times LOG(x) ;; @@65ee 183
                 ldy #>tempf3                              ;; @@65f0 183
                 jsr fmult                                 ;; @@65f2 183
                 jsr exp                                  ; exponentiate the FAC ;; @@65f5 183
                 pla                                       ;; @@65f8 183
                 lsr                                      ; is it even? ;; @@65f9 183
                 bcc negrts                               ; yes. or x>0 ;; @@65fa 183
;negate the number in FAC ;; @@65fc 183
 ;; @@65fc 183
 ;; @@65fc 183
negop                                                     ; /// entry point ;; @@65fc 184
                 lda facexp                                ;; @@65fc 184
                 beq negrts                                ;; @@65fe 184
                 lda facsgn                                ;; @@6600 184
                 eor #$ff                                  ;; @@6602 184
                 sta facsgn                                ;; @@6604 184
negrts           rts                                       ;; @@6606 184
 ;; @@6607 184
;.end ;; @@6607 184
; .page ;; @@6607 184
; .subttl Floating Point Math Package (CODE24) ;; @@6607 184
 ;; @@6607 184
; Exponentation Function ;; @@6607 184
; ;; @@6607 184
; First save the original argument and multiply the FAC by LOG2(e).  The ;; @@6607 184
; result is used to determine if overflow will occur since ;; @@6607 184
; ;; @@6607 184
;  EXP(x) = 2^(x*LOG2(e)) ;; @@6607 184
; ;; @@6607 184
; where ;; @@6607 184
;  LOG2(e) = LOG(e), base 2 ;; @@6607 184
; ;; @@6607 184
; Then save the integer part of this to scale the answer at the end, since ;; @@6607 184
; 2^y=2^INT(y)*2^(y-INT(y)) and 2^INT(y) are easy to compute.  Now compute ;; @@6607 184
; ;; @@6607 184
;  2^(x*LOG2(e)-INT(x*LOG2(e)) ;; @@6607 184
; by ;; @@6607 184
;  p(LOG(2)*(INT(x*LOG2(e))+1)-x ;; @@6607 184
; ;; @@6607 184
; where p is an approximation polynomial. The result is then scaled by the ;; @@6607 184
; power of two previously saved.  Re: Taylor expansion. ;; @@6607 184
 ;; @@6607 184
 ;; @@6607 184
exp              lda #<logeb2                             ; multiply by LOG(e) base 2 ;; @@6607 184
                 ldy #>logeb2                              ;; @@6609 184
                 jsr rommlt                               ; LOGEB2->ARG, FAC=FAC*ARG ;; @@660b 184
                 lda facov                                 ;; @@660e 184
                 adc #$50                                 ; ???? ;; @@6610 184
                 bcc _local_1183_10                        ;; @@6612 184
                 jsr incrnd                                ;; @@6614 184
 ;; @@6617 184
_local_1183_10   sta oldov                                 ;; @@6617 184
                 jsr movef                                ; to save in ARG without round.  ARG=FAC, facov=0) ;; @@6619 184
                 lda facexp                                ;; @@661c 184
                 cmp #$88                                 ; if ABS(FAC) >= 128, too big ;; @@661e 184
                 bcc _local_1183_30                        ;; @@6620 184
 ;; @@6622 184
_local_1183_20   jsr mldvex                               ; overflow or overflow ;; @@6622 184
_local_1183_30   jsr int                                  ; FAC=INT(FAC), uses facov ;; @@6625 184
                 lda integr                               ; get low part ;; @@6628 184
                 clc                                       ;; @@662a 184
                 adc #$81                                  ;; @@662b 184
                 beq _local_1183_20                       ; overflow or overflow!! ;; @@662d 184
 ;; @@662f 184
                 sec                                       ;; @@662f 184
                 sbc #1                                   ; subtract it ;; @@6630 184
                 pha                                      ; save a while ;; @@6632 184
 ;; @@6633 184
                 ldx #5                                   ; swap FAC and ARG ;; @@6633 184
_local_1183_40   lda argexp,x                              ;; @@6635 184
                 ldy facexp,x                              ;; @@6637 184
                 sta facexp,x                              ;; @@6639 184
                 sty argexp,x                              ;; @@663b 184
                 dex                                       ;; @@663d 184
                 bpl _local_1183_40                        ;; @@663e 184
 ;; @@6640 184
                 lda oldov                                 ;; @@6640 184
                 sta facov                                 ;; @@6642 184
                 jsr fsubt                                ; FAC=ARG-FAC ;; @@6644 184
                 jsr negop                                ; negate FAC ;; @@6647 184
                 lda #<expcon                              ;; @@664a 184
                 ldy #>expcon                              ;; @@664c 184
                 jsr poly                                  ;; @@664e 184
                 lda #0                                    ;; @@6651 184
                 sta arisgn                               ; multiply by positive 1.0 ;; @@6653 184
 ;; @@6655 184
                 pla                                      ; recall scale factor ;; @@6655 184
                 jsr mldexp                               ; modify facexp and check for overflow ;; @@6656 184
                 rts                                      ; (has to do jsr due to pla's in muldiv) ;; @@6659 184
 ;; @@665a 184
; .page ;; @@665a 184
; Polynomial Evaluator and the Random Number Generator. ;; @@665a 184
; ;; @@665a 184
; Evaluate  p(x^2)*x ;; @@665a 184
; The pointer to degree is in (a,y) and the constants follow the degree. ;; @@665a 184
; For x=FAC, compute  c0*x + c1*x^3 + c2*x^5 + c3*x^7 +...+ c(n)*x^(2*n+1) ;; @@665a 184
 ;; @@665a 184
 ;; @@665a 184
polyx            sta polypt                               ; retain polynomial pointer for later ;; @@665a 185
                 sty polypt+1                              ;; @@665c 185
                 jsr mov1f                                ; save FAC in factmp (y=0 upon return) ;; @@665e 185
                 lda #tempf1                               ;; @@6661 185
                 jsr fmult                                ; compute x^2. ;; @@6663 185
                 jsr poly1                                ; compute p(x^2). ;; @@6666 185
                 lda #<tempf1                              ;; @@6669 185
                 ldy #>tempf1                              ;; @@666b 185
                 +lbra fmult                              ; multiply by FAC again ;; @@666d 185
 ;; @@6670 185
 ;; @@6670 185
; Polynomial Evaluator ;; @@6670 185
; ;; @@6670 185
; Pointer to degree is in (a,y). ;; @@6670 185
; Compute:  c0+c1*x+c2*x^2+c3*x^3+c4*x^4...+c(n-1)*x^(n-1)+c(n)*x^n ;; @@6670 185
;  which is roughly (LOG(2)^n)/LOG(EXP(1))/n! ;; @@6670 185
 ;; @@6670 185
 ;; @@6670 185
poly             sta polypt                                ;; @@6670 185
                 sty polypt+1                              ;; @@6672 185
 ;; @@6674 185
poly1            jsr mov2f                                ; save FAC (rounds, .y=0) ;; @@6674 185
                 lda (polypt),y                            ;; @@6677 185
                 sta degree                                ;; @@6679 185
                 inw polypt                                ;; @@667b 185
                 lda polypt                                ;; @@667d 185
                 ldy polypt+1                              ;; @@667f 185
 ;; @@6681 185
_local_1184_10   jsr rommlt                                ;; @@6681 185
                 lda polypt                               ; get current pointer ;; @@6684 185
                 ldy polypt+1                              ;; @@6686 185
                 clc                                       ;; @@6688 185
                 adc #5                                    ;; @@6689 185
                 bcc _local_1184_20                        ;; @@668b 185
                 iny                                       ;; @@668d 185
_local_1184_20   sta polypt                                ;; @@668e 185
                 sty polypt+1                              ;; @@6690 185
                 jsr romadd                               ; add in constant ;; @@6692 185
                 lda #<tempf2                             ; multiply the original FAC ;; @@6695 185
                 ldy #>tempf2                              ;; @@6697 185
                 dec degree                               ; done? ;; @@6699 185
                 bne _local_1184_10                        ;; @@669b 185
                 rts                                      ; yes ;; @@669d 185
 ;; @@669e 185
;.end ;; @@669e 185
; .page ;; @@669e 185
; .subttl Floating Point Math Package (TRIG) ;; @@669e 185
 ;; @@669e 185
; Sine, Cosine, and Tangent Functions. ;; @@669e 185
 ;; @@669e 185
 ;; @@669e 185
 ;; @@669e 185
; Cosine function cos(x)=sin(x+pi/2) ;; @@669e 185
 ;; @@669e 185
 ;; @@669e 185
cos              lda #<pi2                                ; pointer to pi/2 ;; @@669e 186
                 ldy #>pi2                                 ;; @@66a0 186
                 jsr romadd                               ; add it in.  fall into sine ;; @@66a2 186
 ;; @@66a5 186
 ;; @@66a5 186
 ;; @@66a5 186
; Sine function ;; @@66a5 186
; ;; @@66a5 186
; Use identities to get FAC in quadrants I or IV.  The FAC is divided by 2*pi ;; @@66a5 186
; and the integer part is ignored because sin(x+2*pi)=sin(x).  Then the ;; @@66a5 186
; argument can be compared with pi/2 by comparing the result of the division ;; @@66a5 186
; with pi/2(2*pi)=1/4.  Identities are then used to get the result in quadrants ;; @@66a5 186
; I or IV.  An approximation polynomial is then used to compute sin(x). ;; @@66a5 186
 ;; @@66a5 186
 ;; @@66a5 186
sin              jsr movaf                                 ;; @@66a5 186
                 lda #<twopi                              ; get pointer to divisor ;; @@66a8 186
                 ldy #>twopi                               ;; @@66aa 186
                 ldx argsgn                               ; get sign of result ;; @@66ac 186
                 jsr fdivf                                 ;; @@66ae 186
                 jsr movaf                                ; get result into ARG ;; @@66b1 186
                 jsr int                                  ; integerize FAC ;; @@66b4 186
                 lda #0                                    ;; @@66b7 186
                 sta arisgn                               ; always have the same sign ;; @@66b9 186
                 jsr fsubt                                ; keep only the fractional part ;; @@66bb 186
                 lda #<fr4                                ; get pointer to 1/4 ;; @@66be 186
                 ldy #>fr4                                 ;; @@66c0 186
                 jsr romsub                                ;; @@66c2 186
                 lda facsgn                               ; save sign for later ;; @@66c5 186
                 pha                                       ;; @@66c7 186
                 bpl sin1                                 ; first quadrant ;; @@66c8 186
                 jsr faddh                                ; add 1/2 to FAC ;; @@66ca 186
                 lda facsgn                               ; sign is negative? ;; @@66cd 186
                 bmi sin2                                  ;; @@66cf 186
                 lda tansgn                               ; quads II and III come here ;; @@66d1 186
                 eor #$ff                                  ;; @@66d3 186
                 sta tansgn                                ;; @@66d5 186
 ;; @@66d7 186
sin1             jsr negop                                ; if positive, negate it ;; @@66d7 186
 ;; @@66da 186
sin2             lda #<fr4                                ; pointer to 1/4 ;; @@66da 186
                 ldy #>fr4                                 ;; @@66dc 186
                 jsr romadd                               ; add it in ;; @@66de 186
                 pla                                      ; get original quadrant ;; @@66e1 186
                 bpl _local_1185_10                        ;; @@66e2 186
                 jsr negop                                ; if negative, negate result ;; @@66e4 186
 ;; @@66e7 186
_local_1185_10   lda #<sincon                              ;; @@66e7 186
                 ldy #>sincon                              ;; @@66e9 186
                 +lbra polyx                              ; do approximation polyomial ;; @@66eb 186
 ;; @@66ee 186
 ;; @@66ee 186
 ;; @@66ee 186
; Tangent function ;; @@66ee 186
 ;; @@66ee 186
 ;; @@66ee 186
tan              jsr mov1f                                ; move FAC into temporary ;; @@66ee 187
                 lda #0                                    ;; @@66f1 187
                 sta tansgn                               ; remember whether to negate ;; @@66f3 187
                 jsr sin                                  ; compute the sin ;; @@66f5 187
                 ldx #<tempf3                              ;; @@66f8 187
                 ldy #>tempf3                              ;; @@66fa 187
                 jsr movmf                                ; put sign into other temp ;; @@66fc 187
                 lda #<tempf1                              ;; @@66ff 187
                 ldy #>tempf1                              ;; @@6701 187
                 jsr movfm                                ; put this memory location into FAC ;; @@6703 187
                 lda #0                                    ;; @@6706 187
                 sta facsgn                               ; start off positive ;; @@6708 187
                 lda tansgn                                ;; @@670a 187
                 jsr _local_1186_10                       ; compute cosine ;; @@670c 187
                 lda #<tempf3                              ;; @@670f 187
                 ldy #>tempf3                             ; address of sine value ;; @@6711 187
; bra fdiv ;divide sine by cosine and return ;; @@6713 187
                 jsr conupk                               ; unpack constant    [910226] FAB ;; @@6713 187
                 +lbeq overr                              ; overflow error     " ;; @@6716 187
                 +lbra fdivt                              ; " ;; @@6719 187
 ;; @@671c 187
_local_1186_10   pha                                      ; cosc. ;; @@671c 187
                 bra sin1                                  ;; @@671d 187
 ;; @@671f 187
 ;; @@671f 187
; Arctangent function ;; @@671f 187
; ;; @@671f 187
; Use identities to get arg between 0 and 1 and then use an approximation ;; @@671f 187
; polynomial to compute arctan(x). ;; @@671f 187
 ;; @@671f 187
 ;; @@671f 187
atn              lda facsgn                               ; what is sign? ;; @@671f 188
                 pha                                      ; save for later ;; @@6721 188
                 bpl _local_1187_10                        ;; @@6722 188
                 jsr negop                                ; if negative, negate FAC ;; @@6724 188
;use arctan(x)=-arctan(-x) ;; @@6727 188
_local_1187_10   lda facexp                                ;; @@6727 188
                 pha                                      ; save this too for later ;; @@6729 188
                 cmp #$81                                 ; see if FAC >= 1.0 ;; @@672a 188
                 bcc _local_1187_20                       ; it is less than 1 ;; @@672c 188
                 lda #<fone                               ; get pntr to 1.0 ;; @@672e 188
                 ldy #>fone                                ;; @@6730 188
                 jsr romdiv                               ; compute reciprocal ;; @@6732 188
;use aectan(x)=pi/2-arctan(1/x) ;; @@6735 188
_local_1187_20   lda #<atncon                             ; pointer to arctan constants ;; @@6735 188
                 ldy #>atncon                              ;; @@6737 188
                 jsr polyx                                 ;; @@6739 188
                 pla                                       ;; @@673c 188
                 cmp #$81                                 ; was original argument < 1? ;; @@673d 188
                 bcc _local_1187_30                       ; yes ;; @@673f 188
                 lda #<pi2                                 ;; @@6741 188
                 ldy #>pi2                                 ;; @@6743 188
                 jsr romsub                               ; subtract arctan from pi/2 ;; @@6745 188
 ;; @@6748 188
_local_1187_30   pla                                      ; was original aurgument positive? ;; @@6748 188
                 bpl _local_1187_40                       ; yes ;; @@6749 188
                 +lbra negop                              ; if negative, negate result ;; @@674b 188
 ;; @@674e 188
_local_1187_40   rts                                      ; all done ;; @@674e 188
 ;; @@674f 188
;.end ;; @@674f 188
; .page ;; @@674f 188
; .subttl  BOOT ;; @@674f 188
 ;; @@674f 188
;**************************************************************************** ;; @@674f 188
; BOOT  Boot has three modes of operation... ;; @@674f 188
; ;; @@674f 188
;   1. *B*LOAD a given binary file and SYS to its load address. ;; @@674f 188
;   2. *D*LOAD a BASIC file named AUTOBOOT.C65* and RUN it. ;; @@674f 188
;   3. BOOT SYS loads the home sector to $0400 and JMPs to it. ;; @@674f 188
; ;; @@674f 188
; For modes 1 & 2, syntax is the same as BLOAD.  Differentiate ;; @@674f 188
; between the two modes via the presence of a filename.  All other ;; @@674f 188
; parameters, such as drive and device numbers, are utilized in the ;; @@674f 188
; normal manner.  For mode 3 there are no options.  It's intended ;; @@674f 188
; to boot a new OS.  BASIC is turned off if it's successful.  If it ;; @@674f 188
; fails, the run time stack & sprites might be corrupted. ;; @@674f 188
;**************************************************************************** ;; @@674f 188
 ;; @@674f 188
boot             cmp #sys_token                           ; BOOTSYS?      [910111] ;; @@674f 189
                 bne _local_1188_1                        ; no ;; @@6751 189
                 jsr chrget                               ; yes- eat token ;; @@6753 189
                 jsr _bootsys                             ; attempt to boot a new OS ;; @@6756 189
                 bcc _local_1188_15                       ; returned to us after successful install ;; @@6759 189
                 ldx #errbdk                              ; bootsys failed, report 'bad disk'???? ;; @@675b 189
                 +lbra error                               ;; @@675d 189
 ;; @@6760 189
_local_1188_1    bbr4 runmod,_local_1188_2                ; Error if in Edit mode     [910620] ;; @@6760 189
                 +lbra edit_err                            ;; @@6763 189
 ;; @@6766 189
_local_1188_2    lda #0                                   ; BOOT "filename"     [910417] ;; @@6766 189
                 sta verck                                ; want 'load', not 'verify' ;; @@6768 189
                 lda #$e6                                 ; set up parameters for DOS parser like BLOAD ;; @@676a 189
                 ldx #$fc                                  ;; @@676c 189
                 jsr dosprx                               ; parse the command ;; @@676e 189
                 bbr0 parsts,_local_1188_20               ; was there a filename?  branch if not ;; @@6771 189
                 jsr bload_boot                           ; yes- bload it ;; @@6774 189
                 +lbcs erexit                             ; load error ;; @@6777 189
 ;; @@677a 189
; ldx current_bank ;assume no B(ank) arg was given    [910114] ;; @@677a 189
; bbr0 parstx,_local_1188_10  ; correct, use current setup ;; @@677a 189
                 ldx dosbnk                               ; else use given bank number ;; @@677a 189
_local_1188_10   stx _bank                                 ;; @@677d 189
                 lda _starting_addr                       ; set up address BLOAD loaded to ;; @@677f 189
                 sta _pclo                                 ;; @@6781 189
                 lda _starting_addr+1                      ;; @@6783 189
                 sta _pchi                                 ;; @@6785 189
                 jsr _jsr_far                             ; call it ;; @@6787 189
_local_1188_15   rts                                       ;; @@678a 189
 ;; @@678b 189
_local_1188_20   ldy #$ff                                  ;; @@678b 189
_local_1188_30   iny                                      ; Copy default filename from ROM into buffer ;; @@678d 189
                 lda autoboot_filename,y                   ;; @@678e 189
                 sta savram,y                              ;; @@6791 189
                 bne _local_1188_30                       ; null terminated ;; @@6794 189
 ;; @@6796 189
                 sty dosf1l                               ; length not counting terminator ;; @@6796 189
                 smb6 runmod                              ; set flag for load not to go to ready ;; @@6799 189
                 jsr dload_boot                           ; Load it ;; @@679b 189
                 +lbcs erexit                             ; error if problems ;; @@679e 189
                 +lbra run_a_program                      ; else go run it ;; @@67a1 189
 ;; @@67a4 189
; .page ;; @@67a4 189
; AUTOBOOT_CSG Runs a system diagnostic if PB0 is low after initialization. ;; @@67a4 189
;  Diagnostic is copied to RAM-0 from ROM-2 and jumped to. ;; @@67a4 189
 ;; @@67a4 189
autobootCSG                                               ; Run ROMed diagnostic if PB0 low   [911105] ;; @@67a4 190
                 lda $dd01                                 ;; @@67a4 190
                 lsr                                       ;; @@67a7 190
                 bcs autoboot                             ; no, try to boot from disk ;; @@67a8 190
 ;; @@67aa 190
                 sei                                      ; prevent IRQ from wacking code DL'd to $1xxx  [911106] ;; @@67aa 190
                 ldx #12-1                                 ;; @@67ab 190
_local_1189_10   lda _local_1189_20,x                     ; prep DMA list ;; @@67ad 190
                 sta dma1_cmd,x                            ;; @@67b0 190
                 dex                                       ;; @@67b3 190
                 bpl _local_1189_10                        ;; @@67b4 190
 ;; @@67b6 190
                 lda #0                                    ;; @@67b6 190
                 ldx #>dma1_cmd                           ; copy program from ROM to RAM ;; @@67b8 190
                 ldy #<dma1_cmd                            ;; @@67ba 190
                 sta dma_ctlr+2                           ; dma_list bank ;; @@67bc 190
                 stx dma_ctlr+1                           ; dma_list hi ;; @@67bf 190
                 sty dma_ctlr                             ; dma_list lo & trigger ;; @@67c2 190
 ;; @@67c5 190
; jmp run_a_program ;if 'program' was BASIC ;; @@67c5 190
; lda #0   ;else set up arg's for call to 'long jmp'  [911105] ;; @@67c5 190
                 sta _bank                                 ;; @@67c5 190
                 sta _pclo                                 ;; @@67c7 190
                 lda #$10                                  ;; @@67c9 190
                 sta _pchi                                 ;; @@67cb 190
                 jmp _jmp_far                             ; jump to code, no return.  NOTE: this *MAPs* RAM-0 into context! ;; @@67cd 190
 ;; @@67d0 190
; move from $024001 to $002001, $3FFF bytes  BASIC program ;; @@67d0 190
;_local_1189_20 .byte $00,$ff,$3f,$01,$40,$02,$01,$20,$00,$00,$00,$00 ;; @@67d0 190
 ;; @@67d0 190
; move from $024000 to $1000, $4000 bytes   Diagnostic  [911105] ;; @@67d0 190
_local_1189_20   !text $00,$00,$40,$00,$40,$02,$00,$10,$00,0,0,0  ;; @@67d0 190
 ;; @@67dc 190
; .page ;; @@67dc 190
; AUTOBOOT Attempts to RUN a disk program after cold startup.  The ;; @@67dc 190
;  program must be a BASIC program called "AUTOBOOT.C65*" ;; @@67dc 190
 ;; @@67dc 190
autoboot                                                   ;; @@67dc 191
                 lda #0                                   ; Select internal drive ;; @@67dc 191
                 sta fdc                                   ;; @@67de 191
_local_1190_10   bit fdc+2                                ; busywait ;; @@67e1 191
                 bmi _local_1190_10                        ;; @@67e4 191
                 lda fdc+3                                ; See if a diskette is present ;; @@67e6 191
                 and #$08                                  ;; @@67e9 191
                 beq _local_1190_30                       ; exit with no action taken if not ;; @@67eb 191
 ;; @@67ed 191
                 lda #$e6                                 ; set up parameters for DOS parser like BLOAD ;; @@67ed 191
                 ldx #$fc                                  ;; @@67ef 191
                 jsr dosprx                               ; let the parser init DOS stuff ;; @@67f1 191
 ;; @@67f4 191
                 ldy #$ff                                  ;; @@67f4 191
_local_1190_20   iny                                      ; Copy filename from ROM into buffer ;; @@67f6 191
                 lda autoboot_filename,y                   ;; @@67f7 191
                 sta savram,y                              ;; @@67fa 191
                 bne _local_1190_20                       ; null terminated ;; @@67fd 191
                 sty dosf1l                               ; length not counting terminator ;; @@67ff 191
 ;; @@6802 191
                 lda #%01000001                           ; set flag for load indicating autoboot ;; @@6802 191
                 sta runmod                               ; set flag for load not to go to ready ;; @@6804 191
                 jsr dload_boot                           ; skip parser & load it ;; @@6806 191
 ;; @@6809 191
                 lda #0                                   ; clear autoboot flags ;; @@6809 191
                 sta runmod                                ;; @@680b 191
                 phx                                      ; save end address ;; @@680d 191
                 phy                                       ;; @@680e 191
                 jsr _readst                              ; get status report, but check it later ;; @@680f 191
                 pha                                       ;; @@6812 191
                 jsr Suck_DS                              ; clear any DOS errors (to kill error LED) ;; @@6813 191
                 pla                                      ; now check I/O status ;; @@6816 191
                 ply                                       ;; @@6817 191
                 plx                                       ;; @@6818 191
                 and #$bf                                 ; EOI is okay ;; @@6819 191
                 bne _local_1190_30                       ; outside problems ;; @@681b 191
                 bcs _local_1190_30                       ; inside problems ;; @@681d 191
 ;; @@681f 191
                 stx text_top                             ; success- set end address & run it ;; @@681f 191
                 sty text_top+1                            ;; @@6821 191
                 cli                                       ;; @@6823 191
                 +lbra run_a_program                       ;; @@6824 191
 ;; @@6827 191
_local_1190_30   rts                                      ; failure- go_ready ;; @@6827 191
 ;; @@6828 191
 ;; @@6828 191
autoboot_filename                                           ;; @@6828 192
                 !text "AUTOBOOT.C65*",0                   ;; @@6828 192
 ;; @@6836 192
; .page ;; @@6836 192
; .subttl  SAVE  LOAD  VERIFY  OPEN  CLOSE ;; @@6836 192
 ;; @@6836 192
erexit           tax                                      ; set termination flags ;; @@6836 192
                 +lbne error                              ; normal error ;; @@6837 192
                 +lbra break_exit                         ; user break ;; @@683a 192
 ;; @@683d 192
 ;; @@683d 192
 ;; @@683d 192
outch            jsr _bsout                                ;; @@683d 192
                 bcs erexit                                ;; @@6840 192
                 rts                                       ;; @@6842 192
 ;; @@6843 192
 ;; @@6843 192
 ;; @@6843 192
inchr            jsr _basin                                ;; @@6843 192
                 bcs erexit                                ;; @@6846 192
                 rts                                       ;; @@6848 192
 ;; @@6849 192
 ;; @@6849 192
coout                                                      ;; @@6849 192
; jsr put_io_in_map ;; @@6849 192
                 jsr _chkout                               ;; @@6849 192
                 jsr dschk                                ; see if device # >=4, and clear DS if so ;; @@684c 192
                 bcs erexit                               ; take error exit of there was one ;; @@684f 192
                 rts                                       ;; @@6851 192
 ;; @@6852 192
 ;; @@6852 192
coin                                                       ;; @@6852 192
; jsr put_io_in_map ;; @@6852 192
                 jsr _chkin                                ;; @@6852 192
                 jsr dschk                                ; see if device # >=4, and clear DS if so ;; @@6855 192
                 bcs erexit                                ;; @@6858 192
                 rts                                       ;; @@685a 192
 ;; @@685b 192
cgetl                                                      ;; @@685b 192
; jsr put_io_in_map ;; @@685b 192
                 jsr _getin                                ;; @@685b 192
                 +lbcs break_exit                         ; 'stop' key was pressed ;; @@685e 192
                 rts                                       ;; @@6861 192
 ;; @@6862 192
; .page ;; @@6862 192
save             jsr plsv                                 ; parse parameters, dschk ;; @@6862 192
 ;; @@6865 192
 ;; @@6865 192
savenp                                                    ; Save Program (from DSave) ;; @@6865 192
                 ldx text_top                             ; ending address ;; @@6865 192
                 ldy text_top+1                            ;; @@6867 192
                 lda #<txttab                             ; pointer to start address ;; @@6869 192
 ;; @@686b 192
 ;; @@686b 192
savenb                                                    ; Save Binary (from BSave & KEY SAVE) ;; @@686b 192
; jsr put_io_in_map ;; @@686b 192
                 jsr _savesp                              ; save it ;; @@686b 192
 ;; @@686e 192
; Any changes to the following code must be duplicated at: ;; @@686e 192
;  bload ;; @@686e 192
;  load (load_file) ;; @@686e 192
 ;; @@686e 192
exit_disk_op                                               ;; @@686e 192
exit_disk_operation                                           ;; @@686e 192
                 php                                      ; preserve kernel error status (.c) ;; @@686e 192
                 pha                                      ; preserve kernel error # (.a) ;; @@686f 192
                 jsr print_dos_error                      ; print DOS error msg if any only in direct mode ;; @@6870 192
                 pla                                       ;; @@6873 192
                 plp                                       ;; @@6874 192
                 bcc _local_1191_30                       ; branch if no error (rts) ;; @@6875 192
                 bbs7 runmod,_local_1191_20               ; branch if run mode (erexit) ;; @@6877 192
                 cmp #errfnf                              ; is it 'file not found' catch-all? ;; @@687a 192
                 bne _local_1191_10                       ; no  (erexit) ;; @@687c 192
                 sta errnum                               ; yes- save error # for 'er' ;; @@687e 192
                 ora #$80                                 ; but no errdis ;; @@6881 192
_local_1191_10   sec                                       ;; @@6883 192
_local_1191_20   bcs erexit                               ; exit if kernel problem (rts) ;; @@6884 192
_local_1191_30   rts                                       ;; @@6886 192
 ;; @@6887 192
; .page ;; @@6887 192
verify           lda #1                                   ; verify flag ;; @@6887 193
                 !text $2c                                ; skip two bytes ;; @@6889 193
 ;; @@688a 193
load             lda #0                                   ; load flag ;; @@688a 193
                 sta verck                                 ;; @@688c 193
_local_1192_1    bbr4 runmod,_local_1192_2                ; Error if in Edit mode     [910620] ;; @@688e 193
                 +lbra edit_err                            ;; @@6891 193
_local_1192_2    jsr plsv                                 ; parse parameters, dschk ;; @@6894 193
 ;; @@6897 193
cld10                                                     ; <<<<<<<<<<<<<<<<<<<<<<<<<<<<<< entry from dload ;; @@6897 194
; jsr put_io_in_map ;; @@6897 194
                 lda verck                                 ;; @@6897 194
                 ldx txttab                               ; .x and .y have alt... ;; @@6899 194
                 ldy txttab+1                             ; ...load address ;; @@689b 194
 ;; @@689d 194
; Any changes to the following code must be duplicated at: ;; @@689d 194
;  bload ;; @@689d 194
;  save (exit_disk_op) ;; @@689d 194
 ;; @@689d 194
load_file                                                  ;; @@689d 194
                 jsr _loadsp                              ; load it ;; @@689d 194
                 bbs0 runmod,cld20                        ; skip error checks if autoboot (rts) ;; @@68a0 194
                 phx                                      ; save end address ;; @@68a3 194
                 phy                                       ;; @@68a4 194
                 php                                      ; save kernel load status (.c) ;; @@68a5 194
                 pha                                      ; save kernel error # (.a) ;; @@68a6 194
                 jsr _readst                              ; save I/O status byte ;; @@68a7 194
                 sta parsts                                ;; @@68aa 194
                 jsr print_dos_error                      ; report error msg if any only in direct mode ;; @@68ac 194
                 pla                                      ; restore error stuff ;; @@68af 194
                 plp                                       ;; @@68b0 194
                 bcc _local_1193_30                       ; branch if no error (rts) ;; @@68b1 194
                 bbs7 runmod,_local_1193_20               ; branch if run mode (erexit) ;; @@68b3 194
                 cmp #errfnf                              ; is it 'file not found' catch-all? ;; @@68b6 194
                 bne _local_1193_10                       ; no  (erexit) ;; @@68b8 194
                 sta errnum                               ; yes- save error # for 'er' ;; @@68ba 194
                 ora #$80                                 ; but no errdis ;; @@68bd 194
_local_1193_10   sec                                       ;; @@68bf 194
_local_1193_20   +lbcs erexit                             ; exit if kernel problem ;; @@68c0 194
_local_1193_30   ply                                      ; restore end address ;; @@68c3 194
                 plx                                       ;; @@68c4 194
                 lda verck                                 ;; @@68c5 194
                 beq cld50                                ; was load ;; @@68c7 194
 ;; @@68c9 194
; Finish verify ;; @@68c9 194
 ;; @@68c9 194
verify_check                                               ;; @@68c9 195
                 ldx #ervfy                               ; assume error ;; @@68c9 195
; jsr _readst  ;read status ;; @@68cb 195
                 bbs4 parsts,cld55                        ; branch if 'verify' error ;; @@68cb 195
                 bbs7 runmod,cld20                        ; branch if not direct mode ;; @@68ce 195
verify_ok                                                  ;; @@68d1 195
                 jsr _primm                                ;; @@68d1 195
                 !text cr,"OK", cr,0                       ;; @@68d4 195
cld20            rts                                       ;; @@68d9 195
 ;; @@68da 195
 ;; @@68da 195
 ;; @@68da 195
; Finish load ;; @@68da 195
 ;; @@68da 195
cld50                                                      ;; @@68da 195
; jsr _readst  ;check I/O status ;; @@68da 195
                 lda parsts                                ;; @@68da 195
                 and #%10111111                           ; EOI is okay, so mask it ;; @@68dc 195
                 beq cld60                                ; good- finish load operation ;; @@68de 195
 ;; @@68e0 195
load_error                                                 ;; @@68e0 195
                 ldx #erload                               ;; @@68e0 195
cld55            +lbra error                               ;; @@68e2 195
 ;; @@68e5 195
 ;; @@68e5 195
cld60            stx text_top                              ;; @@68e5 195
                 sty text_top+1                           ; end load address ;; @@68e7 195
 ;; @@68e9 195
                 bbs7 runmod,cld70                        ; branch if not direct mode ;; @@68e9 195
                 bbs6 runmod,cld20                        ; special "RUN file_name" flag...get out here (rts) ;; @@68ec 195
 ;; @@68ef 195
                 jsr link_program                         ; relink ;; @@68ef 195
                 jsr runc                                 ; clear vars ;; @@68f2 195
                 +lbra ready_2                            ; print 'ready' & return to main ;; @@68f5 195
 ;; @@68f8 195
 ;; @@68f8 195
; Program load ;; @@68f8 195
 ;; @@68f8 195
cld70            jsr reset_txtptr                          ;; @@68f8 195
                 jsr link_program                          ;; @@68fb 195
                 +lbra fload                               ;; @@68fe 195
 ;; @@6901 195
; .page ;; @@6901 195
open             jsr paoc                                 ; parse statement ;; @@6901 195
                 jsr _open                                ; open it ;; @@6904 195
                 bra close_out_1                           ;; @@6907 195
 ;; @@6909 195
 ;; @@6909 195
 ;; @@6909 195
close            jsr paoc                                 ; parse statement ;; @@6909 195
; jsr put_io_in_map ;; @@690c 195
                 lda andmsk                               ; get la ;; @@690c 195
 ;; @@690e 195
 ;; @@690e 195
close_out                                                 ; enter with .a=LA   [900725] ;; @@690e 195
                 clc                                      ; flag a real close ;; @@690e 195
                 jsr _close                               ; close it ;; @@690f 195
 ;; @@6912 195
close_out_1                                                ;; @@6912 195
                 php                                       ;; @@6912 195
                 pha                                       ;; @@6913 195
                 lda _fa                                  ; special error checking if disk op ;; @@6914 195
                 cmp #8                                    ;; @@6916 195
                 bcc _local_1194_10                        ;; @@6918 195
                 pla                                       ;; @@691a 195
                 plp                                       ;; @@691b 195
                 +lbra exit_disk_operation                ; disk ;; @@691c 195
 ;; @@691f 195
_local_1194_10   pla                                      ; something else ;; @@691f 195
                 plp                                       ;; @@6920 195
                 +lbcs erexit                              ;; @@6921 195
                 rts                                       ;; @@6924 195
 ;; @@6925 195
; .page ;; @@6925 195
; Parse LOAD, SAVE, & VERIFY commands ;; @@6925 195
 ;; @@6925 195
plsv                                                       ;; @@6925 196
                 lda #0                                   ; set default filename (none) ;; @@6925 196
                 jsr _setnam                               ;; @@6927 196
                 ldx _default_drive                       ; set default device # (dosffn) ;; @@692a 196
                 ldy #0                                   ; command 0 ;; @@692d 196
                 jsr _setlfs                               ;; @@692f 196
                 lda text_bank                            ; all loads to   bank 0 ???? set default memory banks ;; @@6932 196
                 ldx var_bank                             ; all names from bank 1 ????   [910620] ;; @@6934 196
                 jsr _setbank                              ;; @@6936 196
 ;; @@6939 196
                 jsr paoc20                               ; by-pass junk ;; @@6939 196
                 jsr paoc15                               ; get/set file name ;; @@693c 196
                 jsr paoc20                               ; by-pass junk ;; @@693f 196
                 jsr plsv7                                ; get ',fa' ;; @@6942 196
                 ldy #0                                   ; command 0 ;; @@6945 196
                 stx andmsk                                ;; @@6947 196
                 jsr _setlfs                               ;; @@6949 196
                 jsr paoc20                               ; by-pass junk ;; @@694c 196
                 jsr plsv7                                ; get ',sa' ;; @@694f 196
                 txa                                      ; new command ;; @@6952 196
                 tay                                       ;; @@6953 196
                 ldx andmsk                               ; device # ;; @@6954 196
                 jsr _setlfs                               ;; @@6956 196
                 bra dschk                                ; make dosfa current   [900801] ;; @@6959 196
 ;; @@695b 196
 ;; @@695b 196
 ;; @@695b 196
; Look for comma followed by byte ;; @@695b 196
 ;; @@695b 196
plsv7            jsr paoc30                                ;; @@695b 196
                 +lbra getbyt                              ;; @@695e 196
 ;; @@6961 196
 ;; @@6961 196
 ;; @@6961 196
; Skip return if next char is end ;; @@6961 196
 ;; @@6961 196
paoc20           jsr chrgot                                ;; @@6961 196
                 bne paocx                                 ;; @@6964 196
                 pla                                       ;; @@6966 196
                 pla                                       ;; @@6967 196
paocx            rts                                       ;; @@6968 196
 ;; @@6969 196
 ;; @@6969 196
 ;; @@6969 196
; Check for comma and good stuff ;; @@6969 196
 ;; @@6969 196
paoc30           jsr chkcom                               ; check comma ;; @@6969 196
 ;; @@696c 196
paoc32           jsr chrgot                               ; get current character ;; @@696c 196
                 bne paocx                                ; is okay ;; @@696f 196
                 +lbra snerr                              ; bad...end of line ;; @@6971 196
 ;; @@6974 196
 ;; @@6974 196
; Parse OPEN/CLOSE ;; @@6974 196
 ;; @@6974 196
paoc             lda #sys_bank                            ; ????      [910620] ;; @@6974 196
                 ldx var_bank                             ;  ;; @@6976 196
                 jsr _setbank                             ; filename bank     (string bank)???? ;; @@6978 196
                 jsr _setnam                              ; default file name (null) ;; @@697b 196
                 jsr paoc32                               ; must get something ;; @@697e 196
                 jsr getbyt                               ; get la ;; @@6981 196
                 stx andmsk                                ;; @@6984 196
                 txa                                       ;; @@6986 196
                 ldx _default_drive                       ; default device ;; @@6987 196
                 ldy #0                                   ; default command ;; @@698a 196
                 jsr _setlfs                              ; store it ;; @@698c 196
                 jsr paoc20                               ; skip junk ;; @@698f 196
                 jsr plsv7                                 ;; @@6992 196
                 stx eormsk                                ;; @@6995 196
                 ldy #0                                   ; default sa (command) ;; @@6997 196
                 lda andmsk                               ; get la ;; @@6999 196
                 cpx #3                                    ;; @@699b 196
                 bcc _local_1195_10                        ;; @@699d 196
                 dey                                      ; if sa not given and fa=serial bus, default to $ff ;; @@699f 196
_local_1195_10   jsr _setlfs                              ; store them ;; @@69a0 196
                 jsr paoc20                               ; skip junk ;; @@69a3 196
                 jsr plsv7                                ; get sa ;; @@69a6 196
                 txa                                       ;; @@69a9 196
                 tay                                       ;; @@69aa 196
                 ldx eormsk                                ;; @@69ab 196
                 lda andmsk                                ;; @@69ad 196
                 jsr _setlfs                              ; set up real everything ;; @@69af 196
                 jsr paoc20                                ;; @@69b2 196
                 jsr paoc30                                ;; @@69b5 196
 ;; @@69b8 196
paoc15           jsr frmstr                               ; do frmevl, frestr. return with len in a, index =~string ;; @@69b8 197
                 jsr getspa                               ; ????fixes old PET bug- load"string",val(chr$(56)) [910917] ;; @@69bb 197
; ldx index1 ;; @@69be 197
; ldy index1+1 ;; @@69be 197
                 jsr _setnam                              ; bank always set at plsv ;; @@69be 197
;fall into dschk     [900801] ;; @@69c1 197
 ;; @@69c1 197
 ;; @@69c1 197
 ;; @@69c1 197
dschk            php                                      ; check if current device >=8, and clear DS if so ;; @@69c1 197
                 pha                                       ;; @@69c2 197
                 lda _fa                                   ;; @@69c3 197
                 cmp #1                                    ;; @@69c5 197
                 bne _local_1196_10                        ;; @@69c7 197
                 lda _default_drive                        ;; @@69c9 197
                 sta _fa                                   ;; @@69cc 197
_local_1196_10   cmp #8                                   ; ????     [900807] ;; @@69ce 197
                 bcc _local_1196_20                        ;; @@69d0 197
                 sta dosfa                                ; also make last DOS device = current device ;; @@69d2 197
                 jsr Clear_DS                              ;; @@69d5 197
_local_1196_20   pla                                       ;; @@69d8 197
                 plp                                       ;; @@69d9 197
                 rts                                       ;; @@69da 197
 ;; @@69db 197
; .page ;; @@69db 197
;k_readst ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _readst ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_setlfs ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _setlfs ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_setnam ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _setnam ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_basin ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _basin ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_bsout ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _bsout ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_clrch ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _clrch ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_close ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _close ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_clall ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _clall ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_primm ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _primm ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_setbank ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _setbank ;; @@69db 197
; rts ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_plot ;; @@69db 197
; sta sw_rom_ram0  ;???? ;; @@69db 197
; jmp _plot ;; @@69db 197
 ;; @@69db 197
 ;; @@69db 197
;k_stop ;; @@69db 197
; jsr put_io_in_map ;; @@69db 197
; jmp _stop ;; @@69db 197
 ;; @@69db 197
;.end ;; @@69db 197
; .page ;; @@69db 197
; .subttl  PRINT USING ;; @@69db 197
; Print Using - Formatted print routine ;; @@69db 197
; ;; @@69db 197
; Entered by cmd, print, or print# ;; @@69db 197
; Syntax:  PRINT USING"****";a;b;c ;; @@69db 197
 ;; @@69db 197
pudefs           !text " ,.$"                             ; default:  fill, comma, dec pnt, money symbol ;; @@69db 198
 ;; @@69df 198
using            ldx #$ff                                  ;; @@69df 198
                 stx endfd                                 ;; @@69e1 198
                 jsr chrget                                ;; @@69e4 198
                 jsr frmevl                               ; evaluate format string ;; @@69e7 198
                 jsr chkstr                               ; must be string type... ;; @@69ea 198
 ;; @@69ed 198
                 lda facmo                                ; save temp descriptor ;; @@69ed 198
                 pha                                       ;; @@69ef 198
                 lda facmo+1                               ;; @@69f0 198
                 pha                                       ;; @@69f2 198
 ;; @@69f3 198
                 ldy #2                                   ; move (facmo),1&2 to form,form+1 ;; @@69f3 198
_local_1197_10   jsr indfmo                                ;; @@69f5 198
                 dey                                       ;; @@69f8 198
                 sta form,y                                ;; @@69f9 198
                 bne _local_1197_10                        ;; @@69fc 198
 ;; @@69fe 198
                 jsr indfmo                               ; get length ;; @@69fe 198
                 sta lfor                                  ;; @@6a01 198
                 tay                                       ;; @@6a04 198
                 beq _local_1197_99                       ; syntax error if length is zero ;; @@6a05 198
 ;; @@6a07 198
_local_1197_20   dey                                       ;; @@6a07 198
                 jsr indfrm                                ;; @@6a08 198
                 cmp #'#'                                 ; at least one # in format? ;; @@6a0b 198
                 beq _local_1197_30                       ; yes... ;; @@6a0d 198
                 tya                                      ; no...end of format ;; @@6a0f 198
                 bne _local_1197_20                       ; no... ;; @@6a10 198
_local_1197_99   +lbra snerr                              ; yes...syntax error ;; @@6a12 198
 ;; @@6a15 198
 ;; @@6a15 198
_local_1197_30   lda #';'                                 ; ' ;; @@6a15 198
eex2             jsr synchr                               ; check character ;; @@6a17 199
                 sty z_p_temp_1                           ; clear flag for anaf ;; @@6a1a 199
                 sty bnr                                  ; set pointer to begin of no ;; @@6a1c 199
                 jsr frmevl                               ; evaluate expression ;; @@6a1f 199
                 bbr7 valtyp,conv                         ; branch if numeric ;; @@6a22 199
 ;; @@6a25 199
                 jsr ini                                  ; init counters and flags ;; @@6a25 199
                 jsr anaf                                 ; analyze format ;; @@6a28 199
                 ldx chsn                                 ; > or = in format field ;; @@6a2b 199
                 beq prcha                                ; branch if not ;; @@6a2e 199
                 ldx #0                                    ;; @@6a30 199
                 sec                                       ;; @@6a32 199
                 lda cform                                 ;; @@6a33 199
                 sbc hulp                                 ; .a=room left in field ;; @@6a36 199
                 bcc prcha                                ; branch if no room left ;; @@6a38 199
                 ldx #'='                                  ;; @@6a3a 199
                 cpx chsn                                 ; = in field ;; @@6a3c 199
                 bne _local_1198_50                       ; branch if not ;; @@6a3f 199
                 lsr                                      ; .a=.a/2 ;; @@6a41 199
                 adc #0                                   ; add 1 if odd ;; @@6a42 199
 ;; @@6a44 199
_local_1198_50   tax                                      ; store no of blanks in x ;; @@6a44 199
prcha            ldy #0                                    ;; @@6a45 200
chx              txa                                       ;; @@6a47 200
                 beq cpef                                 ; branch if no blanks ;; @@6a48 200
                 dex                                       ;; @@6a4a 200
 ;; @@6a4b 200
oblk             lda #' '                                 ; output a blank ;; @@6a4b 200
                 bra outc                                 ; always ;; @@6a4d 200
 ;; @@6a4f 200
 ;; @@6a4f 200
cpef             cpy hulp                                 ; end of string reached? ;; @@6a4f 200
                 bcs oblk                                 ; output blank if yes ;; @@6a51 200
                 jsr indin1_ram1                          ; lda (index),y ;; @@6a53 200
                 iny                                       ;; @@6a56 200
 ;; @@6a57 200
outc             jsr cdout                                ; output character ;; @@6a57 200
                 bne chx                                  ; branch if not ready ;; @@6a5a 200
                 bra reay                                  ;; @@6a5c 200
 ;; @@6a5e 200
 ;; @@6a5e 200
 ;; @@6a5e 200
conv             jsr fout                                 ; convert mfp to decimal ;; @@6a5e 200
 ;; @@6a61 200
                 ldy #$ff                                 ; build descriptor for fout string ;; @@6a61 200
_local_1199_10   iny                                      ; how big IS it? ;; @@6a63 200
                 lda fbuffr,y                              ;; @@6a64 200
                 bne _local_1199_10                        ;; @@6a67 200
                 tya                                       ;; @@6a69 200
                 jsr strspa                               ; jsr getspa,stx dsctmp+1,sty dsctmp+2,sta dsctmp,rts ;; @@6a6a 200
 ;; @@6a6d 200
                 phx                                       ;; @@6a6d 200
                 ldy #0                                    ;; @@6a6e 200
                 ldx #dsctmp+1                             ;; @@6a70 200
_local_1199_20   lda fbuffr,y                              ;; @@6a72 200
                 beq _local_1199_30                        ;; @@6a75 200
                 jsr sta_far_ram1                         ; sta (dsctmp+1),y ;; @@6a77 200
                 iny                                       ;; @@6a7a 200
                 bne _local_1199_20                        ;; @@6a7b 200
 ;; @@6a7d 200
_local_1199_30   plx                                       ;; @@6a7d 200
                 jsr putnew                                ;; @@6a7e 200
                 jsr ini                                  ; init counters and flags ;; @@6a81 200
                 jsr fform                                ; output one formatted number ;; @@6a84 200
 ;; @@6a87 200
reay             jsr chrgot                               ; get old character ;; @@6a87 201
                 cmp #','                                 ; comma? ;; @@6a8a 201
                 beq eex2                                 ; continue print use if yes ;; @@6a8c 201
                 sec                                       ;; @@6a8e 201
                 ror z_p_temp_1                           ; set flag for anaf ;; @@6a8f 201
                 jsr anaf                                 ; print rest of format ;; @@6a91 201
                 ply                                      ; restore descriptor ;; @@6a94 201
                 pla                                       ;; @@6a95 201
                 jsr fretmp                                ;; @@6a96 201
                 jsr chrgot                                ;; @@6a99 201
                 cmp #';'                                 ; semi-colon? ;; @@6a9c 201
                 +lbne crdo                               ; end of print using ;; @@6a9e 201
                 jmp chrget                               ; branch if yes ;; @@6aa1 201
 ;; @@6aa4 201
; .page ;; @@6aa4 201
;  FFORM - output a number to format ;; @@6aa4 201
; ;; @@6aa4 201
;  Number is in fbuffr,  format checked by anaf ;; @@6aa4 201
 ;; @@6aa4 201
fform                                                      ;; @@6aa4 201
; sta sw_rom_ram0 ;???? ;; @@6aa4 201
                 lda pufill                                ;; @@6aa4 201
                 sta blfd                                 ; set working fill char ;; @@6aa7 201
                 lda #$ff                                  ;; @@6aaa 201
ana              sta sno                                  ; save blank or '-' in sno ;; @@6aac 201
                 bra insy                                  ;; @@6aaf 201
 ;; @@6ab1 201
 ;; @@6ab1 201
stp              stx point                                ; set point pointer ;; @@6ab1 201
insy             cpy hulp                                 ; end of no reached? ;; @@6ab3 201
                 beq eoa                                  ; branch if yes ;; @@6ab5 201
                 lda fbuffr,y                             ; get character of no ;; @@6ab7 201
                 iny                                       ;; @@6aba 201
                 cmp #' '                                 ; blank? ;; @@6abb 201
                 beq insy                                 ; yes...span ;; @@6abd 201
                 cmp #'-'                                 ; sign no negative ;; @@6abf 201
                 beq ana                                  ; yes... ;; @@6ac1 201
                 cmp #'.'                                 ; decimal point? ;; @@6ac3 201
                 beq stp                                  ; yes... ;; @@6ac5 201
                 cmp #'E'                                 ; is char 'e'? ;; @@6ac7 201
                 beq lsg                                  ; yes... ;; @@6ac9 201
                 sta fbuffr,x                             ; move number ;; @@6acb 201
                 stx enr                                  ; update end-no pointer ;; @@6ace 201
                 inx                                       ;; @@6ad1 201
                 bit point                                ; point pointer set? ;; @@6ad2 201
                 bpl insy                                 ; yes... ;; @@6ad4 201
                 inc vn                                   ; count digits before point ;; @@6ad6 201
                 bra insy                                  ;; @@6ad9 201
 ;; @@6adb 201
 ;; @@6adb 201
lsg              lda fbuffr,y                              ;; @@6adb 201
                 cmp #'-'                                 ; sign of exponent negative ;; @@6ade 201
                 bne _local_1200_10                       ; no... ;; @@6ae0 201
                 ror usgn                                 ; make sign negative ;; @@6ae2 201
_local_1200_10   iny                                       ;; @@6ae5 201
                 sty uexp                                 ; set exponent pointer ;; @@6ae6 201
 ;; @@6ae9 201
eoa              lda point                                ; decimal found? ;; @@6ae9 202
                 bpl _local_1201_20                       ; yes... ;; @@6aeb 202
                 stx point                                ; no...add point ;; @@6aed 202
 ;; @@6aef 202
_local_1201_20   jsr anaf                                 ; analyze format ;; @@6aef 202
                 lda vf                                    ;; @@6af2 202
                 cmp #$ff                                  ;; @@6af5 202
                 beq _local_1201_40                       ; field overflow ;; @@6af7 202
                 lda fesp                                 ; exponent in field ;; @@6af9 202
                 beq cff                                  ; convert to f format if not ;; @@6afc 202
                 lda uexp                                 ; exponent in number? ;; @@6afe 202
                 bne _local_1201_30                       ; yes... ;; @@6b01 202
                 ldx enr                                   ;; @@6b03 202
                 jsr et2                                  ; add exponent to number ;; @@6b06 202
                 dec fbuffr+2,x                            ;; @@6b09 202
                 inx                                       ;; @@6b0c 202
                 stx uexp                                  ;; @@6b0d 202
                 jsr alg                                  ; delete leading zeros ;; @@6b10 202
                 beq hup                                  ; all zero ;; @@6b13 202
 ;; @@6b15 202
_local_1201_30   ldy posp                                 ; + or - in format? ;; @@6b15 202
                 bne sswe                                 ; yes... ;; @@6b18 202
                 ldy sno                                  ; +? ;; @@6b1a 202
                 bmi sswe                                 ; yes... ;; @@6b1d 202
                 lda vf                                    ;; @@6b1f 202
 ;; @@6b22 202
_local_1201_40   beq errf                                 ; no room for sign ;; @@6b22 202
                 dec vf                                   ; reserve room ;; @@6b24 202
                 bne _local_1201_50                        ;; @@6b27 202
                 lda nf                                   ; one #? ;; @@6b29 202
                 beq errf                                 ; yes...error ;; @@6b2c 202
 ;; @@6b2e 202
_local_1201_50   inc swe                                   ;; @@6b2e 202
 ;; @@6b31 202
sswe             jsr shpn                                 ; shift decimal point ;; @@6b31 203
                 jsr uround                               ; round number ;; @@6b34 203
                 jsr shpn                                 ; shift again if necessary ;; @@6b37 203
 ;; @@6b3a 203
hup              +lbra chout                              ; output number ;; @@6b3a 203
 ;; @@6b3d 203
 ;; @@6b3d 203
 ;; @@6b3d 203
cff              ldy uexp                                 ; exponent in no? ;; @@6b3d 203
                 beq _local_1202_20                       ; no... ;; @@6b40 203
                 sta hulp                                 ; delete exponent ;; @@6b42 203
                 sec                                      ; adjust decimal point ;; @@6b44 203
                 ror etof                                 ; set e-to-f flag ;; @@6b45 203
                 ldy point                                 ;; @@6b48 203
                 lda usgn                                 ; exec nos3 or nos4 ;; @@6b4a 203
                 bpl _local_1202_10                       ; depends on sign of exp ;; @@6b4d 203
                 jsr nos3                                  ;; @@6b4f 203
                 bra _local_1202_30                        ;; @@6b52 203
 ;; @@6b54 203
_local_1202_10   jsr nos4                                  ;; @@6b54 203
 ;; @@6b57 203
_local_1202_20   ldy point                                ; at start of no? ;; @@6b57 203
                 beq _local_1202_30                       ; yes... ;; @@6b59 203
                 jsr cho                                  ; no = 0 ? ;; @@6b5b 203
                 beq _local_1202_40                       ; yes...no round ;; @@6b5e 203
 ;; @@6b60 203
_local_1202_30   jsr uround                                ;; @@6b60 203
                 bra _local_1202_50                        ;; @@6b63 203
 ;; @@6b65 203
_local_1202_40   dec vn                                   ; adjust...no was 0 ;; @@6b65 203
_local_1202_50   sec                                       ;; @@6b68 203
                 lda vf                                    ;; @@6b69 203
                 sbc vn                                    ;; @@6b6c 203
                 bcc errf                                 ; no fit...error ;; @@6b6f 203
                 sta swe                                  ; save difference ;; @@6b71 203
                 ldy posp                                 ; + or -? ;; @@6b74 203
                 bne ahp                                  ; yes... ;; @@6b77 203
                 ldy sno                                  ; get sign ;; @@6b79 203
                 bmi ahp                                  ; positive... ;; @@6b7c 203
                 tay                                       ;; @@6b7e 203
                 beq errf                                 ; no room for sign ;; @@6b7f 203
                 dey                                       ;; @@6b81 203
                 bne ldvn                                 ; swe<>1 ;; @@6b82 203
                 lda nf                                    ;; @@6b84 203
                 ora vn                                   ; both zero? ;; @@6b87 203
                 bne hup                                  ; no... ;; @@6b8a 203
 ;; @@6b8c 203
 ;; @@6b8c 203
errf             lda #'*'                                 ; format error ;; @@6b8c 204
stout            jsr cdout                                ; fill field with stars ;; @@6b8e 204
                 bne stout                                 ;; @@6b91 204
                 rts                                       ;; @@6b93 204
 ;; @@6b94 204
 ;; @@6b94 204
ahp              tay                                      ; output no if swe=0 ;; @@6b94 204
                 beq hup                                   ;; @@6b95 204
ldvn             lda vn                                    ;; @@6b97 204
                 bne hup                                  ; vn<>0 ;; @@6b9a 204
                 dec swe                                  ; add extra 0 ;; @@6b9c 204
                 inc z_p_temp_1                           ; before decimal point ;; @@6b9f 204
                 bra hup                                   ;; @@6ba1 204
 ;; @@6ba3 204
; .page ;; @@6ba3 204
; Using- shift decimal point ;; @@6ba3 204
 ;; @@6ba3 204
shpn             sec                                       ;; @@6ba3 204
                 lda vf                                    ;; @@6ba4 204
                 sbc vn                                    ;; @@6ba7 204
                 beq rdy                                  ; format o.k ;; @@6baa 204
                 ldy point                                 ;; @@6bac 204
                 bcc pntl                                 ; vf<vn ;; @@6bae 204
                 sta hulp                                  ;; @@6bb0 204
 ;; @@6bb2 204
incy             cpy enr                                  ; end of no reached? ;; @@6bb2 204
                 beq ity                                   ;; @@6bb5 204
                 bcs nos1                                 ; yes... ;; @@6bb7 204
 ;; @@6bb9 204
ity              iny                                       ;; @@6bb9 204
nos1             inc vn                                    ;; @@6bba 204
nos4             jsr eado                                 ; adjust exponent ;; @@6bbd 204
                 dec hulp                                 ; ready? ;; @@6bc0 204
                 bne incy                                 ; no... ;; @@6bc2 204
                 beq poit                                  ;; @@6bc4 204
 ;; @@6bc6 204
pntl             eor #$ff                                  ;; @@6bc6 204
                 adc #1                                    ;; @@6bc8 204
                 sta hulp                                 ; =vn-vf ;; @@6bca 204
 ;; @@6bcc 204
decy             cpy bnr                                  ; begin of no? ;; @@6bcc 204
                 beq inz1                                 ; yes... ;; @@6bcf 204
                 dey                                       ;; @@6bd1 204
                 dec vn                                    ;; @@6bd2 204
                 bra inz2                                  ;; @@6bd5 204
 ;; @@6bd7 204
 ;; @@6bd7 204
inz1             inc z_p_temp_1                           ; add leading zeros ;; @@6bd7 204
inz2             lda #$80                                  ;; @@6bd9 204
nos3             jsr eadj                                 ; adjust exponent ;; @@6bdb 204
                 dec hulp                                 ; ready? ;; @@6bde 204
                 bne decy                                 ; no... ;; @@6be0 204
 ;; @@6be2 204
poit             sty point                                ; decimal point pointer ;; @@6be2 204
rdy              rts                                       ;; @@6be4 204
 ;; @@6be5 204
; .page ;; @@6be5 204
; Using- adjust exponent ;; @@6be5 204
 ;; @@6be5 204
sexp             bne retrn                                ; no over/underflow ;; @@6be5 204
                 eor #$09                                 ; .a is 0 or 9 ;; @@6be7 204
                 sta fbuffr,x                             ; digit back in exp ;; @@6be9 204
                 dex                                      ; = 0 or 9 ;; @@6bec 204
                 cpx uexp                                  ;; @@6bed 204
                 rts                                       ;; @@6bf0 204
 ;; @@6bf1 204
 ;; @@6bf1 204
eado             lda #0                                    ;; @@6bf1 204
eadj             ldx uexp                                  ;; @@6bf3 204
                 inx                                       ;; @@6bf6 204
                 bit etof                                 ; e-to-f flag on? ;; @@6bf7 204
                 bmi _local_1203_20                       ; yes... ;; @@6bfa 204
                 eor usgn                                  ;; @@6bfc 204
                 beq _local_1203_20                       ; ++ or -- ;; @@6bff 204
 ;; @@6c01 204
_local_1203_10   jsr tag3                                 ; inc exp, overflow? ;; @@6c01 204
                 jsr sexp                                 ; digit 0 if yes ;; @@6c04 204
                 bcs _local_1203_10                       ; try second digit ;; @@6c07 204
                 +lbra overr                              ; exp>99 ;; @@6c09 204
 ;; @@6c0c 204
_local_1203_20   lda fbuffr,x                              ;; @@6c0c 204
                 dec fbuffr,x                             ; decrement exp ;; @@6c0f 204
                 cmp #'0'                                 ; underflow on digit? ;; @@6c12 204
                 jsr sexp                                 ; set digit=9 if yes... ;; @@6c14 204
                 bcs _local_1203_20                       ; try 2nd digit ;; @@6c17 204
                 bit etof                                 ; flag off? ;; @@6c19 204
                 bpl et3                                  ; yes... ;; @@6c1c 204
                 sty point                                ; decimal point pointer ;; @@6c1e 204
 ;; @@6c20 204
retrn            pla                                       ;; @@6c20 205
                 pla                                       ;; @@6c21 205
                 rts                                      ; return to fform/main ;; @@6c22 205
 ;; @@6c23 205
 ;; @@6c23 205
et3              lda usgn                                  ;; @@6c23 205
                 eor #$80                                 ; reverse sign exp ;; @@6c26 205
et2              sta usgn                                  ;; @@6c28 205
                 lda #'0'                                  ;; @@6c2b 205
                 sta fbuffr+1,x                           ; exp<0 here ;; @@6c2d 205
                 lda #'1'                                  ;; @@6c30 205
                 sta fbuffr+2,x                            ;; @@6c32 205
                 rts                                       ;; @@6c35 205
 ;; @@6c36 205
 ;; @@6c36 205
tag3             lda fbuffr,x                             ; get digit of exp ;; @@6c36 205
                 inc fbuffr,x                             ; increment digit ;; @@6c39 205
                 cmp #'9'                                 ; overflow ;; @@6c3c 205
                 rts                                      ; return .z set ;; @@6c3e 205
 ;; @@6c3f 205
; .page ;; @@6c3f 205
; Using- ansub: load format field char in .a ;; @@6c3f 205
 ;; @@6c3f 205
ansub            clc                                       ;; @@6c3f 205
                 iny                                      ; begin format? ;; @@6c40 205
                 beq _local_1204_10                       ; yes... ;; @@6c41 205
                 cpy lfor                                 ; end? ;; @@6c43 205
                 bcc _local_1204_20                       ; no... ;; @@6c46 205
 ;; @@6c48 205
_local_1204_10   ldy z_p_temp_1                           ; <>0? ;; @@6c48 205
                 bne retrn                                ; yes... ;; @@6c4a 205
 ;; @@6c4c 205
_local_1204_20   jsr indfrm                                ;; @@6c4c 205
                 inc cform                                ; pointer to field ;; @@6c4f 205
                 rts                                       ;; @@6c52 205
 ;; @@6c53 205
 ;; @@6c53 205
;  Using- ini: init counters and flags ;; @@6c53 205
 ;; @@6c53 205
ini              jsr frefac                               ; free temp descriptor ;; @@6c53 206
                 sta hulp                                 ; length string ;; @@6c56 206
                 ldx #$0a                                 ; printed in hulp ;; @@6c58 206
                 lda #0                                    ;; @@6c5a 206
 ;; @@6c5c 206
_local_1205_10   sta swe,x                                ; init working registers ;; @@6c5c 206
                 dex                                       ;; @@6c5f 206
                 bpl _local_1205_10                        ;; @@6c60 206
                 stx flag                                 ; comma flag =ff ;; @@6c62 206
                 stx point                                ; point pointer=ff ;; @@6c65 206
                 stx dolr                                 ; dollar flag=ff ;; @@6c67 206
                 tax                                      ; x=y=0 ;; @@6c6a 206
                 tay                                       ;; @@6c6b 206
                 rts                                       ;; @@6c6c 206
 ;; @@6c6d 206
; .page ;; @@6c6d 206
; Using- round number ;; @@6c6d 206
 ;; @@6c6d 206
uround           clc                                       ;; @@6c6d 207
                 lda point                                 ;; @@6c6e 207
                 adc nf                                   ; overflow? ;; @@6c70 207
                 bcs rrts                                 ; yes... ;; @@6c73 207
                 sec                                       ;; @@6c75 207
                 sbc z_p_temp_1                           ; underflow? ;; @@6c76 207
                 bcc rrts                                 ; yes... ;; @@6c78 207
                 cmp enr                                  ; anything to round? ;; @@6c7a 207
                 beq _local_1206_10                       ; yes... ;; @@6c7d 207
                 bcs rrts                                 ; no... ;; @@6c7f 207
 ;; @@6c81 207
_local_1206_10   cmp bnr                                  ; again... ;; @@6c81 207
                 bcc rrts                                 ; no... ;; @@6c84 207
                 tax                                       ;; @@6c86 207
                 lda fbuffr,x                             ; get digit ;; @@6c87 207
                 cmp #'5'                                 ; <5 ? ;; @@6c8a 207
                 bcc rrts                                 ; yes...no round ;; @@6c8c 207
 ;; @@6c8e 207
_local_1206_20   cpx bnr                                  ; begin of no reached? ;; @@6c8e 207
                 beq _local_1206_30                       ; yes..add 1 ;; @@6c91 207
                 dex                                       ;; @@6c93 207
                 jsr tag3                                 ; increment digit ;; @@6c94 207
                 stx enr                                  ; new end of no pointer ;; @@6c97 207
                 beq _local_1206_20                       ; branch on overflow ;; @@6c9a 207
                 rts                                       ;; @@6c9c 207
 ;; @@6c9d 207
_local_1206_30   lda #'1'                                  ;; @@6c9d 207
                 sta fbuffr,x                              ;; @@6c9f 207
                 inx                                       ;; @@6ca2 207
                 stx point                                 ;; @@6ca3 207
                 dec z_p_temp_1                           ; # of 0's before '.' ;; @@6ca5 207
                 bpl rrts                                 ; no underflow ;; @@6ca7 207
                 inc z_p_temp_1                           ; underflow...back to 0 ;; @@6ca9 207
                 inc vn                                    ;; @@6cab 207
rrts             rts                                       ;; @@6cae 208
 ;; @@6caf 208
; .page ;; @@6caf 208
; Using- alg: delete leading zeros of no ;; @@6caf 208
 ;; @@6caf 208
alg              ldy point                                ; start with a .? ;; @@6caf 208
                 beq szer                                 ; yes... ;; @@6cb1 208
 ;; @@6cb3 208
cho              ldy bnr                                   ;; @@6cb3 208
cmo              lda fbuffr,y                             ; start with a 0? ;; @@6cb6 208
                 cmp #'0'                                  ;; @@6cb9 208
                 rts                                       ;; @@6cbb 208
 ;; @@6cbc 208
 ;; @@6cbc 208
nbr              inc point                                ; adjust point ;; @@6cbc 208
                 jsr eado                                 ; and exponent ;; @@6cbe 208
                 inc bnr                                  ; and pointer to begin of no ;; @@6cc1 208
                 cpy enr                                  ; end of number? ;; @@6cc4 208
                 beq rrts                                 ; yes... ;; @@6cc7 208
                 iny                                       ;; @@6cc9 208
 ;; @@6cca 208
szer             jsr cmo                                  ; zero in no? ;; @@6cca 208
                 beq nbr                                  ; yes... ;; @@6ccd 208
                 rts                                      ; no... ;; @@6ccf 208
 ;; @@6cd0 208
 ;; @@6cd0 208
; Using- chout: print number ;; @@6cd0 208
 ;; @@6cd0 208
chout            lda dolr                                 ; dollar flag set? ;; @@6cd0 208
                 bmi _local_1207_10                       ; no... ;; @@6cd3 208
                 inc z_p_temp_1                           ; make room for $ ;; @@6cd5 208
 ;; @@6cd7 208
_local_1207_10   ldx bnr                                  ; start of # ;; @@6cd7 208
                 dex                                       ;; @@6cda 208
                 ldy begfd                                ; begin of field ;; @@6cdb 208
 ;; @@6cde 208
afrm             jsr indfrm                                ;; @@6cde 209
                 iny                                       ;; @@6ce1 209
                 cmp #','                                 ; comma? ;; @@6ce2 209
                 bne punt                                 ; no... ;; @@6ce4 209
                 bit flag                                 ; comma flag on? ;; @@6ce6 209
                 bmi bout                                 ; yes, do a fill char ;; @@6ce9 209
; sta sw_rom_ram0 ;???? ;; @@6ceb 209
                 lda pucoma                                ;; @@6ceb 209
                 bra out                                  ; no,...output a comma char ;; @@6cee 209
 ;; @@6cf0 209
 ;; @@6cf0 209
bout             lda blfd                                  ;; @@6cf0 209
                 bra out                                   ;; @@6cf3 209
 ;; @@6cf5 209
 ;; @@6cf5 209
punt             cmp #'.'                                 ; decimal point? ;; @@6cf5 209
                 bne afplus                                ;; @@6cf7 209
; sta sw_rom_ram0 ;???? ;; @@6cf9 209
                 lda pudot                                ; yes... ;; @@6cf9 209
                 bra out                                   ;; @@6cfc 209
 ;; @@6cfe 209
 ;; @@6cfe 209
afplus           cmp #'+'                                 ; plus? ;; @@6cfe 209
                 beq ispl                                 ; yes... ;; @@6d00 209
                 cmp #'-'                                 ; minus? ;; @@6d02 209
                 beq ispl1                                ; yes... ;; @@6d04 209
                 cmp #'^'                                 ; up arrow? ;; @@6d06 209
                 bne pndd                                 ; no... ;; @@6d08 209
                 lda #'E'                                  ;; @@6d0a 209
                 jsr cdout                                 ;; @@6d0c 209
                 ldy uexp                                  ;; @@6d0f 209
                 jsr cmo                                  ; first dig of exp zero? ;; @@6d12 209
                 bne _local_1208_10                       ; no... ;; @@6d15 209
                 iny                                       ;; @@6d17 209
                 jsr cmo                                  ; second digit? ;; @@6d18 209
                 beq _local_1208_20                       ; yes ;; @@6d1b 209
 ;; @@6d1d 209
_local_1208_10   lda #'-'                                  ;; @@6d1d 209
                 bit usgn                                  ;; @@6d1f 209
                 bmi _local_1208_30                        ;; @@6d22 209
 ;; @@6d24 209
_local_1208_20   lda #'+'                                  ;; @@6d24 209
_local_1208_30   jsr cdout                                ; output sign exp ;; @@6d26 209
                 ldx uexp                                  ;; @@6d29 209
                 lda fbuffr,x                              ;; @@6d2c 209
                 jsr cdout                                ; output first dig exp ;; @@6d2f 209
                 ldy endfd                                 ;; @@6d32 209
                 bra telx                                  ;; @@6d35 209
 ;; @@6d37 209
ispl1            lda sno                                  ; positive? ;; @@6d37 210
                 bmi bout                                 ; yes...out blank or * ;; @@6d3a 210
ispl             lda sno                                  ; output sgn ;; @@6d3c 210
                 bra out                                   ;; @@6d3f 210
 ;; @@6d41 210
 ;; @@6d41 210
zerot            lda z_p_temp_1                           ; # of zeros ;; @@6d41 210
                 bne zerot1                                ;; @@6d43 210
                 cpx enr                                  ; end of # reached? ;; @@6d45 210
                 beq zout                                 ; yes...output zero ;; @@6d48 210
 ;; @@6d4a 210
telx             inx                                       ;; @@6d4a 210
                 lda fbuffr,x                             ; get digit ;; @@6d4b 210
                 !text $2c                                ; skip ;; @@6d4e 210
 ;; @@6d4f 210
zout             lda #'0'                                 ; output zero ;; @@6d4f 210
 ;; @@6d51 210
outs             lsr flag                                 ; clear comma flag ;; @@6d51 210
 ;; @@6d54 210
out              jsr cdout                                ; output character ;; @@6d54 210
                 +lbeq rrts                                ;; @@6d57 210
                 bra afrm                                 ; not ready... ;; @@6d5a 210
 ;; @@6d5c 210
 ;; @@6d5c 210
zerot1           dec z_p_temp_1                           ; count leading zeros ;; @@6d5c 210
                 lda dolr                                 ; $ flag set? ;; @@6d5e 210
                 bmi zout                                 ; no...output zero ;; @@6d61 210
 ;; @@6d63 210
                 jsr indfrm                               ; take a peek at the next character in the format string ;; @@6d63 210
                 cmp #','                                 ; if it's a comma, we got problems ;; @@6d66 210
                 bne _local_1209_10                       ; ...branch if no comma & resume normal processing ;; @@6d68 210
 ;; @@6d6a 210
                 lda blfd                                 ; here's the "$,999.99" bug fix: ;; @@6d6a 210
                 jsr cdout                                ; print a 'fill' character instead of the '$' ;; @@6d6d 210
                 iny                                      ; and increment format string pointer past comma ;; @@6d70 210
 ;; @@6d71 210
_local_1209_10   sec                                      ; resume normal processing ;; @@6d71 210
                 ror dolr                                 ; clear the dollar flag & go on to print '$' ;; @@6d72 210
; sta sw_rom_ram0 ;???? ;; @@6d75 210
                 lda pumony                                ;; @@6d75 210
                 bra outs                                 ; output money symbol ;; @@6d78 210
 ;; @@6d7a 210
 ;; @@6d7a 210
pndd             lda swe                                  ; # of blanks ;; @@6d7a 211
                 beq zerot                                 ;; @@6d7d 211
                 dec swe                                  ; count ! ;; @@6d7f 211
 ;; @@6d82 211
_local_1210_5    +lbne bout                               ; out blank or * ;; @@6d82 211
                 lda posp                                 ; + or - in field? ;; @@6d85 211
                 bmi _local_1210_5                        ; yes...out blank or * ;; @@6d88 211
 ;; @@6d8a 211
_local_1210_10   jsr indfrm                                ;; @@6d8a 211
                 cmp #','                                 ; comma? ;; @@6d8d 211
                 bne ispl1                                ; no...out sign ;; @@6d8f 211
                 lda blfd                                 ; yes... ;; @@6d91 211
                 jsr cdout                                ; out blank or * ;; @@6d94 211
                 iny                                       ;; @@6d97 211
                 bra _local_1210_10                        ;; @@6d98 211
 ;; @@6d9a 211
 ;; @@6d9a 211
 ;; @@6d9a 211
cdout            jsr outch ;outdo                         ; char out ;; @@6d9a 212
                 dec cform                                ; count it ;; @@6d9d 212
                 rts                                       ;; @@6da0 212
 ;; @@6da1 212
; .page ;; @@6da1 212
; Using- anaf: analyze format ;; @@6da1 212
 ;; @@6da1 212
anaf             ldy endfd                                ; format pointer ;; @@6da1 212
gfor             jsr ansub                                 ;; @@6da4 212
                 jsr comp                                 ; check special chars ;; @@6da7 212
                 bne pchar                                ; no match... ;; @@6daa 212
                 sty begfd                                ; save beginning of field ;; @@6dac 212
                 bcc ffoun                                ; # was found ;; @@6daf 212
                 tax                                      ; save char ;; @@6db1 212
 ;; @@6db2 212
sfur             jsr ansub                                ; get next format char ;; @@6db2 212
                 bcs _local_1211_10                       ; stop on wrap-around ;; @@6db5 212
                 jsr com1                                 ; compare specials ;; @@6db7 212
                 beq foun1                                ; found some... ;; @@6dba 212
 ;; @@6dbc 212
_local_1211_10   ldy begfd                                 ;; @@6dbc 212
                 txa                                       ;; @@6dbf 212
pchar            jsr outch ;outdo                         ; out character ;; @@6dc0 213
                 bra gfor                                  ;; @@6dc3 213
 ;; @@6dc5 213
 ;; @@6dc5 213
foun1            bcs sfur                                 ; no #...keep looking ;; @@6dc5 213
                 ldy begfd                                 ;; @@6dc7 213
ffoun            ldx z_p_temp_1                            ;; @@6dca 213
                 bne trts                                  ;; @@6dcc 213
                 stx cform                                 ;; @@6dce 213
                 dey                                       ;; @@6dd1 213
 ;; @@6dd2 213
hyo2             dec cform                                ; correct counter ;; @@6dd2 213
hyo              jsr ansub                                ; get next format char ;; @@6dd5 213
                 bcs efo                                  ; end of format ;; @@6dd8 213
                 cmp #','                                 ; comma? ;; @@6dda 213
                 beq hyo                                  ; yes...ignore it ;; @@6ddc 213
                 jsr isp                                  ; + or - in format? ;; @@6dde 213
                 bcc hyo2                                 ; yes... ;; @@6de1 213
                 cmp #'.'                                 ; decimal point? ;; @@6de3 213
                 bne avf1                                 ; no... ;; @@6de5 213
                 inx                                       ;; @@6de7 213
                 cpx #2                                   ; more than 1 decimal? ;; @@6de8 213
                 bcc hyo                                  ; no... ;; @@6dea 213
ero              +lbra snerr                              ; yes...syntax error ;; @@6dec 213
 ;; @@6def 213
 ;; @@6def 213
avf1             jsr com2                                 ; =, >, or # in field ;; @@6def 213
                 bne llar                                 ; no... ;; @@6df2 213
                 bcc hyo1                                 ; was # ;; @@6df4 213
                 sta chsn                                 ; was > or = ;; @@6df6 213
 ;; @@6df9 213
hyo1             inc vf,x                                  ;; @@6df9 213
                 bra hyo                                   ;; @@6dfc 213
 ;; @@6dfe 213
llar             cmp #'$'                                 ; dollar? ;; @@6dfe 213
                 bne expo                                 ; no... ;; @@6e00 213
                 bit dolr                                 ; test flag ;; @@6e02 213
                 bpl hyo1                                 ; no... ;; @@6e05 213
                 clc                                       ;; @@6e07 213
                 ror dolr                                 ; set flag ;; @@6e08 213
                 dec vf                                    ;; @@6e0b 213
                 bra hyo1                                  ;; @@6e0e 213
 ;; @@6e10 213
expo             cmp #'^'                                 ; up arrow? ;; @@6e10 213
                 bne isp                                  ; no... ;; @@6e12 213
                 ldx #$02                                  ;; @@6e14 213
_local_1212_10   jsr ansub                                ; must be 4 up arrows ;; @@6e16 213
                 bcs ero                                   ;; @@6e19 213
                 cmp #'^'                                 ; up arrow? ;; @@6e1b 213
                 bne ero                                   ;; @@6e1d 213
                 dex                                       ;; @@6e1f 213
                 bpl _local_1212_10                        ;; @@6e20 213
                 inc fesp                                 ; set exp flag ;; @@6e22 213
                 jsr ansub                                ; next format char ;; @@6e25 213
                 bcs efo                                  ; end of format ;; @@6e28 213
 ;; @@6e2a 213
isp              cmp #'+'                                 ; plus? ;; @@6e2a 214
                 bne chom                                 ; no... ;; @@6e2c 214
                 lda sno                                  ; sign neg? ;; @@6e2e 214
                 bpl spos                                 ; yes... ;; @@6e31 214
                 lda #'+'                                  ;; @@6e33 214
                 sta sno                                   ;; @@6e35 214
 ;; @@6e38 214
spos             lda posp                                 ; + or - already? ;; @@6e38 214
                 bne ero                                   ;; @@6e3b 214
                 ror posp                                 ; make posp neg/clc ;; @@6e3d 214
                 sty endfd                                ; end field pointer ;; @@6e40 214
                 inc cform                                ; correct counter ;; @@6e43 214
trts             rts                                       ;; @@6e46 214
 ;; @@6e47 214
 ;; @@6e47 214
chom             cmp #'-'                                 ; minus? ;; @@6e47 214
                 beq spos                                 ; yes... ;; @@6e49 214
                 sec                                       ;; @@6e4b 214
efo              sty endfd                                ; end field pointer ;; @@6e4c 214
                 dec endfd                                 ;; @@6e4f 214
                 rts                                       ;; @@6e52 214
 ;; @@6e53 214
 ;; @@6e53 214
; Using- comp: compare .a with symbols ;; @@6e53 214
 ;; @@6e53 214
comp             cmp #'+'                                  ;; @@6e53 214
                 beq rt                                    ;; @@6e55 214
                 cmp #'-'                                  ;; @@6e57 214
                 beq rt                                    ;; @@6e59 214
 ;; @@6e5b 214
com1             cmp #'.'                                  ;; @@6e5b 214
                 beq rt                                    ;; @@6e5d 214
 ;; @@6e5f 214
com2             cmp #'='                                  ;; @@6e5f 214
                 beq rt                                    ;; @@6e61 214
                 cmp #'>'                                  ;; @@6e63 214
                 beq rt                                    ;; @@6e65 214
                 cmp #'#'                                  ;; @@6e67 214
                 bne rt                                    ;; @@6e69 214
                 clc                                       ;; @@6e6b 214
rt               rts                                       ;; @@6e6c 214
 ;; @@6e6d 214
;.end ;; @@6e6d 214
; .page ;; @@6e6d 214
; .subttl  INSTR() ;; @@6e6d 214
 ;; @@6e6d 214
;  INSTRing - Find position of str1 in str2 at or after position n ;; @@6e6d 214
; ;; @@6e6d 214
; Usage: INSTR(a$,b${,n}) ;; @@6e6d 214
 ;; @@6e6d 214
instr            lda facmo                                ; save pointer to temporary descriptors ;; @@6e6d 214
                 sta tmpdes                                ;; @@6e6f 214
                 lda facmo+1                               ;; @@6e72 214
                 sta tmpdes+1                              ;; @@6e74 214
 ;; @@6e77 214
                 jsr frmevl                               ; get next arg ;; @@6e77 214
                 jsr chkstr                               ; must be string ;; @@6e7a 214
                 lda facmo                                 ;; @@6e7d 214
                 sta tmpdes+2                              ;; @@6e7f 214
                 lda facmo+1                               ;; @@6e82 214
                 sta tmpdes+3                              ;; @@6e84 214
 ;; @@6e87 214
                 ldx #1                                   ; default starting position ;; @@6e87 214
                 stx faclo                                 ;; @@6e89 214
                 jsr chrgot                                ;; @@6e8b 214
                 cmp #')'                                 ; any length argument? ;; @@6e8e 214
                 beq _local_1213_1                        ; branch if not ;; @@6e90 214
                 jsr combyt                               ; else go get a one byte argument ;; @@6e92 214
 ;; @@6e95 214
_local_1213_1    jsr chkcls                               ; look for ) ;; @@6e95 214
                 ldx faclo                                 ;; @@6e98 214
                 +lbeq fcerr                              ; starting position can't be 0 ;; @@6e9a 214
                 dex                                       ;; @@6e9d 214
                 stx positn                                ;; @@6e9e 214
 ;; @@6ea0 214
                 ldx #3                                   ; copy 'pointers to temp descriptors' to zero page ;; @@6ea0 214
_local_1213_3    lda tmpdes,x                              ;; @@6ea2 214
                 sta ptarg1,x                              ;; @@6ea5 214
                 dex                                       ;; @@6ea7 214
                 bpl _local_1213_3                         ;; @@6ea8 214
 ;; @@6eaa 214
                 ldy #2                                   ; now get the descriptors ;; @@6eaa 214
_local_1213_4    lda #ptarg1                               ;; @@6eac 214
                 jsr lda_far_ram1                         ; lda (ptarg1),y ;; @@6eae 214
                 sta str1,y                                ;; @@6eb1 214
                 lda #ptarg2                               ;; @@6eb4 214
                 jsr lda_far_ram1                         ; lda (ptarg2),y ;; @@6eb6 214
                 sta str2,y                                ;; @@6eb9 214
                 dey                                       ;; @@6ebc 214
                 bpl _local_1213_4                         ;; @@6ebd 214
 ;; @@6ebf 214
                 lda str2                                 ; check if string 2 is null ;; @@6ebf 214
                 beq _local_1213_50                       ; if so, return 0 ;; @@6ec1 214
 ;; @@6ec3 214
_local_1213_10   lda #0                                    ;; @@6ec3 214
                 sta match                                 ;; @@6ec5 214
                 clc                                       ;; @@6ec7 214
                 lda str2                                 ; length of string 2 ;; @@6ec8 214
                 adc positn                                ;; @@6eca 214
                 bcs _local_1213_50                       ; too long, not found ;; @@6ecc 214
                 cmp str1                                 ; see if > length of string 1 ;; @@6ece 214
                 bcc _local_1213_20                       ; < len string 1 ;; @@6ed0 214
                 bne _local_1213_50                       ; must be >, not found ;; @@6ed2 214
 ;; @@6ed4 214
_local_1213_20   ldy match                                 ;; @@6ed4 214
                 cpy str2                                 ; if match len = str len, then found ;; @@6ed6 214
                 beq _local_1213_40                        ;; @@6ed8 214
                 tya                                       ;; @@6eda 214
                 clc                                       ;; @@6edb 214
                 adc positn                               ; compare str1(s+p+m) with str2(m) ;; @@6edc 214
                 tay                                       ;; @@6ede 214
                 lda #str1+1                               ;; @@6edf 214
                 jsr lda_far_ram1                         ; lda (str1+1),y ;; @@6ee1 214
                 sta syntmp                                ;; @@6ee4 214
                 ldy match                                 ;; @@6ee6 214
                 lda #str2+1                               ;; @@6ee8 214
                 jsr lda_far_ram1                         ; lda (str2+1),y ;; @@6eea 214
                 cmp syntmp                                ;; @@6eed 214
                 beq _local_1213_30                        ;; @@6eef 214
                 inc positn                               ; not the same, start over from next positn ;; @@6ef1 214
                 bra _local_1213_10                       ; always ;; @@6ef3 214
 ;; @@6ef5 214
_local_1213_30   inc match                                ; count characters that match ;; @@6ef5 214
                 bra _local_1213_20                       ; always ;; @@6ef7 214
 ;; @@6ef9 214
 ;; @@6ef9 214
_local_1213_40   inc positn                               ; found ;; @@6ef9 214
                 lda positn                                ;; @@6efb 214
                 !text $2c                                 ;; @@6efd 214
 ;; @@6efe 214
_local_1213_50   lda #0                                   ; not found ;; @@6efe 214
; sta sw_rom_ram0 ;???? ;; @@6f00 214
                 pha                                       ;; @@6f00 214
                 lda tmpdes+2                             ; free temp descriptors ;; @@6f01 214
                 ldy tmpdes+3                              ;; @@6f04 214
                 jsr fretmp                                ;; @@6f07 214
; sta sw_rom_ram0 ;???? ;; @@6f0a 214
                 lda tmpdes                                ;; @@6f0a 214
                 ldy tmpdes+1                              ;; @@6f0d 214
                 jsr fretmp                                ;; @@6f10 214
                 ply                                       ;; @@6f13 214
                 +lbra sngflt                             ; float 1 byte in .y ;; @@6f14 214
 ;; @@6f17 214
;.end ;; @@6f17 214
; .page ;; @@6f17 214
; .subttl  TYPE ;; @@6f17 214
 ;; @@6f17 214
; TYPE  types a given disk (SEQ) file to output channel ;; @@6f17 214
; ;; @@6f17 214
 ;; @@6f17 214
type             ldz #0                                    ;; @@6f17 215
 ;; @@6f19 215
open_SEQ_file                                              ;; @@6f19 215
                 phz                                      ; save EDIT load flag    [910620] ;; @@6f19 215
                 lda #$e6                                 ; parse:  filename [,U#] [,D#] ;; @@6f1a 215
                 jsr dosprs                               ; (like dopen:      0 0 0 *  * 0 0 1 ) ;; @@6f1c 215
                 jsr chk1                                 ; check parameters ;; @@6f1f 215
                 jsr find_la                              ; find an available LA ;; @@6f22 215
                 jsr find_sa                              ; find an available SA ;; @@6f25 215
                 ldy #fopnseq                              ;; @@6f28 215
                 ldx #6                                    ;; @@6f2a 215
                 jsr open_file                            ; open the file ;; @@6f2c 215
                 +lbcs list_err                           ; exit if error ;; @@6f2f 215
                 plz                                      ; [910620] ;; @@6f32 215
                 beq _local_1214_20                        ;; @@6f33 215
                 rts                                      ; or exit if called by EDIT load routine ;; @@6f35 215
 ;; @@6f36 215
_local_1214_20   jsr _stop                                ; check stop key ;; @@6f36 215
                 beq _local_1214_30                       ; exit if down ;; @@6f39 215
                 ldx dosla                                 ;; @@6f3b 215
                 jsr _chkin                               ; get input channel ;; @@6f3e 215
                 bcs _local_1214_30                       ; exit if bad?? ;; @@6f41 215
                 ldx #0                                    ;; @@6f43 215
_local_1214_25   cpx #255                                 ; check buffer (buflen????) ;; @@6f45 215
; bcs 99$   ; 'too long' error ;; @@6f47 215
                 beq _local_1214_26                       ; allow long lines   [910620] ;; @@6f47 215
                 jsr _basin                               ; read file data ;; @@6f49 215
                 sta dosstr,x                             ; buffer it ;; @@6f4c 215
                 inx                                      ; bump buffer pointer ;; @@6f4f 215
                 tay                                      ; save char ;; @@6f50 215
                 jsr _readst                              ; check channel status ;; @@6f51 215
                 bne _local_1214_26                       ; exit if eof or error ;; @@6f54 215
                 cpy #cr                                   ;; @@6f56 215
                 bne _local_1214_25                       ; loop until eol ;; @@6f58 215
 ;; @@6f5a 215
_local_1214_26   php                                      ; save input channel status (beq=eol, bne=eof/err) ;; @@6f5a 215
                 stx t4                                   ; save character count ;; @@6f5b 215
                 jsr dcato                                ; get output channel ;; @@6f5e 215
                 ldx #0                                    ;; @@6f61 215
_local_1214_27   cpx t4                                   ; check buffer ;; @@6f63 215
                 bcs _local_1214_28                       ; end of buffered data ;; @@6f66 215
                 lda dosstr,x                             ; output data ;; @@6f68 215
                 jsr _bsout                                ;; @@6f6b 215
                 inx                                      ; bump buffer pointer ;; @@6f6e 215
                 bne _local_1214_27                       ; loop until end of buffer ;; @@6f6f 215
 ;; @@6f71 215
_local_1214_28   jsr _clrch                                ;; @@6f71 215
                 plp                                      ; check input status ;; @@6f74 215
                 beq _local_1214_20                       ; loop until eof or bad status ;; @@6f75 215
 ;; @@6f77 215
_local_1214_30   +lbra list_exit                          ; release channel, close file, return to main ;; @@6f77 215
 ;; @@6f7a 215
;99$ jsr _clrch  ;non-I/O trouble   removed [910620] ;; @@6f7a 215
; lda dosla  ; shut down disk & report BASIC error ;; @@6f7a 215
; clc ;; @@6f7a 215
; jsr _close ;; @@6f7a 215
; bra errlen  ;buffer overflow: report 'string too long' ;; @@6f7a 215
 ;; @@6f7a 215
; .page ;; @@6f7a 215
; .subttl  DISK command ;; @@6f7a 215
 ;; @@6f7a 215
; DISK "command_string" [,U#] [,D#]     new [910123] ;; @@6f7a 215
 ;; @@6f7a 215
disk                                                       ;; @@6f7a 216
                 lda #$f6                                 ; parse:  command_string [,U#] ;; @@6f7a 216
                 jsr dosprs                                ;; @@6f7c 216
                 jsr chk1                                 ; check parameters ;; @@6f7f 216
                 lda #doslfn                              ; la (reserved la) ;; @@6f82 216
                 sta dosla                                 ;; @@6f84 216
                 lda #$6f                                  ;; @@6f87 216
                 sta dossa                                ; sa (command channel) ;; @@6f89 216
                 ldy #fdisk                                ;; @@6f8c 216
                 ldx #2                                   ; add "/" [911108] ;; @@6f8e 216
                 jsr open_file                            ; open command channel & send command string ;; @@6f90 216
                 php                                      ; save error status    [910404] ;; @@6f93 216
                 pha                                       ;; @@6f94 216
                 lda #doslfn                              ; close it ;; @@6f95 216
                 sec                                      ; not a real close ;; @@6f97 216
                 jsr _close                               ; close it ;; @@6f98 216
                 pla                                      ; [910404] ;; @@6f9b 216
                 plp                                       ;; @@6f9c 216
                 +lbra exit_disk_op                       ; common error check & exit path ???? ;; @@6f9d 216
 ;; @@6fa0 216
 ;; @@6fa0 216
;.end ;; @@6fa0 216
; .page ;; @@6fa0 216
; .subttl  DOS 1 ;; @@6fa0 216
 ;; @@6fa0 216
; These routines take tokens and values after the following BASIC keywords: ;; @@6fa0 216
; ;; @@6fa0 216
;  DOPEN,   DCLOSE,  APPEND,  CONCAT, RECORD ;; @@6fa0 216
;  DLOAD,   DSAVE,   DVERIFY, BLOAD,  BSAVE ;; @@6fa0 216
;  FORMAT,  COLLECT, BACKUP,  COPY ;; @@6fa0 216
;  CATALOG, RENAME,  SCRATCH, DCLEAR ;; @@6fa0 216
; ;; @@6fa0 216
; It then parses the following line and finds syntax errors, checks for values ;; @@6fa0 216
; out of range, and sets variables in the zero-page to be passed to the disk ;; @@6fa0 216
; message generator. ;; @@6fa0 216
 ;; @@6fa0 216
 ;; @@6fa0 216
directory                                                 ; display disk directory (catalog) ;; @@6fa0 216
                 jsr chrgot                               ; get current chr ;; @@6fa0 216
                 cmp #esc_command_token                   ; eat dirECTORY kludge if it's there ;; @@6fa3 216
                 bne _local_1215_1                         ;; @@6fa5 216
                 jsr chrget                               ; (esc token + another) ;; @@6fa7 216
                 cmp #ectory_token                         ;; @@6faa 216
                 +lbne snerr                               ;; @@6fac 216
                 jsr chrget                               ; yes- get next good char ;; @@6faf 216
 ;; @@6fb2 216
_local_1215_1    jsr dospar                               ; parse the line ;; @@6fb2 216
                 lda parsts                               ; check options ;; @@6fb5 216
                 and #$e6                                  ;; @@6fb7 216
                 +lbne snerr                               ;; @@6fb9 216
 ;; @@6fbc 216
                 ldy #fdir                                ; table offset for directory ;; @@6fbc 216
                 bit dosflags                             ; want recoverable files? [901024] ;; @@6fbe 216
                 bvc _local_1215_2                        ; no ;; @@6fc1 216
                 ldy #fdirr                               ; yes ;; @@6fc3 216
_local_1215_2    ldx #1                                   ; just $ ;; @@6fc5 216
                 lda parsts                               ; check for default ;; @@6fc7 216
                 and #$11                                 ; no drive? ;; @@6fc9 216
                 beq _local_1215_20                        ;; @@6fcb 216
                 lsr                                       ;; @@6fcd 216
                 bcc _local_1215_10                       ; just drive ;; @@6fce 216
                 inx                                      ; drive and filename ;; @@6fd0 216
                 inx                                       ;; @@6fd1 216
_local_1215_10   inx                                       ;; @@6fd2 216
_local_1215_20   txa                                      ; a now has length ;; @@6fd3 216
                 jsr sendp                                ; build ;; @@6fd4 216
 ;; @@6fd7 216
                 ldx #sys_bank                            ; set banks????  fname in system space, bank0 [910620] ;; @@6fd7 216
                 txa                                      ; (load bank is don't care- we're not actually loading) ;; @@6fd9 216
                 jsr _setbank                              ;; @@6fda 216
 ;; @@6fdd 216
                 ldy #$60                                 ; sa, load floppy ;; @@6fdd 216
                 ldx dosfa                                 ;; @@6fdf 216
                 lda #doslfn                              ; lfn ;; @@6fe2 216
                 jsr _setlfs                              ; set file parameters ;; @@6fe4 216
                 jsr _open                                ; open it... ;; @@6fe7 216
                 bcc _local_1215_30                       ; ...ok ;; @@6fea 216
                 pha                                       ;; @@6fec 216
                 jsr dcat11                               ; ...error, shut down and report ;; @@6fed 216
                 plx                                       ;; @@6ff0 216
                 sec                                       ;; @@6ff1 216
                 +lbra error                               ;; @@6ff2 216
 ;; @@6ff5 216
_local_1215_30   lda channl                               ; determine DIR vs LDIR ;; @@6ff5 216
                 bne ldir                                 ; if output channel not default (screen) ;; @@6ff7 216
; use LDIR ;; @@6ff9 216
 ;; @@6ff9 216
; Get length in blocks ;; @@6ff9 216
 ;; @@6ff9 216
dir              ldx #doslfn                               ;; @@6ff9 217
                 jsr _chkin                                ;; @@6ffb 217
                 bcs dcat11                               ; if problem?? ;; @@6ffe 217
                 jsr _readst                              ; check status ;; @@7000 217
                 bne dcat11                               ; exit if bad status ;; @@7003 217
                 jsr crdo                                 ; output new line ;; @@7005 217
                 ldy #3                                   ; loop counter ;; @@7008 217
 ;; @@700a 217
dcat3            sty t3                                   ; save counter ;; @@700a 217
 ;; @@700d 217
_local_1216_10   jsr _basin                               ; get char ;; @@700d 217
                 sta t4                                    ;; @@7010 217
                 jsr _basin                               ; get char ;; @@7013 217
                 sta t4+1                                  ;; @@7016 217
                 jsr _readst                              ; check status ;; @@7019 217
                 bne dcat11                               ; exit if eof or bad status ;; @@701c 217
                 dec t3                                    ;; @@701e 217
                 bne _local_1216_10                       ; if not done ;; @@7021 217
 ;; @@7023 217
; Output blocks number ;; @@7023 217
 ;; @@7023 217
                 ldx t4                                    ;; @@7023 217
                 lda t4+1                                  ;; @@7026 217
                 jsr linprt                               ; output number ;; @@7029 217
                 lda #' '                                  ;; @@702c 217
                 jsr _bsout                               ; output a space ;; @@702e 217
 ;; @@7031 217
; Get name & output it ;; @@7031 217
 ;; @@7031 217
dcat4            jsr _readst                              ; get status ;; @@7031 218
                 bne dcat10                               ; if bad status ;; @@7034 218
                 jsr _basin                               ; get char ;; @@7036 218
                 beq dcat5                                ; if eol ;; @@7039 218
                 jsr _bsout                               ; echo char ;; @@703b 218
                 bra dcat4                                ; continue to process name until eol or err ;; @@703e 218
 ;; @@7040 218
; Here on end of name ;; @@7040 218
 ;; @@7040 218
dcat5            jsr crdo                                 ; output new line ;; @@7040 218
                 jsr _stop                                ; check stop key ;; @@7043 218
                 beq dcat11                               ; exit if stop request ;; @@7046 218
 ;; @@7048 218
; Process next ;; @@7048 218
 ;; @@7048 218
                 ldy #2                                   ; perform 2 times ;; @@7048 218
                 bra dcat3                                 ;; @@704a 218
 ;; @@704c 218
 ;; @@704c 218
; Exit directory ;; @@704c 218
 ;; @@704c 218
dcat10           jsr crdo                                 ; flush current line ;; @@704c 218
dcat11           jsr release_channels                     ; release cmd channel, restore terminal ;; @@704f 218
                 lda #doslfn                               ;; @@7052 218
                 +lbra close_out                          ; [900725] ;; @@7054 218
 ;; @@7057 218
; .page ;; @@7057 218
; LDIR  same as DIR, except it buffers each line to reduce ;; @@7057 218
;       talker/listener turnaround time.  Even so, it is still ;; @@7057 218
; unacceptably slow for normal screen output, which is ;; @@7057 218
; why it was split out from the original DIRECTORY routine. ;; @@7057 218
; ;; @@7057 218
 ;; @@7057 218
; Read block count ;; @@7057 218
 ;; @@7057 218
ldir                                                       ;; @@7057 218
                 lda #$c0                                 ; serial bus kludge for open4,4:cmd4:dir ???? ;; @@7057 218
                 and $d609                                 ;; @@7059 218
                 trb $d609                                ; disable fast serial bus ;; @@705c 218
                 sta sid_speed_flag                       ; but save enables so we can restore them ;; @@705f 218
 ;; @@7061 218
                 ldy #3                                   ; loop counter (3=skip fake load adr & link bytes) ;; @@7061 218
_local_1217_1    sty t3                                   ; save counter ;; @@7063 218
                 ldx #doslfn                               ;; @@7066 218
                 jsr _chkin                                ;; @@7068 218
                 bcs ldir_end                             ; problem?? ;; @@706b 218
 ;; @@706d 218
_local_1217_10   jsr _readst                              ; check status ;; @@706d 218
                 bne ldir_end                             ; exit if bad status ;; @@7070 218
                 jsr _basin                               ; get block count ;; @@7072 218
                 sta dosstr                               ; buffer it ;; @@7075 218
                 jsr _basin                                ;; @@7078 218
                 sta dosstr+1                              ;; @@707b 218
                 dec t3                                    ;; @@707e 218
                 bne _local_1217_10                       ; continue eating bytes until we have block count ;; @@7081 218
 ;; @@7083 218
; Read filename ;; @@7083 218
 ;; @@7083 218
                 ldx #1                                   ; buffer index-1 ;; @@7083 218
_local_1217_20   inx                                       ;; @@7085 218
                 jsr _readst                              ; check status ;; @@7086 218
                 bne ldir_end                             ; exit if eof or bad status ;; @@7089 218
                 jsr _basin                               ; buffer next character ;; @@708b 218
                 sta dosstr,x                              ;; @@708e 218
                 bne _local_1217_20                       ; loop until eol (null terminator) ;; @@7091 218
 ;; @@7093 218
; Print one line of directory ;; @@7093 218
 ;; @@7093 218
                 jsr dcato                                ; get output channel ;; @@7093 218
                 ldx dosstr                                ;; @@7096 218
                 lda dosstr+1                              ;; @@7099 218
                 jsr linprt                               ; print blocks ;; @@709c 218
 ;; @@709f 218
                 lda #' '                                  ;; @@709f 218
                 jsr _bsout                               ; print space ;; @@70a1 218
 ;; @@70a4 218
                 ldx #2                                    ;; @@70a4 218
_local_1217_30   lda dosstr,x                              ;; @@70a6 218
                 beq _local_1217_40                        ;; @@70a9 218
                 jsr _bsout                               ; print filename (null terminated) ;; @@70ab 218
                 inx                                       ;; @@70ae 218
                 bne _local_1217_30                        ;; @@70af 218
 ;; @@70b1 218
_local_1217_40   jsr crdo                                 ; print return ;; @@70b1 218
                 jsr _clrch                                ;; @@70b4 218
                 jsr _stop                                ; check stop key ;; @@70b7 218
                 beq ldir_end                             ; exit if stop request ;; @@70ba 218
 ;; @@70bc 218
; Continue with next line ;; @@70bc 218
 ;; @@70bc 218
                 ldy #2                                   ; set to skip fake link bytes ;; @@70bc 218
                 bra _local_1217_1                        ; loop ;; @@70be 218
 ;; @@70c0 218
 ;; @@70c0 218
ldir_end                                                   ;; @@70c0 219
                 lda sid_speed_flag                       ; serial bus kludge for open4,4:cmd4:dir ???? ;; @@70c0 219
                 tsb $d609                                ; restore fast serial bus enables ;; @@70c2 219
                 bra dcat11                                ;; @@70c5 219
 ;; @@70c7 219
 ;; @@70c7 219
 ;; @@70c7 219
dcato            jsr _clrch                                ;; @@70c7 219
                 ldx channl                               ; restore output channel ;; @@70ca 219
                 beq _local_1218_10                       ; branch if screen (default output) ;; @@70cc 219
                 jmp _chkout                              ; else get output channel ;; @@70ce 219
 ;; @@70d1 219
_local_1218_10   rts                                       ;; @@70d1 219
 ;; @@70d2 219
; .page ;; @@70d2 219
; DOPEN dfn(,t(,r)) ;; @@70d2 219
 ;; @@70d2 219
dopen            lda #$22                                 ; set error flag ;; @@70d2 220
                 jsr dosprs                               ; parse the line ;; @@70d4 220
                 jsr chk6                                 ; check required parameters ;; @@70d7 220
                 jsr find_sa                              ; find unused secondary address ;; @@70da 220
                 ldy #fopn                                ; fcb format pointer ;; @@70dd 220
                 ldx #4                                   ; normal length ;; @@70df 220
                 bbr6 parsts,open_it                      ; relative record? branch if not relative ;; @@70e1 220
                 ldx #8                                   ; random access length ;; @@70e4 220
                 bra open_it                              ; [910925] ;; @@70e6 220
 ;; @@70e8 220
;_local_1219_10 jsr open_file  ;open it ;; @@70e8 220
; bra exit_disk_op ;report any DOS errors, & return to main [910404] ;; @@70e8 220
 ;; @@70e8 220
 ;; @@70e8 220
 ;; @@70e8 220
; APPEND ;; @@70e8 220
 ;; @@70e8 220
append           lda #$e2                                 ; set error flags ;; @@70e8 220
                 jsr dosprs                               ; parse the line ;; @@70ea 220
                 jsr chk6                                 ; check required parameters ;; @@70ed 220
                 jsr find_sa                              ; find secondary address ;; @@70f0 220
                 ldy #fapn                                ; tabld index ;; @@70f3 220
                 ldx #5                                   ; length ;; @@70f5 220
open_it                                                    ;; @@70f7 220
                 jsr open_file                            ; open it ;; @@70f7 220
                 +lbra exit_disk_op                       ; report any DOS errors, & return to main [910404] ;; @@70fa 220
 ;; @@70fd 220
 ;; @@70fd 220
 ;; @@70fd 220
open_file                                                 ; dop2. ;; @@70fd 220
                 txa                                      ; set length into a ;; @@70fd 220
                 jsr sendp                                 ;; @@70fe 220
                 jsr _clrch                                ;; @@7101 220
                 ldx #sys_bank                            ; fname is in system space, bank0  [910620] ;; @@7104 220
                 txa                                      ; (load bank not req'd)???? ;; @@7106 220
                 jsr _setbank                              ;; @@7107 220
                 jmp _open                                 ;; @@710a 220
 ;; @@710d 220
; .page ;; @@710d 220
; Find an available secondary address ;; @@710d 220
 ;; @@710d 220
find_sa                                                    ;; @@710d 220
                 ldy #$61                                 ; 2-14 possible ;; @@710d 220
 ;; @@710f 220
_local_1219_10   iny                                       ;; @@710f 220
                 cpy #$6f                                  ;; @@7110 220
                 beq too_many_files                       ; if none available error ;; @@7112 220
                 jsr _lkupsa                              ; kernel will lookup this sa in its tables ;; @@7114 220
                 bcc _local_1219_10                       ; if used keep looking ;; @@7117 220
                 sty dossa                                ; save secondary address ;; @@7119 220
                 rts                                      ; return .y = sa ;; @@711c 220
 ;; @@711d 220
 ;; @@711d 220
 ;; @@711d 220
; Find an available logical address ;; @@711d 220
 ;; @@711d 220
find_la                                                    ;; @@711d 221
                 lda #0                                   ; 1-127 possible ;; @@711d 221
 ;; @@711f 221
_local_1220_10   inc                                       ;; @@711f 221
                 bmi too_many_files                       ; if none available error ;; @@7120 221
                 jsr _lkupla                              ; kernel will lookup this la in its tables ;; @@7122 221
                 bcc _local_1220_10                       ; if used keep looking ;; @@7125 221
                 sta dosla                                ; save logical address ;; @@7127 221
                 rts                                      ; return .a = la ;; @@712a 221
 ;; @@712b 221
 ;; @@712b 221
 ;; @@712b 221
 ;; @@712b 221
too_many_files                                             ;; @@712b 222
                 ldx #errtmf                              ; too many files open ;; @@712b 222
                 +lbra error                               ;; @@712d 222
 ;; @@7130 222
; .page ;; @@7130 222
; Close disk file ;; @@7130 222
 ;; @@7130 222
dclose           lda #$f3                                 ; set error flags ;; @@7130 222
                 jsr dosprs                               ; parse the line ;; @@7132 222
                 jsr Clear_DS                              ;; @@7135 222
                 bbr2 parsts,dclall                       ; any la given?  branch if not ;; @@7138 222
                 lda dosla                                 ;; @@713b 222
                 +lbra close_out                           ;; @@713e 222
 ;; @@7141 222
dclall           lda dosfa                                ; get disk # ;; @@7141 222
; jsr put_io_in_map ;; @@7144 222
                 jmp _close_all                           ; close all channels ;; @@7144 222
 ;; @@7147 222
 ;; @@7147 222
 ;; @@7147 222
; DSAVE dfn ;; @@7147 222
 ;; @@7147 222
dsave            bbr4 runmod,_local_1221_10               ; PROGRAM or EDIT mode?    [910620] ;; @@7147 222
                 +lbra edit_save                          ; edit ;; @@714a 222
 ;; @@714d 222
_local_1221_10   lda #$66                                 ; set error flags ;; @@714d 222
                 jsr dosprs                               ; parse the line ;; @@714f 222
                 jsr chk2                                 ; check required parameters ;; @@7152 222
                 ldy #fopn                                ; table offset ;; @@7155 222
                 lda #4                                   ; ..length, ;; @@7157 222
                 jsr sendp                                 ;; @@7159 222
 ;; @@715c 222
                 lda text_bank                            ; default to text bank set up banks???? [910620] ;; @@715c 222
                 ldx #sys_bank                            ; fname is in system space, bank0 ;; @@715e 222
                 jsr _setbank                              ;; @@7160 222
                 +lbra savenp                              ;; @@7163 222
 ;; @@7166 222
; .page ;; @@7166 222
; DVERIFY ;; @@7166 222
 ;; @@7166 222
dverify          lda #1                                   ; flag 'verify' ;; @@7166 223
                 !text $2c                                 ;; @@7168 223
 ;; @@7169 223
 ;; @@7169 223
 ;; @@7169 223
; DLOAD dfn ;; @@7169 223
 ;; @@7169 223
dload            lda #0                                    ;; @@7169 223
                 sta verck                                ; set load flag (for verify check later) ;; @@716b 223
 ;; @@716d 223
                 bbr4 runmod,_local_1222_10               ; PROGRAM or EDIT mode?    [910620] ;; @@716d 223
                 +lbra edit_load                          ; edit ;; @@7170 223
 ;; @@7173 223
_local_1222_10   lda #$e6                                 ; set error flags ;; @@7173 223
                 jsr dosprs                               ; parse the line ;; @@7175 223
                 jsr chk2                                 ; check required parameters ;; @@7178 223
 ;; @@717b 223
 ;; @@717b 223
dload_boot                                                ; <<<<<<<<<<<<<<<<<< entry for BOOT'AUTOBOOT.C65' ;; @@717b 224
                 lda #0                                    ;; @@717b 224
                 sta dossa                                ; set relocate flag ;; @@717d 224
                 ldy #fopn                                ; table offset ;; @@7180 224
                 lda #4                                   ; ..length ;; @@7182 224
                 jsr sendp                                 ;; @@7184 224
 ;; @@7187 224
                 lda text_bank                            ; set up banks ???? want text_bank ????  [910620] ;; @@7187 224
                 ldx #sys_bank                            ; fname is in system space, bank0 ;; @@7189 224
                 jsr _setbank                              ;; @@718b 224
 ;; @@718e 224
                 +lbra cld10                              ; finish load, using 'LOAD' code. ;; @@718e 224
 ;; @@7191 224
; .page ;; @@7191 224
; BSAVE ;; @@7191 224
 ;; @@7191 224
bsave            lda #$66                                 ; std error flag ;; @@7191 224
                 ldx #$f8                                 ; auxiliary error flag (allow bank, start & end address) ;; @@7193 224
                 jsr dosprx                               ; parse options ;; @@7195 224
                 jsr chk2                                 ; check required parameters ;; @@7198 224
 ;; @@719b 224
                 lda parstx                               ; check for starting & ending addresses ;; @@719b 224
                 and #6                                    ;; @@719d 224
                 cmp #6                                    ;; @@719f 224
                 +lbne snerr                              ; ..if not present, syntax error ;; @@71a1 224
 ;; @@71a4 224
                 lda dosofh+1                             ; check that ea>sa ;; @@71a4 224
                 cmp dosofl+1                              ;; @@71a7 224
                 +lbcc fcerr                              ; ...error ;; @@71aa 224
                 bne _local_1223_20                        ;; @@71ad 224
                 lda dosofh                                ;; @@71af 224
                 cmp dosofl                                ;; @@71b2 224
                 +lbcc fcerr                              ; ...error ;; @@71b5 224
                 +lbeq fcerr                               ;; @@71b8 224
 ;; @@71bb 224
_local_1223_20   ldy #fopn                                ; table offset ;; @@71bb 224
                 lda #4                                   ; ..length ;; @@71bd 224
                 jsr sendp                                 ;; @@71bf 224
 ;; @@71c2 224
                 lda dosbnk                               ; get requested bank ;; @@71c2 224
                 ldx #sys_bank                            ; ..and name will be in system bank ;; @@71c5 224
                 jsr _setbank                             ; ..and go set up bank ;; @@71c7 224
 ;; @@71ca 224
                 ldx dosofl                               ; start addr ;; @@71ca 224
                 ldy dosofl+1                              ;; @@71cd 224
                 lda #highds                              ; ..and a pointer to start address ;; @@71d0 224
                 stx highds                                ;; @@71d2 224
                 sty highds+1                              ;; @@71d4 224
                 ldx dosofh                               ; end addr ;; @@71d6 224
                 ldy dosofh+1                              ;; @@71d9 224
                 +lbra savenb                              ;; @@71dc 224
 ;; @@71df 224
 ;; @@71df 224
; .page ;; @@71df 224
; DVERIFY ;; @@71df 224
 ;; @@71df 224
bverify          lda #1                                   ; flag 'verify' ;; @@71df 225
                 !text $2c                                 ;; @@71e1 225
 ;; @@71e2 225
 ;; @@71e2 225
; BLOAD dfn ;; @@71e2 225
 ;; @@71e2 225
bload            lda #0                                   ; flag 'load' ;; @@71e2 225
                 sta verck                                ; eventually the 'load' routine will look here ;; @@71e4 225
 ;; @@71e6 225
                 lda #$e6                                 ; std error flag ;; @@71e6 225
                 ldx #$fc                                 ; aux error flag (allow bank & load address) ;; @@71e8 225
                 jsr dosprx                               ; parse options ;; @@71ea 225
 ;; @@71ed 225
bload_boot                                                ; <<<<<<<<<<<<<<<<<<<<<< entry for BOOT'filename' ;; @@71ed 225
                 jsr chk2                                 ; check required parameters ;; @@71ed 225
                 ldx dosofl                               ; get starting address high ;; @@71f0 225
                 ldy dosofl+1                             ; ..and lo ;; @@71f3 225
                 lda #0                                   ; assume x & y not both=ff (means real add., not def) ;; @@71f6 225
                 cpx #$ff                                  ;; @@71f8 225
                 bne _local_1224_5                         ;; @@71fa 225
                 cpy #$ff                                  ;; @@71fc 225
                 bne _local_1224_5                         ;; @@71fe 225
                 lda #$ff                                 ; use defaults ;; @@7200 225
_local_1224_5    sta dossa                                 ;; @@7202 225
 ;; @@7205 225
                 ldy #fopn                                ; table offset ;; @@7205 225
                 lda #4                                   ; ..length, ;; @@7207 225
                 jsr sendp                                ; ...and go send parameters ;; @@7209 225
 ;; @@720c 225
                 lda dosbnk                                ;; @@720c 225
                 ldx #sys_bank                             ;; @@720f 225
                 jsr _setbank                              ;; @@7211 225
 ;; @@7214 225
                 lda verck                                ; flag LOAD or VERIFY ;; @@7214 225
                 ldx dosofl                               ; get starting address high ;; @@7216 225
                 ldy dosofl+1                             ; ..and lo (in case this isn't a 'default' load) ;; @@7219 225
                 jsr _loadsp                              ; load it ;; @@721c 225
 ;; @@721f 225
; Any changes to the following code must be duplicated at: ;; @@721f 225
;  load (load_file) ;; @@721f 225
;  save (exit_disk_op) ;; @@721f 225
 ;; @@721f 225
                 php                                      ; save kernel load status (.c) ;; @@721f 225
                 pha                                      ; save kernel error # (.a) ;; @@7220 225
                 jsr _readst                              ; save I/O status byte ;; @@7221 225
                 sta parsts                                ;; @@7224 225
                 jsr print_dos_error                      ; report DOS problems ;; @@7226 225
                 pla                                      ; restore error stuff ;; @@7229 225
                 plp                                       ;; @@722a 225
                 bcc _local_1224_30                       ; branch if no error (rts) ;; @@722b 225
                 bbs7 runmod,_local_1224_20               ; branch if run mode (erexit) ;; @@722d 225
                 cmp #errfnf                              ; is it 'file not found' catch-all? ;; @@7230 225
                 bne _local_1224_10                       ; no  (erexit) ;; @@7232 225
                 sta errnum                               ; yes- save error # for 'er' ;; @@7234 225
                 ora #$80                                 ; but no errdis ;; @@7237 225
_local_1224_10   sec                                       ;; @@7239 225
_local_1224_20   +lbcs erexit                             ; exit if kernel problem (rts) ;; @@723a 225
 ;; @@723d 225
_local_1224_30   lda verck                                ; load or verify operation? ;; @@723d 225
                 +lbne verify_check                       ; verify ;; @@723f 225
 ;; @@7242 225
; jsr _readst  ;  read status ;; @@7242 225
                 lda parsts                               ; load ;; @@7242 225
                 and #%10111111                           ; EOI is okay, so mask it ;; @@7244 225
                 +lbne load_error                         ; load error ;; @@7246 225
                 clc                                       ;; @@7249 225
                 rts                                       ;; @@724a 225
 ;; @@724b 225
; .page ;; @@724b 225
; HEADER nddn [,id]  (alias: FORMAT) ;; @@724b 225
 ;; @@724b 225
header           jsr dospar                               ; parse the line ;; @@724b 226
                 jsr chk1                                 ; check parameter errors ;; @@724e 226
                 and #$01                                  ;; @@7251 226
                 cmp #$01                                  ;; @@7253 226
                 +lbne snerr                              ; if required parameters not present ;; @@7255 226
 ;; @@7258 226
                 jsr _clall                               ; close all files ;; @@7258 226
                 jsr are_you_sure                         ; confirm if in direct mode ;; @@725b 226
                 bne header_rts                           ; exit if 'no' response ;; @@725e 226
                 ldy #fhed                                ; tabld index ;; @@7260 226
                 lda #4                                   ; length ;; @@7262 226
                 ldx dosdid                               ; check for diskid ;; @@7264 226
                 beq _local_1225_10                        ;; @@7267 226
                 lda #6                                   ; length with id ;; @@7269 226
 ;; @@726b 226
_local_1225_10   jsr trans                                ; build and send command ;; @@726b 226
;fall into 'print_dos_error' ;; @@726e 226
 ;; @@726e 226
; .page ;; @@726e 226
print_dos_error                                           ; [900725] ;; @@726e 227
                 bbs7 runmod,header_rts                   ; branch if not direct mode ;; @@726e 227
                 jsr Check_DS                             ; get current disk error message ;; @@7271 227
                 ldy #0                                    ;; @@7274 227
                 lda #dsdesc+1                             ;; @@7276 227
                 jsr lda_far_ram1                         ; lda (dsdesc+1),y peek at first character ;; @@7278 227
                 cmp #'2'                                  ;; @@727b 227
                 bcc header_rts                           ; branch if no error occured ('00' or '01') ;; @@727d 227
                 cmp #'7'                                  ;; @@727f 227
                 bne _local_1226_1                        ; [900730] ;; @@7281 227
                 iny                                       ;; @@7283 227
                 lda #dsdesc+1                             ;; @@7284 227
                 jsr lda_far_ram1                         ; might be '73' powerup message ;; @@7286 227
                 cmp #'3'                                  ;; @@7289 227
                 beq header_rts                           ; yup ;; @@728b 227
 ;; @@728d 227
; ldx #errbdk  ; bad disk error (carry is set) ;; @@728d 227
; bra error ;; @@728d 227
 ;; @@728d 227
; Print DOS error message as if it were a BASIC error message   [900910] ;; @@728d 227
 ;; @@728d 227
_local_1226_1    lda #$ff                                 ; reset error line ;; @@728d 227
                 sta errlin                               ;  ;; @@728f 227
                 sta errlin+1                              ;; @@7292 227
                 jsr _clrch                                ;; @@7295 227
; inc a   ;a=0 restore output to screen   [910909] ;; @@7298 227
                 sta channl                                ;; @@7298 227
                 jsr RestoreTextScreen                    ; make sure we're in text mode????  [910404] ;; @@729a 227
                 jsr init_stack                           ; clean up system, string temps, etc.  [910121] ;; @@729d 227
 ;; @@72a0 227
                 jsr highlight_text                       ; [910624] ;; @@72a0 227
                 jsr _primm                               ; start a new line with '?DOS: ' ;; @@72a3 227
                 !text cr,"?DOS: ",0                      ; (to distinguish ?DOS: SYNTAX ERROR from ?SYNTAX ERROR) ;; @@72a6 227
 ;; @@72ae 227
                 ldy #3                                   ; print text part of message only ;; @@72ae 227
                 lda #dsdesc+1                             ;; @@72b0 227
                 jsr lda_far_ram1                         ; skip err#, comma, & leading space if any ;; @@72b2 227
                 cmp #' '                                  ;; @@72b5 227
                 bne _local_1226_20                        ;; @@72b7 227
                 iny                                       ;; @@72b9 227
_local_1226_10   lda #dsdesc+1                             ;; @@72ba 227
                 jsr lda_far_ram1                          ;; @@72bc 227
                 cmp #','                                 ; finished at comma preceding trk, sector ;; @@72bf 227
                 beq _local_1226_30                        ;; @@72c1 227
_local_1226_20   jsr outch                                 ;; @@72c3 227
                 iny                                       ;; @@72c6 227
                 bpl _local_1226_10                       ; loop always (bpl=failsafe) ;; @@72c7 227
 ;; @@72c9 227
_local_1226_30   jsr highlight_done                       ; [910624] ;; @@72c9 227
                 jsr crdo                                  ;; @@72cc 227
                 +lbra ready                              ; we're in direct mode, error msg has been printed, abort ;; @@72cf 227
 ;; @@72d2 227
header_rts                                                 ;; @@72d2 228
                 clc                                       ;; @@72d2 228
                 rts                                       ;; @@72d3 228
 ;; @@72d4 228
; .page ;; @@72d4 228
; SCRATCH sdfn  aliases: DELETE, ERASE ;; @@72d4 228
 ;; @@72d4 228
scratch          jsr dospar                               ; parse the line ;; @@72d4 228
                 jsr chk1                                  ;; @@72d7 228
                 jsr are_you_sure                         ; confirm if in direct mode ;; @@72da 228
                 bne _local_1227_30                       ; branch if 'no' response given ;; @@72dd 228
 ;; @@72df 228
                 ldy #fscr                                ; offset ;; @@72df 228
                 lda #4                                   ; length ;; @@72e1 228
                 bit dosflags                             ; scratch or recover? ;; @@72e3 228
                 bvc _local_1227_1                        ; scratch ;; @@72e6 228
                 ldy #frscr                               ; recover ;; @@72e8 228
                 lda #6                                    ;; @@72ea 228
_local_1227_1    jsr trans                                ; transmit scratch command ;; @@72ec 228
                 jsr Read_DS                              ; read error channel & update DS$ ;; @@72ef 228
 ;; @@72f2 228
                 bbs7 runmod,_local_1227_30               ; branch if not direct mode ;; @@72f2 228
                 jsr crdo                                 ; output cr ;; @@72f5 228
 ;; @@72f8 228
                 ldy #0                                   ; display 'files scratched' DOS message ;; @@72f8 228
_local_1227_10   lda #dsdesc+1                             ;; @@72fa 228
                 jsr lda_far_ram1                         ; lda (dsdesc+1),y ;; @@72fc 228
                 beq _local_1227_20                       ; if end of error message ;; @@72ff 228
                 jsr outch                                ; print it ;; @@7301 228
                 iny                                       ;; @@7304 228
                 bpl _local_1227_10                       ; always (bpl=failsafe) ;; @@7305 228
 ;; @@7307 228
_local_1227_20   jsr crdo                                 ; done ;; @@7307 228
 ;; @@730a 228
_local_1227_30   rts                                       ;; @@730a 228
 ;; @@730b 228
; .page ;; @@730b 228
; RECORD- relative record access ;; @@730b 228
 ;; @@730b 228
record           lda #'#'                                  ;; @@730b 229
                 jsr synchr                               ; syntax error if not 'record#' ;; @@730d 229
 ;; @@7310 229
                 jsr getbyt                               ; get lfn in x ;; @@7310 229
                 cpx #0                                    ;; @@7313 229
                 +lbeq fcerr                              ; cannot be zero ;; @@7315 229
                 stx dosla                                ; save logical address ;; @@7318 229
 ;; @@731b 229
                 jsr comwrd                               ; check for comma, get record number in 'poker' ;; @@731b 229
 ;; @@731e 229
                 ldx #1                                   ; set up to get starting byte # - default is 1 ;; @@731e 229
                 jsr optbyt                                ;; @@7320 229
                 stx dosrcl                               ; save byte position (pos)    [911024] ;; @@7323 229
                 txa                                      ; cpx #0 ;; @@7326 229
                 +lbeq fcerr                              ; if out of range ;; @@7327 229
                 inx                                      ; cpx #$ff ;; @@732a 229
                 +lbeq fcerr                              ; if out of range ;; @@732b 229
 ;; @@732e 229
                 lda dosla                                ; get logical address ;; @@732e 229
; jsr put_io_in_map ;; @@7331 229
                 jsr _lkupla                              ; logical to physical map ;; @@7331 229
                 bcs _local_1228_20                       ; if file not found (not open)    [910404] ;; @@7334 229
                 sty dossa_temp                           ; save secondary address ;; @@7336 229
 ;; @@7339 229
                 stx dosfa                                ; set up device number for trans routine ;; @@7339 229
                 lda #0                                    ;; @@733c 229
                 sta dosla                                ; set up logical address for trans routine ;; @@733e 229
                 lda #$6f                                  ;; @@7341 229
                 sta dossa                                ; and secondary address, too! ;; @@7343 229
 ;; @@7346 229
                 ldy #frec                                ; set pointer ;; @@7346 229
                 lda #4                                   ; process five bytes ;; @@7348 229
                 jsr trans                                ; send command ;; @@734a 229
                 +lbra print_dos_error                    ; if any ;; @@734d 229
 ;; @@7350 229
_local_1228_20   ldx #errfno                              ; file not found err (file not open)   [910404] ;; @@7350 229
                 +lbra error                               ;; @@7352 229
 ;; @@7355 229
; .page ;; @@7355 229
; DCLEAR - reinitilaize the drive ;; @@7355 229
 ;; @@7355 229
dclear           jsr dospar                               ; parse the line ;; @@7355 230
                 ldy #finit                               ; set code ;; @@7358 230
                 lda #2                                    ;; @@735a 230
                 jsr trans                                ; send command ;; @@735c 230
                 jsr print_dos_error                      ; if any ;; @@735f 230
                 +lbra dclall                              ;; @@7362 230
 ;; @@7365 230
 ;; @@7365 230
 ;; @@7365 230
 ;; @@7365 230
; COLLECT v<drive#> ;; @@7365 230
 ;; @@7365 230
collect          jsr dospar                               ; parse the line ;; @@7365 230
                 jsr chk3                                 ; check optional parameters ;; @@7368 230
                 jsr _clall                               ; close all files ;; @@736b 230
                 ldy #fcoll                               ; tabld offset ;; @@736e 230
                 lda #1                                   ; length ;; @@7370 230
                 bbr4 parsts,_local_1229_10                ;; @@7372 230
                 inc                                      ; include drive ;; @@7375 230
_local_1229_10   jsr trans                                ; send command ;; @@7376 230
                 +lbra print_dos_error                    ; if any ;; @@7379 230
 ;; @@737c 230
 ;; @@737c 230
; .page ;; @@737c 230
; COPY cdddfn=sdsfn ;; @@737c 230
 ;; @@737c 230
dcopy            jsr dospar                               ; parse the line ;; @@737c 231
                 and #$30                                  ;; @@737f 231
                 cmp #$30                                 ; check required parameters ;; @@7381 231
                 bne _local_1230_10                       ; branch if single drive copy ;; @@7383 231
                 lda parsts                               ; else check for dual drive params ;; @@7385 231
                 and #$c7                                  ;; @@7387 231
                 beq _local_1230_20                        ;; @@7389 231
                 and #3                                   ; special check for 2nd filename   [910717] ;; @@738b 231
                 cmp #3                                    ;; @@738d 231
                 beq _local_1230_10                       ; branch if given ;; @@738f 231
                 lda #'*'                                  ;; @@7391 231
                 sta dosdid                               ; else supply "*" for him, just like 'name2' ;; @@7393 231
                 lda #1                                    ;; @@7396 231
                 ldx #<dosdid                              ;; @@7398 231
                 ldy #>dosdid                              ;; @@739a 231
                 sta dosf2l                                ;; @@739c 231
                 stx dosf2a                                ;; @@739f 231
                 sty dosf2a+1                              ;; @@73a2 231
                 lda #2                                   ; and set filename2 flag ;; @@73a5 231
                 tsb parsts                               ; set flag in status ;; @@73a7 231
_local_1230_10   lda parsts                                ;; @@73a9 231
                 jsr chk4                                  ;; @@73ab 231
; lda parsts ;; @@73ae 231
_local_1230_20   ldy #fcopy                               ; tabld offset ;; @@73ae 231
                 lda #8                                   ; length ;; @@73b0 231
                 jsr trans                                ; send command ;; @@73b2 231
                 +lbra print_dos_error                    ; if any ;; @@73b5 231
 ;; @@73b8 231
 ;; @@73b8 231
 ;; @@73b8 231
; CONCAT ;; @@73b8 231
 ;; @@73b8 231
concat           jsr dospar                               ; parse the line ;; @@73b8 232
                 jsr chk4                                  ;; @@73bb 232
                 ldy #fconc                               ; offset ;; @@73be 232
                 lda #12                                  ; length ;; @@73c0 232
                 jsr trans                                ; send command ;; @@73c2 232
                 +lbra print_dos_error                    ; if any ;; @@73c5 232
 ;; @@73c8 232
 ;; @@73c8 232
 ;; @@73c8 232
 ;; @@73c8 232
; RENAME rdddfn=sdsfn ;; @@73c8 232
 ;; @@73c8 232
rename           lda #$e4                                 ; set error flags ;; @@73c8 232
                 jsr dosprs                               ; parse the line ;; @@73ca 232
                 jsr chk5                                  ;; @@73cd 232
                 ldy #fren                                ; offset ;; @@73d0 232
                 lda #8                                   ; length ;; @@73d2 232
                 jsr trans                                ; send command ;; @@73d4 232
                 +lbra print_dos_error                    ; if any ;; @@73d7 232
 ;; @@73da 232
 ;; @@73da 232
; .page ;; @@73da 232
; BACKUP D<destination_drive>=D<source_drive> ;; @@73da 232
; ;; @@73da 232
; where destination|source_drive is [0...9] ;; @@73da 232
 ;; @@73da 232
backup           lda #$c7                                 ; set error flags ;; @@73da 232
                 jsr dosprs                               ; parse the line ;; @@73dc 232
                 and #$30                                 ; required parameters ;; @@73df 232
                 cmp #$30                                  ;; @@73e1 232
                 +lbne snerr                               ;; @@73e3 232
                 jsr are_you_sure                          ;; @@73e6 232
                 beq _local_1231_10                       ; if run mode or not 'yes' ;; @@73e9 232
                 rts                                       ;; @@73eb 232
 ;; @@73ec 232
_local_1231_10   jsr dclall                               ; close disk ;; @@73ec 232
                 ldy #fbak                                 ;; @@73ef 232
                 lda #4                                   ; length ;; @@73f1 232
                 jsr trans                                ; send command ;; @@73f3 232
                 +lbra print_dos_error                    ; if any ;; @@73f6 232
 ;; @@73f9 232
 ;; @@73f9 232
; .page ;; @@73f9 232
; Trans subroutine ;; @@73f9 232
 ;; @@73f9 232
trans            jsr sendp                                ; build string to output ;; @@73f9 233
                 jsr _clrch                                ;; @@73fc 233
                 ldx #sys_bank                            ; name is in system space, bank0 ????  [910620] ;; @@73ff 233
                 txa                                       ;; @@7401 233
                 jsr _setbank                              ;; @@7402 233
                 jsr _open                                ; send it... ;; @@7405 233
                 php                                      ; save error status (.c) ;; @@7408 233
                 pha                                      ; save error code (if any) ;; @@7409 233
                 lda dosla                                 ;; @@740a 233
                 sec                                       ;; @@740d 233
                 jsr _close                               ; special close... ;; @@740e 233
                 pla                                      ; pop error ;; @@7411 233
                 plp                                      ; pop error status ;; @@7412 233
                 +lbcs erexit                             ; ...branch if there was an error opening ;; @@7413 233
                 rts                                       ;; @@7416 233
 ;; @@7417 233
;.end ;; @@7417 233
; .page ;; @@7417 233
; .subttl  DOS 2 ;; @@7417 233
 ;; @@7417 233
; This is the DOS parser routine which looks at lines passed to it and ;; @@7417 233
; verifies that the syntax is proper.  -mgm 7/23/79- ;; @@7417 233
; ;; @@7417 233
; Entry  (dosprs) ;; @@7417 233
; a = parsts bit which must be zero. ;; @@7417 233
; ;; @@7417 233
; Exit  a = parsts as follows ;; @@7417 233
; ;; @@7417 233
;    --------------------------------- ;; @@7417 233
;    | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | ;; @@7417 233
;    --------------------------------- ;; @@7417 233
;      ^   ^   ^   ^   ^   ^   ^   ^ ;; @@7417 233
;      |   |   |   |   |   |   |   |_____ fn1 set for the first filename ;; @@7417 233
;      |   |   |   |   |   |   |_______ fn2 set for second filename ;; @@7417 233
;      |   |   |   |   |   |_________ la set when #lfn parsed ;; @@7417 233
;      |   |   |   |   |___________ fa set for device number ;; @@7417 233
;      |   |   |   |_____________ d1 set for first disk unit ;; @@7417 233
;      |   |   |_______________ d2 set for second disk unit ;; @@7417 233
;      |   |_________________ dosrcl set for record size ;; @@7417 233
;      |___________________ @ set when @ encountered ;; @@7417 233
; ;; @@7417 233
; The following are the vaild bit patterns for parsts after parsing for the ;; @@7417 233
; various keywords: ;; @@7417 233
; ;; @@7417 233
;       7 6 5 4  3 2 1 0 ;; @@7417 233
; ;; @@7417 233
;     header  0 0 0 *  * 0 0 1 ;; @@7417 233
;     collect 0 0 0 *  * 0 0 0 ;; @@7417 233
;     dclear  0 0 0 *  * 0 0 0 ;; @@7417 233
;     backup  0 0 1 1  * 0 0 0 ;; @@7417 233
;     copy    0 0 1 1  * 0 0 0 ;; @@7417 233
;      or..   0 0 * *  * 0 1 1 ;; @@7417 233
;     concat  0 0 * *  * 0 1 1 ;; @@7417 233
;     bsave   * 0 0 *  * 0 0 1 ;; @@7417 233
;     dsave   * 0 0 *  * 0 0 1 ;; @@7417 233
;     bload   0 0 0 *  * 0 0 1 ;; @@7417 233
;     dload   0 0 0 *  * 0 0 1 ;; @@7417 233
;     dverify 0 0 0 *  * 0 0 1 ;; @@7417 233
;     catalog 0 0 0 *  * 0 0 * ;; @@7417 233
;     rename  0 0 0 *  * 0 1 1 ;; @@7417 233
;     append  0 0 0 *  * 1 0 1 ;; @@7417 233
;     scratch 0 0 0 *  * 0 0 1 ;; @@7417 233
;     dopen   * * 0 *  * 1 0 1 ;; @@7417 233
;     dclose  0 0 0 0  * * 0 0 ;; @@7417 233
;             ^ ^ ^ ^  ^ ^ ^ ^ ;; @@7417 233
;             @ l d d  f l f f ;; @@7417 233
;             r r 2 1  a a n n ;; @@7417 233
;             p e          2 1 ;; @@7417 233
;             l l ;; @@7417 233
; ;; @@7417 233
;      "0" bits are required to be clear ;; @@7417 233
;      "1" bits are required to be set ;; @@7417 233
;      "*" bits are optional parameters ;; @@7417 233
; .page ;; @@7417 233
; Entry (dosprs): ;; @@7417 233
;  parstx shall be set to prevent any auxiliary options to be specified. ;; @@7417 233
; ;; @@7417 233
; Entry (dosprx): ;; @@7417 233
;  .x = parstx bits which must be zero. ;; @@7417 233
; ;; @@7417 233
; Exit:  .x = parstx as follows: ;; @@7417 233
; ;; @@7417 233
;     --------------------------------- ;; @@7417 233
;     | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 | ;; @@7417 233
;     --------------------------------- ;; @@7417 233
;       ^   ^   ^   ^   ^   ^   ^   ^____ bnk is set for bank option ;; @@7417 233
;       |   |   |   |   |   |   | ______ offl set for 1st address ;; @@7417 233
;       |   |   |   |   |   |_________ offh set for 2nd address ;; @@7417 233
;       |   |   |   |   |___________ unused ;; @@7417 233
;       |   |   |   |_____________ unused ;; @@7417 233
;       |   |   |_______________ unused ;; @@7417 233
;       |   |_________________ unused ;; @@7417 233
;       |___________________ unused ;; @@7417 233
; ;; @@7417 233
; The following are the valid bit patterns for parstx after parsing for the ;; @@7417 233
; various keywords.  These options are allowed for load/save commands only. ;; @@7417 233
; ;; @@7417 233
;    7 6 5 4  3 2 1 0 ;; @@7417 233
; ;; @@7417 233
;   bsave   0 0 0 0  0 1 1 * ;; @@7417 233
;   bload   0 0 0 0  0 0 * * ;; @@7417 233
;   bverify 0 0 0 0  0 0 * * ;; @@7417 233
;   [auto]boot 0 0 0 0  0 0 * * ;; @@7417 233
;    ^ ^ ^ ^  ^ ^ ^ ^ ;; @@7417 233
;    ? ? ? ?  ? o o b ;; @@7417 233
;        f f n ;; @@7417 233
;        h l k ;; @@7417 233
; ;; @@7417 233
;      "0" bits are required to be clear ;; @@7417 233
;      "1" bits are required to be set ;; @@7417 233
;      "*" bits are optional parameters ;; @@7417 233
 ;; @@7417 233
dostbl           !word $ffff,$ffff                        ; default start/end address ;; @@7417 233
                 !text doslfn,dosffn,$6f                  ; default la/fa/sa ;; @@741b 233
 ;; @@741e 233
; .page ;; @@741e 233
dospar           lda #0                                   ; DOS Parser ;; @@741e 233
 ;; @@7420 233
dosprs                                                    ; special error flag entry ;; @@7420 233
                 ldx #$ff                                 ; no aux options! ;; @@7420 233
 ;; @@7422 233
dosprx                                                    ; spec aux error flag entry ;; @@7422 233
                 pha                                      ; save error flags ;; @@7422 233
                 phx                                       ;; @@7423 233
                 lda #0                                    ;; @@7424 233
                 sta parsts                               ; reset parser status/option words ;; @@7426 233
                 sta parstx                                ;; @@7428 233
 ;; @@742a 233
                 ldx #dosspc                              ; clear DOS scratch area   [900522] ;; @@742a 233
_local_1232_10   sta xcnt-1,x                              ;; @@742c 233
                 dex                                      ; no filenames, null lengths ;; @@742f 233
                 bne _local_1232_10                        ;; @@7430 233
 ;; @@7432 233
                 ldx #dossa-dosofl                        ; set some defaults from table ;; @@7432 233
_local_1232_20   lda dostbl,x                              ;; @@7434 233
                 sta dosofl,x                             ; start/end adr = $FFFF, la/fa/sa ;; @@7437 233
                 dex                                       ;; @@743a 233
                 bpl _local_1232_20                        ;; @@743b 233
 ;; @@743d 233
                 ldx _default_drive                       ; set default device   [900522] ;; @@743d 233
                 stx dosfa                                 ;; @@7440 233
                 ldx current_bank                         ; set current bank ;; @@7443 233
                 stx dosbnk                                ;; @@7446 233
 ;; @@7449 233
                 jsr chrgot                               ; get next character from command string ;; @@7449 233
                 bne parse1                               ; if eol stick with defaults, else begin parsing ;; @@744c 233
 ;; @@744e 233
 ;; @@744e 233
; Done parsing, check for errors, return if everything okay ;; @@744e 233
 ;; @@744e 233
done             pla                                      ; get aux error flag ;; @@744e 234
                 and parstx                               ; repeated or illegal params? ;; @@744f 234
                 +lbne snerr                              ; yes- report syntax error ;; @@7451 234
                 pla                                      ; get error flags ;; @@7454 234
                 jsr prmrpt                                ;; @@7455 234
                 lda parsts                                ;; @@7458 234
                 ldx parstx                                ;; @@745a 234
                 rts                                       ;; @@745c 234
 ;; @@745d 234
; .page ;; @@745d 234
; Parse given parameters.  what it is  example ;; @@745d 234
;     -------------------- --------- ;; @@745d 234
parse1           cmp #'"'                                  ;; @@745d 234
                 +lbeq name1                              ; explicit filename "file" ;; @@745f 234
                 cmp #'('                                  ;; @@7462 234
                 +lbeq name1                              ; evaluate filename (f$) ;; @@7464 234
                 cmp #'#'                                  ;; @@7467 234
                 beq logadr                               ; logical file number #1 ;; @@7469 234
                 cmp #'U'                                  ;; @@746b 234
                 beq unit1                                ; unit number  U8 ;; @@746d 234
                 cmp #'D'                                  ;; @@746f 234
                 beq drv1                                 ; drive number  D0 ;; @@7471 234
                 cmp #'P'                                  ;; @@7473 234
                 +lbeq doffl                              ; load/save address P1234 ;; @@7475 234
                 cmp #'B'                                  ;; @@7478 234
                 beq dbank1                               ; load/save bank   B0 ;; @@747a 234
                 cmp #'W'                                  ;; @@747c 234
                 beq reclen                               ; write mode  W ;; @@747e 234
                 cmp #'L'                                  ;; @@7480 234
                 beq reclen                               ; record length  L80 ;; @@7482 234
                 cmp #'R'                                  ;; @@7484 234
                 +lbeq recover                            ; recover mode  R ;; @@7486 234
                 cmp #'I'                                  ;; @@7489 234
                 beq ident                                ; ID   Ixx ;; @@748b 234
                 cmp #on_token                             ;; @@748d 234
; beq on1   ; ON token  ON ;; @@748f 234
 ;; @@748f 234
                 +lbne snerr                              ; none of these, syntax error ;; @@748f 234
 ;; @@7492 234
; .page ;; @@7492 234
on1              jsr on                                    ;; @@7492 234
                 +lbra del1                                ;; @@7495 234
 ;; @@7498 234
 ;; @@7498 234
unit1            jsr unit                                 ; do unit# parsing ;; @@7498 234
                 +lbra del1                               ; always ;; @@749b 234
 ;; @@749e 234
 ;; @@749e 234
dbank1           jsr dbank                                 ;; @@749e 234
                 +lbra del1                               ; always ;; @@74a1 234
 ;; @@74a4 234
 ;; @@74a4 234
logadr           lda #4                                    ;; @@74a4 234
                 jsr prmrpt                               ; check for repeated parameter ;; @@74a6 234
                 jsr gtbytc                               ; getval ;; @@74a9 234
                 txa                                      ; cpx #0 ;; @@74ac 234
                 +lbeq fcerr                              ; if illegal value ;; @@74ad 234
                 stx dosla                                 ;; @@74b0 234
                 lda #4                                   ; set logical address flag ;; @@74b3 234
                 +lbra del1                               ; get next parameter ;; @@74b5 234
 ;; @@74b8 234
 ;; @@74b8 234
reclen           tax                                      ; save char ;; @@74b8 234
                 lda #$40                                  ;; @@74b9 234
                 jsr prmrpt                               ; check for repeated parameter ;; @@74bb 234
                 cpx #'W'                                  ;; @@74be 234
                 bne _local_1233_10                        ;; @@74c0 234
                 jsr chrget                                ;; @@74c2 234
                 bra _local_1233_20                       ; set parsts ;; @@74c5 234
 ;; @@74c7 234
_local_1233_10   ldx #1                                   ; a kludge to allow  DOPEN#lf,"relfile",L  [911024] ;; @@74c7 234
                 jsr chrget                                ;; @@74c9 234
                 beq _local_1233_12                       ; eol? open existing rel file ;; @@74cc 234
                 jsr getbyt                               ; get reclen (was getval) ;; @@74ce 234
_local_1233_12   stx dosrcl                               ; store parcel ;; @@74d1 234
                 txa                                      ; cpx #0 ;; @@74d4 234
                 beq _local_1233_15                       ; zero illegal dosrcl ;; @@74d5 234
                 inx                                      ; cpx #255 ;; @@74d7 234
_local_1233_15   +lbeq fcerr                              ; illegal dosrcl ;; @@74d8 234
 ;; @@74db 234
_local_1233_20   lda #$40                                 ; set dosrcl flag & ;; @@74db 234
                 +lbra del1                                ;; @@74dd 234
 ;; @@74e0 234
 ;; @@74e0 234
drv1             lda #$10                                  ;; @@74e0 235
                 jsr prmrpt                               ; check for repeated parameter ;; @@74e2 235
                 jsr gtbytc                               ; getval ;; @@74e5 235
                 cpx #10                                   ;; @@74e8 235
                 +lbcs fcerr                              ; illegal drv# if >9 [allow 0: to 9: ?????] ;; @@74ea 235
                 stx dosds1                                ;; @@74ed 235
                 stx dosds2                                ;; @@74f0 235
                 lda #$10                                  ;; @@74f3 235
                 +lbra del1                                ;; @@74f5 235
 ;; @@74f8 235
 ;; @@74f8 235
ident            lda #$80                                 ; set ID flag ;; @@74f8 235
                 tsb dosflags                              ;; @@74fa 235
                 +lbne snerr                              ; repeated parameter ;; @@74fd 235
                 jsr chrget                               ; get next character ;; @@7500 235
                 cmp #'('                                 ; c65: allow I(ID$) syntax  [900710] ;; @@7503 235
                 bne _local_1234_10                        ;; @@7505 235
                 jsr frmstr                               ; get ID from var ;; @@7507 235
                 cmp #2                                    ;; @@750a 235
                 +lbcc err_mfn                            ; if length < 2, error ;; @@750c 235
                 ldy #0                                    ;; @@750f 235
                 jsr indin1_ram1                          ; else grab first two characters ;; @@7511 235
                 sta dosdid                                ;; @@7514 235
                 iny                                       ;; @@7517 235
                 jsr indin1_ram1                           ;; @@7518 235
                 sta dosdid+1                              ;; @@751b 235
                 bra delim1                               ; continue ;; @@751e 235
 ;; @@7520 235
_local_1234_10   sta dosdid                               ; m(txtptr => dosdid ;; @@7520 235
                 jsr chrget                                ;; @@7523 235
                 sta dosdid+1                              ;; @@7526 235
                 jsr chrget                               ; continue ;; @@7529 235
                 bra delim2                                ;; @@752c 235
 ;; @@752e 235
 ;; @@752e 235
doffl            lda #$02                                 ; check aux status ;; @@752e 236
                 jsr prxrpt                                ;; @@7530 236
                 jsr getoff                               ; get offset value ;; @@7533 236
                 sty dosofl                                ;; @@7536 236
                 sta dosofl+1                              ;; @@7539 236
                 lda #$02                                  ;; @@753c 236
dlimx1           ora parstx                               ; set aux status bits ;; @@753e 236
                 sta parstx                                ;; @@7540 236
                 bne delim1                               ; try for next param ;; @@7542 236
 ;; @@7544 236
 ;; @@7544 236
doffh            lda #$04                                  ;; @@7544 236
                 jsr prxrpt                                ;; @@7546 236
                 jsr getoff                                ;; @@7549 236
                 sty dosofh                                ;; @@754c 236
                 sta dosofh+1                              ;; @@754f 236
                 lda #$04                                  ;; @@7552 236
                 bra dlimx1                               ; set aux status ;; @@7554 236
 ;; @@7556 236
 ;; @@7556 236
recover          lda #$40                                  ;; @@7556 236
                 tsb dosflags                             ; set 'recover' bit ;; @@7558 236
                 +lbne snerr                              ; if repeated parameter ;; @@755b 236
                 jsr chrget                               ; continue ;; @@755e 236
                 bra delim2                                ;; @@7561 236
 ;; @@7563 236
 ;; @@7563 236
name1            lda #1                                   ; name1 allowed only once ;; @@7563 236
                 jsr newnam                               ; do name parsing ;; @@7565 236
                 sta dosf1l                                ;; @@7568 236
 ;; @@756b 236
                 ldy #0                                    ;; @@756b 236
_local_1235_10   jsr indin1_ram1                           ;; @@756d 236
                 sta savram,y                             ; copy name into buffer ;; @@7570 236
                 iny                                       ;; @@7573 236
                 cpy dosf1l                                ;; @@7574 236
                 bcc _local_1235_10                       ; ...copy all of it ;; @@7577 236
                 lda #1                                   ; set name1 flag ;; @@7579 236
 ;; @@757b 236
 ;; @@757b 236
del1             tsb parsts                                ;; @@757b 237
 ;; @@757d 237
delim1           jsr chrgot                                ;; @@757d 237
delim2           bne nxxx                                  ;; @@7580 237
                 +lbra done                               ; <cr>/<> => done ;; @@7582 237
 ;; @@7585 237
 ;; @@7585 237
next6            cmp #on_token                             ;; @@7585 237
                 +lbeq on1                                 ;; @@7587 237
                 cmp #to_token                            ; "to" token ;; @@758a 237
                 +lbne snerr                              ; syntax error ;; @@758c 237
 ;; @@758f 237
;  If "to" is not followed by an offset param, then do file2 params. ;; @@758f 237
;  Otherwise, do high offset and continue with file0 options. ;; @@758f 237
 ;; @@758f 237
                 jsr chrget                                ;; @@758f 237
                 cmp #'P'                                  ;; @@7592 237
                 bne pars22                                ;; @@7594 237
                 beq doffh                                 ;; @@7596 237
 ;; @@7598 237
 ;; @@7598 237
nxxx             cmp #','                                  ;; @@7598 237
                 bne next6                                 ;; @@759a 237
                 jsr chrget                                ;; @@759c 237
                 +lbra parse1                              ;; @@759f 237
 ;; @@75a2 237
 ;; @@75a2 237
parse2           jsr chrget                                ;; @@75a2 237
pars22           cmp #'D'                                  ;; @@75a5 237
                 beq _local_1236_10                        ;; @@75a7 237
                 cmp #on_token                            ; "on" token ;; @@75a9 237
                 beq on2                                   ;; @@75ab 237
                 cmp #'U'                                  ;; @@75ad 237
                 beq unit2                                 ;; @@75af 237
                 cmp #'"'                                  ;; @@75b1 237
                 beq name2                                 ;; @@75b3 237
                 cmp #'('                                  ;; @@75b5 237
                 beq name2                                 ;; @@75b7 237
 ;; @@75b9 237
_local_1236_10   lda #$20                                  ;; @@75b9 237
                 jsr prmrpt                               ; check for repeated parameter ;; @@75bb 237
                 jsr gtbytc                               ; getval ;; @@75be 237
                 cpx #10                                   ;; @@75c1 237
                 +lbcs fcerr                              ; illegal drive #  [allow 0: to 9: ????] ;; @@75c3 237
                 stx dosds2                                ;; @@75c6 237
                 lda #$20                                  ;; @@75c9 237
                 bra del2                                  ;; @@75cb 237
 ;; @@75cd 237
on2              jsr on                                    ;; @@75cd 238
                 bra del2                                  ;; @@75d0 238
 ;; @@75d2 238
 ;; @@75d2 238
unit2            jsr unit                                 ; do unit# parsing ;; @@75d2 238
                 bra del2                                 ; always ;; @@75d5 238
 ;; @@75d7 238
name2            lda #2                                   ; name2 allowed only once ;; @@75d7 238
                 jsr newnam                                ;; @@75d9 238
                 sta dosf2l                                ;; @@75dc 238
                 stx dosf2a                                ;; @@75df 238
                 sty dosf2a+1                              ;; @@75e2 238
 ;; @@75e5 238
                 lda #2                                   ; set filename2 flag & ;; @@75e5 238
del2             tsb parsts                               ; set flag in status ;; @@75e7 238
                 jsr chrgot                                ;; @@75e9 238
                 +lbeq done                               ; done on <cr>/<> ;; @@75ec 238
                 cmp #','                                  ;; @@75ef 238
                 beq parse2                                ;; @@75f1 238
                 cmp #on_token                            ; "on" token ;; @@75f3 238
                 beq on2                                   ;; @@75f5 238
                 cmp #'U'                                  ;; @@75f7 238
                 beq unit2                                 ;; @@75f9 238
                 +lbra snerr                               ;; @@75fb 238
 ;; @@75fe 238
 ;; @@75fe 238
on               jsr chrget                                ;; @@75fe 238
                 cmp #'B'                                  ;; @@7601 238
                 beq dbank                                 ;; @@7603 238
                 cmp #'U'                                  ;; @@7605 238
                 +lbne snerr                               ;; @@7607 238
 ;; @@760a 238
 ;; @@760a 238
unit             jsr gtbytc                               ; getval ;; @@760a 238
                 cpx #31                                   ;; @@760d 238
                 bcs err_ild                              ; error if >30 ;; @@760f 238
                 cpx #1                                   ; drive 1 = use system default drive  [910221] ;; @@7611 238
                 bne _local_1237_10                        ;; @@7613 238
                 ldx _default_drive                        ;; @@7615 238
                 bra _local_1237_20                        ;; @@7618 238
_local_1237_10   cpx #4                                    ;; @@761a 238
                 bcc err_ild                              ; error if <4 ;; @@761c 238
_local_1237_20   stx dosfa                                 ;; @@761e 238
                 lda #$08                                 ; set parser's unit flag ;; @@7621 238
                 rts                                       ;; @@7623 238
 ;; @@7624 238
 ;; @@7624 238
dbank            lda #$01                                 ; repeated param? ;; @@7624 239
                 jsr prxrpt                                ;; @@7626 239
                 jsr gtbytc                               ; getval ;; @@7629 239
; cpx #16  ;bank too large? ;; @@762c 239
; bcs fcerr ;illegal qty ;; @@762c 239
                 stx dosbnk                                ;; @@762c 239
                 lda #$01                                  ;; @@762f 239
                 tsb parstx                               ; set bnk bit in aux status ;; @@7631 239
                 lda #0                                   ; .a=std status wrd, no bits to set ;; @@7633 239
                 rts                                       ;; @@7635 239
 ;; @@7636 239
 ;; @@7636 239
newnam                                                     ;; @@7636 239
                 pha                                      ; save nam1,2 for subdir check later  [901115] ;; @@7636 239
                 jsr prmrpt                               ; check for repeated parameter ;; @@7637 239
                 jsr frmstr                                ;; @@763a 239
                 tax                                      ; save length of string ;; @@763d 239
                 beq err_mfn                              ; if length = 0 ;; @@763e 239
                 ldy #0                                    ;; @@7640 239
                 jsr indin1_ram1                           ;; @@7642 239
                 cmp #'@'                                 ; Replace file convention? ;; @@7645 239
                 bne _local_1238_10                       ; no ;; @@7647 239
                 lda #$80                                 ; yes- check for repeated param ;; @@7649 239
                 jsr prmrpt                                ;; @@764b 239
                 smb7 parsts                              ; set "@" flag ;; @@764e 239
                 dex                                      ; decrement length ;; @@7650 239
                 inw index1                               ; increment past "@" ;; @@7651 239
                 bra lenchk                                ;; @@7653 239
 ;; @@7655 239
_local_1238_10   cmp #'/'                                 ; Subdirectory (partition)?   [901115] ;; @@7655 239
                 bne lenchk                               ; no ;; @@7657 239
                 pla                                      ; yes- recall nam1 or nam2 ;; @@7659 239
                 tsb dosflags                             ; set appropriate '/' flag (.a=1 or 2) ;; @@765a 239
                 dex                                      ; decrement length ;; @@765d 239
                 inw index1                               ; increment past "@" ;; @@765e 239
                 !text $89                                 ;; @@7660 239
 ;; @@7661 239
 ;; @@7661 239
lenchk           pla                                      ; [901115] ;; @@7661 240
                 txa                                      ; Check filename length ;; @@7662 240
                 beq err_mfn                              ; too small, missing filename  [901115] ;; @@7663 240
; cmp #17  ;  ???? (problem if name has ',P') ;; @@7665 240
; bcs errlen ; too long ;; @@7665 240
                 ldx index1                                ;; @@7665 240
                 ldy index1+1                             ; ok- return pointer to filename ;; @@7667 240
                 rts                                       ;; @@7669 240
 ;; @@766a 240
 ;; @@766a 240
err_mfn          ldx #err_missing_fname                    ;; @@766a 240
                 !text $2c                                 ;; @@766c 240
 ;; @@766d 240
err_ild          ldx #err_illegal_device                   ;; @@766d 240
                 !text $2c                                 ;; @@766f 240
 ;; @@7670 240
errlen           ldx #errls                               ; string or filename too long ;; @@7670 240
                 +lbra error                               ;; @@7672 240
 ;; @@7675 240
 ;; @@7675 240
 ;; @@7675 240
; Get next value routine (use gtbytc instead!) ;; @@7675 240
 ;; @@7675 240
;getval jsr chrget ;get nxt chr ;; @@7675 240
; beq snerr ;if end of statement ;; @@7675 240
; bra getbyt ;       [911024] ;; @@7675 240
 ;; @@7675 240
; bcc getbyt ;can be numeric, go evaluate it  why this crap ???? ;; @@7675 240
; jsr chkopn ;or a "(" ;; @@7675 240
; jsr getbyt ;anything else is an error ;; @@7675 240
; bra chkcls ;need closing ")" ;; @@7675 240
 ;; @@7675 240
 ;; @@7675 240
 ;; @@7675 240
; Get next 2-byte expression.  Exit: .a,.y (high,low) value ;; @@7675 240
 ;; @@7675 240
getoff           jsr chrget                               ; get nxt chr ;; @@7675 240
                 +lbeq snerr                              ; if end of statement ;; @@7678 240
                 +lbcc getwrd                             ; can be num. const, go evaluate it ;; @@767b 240
                 jsr chkopn                               ; or a "(" ;; @@767e 240
                 jsr getwrd                               ; expr ;; @@7681 240
                 jsr chkcls                               ; need closing ")" ;; @@7684 240
                 ldy poker                                 ;; @@7687 240
                 lda poker+1                               ;; @@7689 240
                 rts                                       ;; @@768b 240
 ;; @@768c 240
 ;; @@768c 240
 ;; @@768c 240
; Prmrpt checks for a repeated parameter. ;; @@768c 240
; ;; @@768c 240
; Entry: .a contains parsts flag to check ;; @@768c 240
 ;; @@768c 240
 ;; @@768c 240
prmrpt           and parsts                               ; compare mask with status ;; @@768c 240
                 +lbne snerr                              ; error if bit previously set ;; @@768e 240
                 rts                                       ;; @@7691 240
 ;; @@7692 240
 ;; @@7692 240
 ;; @@7692 240
; Prxrpt checks for a repeated parameter. ;; @@7692 240
; ;; @@7692 240
; Entry: .a contains parstx flag to check ;; @@7692 240
 ;; @@7692 240
 ;; @@7692 240
prxrpt           and parstx                               ; and with parstx ;; @@7692 240
                 +lbne snerr                              ; if bit previously set ;; @@7694 240
                 rts                                       ;; @@7697 240
 ;; @@7698 240
;.end ;; @@7698 240
; .page ;; @@7698 240
; .subttl  DOS 3 ;; @@7698 240
 ;; @@7698 240
; CBM-2001 BASIC-4 disk verb processors.  -- rsr 7-24-79 -- ;; @@7698 240
; ;; @@7698 240
; Token Table Definitions ;; @@7698 240
 ;; @@7698 240
xsca             =$c2                                     ; send dossca ;; @@7698 240
xid              =$d0                                     ; sends disk id ;; @@7698 240
xd1              =$d1                                     ; sends dosds1 ;; @@7698 240
xd2              =$d2                                     ; sends dosds2 ;; @@7698 240
xrec             =$e0                                     ; sends S for SEQ, or dosrcl ;; @@7698 240
xwrt             =$e1                                     ; sends W or L ;; @@7698 240
xrcl             =$e2                                     ; send low ((poker)) ;; @@7698 240
xfat             =$f0                                     ; sends "@" or "/" if specified ;; @@7698 240
xfn1             =$f1                                     ; sends filename1 ;; @@7698 240
xfn2             =$f2                                     ; sends filename2 ;; @@7698 240
 ;; @@7698 240
 ;; @@7698 240
; Tabld - used to build disk command strings ;; @@7698 240
 ;; @@7698 240
tabld                                                      ;; @@7698 240
finit            = $ff                                    ; Dclear ;; @@7698 240
                 !text "I",xd1                             ;; @@7698 240
 ;; @@769a 240
fdir             = *-tabld-1                              ; Dir ;; @@769a 240
                 !text "$",xd1,":",xfn1                    ;; @@769a 240
 ;; @@769e 240
fdirr            = *-tabld-1                              ; Recover Dir  [901024] ;; @@769e 240
                 !text "_",xd1,":",xfn1                   ; ('_'=CBM backarrow, $5F) ;; @@769e 240
 ;; @@76a2 240
fopn             = *-tabld-1                              ; Dopen ;; @@76a2 240
                 !text xfat,xd1,":",xfn1,",",xwrt,",",xrec  ;; @@76a2 240
 ;; @@76aa 240
fopnseq          = *-tabld-1                              ; Type   [900801] ;; @@76aa 240
                 !text xfat,xd1,":",xfn1,",S"              ;; @@76aa 240
 ;; @@76b0 240
fsavseq          = *-tabld-1                              ; EDIT_SAVE  [910620] ;; @@76b0 240
                 !text xfat,xd1,":",xfn1,",S,W"            ;; @@76b0 240
 ;; @@76b8 240
fconc            = *-tabld-1                              ; Concat ;; @@76b8 240
                 !text "C",xd2,":",xfn2,"=",xd2,":",xfn2,","  ;; @@76b8 240
 ;; @@76c1 240
fapn             = *-tabld-1                              ; Append ;; @@76c1 240
                 !text xd1,":",xfn1,",A"                   ;; @@76c1 240
 ;; @@76c6 240
fhed             = *-tabld-1                              ; Header ;; @@76c6 240
                 !text "N",xd1,":",xfn1,",",xid            ;; @@76c6 240
 ;; @@76cc 240
fcoll            = *-tabld-1                              ; Collect ;; @@76cc 240
                 !text "V",xd1                             ;; @@76cc 240
 ;; @@76ce 240
fbak             = *-tabld-1                              ; Backup ;; @@76ce 240
                 !text "D",xd2,"=",xd1                     ;; @@76ce 240
 ;; @@76d2 240
fcopy            = *-tabld-1                              ; Copy ;; @@76d2 240
                 !text "C",xd2,":",xfn2,"=",xd1,":",xfn1   ;; @@76d2 240
 ;; @@76da 240
fren             = *-tabld-1                              ; Rename ;; @@76da 240
                 !text "R",xd1,":",xfn2,"=",xd1,":",xfn1   ;; @@76da 240
 ;; @@76e2 240
fscr             = *-tabld-1                              ; Scratch ;; @@76e2 240
                 !text "S",xd1,":",xfn1                    ;; @@76e2 240
 ;; @@76e6 240
frscr            = *-tabld-1                              ; Recover Del  [901024] ;; @@76e6 240
                 !text "F-R",xd1,":",xfn1                  ;; @@76e6 240
 ;; @@76ec 240
fdisk            = *-tabld-1                              ; Disk command  [910123] ;; @@76ec 240
                 !text xfat,xfn1                          ; pass '/' [911030] ;; @@76ec 240
 ;; @@76ee 240
frec             = *-tabld-1                              ; Record ;; @@76ee 240
                 !text "P",xsca,xrcl,xrec                  ;; @@76ee 240
 ;; @@76f2 240
; .page ;; @@76f2 240
; Send parameters to device ;; @@76f2 240
; ;; @@76f2 240
; Entry: .a = number of bytes in format ;; @@76f2 240
;  .y = pointer to TABLD entry ;; @@76f2 240
 ;; @@76f2 240
sendp            sta xcnt                                 ; save number of string bytes ;; @@76f2 240
                 phy                                       ;; @@76f5 240
                 jsr Clear_DS                             ; clear old status ;; @@76f6 240
 ;; @@76f9 240
                 ldx #0                                    ;; @@76f9 240
sdp1             pla                                       ;; @@76fb 240
                 dec xcnt                                  ;; @@76fc 240
                 bmi tranr                                 ;; @@76ff 240
                 tay                                       ;; @@7701 240
                 iny                                      ; move down table ;; @@7702 240
                 phy                                       ;; @@7703 240
                 lda tabld,y                              ; get next entry ;; @@7704 240
                 bpl sdp5                                 ; if not escape code ;; @@7707 240
                 cmp #xsca                                ; if not secondary address ;; @@7709 240
                 beq rsca                                  ;; @@770b 240
                 cmp #xid                                  ;; @@770d 240
                 beq rid                                  ; if disk id ;; @@770f 240
                 cmp #xrcl                                 ;; @@7711 240
                 +lbeq rdcn                               ; if record number ;; @@7713 240
                 cmp #xwrt                                 ;; @@7716 240
                 beq rwrt                                 ; if W or L ;; @@7718 240
                 cmp #xfat                                 ;; @@771a 240
                 beq rfat                                 ; if "@" symbol request ;; @@771c 240
                 cmp #xfn1                                 ;; @@771e 240
                 +lbeq rsfn                               ; if filename 1 ;; @@7720 240
                 cmp #xfn2                                 ;; @@7723 240
                 +lbeq rdfn                               ; if filename 2 ;; @@7725 240
                 cmp #xrec                                 ;; @@7728 240
                 bne sdp2                                 ; if not record type ;; @@772a 240
                 lda dosrcl                               ; get rec # ;; @@772c 240
                 cmp #1                                   ; kludge to allow DOPEN#lf,"relfile",L  [911024] ;; @@772f 240
                 bne sdp5                                 ; (note RECORD byte 0 = byte 1 anyhow) ;; @@7731 240
                 dec                                       ;; @@7733 240
                 bra sdp5                                 ; always branch ;; @@7734 240
 ;; @@7736 240
sdp2             cmp #xd1                                  ;; @@7736 240
                 bne sdp3                                 ; if not drive 1 ;; @@7738 240
                 lda dosds1                                ;; @@773a 240
                 bra sdp4                                 ; always branch ;; @@773d 240
 ;; @@773f 240
sdp3             cmp #xd2                                  ;; @@773f 240
                 bne sdp1                                 ; if not drive 2, continue ;; @@7741 240
                 lda dosds2                                ;; @@7743 240
sdp4             ora #'0'                                 ; change # to PETSCII ;; @@7746 240
 ;; @@7748 240
sdp5             sta dosstr,x                             ; else into buffer ;; @@7748 240
                 inx                                       ;; @@774b 240
                 bra sdp1                                 ; always ;; @@774c 240
 ;; @@774e 240
 ;; @@774e 240
tranr            txa                                      ; length to a ;; @@774e 240
                 pha                                       ;; @@774f 240
                 ldx #<dosstr                             ; set filename ;; @@7750 240
                 ldy #>dosstr                              ;; @@7752 240
                 jsr _setnam                               ;; @@7754 240
 ;; @@7757 240
                 lda dosla                                ; set channel ;; @@7757 240
                 ldx dosfa                                 ;; @@775a 240
                 ldy dossa                                 ;; @@775d 240
                 jsr _setlfs                               ;; @@7760 240
 ;; @@7763 240
                 pla                                       ;; @@7763 240
                 rts                                       ;; @@7764 240
 ;; @@7765 240
 ;; @@7765 240
 ;; @@7765 240
 ;; @@7765 240
rsca             lda dossa_temp                           ; secondary address (record) ;; @@7765 240
                 bra sdp5                                 ; always ;; @@7768 240
 ;; @@776a 240
 ;; @@776a 240
rfat             bbr7 parsts,_local_1239_10               ; if "@" not encountered ;; @@776a 240
                 lda #'@'                                  ;; @@776d 240
                 bra sdp5                                 ; always ;; @@776f 240
 ;; @@7771 240
_local_1239_10   lda dosflags                              ;; @@7771 240
                 lsr                                       ;; @@7774 240
                 bcc sdp1                                 ; if "/" not encountered ;; @@7775 240
                 lda #'/'                                  ;; @@7777 240
                 bra sdp5                                  ;; @@7779 240
 ;; @@777b 240
 ;; @@777b 240
; ID subroutine ;; @@777b 240
 ;; @@777b 240
rid              lda dosdid                               ; include id ;; @@777b 241
                 sta dosstr,x                              ;; @@777e 241
                 inx                                       ;; @@7781 241
                 lda dosdid+1                              ;; @@7782 241
                 bra sdp5                                 ; always ;; @@7785 241
 ;; @@7787 241
 ;; @@7787 241
rwrt             lda dosrcl                               ; check for L or W ;; @@7787 241
                 beq _local_1240_10                       ; zero then write ;; @@778a 241
                 lda #'L'                                  ;; @@778c 241
                 bra sdp5                                 ; always ;; @@778e 241
 ;; @@7790 241
_local_1240_10   lda #'S'                                 ; send W,S ;; @@7790 241
                 sta dosrcl                                ;; @@7792 241
                 lda #'W'                                  ;; @@7795 241
                 bra sdp5                                 ; always ;; @@7797 241
 ;; @@7799 241
 ;; @@7799 241
 ;; @@7799 241
; Move record number ;; @@7799 241
 ;; @@7799 241
rdcn             lda poker                                 ;; @@7799 242
                 sta dosstr,x                              ;; @@779b 242
                 lda poker+1                               ;; @@779e 242
                 inx                                       ;; @@77a0 242
                 bra sdp5                                 ; always ;; @@77a1 242
 ;; @@77a3 242
 ;; @@77a3 242
; Move file names ;; @@77a3 242
 ;; @@77a3 242
rsfn             ldy dosf1l                               ; file name 1: get length ;; @@77a3 242
                 beq rdrt0                                ; if null string ;; @@77a6 242
 ;; @@77a8 242
                 ldy #0                                   ; move name to dosstr ;; @@77a8 242
_local_1241_10   lda savram,y                              ;; @@77aa 242
                 sta dosstr,x                              ;; @@77ad 242
                 inx                                       ;; @@77b0 242
                 iny                                       ;; @@77b1 242
                 cpy dosf1l                                ;; @@77b2 242
                 bne _local_1241_10                       ; if move not complete ;; @@77b5 242
                 bra rdrt1                                ; always ;; @@77b7 242
 ;; @@77b9 242
 ;; @@77b9 242
rdfn             lda dosf2a                                ;; @@77b9 243
                 sta index1                                ;; @@77bc 243
                 lda dosf2a+1                              ;; @@77be 243
                 sta index1+1                              ;; @@77c1 243
                 ldy dosf2l                                ;; @@77c3 243
                 beq rdrt0                                ; if null string ;; @@77c6 243
 ;; @@77c8 243
                 ldy #0                                   ; move name to dosstr ;; @@77c8 243
_local_1242_10   jsr indin1_ram1                           ;; @@77ca 243
                 sta dosstr,x                              ;; @@77cd 243
                 inx                                       ;; @@77d0 243
                 iny                                       ;; @@77d1 243
                 cpy dosf2l                                ;; @@77d2 243
                 bne _local_1242_10                       ; if move not complete ;; @@77d5 243
                 !text $89                                ; hop ;; @@77d7 243
 ;; @@77d8 243
rdrt0            dex                                      ; case cdd=sd ;; @@77d8 244
rdrt1            +lbra sdp1                               ; get next symbol ;; @@77d9 244
 ;; @@77dc 244
; .page ;; @@77dc 244
; Syntax checker DOS write ;; @@77dc 244
 ;; @@77dc 244
chk1             and #$e6                                 ; for HEADER, DLOAD, SCRATCH, TYPE, LIST ;; @@77dc 244
                 +lbne snerr                               ;; @@77de 244
 ;; @@77e1 244
chk2             lda parsts                               ; for DSAVE ;; @@77e1 244
                 and #1                                    ;; @@77e3 244
                 cmp #1                                   ; check required parameters ;; @@77e5 244
                 +lbne snerr                              ; error if 1 missing ;; @@77e7 244
                 lda parsts                               ; reload for return ;; @@77ea 244
                 rts                                       ;; @@77ec 244
 ;; @@77ed 244
 ;; @@77ed 244
chk3             and #$e7                                 ; for COLLECT ;; @@77ed 244
                 +lbne snerr                              ; check optional parameters ;; @@77ef 244
                 rts                                       ;; @@77f2 244
 ;; @@77f3 244
 ;; @@77f3 244
chk4             and #$c4                                 ; for COPY, CONCAT ;; @@77f3 244
                 +lbne snerr                              ; check optional parameters ;; @@77f5 244
                 lda parsts                                ;; @@77f8 244
chk5             and #3                                   ; for RENAME ;; @@77fa 244
                 cmp #3                                   ; check required parameters ;; @@77fc 244
                 +lbne snerr                               ;; @@77fe 244
                 lda parsts                               ; reload for return ;; @@7801 244
                 rts                                       ;; @@7803 244
 ;; @@7804 244
 ;; @@7804 244
chk6             and #5                                   ; for APPEND, DOPEN ;; @@7804 244
                 cmp #5                                   ; check required parameters ;; @@7806 244
                 +lbne snerr                               ;; @@7808 244
                 lda parsts                               ; reload for rts ;; @@780b 244
                 rts                                       ;; @@780d 244
 ;; @@780e 244
;.end ;; @@780e 244
; .page ;; @@780e 244
; .subttl  DOS 4 ;; @@780e 244
 ;; @@780e 244
; Allocate DS$ if nesessary, but use old DS$ string otherwise ;; @@780e 244
; Called by DS$ and DS ;; @@780e 244
 ;; @@780e 244
Check_DS                                                  ; chkds. ;; @@780e 244
                 lda dsdesc                                ;; @@780e 244
                 beq Read_DS_1                            ; branch if DS$ is not in memory ;; @@7810 244
                 rts                                      ; else return & use old one ;; @@7812 244
 ;; @@7813 244
 ;; @@7813 244
; Allocate DS$ if necessary & Read DOS error channel ;; @@7813 244
 ;; @@7813 244
Read_DS                                                   ; errchl. ;; @@7813 244
                 lda dsdesc                               ; has DS$ space been allocated? ;; @@7813 244
                 bne Read_DS_2                            ; yes ;; @@7815 244
 ;; @@7817 244
Read_DS_1                                                  ;; @@7817 244
                 lda #40                                  ; no- get 40 char string ;; @@7817 244
                 sta dsdesc                                ;; @@7819 244
                 jsr getspa                               ; allocate space for DS$ ;; @@781b 244
                 stx dsdesc+1                             ; low address of string ;; @@781e 244
                 sty dsdesc+2                             ; high   "    "    " ;; @@7820 244
                 ldx #dsdesc+1                            ; set up string back pointer to dsdesc ;; @@7822 244
                 ldy #40                                   ;; @@7824 244
                 lda #<dsdesc                              ;; @@7826 244
                 jsr sta_far_ram1                         ; sta (dsdesc+1),y ;; @@7828 244
                 iny                                       ;; @@782b 244
                 lda #>dsdesc                              ;; @@782c 244
                 jsr sta_far_ram1                         ; sta (dsdesc+1),y ;; @@782e 244
 ;; @@7831 244
Read_DS_2                                                  ;; @@7831 244
                 ldx dosfa                                ; fa ;; @@7831 244
                 cpx #2                                    ;; @@7834 244
                 bcs _local_1243_10                       ; if =0 or 1 use default  [910429] ;; @@7836 244
                 ldx _default_drive                       ; (was dosffn)   [900710] ;; @@7838 244
                 stx dosfa                                 ;; @@783b 244
_local_1243_10   lda #doslfn                              ; la (reserved la) ;; @@783e 244
                 ldy #$6f                                 ; sa (command channel) ;; @@7840 244
                 jsr _setlfs                               ;; @@7842 244
                 lda #0                                   ; no name (so no setbank) ;; @@7845 244
                 jsr _setnam                               ;; @@7847 244
                 jsr _open                                ; get command channel ;; @@784a 244
                 ldx #doslfn                               ;; @@784d 244
                 jsr _chkin                                ;; @@784f 244
                 bcs _local_1243_40                       ; a problem (file already open??) ;; @@7852 244
 ;; @@7854 244
                 ldy #$ff                                  ;; @@7854 244
_local_1243_20   iny                                      ; read disk error message ;; @@7856 244
                 jsr _basin                                ;; @@7857 244
                 cmp #cr                                   ;; @@785a 244
                 beq _local_1243_30                       ; if eol ;; @@785c 244
                 ldx #dsdesc+1                             ;; @@785e 244
                 jsr sta_far_ram1                         ; sta (dsdesc+1),y copy to DS$ ;; @@7860 244
                 cpy #40                                   ;; @@7863 244
                 bcc _local_1243_20                       ; loop unless too long ;; @@7865 244
 ;; @@7867 244
_local_1243_30   lda #0                                   ; errend. ;; @@7867 244
                 ldx #dsdesc+1                            ; terminate DS$ with a null ;; @@7869 244
                 jsr sta_far_ram1                         ; sta (dsdesc+1),y ;; @@786b 244
 ;; @@786e 244
                 jsr _clrch                               ; shut down command channel ;; @@786e 244
                 lda #doslfn                               ;; @@7871 244
                 sec                                      ; not a real close ;; @@7873 244
                 jmp _close                               ; close it and rts ;; @@7874 244
 ;; @@7877 244
_local_1243_40   pha                                      ; errbad. ;; @@7877 244
                 jsr _local_1243_30                        ;; @@7878 244
                 jsr Clear_DS                             ; flag 'no DS available' ;; @@787b 244
                 plx                                      ; get error ;; @@787e 244
                 +lbra error                               ;; @@787f 244
 ;; @@7882 244
; .page ;; @@7882 244
; Clear_DS subroutine - forget current DS$ message, if any ;; @@7882 244
; ;; @@7882 244
 ;; @@7882 244
Clear_DS                                                  ; oldclr. ;; @@7882 245
                 lda dsdesc                               ; check for allocation ;; @@7882 245
                 beq _local_1244_10                       ; branch if not allocated ;; @@7884 245
 ;; @@7886 245
                 phy                                      ; mark current DS$ string as garbage ;; @@7886 245
                 phx                                       ;; @@7887 245
; lda #40   ;   standard DS$ allocation ;; @@7888 245
                 tay                                       ;; @@7888 245
                 ldx #dsdesc+1                             ;; @@7889 245
                 jsr sta_far_ram1                         ; sta (dsdesc+1),y length of garbage ;; @@788b 245
                 iny                                       ;; @@788e 245
                 lda #$ff                                  ;; @@788f 245
                 jsr sta_far_ram1                         ; sta (dsdesc+1),y garbage flagged ;; @@7891 245
                 inc                                       ;; @@7894 245
                 sta dsdesc                               ; (0)    kill DS$ ;; @@7895 245
                 plx                                       ;; @@7897 245
                 ply                                       ;; @@7898 245
 ;; @@7899 245
_local_1244_10   rts                                       ;; @@7899 245
 ;; @@789a 245
; .page ;; @@789a 245
; Read DOS error message, but don't care what it is.  Want to stop disk LED blink. ;; @@789a 245
; ;; @@789a 245
 ;; @@789a 245
Suck_DS                                                    ;; @@789a 246
                 ldx dosfa                                ; fa ;; @@789a 246
                 lda #doslfn                              ; la (reserved la) ;; @@789d 246
                 ldy #$6f                                 ; sa (command channel) ;; @@789f 246
                 jsr _setlfs                               ;; @@78a1 246
                 lda #0                                   ; no name (so no setbank) ;; @@78a4 246
                 jsr _setnam                               ;; @@78a6 246
                 jsr _open                                ; get command channel ;; @@78a9 246
                 ldx #doslfn                               ;; @@78ac 246
                 jsr _chkin                                ;; @@78ae 246
                 bcs _local_1245_20                       ; skip input if problem ;; @@78b1 246
 ;; @@78b3 246
_local_1245_10   jsr _basin                               ; read disk error message ;; @@78b3 246
                 cmp #cr                                   ;; @@78b6 246
                 bne _local_1245_10                       ; loop until eol ;; @@78b8 246
 ;; @@78ba 246
_local_1245_20   jsr _clrch                               ; shut down command channel ;; @@78ba 246
                 lda #doslfn                               ;; @@78bd 246
                 sec                                      ; not a real close ;; @@78bf 246
                 jmp _close                               ; close it ;; @@78c0 246
 ;; @@78c3 246
; .page ;; @@78c3 246
; R-U-sure subroutine ;; @@78c3 246
 ;; @@78c3 246
are_you_sure                                               ;; @@78c3 247
 ;; @@78c3 247
                 bbs7 runmod,response_fake                ; branch if not direct mode ;; @@78c3 247
 ;; @@78c6 247
                 jsr _primm                               ; else prompt user for y/n answer ;; @@78c6 247
                 !text "ARE YOU SURE? ", 0                 ;; @@78c9 247
 ;; @@78d8 247
 ;; @@78d8 247
response_get                                               ;; @@78d8 247
                 jsr _clrch                               ; clear channel for basin ;; @@78d8 247
                 jsr _basin                               ; next char ;; @@78db 247
                 pha                                      ; save first char of reply ;; @@78de 247
 ;; @@78df 247
_local_1246_10   cmp #cr                                  ; eat chars until end of line ;; @@78df 247
                 beq _local_1246_20                       ; if cr received, exit ;; @@78e1 247
                 jsr _basin                                ;; @@78e3 247
                 bne _local_1246_10                       ; continue to ignore ;; @@78e6 247
 ;; @@78e8 247
_local_1246_20   jsr _bsout                               ; new line     [910212] FAB ;; @@78e8 247
                 pla                                       ;; @@78eb 247
                 cmp #'Y'                                 ; z set means ans=y..... ;; @@78ec 247
                 rts                                       ;; @@78ee 247
 ;; @@78ef 247
 ;; @@78ef 247
response_fake                                              ;; @@78ef 248
                 lda #0                                   ; ...or not in direct mode ;; @@78ef 248
                 rts                                       ;; @@78f1 248
 ;; @@78f2 248
;.end ;; @@78f2 248
; .page ;; @@78f2 248
; .subttl  General Purpose Subroutines ;; @@78f2 248
 ;; @@78f2 248
;***************************************************************** ;; @@78f2 248
;  OPTWRD - get an optional, unsigned 2-byte value in y,a. ;; @@78f2 248
; ;; @@78f2 248
;      case 1 : pointer at end of line: ;; @@78f2 248
;   return a=y=0, clear c to flag 'default' ;; @@78f2 248
;      case 2 : pointer is at comma, next non-blank is also a comma: ;; @@78f2 248
;   return a=y=0, clear c to flag 'default' ;; @@78f2 248
;      case 3 : pointer is at comma, next non-blank is not a comma: ;; @@78f2 248
;   get word in y,a, set c to flag 'non-default' ;; @@78f2 248
;***************************************************************** ;; @@78f2 248
 ;; @@78f2 248
optwrd           jsr chrgot                                ;; @@78f2 248
                 beq _local_1247_10                        ;; @@78f5 248
                 jsr chkcom                                ;; @@78f7 248
                 cmp #','                                  ;; @@78fa 248
                 beq _local_1247_10                        ;; @@78fc 248
                 jsr getwrd                                ;; @@78fe 248
                 sec                                       ;; @@7901 248
                 rts                                       ;; @@7902 248
 ;; @@7903 248
_local_1247_10   lda #0                                    ;; @@7903 248
                 tay                                       ;; @@7905 248
 ;; @@7906 248
optw99           clc                                       ;; @@7906 249
                 rts                                       ;; @@7907 249
 ;; @@7908 249
; .page ;; @@7908 249
comsad           jsr chkcom                               ; get a comma & signed 2-byte arg in y,a   [910307] ;; @@7908 249
                 +lbra sadwrd                              ;; @@790b 249
 ;; @@790e 249
 ;; @@790e 249
 ;; @@790e 249
optsad           jsr chrgot                               ; get a comma & optional, signed 2-byte arg in y,a [910307] ;; @@790e 249
                 beq _local_1248_10                       ; eol, therefore this arg is not specified ;; @@7911 249
                 jsr chkcom                               ; eat comma ;; @@7913 249
                 cmp #','                                 ; is next a comma too? ;; @@7916 249
                 beq _local_1248_10                       ; yes, therefore this arg is not specified ;; @@7918 249
                 jsr sadwrd                               ; get signed word ;; @@791a 249
                 sec                                       ;; @@791d 249
                 rts                                       ;; @@791e 249
 ;; @@791f 249
_local_1248_10   lda #0                                   ; default optional arg to zero ;; @@791f 249
                 tay                                       ;; @@7921 249
                 clc                                       ;; @@7922 249
                 rts                                       ;; @@7923 249
 ;; @@7924 249
; .page ;; @@7924 249
;***************************************************************** ;; @@7924 249
;  OPTBYT - get an optional 1 byte value in x. ;; @@7924 249
; ;; @@7924 249
;  Enter with default value in x. ;; @@7924 249
; ;; @@7924 249
;      case 1 : pointer at end of line: ;; @@7924 249
;   return default x. ;; @@7924 249
;      case 2 : pointer is at comma, next non-blank is also a comma: ;; @@7924 249
;   return default x. ;; @@7924 249
;      case 3 : pointer is at comma, next non-blank is not a comma: ;; @@7924 249
;   get byte in x. ;; @@7924 249
;***************************************************************** ;; @@7924 249
 ;; @@7924 249
optzer           ldx #0                                   ; optional byte, with default=0 ;; @@7924 250
 ;; @@7926 250
optbyt           jsr chrgot                                ;; @@7926 250
                 beq optw99                               ; EOL: clc/rts ;; @@7929 250
                 jsr chkcom                                ;; @@792b 250
                 cmp #','                                  ;; @@792e 250
                 beq optw99                               ; Comma: clc/rts ;; @@7930 250
                 jsr getbyt                                ;; @@7932 250
                 sec                                       ;; @@7935 250
                 rts                                       ;; @@7936 250
 ;; @@7937 250
; .page ;; @@7937 250
prtdec                                                     ;; @@7937 250
                 phy                                       ;; @@7937 250
                 phx                                       ;; @@7938 250
                 tax                                      ; prints decimal value of chr in .a ;; @@7939 250
                 lda #0                                    ;; @@793a 250
                 jsr linprt                                ;; @@793c 250
                 plx                                       ;; @@793f 250
                 ply                                       ;; @@7940 250
                 rts                                       ;; @@7941 250
 ;; @@7942 250
 ;; @@7942 250
 ;; @@7942 250
retpat                                                    ; f.bowen ;; @@7942 250
                 dey                                      ; [910828] ;; @@7942 250
                 lda (fndpnt),y                           ; restore pointers ;; @@7943 250
                 sta txtptr+1                              ;; @@7945 250
                 dey                                       ;; @@7947 250
                 lda (fndpnt),y                            ;; @@7948 250
                 sta txtptr                                ;; @@794a 250
                 dey                                       ;; @@794c 250
                 lda (fndpnt),y                            ;; @@794d 250
 ;; @@794f 250
                 sta curlin+1                             ; fixes a problem when RETURNing to a GOSUB in direct mode ;; @@794f 250
                 dey                                      ; or LOOPing to a DO in direct mode. 'curlin+1' must not be ;; @@7951 250
                 tax                                      ; restored to $ff without also resetting 'runmod' ;; @@7952 250
                 inx                                       ;; @@7953 250
                 bne _local_1249_10                       ; branch if GOSUB or DO was from a program ;; @@7954 250
                 lda #%11000000                            ;; @@7956 250
                 trb runmod                               ; else force return to direct mode ;; @@7958 250
 ;; @@795a 250
_local_1249_10   lda (fndpnt),y                            ;; @@795a 250
                 sta curlin                                ;; @@795c 250
                 rts                                       ;; @@795e 250
 ;; @@795f 250
 ;; @@795f 250
vbits            !text $01,$02,$04,$01,$02,$04            ; for stereo filter, volume bit setting ;; @@795f 251
sbits            !text $01,$02,$04,$08,$10,$20,$40,$80     ;; @@7965 251
rbits            !text $80,$40,$20,$10,$08,$04,$02,$01     ;; @@796d 251
 ;; @@7975 251
;.end ;; @@7975 251
; .page ;; @@7975 251
; .subttl BASIC IRQ Handler ;; @@7975 251
 ;; @@7975 251
basic_irq                                                  ;; @@7975 251
; lda _vicIRQ  ;a VIC raster interrupt? ;; @@7975 251
; and #%10000001  ; (used to update moving sprites & sound stuff) ;; @@7975 251
; cmp #%10000001 ;; @@7975 251
; bne collision_irq ; no, go check other VIC interrupts ;; @@7975 251
 ;; @@7975 251
                 lda irq_wrap_flag                        ; filter out wrapped IRQ calls (allows interruptable code) ;; @@7975 251
                 beq _local_1250_1                        ; it's ok ;; @@7978 251
                 rts                                      ; exit- we're already handling one interrupt ;; @@797a 251
 ;; @@797b 251
_local_1250_1    inc irq_wrap_flag                        ; shut the door ;; @@797b 251
                 cli                                      ; but leave the window open ;; @@797e 251
 ;; @@797f 251
; .page ;; @@797f 251
; Test if there was a VIC collision/light pen interrupt ;; @@797f 251
 ;; @@797f 251
collision_irq                                              ;; @@797f 252
; sei ;; @@797f 252
                 lda _vicIRQ                              ; check VIC IRQ flags ;; @@797f 252
                 and #%00001110                           ; mask all but lp, s/s, and s/bgnd flags ;; @@7981 252
                 beq _local_1251_40                       ; exit if none set ;; @@7983 252
                 trb _vicIRQ                              ; else reset flags we're going to handle ;; @@7985 252
                 lsr                                      ; shift out raster interrupt bit (not used) ;; @@7987 252
 ;; @@7988 252
; Test for 3 types of collision interrupts : sprite/sprite, sprite/bgnd, & light pen ;; @@7988 252
 ;; @@7988 252
                 ldy #1                                   ; loop for sprite/bgnd and sprite/sprite collision check ;; @@7988 252
_local_1251_10   lsr                                       ;; @@798a 252
                 bcc _local_1251_30                       ; bit not set ==> not source of interrupt ;; @@798b 252
 ;; @@798d 252
                 pha                                       ;; @@798d 252
                 lda vic+30,y                             ; accumulate collision data (resets register) ;; @@798e 252
                 ora collisions,y                          ;; @@7991 252
                 sta collisions,y                          ;; @@7994 252
 ;; @@7997 252
                 lda intval                               ; allowable interrupts ;; @@7997 252
                 cpy #0                                   ; examine selected bit ;; @@799a 252
                 beq _local_1251_20                        ;; @@799c 252
                 lsr                                       ;; @@799e 252
_local_1251_20   lsr                                       ;; @@799f 252
                 bcc _local_1251_25                       ; BASIC doesn't want this interrupt ;; @@79a0 252
                 lda #$ff                                  ;; @@79a2 252
                 sta int_trip_flag,y                      ; turn on trip flag ;; @@79a4 252
 ;; @@79a7 252
_local_1251_25   pla                                       ;; @@79a7 252
 ;; @@79a8 252
_local_1251_30   dey                                       ;; @@79a8 252
                 bpl _local_1251_10                        ;; @@79a9 252
 ;; @@79ab 252
; .page ;; @@79ab 252
; Check light pen latch ;; @@79ab 252
 ;; @@79ab 252
                 lsr                                       ;; @@79ab 252
                 bcc _local_1251_40                       ; LightPen latch not valid ;; @@79ac 252
 ;; @@79ae 252
                 ldx vic+49                               ; 4567R7 bug- must read LP_latches in Slow mode???? ;; @@79ae 252
                 lda #%01000000                           ; [910618] ;; @@79b1 252
                 trb vic+49                                ;; @@79b3 252
                 ldy vic+19                               ; save latched x position ;; @@79b6 252
                 sty lightpen_xpos                         ;; @@79b9 252
                 ldy vic+20                               ; save latched y position ;; @@79bc 252
                 sty lightpen_ypos                         ;; @@79bf 252
                 stx vic+49                               ; restore speed     [910618] ;; @@79c2 252
 ;; @@79c5 252
                 lda intval                               ; is BASIC interested in our little find? ;; @@79c5 252
                 and #4                                    ;; @@79c8 252
                 beq _local_1251_40                       ; no, move on to next IRQ task ;; @@79ca 252
                 lda #$ff                                  ;; @@79cc 252
                 sta int_trip_flag+2                      ; yes- let BASIC know we caught one ;; @@79ce 252
 ;; @@79d1 252
_local_1251_40                                             ;; @@79d1 252
; .page ;; @@79d1 252
; Update moving sprites ;; @@79d1 252
 ;; @@79d1 252
movspr_irq                                                 ;; @@79d1 253
                 lda vic+21                               ; any sprites active?    [910212] ;; @@79d1 253
                 +lbeq music_irq                          ; no- skip ahead ;; @@79d4 253
 ;; @@79d7 253
                 ldy #7                                   ; check each of 8 sprites ;; @@79d7 253
_local_1252_10   lda vic+21                               ; is this sprite is enabled? ;; @@79d9 253
                 and sbits,y                               ;; @@79dc 253
                 beq _local_1252_40                       ; sprite not enabled ;; @@79df 253
 ;; @@79e1 253
                 ldx sproff,y                             ; get offset to sprite info from a table ;; @@79e1 253
                 lda sprite_data,x                        ; is this sprite moving (speed >0 )? ;; @@79e4 253
                 beq _local_1252_40                       ; sprite not moving ;; @@79e7 253
                 bpl _local_1252_15                       ; sprite moving, no destination ;; @@79e9 253
                 bsr movspr_to_irq                        ; sprite moving to a destination [910809] ;; @@79eb 253
                 bra _local_1252_40                        ;; @@79ee 253
 ;; @@79f0 253
_local_1252_15   sta sprite_data+1,x                      ; set counter ;; @@79f0 253
_local_1252_20   tya                                      ; convert sprite# to a VIC register pointer ;; @@79f3 253
                 asl                                       ;; @@79f4 253
                 tay                                       ;; @@79f5 253
                 lda sprite_data+2,x                      ; get angle sign ;; @@79f6 253
                 dec                                      ; subtract 1 for cosine ;; @@79f9 253
                 inx                                       ;; @@79fa 253
                 inx                                       ;; @@79fb 253
                 iny                                       ;; @@79fc 253
                 jsr sprsub                               ; update y position ;; @@79fd 253
                 dex                                       ;; @@7a00 253
                 dex                                       ;; @@7a01 253
                 dey                                       ;; @@7a02 253
                 lda sprite_data+2,x                       ;; @@7a03 253
                 jsr sprsub                               ; update x position ;; @@7a06 253
                 php                                       ;; @@7a09 253
                 tya                                       ;; @@7a0a 253
                 lsr                                      ; restore index (.Y=sprite pointer) ;; @@7a0b 253
                 tay                                       ;; @@7a0c 253
                 plp                                       ;; @@7a0d 253
                 bcc _local_1252_30                       ; skip if no overflow ;; @@7a0e 253
                 lda vic+16                               ; get x position msb bits ???vic_save ;; @@7a10 253
                 eor sbits,y                              ; invert bit ;; @@7a13 253
                 sta vic+16                               ; ???vic_save ;; @@7a16 253
_local_1252_30   dec sprite_data+1,x                       ;; @@7a19 253
                 bne _local_1252_20                       ; loop until counter done ;; @@7a1c 253
 ;; @@7a1e 253
_local_1252_40   dey                                      ; check next sprite ;; @@7a1e 253
                 bpl _local_1252_10                       ; loop until done moving all sprites ;; @@7a1f 253
                 +lbra music_irq                          ; then continue with next IRQ task ;; @@7a21 253
; .page ;; @@7a24 253
movspr_to_irq                                             ; [910809] ;; @@7a24 254
                 phy                                      ; sprite # ;; @@7a24 254
                 and #$3f                                 ; speed factor ;; @@7a25 254
                 taz                                       ;; @@7a27 254
                 tya                                      ; vic sprite index ;; @@7a28 254
                 asl                                       ;; @@7a29 254
                 tay                                       ;; @@7a2a 254
 ;; @@7a2b 254
_local_1253_10   sec                                      ; for i = 1 to abs(greatr) ;; @@7a2b 254
                 lda sprite_data+1,x                       ;; @@7a2c 254
                 sbc #1                                    ;; @@7a2f 254
                 sta sprite_data+1,x                       ;; @@7a31 254
                 bcs _local_1253_20                        ;; @@7a34 254
                 lda sprite_data+2,x                       ;; @@7a36 254
                 sbc #0                                    ;; @@7a39 254
                 sta sprite_data+2,x                       ;; @@7a3b 254
                 bcs _local_1253_20                        ;; @@7a3e 254
                 lda #0                                    ;; @@7a40 254
                 sta sprite_data,x                        ; done!  sprite is at its destination ;; @@7a42 254
                 ply                                      ; remember sprite # ;; @@7a45 254
                 rts                                       ;; @@7a46 254
 ;; @@7a47 254
_local_1253_20   lda sprite_data+3,x                      ; ptr(lesser) ;; @@7a47 254
                 bit sprite_data+10,x                      ;; @@7a4a 254
                 bmi _local_1253_30                       ; if e > 0 ;; @@7a4d 254
                 bit sprite_data+3,x                      ; sgn(lesser) (b7=1=neg, b6=1=pos, else 0) ;; @@7a4f 254
                 jsr drwinc                               ; pos(lesser) = pos(lesser) + sgn(lesser) ;; @@7a52 254
 ;; @@7a55 254
                 lda sprite_data+4,x                      ; ptr(greater) ;; @@7a55 254
_local_1253_30   lsr                                      ; which f? ;; @@7a58 254
                 bcs _local_1253_40                        ;; @@7a59 254
                 lda sprite_data+9,x                      ; e = e + f1 ;; @@7a5b 254
                 adc sprite_data+5,x                       ;; @@7a5e 254
                 sta sprite_data+9,x                       ;; @@7a61 254
                 lda sprite_data+10,x                      ;; @@7a64 254
                 adc sprite_data+6,x                       ;; @@7a67 254
                 sta sprite_data+10,x                      ;; @@7a6a 254
                 bra _local_1253_50                        ;; @@7a6d 254
 ;; @@7a6f 254
_local_1253_40   clc                                       ;; @@7a6f 254
                 lda sprite_data+9,x                      ; e = e + f2 ;; @@7a70 254
                 adc sprite_data+7,x                       ;; @@7a73 254
                 sta sprite_data+9,x                       ;; @@7a76 254
                 lda sprite_data+10,x                      ;; @@7a79 254
                 adc sprite_data+8,x                       ;; @@7a7c 254
                 sta sprite_data+10,x                      ;; @@7a7f 254
 ;; @@7a82 254
_local_1253_50   lda sprite_data+4,x                      ; ptr(greater) ;; @@7a82 254
                 bit sprite_data+4,x                      ; sgn(greater) (b7=1=neg, b6=1=pos, else 0) ;; @@7a85 254
                 jsr drwinc                               ; pos(greater) = pos(greater) + sgn(greater) ;; @@7a88 254
 ;; @@7a8b 254
                 dez                                      ; count ;; @@7a8b 254
                 bne _local_1253_10                        ;; @@7a8c 254
                 ply                                      ; remember sprite # ;; @@7a8e 254
                 rts                                      ; done this frame ;; @@7a8f 254
 ;; @@7a90 254
 ;; @@7a90 254
drwinc           php                                       ;; @@7a90 255
                 and #1                                   ; adjust .y for x or y position ;; @@7a91 255
                 beq _local_1254_5                        ; 0=x ;; @@7a93 255
                 iny                                      ; 1=y ;; @@7a95 255
_local_1254_5    plp                                       ;; @@7a96 255
                 bmi _local_1254_10                       ; enter with b7=negative, b6=positive, else zero ;; @@7a97 255
                 bvc _local_1254_30                        ;; @@7a99 255
 ;; @@7a9b 255
                 lda vic,y                                ; positive direction ;; @@7a9b 255
                 inc                                       ;; @@7a9e 255
                 sta vic,y                                 ;; @@7a9f 255
                 bra _local_1254_20                        ;; @@7aa2 255
 ;; @@7aa4 255
_local_1254_10   lda vic,y                                ; negative direction ;; @@7aa4 255
                 dec                                       ;; @@7aa7 255
                 sta vic,y                                 ;; @@7aa8 255
                 cmp #$ff                                  ;; @@7aab 255
 ;; @@7aad 255
_local_1254_20   bne _local_1254_30                       ; no wrap ;; @@7aad 255
                 tya                                       ;; @@7aaf 255
                 bit #1                                    ;; @@7ab0 255
                 bne _local_1254_30                       ; wrap in y okay ;; @@7ab2 255
                 lsr                                       ;; @@7ab4 255
                 tay                                       ;; @@7ab5 255
                 lda sbits,y                              ; wrap in x- toggle msb ;; @@7ab6 255
                 eor vic+16                                ;; @@7ab9 255
                 sta vic+16                                ;; @@7abc 255
                 tya                                       ;; @@7abf 255
                 asl                                       ;; @@7ac0 255
                 tay                                       ;; @@7ac1 255
 ;; @@7ac2 255
_local_1254_30   tya                                      ; restore y to sprite offset ;; @@7ac2 255
                 and #$fe                                  ;; @@7ac3 255
                 tay                                       ;; @@7ac5 255
                 rts                                       ;; @@7ac6 255
 ;; @@7ac7 255
; .page ;; @@7ac7 255
; Play music, if in progress ;; @@7ac7 255
 ;; @@7ac7 255
music_irq                                                  ;; @@7ac7 256
                 ldx #0                                    ;; @@7ac7 256
_local_1255_100  ldy voices+1,x                            ;; @@7ac9 256
                 bmi _local_1255_110                      ; skip if not active ;; @@7acc 256
 ;; @@7ace 256
                 lda voices,x                              ;; @@7ace 256
                 sec                                       ;; @@7ad1 256
                 sbc tempo_rate                           ; decrement current value by current tempo ;; @@7ad2 256
                 sta voices,x                              ;; @@7ad5 256
                 bcs _local_1255_110                       ;; @@7ad8 256
                 tya                                      ; lda voices+1,x ;; @@7ada 256
                 sbc #0                                    ;; @@7adb 256
                 sta voices+1,x                            ;; @@7add 256
                 bcs _local_1255_110                      ; ok, no underflow ;; @@7ae0 256
 ;; @@7ae2 256
                 txa                                       ;; @@7ae2 256
                 lsr                                      ; get offset to waveform ;; @@7ae3 256
                 tay                                       ;; @@7ae4 256
                 lda waveform,y                           ; get waveform ;; @@7ae5 256
                 and #$fe                                 ; mask out gate bit ;; @@7ae8 256
                 pha                                       ;; @@7aea 256
                 lda SID_offset,y                         ; get offset to correct oscillator ;; @@7aeb 256
                 tay                                       ;; @@7aee 256
                 pla                                       ;; @@7aef 256
; jsr go_slow  ;      [910716] 4567R7A ;; @@7af0 256
                 sta sid1+4,y                             ; turn off sound ;; @@7af0 256
; jsr go_fast  ;      [910716] 4567R7A ;; @@7af3 256
 ;; @@7af3 256
_local_1255_110  inx                                       ;; @@7af3 256
                 inx                                       ;; @@7af4 256
                 cpx #6+6                                 ; [910612] ;; @@7af5 256
                 bcc _local_1255_100                      ; loop for 6 voices ;; @@7af7 256
;then continue with next IRQ task ;; @@7af9 256
; .page ;; @@7af9 256
; Test if SOUND command wants anything ;; @@7af9 256
 ;; @@7af9 256
sound_irq                                                  ;; @@7af9 257
                 ldy #6-1                                 ; test six voices    [910612] ;; @@7af9 257
_local_1256_10   lda sound_time_hi,y                      ; active if msb clear ;; @@7afb 257
                 bpl _local_1256_12                        ;; @@7afe 257
_local_1256_11   dey                                       ;; @@7b00 257
                 bpl _local_1256_10                        ;; @@7b01 257
                 +lbra basic_irq_end                       ;; @@7b03 257
 ;; @@7b06 257
_local_1256_12   clc                                      ; add step to frequency ;; @@7b06 257
                 lda sound_freq_lo,y                       ;; @@7b07 257
                 adc sound_step_lo,y                       ;; @@7b0a 257
                 sta sound_freq_lo,y                       ;; @@7b0d 257
                 lda sound_freq_hi,y                       ;; @@7b10 257
                 adc sound_step_hi,y                       ;; @@7b13 257
                 sta sound_freq_hi,y                       ;; @@7b16 257
 ;; @@7b19 257
                 lda sound_direction,y                    ; test if this is up or down ;; @@7b19 257
                 tax                                       ;; @@7b1c 257
                 and #1                                    ;; @@7b1d 257
                 beq _local_1256_20                       ; branch if up ;; @@7b1f 257
 ;; @@7b21 257
; If step direction is down, .C==0 OR freq < min  ==> reset value ;; @@7b21 257
 ;; @@7b21 257
                 bcc _local_1256_13                       ; underflow, reset ;; @@7b21 257
                 sec                                       ;; @@7b23 257
                 lda sound_freq_lo,y                       ;; @@7b24 257
                 sbc sound_min_lo,y                        ;; @@7b27 257
                 lda sound_freq_hi,y                       ;; @@7b2a 257
                 sbc sound_min_hi,y                        ;; @@7b2d 257
                 bcs _local_1256_40                       ; no borrow, don't reset ;; @@7b30 257
 ;; @@7b32 257
_local_1256_13   cpx #2                                   ; is 'cycle' bit set? ;; @@7b32 257
                 bcc _local_1256_15                       ; no, keep direction 'down' ;; @@7b34 257
 ;; @@7b36 257
                 jsr negate_step                          ; make step 2's comp ;; @@7b36 257
                 lda #2                                   ; change direction to 'up' ;; @@7b39 257
                 sta sound_direction,y                     ;; @@7b3b 257
                 bne _local_1256_35                       ; go reset for 'up' ;; @@7b3e 257
 ;; @@7b40 257
_local_1256_15   lda sound_max_lo,y                       ; reset to max ;; @@7b40 257
                 sta sound_freq_lo,y                       ;; @@7b43 257
                 lda sound_max_hi,y                        ;; @@7b46 257
                 sta sound_freq_hi,y                       ;; @@7b49 257
                 bra _local_1256_40                       ; go update SID frequency ;; @@7b4c 257
 ;; @@7b4e 257
; If step direction is up, overflow (.C==1) OR freq > max ==> reset frequency ;; @@7b4e 257
 ;; @@7b4e 257
_local_1256_20   bcs _local_1256_30                       ; overflow, must reset ;; @@7b4e 257
                 lda sound_freq_hi,y                      ; 16 bit compare (yech!) ;; @@7b50 257
                 cmp sound_max_hi,y                        ;; @@7b53 257
                 bcc _local_1256_40                       ; freq < max, no reset ;; @@7b56 257
                 bne _local_1256_30                       ; freq > max, reset ;; @@7b58 257
                 lda sound_freq_lo,y                      ; msb's the same, test lsb's ;; @@7b5a 257
                 cmp sound_max_lo,y                        ;; @@7b5d 257
                 bcc _local_1256_40                       ; freq < max, no reset ;; @@7b60 257
                 beq _local_1256_40                       ; freq = max, no reset ;; @@7b62 257
 ;; @@7b64 257
_local_1256_30   cpx #2                                   ; is this 'cycle'? ;; @@7b64 257
                 bcc _local_1256_35                       ; no, go reset for next 'up' ;; @@7b66 257
 ;; @@7b68 257
                 jsr negate_step                          ; make step 2's comp ;; @@7b68 257
                 lda #3                                   ; change direction to 'down' ;; @@7b6b 257
                 sta sound_direction,y                     ;; @@7b6d 257
                 bne _local_1256_15                       ; go reset for next 'down' ;; @@7b70 257
 ;; @@7b72 257
_local_1256_35   lda sound_min_lo,y                       ; set freq to minimum value ;; @@7b72 257
                 sta sound_freq_lo,y                       ;; @@7b75 257
                 lda sound_min_hi,y                        ;; @@7b78 257
                 sta sound_freq_hi,y                       ;; @@7b7b 257
 ;; @@7b7e 257
; Update SID frequency registers ;; @@7b7e 257
 ;; @@7b7e 257
_local_1256_40                                             ;; @@7b7e 257
; jsr go_slow  ;      [910716] 4567R7A ;; @@7b7e 257
                 ldx SID_offset,y                         ; get index to SID voices ;; @@7b7e 257
                 lda sound_freq_lo,y                       ;; @@7b81 257
                 sta sid1,x                                ;; @@7b84 257
                 lda sound_freq_hi,y                       ;; @@7b87 257
                 sta sid1+1,x                              ;; @@7b8a 257
; jsr go_fast  ;      [910716] 4567R7A ;; @@7b8d 257
 ;; @@7b8d 257
; Decrement total time - see if it's time to bring down the curtain ;; @@7b8d 257
 ;; @@7b8d 257
                 tya                                       ;; @@7b8d 257
                 tax                                       ;; @@7b8e 257
                 lda sound_time_lo,x                      ; 16 bit decrement - not very pretty ;; @@7b8f 257
                 bne _local_1256_50                        ;; @@7b92 257
                 dec sound_time_hi,x                       ;; @@7b94 257
_local_1256_50   dec sound_time_lo,x                       ;; @@7b97 257
 ;; @@7b9a 257
                 lda sound_time_hi,x                      ; underflow? ;; @@7b9a 257
                 +lbpl _local_1256_11                     ; nope ;; @@7b9d 257
 ;; @@7ba0 257
; Time to turn off this voice ;; @@7ba0 257
 ;; @@7ba0 257
; jsr go_slow  ;      [910716] 4567R7A ;; @@7ba0 257
                 lda #$08                                  ;; @@7ba0 257
                 ldx SID_offset,y                          ;; @@7ba2 257
                 sta sid1+4,x                              ;; @@7ba5 257
; jsr go_fast  ;      [910716] 4567R7A ;; @@7ba8 257
                 +lbra _local_1256_11                      ;; @@7ba8 257
 ;; @@7bab 257
 ;; @@7bab 257
negate_step                                                ;; @@7bab 258
                 lda sound_step_lo,y                       ;; @@7bab 258
                 eor #$ff                                  ;; @@7bae 258
                 clc                                       ;; @@7bb0 258
                 adc #1                                    ;; @@7bb1 258
                 sta sound_step_lo,y                       ;; @@7bb3 258
                 lda sound_step_hi,y                       ;; @@7bb6 258
                 eor #$ff                                  ;; @@7bb9 258
                 adc #0                                    ;; @@7bbb 258
                 sta sound_step_hi,y                       ;; @@7bbd 258
                 rts                                       ;; @@7bc0 258
 ;; @@7bc1 258
 ;; @@7bc1 258
; .page ;; @@7bc1 258
; Here is where BASIC_IRQ exits ;; @@7bc1 258
 ;; @@7bc1 258
basic_irq_end                                              ;; @@7bc1 258
                 dec irq_wrap_flag                        ; open the door to IRQ ;; @@7bc1 258
                 cli                                       ;; @@7bc4 258
                 rts                                       ;; @@7bc5 258
 ;; @@7bc6 258
; .page ;; @@7bc6 258
; Update sprite position subroutine ;; @@7bc6 258
 ;; @@7bc6 258
sprsub           pha                                      ; save angle phase ;; @@7bc6 258
                 clc                                       ;; @@7bc7 258
                 lda sprite_data+3,x                      ; add low bytes ;; @@7bc8 258
                 adc sprite_data+7,x                       ;; @@7bcb 258
                 sta sprite_data+7,x                       ;; @@7bce 258
                 lda sprite_data+4,x                      ; add high bytes ;; @@7bd1 258
                 adc sprite_data+8,x                       ;; @@7bd4 258
                 sta sprite_data+8,x                       ;; @@7bd7 258
                 pla                                      ; get angle sign ;; @@7bda 258
                 bcc _local_1257_30                       ; skip if no carry - do not update position ;; @@7bdb 258
                 lsr                                       ;; @@7bdd 258
                 lsr                                      ; test if positive or negative ;; @@7bde 258
                 lda vic,y                                ; ???vic_save ;; @@7bdf 258
                 bcs _local_1257_10                       ; skip if negative ;; @@7be2 258
                 adc #1                                   ; increment position ;; @@7be4 258
                 bra _local_1257_20                        ;; @@7be6 258
 ;; @@7be8 258
_local_1257_10   sbc #1                                   ; decrement position ;; @@7be8 258
                 cmp #$ff                                 ; set carry if underflow ;; @@7bea 258
_local_1257_20   sta vic,y                                ; decrement position  ???vic_save ;; @@7bec 258
_local_1257_30   rts                                       ;; @@7bef 258
 ;; @@7bf0 258
;.end ;; @@7bf0 258
; .page ;; @@7bf0 258
; .subttl  MOUSE ;; @@7bf0 258
 ;; @@7bf0 258
;*********************************************************************** ;; @@7bf0 258
;*   MOUSE  ON  [,[port] [,[sprite] [,[hotspot] [,X/Yposition] ]]] ;; @@7bf0 258
;*   MOUSE  OFF ;; @@7bf0 258
;*    where: port     = (1...3) for joyport 1, 2, or either (both) ;; @@7bf0 258
;*  sprite   = (0...7) sprite pointer ;; @@7bf0 258
;*  hotspot  = x,y offset in sprite, default 0,0 ;; @@7bf0 258
;*  position = normal, relative, or angluar coordinates ;; @@7bf0 258
;* ;; @@7bf0 258
;*      (defaults to sprite 0, port 2, last hotspot & position) ;; @@7bf0 258
;*********************************************************************** ;; @@7bf0 258
 ;; @@7bf0 258
mouse            cmp #on_token                            ; new [910122] ;; @@7bf0 259
                 beq _local_1258_10                        ;; @@7bf2 259
                 jsr chkesc                                ;; @@7bf4 259
                 cmp #off_token                            ;; @@7bf7 259
                 +lbne snerr                               ;; @@7bf9 259
 ;; @@7bfc 259
;    The Kernel MOUSE_CMD is called to install or remove mouse driver. ;; @@7bfc 259
; .a= B7,6 set to install mouse in game port 2 ($80), 1 ($40), or both ($C0) ;; @@7bfc 259
; .a= 0 to disable mouse driver ;; @@7bfc 259
; .x= 0-7 physical sprite pointer ;; @@7bfc 259
 ;; @@7bfc 259
                 lda #0                                   ; TURN MOUSE OFF ;; @@7bfc 259
                 jsr _mouse                               ; do it ;; @@7bfe 259
                 +lbra chkeos                             ; eat token & exit after checking for eos ;; @@7c01 259
 ;; @@7c04 259
;TURN MOUSE ON ;; @@7c04 259
_local_1258_10   jsr chrget                               ; eat token ;; @@7c04 259
                 ldx #2                                   ; get (optional) port# in .X ;; @@7c07 259
                 jsr optbyt                               ; if not present default to port 2 ;; @@7c09 259
                 cpx #4                                   ;  ;; @@7c0c 259
                 +lbcs fcerr                              ; illegal value ;; @@7c0e 259
                 phx                                       ;; @@7c11 259
 ;; @@7c12 259
                 ldx #0                                   ; get (optional) sprite# in .X ;; @@7c12 259
                 jsr optbyt                               ; if not present default to sprite 0 ;; @@7c14 259
                 cpx #8                                    ;; @@7c17 259
                 +lbcs fcerr                              ; illegal value ;; @@7c19 259
                 stx z_p_temp_1                            ;; @@7c1c 259
                 ldy sproff,x                             ; kill moving sprite ;; @@7c1e 259
                 lda #0                                   ; get offset to speed data ;; @@7c21 259
                 sta sprite_data,y                        ; reset sprite's speed value ;; @@7c23 259
 ;; @@7c26 259
                 pla                                      ; setup for Kernel call- get port# into b7,6 ;; @@7c26 259
                 ror                                      ; .a= port(s), .x=sprite ;; @@7c27 259
                 ror                                       ;; @@7c28 259
                 ror                                       ;; @@7c29 259
                 jsr _mouse                               ; do it (???? do after coord error check) ;; @@7c2a 259
 ;; @@7c2d 259
; .page ;; @@7c2d 259
                 jsr optbyt                               ; get (optional) hotspot, x  new [910307] ;; @@7c2d 259
                 bcc _local_1258_20                       ; not given ;; @@7c30 259
                 cpx #24                                   ;; @@7c32 259
                 +lbcs fcerr                              ; out of range (0-23) ;; @@7c34 259
                 txa                                       ;; @@7c37 259
                 neg                                       ;; @@7c38 259
                 tax                                       ;; @@7c39 259
                 adc #24                                   ;; @@7c3a 259
                 sta _mouse_left                           ;; @@7c3c 259
                 txa                                       ;; @@7c3f 259
                 clc                                       ;; @@7c40 259
                 adc #87                                   ;; @@7c41 259
                 sta _mouse_right                          ;; @@7c43 259
 ;; @@7c46 259
_local_1258_20   jsr optbyt                               ; get (optional) hotspot, y ;; @@7c46 259
                 bcc _local_1258_30                       ; not given ;; @@7c49 259
                 cpx #21                                   ;; @@7c4b 259
                 +lbcs fcerr                              ; out of range (0-20) ;; @@7c4d 259
                 txa                                       ;; @@7c50 259
                 neg                                       ;; @@7c51 259
                 tax                                       ;; @@7c52 259
                 adc #50                                   ;; @@7c53 259
                 sta _mouse_top                            ;; @@7c55 259
                 txa                                       ;; @@7c58 259
                 clc                                       ;; @@7c59 259
                 adc #250                                  ;; @@7c5a 259
                 sta _mouse_bottom                         ;; @@7c5c 259
 ;; @@7c5f 259
_local_1258_30   jsr chrgot                               ; get (optional) position coordinate  [910123] ;; @@7c5f 259
                 beq _local_1258_40                       ; eol, use this sprite's last position ;; @@7c62 259
                 jsr sprcor                               ; else get first coordinate ;; @@7c64 259
                 bit numcnt                               ; test coordinate type ;; @@7c67 259
                 +lbvs snerr                              ; syntax error ;; @@7c6a 259
                 sty xdest                                ; save coordinate value ;; @@7c6d 259
                 sty xdest+2                               ;; @@7c70 259
                 sta xdest+1                               ;; @@7c73 259
                 sta xdest+3                               ;; @@7c76 259
 ;; @@7c79 259
                 lda #$7f                                 ; flag 'mouse' for movspr call  [910808] ;; @@7c79 259
                 sta op                                    ;; @@7c7b 259
                 jsr sprcor                               ; get second coordinate ;; @@7c7d 259
                 bit numcnt                               ; test type of coordinate ;; @@7c80 259
                 +lbvc movspr_normal                      ; position sprite, normal coordinates ;; @@7c83 259
                 +lbmi movspr_angle                       ; angular coordinates ;; @@7c86 259
                 +lbra snerr                              ; else error ;; @@7c89 259
 ;; @@7c8c 259
_local_1258_40   rts                                       ;; @@7c8c 259
 ;; @@7c8d 259
;.end ;; @@7c8d 259
; .page ;; @@7c8d 259
;************************************************************************ ;; @@7c8d 259
;*   RMOUSE Returns in variable list current status of mouse * ;; @@7c8d 259
;*         * ;; @@7c8d 259
;*   Syntax: RMOUSE [Xposition [,Yposition [, Buttons] ]]  * ;; @@7c8d 259
;*         * ;; @@7c8d 259
;*   Where: X,Yposition = current position of mouse pointer sprite * ;; @@7c8d 259
;*  Button      = current status of mouse buttons  * ;; @@7c8d 259
;*         * ;; @@7c8d 259
;*   0   = no button     * ;; @@7c8d 259
;*   1   = right button    * ;; @@7c8d 259
;*   128 = left button    * ;; @@7c8d 259
;*   129 = both buttons    * ;; @@7c8d 259
;*         * ;; @@7c8d 259
;* If a mouse is not installed, "-1" is returned for all vars. * ;; @@7c8d 259
;* If both ports are enabled, buttons from each port are merged. * ;; @@7c8d 259
;************************************************************************ ;; @@7c8d 259
 ;; @@7c8d 259
rmouse           lda #0                                   ; Init ;; @@7c8d 260
                 sta count                                ; variable count = 0 ;; @@7c8f 260
                 dec                                       ;; @@7c91 260
                 ldx #6-1                                  ;; @@7c92 260
_local_1259_10   sta grapnt,x                             ; positions/buttons = -1 ;; @@7c94 260
                 dex                                       ;; @@7c96 260
                 bpl _local_1259_10                        ;; @@7c97 260
 ;; @@7c99 260
                 lda _mouse_enable                        ; Is there a mouse in the house? ;; @@7c99 260
                 and #%11000000                            ;; @@7c9c 260
                 beq _local_1259_50                       ; no, exit ;; @@7c9e 260
                 pha                                      ; yes, save port assigns for later ;; @@7ca0 260
                 sei                                       ;; @@7ca1 260
                 ldy _mouse_pointer                       ; Where is it?  Get pointer to sprite ;; @@7ca2 260
                 lda vic,y                                ; Get X position    ???vic_save ;; @@7ca5 260
                 sta grapnt                               ; lsb ;; @@7ca8 260
                 lda sbits,y                               ;; @@7caa 260
                 and vic+16                               ; msb    ???vic_save ;; @@7cad 260
                 beq _local_1259_20                        ;; @@7cb0 260
                 lda #1                                   ; convert to 0 or 1 ;; @@7cb2 260
_local_1259_20   sta grapnt+1                              ;; @@7cb4 260
                 iny                                      ; Get Y position ;; @@7cb6 260
                 lda vic,y                                ; lsb    ???vic_save ;; @@7cb7 260
                 sta grapnt+2                              ;; @@7cba 260
                 lda #0                                   ; msb (fake it) ;; @@7cbc 260
                 sta grapnt+3                              ;; @@7cbe 260
 ;; @@7cc0 260
                 sta grapnt+4                             ; Init button status ;; @@7cc0 260
                 sta grapnt+5                              ;; @@7cc2 260
                 ldz d1pra                                ; Set up port & read buttons ;; @@7cc4 260
                 lda #$ff                                 ; save kybd output lines (IRQ already disabled) ;; @@7cc7 260
                 sta d1pra                                ; set to not read any kybd inputs ;; @@7cc9 260
 ;; @@7ccc 260
                 ldy #0                                   ; which port? ;; @@7ccc 260
                 plx                                      ; recall port assignments ;; @@7cce 260
_local_1259_30   txa                                       ;; @@7ccf 260
                 asl                                      ; .c=1 if this one ;; @@7cd0 260
                 tax                                       ;; @@7cd1 260
                 bcc _local_1259_40                       ; not this one ;; @@7cd2 260
                 lda d1pra,y                              ; read it (logical port is opposite physical port) ;; @@7cd4 260
                 and #%00010001                           ; want left, right buttons only ;; @@7cd7 260
                 eor #%00010001                           ; (invert, since low means button down) ;; @@7cd9 260
                 tsb grapnt+4                              ;; @@7cdb 260
                 and #%00010000                           ; shift left button to msb ;; @@7cdd 260
                 beq _local_1259_40                        ;; @@7cdf 260
                 smb7 grapnt+4                             ;; @@7ce1 260
_local_1259_40   iny                                      ; next port ;; @@7ce3 260
                 cpy #2                                    ;; @@7ce4 260
                 bcc _local_1259_30                        ;; @@7ce6 260
 ;; @@7ce8 260
                 lda #%01111110                           ; clean up ;; @@7ce8 260
                 trb grapnt+4                             ; fix button register ;; @@7cea 260
                 stz d1pra                                ; restore port for Kernel ;; @@7cec 260
                 cli                                       ;; @@7cef 260
 ;; @@7cf0 260
; At this point, we have snapshot the current mouse status. ;; @@7cf0 260
; Now pass requested info along in a manner very similar to RREG... ;; @@7cf0 260
 ;; @@7cf0 260
_local_1259_50   jsr chrgot                               ; Get a variable name from variable list ;; @@7cf0 260
                 beq _local_1259_90                       ; eol- exit ;; @@7cf3 260
                 cmp #','                                 ;  ;; @@7cf5 260
                 beq _local_1259_70                       ; null- skip this arg ;; @@7cf7 260
                 jsr ptrget                               ; Get pointer to target variable ;; @@7cf9 260
                 sta forpnt                               ; set up so we can share LET code ;; @@7cfc 260
                 sty forpnt+1                              ;; @@7cfe 260
                 lda valtyp                               ; what kind of variable name did ptrget find? ;; @@7d00 260
                 +lbne chkerr                             ; string- type mismatch error ;; @@7d02 260
 ;; @@7d05 260
_local_1259_60   ldx count                                ; Make assignment ;; @@7d05 260
                 ldy grapnt,x                             ; low byte ;; @@7d07 260
                 lda grapnt+1,x                           ; high byte ;; @@7d09 260
                 jsr givayf                               ; float it ;; @@7d0b 260
                 lda intflg                               ; set flags for type of var (int/float) ;; @@7d0e 260
                 jsr qintgr                               ; use part of LET to do the work ;; @@7d10 260
 ;; @@7d13 260
_local_1259_70   inc count                                ; Next assignment ;; @@7d13 260
                 inc count                                 ;; @@7d15 260
                 ldx count                                 ;; @@7d17 260
                 cpx #6                                   ; there are 3 possible ;; @@7d19 260
                 bcs _local_1259_90                       ; done all 3, exit ;; @@7d1b 260
                 jsr chrgot                               ; check terminator ;; @@7d1d 260
                 beq _local_1259_90                       ; eol- exit ;; @@7d20 260
                 jsr chkcom                               ; check delimiter ;; @@7d22 260
                 bra _local_1259_50                       ; loop until done ;; @@7d25 260
 ;; @@7d27 260
_local_1259_90   rts                                       ;; @@7d27 260
 ;; @@7d28 260
;.end ;; @@7d28 260
; .page ;; @@7d28 260
; .subttl   CURSOR ;; @@7d28 260
 ;; @@7d28 260
;***************************************************************** ;; @@7d28 260
;*   CURSOR [ON|OFF,] [column] [,row [,style] ] ;; @@7d28 260
;* ;; @@7d28 260
;*   where: column,row = x,y logical screen position ;; @@7d28 260
;*  style      = flashing (0) or solid (1) ;; @@7d28 260
;*  ON,OFF     = to turn the cursor on or off ;; @@7d28 260
;***************************************************************** ;; @@7d28 260
 ;; @@7d28 260
cursor           cmp #on_token                            ; Check for ON | OFF ;; @@7d28 261
                 clc                                       ;; @@7d2a 261
                 beq _local_1260_20                       ; turn cursor on (.c=0) ;; @@7d2b 261
                 cmp #esc_command_token                    ;; @@7d2d 261
                 bne _local_1260_1                        ; (might be a function) ;; @@7d2f 261
                 jsr chkesc                                ;; @@7d31 261
                 cmp #off_token                           ; turn cursor off (.c=1) ;; @@7d34 261
                 beq _local_1260_20                        ;; @@7d36 261
                 +lbra snerr                               ;; @@7d38 261
 ;; @@7d3b 261
_local_1260_1    pha                                      ; Evaluate cursor position parameters ;; @@7d3b 261
                 sec                                       ;; @@7d3c 261
                 jsr _plot                                ; get current cursor position & save it ;; @@7d3d 261
                 stx srow                                  ;; @@7d40 261
                 sty column                                ;; @@7d42 261
 ;; @@7d44 261
                 ldx column                               ; get new column, default=current column ;; @@7d44 261
                 pla                                       ;; @@7d46 261
                 cmp #','                                  ;; @@7d47 261
                 beq _local_1260_10                       ; not given, use default ;; @@7d49 261
                 jsr getbyt                                ;; @@7d4b 261
_local_1260_10   stx column                                ;; @@7d4e 261
                 ldx srow                                 ; get new row, default=current row ;; @@7d50 261
                 jsr optbyt                                ;; @@7d52 261
; stx srow ;; @@7d55 261
                 ldy column                                ;; @@7d55 261
                 clc                                       ;; @@7d57 261
                 jsr _plot                                ; set new cursor position ;; @@7d58 261
                 +lbcs fcerr                              ; error if bad position ;; @@7d5b 261
 ;; @@7d5e 261
                 jsr optzer                               ; Get new cursor type   ???? assumes screen output ;; @@7d5e 261
                 bcc _local_1260_30                       ; not given, exit ;; @@7d61 261
                 lda #esc                                  ;; @@7d63 261
                 jsr _bsout                               ; use escape sequence to set ;; @@7d65 261
                 txa                                       ;; @@7d68 261
                 and #1                                    ;; @@7d69 261
                 eor #1                                   ; [910808] ;; @@7d6b 261
                 clc                                       ;; @@7d6d 261
                 adc #'E'                                 ; 0=F=flash, 1=E=solid ;; @@7d6e 261
                 jmp _bsout                               ; set it and exit ;; @@7d70 261
 ;; @@7d73 261
_local_1260_20   jsr _cursor                              ; Turn cursor ON or OFF per .c ;; @@7d73 261
 ;; @@7d76 261
                 jsr chrget                               ; eat token, get next character ;; @@7d76 261
                 beq _local_1260_30                       ; eol- exit ;; @@7d79 261
                 jsr chkcom                               ; else, must be comma ;; @@7d7b 261
                 bra _local_1260_1                        ; it is- go evaluate position ;; @@7d7e 261
 ;; @@7d80 261
_local_1260_30   rts                                      ; eol ;; @@7d80 261
 ;; @@7d81 261
; .page ;; @@7d81 261
;************************************************************************ ;; @@7d81 261
;*   RCURSOR Returns in variable list current cursor position * ;; @@7d81 261
;*         * ;; @@7d81 261
;*   Syntax: RCURSOR [column [,row] ]    * ;; @@7d81 261
;************************************************************************ ;; @@7d81 261
 ;; @@7d81 261
rcursor          sec                                      ; new [910228] ;; @@7d81 262
                 jsr _plot                                ; get current cursor position & save it ;; @@7d82 262
                 stx srow                                  ;; @@7d85 262
                 sty column                                ;; @@7d87 262
 ;; @@7d89 262
                 ldx #0                                   ; just like RREG and RMOUSE... ;; @@7d89 262
                 stx count                                 ;; @@7d8b 262
_local_1261_50   jsr chrgot                               ; Get a variable name from variable list ;; @@7d8d 262
                 beq _local_1261_90                       ; eol- exit ;; @@7d90 262
                 cmp #','                                 ;  ;; @@7d92 262
                 beq _local_1261_70                       ; null- skip this arg ;; @@7d94 262
                 jsr ptrget                               ; Get pointer to target variable ;; @@7d96 262
                 sta forpnt                               ; set up so we can share LET code ;; @@7d99 262
                 sty forpnt+1                              ;; @@7d9b 262
                 lda valtyp                               ; what kind of variable name did ptrget find? ;; @@7d9d 262
                 +lbne chkerr                             ; string- type mismatch error ;; @@7d9f 262
 ;; @@7da2 262
_local_1261_60   ldx count                                ; Make assignment ;; @@7da2 262
                 ldy column,x                             ; low byte ;; @@7da4 262
                 lda #0                                   ; high byte ;; @@7da6 262
                 jsr givayf                               ; float it ;; @@7da8 262
                 lda intflg                               ; set flags for type of var (int/float) ;; @@7dab 262
                 jsr qintgr                               ; use part of LET to do the work ;; @@7dad 262
 ;; @@7db0 262
_local_1261_70   inc count                                ; Next assignment ;; @@7db0 262
                 ldx count                                 ;; @@7db2 262
                 cpx #2                                   ; there are 2 possible ;; @@7db4 262
                 bcs _local_1261_90                       ; done 2, exit ;; @@7db6 262
                 jsr chrgot                               ; check terminator ;; @@7db8 262
                 beq _local_1261_90                       ; eol- exit ;; @@7dbb 262
                 jsr chkcom                               ; check delimiter ;; @@7dbd 262
                 bra _local_1261_50                       ; loop until done ;; @@7dc0 262
 ;; @@7dc2 262
_local_1261_90   rts                                       ;; @@7dc2 262
 ;; @@7dc3 262
;.end ;; @@7dc3 262
; .page ;; @@7dc3 262
; .subttl  AutoScroll ;; @@7dc3 262
 ;; @@7dc3 262
AutoScroll                                                 ;; @@7dc3 263
                 pha                                      ; save character for Editor ;; @@7dc3 263
                 bbs7 runmod,AutoScrollno                 ; branch if not direct mode ;; @@7dc4 263
                 ldy channl                               ; is output redirected? ;; @@7dc7 263
                 bne AutoScrollno                         ; yes- can't do scroll (need to read screen) ;; @@7dc9 263
                 lda txttab                                ;; @@7dcb 263
                 ldx txttab+1                             ; is there a program in memory to scroll? ;; @@7dcd 263
                 sta txtptr                                ;; @@7dcf 263
                 stx txtptr+1                              ;; @@7dd1 263
                 iny                                      ; (1) ;; @@7dd3 263
                 jsr indtxt                                ;; @@7dd4 263
                 bne AutoScrollyes                        ; yes- continue ;; @@7dd7 263
                 bra AutoScrollno                         ; no-  exit ;; @@7dd9 263
 ;; @@7ddb 263
AutoScrollpop                                              ;; @@7ddb 263
                 pla                                       ;; @@7ddb 263
                 pla                                       ;; @@7ddc 263
AutoScrollng                                               ;; @@7ddd 263
                 ldx point                                ; restore cursor position ;; @@7ddd 263
                 ldy point+1                               ;; @@7ddf 263
                 clc                                       ;; @@7de1 263
                 jsr _plot                                 ;; @@7de2 263
AutoScrollno                                               ;; @@7de5 263
                 rmb1 helper                              ; remove LINGET flag ;; @@7de5 263
                 pla                                      ; restore character ;; @@7de7 263
                 sec                                      ; return to Editor with no action taken ;; @@7de8 263
                 rts                                       ;; @@7de9 263
 ;; @@7dea 263
AutoScrollyes                                              ;; @@7dea 263
                 ror form                                 ; save .c=direction (character already on stack) ;; @@7dea 263
                 sec                                       ;; @@7dec 263
                 jsr _plot                                ; get current cursor position & save it ;; @@7ded 263
                 stx point                                 ;; @@7df0 263
                 sty point+1                               ;; @@7df2 263
                 smb1 helper                              ; set flag for LINGET not to go to error if it has problems ;; @@7df4 263
                 bbs7 form,AutoScrolldn                   ; branch according to direction of scroll... ;; @@7df6 263
 ;; @@7df9 263
; .page ;; @@7df9 263
AutoScrollup                                              ; wanting to scroll up ;; @@7df9 263
                 sec                                       ;; @@7df9 263
                 lda _screen_bottom                       ; put cursor at bottom of screen ;; @@7dfa 263
                 sbc _screen_top                           ;; @@7dfc 263
                 sta form+1                               ; save where it is- we'll be printing line there ;; @@7dfe 263
                 tax                                       ;; @@7e00 263
                 jsr AutoSearch                           ; search for a line number on screen, put it in linnum ;; @@7e01 263
                 jsr FindLine                             ; find the line in program ;; @@7e04 263
                 bcc _local_1262_10   ;  line not found   ; we have a pointer to the next line ;; @@7e07 263
                 ldy #0                                    ;; @@7e09 263
                 jsr indlow                               ; find the next line, the one we want to print, via link bytes ;; @@7e0b 263
                 tax                                       ;; @@7e0e 263
                 iny                                       ;; @@7e0f 263
                 jsr indlow                                ;; @@7e10 263
                 stx lowtr                                ; advance pointer to it ;; @@7e13 263
                 sta lowtr+1                               ;; @@7e15 263
_local_1262_10   ldx form+1                               ; put cursor back at bottom of screen ;; @@7e17 263
                 ldy #0                                    ;; @@7e19 263
                 clc                                       ;; @@7e1b 263
                 jsr _plot                                 ;; @@7e1c 263
_local_1262_20   jsr crdo                                 ; get a blank line to print on- scroll screen up ;; @@7e1f 263
                 ldy #1                                    ;; @@7e22 263
                 jsr indlow                               ; end of program marker? ;; @@7e24 263
                 bne AutoScrollprint                      ; no-  print this line & exit ;; @@7e27 263
                 lda txttab                               ; yes- loop to start of program, ;; @@7e29 263
                 ldx txttab+1                              ;; @@7e2b 263
                 sta lowtr                                 ;; @@7e2d 263
                 stx lowtr+1                               ;; @@7e2f 263
                 jsr crdo                                 ; and add an extra newline ;; @@7e31 263
                 bra _local_1262_20                        ;; @@7e34 263
 ;; @@7e36 263
; .page ;; @@7e36 263
AutoScrolldn                                              ; wanting to scroll down ;; @@7e36 264
                 ldx #0                                   ; put cursor at top of screen ;; @@7e36 264
                 jsr AutoSearch                           ; search for a line number on screen, put it in linnum ;; @@7e38 264
                 ldx #0                                   ; get a blank line to print on ;; @@7e3b 264
                 ldy #0                                   ; put cursor at top of screen ;; @@7e3d 264
                 clc                                       ;; @@7e3f 264
                 jsr _plot                                 ;; @@7e40 264
_local_1263_10   jsr _primm                               ; and scroll screen (kill any pending Editor modes, too) ;; @@7e43 264
                 !text esc,esc,esc,"W",0                   ;; @@7e46 264
                 jsr FindLine                             ; find the line in program whose number we found on screen ;; @@7e4b 264
                 lda lowtr                                ; (does not matter if it or next higher line is found) ;; @@7e4e 264
                 cmp txttab                                ;; @@7e50 264
                 bne _local_1263_20                        ;; @@7e52 264
                 lda lowtr+1                               ;; @@7e54 264
                 cmp txttab+1                              ;; @@7e56 264
                 bne _local_1263_20                        ;; @@7e58 264
                 lda #$ff                                 ; special case- it's the very first line, want to wrap to last line ;; @@7e5a 264
                 sta linnum+1                             ; fake pointer to the last line, ;; @@7e5c 264
                 jsr _primm                               ; scroll screen to insert extra space, ;; @@7e5e 264
                 !text esc,"W",0                           ;; @@7e61 264
                 bra _local_1263_10                       ; and go around again ;; @@7e64 264
 ;; @@7e66 264
_local_1263_20   lda txttab                               ; start at beginning of program (txttab) and find the line which points at (lowtr) ;; @@7e66 264
                 ldx txttab+1                              ;; @@7e68 264
_local_1263_30   sta index                                ; pointer to link bytes ;; @@7e6a 264
                 stx index+1                               ;; @@7e6c 264
                 ldy #1                                    ;; @@7e6e 264
                 jsr indin1                               ; get link bytes ;; @@7e70 264
                 tax                                       ;; @@7e73 264
                 dey                                       ;; @@7e74 264
                 jsr indin1                                ;; @@7e75 264
                 cpx lowtr+1                              ; do link bytes point at target line? ;; @@7e78 264
                 bne _local_1263_30                        ;; @@7e7a 264
                 cmp lowtr                                 ;; @@7e7c 264
                 bne _local_1263_30                       ; no- use these link bytes to find next line ;; @@7e7e 264
 ;; @@7e80 264
                 lda index                                ; yes- copy pointer ;; @@7e80 264
                 ldx index+1                               ;; @@7e82 264
                 sta lowtr                                 ;; @@7e84 264
                 stx lowtr+1                               ;; @@7e86 264
; bra AutoScrollprint ; print the line & exit ;; @@7e88 264
 ;; @@7e88 264
; .page ;; @@7e88 264
AutoScrollprint                                            ;; @@7e88 265
                 ldy #2                                   ; get line number to print ;; @@7e88 265
                 jsr indlow                                ;; @@7e8a 265
                 tax                                       ;; @@7e8d 265
                 iny                                       ;; @@7e8e 265
                 jsr indlow                                ;; @@7e8f 265
                 jsr p1line                               ; print the number & the line ;; @@7e92 265
; bra AutoScrolldone ;Normal exit ;; @@7e95 265
 ;; @@7e95 265
AutoScrolldone                                             ;; @@7e95 265
                 jsr _primm                               ; kill special Editor modes ;; @@7e95 265
                 !text esc,esc,0                           ;; @@7e98 265
                 ldx point                                ; restore cursor position ;; @@7e9b 265
                 ldy point+1                               ;; @@7e9d 265
                 clc                                       ;; @@7e9f 265
                 jsr _plot                                 ;; @@7ea0 265
                 rmb1 helper                              ; remove LINGET flag ;; @@7ea3 265
                 pla                                      ; restore character ;; @@7ea5 265
                 clc                                      ; return to Editor, with flag we handled character ;; @@7ea6 265
                 rts                                       ;; @@7ea7 265
 ;; @@7ea8 265
AutoSearch                                                 ;; @@7ea8 265
                 ldy #0                                   ; search for any line number on screen in leftmost column ;; @@7ea8 265
                 clc                                       ;; @@7eaa 265
                 jsr _plot                                ; move to beginning of next line ;; @@7eab 265
; bcs AutoScrollpop ;  exit if no more lines ;; @@7eae 265
                 bcs _local_1264_30                       ; no more lines- fake one   [910716] ;; @@7eae 265
                 sec                                       ;; @@7eb0 265
                 jsr _plot                                ; else check if wrapped line ;; @@7eb1 265
                 bcs _local_1264_10                       ; it's wrapped- move up one line ;; @@7eb4 265
                 lda _pnt                                  ;; @@7eb6 265
                 adc _screen_left                         ; (.c=0) ;; @@7eb8 265
                 sta txtptr                               ; copy screen address of logical line to txtptr ;; @@7eba 265
                 lda _pnt+1                                ;; @@7ebc 265
                 adc #0                                    ;; @@7ebe 265
                 sta txtptr+1                              ;; @@7ec0 265
                 ldy #0                                   ; get first character on this line in window ;; @@7ec2 265
                 lda (txtptr),y                            ;; @@7ec4 265
; jsr indtxt  ;    (I did not want to limit search to the first column, ;; @@7ec6 265
                 cmp #'9'+1                               ; but it was way too slow searching the entire screen) ;; @@7ec6 265
                 bcs _local_1264_10                       ; it's not a number ;; @@7ec8 265
                 cmp #'0'                                  ;; @@7eca 265
                 bcs _local_1264_20                       ; it's a digit 0-9, continue ;; @@7ecc 265
 ;; @@7ece 265
_local_1264_10   bbs7 form,_local_1264_15                 ; not on this line- move to next line ;; @@7ece 265
                 dex                                      ; move up one line ;; @@7ed1 265
                 !text $89                                 ;; @@7ed2 265
_local_1264_15   inx                                      ; move down one line ;; @@7ed3 265
                 bra AutoSearch                           ; loop until we find a numeric digit or run out of lines ;; @@7ed4 265
 ;; @@7ed6 265
_local_1264_20   clc                                      ; found a digit, get entire number into linnum & rts ;; @@7ed6 265
                 +lbra linget                              ;; @@7ed7 265
 ;; @@7eda 265
_local_1264_30   lda #$ff                                 ; no line found, fake end of program   [910716] ;; @@7eda 265
                 sta linnum+1                              ;; @@7edc 265
                 rts                                       ;; @@7ede 265
 ;; @@7edf 265
; .ifgt *-$7f00 ;; @@7edf 265
; .messg ***ROM OVERFLOW: $7F00 ;; @@7edf 265
; .endif ;; @@7edf 265
;.end ;; @@7edf 265
; .page ;; @@7edf 265
; .subttl  GRAPHIC Interface ;; @@7edf 265
 ;; @@7edf 265
                 * = $af00                                ; [911001] ;; @@7edf 265
 ;; @@af00 265
;***************************************************************** ;; @@af00 265
; SCREEN DEF      define a screen ;; @@af00 265
; SCREEN SET  set draw, view screen ;; @@af00 265
; SCREEN CLR  clear a screen ;; @@af00 265
; SCREEN OPEN  open a screen ;; @@af00 265
; SCREEN CLOSE  close a screen ;; @@af00 265
;***************************************************************** ;; @@af00 265
 ;; @@af00 265
Screen                                                     ;; @@af00 266
                 cmp #open_token                          ; else dispatch per secondary token... ;; @@af00 266
                 +lbeq ScreenOpen                          ;; @@af02 266
                 cmp #close_token                          ;; @@af05 266
                 +lbeq ScreenClose                         ;; @@af07 266
                 cmp #def_token                            ;; @@af0a 266
                 beq ScreenDef                             ;; @@af0c 266
                 cmp #clr_token                            ;; @@af0e 266
                 beq ScreenClr                             ;; @@af10 266
 ;; @@af12 266
                 jsr chkesc                               ; [910930] ;; @@af12 266
; cmp #esc_command_token ;; @@af15 266
; bne _local_1265_10 ;; @@af15 266
; jsr chrget  ; get past escape token ;; @@af15 266
                 cmp #set_token                            ;; @@af15 266
                 beq ScreenSet                             ;; @@af17 266
_local_1265_10   +lbra snerr                              ; report syntax error ;; @@af19 266
 ;; @@af1c 266
; .page ;; @@af1c 266
CheckGraphicMode                                           ;; @@af1c 267
                 bit $1f4b                                ; Check draw screen allocation   [910711] ;; @@af1c 267
                 bmi NoGraphicArea                         ;; @@af1f 267
                 rts                                      ; ok ;; @@af21 267
 ;; @@af22 267
 ;; @@af22 267
NoGraphicArea                                              ;; @@af22 267
                 ldx #errng                               ; bad- no graphic area???? ;; @@af22 267
                 +lbra error                               ;; @@af24 267
 ;; @@af27 267
 ;; @@af27 267
RestoreTextScreen                                          ; [910404] ;; @@af27 267
                 lda #$ff                                 ; [910930] ;; @@af27 267
                 sta GKI__parm1                           ; leave drawscreen as is ;; @@af29 267
                 sta GKI__parm2                           ; set viewscreen to text ;; @@af2c 267
                 jmp ($800e)                              ; kg65.screen ;; @@af2f 267
 ;; @@af32 267
; lda vic+49  ;Check graphic screen allocation ;; @@af32 267
; and #%00010000 ;; @@af32 267
; beq 99$   ; we're in text mode ;; @@af32 267
;; bit $1f43 ;; @@af32 267
;; bmi NoGraphicArea ;; @@af32 267
; ;; @@af32 267
; sei ;; @@af32 267
; lda #$80 ;; @@af32 267
; bit _mode  ;40/80 mode, 0=80 128=40 ;; @@af32 267
; bmi _local_1266_10 ;; @@af32 267
; ;; @@af32 267
; tsb vic+49  ; 80 ;; @@af32 267
; lda #1 ;; @@af32 267
; trb vic+22  ;  fix x-scroll register ;; @@af32 267
; bra 99$ ;; @@af32 267
; ;; @@af32 267
;_local_1266_10 trb vic+49  ; 40 ;; @@af32 267
; lda #1 ;; @@af32 267
; tsb vic+22  ;  fix x-scroll register ;; @@af32 267
; ;; @@af32 267
;99$ cli ;; @@af32 267
;; lda #0 ;; @@af32 267
;; sta _graphm  ;text mode???? ;; @@af32 267
; rts ;; @@af32 267
 ;; @@af32 267
; .page ;; @@af32 267
;***************************************************************** ;; @@af32 267
; SCNCLR  clear a text or graphic screen ;; @@af32 267
; ;; @@af32 267
;  Syntax : SCNCLR  [ColorReg] ;; @@af32 267
; ;; @@af32 267
; if [ColorReg] not specified, clears text screen ;; @@af32 267
; else clears the graphic screen with given value. ;; @@af32 267
;***************************************************************** ;; @@af32 267
 ;; @@af32 267
ScreenClr                                                  ;; @@af32 267
                 jsr chrget                               ; eat token & fall into SCNCLR ;; @@af32 267
 ;; @@af35 267
scnclr                                                     ;; @@af35 267
                 bne C65__screenclear                     ; have a parameter, go clear graphic screen ;; @@af35 267
 ;; @@af37 267
                 lda #$93                                  ;; @@af37 267
                 jmp _bsout                               ; no parameter, clear text screen ;; @@af39 267
; rts ;; @@af3c 267
 ;; @@af3c 267
 ;; @@af3c 267
 ;; @@af3c 267
;***************************************************************** ;; @@af3c 267
;* SCREEN CLR  clear a graphic screen ;; @@af3c 267
;* ;; @@af3c 267
;*  Syntax : SCREEN CLR  color_reg# ;; @@af3c 267
;* ;; @@af3c 267
;*           parm1 = color reg#  0-255 ;; @@af3c 267
;***************************************************************** ;; @@af3c 267
 ;; @@af3c 267
C65__screenclear                                           ;; @@af3c 267
                 jsr getbyt                               ; get color register # (range 0-255)????? ;; @@af3c 267
;limit to range allowed by current screen def? ;; @@af3f 267
                 stx GKI__parm1                            ;; @@af3f 267
                 jsr CheckGraphicMode                      ;; @@af42 267
                 jmp ($800c)                              ; bra screenclear ;; @@af45 267
 ;; @@af48 267
; .page ;; @@af48 267
;***************************************************************** ;; @@af48 267
;* SCREEN SET  specify draw & view screens ;; @@af48 267
;* ;; @@af48 267
;*  Syntax : SCREEN SET  [DrawScreen] [,ViewScreen] ;; @@af48 267
;* ;; @@af48 267
;*           parm1 = draw screen # 0-3, 255=don't change    [910711] ;; @@af48 267
;*           parm2 = view screen # 0-3, 255=text ;; @@af48 267
;***************************************************************** ;; @@af48 267
 ;; @@af48 267
ScreenSet                                                  ;; @@af48 267
                 jsr chrget                               ; advance past token ;; @@af48 267
 ;; @@af4b 267
C65__screen                                                ;; @@af4b 267
; beq snerr  ;missing args??      [911017] ;; @@af4b 267
                 ldx #255                                 ; [911028] ;; @@af4b 267
                 cmp #','                                  ;; @@af4d 267
                 beq _local_1266_10                       ; options byte only ;; @@af4f 267
 ;; @@af51 267
                 jsr getbyt                               ; get draw screen# in .x ;; @@af51 267
; cpx #4   ;       [910711] ;; @@af54 267
; bcs 20$   ;  out of range error???? (255=leave alone)  [910930] ;; @@af54 267
_local_1266_10   stx GKI__parm1                            ;; @@af54 267
 ;; @@af57 267
                 ldx $1f69                                ; current viewscreen     [911017] ;; @@af57 267
                 jsr optbyt                               ; eat a comma, get view screen# in .x ;; @@af5a 267
; cpx #4   ; ;; @@af5d 267
;20$ bcs fcerr  ;  out of range error???? (255=text)   [910930] ;; @@af5d 267
                 stx GKI__parm2                            ;; @@af5d 267
 ;; @@af60 267
                 jsr ($800e)                              ; kg65.screen ;; @@af60 267
                 bcs NoGraphicArea                         ;; @@af63 267
                 rts                                       ;; @@af65 267
 ;; @@af66 267
; .page ;; @@af66 267
;***************************************************************** ;; @@af66 267
;* SCREEN DEF  define a graphic screen ;; @@af66 267
;* ;; @@af66 267
;*  Syntax : SCREEN DEF  screen#, width, height, depth ;; @@af66 267
;* ;; @@af66 267
;*           parm1 = screen#           0-3    [910711] ;; @@af66 267
;*           parm2 = width             0=320, 1=640, 2=1280 ;; @@af66 267
;*           parm3 = height            0=200, 1=400 ;; @@af66 267
;*           parm4 = depth             1-8 bitplanes (2-256 colors) ;; @@af66 267
;***************************************************************** ;; @@af66 267
 ;; @@af66 267
ScreenDef                                                  ;; @@af66 268
                 jsr chrget                               ; advance past token ;; @@af66 268
 ;; @@af69 268
C65__screendef                                             ;; @@af69 268
                 jsr getbyt                               ; get screen number ;; @@af69 268
                 cpx #4                                   ; range 0-3   [910711] ;; @@af6c 268
                 bcs _local_1267_10                        ;; @@af6e 268
                 stx GKI__parm1                           ; screen# ;; @@af70 268
 ;; @@af73 268
                 jsr combyt                               ; get width ;; @@af73 268
                 cpx #3                                   ; range 0-2 ???? 1280 mode ???? ;; @@af76 268
                 bcs _local_1267_10                        ;; @@af78 268
                 stx GKI__parm2                           ; width ;; @@af7a 268
 ;; @@af7d 268
                 jsr combyt                               ; get height ;; @@af7d 268
                 cpx #2                                   ; range 0-1 ;; @@af80 268
                 bcs _local_1267_10                        ;; @@af82 268
                 stx GKI__parm3                           ; height ;; @@af84 268
 ;; @@af87 268
                 jsr combyt                               ; get depth (# bitplanes) ;; @@af87 268
                 dex                                      ; convert 1-8 to 0-7 ;; @@af8a 268
                 cpx #8                                   ; range 0-7 ;; @@af8b 268
_local_1267_10   +lbcs fcerr                              ; illegal quantity error ;; @@af8d 268
                 stx GKI__parm4                           ; depth ;; @@af90 268
 ;; @@af93 268
                 jmp ($8006)                              ; bra screendef ;; @@af93 268
 ;; @@af96 268
; .page ;; @@af96 268
;***************************************************************** ;; @@af96 268
;* SCREEN OPEN  open a graphic screen for viewing or drawing ;; @@af96 268
;* ;; @@af96 268
;*  Syntax : SCREEN OPEN screen# ;; @@af96 268
;* ;; @@af96 268
;*           parm1 = screen#      0-3    [910711] ;; @@af96 268
;***************************************************************** ;; @@af96 268
 ;; @@af96 268
 ;; @@af96 268
ScreenOpen                                                 ;; @@af96 269
                 jsr chrget                               ; advance past Open token ;; @@af96 269
 ;; @@af99 269
C65__screenopen                                            ;; @@af99 269
                 jsr getbyt                               ; get screen# in .x ;; @@af99 269
                 cpx #4                                   ; range 0-3   [910711] ;; @@af9c 269
                 +lbcs fcerr                              ; branch if out of range ;; @@af9e 269
 ;; @@afa1 269
                 stx GKI__parm1                            ;; @@afa1 269
                 jmp ($8008)                              ; screenopen    [910826] ;; @@afa4 269
 ;; @@afa7 269
; bcs NoGraphicArea ; bad ???? let user catch via RGRAPHIC ;; @@afa7 269
; rts ;; @@afa7 269
 ;; @@afa7 269
; .page ;; @@afa7 269
;***************************************************************** ;; @@afa7 269
;* SCREEN CLOSE  close a graphic screen ;; @@afa7 269
;* ;; @@afa7 269
;*  Syntax : SCREEN CLOSE screen# ;; @@afa7 269
;* ;; @@afa7 269
;*           parm1 = screen#  0-3    [910711] ;; @@afa7 269
;***************************************************************** ;; @@afa7 269
 ;; @@afa7 269
 ;; @@afa7 269
ScreenClose                                                ;; @@afa7 269
                 jsr chrget                               ; advance past Close token ;; @@afa7 269
 ;; @@afaa 269
C65__screenclose                                           ;; @@afaa 269
                 jsr getbyt                               ; get screen# ;; @@afaa 269
                 cpx #4                                   ; range 0-3   [910711] ;; @@afad 269
                 +lbcs fcerr                              ; branch if out of range ;; @@afaf 269
                 stx GKI__parm1                            ;; @@afb2 269
 ;; @@afb5 269
                 jmp ($800a)                              ; bra screenclose ;; @@afb5 269
 ;; @@afb8 269
; .page ;; @@afb8 269
;***************************************************************** ;; @@afb8 269
;* PEN ;; @@afb8 269
;* ;; @@afb8 269
;*  Syntax : PEN  Pen#, ColorReg ;; @@afb8 269
;* ;; @@afb8 269
;*           parm1 = pen#  0-2 ;; @@afb8 269
;*           parm2 = color reg#  0-255 ;; @@afb8 269
;***************************************************************** ;; @@afb8 269
 ;; @@afb8 269
C65__setpen                                                ;; @@afb8 269
                 jsr getbyt                               ; get pen# ;; @@afb8 269
                 cpx #3                                   ; range 0-2 ;; @@afbb 269
                 +lbcs fcerr                              ; branch if out of range ;; @@afbd 269
                 stx GKI__parm1                            ;; @@afc0 269
 ;; @@afc3 269
                 jsr combyt                               ; get color reg# ;; @@afc3 269
;???? error check for max color allowed ;; @@afc6 269
; for the current screen. ;; @@afc6 269
                 stx GKI__parm2                            ;; @@afc6 269
 ;; @@afc9 269
                 jmp ($8010)                              ; bra setpen ;; @@afc9 269
 ;; @@afcc 269
; .page ;; @@afcc 269
;***************************************************************** ;; @@afcc 269
;* DMODE   Set Draw Mode ;; @@afcc 269
;* ;; @@afcc 269
;*  Syntax : DMODE  jam, complement, stencil, style, thickness ;; @@afcc 269
;* ;; @@afcc 269
;*         parm1 = jam           0-1 ;; @@afcc 269
;*         parm2 = complement (XOR) 0-1 ;; @@afcc 269
;*         parm3 = stencil       0-1  <<< not implemented  [911003] ;; @@afcc 269
;*         parm4 = style         0-3  <<< only 0-1 implemented [911003] ;; @@afcc 269
;*         parm5 = thickness     1-8  <<< not implemented  [911003] ;; @@afcc 269
;******************************************************************* ;; @@afcc 269
 ;; @@afcc 269
C65__setdmode                                              ;; @@afcc 269
                 jsr getbyt                               ; jam mode ;; @@afcc 269
                 cpx #2                                    ;; @@afcf 269
                 bcs _local_1268_10                        ;; @@afd1 269
                 stx GKI__parm1                            ;; @@afd3 269
 ;; @@afd6 269
                 jsr combyt                               ; complement (xor) mode ;; @@afd6 269
                 cpx #2                                   ; (ignores jam mode if set) ;; @@afd9 269
                 bcs _local_1268_10                        ;; @@afdb 269
                 stx GKI__parm2                            ;; @@afdd 269
 ;; @@afe0 269
                 jsr combyt                               ; stencil mode (not implemented) ;; @@afe0 269
                 cpx #2                                    ;; @@afe3 269
                 bcs _local_1268_10                        ;; @@afe5 269
                 stx GKI__parm3                            ;; @@afe7 269
 ;; @@afea 269
                 jsr combyt                               ; style mode ;; @@afea 269
                 cpx #4                                   ; 0=solid, 1=pattern, 2=tile (not implemented), 3=reserved ;; @@afed 269
                 bcs _local_1268_10                        ;; @@afef 269
                 stx GKI__parm4                            ;; @@aff1 269
 ;; @@aff4 269
                 jsr combyt                               ; thickness mode (not implemented) ;; @@aff4 269
; dex   ; adjust to 0-7     [911003] ;; @@aff7 269
                 cpx #8+1                                  ;; @@aff7 269
_local_1268_10   +lbcs fcerr                              ; illegal quantity error ;; @@aff9 269
                 stx GKI__parm5                            ;; @@affc 269
 ;; @@afff 269
                 jmp ($8014)                              ; bra setdmode ;; @@afff 269
 ;; @@b002 269
; .page ;; @@b002 269
;***************************************************************** ;; @@b002 269
;* DPAT   set draw pattern ;; @@b002 269
;* ;; @@b002 269
;*  Syntax : DPAT  type [, # bytes, byte1, byte2, byte3, byte4] ;; @@b002 269
;* ;; @@b002 269
;*           parm1 = type        0-63  <<< only 0-4 implemented [911003] ;; @@b002 269
;*           parm2 = # bytes     1-4 ;; @@b002 269
;*           parm3 = byte1       0-255 ;; @@b002 269
;*           parm4 = byte2       0-255 ;; @@b002 269
;*           parm5 = byte3       0-255 ;; @@b002 269
;*           parm6 = byte4       0-255 ;; @@b002 269
;***************************************************************** ;; @@b002 269
 ;; @@b002 269
C65__setdpat                                               ;; @@b002 270
                 jsr getbyt                               ; get pattern type ;; @@b002 270
                 cpx #4+1                                 ; 63+1       [911028] ;; @@b005 270
_local_1269_10   +lbcs fcerr                              ; if out of range ;; @@b007 270
                 stx GKI__parm1                            ;; @@b00a 270
                 txa                                       ;; @@b00d 270
                 bne _local_1269_20                       ; if parm1 is 0 then get extra stuff ;; @@b00e 270
 ;; @@b010 270
                 jsr combyt                               ; get number of bytes ;; @@b010 270
                 cpx #5                                    ;; @@b013 270
                 bcs _local_1269_10                       ; too many bytes ;; @@b015 270
                 stx GKI__parm2                            ;; @@b017 270
                 stx z_p_temp_1                           ; save for count ;; @@b01a 270
 ;; @@b01c 270
                 jsr combyt                               ; get byte 1 ;; @@b01c 270
                 stx GKI__parm3                            ;; @@b01f 270
                 dec z_p_temp_1                            ;; @@b022 270
                 beq _local_1269_20                        ;; @@b024 270
                 +lbmi fcerr                              ; too few bytes ;; @@b026 270
 ;; @@b029 270
                 jsr combyt                               ; get byte 2 ;; @@b029 270
                 stx GKI__parm4                            ;; @@b02c 270
                 dec z_p_temp_1                            ;; @@b02f 270
                 beq _local_1269_20                        ;; @@b031 270
 ;; @@b033 270
                 jsr combyt                               ; get byte 3 ;; @@b033 270
                 stx GKI__parm5                            ;; @@b036 270
                 dec z_p_temp_1                            ;; @@b039 270
                 beq _local_1269_20                        ;; @@b03b 270
 ;; @@b03d 270
                 jsr combyt                               ; get byte 4 ;; @@b03d 270
                 stx GKI__parm6                            ;; @@b040 270
 ;; @@b043 270
_local_1269_20   jmp ($8016)                              ; bra setdpat ;; @@b043 270
 ;; @@b046 270
; .page ;; @@b046 270
;***************************************************************** ;; @@b046 270
;* PALETTE   set palette colors ;; @@b046 270
;* ;; @@b046 270
;*  Syntax : PALETTE {screen|COLOR}, color_index, red, green, blue ;; @@b046 270
;*           PALETTE RESTORE ;; @@b046 270
;* ;; @@b046 270
;*           parm1 = screen  0-3     [910711] ;; @@b046 270
;*           parm2 = color_index 0-255 ;; @@b046 270
;*           parm3 = red           0-31 (b0-3 red, b4=fgbg)  [910520] ;; @@b046 270
;*           parm4 = green         0-15 ;; @@b046 270
;*           parm5 = blue          0-15 ;; @@b046 270
;***************************************************************** ;; @@b046 270
 ;; @@b046 270
C65__setpalette                                            ;; @@b046 271
                 cmp #restore_token                       ; restore palette? ;; @@b046 271
                 bne _local_1270_10                       ; no ;; @@b048 271
                 jsr chrget                               ; yes- advance past Restore token ;; @@b04a 271
                 jmp _palette_init                         ;; @@b04d 271
 ;; @@b050 271
_local_1270_10   cmp #color_token                         ; set physical color register? ;; @@b050 271
                 bne _local_1270_20                       ; no- set logical color register ;; @@b052 271
                 sta GKI__parm1                            ;; @@b054 271
                 jsr chrget                               ; yes- advance past Color token ;; @@b057 271
                 jsr getbyt                                ;; @@b05a 271
                 bra _local_1270_30                        ;; @@b05d 271
 ;; @@b05f 271
_local_1270_20   jsr getbyt                               ; get screen# ;; @@b05f 271
                 cpx #4                                   ; [910711] ;; @@b062 271
                 +lbcs fcerr                               ;; @@b064 271
                 stx GKI__parm1                            ;; @@b067 271
 ;; @@b06a 271
                 jsr combyt                               ; get color reg # ;; @@b06a 271
_local_1270_30   stx GKI__parm2                           ; (GKI will check for out of range????) ;; @@b06d 271
 ;; @@b070 271
set_palette                                                ;; @@b070 272
                 jsr combyt                               ; get red & fgbg ;; @@b070 272
                 cpx #32                                  ; [910520] ;; @@b073 272
                 +lbcs fcerr                               ;; @@b075 272
                 stx GKI__parm3                            ;; @@b078 272
 ;; @@b07b 272
                 jsr getcomnyb                            ; get green ;; @@b07b 272
; cpx #16 ;; @@b07e 272
; bcs 10$ ;; @@b07e 272
                 stx GKI__parm4                            ;; @@b07e 272
 ;; @@b081 272
                 jsr getcomnyb                            ; get blue ;; @@b081 272
; cpx #16 ;; @@b084 272
; bcs fcerr  ; illegal quantity error ;; @@b084 272
                 stx GKI__parm5                            ;; @@b084 272
 ;; @@b087 272
                 lda GKI__parm1                           ; logical or physical color register? ;; @@b087 272
                 bpl _local_1271_40                       ; logical ;; @@b08a 272
                 ldx GKI__parm2                            ;; @@b08c 272
                 lda GKI__parm3                           ; physical ;; @@b08f 272
                 sta _red,x                                ;; @@b092 272
                 lda GKI__parm4                            ;; @@b095 272
                 sta _green,x                              ;; @@b098 272
                 lda GKI__parm5                            ;; @@b09b 272
                 sta _blue,x                               ;; @@b09e 272
                 bra _local_1271_50                        ;; @@b0a1 272
 ;; @@b0a3 272
_local_1271_40   jsr ($8012)                              ; go set screen palette ;; @@b0a3 272
                 +lbcs NoGraphicArea                      ; illegal screen# or color#  [910917] ;; @@b0a6 272
 ;; @@b0a9 272
_local_1271_50   jsr optbyt                               ; get another color reg # ? ;; @@b0a9 272
                 stx GKI__parm2                            ;; @@b0ac 272
                 bcs set_palette                          ; yes- loop ;; @@b0af 272
                 rts                                       ;; @@b0b1 272
 ;; @@b0b2 272
; .page ;; @@b0b2 272
;***************************************************************** ;; @@b0b2 272
;* LINE  draw a dot, a line or a stick shape ;; @@b0b2 272
;* ;; @@b0b2 272
;*  Syntax : LINE  x0, y0 [,[x1] [,y1]]... ;; @@b0b2 272
;* ;; @@b0b2 272
;* parm1,2 = x0 (lo/hi) ;; @@b0b2 272
;* parm3,4 = y0 ;; @@b0b2 272
;* parm5,6 = x1 (x1,y1)=(x0,y0) if not specified ;; @@b0b2 272
;* parm7,8 = y1 ;; @@b0b2 272
;***************************************************************** ;; @@b0b2 272
 ;; @@b0b2 272
C65__line                                                  ;; @@b0b2 273
                 cmp #input_token                         ; special check for 'line input#'  [910103] ;; @@b0b2 273
                 +lbeq linputn                            ; yes ;; @@b0b4 273
                 cmp #input_token+1                       ; special check for 'line input' ;; @@b0b7 273
                 +lbeq linput                             ; yes ;; @@b0b9 273
 ;; @@b0bc 273
                 jsr CheckGraphicMode                      ;; @@b0bc 273
                 jsr sadwrd                               ; get x0 ;; @@b0bf 273
                 sty GKI__parm1                            ;; @@b0c2 273
                 sta GKI__parm2                            ;; @@b0c5 273
                 sty GKI__parm5                           ; [910228] ;; @@b0c8 273
                 sta GKI__parm6                            ;; @@b0cb 273
 ;; @@b0ce 273
                 jsr comsad                               ; get y0 ;; @@b0ce 273
                 sty GKI__parm3                            ;; @@b0d1 273
                 sta GKI__parm4                            ;; @@b0d4 273
                 sty GKI__parm7                           ; [910228] ;; @@b0d7 273
                 sta GKI__parm8                            ;; @@b0da 273
 ;; @@b0dd 273
                 jsr optsad                               ; get x1     [910228] ;; @@b0dd 273
                 bcc _local_1272_10                       ; use x0 ;; @@b0e0 273
_local_1272_1    sty GKI__parm5                            ;; @@b0e2 273
                 sta GKI__parm6                            ;; @@b0e5 273
 ;; @@b0e8 273
_local_1272_10   jsr optsad                               ; get y1     [910228] ;; @@b0e8 273
                 bcc _local_1272_20                       ; use y0 ;; @@b0eb 273
                 sty GKI__parm7                            ;; @@b0ed 273
                 sta GKI__parm8                            ;; @@b0f0 273
 ;; @@b0f3 273
_local_1272_20   jsr ($8018)                              ; draw a line from x0,y0 to x1,y1 ;; @@b0f3 273
 ;; @@b0f6 273
                 ldx #3                                    ;; @@b0f6 273
_local_1272_30   lda GKI__parm5,x                         ; copy x1,y1 to x0,y0 ;; @@b0f8 273
                 sta GKI__parm1,x                          ;; @@b0fb 273
                 dex                                       ;; @@b0fe 273
                 bpl _local_1272_30                        ;; @@b0ff 273
 ;; @@b101 273
                 jsr optsad                               ; more? ;; @@b101 273
                 bcs _local_1272_1                        ; yes, continue ;; @@b104 273
                 rts                                       ;; @@b106 273
 ;; @@b107 273
; .page ;; @@b107 273
;***************************************************************** ;; @@b107 273
;* BOX   draw a 4-sided figure ;; @@b107 273
;* ;; @@b107 273
;*  Syntax :  BOX x0,y0, x1,y1, x2,y2, x3,y3 [,solid flag] ;; @@b107 273
;* ;; @@b107 273
;* parm1,2   = x0  (lo/hi) ;; @@b107 273
;* parm3,4   = y0 ;; @@b107 273
;* parm5,6   = x1 ;; @@b107 273
;* parm7,8   = y1 ;; @@b107 273
;* parm9,10  = x2 ;; @@b107 273
;* parm11,12 = y2 ;; @@b107 273
;* parm13,14 = x3 ;; @@b107 273
;* parm15,16 = y3 ;; @@b107 273
;* parm17    = solid flag ;; @@b107 273
;***************************************************************** ;; @@b107 273
 ;; @@b107 273
C65__box                                                   ;; @@b107 274
                 jsr CheckGraphicMode                      ;; @@b107 274
                 jsr sadwrd                               ; get x0 ;; @@b10a 274
                 sty GKI__parm1                            ;; @@b10d 274
                 sta GKI__parm2                            ;; @@b110 274
 ;; @@b113 274
                 jsr comsad                               ; get y0 ;; @@b113 274
                 sty GKI__parm3                            ;; @@b116 274
                 sta GKI__parm4                            ;; @@b119 274
 ;; @@b11c 274
                 jsr comsad                               ; get x1 ;; @@b11c 274
                 sty GKI__parm5                            ;; @@b11f 274
                 sta GKI__parm6                            ;; @@b122 274
 ;; @@b125 274
                 jsr comsad                               ; get y1 ;; @@b125 274
                 sty GKI__parm7                            ;; @@b128 274
                 sta GKI__parm8                            ;; @@b12b 274
 ;; @@b12e 274
                 jsr comsad                               ; get x2 ;; @@b12e 274
                 sty GKI__parm9                            ;; @@b131 274
                 sta GKI__parm10                           ;; @@b134 274
 ;; @@b137 274
                 jsr comsad                               ; get y2 ;; @@b137 274
                 sty GKI__parm11                           ;; @@b13a 274
                 sta GKI__parm12                           ;; @@b13d 274
 ;; @@b140 274
                 jsr comsad                               ; get x3 ;; @@b140 274
                 sty GKI__parm13                           ;; @@b143 274
                 sta GKI__parm14                           ;; @@b146 274
 ;; @@b149 274
                 jsr comsad                               ; get y3 ;; @@b149 274
                 sty GKI__parm15                           ;; @@b14c 274
                 sta GKI__parm16                           ;; @@b14f 274
 ;; @@b152 274
                 jsr optzer                               ; get solid flag ;; @@b152 274
                 stx GKI__parm17                           ;; @@b155 274
 ;; @@b158 274
                 jmp ($801a)                              ; bra box ;; @@b158 274
 ;; @@b15b 274
; .page ;; @@b15b 274
;***************************************************************** ;; @@b15b 274
;* CIRCLE   draw a Circle ;; @@b15b 274
;* ;; @@b15b 274
;*  Syntax : CIRCLE  CenterX, CenterY, radius [,solid flag] ;; @@b15b 274
;* ;; @@b15b 274
;*         parm1 = center x lo ;; @@b15b 274
;*         parm2 = center x hi ;; @@b15b 274
;*         parm3 = center y lo ;; @@b15b 274
;*         parm4 = center y hi ;; @@b15b 274
;*         parm5 = radius lo ;; @@b15b 274
;*         parm6 = radius hi ;; @@b15b 274
;*         parm7 = solid flag 0=no, 1=yes ;; @@b15b 274
;***************************************************************** ;; @@b15b 274
 ;; @@b15b 274
C65__circle                                                ;; @@b15b 274
                 jsr CheckGraphicMode                      ;; @@b15b 274
                 jsr sadwrd                               ; get center x ;; @@b15e 274
                 sty GKI__parm1                            ;; @@b161 274
                 sta GKI__parm2                            ;; @@b164 274
 ;; @@b167 274
                 jsr comsad                               ; get center y ;; @@b167 274
                 sty GKI__parm3                            ;; @@b16a 274
                 sta GKI__parm4                            ;; @@b16d 274
 ;; @@b170 274
                 jsr comsad                               ; get radius ;; @@b170 274
                 sty GKI__parm5                            ;; @@b173 274
                 sta GKI__parm6                            ;; @@b176 274
 ;; @@b179 274
                 jsr optzer                               ; get solid flag ;; @@b179 274
                 cpx #2                                    ;; @@b17c 274
                 +lbcs fcerr                               ;; @@b17e 274
                 stx GKI__parm7                            ;; @@b181 274
 ;; @@b184 274
                 jmp ($801c)                              ; bra circle ;; @@b184 274
 ;; @@b187 274
; .page ;; @@b187 274
; .subttl  ELLIPSE ;; @@b187 274
 ;; @@b187 274
;***************************************************************** ;; @@b187 274
;* ELLIPSE   draw an Ellipse ;; @@b187 274
;* ;; @@b187 274
;*  Syntax : ELLIPSE  CenterX, CenterY, RadiusX,  RadiusY  [,solid flag] ;; @@b187 274
;* ;; @@b187 274
;*         parm1 = center x lo ;; @@b187 274
;*         parm2 = center x hi ;; @@b187 274
;*         parm3 = center y lo ;; @@b187 274
;*         parm4 = center y hi ;; @@b187 274
;*         parm5 = x radius lo ;; @@b187 274
;*         parm6 = x radius hi ;; @@b187 274
;*         parm7 = y radius lo ;; @@b187 274
;*         parm8 = y radius hi ;; @@b187 274
;*         parm9 = solid flag 0-1 ;; @@b187 274
;***************************************************************** ;; @@b187 274
 ;; @@b187 274
C65__ellipse                                               ;; @@b187 274
                 jsr CheckGraphicMode                      ;; @@b187 274
                 jsr sadwrd                               ; get center x ;; @@b18a 274
                 sty GKI__parm1                            ;; @@b18d 274
                 sta GKI__parm2                            ;; @@b190 274
 ;; @@b193 274
                 jsr comsad                               ; get center y ;; @@b193 274
                 sty GKI__parm3                            ;; @@b196 274
                 sta GKI__parm4                            ;; @@b199 274
 ;; @@b19c 274
                 jsr comsad                               ; get xradius ;; @@b19c 274
                 sty GKI__parm5                            ;; @@b19f 274
                 sta GKI__parm6                            ;; @@b1a2 274
 ;; @@b1a5 274
                 jsr comsad                               ; get yradius ;; @@b1a5 274
                 sty GKI__parm7                            ;; @@b1a8 274
                 sta GKI__parm8                            ;; @@b1ab 274
 ;; @@b1ae 274
                 jsr optzer                               ; get solid flag ;; @@b1ae 274
                 cpx #2                                    ;; @@b1b1 274
                 +lbcs fcerr                               ;; @@b1b3 274
                 stx GKI__parm9                            ;; @@b1b6 274
 ;; @@b1b9 274
                 jmp ($8020)                              ; bra ellipse ;; @@b1b9 274
 ;; @@b1bc 274
; .page ;; @@b1bc 274
; .subttl  POLYGON ;; @@b1bc 274
 ;; @@b1bc 274
;***************************************************************** ;; @@b1bc 274
;* POLYGON   draw a regular n-sided Polygon ;; @@b1bc 274
;* ;; @@b1bc 274
;*  POLYGON  X,Y, Xradius, Yradius, sides [,drawsides [,subtend [,angle [,solid] ]]] ;; @@b1bc 274
;* ;; @@b1bc 274
;*         parm1 = center x lo ;; @@b1bc 274
;*         parm2 = center x hi ;; @@b1bc 274
;*         parm3 = center y lo ;; @@b1bc 274
;*         parm4 = center y hi ;; @@b1bc 274
;*         parm5 = xradius lo ;; @@b1bc 274
;*         parm6 = xradius hi ;; @@b1bc 274
;*         parm7 = yradius lo ;; @@b1bc 274
;*         parm8 = yradius hi ;; @@b1bc 274
;*         parm9 = solid flag 0-1 ;; @@b1bc 274
;*         parm10 = sa lo (starting angle 0-360) ;; @@b1bc 274
;*         parm11 = sa hi ;; @@b1bc 274
;*         parm12 = # of sides to draw (1 to 127) ;; @@b1bc 274
;*         parm13 = # of sides (3 to parm12) ;; @@b1bc 274
;*         parm14 = subtend flag 0-1 ;; @@b1bc 274
;**************************************************************** ;; @@b1bc 274
 ;; @@b1bc 274
C65__polygon                                              ; changed BASIC syntax to something more reasonable [910923] FAB ;; @@b1bc 274
                 jsr CheckGraphicMode                      ;; @@b1bc 274
                 jsr sadwrd                               ; get center x ;; @@b1bf 274
                 sty GKI__parm1                            ;; @@b1c2 274
                 sta GKI__parm2                            ;; @@b1c5 274
 ;; @@b1c8 274
                 jsr comsad                               ; get center y ;; @@b1c8 274
                 sty GKI__parm3                            ;; @@b1cb 274
                 sta GKI__parm4                            ;; @@b1ce 274
 ;; @@b1d1 274
                 jsr comwrd                               ; get x radius ;; @@b1d1 274
                 sty GKI__parm5                            ;; @@b1d4 274
                 sta GKI__parm6                            ;; @@b1d7 274
 ;; @@b1da 274
                 jsr comwrd                               ; get y radius ;; @@b1da 274
                 sty GKI__parm7                            ;; @@b1dd 274
                 sta GKI__parm8                            ;; @@b1e0 274
 ;; @@b1e3 274
                 jsr combyt                               ; get number of sides ;; @@b1e3 274
                 cpx #3                                    ;; @@b1e6 274
                 bcc _local_1273_20                       ; too few ;; @@b1e8 274
                 cpx #128                                  ;; @@b1ea 274
_local_1273_10   +lbcs fcerr                              ; too many ;; @@b1ec 274
                 stx GKI__parm13                           ;; @@b1ef 274
 ;; @@b1f2 274
; ldx GKI__parm13  ;get number of sides to draw (default=#sides) ;; @@b1f2 274
                 jsr optbyt                                ;; @@b1f2 274
                 cpx #1                                   ; must be at least 1 side ;; @@b1f5 274
_local_1273_20   +lbcc fcerr                               ;; @@b1f7 274
                 stx GKI__parm12                           ;; @@b1fa 274
                 dex                                       ;; @@b1fd 274
                 cpx GKI__parm13                          ; draw sides must be <= #sides ;; @@b1fe 274
                 bcs _local_1273_10                        ;; @@b201 274
 ;; @@b203 274
                 jsr optzer                               ; get subtend flag ;; @@b203 274
; cpx #2 ;; @@b206 274
; bcs _local_1273_10 ;; @@b206 274
                 stx GKI__parm14                           ;; @@b206 274
 ;; @@b209 274
                 jsr optwrd                               ; get starting angle (default=0 degrees) ;; @@b209 274
                 sty GKI__parm10                          ; lo ;; @@b20c 274
                 sta GKI__parm11                          ; hi ;; @@b20f 274
 ;; @@b212 274
                 jsr optzer                               ; get solid flag ;; @@b212 274
; cpx #2 ;; @@b215 274
; bcs _local_1273_10 ;; @@b215 274
                 stx GKI__parm9                            ;; @@b215 274
 ;; @@b218 274
                 jmp ($801e)                              ; bra polygon ;; @@b218 274
 ;; @@b21b 274
; .page ;; @@b21b 274
; .subttl  SET multipurpose command ;; @@b21b 274
 ;; @@b21b 274
;  SET  A multipurpose command initiator ;; @@b21b 274
 ;; @@b21b 274
 ;; @@b21b 274
C65__set                                                   ;; @@b21b 275
                 cmp #verify_token                        ; SET VERIFY <ON | OFF>  new [910429] ;; @@b21b 275
                 +lbeq verify_mode                         ;; @@b21d 275
                 cmp #def_token                           ; SET DEF unit ;; @@b220 275
                 bne _local_1274_10                        ;; @@b222 275
                 jsr getdisknum_1                          ;; @@b224 275
                 stx _default_drive                        ;; @@b227 275
                 stx dosfa                                ; Make last DOS device = current device ;; @@b22a 275
                 +lbra Clear_DS                            ;; @@b22d 275
 ;; @@b230 275
 ;; @@b230 275
 ;; @@b230 275
_local_1274_10   jsr chkesc                               ; Must be ESCape token ;; @@b230 275
                 cmp #disk_token                          ; ok so far ;; @@b233 275
                 +lbne bad_command                        ; unknown command ;; @@b235 275
 ;; @@b238 275
 ;; @@b238 275
 ;; @@b238 275
 ;; @@b238 275
                 jsr getdisknum_1                         ; SET DISK # [<,|TO> #] ;; @@b238 275
                 stx dosfa                                ; got current disk unit # ;; @@b23b 275
 ;; @@b23e 275
                 jsr chrgot                               ; check delimiter (comma, 'TO', or eos) ;; @@b23e 275
                 +lbeq Clear_DS                           ; eos- just change DOS' current drive [910417] ;; @@b241 275
                 cmp #','                                 ; not eos, must be comma or 'TO' ;; @@b244 275
                 beq _local_1274_20                        ;; @@b246 275
                 cmp #to_token                             ;; @@b248 275
                 +lbne snerr                               ;; @@b24a 275
 ;; @@b24d 275
_local_1274_20   jsr getdisknum_1                         ; skip delimiter ;; @@b24d 275
                 stx dosds2                               ; got new disk unit # ;; @@b250 275
 ;; @@b253 275
 ;; @@b253 275
; .page ;; @@b253 275
;  Open disk command channel & pass it 'renumber' command ;; @@b253 275
 ;; @@b253 275
                 jsr dclall                               ; Close any open files???? ;; @@b253 275
 ;; @@b256 275
                 ldx #6-1                                  ;; @@b256 275
_local_1274_30   lda disk_renum_cmd,x                     ; move command to RAM, setup for open ;; @@b258 275
                 sta savram,x                              ;; @@b25b 275
                 dex                                       ;; @@b25e 275
                 bpl _local_1274_30                        ;; @@b25f 275
                 lda dosds2                                ;; @@b261 275
                 ora #32                                  ; make new # a talk/listen address ;; @@b264 275
                 sta savram+6                              ;; @@b266 275
                 lda dosds2                                ;; @@b269 275
                 ora #64                                   ;; @@b26c 275
                 sta savram+7                              ;; @@b26e 275
 ;; @@b271 275
                 lda #8                                   ; command string length ;; @@b271 275
                 jsr SendDiskCmd                          ; Send command ;; @@b273 275
                 lda dosds2                                ;; @@b276 275
                 sta dosfa                                ; Make last DOS device = current device ;; @@b279 275
                 +lbra close_out_1                        ; common error check & exit path ???? ;; @@b27c 275
 ;; @@b27f 275
 ;; @@b27f 275
disk_renum_cmd   !text "M-W",119,0,2                      ; Renumber Drive command ;; @@b27f 276
 ;; @@b285 276
; .page ;; @@b285 276
 ;; @@b285 276
;  GetDiskNum - Get a (required) disk number and check it ;; @@b285 276
 ;; @@b285 276
getdisknum_1                                               ;; @@b285 276
                 jsr chrget                               ; skip current character ;; @@b285 276
getdisknum                                                 ;; @@b288 276
                 jsr getbyt                               ; get number in .x ;; @@b288 276
                 cpx #8                                   ; check range (8-30) ;; @@b28b 276
                 +lbcc fcerr                               ;; @@b28d 276
                 cpx #31                                   ;; @@b290 276
                 +lbcs fcerr                               ;; @@b292 276
                 rts                                      ; returns only if okay ;; @@b295 276
 ;; @@b296 276
 ;; @@b296 276
 ;; @@b296 276
;  SendDiskCmd - Send command in SAVRAM to disk, length in .A ;; @@b296 276
 ;; @@b296 276
SendDiskCmd                                                ;; @@b296 276
; lda #   ; command string length ;; @@b296 276
                 ldx #<savram                             ; address ;; @@b296 276
                 ldy #>savram                              ;; @@b298 276
                 jsr _setnam                               ;; @@b29a 276
                 ldx #sys_bank                            ; ???? sysbank ???? ;; @@b29d 276
                 jsr _setbank                              ;; @@b29f 276
                 jsr _clrch                               ; Restore normal channels, establish our's ;; @@b2a2 276
                 ldx dosfa                                ; fa ;; @@b2a5 276
                 lda #doslfn                              ; la (reserved la) ;; @@b2a8 276
                 ldy #$6f                                 ; sa (command channel) ;; @@b2aa 276
                 jsr _setlfs                               ;; @@b2ac 276
                 jsr _open                                ; open channel & send command ;; @@b2af 276
                 lda #doslfn                              ; close it already ;; @@b2b2 276
                 sec                                      ; not a real close ;; @@b2b4 276
                 jsr _close                                ;; @@b2b5 276
                 +lbra Clear_DS                           ; Exit ;; @@b2b8 276
 ;; @@b2bb 276
; .page ;; @@b2bb 276
;  SET VERIFY <ON | OFF> Set DOS verify-after-write mode for 3.5" drives ;; @@b2bb 276
 ;; @@b2bb 276
verify_mode                                                ;; @@b2bb 276
                 jsr chrget                               ; eat 'verify' token, get next  new [910429] ;; @@b2bb 276
                 cmp #on_token                             ;; @@b2be 276
                 sec                                       ;; @@b2c0 276
                 beq _local_1275_10                       ; turn verify on (.c=1) ;; @@b2c1 276
                 jsr chkesc                                ;; @@b2c3 276
                 cmp #off_token                           ; turn cursor off (.c=0) ;; @@b2c6 276
                 +lbne snerr                               ;; @@b2c8 276
                 clc                                       ;; @@b2cb 276
 ;; @@b2cc 276
;  Open disk command channel & pass it 'verify' command ;; @@b2cc 276
 ;; @@b2cc 276
_local_1275_10   php                                      ; Save mode ;; @@b2cc 276
                 jsr chkeos                               ; eat 'on/off' token, error if not eos ;; @@b2cd 276
 ;; @@b2d0 276
                 ldx #4-1                                  ;; @@b2d0 276
_local_1275_20   lda verify_cmd,x                         ; move command to RAM, setup for open ;; @@b2d2 276
                 sta savram,x                              ;; @@b2d5 276
                 dex                                       ;; @@b2d8 276
                 bpl _local_1275_20                        ;; @@b2d9 276
 ;; @@b2db 276
                 lda #0                                   ; form on/off flag ;; @@b2db 276
                 plp                                       ;; @@b2dd 276
                 rol                                       ;; @@b2de 276
                 ora #$30                                  ;; @@b2df 276
                 sta savram+4                              ;; @@b2e1 276
 ;; @@b2e4 276
                 lda #5                                   ; command string length ;; @@b2e4 276
                 jsr SendDiskCmd                          ; Send command ;; @@b2e6 276
                 +lbra close_out_1                        ; common error check & exit path ???? ;; @@b2e9 276
 ;; @@b2ec 276
 ;; @@b2ec 276
verify_cmd       !text "U0>V"                             ; Verify on/off command ;; @@b2ec 277
 ;; @@b2f0 277
;.end ;; @@b2f0 277
; .page ;; @@b2f0 277
; .subttl  CHAR ;; @@b2f0 277
 ;; @@b2f0 277
;***************************************************************** ;; @@b2f0 277
;* CHAR   draw a character string ;; @@b2f0 277
;* ;; @@b2f0 277
;*  Syntax : CHAR column, row, height, width, direction, "string" [,charsetadr [,bank]] ;; @@b2f0 277
;* ;; @@b2f0 277
;* parm1  = column# ;; @@b2f0 277
;* parm2  = row lo ;; @@b2f0 277
;* parm3  = row hi ;; @@b2f0 277
;* parm4  = height ;; @@b2f0 277
;* parm5  = width ;; @@b2f0 277
;* parm6  = direction ;; @@b2f0 277
;* parm7  = len of string ;; @@b2f0 277
;* parm8  = lo addr of string ;; @@b2f0 277
;* parm9  = hi addr of string ;; @@b2f0 277
;* parm10 = lo addr of character set $29800 default ;; @@b2f0 277
;* parm11 = hi addr of character set ;; @@b2f0 277
;* parm12 = bank of character set   [910912] ;; @@b2f0 277
;**************************************************************** ;; @@b2f0 277
 ;; @@b2f0 277
C65__char                                                  ;; @@b2f0 277
                 jsr CheckGraphicMode                      ;; @@b2f0 277
                 jsr getbyt                               ; get column ;; @@b2f3 277
                 stx GKI__parm1                            ;; @@b2f6 277
 ;; @@b2f9 277
                 jsr comsad                               ; get row ;; @@b2f9 277
                 sty GKI__parm2                            ;; @@b2fc 277
                 sta GKI__parm3                            ;; @@b2ff 277
 ;; @@b302 277
                 jsr combyt                               ; get height ;; @@b302 277
                 stx GKI__parm4                            ;; @@b305 277
 ;; @@b308 277
                 jsr combyt                               ; get width ;; @@b308 277
                 stx GKI__parm5                            ;; @@b30b 277
 ;; @@b30e 277
                 jsr combyt                               ; get direction ;; @@b30e 277
                 stx GKI__parm6                            ;; @@b311 277
 ;; @@b314 277
                 jsr chkcom                                ;; @@b314 277
                 jsr frmevl                               ; evaluate the string ;; @@b317 277
                 jsr chkstr                               ; type mismatch error if not string ;; @@b31a 277
                 ldy #0                                    ;; @@b31d 277
                 jsr indfmo                               ; pointer to string descriptor is left in the fac by frmevl ;; @@b31f 277
                 sta GKI__parm7                           ; length  ???? check for null string ???? ;; @@b322 277
                 pha                                       ;; @@b325 277
                 iny                                       ;; @@b326 277
                 jsr indfmo                                ;; @@b327 277
                 sta GKI__parm8                           ; adrlo ;; @@b32a 277
                 iny                                       ;; @@b32d 277
                 jsr indfmo                                ;; @@b32e 277
                 sta GKI__parm9                           ; adrhi ;; @@b331 277
                 jsr frefac                               ; [910917] ;; @@b334 277
                 pla                                       ;; @@b337 277
                 jsr getspa                                ;; @@b338 277
 ;; @@b33b 277
                 jsr optwrd                               ; get charset address (????bank) ;; @@b33b 277
                 bcs _local_1276_10                       ; given ;; @@b33e 277
                 ldy #<$9800                              ; not given- use ROM as default   [910207] FAB ;; @@b340 277
                 lda #>$9800                              ; ???? uc/lc or graphic set ???? ;; @@b342 277
_local_1276_10   sty GKI__parm10                          ; lo ;; @@b344 277
                 sta GKI__parm11                          ; hi ;; @@b347 277
                 ldx #2                                   ; default to ROM bank 2    [910912] FAB ;; @@b34a 277
                 jsr optbyt                                ;; @@b34c 277
                 stx GKI__parm12                           ;; @@b34f 277
 ;; @@b352 277
                 lda GKI__parm7                           ; ???? check for null string ???? ;; @@b352 277
                 beq _local_1276_40                        ;; @@b355 277
                 jmp ($802c)                              ; bra kg65.char ;; @@b357 277
 ;; @@b35a 277
_local_1276_40   rts                                       ;; @@b35a 277
 ;; @@b35b 277
; .page ;; @@b35b 277
; .subttl  PAINT ;; @@b35b 277
 ;; @@b35b 277
;***************************************************************** ;; @@b35b 277
;* PAINT   fill a graphic area with color ;; @@b35b 277
;* ;; @@b35b 277
;*  Syntax : PAINT x, y [,mode [,color]] ;; @@b35b 277
;* ;; @@b35b 277
;* parm1  = x lo ;; @@b35b 277
;* parm2  = x lo ;; @@b35b 277
;* parm3  = y lo ;; @@b35b 277
;* parm4  = y hi ;; @@b35b 277
;* parm5  = mode ;; @@b35b 277
;* parm6  = color ;; @@b35b 277
;* ;; @@b35b 277
;* fill color is pen-A ;; @@b35b 277
; mode 0: fill region defined by color at x,y (default) new modes [910916] FAB ;; @@b35b 277
; mode 1: fill region using given color as boundary ;; @@b35b 277
; mode 2: fill connected region ;; @@b35b 277
;**************************************************************** ;; @@b35b 277
 ;; @@b35b 277
C65__paint                                                ; new [910228] FAB ;; @@b35b 278
                 jsr CheckGraphicMode                      ;; @@b35b 278
                 jsr sadwrd                               ; get x ;; @@b35e 278
                 sty GKI__parm1                            ;; @@b361 278
                 sta GKI__parm2                            ;; @@b364 278
 ;; @@b367 278
                 jsr comsad                               ; get y ;; @@b367 278
                 sty GKI__parm3                            ;; @@b36a 278
                 sta GKI__parm4                            ;; @@b36d 278
 ;; @@b370 278
                 ldx #0                                   ; [910916] ;; @@b370 278
                 jsr optbyt                               ; mode, default = 0 (fill region pointed to) ;; @@b372 278
                 cpx #3                                    ;; @@b375 278
                 +lbcs fcerr                              ; (range 0-2) ;; @@b377 278
                 stx GKI__parm5                            ;; @@b37a 278
                 ldx #0                                    ;; @@b37d 278
                 jsr optbyt                               ; boundary color, default = 0 ;; @@b37f 278
                 stx GKI__parm6                            ;; @@b382 278
 ;; @@b385 278
_local_1277_10   jsr garba2                               ; create space in var bank for paint stack [910716] ;; @@b385 278
                 lda strend                                ;; @@b388 278
                 sta GKI__parm7                           ; pass pointer to bottom of bank-1 free space ;; @@b38a 278
                 lda strend+1                             ; (top of stack) ;; @@b38d 278
                 sta GKI__parm8                            ;; @@b38f 278
                 sec                                       ;; @@b392 278
                 lda fretop                               ; pass pointer to top of free space ;; @@b393 278
                 sbc #3                                   ; (bottom of stack) ;; @@b395 278
                 sta GKI__parm9                            ;; @@b397 278
                 lda fretop+1                              ;; @@b39a 278
                 sbc #0                                    ;; @@b39c 278
                 sta GKI__parm10                           ;; @@b39e 278
 ;; @@b3a1 278
                 jsr ($802e)                              ; bra paint ;; @@b3a1 278
                 bcs _local_1277_20                       ; error- stack overflow or stop key ;; @@b3a4 278
                 rts                                       ;; @@b3a6 278
 ;; @@b3a7 278
_local_1277_20   cpx #errom                                ;; @@b3a7 278
                 +lbeq error                              ; stack overflow, say 'out of memory' ;; @@b3a9 278
                 +lbra break_exit                         ; user hit stop key ;; @@b3ac 278
 ;; @@b3af 278
; .page ;; @@b3af 278
; .subttl   LOAD/SAVE IFF ;; @@b3af 278
 ;; @@b3af 278
;***************************************************************** ;; @@b3af 278
;*   LOADIFF "filename" [,U#] [,D#] ;; @@b3af 278
;* ;; @@b3af 278
;* ???? requires SCREEN already opened   910402 FAB ;; @@b3af 278
;***************************************************************** ;; @@b3af 278
 ;; @@b3af 278
loadiff                                                    ;; @@b3af 279
                 jsr CheckGraphicMode                      ;; @@b3af 279
                 lda #$e6                                 ; parse:  filename [,U#] [,D#] ;; @@b3b2 279
                 jsr dosprs                               ; (like dopen:  0 0 0 *  * 0 0 1 ) ;; @@b3b4 279
                 jsr chk1                                 ; check parameters ;; @@b3b7 279
                 lda #0                                    ;; @@b3ba 279
                 sta dossa                                ; setup as dload would (0 = load channel) ;; @@b3bc 279
                 jsr find_la                              ; find an available la to use (cannot use reserved one) ;; @@b3bf 279
                 ldy #fopn                                 ;; @@b3c2 279
                 ldx #4                                    ;; @@b3c4 279
                 jsr open_file                            ; open the file ;; @@b3c6 279
                 bcs _local_1278_10                       ; exit if error ;; @@b3c9 279
 ;; @@b3cb 279
                 ldx dosla                                 ;; @@b3cb 279
; stx GKI__parm1 ;; @@b3ce 279
                 jsr _chkin                               ; get input channel ;; @@b3ce 279
_local_1278_10   +lbcs list_err                           ; exit if error ;; @@b3d1 279
 ;; @@b3d4 279
                 jsr ($802a)                              ; Load it ;; @@b3d4 279
 ;; @@b3d7 279
exit_GKI_disk_op                                           ;; @@b3d7 280
                 php                                      ; preserve completion status ;; @@b3d7 280
                 pha                                       ;; @@b3d8 280
                 jsr _clrch                                ;; @@b3d9 280
                 lda dosla                                 ;; @@b3dc 280
                 jsr close_out                            ; close channel ;; @@b3df 280
 ;; @@b3e2 280
                 jsr is_stop_key_down                     ; weed out BREAK error ;; @@b3e2 280
                 plx                                       ;; @@b3e5 280
                 plp                                       ;; @@b3e6 280
                 +lbcs error                              ; must be I/O or file data error ;; @@b3e7 280
                 rts                                      ; load was successful ;; @@b3ea 280
 ;; @@b3eb 280
; .page ;; @@b3eb 280
;***************************************************************** ;; @@b3eb 280
;* ;; @@b3eb 280
;*   SAVEIFF "[@]filename" [,U#] [,D#]      [910930] FAB ;; @@b3eb 280
;* ;; @@b3eb 280
;***************************************************************** ;; @@b3eb 280
 ;; @@b3eb 280
saveiff                                                    ;; @@b3eb 280
                 jsr CheckGraphicMode                      ;; @@b3eb 280
                 lda #$66                                 ; set error flags ;; @@b3ee 280
                 jsr dosprs                               ; parse the line ;; @@b3f0 280
                 jsr chk2                                 ; check required parameters ;; @@b3f3 280
                 lda #1                                    ;; @@b3f6 280
                 sta dossa                                ; setup as dsave would (1 = save channel) ;; @@b3f8 280
                 jsr find_la                              ; find an available la to use (cannot use reserved one) ;; @@b3fb 280
                 ldy #fopn                                 ;; @@b3fe 280
                 ldx #4                                    ;; @@b400 280
                 jsr open_file                            ; open the file ;; @@b402 280
                 bcs _local_1279_10                       ; exit if error ;; @@b405 280
 ;; @@b407 280
                 ldx dosla                                 ;; @@b407 280
; stx GKI__parm1 ;; @@b40a 280
                 jsr _chkout                              ; get output channel ;; @@b40a 280
_local_1279_10   +lbcs list_err                           ; exit if error ;; @@b40d 280
 ;; @@b410 280
                 jsr ($803a)                              ; Save it ;; @@b410 280
                 bra exit_GKI_disk_op                      ;; @@b413 280
 ;; @@b415 280
; php   ;preserve completion status ;; @@b415 280
; pha ;; @@b415 280
; jsr _clrch ;; @@b415 280
; lda dosla ;; @@b415 280
; jsr close_out  ;close channel ;; @@b415 280
; ;; @@b415 280
; jsr is_stop_key_down ; weed out BREAK error ;; @@b415 280
; plx ;; @@b415 280
; plp ;; @@b415 280
; bcs error  ; must be I/O or file data error ;; @@b415 280
; rts   ; load was successful ;; @@b415 280
 ;; @@b415 280
;.end ;; @@b415 280
; .page ;; @@b415 280
; .subttl   VIEWPORT Commands ;; @@b415 280
 ;; @@b415 280
;***************************************************************** ;; @@b415 280
;*   VIEWPORT <CLR | DEF>  x, y, viewport_width, viewport_height ;; @@b415 280
;* ;; @@b415 280
;* assumes SCREEN already opened   910626 FAB ;; @@b415 280
;***************************************************************** ;; @@b415 280
 ;; @@b415 280
C65__Viewport                                              ;; @@b415 281
                 pha                                      ; save secondary command ;; @@b415 281
                 jsr chrget                               ; advance past it ;; @@b416 281
                 jsr CheckGraphicMode                     ; make sure a screen is open ;; @@b419 281
 ;; @@b41c 281
                 jsr sadwrd                               ; get x0 ;; @@b41c 281
                 sty GKI__parm1                            ;; @@b41f 281
                 sta GKI__parm2                            ;; @@b422 281
 ;; @@b425 281
                 jsr comsad                               ; get y0 ;; @@b425 281
                 sty GKI__parm3                            ;; @@b428 281
                 sta GKI__parm4                            ;; @@b42b 281
 ;; @@b42e 281
                 jsr comsad                               ; get width (delta-x) ;; @@b42e 281
                 sty GKI__parm5                            ;; @@b431 281
                 sta GKI__parm6                            ;; @@b434 281
 ;; @@b437 281
                 jsr comsad                               ; get height (delta-y) ;; @@b437 281
                 sty GKI__parm7                            ;; @@b43a 281
                 sta GKI__parm8                            ;; @@b43d 281
 ;; @@b440 281
                 pla                                      ; dispatch per secondary token... ;; @@b440 281
                 cmp #clr_token                            ;; @@b441 281
                 beq _local_1280_10                        ;; @@b443 281
                 cmp #def_token                            ;; @@b445 281
                 +lbne snerr                              ; error ;; @@b447 281
 ;; @@b44a 281
                 jmp ($8030)                              ; define viewport & return ;; @@b44a 281
 ;; @@b44d 281
_local_1280_10   jmp ($8022)                              ; clear viewport (???? make this a box command) ;; @@b44d 281
 ;; @@b450 281
; .page ;; @@b450 281
C65__copy                                                  ;; @@b450 282
C65__cut                                                   ;; @@b450 282
C65__paste                                                 ;; @@b450 282
                 jmp bad_command                           ;; @@b450 282
 ;; @@b453 282
; .page ;; @@b453 282
; .subttl  GENLOCK ;; @@b453 282
 ;; @@b453 282
;***************************************************************** ;; @@b453 282
;* GENLOCK  set/reset genlock mode & color registers ;; @@b453 282
;* ;; @@b453 282
;*  Syntax: GENLOCK <ON[,color#[,...]] | OFF[,color#,R,G,B]> ;; @@b453 282
;***************************************************************** ;; @@b453 282
 ;; @@b453 282
genlock          sta GKI__parm1                           ; save token as flag for set palette   [910107] ;; @@b453 282
                 cmp #on_token                             ;; @@b456 282
                 beq _local_1281_20                        ;; @@b458 282
                 jsr chkesc                                ;; @@b45a 282
                 cmp #off_token                            ;; @@b45d 282
                 +lbne snerr                               ;; @@b45f 282
;TURN GENLOCK OFF ;; @@b462 282
                 lda vic+49                               ; any interlaced bitplanes on? ;; @@b462 282
                 and #%00011001                            ;; @@b465 282
                 cmp #%00011001                            ;; @@b467 282
                 beq _local_1281_10                       ; yes, leave interlace mode on ;; @@b469 282
 ;; @@b46b 282
                 lda #%00000001                            ;; @@b46b 282
                 trb vic+49                               ; no, turn interlace off ;; @@b46d 282
_local_1281_10   lda #%00000010                            ;; @@b470 282
                 trb vic+48                               ; reset external sync mode ;; @@b472 282
; beq _local_1281_12   ;       [910114] ;; @@b475 282
; lda vic+63  ;       [910111] ;; @@b475 282
; inc a   ;  adjust vert. position (chip bug ????) ;; @@b475 282
; inc a   ;  (to be handled by a custom C65 genlock board) ;; @@b475 282
; inc a ;; @@b475 282
; sta vic+63 ;; @@b475 282
 ;; @@b475 282
_local_1281_12   jsr chrget                               ; eat token ;; @@b475 282
                 jsr optbyt                               ; get (optional) color reg# in .X ;; @@b478 282
                 stx GKI__parm2                           ; save it ;; @@b47b 282
                 +lbcs set_palette                        ; if present, go do it & exit ;; @@b47e 282
_local_1281_15   rts                                      ; if not present (eol), exit ;; @@b481 282
 ;; @@b482 282
 ;; @@b482 282
_local_1281_20   lda #%00000001                           ; TURN GENLOCK ON ;; @@b482 282
                 tsb vic+49                               ; set interlace mode ;; @@b484 282
                 asl                                       ;; @@b487 282
                 tsb vic+48                               ; set external sync mode ;; @@b488 282
; bne _local_1281_22   ;       [910114] ;; @@b48b 282
; lda vic+63  ;       [910111] ;; @@b48b 282
; dec a   ;  adjust vert. position (chip bug ????) ;; @@b48b 282
; dec a   ;  (to be handled by a custom C65 genlock board) ;; @@b48b 282
; dec a ;; @@b48b 282
; sta vic+63 ;; @@b48b 282
 ;; @@b48b 282
_local_1281_22   jsr chrget                               ; eat token ;; @@b48b 282
_local_1281_25   jsr optbyt                               ; get (optional) color reg# in .X ;; @@b48e 282
                 bcc _local_1281_15                       ; if not present (eol), exit ;; @@b491 282
                 lda #%00010000                           ; if present, set FGBG bit in red palette ;; @@b493 282
                 sta _red,x                                ;; @@b495 282
                 bra _local_1281_25                       ; loop ;; @@b498 282
 ;; @@b49a 282
; .page ;; @@b49a 282
; .subttl  COLOR Control ;; @@b49a 282
 ;; @@b49a 282
;***************************************************************** ;; @@b49a 282
;* COLOR       <ON | OFF> Enable|Disable SW & HW color ;; @@b49a 282
;* FOREGROUND  color# Set Foreground color (text) ;; @@b49a 282
;* HIGHLIGHT   color# Set Highlight color (text) ;; @@b49a 282
;* BACKGROUND  color# Set VIC Background color ;; @@b49a 282
;* BORDER      color# Set VIC Border color ;; @@b49a 282
;***************************************************************** ;; @@b49a 282
 ;; @@b49a 282
color            cmp #','                                 ; optional first arg ;; @@b49a 283
                 beq _local_1282_20                        ;; @@b49c 283
                 cmp #on_token                            ; SOFTWARE (Editor) color mode ;; @@b49e 283
                 beq _local_1282_10                        ;; @@b4a0 283
                 jsr chkesc                                ;; @@b4a2 283
                 cmp #off_token                            ;; @@b4a5 283
_local_1282_5    +lbne snerr                               ;; @@b4a7 283
 ;; @@b4aa 283
                 ldy #'['                                 ; OFF (color & attributes) ;; @@b4aa 283
                 !text $2c                                 ;; @@b4ac 283
_local_1282_10   ldy #']'                                 ; ON ;; @@b4ad 283
                 lda #esc                                  ;; @@b4af 283
                 jsr _bsout                               ; do it ;; @@b4b1 283
                 tya                                       ;; @@b4b4 283
                 jsr _bsout                                ;; @@b4b5 283
                 jsr chrget                               ; eat token ;; @@b4b8 283
                 beq _local_1282_40                       ; eol- exit ;; @@b4bb 283
 ;; @@b4bd 283
_local_1282_20   jsr chkcom                               ; else must be comma, eat & get next ;; @@b4bd 283
; jsr chrgot  ;      [910930] ;; @@b4c0 283
                 cmp #on_token                            ; HARDWARE (Vic) color mode ;; @@b4c0 283
                 beq _local_1282_30                        ;; @@b4c2 283
                 jsr chkesc                                ;; @@b4c4 283
                 cmp #off_token                            ;; @@b4c7 283
                 bne _local_1282_5                         ;; @@b4c9 283
 ;; @@b4cb 283
                 lda #%00000010                           ; OFF (monochrome) ;; @@b4cb 283
                 tsb vic+49                                ;; @@b4cd 283
                 bra _local_1282_35                        ;; @@b4d0 283
 ;; @@b4d2 283
_local_1282_30   lda #%00000010                           ; ON ;; @@b4d2 283
                 trb vic+49                                ;; @@b4d4 283
_local_1282_35   +lbra chrget                             ; exit after eating last token ;; @@b4d7 283
 ;; @@b4da 283
_local_1282_40   rts                                      ; exit after encountering eol ;; @@b4da 283
 ;; @@b4db 283
; .page ;; @@b4db 283
foreground                                                 ;; @@b4db 284
                 jsr getnyb                               ; Set text foreground color ;; @@b4db 284
                 stx _color                                ;; @@b4de 284
                 rts                                       ;; @@b4e0 284
 ;; @@b4e1 284
 ;; @@b4e1 284
 ;; @@b4e1 284
highlight                                                  ;; @@b4e1 284
                 +lbeq snerr                              ; missing args??     [911017] ;; @@b4e1 284
                 cmp #','                                  ;; @@b4e4 284
                 beq _local_1283_10                       ; options byte only ;; @@b4e6 284
 ;; @@b4e8 284
                 jsr getbyt                               ; Set text highlight color ;; @@b4e8 284
                 stx highlight_color                       ;; @@b4eb 284
 ;; @@b4ee 284
_local_1283_10   jsr optzer                               ; set options:     [911001] ;; @@b4ee 284
                 bcc _local_1283_20                       ; comma but no value not given?? ;; @@b4f1 284
                 txa                                       ;; @@b4f3 284
                 and #3                                   ; 0= error msgs only ;; @@b4f4 284
                 asl                                      ; 1= REMs ;; @@b4f6 284
                 asl                                      ; 2= tokens ;; @@b4f7 284
                 asl                                       ;; @@b4f8 284
                 sta helper                                ;; @@b4f9 284
_local_1283_20   rts                                       ;; @@b4fb 284
 ;; @@b4fc 284
 ;; @@b4fc 284
 ;; @@b4fc 284
background                                                 ;; @@b4fc 285
                 jsr getnyb                               ; Set Vic background color ;; @@b4fc 285
                 stx vic+33                                ;; @@b4ff 285
                 rts                                       ;; @@b502 285
 ;; @@b503 285
 ;; @@b503 285
 ;; @@b503 285
border                                                     ;; @@b503 285
                 jsr getnyb                               ; Set Vic border color ;; @@b503 285
                 stx vic+32                                ;; @@b506 285
                 rts                                       ;; @@b509 285
 ;; @@b50a 285
; .page ;; @@b50a 285
getcomnyb                                                  ;; @@b50a 285
                 jsr chkcom                               ; check for comma ;; @@b50a 285
getnyb                                                     ;; @@b50d 285
                 jsr getbyt                               ; Get a nybble, check range (0-15) ;; @@b50d 285
chknyb                                                     ;; @@b510 285
                 cpx #16                                   ;; @@b510 285
                 +lbcs fcerr                               ;; @@b512 285
                 rts                                       ;; @@b515 285
 ;; @@b516 285
 ;; @@b516 285
 ;; @@b516 285
chkesc                                                    ; Check for escape token, error if not, else get next token ;; @@b516 285
                 cmp #esc_command_token                    ;; @@b516 285
                 +lbne snerr                               ;; @@b518 285
                 jsr chrget                                ;; @@b51b 285
                 +lbeq snerr                              ; eos? report error if so ;; @@b51e 285
                 rts                                       ;; @@b521 285
 ;; @@b522 285
 ;; @@b522 285
 ;; @@b522 285
chkeos                                                    ; Check for next byte = end of statement, error if not ;; @@b522 285
                 jsr chrget                                ;; @@b522 285
                 +lbne snerr                              ; eos? report error if not ;; @@b525 285
                 rts                                       ;; @@b528 285
 ;; @@b529 285
 ;; @@b529 285
;.end ;; @@b529 285
; .page ;; @@b529 285
; .subttl SPRITE Commands and Functions ;; @@b529 285
 ;; @@b529 285
;************************************************************************************ ;; @@b529 285
; SPRITE CLR ;; @@b529 285
; SPRITE {LOAD|SAVE} "filename" [,Ddrive] [,Udevice] ;; @@b529 285
; SPRITE sprite [,enable [,color [,priority [,xexp [,yexp [,resolution] ]]]]] ;; @@b529 285
; ;; @@b529 285
; where: sprite  :== sprite number (1-8) ;; @@b529 285
;  enable  :== enable  (0=off, 1=on) ;; @@b529 285
;  color  :== color  (0-15) ;; @@b529 285
;  priority :== sprite/bgnd  (0=sprite, 1=bgnd) ;; @@b529 285
;  xexp  :== expand x direction (0=no, 1=yes) ;; @@b529 285
;  yexp  :== expand y direction (0=no, 1=yes) ;; @@b529 285
;  resolution :== resolution  (0=hires, 1=multicolor) ;; @@b529 285
;************************************************************************************ ;; @@b529 285
 ;; @@b529 285
sprite           cmp #clr_token                           ; SPRITE CLR: init environment   [910717] ;; @@b529 285
                 +lbeq Sprite_CLR                         ; yes ;; @@b52b 285
                 cmp #save_token                          ; SPRITE SAVE: save sprite data   [911001] ;; @@b52e 285
                 beq Sprite_Save                          ; yes ;; @@b530 285
                 cmp #load_token                          ; SPRITE LOAD: load sprite data   [911001] ;; @@b532 285
                 beq Sprite_Load                          ; yes ;; @@b534 285
 ;; @@b536 285
                 jsr get_sprite_number                    ; get sprite number in z_p_temp_1 ;; @@b536 285
                 jsr optbyt                               ; look for (optional) enable ;; @@b539 285
                 bcc _local_1284_10                       ; none here, don't change ;; @@b53c 285
                 ldy #21                                   ;; @@b53e 285
                 jsr sprbit                               ; set/clear sprite bit ;; @@b540 285
 ;; @@b543 285
_local_1284_10   jsr optbyt                               ; get (optional) color ;; @@b543 285
                 bcc _local_1284_20                       ; branch if no arg ;; @@b546 285
                 jsr chknyb                               ; [910109] ;; @@b548 285
                 txa                                       ;; @@b54b 285
                 ldx z_p_temp_1                           ; get back sprite number ;; @@b54c 285
; jsr put_io_in_map ;; @@b54e 285
                 sta vic+39,x                              ;; @@b54e 285
 ;; @@b551 285
_local_1284_20   jsr optbyt                               ; look for (optional) priority ;; @@b551 285
                 bcc _local_1284_30                        ;; @@b554 285
                 ldy #27                                   ;; @@b556 285
                 jsr sprbit                                ;; @@b558 285
 ;; @@b55b 285
_local_1284_30   jsr optbyt                               ; look for (optional) x expansion ;; @@b55b 285
                 bcc _local_1284_40                        ;; @@b55e 285
                 ldy #29                                   ;; @@b560 285
                 jsr sprbit                                ;; @@b562 285
 ;; @@b565 285
_local_1284_40   jsr optbyt                               ; look for (optional) y expansion ;; @@b565 285
                 bcc _local_1284_50                        ;; @@b568 285
                 ldy #23                                   ;; @@b56a 285
                 jsr sprbit                                ;; @@b56c 285
 ;; @@b56f 285
_local_1284_50   jsr optbyt                               ; look for (optional) resolution ;; @@b56f 285
                 bcc _local_1284_60                        ;; @@b572 285
                 ldy #28                                   ;; @@b574 285
                 jsr sprbit                                ;; @@b576 285
 ;; @@b579 285
_local_1284_60   rts                                       ;; @@b579 285
 ;; @@b57a 285
; .page ;; @@b57a 285
Sprite_Save                                               ; Just like Key_Save     [911001] ;; @@b57a 286
                 jsr GetSaveChannel                        ;; @@b57a 286
                 lda #highds                              ; set starting & ending addresses ;; @@b57d 286
                 ldy #>sprite_base                        ; start address & pointer to it ;; @@b57f 286
                 ldx #<sprite_base                         ;; @@b581 286
                 sty highds+1                              ;; @@b583 286
                 stx highds                                ;; @@b585 286
                 iny                                      ; end address = start address + 512 + 1 ;; @@b587 286
                 iny                                       ;; @@b588 286
                 inx                                       ;; @@b589 286
                 +lbra savenb                             ; [910925] ;; @@b58a 286
 ;; @@b58d 286
 ;; @@b58d 286
 ;; @@b58d 286
Sprite_Load                                                ;; @@b58d 286
                 jsr GetLoadChannel                       ; get a channel      [911001] ;; @@b58d 286
                 ldy #>sprite_base                         ;; @@b590 286
                 lda #<sprite_base                         ;; @@b592 286
                 jsr LoadBlock                            ; load first block ;; @@b594 286
                 inc highds+1                              ;; @@b597 286
                 jsr LoadBlockNext                        ; load second block ;; @@b599 286
                 +lbra list_err                           ; release channel, close file, return to main ;; @@b59c 286
 ;; @@b59f 286
; .page ;; @@b59f 286
;  Set or clear a bit in a VIC register ;; @@b59f 286
; ;; @@b59f 286
; .X = 1 to set, 0 to clear ;; @@b59f 286
; .Y = register in VIC to operate opon ;; @@b59f 286
 ;; @@b59f 286
sprbit           txa                                       ;; @@b59f 286
                 lsr                                      ; put lsb in .C (0 clear, 1 set sprite bit) ;; @@b5a0 286
                 +lbne fcerr                              ; only 0 or 1, please. ;; @@b5a1 286
; jsr put_io_in_map ;; @@b5a4 286
                 ldx z_p_temp_1                           ; get sprite number ;; @@b5a4 286
                 lda sbits,x                               ;; @@b5a6 286
                 ora vic,y                                 ;; @@b5a9 286
                 bcs _local_1285_10                        ;; @@b5ac 286
                 eor sbits,x                               ;; @@b5ae 286
_local_1285_10   sta vic,y                                 ;; @@b5b1 286
                 rts                                       ;; @@b5b4 286
 ;; @@b5b5 286
 ;; @@b5b5 286
get_sprite_number                                           ;; @@b5b5 287
                 jsr getbyt                                ;; @@b5b5 287
; dex        [910221] ;; @@b5b8 287
                 cpx #8                                    ;; @@b5b8 287
                 +lbcs fcerr                               ;; @@b5ba 287
                 stx z_p_temp_1                            ;; @@b5bd 287
                 rts                                       ;; @@b5bf 287
 ;; @@b5c0 287
;.end ;; @@b5c0 287
; .page ;; @@b5c0 287
; .subttl MOVSPR Command ;; @@b5c0 287
 ;; @@b5c0 287
;**************************************************************** ;; @@b5c0 287
; Move Sprite.  Position sprite and optionally animate it. ;; @@b5c0 287
; ;; @@b5c0 287
;   MOVSPR n, [ p | x#y ]   or   MOVSPR n, p1 TO p2, speed ;; @@b5c0 287
; ;; @@b5c0 287
;  n = Sprite number (0-7) ;; @@b5c0 287
; p = (x,y) coordinate. ;; @@b5c0 287
;  Relative and angular distances  are relative to ;; @@b5c0 287
;  current sprite position and scaled if scaling is on. ;; @@b5c0 287
; x#y = Constant movement at an angle-x with speed-y. ;; @@b5c0 287
;**************************************************************** ;; @@b5c0 287
 ;; @@b5c0 287
movspr           lda #0                                   ; flag 'movspr' initial coord   [910808] ;; @@b5c0 287
                 sta op                                   ; (0=movspr, $80=movspr_to, $7f=mouse) ;; @@b5c2 287
                 jsr get_sprite_number                    ; get sprite # ;; @@b5c4 287
                 jsr sprcor                               ; get first coordinate (y,a) ;; @@b5c7 287
movspr_1                                                  ; entry to eval destination coordinate  [910808] ;; @@b5ca 287
                 bit numcnt                               ; test coordinate type ;; @@b5ca 287
                 +lbvs snerr                              ; syntax error ;; @@b5cd 287
                 sty xdest                                ; save coordinate value ;; @@b5d0 287
                 sty xdest+2                               ;; @@b5d3 287
                 sta xdest+1                               ;; @@b5d6 287
                 sta xdest+3                               ;; @@b5d9 287
 ;; @@b5dc 287
                 jsr sprcor                               ; get second coordinate (y,a) ;; @@b5dc 287
                 bit numcnt                               ; test coordinate type & dispatch accordingly ;; @@b5df 287
                 bvc movspr_normal                        ; normal coordinates ;; @@b5e2 287
                 bmi movspr_angle                         ; angular coordinates ;; @@b5e4 287
 ;; @@b5e6 287
                 bit op                                   ; angle#speed, test if allowed ;; @@b5e6 287
                 +lbmi snerr                              ; ng- movspr_to call ;; @@b5e8 287
                 phy                                      ; ok- save speed value ;; @@b5eb 287
                 ldy #xdest-vwork                          ;; @@b5ec 287
                 jsr getang                               ; get angle of movement ;; @@b5ee 287
                 ldx z_p_temp_1                           ; get sprite number ;; @@b5f1 287
                 ldy sproff,x                             ; get offset to speed data ;; @@b5f3 287
                 lda #0                                    ;; @@b5f6 287
                 sta sprite_data,y                        ; turn off sprite speed ;; @@b5f8 287
                 iny                                       ;; @@b5fb 287
 ;; @@b5fc 287
                 ldx #3                                    ;; @@b5fc 287
_local_1286_20   lsr sinval,x                              ;; @@b5fe 287
                 dex                                       ;; @@b601 287
                 ror sinval,x                              ;; @@b602 287
                 dex                                       ;; @@b605 287
                 bpl _local_1286_20                        ;; @@b606 287
 ;; @@b608 287
_local_1286_30   sei                                       ;; @@b608 287
                 inx                                      ; x=0 ;; @@b609 287
                 lda angsgn,x                             ; move angle data to speed data ;; @@b60a 287
                 iny                                       ;; @@b60d 287
                 sta sprite_data,y                         ;; @@b60e 287
                 cpx #4                                    ;; @@b611 287
                 bne _local_1286_30                        ;; @@b613 287
 ;; @@b615 287
                 lda #0                                   ; clear speed angle counts ;; @@b615 287
_local_1286_40   iny                                       ;; @@b617 287
                 sta sprite_data,y                         ;; @@b618 287
                 dex                                       ;; @@b61b 287
                 bne _local_1286_40                        ;; @@b61c 287
 ;; @@b61e 287
                 pla                                      ; restore speed value ;; @@b61e 287
                 and #$3f                                 ; limit range (0-63) ????  [910806] ;; @@b61f 287
                 sta sprite_data-10,y                     ; start sprite movement ;; @@b621 287
                 cli                                       ;; @@b624 287
                 rts                                       ;; @@b625 287
 ;; @@b626 287
movspr_angle                                               ;; @@b626 288
; jsr swapxy  ;swap y and a (eventually) : y ==> x ;; @@b626 288
; tay   ;        a ==> y ;; @@b626 288
; txa   ;        x ==> a ;; @@b626 288
                 pha                                       ;; @@b626 288
                 tya                                       ;; @@b627 288
                 ply                                       ;; @@b628 288
 ;; @@b629 288
                 jsr gtang1                               ; get angle values ;; @@b629 288
; ldx #xdest-vwork ;; @@b62c 288
; jsr scalxy  ;scale lengths ;; @@b62c 288
                 ldx #xdest-vwork                          ;; @@b62c 288
                 clc                                       ;; @@b62e 288
 ;; @@b62f 288
_local_1287_60   jsr angmlt                               ; multiply lengths*angles for x and y ;; @@b62f 288
                 sta vwork,x                               ;; @@b632 288
                 tya                                       ;; @@b635 288
                 sta vwork+1,x                             ;; @@b636 288
                 inx                                       ;; @@b639 288
                 inx                                       ;; @@b63a 288
                 cpx #ydest-vwork                          ;; @@b63b 288
                 beq _local_1287_60                       ; loop to do y-position ;; @@b63d 288
 ;; @@b63f 288
                 ror numcnt                               ; shift in carry to set msb ;; @@b63f 288
                 bra movspr_position                      ; go place sprite ;; @@b642 288
 ;; @@b644 288
 ;; @@b644 288
movspr_normal                                             ; [910122] ;; @@b644 289
                 sty xdest+2                              ; save second coordinate (y,a) ;; @@b644 289
                 sta xdest+3                               ;; @@b647 289
; ldx #xdest-vwork ;; @@b64a 289
; jsr scalxy  ;scale the coordinates ;; @@b64a 289
 ;; @@b64a 289
 ;; @@b64a 289
movspr_position                                            ;; @@b64a 289
                 sei                                      ; [910123] ;; @@b64a 289
                 lda z_p_temp_1                           ; get sprite number ;; @@b64b 289
                 tax                                      ; use as an index ;; @@b64d 289
                 asl                                       ;; @@b64e 289
                 tay                                      ; get sprite-number * 2 as another index ;; @@b64f 289
 ;; @@b650 289
                 bbr7 op,_local_1288_10                    ;; @@b650 289
                 rts                                      ; >>>exit here if movspr_to call   [910808] ;; @@b653 289
 ;; @@b654 289
_local_1288_10   lda xdest+2                              ; get y-coordinate ;; @@b654 289
                 asl numcnt                               ; test if relative ;; @@b657 289
                 bcc _local_1288_80                       ; skip if absolute ;; @@b65a 289
                 clc                                       ;; @@b65c 289
                 bpl _local_1288_75                       ; skip if normal coordinates ;; @@b65d 289
                 eor #$ff                                  ;; @@b65f 289
                 sec                                      ; invert to subtract if angular ;; @@b661 289
_local_1288_75   adc vic+1,y                              ; add to current sprite y-value  ???vic_save ;; @@b662 289
 ;; @@b665 289
_local_1288_80   sta vic+1,y                              ; save new sprite y-position  ???vic_save ;; @@b665 289
                 lda xdest                                ; get low byte of x-coordinate ;; @@b668 289
                 asl numcnt                               ; test if relative ;; @@b66b 289
                 bpl _local_1288_95                       ; skip if absolute ;; @@b66e 289
                 clc                                       ;; @@b670 289
                 adc vic,y                                ; add current sprite x-position  ???vic_save ;; @@b671 289
                 sta vic,y                                ; save sprite x-position   ???vic_save ;; @@b674 289
                 bcs _local_1288_90                       ; skip if carry ;; @@b677 289
                 inc xdest+1                              ; invert lsb ;; @@b679 289
 ;; @@b67c 289
_local_1288_90   lda vic+16                               ; get x-position msb bits  ???vic_save ;; @@b67c 289
                 bra _local_1288_98                       ; test if need to invert msb bit ;; @@b67f 289
 ;; @@b681 289
_local_1288_95   sta vic,y                                ; save new sprite x-position  ???vic_save ;; @@b681 289
                 lda vic+16                               ; ???vic_save ;; @@b684 289
                 ora sbits,x                              ; set x-position msb bit ;; @@b687 289
 ;; @@b68a 289
_local_1288_98   lsr xdest+1                              ; match to lsb of x-coordinate high byte ;; @@b68a 289
                 bcs _local_1288_100                      ; skip if should be set ;; @@b68d 289
                 eor sbits,x                              ; reset bit ;; @@b68f 289
 ;; @@b692 289
_local_1288_100  sta vic+16                               ; save position msb bits   ???vic_save ;; @@b692 289
; cli ;; @@b695 289
;1_local_1288_10 rts   ; mouse or movspr_to ;; @@b695 289
 ;; @@b695 289
; .page ;; @@b695 289
movspr_to                                                 ; setup for moving sprite to a particular position ;; @@b695 290
;we have already positioned the sprite onscreen ;; @@b695 290
                 jsr chrgot                               ; reget terminating character ;; @@b695 290
                 cmp #to_token                             ;; @@b698 290
                 beq _local_1289_5                        ; not our call ;; @@b69a 290
                 cli                                       ;; @@b69c 290
                 rts                                       ;; @@b69d 290
 ;; @@b69e 290
_local_1289_5    smb7 op                                  ; it's for us- let everybody else know we're in charge ;; @@b69e 290
                 jsr chrget                               ; move to next non-space character ;; @@b6a0 290
                 clc                                       ;; @@b6a3 290
                 jsr sprcor_1                             ; go get & evaluate destination coordinate ;; @@b6a4 290
                 jsr movspr_1                             ; returns with sprite# in .x, VIC sprite index in .y, ;; @@b6a7 290
;P1 in VIC sprite regs, and P2 in x,ydest ;; @@b6aa 290
                 asl numcnt                               ; Y: handle specific coordinate types ;; @@b6aa 290
                 bcc _local_1289_20                       ; skip if absolute ;; @@b6ad 290
                 clc                                       ;; @@b6af 290
                 lda xdest+2                              ; get y-coordinate ;; @@b6b0 290
                 bpl _local_1289_10                       ; skip if normal coordinates ;; @@b6b3 290
                 eor #$ff                                  ;; @@b6b5 290
                 sec                                      ; invert to subtract if angular ;; @@b6b7 290
_local_1289_10   adc vic+1,y                              ; add to current sprite y-value ???vic_save ;; @@b6b8 290
                 sta xdest+2                              ; save sprite destination y-position ;; @@b6bb 290
 ;; @@b6be 290
_local_1289_20   asl numcnt                               ; X: handle specific coordinate types ;; @@b6be 290
                 bpl _local_1289_30                       ; skip if absolute ;; @@b6c1 290
                 clc                                       ;; @@b6c3 290
                 lda xdest                                ; get low byte of x-coordinate ;; @@b6c4 290
                 adc vic,y                                ; add current sprite x-position  ???vic_save ;; @@b6c7 290
                 sta xdest                                ; save sprite destination x-position ;; @@b6ca 290
                 bcc _local_1289_30                        ;; @@b6cd 290
                 inc xdest+1                               ;; @@b6cf 290
 ;; @@b6d2 290
_local_1289_30   phy                                       ;; @@b6d2 290
                 jsr combyt                               ; get speed parameter ;; @@b6d3 290
                 txa                                       ;; @@b6d6 290
                 and #$3f                                 ; limit range (0-63) ???? ;; @@b6d7 290
                 ora #$80                                  ;; @@b6d9 290
                 sta xcnt                                 ; save in temp. ;; @@b6db 290
                 ply                                       ;; @@b6de 290
 ;; @@b6df 290
                 lda vic,y                                ; copy current sprite pos'n to line vars ;; @@b6df 290
                 sta xpos                                 ; in preparation for line calculations ;; @@b6e2 290
                 lda vic+1,y                               ;; @@b6e5 290
                 sta ypos                                  ;; @@b6e8 290
                 lda #0                                    ;; @@b6eb 290
                 sta xpos+1                                ;; @@b6ed 290
                 sta ypos+1                                ;; @@b6f0 290
                 tya                                       ;; @@b6f3 290
                 lsr                                       ;; @@b6f4 290
                 tay                                       ;; @@b6f5 290
                 lda sbits,y                               ;; @@b6f6 290
                 and vic+16                                ;; @@b6f9 290
                 beq _local_1289_40                        ;; @@b6fc 290
                 inc xpos+1                                ;; @@b6fe 290
_local_1289_40                                             ;; @@b701 290
; .page ;; @@b701 290
;****************************************************************** ;; @@b701 290
;  MOVSPR n, p1 TO p2 - move a sprite along line from p1 to p2 ;; @@b701 290
; ;; @@b701 290
; The following is performed now: ;; @@b701 290
; ;; @@b701 290
;           absx    = abs(destx-posx) : absy = abs(desty-posy) ;; @@b701 290
;           sgnx    = sgn(destx-posx) : sgny = sgn(desty-posy) ;; @@b701 290
;                     ( sgn=(1,0,-1) if (+,0,-) ) ;; @@b701 290
;           greatr  = index to the greatr of absx,absy ;; @@b701 290
;           lesser  = index to the smaller of absx,absy ;; @@b701 290
; ;; @@b701 290
;           fct1    = 2*min(absx,absy) ;; @@b701 290
;           fct2    = fct1 - 2*max(absx,absy) ;; @@b701 290
;           error   = fct1 - max(absx,absy) ;; @@b701 290
; ;; @@b701 290
; The following is performed during IRQ: ;; @@b701 290
; ;; @@b701 290
;           for i:= 1 to max(absx,absy) do begin ;; @@b701 290
;                 movspr n, posx, posy ;; @@b701 290
;                 if error > 0 then begin ;; @@b701 290
;                      pos(lesser):= pos(lesser) + sgn(lesser) ;; @@b701 290
;                      error:= error + fct2 ;; @@b701 290
;                      end ;; @@b701 290
;                      else error:= error + fct1 ;; @@b701 290
;                 pos(greatr):= pos(greatr) + sgn(greatr) ;; @@b701 290
;           end; ;; @@b701 290
; ;; @@b701 290
; (modification of C128 Bresenham DrawLn algorithm 910808 F.Bowen) ;; @@b701 290
;****************************************************************** ;; @@b701 290
 ;; @@b701 290
movspr_line                                                ;; @@b701 291
                 ldx #ypos-vwork                           ;; @@b701 291
                 ldy #ydest-vwork                          ;; @@b703 291
_local_1290_10   lda #0                                    ;; @@b705 291
                 sta xsgn,x                               ; init direction pointers ;; @@b707 291
                 sta xsgn+1,x                              ;; @@b70a 291
                 jsr abstwo                               ; get absolute value of coordinate differences ;; @@b70d 291
                 bpl _local_1290_20                       ; and determine direction ;; @@b710 291
                 dec xsgn,x                               ; negative direction ;; @@b712 291
                 dec xsgn+1,x                              ;; @@b715 291
                 bra _local_1290_40                        ;; @@b718 291
 ;; @@b71a 291
_local_1290_20   cmp #0                                    ;; @@b71a 291
                 bne _local_1290_30                        ;; @@b71c 291
                 cpy #0                                    ;; @@b71e 291
                 beq _local_1290_40                       ; zero direction ;; @@b720 291
_local_1290_30   inc xsgn,x                               ; positive direction ;; @@b722 291
_local_1290_40   sta xabs,x                                ;; @@b725 291
                 asl                                       ;; @@b728 291
                 sta fct,x                                ; fct(x,y) = 2*abs(x,y) ;; @@b729 291
                 tya                                       ;; @@b72c 291
                 sta xabs+1,x                              ;; @@b72d 291
                 rol                                       ;; @@b730 291
                 sta fct+1,x                               ;; @@b731 291
                 dex                                       ;; @@b734 291
                 dex                                       ;; @@b735 291
                 ldy #xdest-vwork                         ; loop to do in x-direction ;; @@b736 291
                 cpx #xpos-vwork                           ;; @@b738 291
                 beq _local_1290_10                        ;; @@b73a 291
 ;; @@b73c 291
                 ldx #yabs-savram                         ; determine max(xabs,yabs) ;; @@b73c 291
                 ldy #xabs-savram                          ;; @@b73e 291
                 jsr subtwo_savram                         ;; @@b740 291
                 lda #0                                    ;; @@b743 291
                 rol                                       ;; @@b745 291
                 rol                                      ; a = c * 2 ;; @@b746 291
                 sta lesser                               ; index to smaller delta ;; @@b747 291
                 eor #2                                    ;; @@b74a 291
                 sta greatr                               ; index to greater delta ;; @@b74c 291
 ;; @@b74f 291
                 clc                                       ;; @@b74f 291
                 lda #fct-savram                           ;; @@b750 291
                 adc lesser                                ;; @@b752 291
                 pha                                       ;; @@b755 291
                 tay                                       ;; @@b756 291
                 eor #2                                    ;; @@b757 291
                 tax                                       ;; @@b759 291
                 jsr subtwo_savram                        ; fct(greatr) = fct(lesser)-fct(greatr) ;; @@b75a 291
                 sta savram,x                              ;; @@b75d 291
                 sty savram+1,x                            ;; @@b760 291
 ;; @@b763 291
                 ply                                      ; fct(lesser) ;; @@b763 291
                 clc                                       ;; @@b764 291
                 lda #xabs-savram                          ;; @@b765 291
                 adc greatr                                ;; @@b767 291
                 tax                                       ;; @@b76a 291
                 jsr subtwo_savram                        ; error = fct(lesser) - abs(greatr) ;; @@b76b 291
                 sta errval                                ;; @@b76e 291
                 sty errval+1                              ;; @@b771 291
 ;; @@b774 291
; At this point, we've positioned the sprite at the start position, and have ;; @@b774 291
; calculated everything we need to move it along a line towards the destination ;; @@b774 291
; position.  All that's left is to copy the working vars into the sprite_data ;; @@b774 291
; tables where the IRQ routine can find & diddle with our data. ;; @@b774 291
; ;; @@b774 291
;    move ang/dist move line ;; @@b774 291
;  offset= 0 b7=0+speed b7=1+speed ;; @@b774 291
;   1 counter  counter lo ;; @@b774 291
;   2 angle sign         hi ;; @@b774 291
;   3,4 delta-X  dir+min/max ;; @@b774 291
;   5,6 delta-Y  fct1 ;; @@b774 291
;   7,8 total-X  fct2 ;; @@b774 291
;   9,10 total-Y  error ;; @@b774 291
 ;; @@b774 291
                 ldy z_p_temp_1                           ; sprite # ;; @@b774 291
                 ldx sproff,y                             ; sprite IRQ table offset ;; @@b776 291
 ;; @@b779 291
                 lda xcnt                                 ; set speed factor ;; @@b779 291
                 sta sprite_data,x                         ;; @@b77c 291
                 ldy greatr                                ;; @@b77f 291
                 lda xabs,y                               ; set counter = max(xyabs) ;; @@b782 291
                 sta sprite_data+1,x                       ;; @@b785 291
                 lda xabs+1,y                              ;; @@b788 291
                 sta sprite_data+2,x                       ;; @@b78b 291
                 lda xsgn,y                               ; set dir(max) and max ;; @@b78e 291
                 ora xsgn+1,y                              ;; @@b791 291
                 and #3                                    ;; @@b794 291
                 lsr                                       ;; @@b796 291
                 ror                                       ;; @@b797 291
                 ora greatr                                ;; @@b798 291
                 ror                                       ;; @@b79b 291
                 sta sprite_data+4,x                       ;; @@b79c 291
                 ldy lesser                                ;; @@b79f 291
                 lda xsgn,y                               ; set dir(min) and min ;; @@b7a2 291
                 ora xsgn+1,y                              ;; @@b7a5 291
                 and #3                                    ;; @@b7a8 291
                 lsr                                       ;; @@b7aa 291
                 ror                                       ;; @@b7ab 291
                 ora lesser                                ;; @@b7ac 291
                 ror                                       ;; @@b7af 291
                 sta sprite_data+3,x                       ;; @@b7b0 291
                 ldy #0                                   ; set f1, f2, and e ;; @@b7b3 291
_local_1290_50   lda fct,y                                 ;; @@b7b5 291
                 sta sprite_data+5,x                       ;; @@b7b8 291
                 inx                                       ;; @@b7bb 291
                 iny                                       ;; @@b7bc 291
                 cpy #6                                    ;; @@b7bd 291
                 bcc _local_1290_50                        ;; @@b7bf 291
 ;; @@b7c1 291
                 cli                                       ;; @@b7c1 291
                 rts                                      ; done! ;; @@b7c2 291
 ;; @@b7c3 291
; .page ;; @@b7c3 291
;  SPRCOR  -- Get sprite position coordinate ;; @@b7c3 291
; ;; @@b7c3 291
 ;; @@b7c3 291
sprcor           jsr chkcom_1                             ; check for a comma ;; @@b7c3 292
sprcor_1                                                   ;; @@b7c6 292
                 ror numcnt                               ; reset msb if comma else set msb ;; @@b7c6 292
                 bpl _local_1291_10                       ; skip if got a comma ;; @@b7c9 292
                 cmp #';'                                 ; test if angular data ;; @@b7cb 292
                 beq _local_1291_30                       ; skip if yes - 2 msb's = 1 1 ;; @@b7cd 292
                 cmp #'#'                                 ; test if speed type ;; @@b7cf 292
                 beq _local_1291_20                       ; skip if yes - 2 msb's = 0 1 ;; @@b7d1 292
                 +lbra snerr                              ; syntax error if none of above ;; @@b7d3 292
 ;; @@b7d6 292
_local_1291_10   jsr chrgot                               ; test for relative coordinate ;; @@b7d6 292
                 cmp #plus_token                          ; test if plus sign ;; @@b7d9 292
                 beq _local_1291_30                       ; skip if yes - show relative ;; @@b7db 292
                 cmp #minus_token                         ; test if minus sign ;; @@b7dd 292
                 beq _local_1291_30                       ; skip if yes - show relative ;; @@b7df 292
_local_1291_20   clc                                      ; reset to show absolute ;; @@b7e1 292
_local_1291_30   ror numcnt                               ; shift in second flag bit ;; @@b7e2 292
 ;; @@b7e5 292
sadwrd           jsr frmnum                               ; get number     label [910307] ;; @@b7e5 293
                 +lbra getsad                             ; get signed 2 byte coordinate,do rts ;; @@b7e8 293
 ;; @@b7eb 293
; .page ;; @@b7eb 293
;************************************************************* ;; @@b7eb 293
; CHKCOM_1  --  Check for a comma ;; @@b7eb 293
; ;; @@b7eb 293
;  carry set & eq = end of string ;; @@b7eb 293
;  carry set & neq = not a comma ;; @@b7eb 293
;  carry clear = a comma ;; @@b7eb 293
;************************************************************* ;; @@b7eb 293
 ;; @@b7eb 293
chkcom_1                                                   ;; @@b7eb 293
                 jsr chrgot                               ; get character in input stream ;; @@b7eb 293
                 beq _local_1292_20                       ; skip if end of string ;; @@b7ee 293
                 cmp #','                                 ; check if a comma ;; @@b7f0 293
                 clc                                       ;; @@b7f2 293
                 beq _local_1292_10                       ; skip if yes ;; @@b7f3 293
                 sec                                      ; set carry if not ;; @@b7f5 293
_local_1292_10   php                                       ;; @@b7f6 293
                 pha                                       ;; @@b7f7 293
                 jsr chrget                               ; move to next non-space character ;; @@b7f8 293
                 pla                                       ;; @@b7fb 293
                 plp                                       ;; @@b7fc 293
_local_1292_20   rts                                       ;; @@b7fd 293
 ;; @@b7fe 293
 ;; @@b7fe 293
sproff           !text 0,11,22,33,44,55,66,77             ; sprite offsets into speed table ;; @@b7fe 294
 ;; @@b806 294
;.end ;; @@b806 294
; .page ;; @@b806 294
; .subttl SPRCOLOR Command ;; @@b806 294
 ;; @@b806 294
;************************************************************** ;; @@b806 294
;* ;; @@b806 294
;*   SPRCOLOR - Set sprite multicolor registers ;; @@b806 294
;* ;; @@b806 294
;* syntax : SPRCOLOR [multicolor_1] [,multicolor_2] ;; @@b806 294
;* ;; @@b806 294
;************************************************************** ;; @@b806 294
 ;; @@b806 294
sprcolor                                                   ;; @@b806 294
                 cmp #','                                 ; is there a first arg? ;; @@b806 294
                 beq _local_1293_10                       ; nope, skip to second ;; @@b808 294
 ;; @@b80a 294
                 jsr getnyb                               ; get 1 byte arg in .X, range 0-15 ;; @@b80a 294
; jsr put_io_in_map ;; @@b80d 294
                 stx vic+37                                ;; @@b80d 294
 ;; @@b810 294
_local_1293_10   jsr optbyt                               ; get (optional) 1 byte arg in .X ;; @@b810 294
                 bcc _local_1293_20                        ;; @@b813 294
                 jsr chknyb                               ; range 0-15 ;; @@b815 294
; jsr put_io_in_map ;; @@b818 294
                 stx vic+38                                ;; @@b818 294
 ;; @@b81b 294
_local_1293_20   rts                                       ;; @@b81b 294
 ;; @@b81c 294
;.end ;; @@b81c 294
; .page ;; @@b81c 294
; .subttl SPRSAV Command ;; @@b81c 294
 ;; @@b81c 294
;*************************************************************** ;; @@b81c 294
;  SPRSAV ( n1 / s1$ ) , ( n2 / s2$ ) ;; @@b81c 294
;   - move string(s1) or sprite(n1) to string(s2) or sprite(n2) ;; @@b81c 294
;               n1 & n2 = a sprite number (1-8) ;; @@b81c 294
;                   s1$ = a string variable or expression ;; @@b81c 294
;                   s2$ = a string variable ;; @@b81c 294
;*************************************************************** ;; @@b81c 294
 ;; @@b81c 294
sprsav           jsr savinp                               ; evaluate 1st expression ;; @@b81c 295
                 bcs _local_1294_20                       ; skip if source is a string ;; @@b81f 295
                 sta forpnt                                ;; @@b821 295
                 sty forpnt+1                             ; save sprite address ;; @@b823 295
                 ldy #62                                   ;; @@b825 295
 ;; @@b827 295
_local_1294_10   lda (forpnt),y                           ; move sprite def to save area ;; @@b827 295
                 sta savram,y                              ;; @@b829 295
                 dey                                       ;; @@b82c 295
                 bpl _local_1294_10                        ;; @@b82d 295
 ;; @@b82f 295
                 iny                                      ; (0) ;; @@b82f 295
                 sty savram+64                            ; save sprite column length ;; @@b830 295
                 sty savram+66                            ; save sprite row length ;; @@b833 295
                 lda #23                                   ;; @@b836 295
                 sta savram+63                             ;; @@b838 295
                 lda #20                                   ;; @@b83b 295
                 sta savram+65                             ;; @@b83d 295
                 ldx #<savram                             ; set ptr to start of sprite def ;; @@b840 295
                 ldy #>savram                              ;; @@b842 295
                 stx strng1                               ; ** ;; @@b844 295
                 sty strng1+1                             ; ** ;; @@b846 295
 ;; @@b848 295
                 lda #67                                  ; set sprite length including lengths ;; @@b848 295
                 jsr strlit_1                             ; **get string space, copy savram to it ;; @@b84a 295
                 jsr desc_free                            ; **free up temp descriptor ;; @@b84d 295
 ;; @@b850 295
_local_1294_20   stx savsiz                               ; save source length ;; @@b850 295
                 sta savsiz+1                              ;; @@b853 295
                 sty savsiz+2                             ; save source start address ;; @@b856 295
 ;; @@b859 295
                 jsr chkcom                               ; check for a comma ;; @@b859 295
                 lda txtptr                               ; save basic text pointer ;; @@b85c 295
                 sta sprtmp_1                              ;; @@b85e 295
                 lda txtptr+1                              ;; @@b861 295
                 sta sprtmp_2                              ;; @@b863 295
                 jsr savinp                               ; get next destination parameter ;; @@b866 295
                 bcs savs50                               ; skip if string ;; @@b869 295
 ;; @@b86b 295
                 sta grapnt                                ;; @@b86b 295
                 sty grapnt+1                             ; save sprite address ;; @@b86d 295
                 lda savsiz+1                              ;; @@b86f 295
                 sta forpnt                               ; get source address ;; @@b872 295
                 lda savsiz+2                              ;; @@b874 295
                 sta forpnt+1                              ;; @@b877 295
                 ldy #0                                    ;; @@b879 295
_local_1294_40   cpy savsiz                               ; test index vs source length ;; @@b87b 295
                 beq _local_1294_45                       ; exit if source depleted ;; @@b87e 295
                 lda #forpnt                              ; move source byte to sprite ;; @@b880 295
                 jsr lda_far_ram1                         ; (from ram bank 1) ;; @@b882 295
; sta sw_rom_ram0 ;; @@b885 295
                 sta (grapnt),y                           ; (to sprite area in bank 0)???? ;; @@b885 295
                 iny                                       ;; @@b887 295
                 cpy #63                                   ;; @@b888 295
                 bne _local_1294_40                        ;; @@b88a 295
_local_1294_45   rts                                       ;; @@b88c 295
 ;; @@b88d 295
 ;; @@b88d 295
savs50           lda sprtmp_1                             ; restore basic text pointer ;; @@b88d 296
                 sta txtptr                                ;; @@b890 296
                 lda sprtmp_2                              ;; @@b892 296
                 sta txtptr+1                              ;; @@b895 296
                 jsr ptrget                               ; get symbol table descriptor for string dest. ;; @@b897 296
                 sta forpnt                                ;; @@b89a 296
                 sty forpnt+1                             ; save symbol table address ;; @@b89c 296
                 lda #<savsiz                              ;; @@b89e 296
                 sta facmo                                ; save descriptor address of source ;; @@b8a0 296
                 lda #>savsiz                              ;; @@b8a2 296
                 sta facmo+1                               ;; @@b8a4 296
                 +lbra inpcom                             ; move source to dest, do rts (snerr if not eol) ;; @@b8a6 296
 ;; @@b8a9 296
; .page ;; @@b8a9 296
savinp           jsr frmevl                               ; evaluate expression ;; @@b8a9 296
                 bbs7 valtyp,desc_free                    ; exit if a string ;; @@b8ac 296
                 jsr conint                               ; get one byte integer in .X ;; @@b8af 296
; dex    ;adjust sprite 1..8 to 0..7  [910220] ;; @@b8b2 296
                 cpx #8                                    ;; @@b8b2 296
                 +lbcs fcerr                              ; bad value ;; @@b8b4 296
                 txa                                      ; move sprite number to .A ;; @@b8b7 296
                 lsr                                       ;; @@b8b8 296
                 ror                                       ;; @@b8b9 296
                 ror                                      ; get sprite address ;; @@b8ba 296
                 ldy #>sprite_base                         ;; @@b8bb 296
                 bcc _local_1295_5                         ;; @@b8bd 296
                 iny                                       ;; @@b8bf 296
_local_1295_5    clc                                      ; flag 'sprite' (as opposed to 'string') ;; @@b8c0 296
                 rts                                       ;; @@b8c1 296
 ;; @@b8c2 296
 ;; @@b8c2 296
desc_free                                                 ; free temporary descriptor, set up pointers to string. ;; @@b8c2 297
                 lda facmo                                ; get address of temp descriptor ;; @@b8c2 297
                 ldy facmo+1                               ;; @@b8c4 297
                 jsr fretms                                ;; @@b8c6 297
                 ldy #0                                   ; get len, addr of string ;; @@b8c9 297
                 jsr indfmo                                ;; @@b8cb 297
                 tax                                       ;; @@b8ce 297
                 iny                                       ;; @@b8cf 297
                 jsr indfmo                                ;; @@b8d0 297
                 pha                                       ;; @@b8d3 297
                 iny                                       ;; @@b8d4 297
                 jsr indfmo                                ;; @@b8d5 297
                 tay                                       ;; @@b8d8 297
                 pla                                       ;; @@b8d9 297
                 sec                                      ; flag 'string found' ;; @@b8da 297
                 rts                                      ; return w/ x=len, (a,y)==> string ;; @@b8db 297
 ;; @@b8dc 297
;.end ;; @@b8dc 297
; .page ;; @@b8dc 297
; .subttl COLLISION Command ;; @@b8dc 297
 ;; @@b8dc 297
;***************************************************************** ;; @@b8dc 297
; COLLISION Command ;; @@b8dc 297
; ;; @@b8dc 297
; Syntax:  COLLISION n [,address] ;; @@b8dc 297
; ;; @@b8dc 297
; Where:   n= 1 ==> sprite / sprite ;; @@b8dc 297
;   2 ==> sprite / background ;; @@b8dc 297
;   3 ==> light pen ;; @@b8dc 297
; ;; @@b8dc 297
; Address ==> BASIC line number to trap to on interrupt ;; @@b8dc 297
;      (no address ==> disable trapping) ;; @@b8dc 297
;***************************************************************** ;; @@b8dc 297
 ;; @@b8dc 297
collision                                                  ;; @@b8dc 297
                 jsr getbyt                               ; get type in .X ;; @@b8dc 297
                 dex                                      ; adjust 1..3 to 0..2 ;; @@b8df 297
                 cpx #3                                    ;; @@b8e0 297
                 +lbcs fcerr                              ; value error ;; @@b8e2 297
 ;; @@b8e5 297
                 phx                                      ; save collision type ;; @@b8e5 297
                 jsr optwrd                               ; get address (line number) in .Y,.A (optional) ;; @@b8e6 297
                 plx                                       ;; @@b8e9 297
; php   ;save .C (.C == 1 ==> real value) ;; @@b8ea 297
                 sta int_adr_hi,x                         ; save address given ;; @@b8ea 297
                 sty int_adr_lo,x                          ;; @@b8ed 297
 ;; @@b8f0 297
                 lda intval                               ; this records valid interrupts ;; @@b8f0 297
                 ora sbits,x                              ; set correct bit ;; @@b8f3 297
; plp ;; @@b8f6 297
                 bcs _local_1296_10                       ; ..unless this is a 'clear', ;; @@b8f6 297
                 eor sbits,x                              ; ..in which case we'll reset bit ;; @@b8f8 297
_local_1296_10   sta intval                                ;; @@b8fb 297
                 rts                                       ;; @@b8fe 297
 ;; @@b8ff 297
;.end ;; @@b8ff 297
; .page ;; @@b8ff 297
; .subttl  RCOLOR Function ;; @@b8ff 297
 ;; @@b8ff 297
;************************************************************************ ;; @@b8ff 297
;  RCOLOR (source)  --  return current color assigned to source ;; @@b8ff 297
;   0  :  Background color ;; @@b8ff 297
;   1  :  Foreground color ;; @@b8ff 297
;   2  :  Highlight color ;; @@b8ff 297
;   3  :  Border color ;; @@b8ff 297
;************************************************************************ ;; @@b8ff 297
 ;; @@b8ff 297
rcolor           jsr conint                               ; evaluate integer argument, put in .X ;; @@b8ff 298
; jsr put_io_in_map ;; @@b902 298
 ;; @@b902 298
                 cpx #4                                    ;; @@b902 298
                 +lbcs fcerr                              ; illegal qty ;; @@b904 298
                 txa                                       ;; @@b907 298
                 asl                                      ; make into word pointer ;; @@b908 298
                 tax                                       ;; @@b909 298
                 lda color_source,x                       ; get address of source ;; @@b90a 298
                 sta grapnt                                ;; @@b90d 298
                 lda color_source+1,x                      ;; @@b90f 298
                 sta grapnt+1                              ;; @@b912 298
                 ldy #0                                    ;; @@b914 298
                 lda (grapnt),y                           ; read source (aways system space or I/O????) ;; @@b916 298
                 and #$0f                                 ; mask unused bits ;; @@b918 298
                 tay                                       ;; @@b91a 298
; iny   ; make color match keytops ;; @@b91b 298
                 +lbra sngflt                             ; float 1 byte in .Y ;; @@b91b 298
 ;; @@b91e 298
color_source                                               ;; @@b91e 298
                 !word vic+33,_color,highlight_color,vic+32  ;; @@b91e 298
 ;; @@b926 298
; .page ;; @@b926 298
; .subttl Graphic Functions ;; @@b926 298
 ;; @@b926 298
; Return graphic screen status & parameters      [910826] ;; @@b926 298
; RGRAPHIC (screen, param) where param = 0 open (1), closed (0), or invalid (>1) ;; @@b926 298
;            1 width  (0=320, 1=640, 2=1280) ;; @@b926 298
;            2 height (0=200, 1=400) ;; @@b926 298
;            3 depth (1-8 bitplanes) ;; @@b926 298
;            4 bitplanes used  (bitmask) ;; @@b926 298
;            5 bank A blocks used (bitmask) ;; @@b926 298
;            6 bank B blocks used (bitmask) ;; @@b926 298
;            7 drawscreen # (0-3) ;; @@b926 298
;            8 viewscreen # (0-3) ;; @@b926 298
;            9 drawmodes  (bitmask) ;; @@b926 298
;           10 pattern type  (bitmask) ;; @@b926 298
; ;; @@b926 298
; Requires a kludge, because RGR used to be a normal 1-arg function in the C128 ;; @@b926 298
; but now it takes two args. ;; @@b926 298
 ;; @@b926 298
rgraphic                                                   ;; @@b926 298
; jsr CheckGraphicMode ;verify screen open ;; @@b926 298
                 pla                                      ; remove token from stack ;; @@b926 298
                 jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820] ;; @@b927 298
 ;; @@b92a 298
                 jsr chkopn                               ; check for open paren ;; @@b92a 298
                 jsr getbyt                               ; get screen # in .X ;; @@b92d 298
                 stx GKI__parm1                            ;; @@b930 298
                 jsr combyt                               ; get param # in .X ;; @@b933 298
                 cpx #10+1                                ; [911028] ;; @@b936 298
                 bcs _local_1297_1                        ; illegal param # ;; @@b938 298
                 phx                                       ;; @@b93a 298
                 jsr chkcls                               ; check for closing parens ;; @@b93b 298
 ;; @@b93e 298
                 jsr ($8038)                              ; read screen params ;; @@b93e 298
_local_1297_1    +lbcs fcerr                              ; bad input???? ;; @@b941 298
 ;; @@b944 298
                 lda GKI__parm2                            ;; @@b944 298
                 plx                                      ; get back desired param # ;; @@b947 298
                 dex                                       ;; @@b948 298
                 bpl _local_1297_10                        ;; @@b949 298
                 eor #$80                                 ; make 0=closed, 1=open, >1=invalid ;; @@b94b 298
                 lsr                                       ;; @@b94d 298
                 lsr                                       ;; @@b94e 298
                 bra _local_1297_12                       ; return screen open status ;; @@b94f 298
 ;; @@b951 298
_local_1297_10   dex                                       ;; @@b951 298
                 bpl _local_1297_20                        ;; @@b952 298
_local_1297_12   lsr                                       ;; @@b954 298
_local_1297_15   lsr                                       ;; @@b955 298
                 lsr                                       ;; @@b956 298
                 lsr                                       ;; @@b957 298
                 and #3                                    ;; @@b958 298
                 bra _local_1297_40                       ; return width, height ;; @@b95a 298
 ;; @@b95c 298
_local_1297_20   dex                                       ;; @@b95c 298
                 bpl _local_1297_25                        ;; @@b95d 298
                 and #8                                    ;; @@b95f 298
                 bra _local_1297_15                        ;; @@b961 298
_local_1297_25   dex                                       ;; @@b963 298
                 bpl _local_1297_30                        ;; @@b964 298
                 and #7                                   ; return depth ;; @@b966 298
                 inc                                      ; make depth 1-8 ;; @@b968 298
                 bra _local_1297_40                        ;; @@b969 298
 ;; @@b96b 298
_local_1297_30   lda GKI__parm3,x                         ; return bp bask, banks, etc. ;; @@b96b 298
_local_1297_40   tay                                       ;; @@b96e 298
                 jsr sngflt                               ; float 1 byte arg in .y ;; @@b96f 298
 ;; @@b972 298
                 jsr PopParms                             ; restore Graphics parameters & LINNUM ;; @@b972 298
                 rts                                       ;; @@b975 298
 ;; @@b976 298
; .page ;; @@b976 298
; Return the color of a given X,Y pixel location on the drawscreen  [910801] ;; @@b976 298
;  PIXEL (x,y) ;; @@b976 298
 ;; @@b976 298
pixel            jsr CheckGraphicMode                     ; verify screen open ;; @@b976 299
                 jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820] ;; @@b979 299
 ;; @@b97c 299
                 jsr getsad                               ; get x ;; @@b97c 299
                 sty GKI__parm1                            ;; @@b97f 299
                 sta GKI__parm2                            ;; @@b982 299
                 jsr comsad                               ; get y ;; @@b985 299
                 sty GKI__parm3                            ;; @@b988 299
                 sta GKI__parm4                            ;; @@b98b 299
                 jsr chkcls                               ; check for closing parens ;; @@b98e 299
 ;; @@b991 299
                 jsr ($8032)                              ; get Bitplane data at pixel (x,y), returned in .y ;; @@b991 299
                 jsr sngflt                               ; go float 1 byte arg in .Y ;; @@b994 299
 ;; @@b997 299
                 jsr PopParms                             ; restore graphics parameters ;; @@b997 299
                 rts                                       ;; @@b99a 299
 ;; @@b99b 299
; .page ;; @@b99b 299
; Return the color of a drawscreen's PEN      [910820] ;; @@b99b 299
;  RPEN (pen#) where pen# = 0,1,2 ;; @@b99b 299
 ;; @@b99b 299
rpen             jsr CheckGraphicMode                     ; verify screen open ;; @@b99b 299
                 jsr PushParms                            ; preserve Graphics parameters & LINNUM  [910820] ;; @@b99e 299
 ;; @@b9a1 299
                 jsr conint                               ; get 1 byte arg in .x (old style single arg function) ;; @@b9a1 299
                 cpx #3                                    ;; @@b9a4 299
                 bcs _local_1298_10                       ; illegal pen #? ;; @@b9a6 299
                 stx GKI__parm1                            ;; @@b9a8 299
 ;; @@b9ab 299
                 jsr ($8036)                              ; convert to logical color# (palette index#) ;; @@b9ab 299
_local_1298_10   +lbcs fcerr                              ; drawscreen not set or illegal quantity somewhere ;; @@b9ae 299
 ;; @@b9b1 299
                 jsr sngflt                               ; go float 1 byte arg in .Y ;; @@b9b1 299
 ;; @@b9b4 299
                 jsr PopParms                             ; restore graphics parameters ;; @@b9b4 299
                 rts                                       ;; @@b9b7 299
 ;; @@b9b8 299
; .page ;; @@b9b8 299
; Return the R,G, or B component of a color     [910820] ;; @@b9b8 299
; RPALETTE (screen#, color#, rgb) ;; @@b9b8 299
 ;; @@b9b8 299
rpalette                                                   ;; @@b9b8 300
                 jsr CheckGraphicMode                     ; verify screen open ;; @@b9b8 300
                 jsr PushParms                            ; Save graphics parameters ;; @@b9bb 300
 ;; @@b9be 300
                 jsr conint                               ; get screen# in .x ;; @@b9be 300
                 cpx #4                                    ;; @@b9c1 300
                 bcs _local_1299_10                       ; illegal screen# ;; @@b9c3 300
                 stx GKI__parm1                            ;; @@b9c5 300
 ;; @@b9c8 300
                 jsr combyt                               ; get color# in .x ????check for legal color# ;; @@b9c8 300
                 stx GKI__parm2                            ;; @@b9cb 300
 ;; @@b9ce 300
                 jsr ($8034)                              ; get RGB components of color# in PARM3,4,5 ;; @@b9ce 300
                 bcs _local_1299_10                       ; something is wrong???? ;; @@b9d1 300
 ;; @@b9d3 300
                 jsr combyt                               ; get r,g,b component# ;; @@b9d3 300
                 cpx #3                                    ;; @@b9d6 300
_local_1299_10   +lbcs fcerr                              ; illegal value ;; @@b9d8 300
 ;; @@b9db 300
                 ldy GKI__parm3,x                         ; get r,g,b value ;; @@b9db 300
                 jsr sngflt                               ; float 1 byte arg in .y ;; @@b9de 300
 ;; @@b9e1 300
                 jsr chkcls                               ; check for closing paren ;; @@b9e1 300
                 jsr PopParms                             ; restore graphics parameters ;; @@b9e4 300
                 rts                                       ;; @@b9e7 300
 ;; @@b9e8 300
; .page ;; @@b9e8 300
PushParms                                                 ; [910820] ;; @@b9e8 301
                 ply                                      ; Grab return address ;; @@b9e8 301
                 plz                                       ;; @@b9e9 301
 ;; @@b9ea 301
                 phw linnum                               ; Save 'poker' value ;; @@b9ea 301
 ;; @@b9ed 301
                 ldx #17-1                                 ;; @@b9ed 301
_local_1300_10   lda GKI__parm1,x                         ; Save Graphics parameters ;; @@b9ef 301
                 pha                                      ; [eg: CHAR x,y,1,1,2,str$(PIXEL(x,y))] ;; @@b9f2 301
                 dex                                       ;; @@b9f3 301
                 bpl _local_1300_10                        ;; @@b9f4 301
 ;; @@b9f6 301
                 phz                                      ; Restore return address ;; @@b9f6 301
                 phy                                       ;; @@b9f7 301
                 rts                                       ;; @@b9f8 301
 ;; @@b9f9 301
 ;; @@b9f9 301
PopParms                                                  ; [910820] ;; @@b9f9 302
                 ply                                      ; Grab return address ;; @@b9f9 302
                 plz                                       ;; @@b9fa 302
 ;; @@b9fb 302
                 ldx #0                                    ;; @@b9fb 302
_local_1301_10   pla                                      ; Restore Graphics parameters ;; @@b9fd 302
                 sta GKI__parm1,x                          ;; @@b9fe 302
                 inx                                       ;; @@ba01 302
                 cpx #17                                   ;; @@ba02 302
                 bcc _local_1301_10                        ;; @@ba04 302
 ;; @@ba06 302
                 pla                                      ; Restore 'poker' value ;; @@ba06 302
                 sta linnum+1                              ;; @@ba07 302
                 pla                                       ;; @@ba09 302
                 sta linnum                                ;; @@ba0a 302
 ;; @@ba0c 302
                 phz                                      ; Restore return address ;; @@ba0c 302
                 phy                                       ;; @@ba0d 302
                 rts                                       ;; @@ba0e 302
 ;; @@ba0f 302
;.end ;; @@ba0f 302
; .page ;; @@ba0f 302
; .subttl RSPRITE Function ;; @@ba0f 302
 ;; @@ba0f 302
;****************************************************************** ;; @@ba0f 302
;* RSPRITE - Return sprite information ;; @@ba0f 302
;* ;; @@ba0f 302
;* Syntax : RSPRITE (sprite_number, argument) ;; @@ba0f 302
;* ;; @@ba0f 302
;* Where  : sprite_number = [0..7] ;; @@ba0f 302
;*   argument = [0..5] ;; @@ba0f 302
;*   0 : enabled?   (y(1)/n(0)) ;; @@ba0f 302
;*   1 : color?     (0-15) ;; @@ba0f 302
;*   2 : priority over background? (y(1)/n(0)) ;; @@ba0f 302
;*   3 : expand in x direction? (y(1)/n(0)) ;; @@ba0f 302
;*   4 : expand in Y direction? (y(1)/n(0)) ;; @@ba0f 302
;*   5 : multicolor sprite?  (y(1)/n(0)) ;; @@ba0f 302
;****************************************************************** ;; @@ba0f 302
 ;; @@ba0f 302
rsprite          jsr conint                               ; get first arg, sprite #, in .X ;; @@ba0f 303
; dex  ;adjust [1..8] to [0..7]   [910220] ;; @@ba12 303
                 cpx #8  ; (318018-03 mod                 ; fab) ;; @@ba12 303
                 bcs _local_1302_1                        ; value error ;; @@ba14 303
                 txa                                       ;; @@ba16 303
                 pha                                      ; save sprite number ;; @@ba17 303
 ;; @@ba18 303
; jsr chkcom ;check for proper delimiter ;; @@ba18 303
; jsr getbyt ;do frmevl, get 1 byte arg (arg) in .X ;; @@ba18 303
                 jsr combyt                               ; [910820] ;; @@ba18 303
                 jsr chkcls                               ; look for closing paren ;; @@ba1b 303
                 cpx #6                                    ;; @@ba1e 303
_local_1302_1    +lbcs fcerr                              ; value error ;; @@ba20 303
 ;; @@ba23 303
                 ply                                      ; sprite number ;; @@ba23 303
; jsr put_io_in_map ;; @@ba24 303
                 lda vic+39,y                             ; assume 'color' ;; @@ba24 303
                 and #$0f                                 ; range 0-15 ;; @@ba27 303
; inc a  ;adjust to 'keyboard' colors   [910724] ;; @@ba29 303
                 cpx #1                                    ;; @@ba29 303
                 beq _local_1302_10                       ; it was color. set up for float ;; @@ba2b 303
 ;; @@ba2d 303
                 lda rspmod,x                             ; get index for this function ;; @@ba2d 303
                 tax                                       ;; @@ba30 303
                 lda sbits,y                              ; get mask for this sprite number ;; @@ba31 303
                 and vic,x                                 ;; @@ba34 303
                 beq _local_1302_10                        ;; @@ba37 303
                 lda #1                                   ; return all non-zeros as '1' ;; @@ba39 303
 ;; @@ba3b 303
_local_1302_10   tay                                       ;; @@ba3b 303
                 +lbra sngflt                             ; go float 1 byte arg in .Y ;; @@ba3c 303
 ;; @@ba3f 303
 ;; @@ba3f 303
rspmod           !text 21,39,27,29,23,28                  ; VIC registers associated with arg# ;; @@ba3f 304
 ;; @@ba45 304
;.end ;; @@ba45 304
; .page ;; @@ba45 304
; .subttl RSPCOLOR Function ;; @@ba45 304
 ;; @@ba45 304
;****************************************************************** ;; @@ba45 304
;* RSPCOLOR - return sprite multicolor reg's ;; @@ba45 304
;* ;; @@ba45 304
;* Syntax : RSPCOLOR (argument) ;; @@ba45 304
;* ;; @@ba45 304
;* Where  : argument = [1..2] ;; @@ba45 304
;*   1 : return multicolor #1 ;; @@ba45 304
;*   2 : return multicolor #2 ;; @@ba45 304
;****************************************************************** ;; @@ba45 304
 ;; @@ba45 304
rspcolor                                                   ;; @@ba45 304
                 jsr chkcls                               ; check for closing paren ;; @@ba45 304
                 jsr conint                               ; get arg in .X ;; @@ba48 304
                 dex                                      ; adjust [1..2] to [0..1 ;; @@ba4b 304
                 cpx #2                                    ;; @@ba4c 304
                 +lbcs fcerr                              ; value error ;; @@ba4e 304
 ;; @@ba51 304
; jsr put_io_in_map ;; @@ba51 304
                 lda vic+37,x                              ;; @@ba51 304
                 and #$0f                                  ;; @@ba54 304
                 tay                                       ;; @@ba56 304
; iny  ;range 0-15     [910724] ;; @@ba57 304
                 +lbra sngflt                             ; float 1 byte arg in .Y ;; @@ba57 304
 ;; @@ba5a 304
;.end ;; @@ba5a 304
; .page ;; @@ba5a 304
; .subttl RSPPOS Function ;; @@ba5a 304
 ;; @@ba5a 304
;****************************************************************** ;; @@ba5a 304
;* RSPPOS - Return sprite location / speed data ;; @@ba5a 304
;* ;; @@ba5a 304
;* Syntax:  RSPPOS (sprite_number, argument) ;; @@ba5a 304
;* ;; @@ba5a 304
;* Where:   sprite_number = [0..7] ;; @@ba5a 304
;*    argument = [0..2] ;; @@ba5a 304
;*   0 : return X position ;; @@ba5a 304
;*   1 : return Y position ;; @@ba5a 304
;*   2 : return current speed ;; @@ba5a 304
;****************************************************************** ;; @@ba5a 304
 ;; @@ba5a 304
rsppos           jsr conint                               ; get first arg, sprite #, in .X ;; @@ba5a 304
; dex  ;adjust [1..8] to [0..7]   [910220] ;; @@ba5d 304
                 cpx #8  ; (318018-03 mod                 ; fab) ;; @@ba5d 304
                 bcs _local_1303_1                        ; value error ;; @@ba5f 304
 ;; @@ba61 304
                 phx                                      ; save sprite number ;; @@ba61 304
; jsr chkcom ;check for proper delimiter ;; @@ba62 304
; jsr getbyt ;do frmevl, get 1 byte arg (arg) in .X ;; @@ba62 304
                 jsr combyt                               ; [910820] ;; @@ba62 304
                 jsr chkcls                               ; look for closing paren ;; @@ba65 304
                 cpx #3                                    ;; @@ba68 304
_local_1303_1    +lbcs fcerr                              ; value error ;; @@ba6a 304
 ;; @@ba6d 304
                 ply                                      ; sprite number ;; @@ba6d 304
                 cpx #2                                    ;; @@ba6e 304
                 bne _local_1303_10                       ; branch if x or y position ;; @@ba70 304
 ;; @@ba72 304
                 ldx sproff,y                             ; get offset into speed data ;; @@ba72 304
                 ldy sprite_data,x                        ; get speed data ;; @@ba75 304
                 +lbra sngflt                             ; go float 1 byte arg in .Y ;; @@ba78 304
 ;; @@ba7b 304
; Get msb of sprite position (in case this is for x position) ;; @@ba7b 304
 ;; @@ba7b 304
_local_1303_10   sei                                       ;; @@ba7b 304
                 lda sbits,y                              ; get bit mask for this sprite ;; @@ba7c 304
                 and vic+16                               ; ???vic_save ;; @@ba7f 304
                 beq _local_1303_20                        ;; @@ba82 304
                 lda #1                                   ; change any non-zero to a '1' ;; @@ba84 304
_local_1303_20   pha                                      ; save msb ;; @@ba86 304
 ;; @@ba87 304
                 tya                                      ; y = sprite# * 2 ;; @@ba87 304
                 asl                                       ;; @@ba88 304
                 tay                                       ;; @@ba89 304
                 txa                                      ; see if this is y position ;; @@ba8a 304
                 lsr                                      ; .C = 0 for x pos'n, 1 for y pos'n ;; @@ba8b 304
                 bcc _local_1303_30                       ; branch if x pos'n ;; @@ba8c 304
 ;; @@ba8e 304
                 iny                                      ; adjust pointer to point to y pos'n in register data ;; @@ba8e 304
                 pla                                       ;; @@ba8f 304
                 lda #0                                   ; ..and force 'msb' to be zero ;; @@ba90 304
                 pha                                       ;; @@ba92 304
 ;; @@ba93 304
_local_1303_30   lda vic,y                                ; get correct location lsb   ???vic_save ;; @@ba93 304
                 cli                                       ;; @@ba96 304
                 tay                                       ;; @@ba97 304
                 pla                                      ; ..and get msb, ;; @@ba98 304
                 +lbra nosflt                             ; ..and go float 2 byte value in y,a ;; @@ba99 304
 ;; @@ba9c 304
;.end ;; @@ba9c 304
; .page ;; @@ba9c 304
; .subttl BUMP Function ;; @@ba9c 304
 ;; @@ba9c 304
;****************************************************************** ;; @@ba9c 304
;* BUMP - read sprite collision ;; @@ba9c 304
;* ;; @@ba9c 304
;* Syntax : BUMP (argument) ;; @@ba9c 304
;* ;; @@ba9c 304
;* Where  : argument = [1..2] ;; @@ba9c 304
;*   1 : sprite/sprite collision ;; @@ba9c 304
;*   2 : sprite/background collision ;; @@ba9c 304
;****************************************************************** ;; @@ba9c 304
 ;; @@ba9c 304
bump             jsr chkcls                                ;; @@ba9c 305
                 jsr conint                               ; get arg in .X ;; @@ba9f 305
                 dex                                      ; adjust [1..2] to [0..1] ;; @@baa2 305
                 cpx #2                                    ;; @@baa3 305
                 +lbcs fcerr                              ; value error ;; @@baa5 305
 ;; @@baa8 305
                 sei                                       ;; @@baa8 305
                 ldy collisions,x                         ; get recorded collisions ;; @@baa9 305
                 lda #0                                   ; reset them ;; @@baac 305
                 sta collisions,x                          ;; @@baae 305
                 cli                                       ;; @@bab1 305
                 +lbra sngflt                             ; float 1 byte arg in .Y ;; @@bab2 305
 ;; @@bab5 305
;.end ;; @@bab5 305
; .page ;; @@bab5 305
; .subttl Sprite Support Routines ;; @@bab5 305
 ;; @@bab5 305
; GRAPHIC3.SRC ;; @@bab5 305
;**************************************************************** ;; @@bab5 305
;  getang  -  set cosine & sine values ;; @@bab5 305
;             results in sinval & cosval based as a fraction ;; @@bab5 305
;             - over 65536 ;; @@bab5 305
;             angsgn = angle phase (0-3) ;; @@bab5 305
;    on input vwork+y = 2 byte angle ;; @@bab5 305
;*************************************************************** ;; @@bab5 305
 ;; @@bab5 305
getang                                                     ;; @@bab5 305
                 jsr settwo                               ; move angle value into y/a ;; @@bab5 305
 ;; @@bab8 305
gtang1           ldx #0                                   ; init count of phase ;; @@bab8 305
 ;; @@baba 305
_local_1304_10   inx                                       ;; @@baba 305
                 sec                                       ;; @@babb 305
                 sbc #90                                  ; subtract 90 until less than 0 ;; @@babc 305
                 bcs _local_1304_10                        ;; @@babe 305
                 dey                                       ;; @@bac0 305
                 bpl _local_1304_10                        ;; @@bac1 305
                 stx angsgn                               ; save phase (here it is 1-4) ;; @@bac3 305
                 pha                                       ;; @@bac6 305
                 adc #90                                  ; make positive ;; @@bac7 305
                 jsr _local_1304_20                       ; do division by 10 ;; @@bac9 305
                 pla                                      ; get 2's comp of angle ;; @@bacc 305
                 clc                                       ;; @@bacd 305
                 eor #$ff                                  ;; @@bace 305
                 adc #1                                   ; make positive ;; @@bad0 305
                 dec angsgn                               ; correct phase ;; @@bad2 305
 ;; @@bad5 305
_local_1304_20   ldx #$ff                                  ;; @@bad5 305
_local_1304_30   inx                                      ; do division by 10 ;; @@bad7 305
                 sec                                       ;; @@bad8 305
                 sbc #10                                   ;; @@bad9 305
                 bcs _local_1304_30                        ;; @@badb 305
                 adc #10                                  ; make positive ;; @@badd 305
                 sta vtemp1                               ; save remainder ;; @@badf 305
                 txa                                       ;; @@bae2 305
                 asl                                      ; get quotient*2 as index ;; @@bae3 305
                 tax                                       ;; @@bae4 305
                 lda angval+1,x                           ; get low byte base ;; @@bae5 305
                 ldy angval,x                             ; get high byte value ;; @@bae8 305
 ;; @@baeb 305
_local_1304_40   clc                                       ;; @@baeb 305
                 dec vtemp1                                ;; @@baec 305
                 bmi _local_1304_50                       ; done - remainder = 0 ;; @@baef 305
                 adc incval+1,x                           ; add low byte increment ;; @@baf1 305
                 pha                                       ;; @@baf4 305
                 tya                                       ;; @@baf5 305
                 adc incval,x                             ; add high byte increment ;; @@baf6 305
                 tay                                       ;; @@baf9 305
                 pla                                       ;; @@bafa 305
                 bcc _local_1304_40                       ; ...always ;; @@bafb 305
 ;; @@bafd 305
_local_1304_50   pha                                      ; save low byte of result ;; @@bafd 305
                 ldx #0                                   ; point to sinval ;; @@bafe 305
                 lda angsgn                                ;; @@bb00 305
                 lsr                                       ;; @@bb03 305
                 bcs _local_1304_60                       ; skip if sine value ;; @@bb04 305
                 ldx #2                                   ; point to cosval ;; @@bb06 305
 ;; @@bb08 305
_local_1304_60   pla                                       ;; @@bb08 305
                 sta sinval,x                             ; save low byte result ;; @@bb09 305
                 tya                                       ;; @@bb0c 305
                 sta sinval+1,x                           ; save high byte result ;; @@bb0d 305
                 rts                                       ;; @@bb10 305
 ;; @@bb11 305
; .page ;; @@bb11 305
;************************************************************* ;; @@bb11 305
;  angmlt  -  multiple 2-byte integer times angle ;; @@bb11 305
;       carry set/reset = cosine/sine ;; @@bb11 305
; ;; @@bb11 305
;       vwork+x = 2-byte integer ;; @@bb11 305
;       result left in y/a ;; @@bb11 305
;************************************************************* ;; @@bb11 305
 ;; @@bb11 305
angmlt                                                     ;; @@bb11 306
                 ldy #sinval-vwork                        ; get offset to angle value ;; @@bb11 306
                 bcc _local_1305_10                       ; get cosine/sine offset ;; @@bb13 306
                 ldy #cosval-vwork                         ;; @@bb15 306
 ;; @@bb17 306
_local_1305_10   lda angsgn                                ;; @@bb17 306
                 adc #2                                   ; correct phase for cosine to look as sine ;; @@bb1a 306
                 lsr                                       ;; @@bb1c 306
                 lsr                                       ;; @@bb1d 306
                 php                                      ; save if carry - means negative angle value ;; @@bb1e 306
                 jsr settwo                               ; get angle fraction in y/a ;; @@bb1f 306
                 cpy #$ff                                 ; test if value should be 1 ;; @@bb22 306
                 bcc _local_1305_20                       ; skip if not ;; @@bb24 306
                 txa                                       ;; @@bb26 306
                 tay                                      ; get offset to integer ;; @@bb27 306
                 jsr settwo                               ; just get integer - multiplied by 1 ;; @@bb28 306
                 bcs _local_1305_30                        ;; @@bb2b 306
 ;; @@bb2d 306
_local_1305_20   jsr twobyt                               ; multiply integer times angle value ;; @@bb2d 306
_local_1305_30   plp                                      ; get sign of angle ;; @@bb30 306
                 bcc invert                               ; invert result if negative,do rts ;; @@bb31 306
                 rts                                       ;; @@bb33 306
 ;; @@bb34 306
; .page ;; @@bb34 306
;************************************************************* ;; @@bb34 306
;  angdst  -  set up values for distance * angles ;; @@bb34 306
;       vwork+x = x & y distances ;; @@bb34 306
;       a = angles : ang1,ang2,ang3,ang4,0,0,0,0 ;; @@bb34 306
;       get  xdist1 = xdist1 * angle-1 ;; @@bb34 306
;     ydist1 = ydist1 * angle-2 ;; @@bb34 306
;     xdist2 = xdist2 * angle-3 ;; @@bb34 306
;     ydist2 = ydist2 * angle-4 ;; @@bb34 306
;************************************************************* ;; @@bb34 306
; ;; @@bb34 306
;angdst ;; @@bb34 306
; sta angcnt      ;save angles ;; @@bb34 306
; ldx #xdist1-vwork ;; @@bb34 306
;angd10 ;; @@bb34 306
; asl angcnt ;; @@bb34 306
; jsr angmlt      ;multiply angle * distance ;; @@bb34 306
; sta vwork,x ;; @@bb34 306
; tya  ;save results ;; @@bb34 306
; sta vwork+1,x ;; @@bb34 306
; inx  ;point to next distance ;; @@bb34 306
; inx ;; @@bb34 306
; cpx #disend-vwork ;; @@bb34 306
; bcc angd10 ;loop 4 times ;; @@bb34 306
;angd20 rts ;; @@bb34 306
 ;; @@bb34 306
;.end ;; @@bb34 306
; .page ;; @@bb34 306
; GRAPHIC8.SRC ;; @@bb34 306
;**************************************************************** ;; @@bb34 306
;  docolr  --  set up color for 8x8 charcater cell ;; @@bb34 306
;   x = row number  --  y = column number ;; @@bb34 306
;**************************************************************** ;; @@bb34 306
; ;; @@bb34 306
;docolr lda _ldtb2,x      ;put address of video ram into grapnt ;; @@bb34 306
; sta grapnt ;; @@bb34 306
; lda graphic_ldtb1,x ;point to bit mapped color area ;; @@bb34 306
; sta grapnt+1 ;; @@bb34 306
; ;; @@bb34 306
; lda colsel  ;get current color source selected ;; @@bb34 306
; ;; @@bb34 306
; bne _local_1305_10   ;branch if NOT background ;; @@bb34 306
; lda fg_bg ;; @@bb34 306
; bit _graphm  ;test if mode = hires ;; @@bb34 306
; bpl 25$   ;if so, go set up byte ;; @@bb34 306
; rts   ;else exit ;; @@bb34 306
; ;; @@bb34 306
;_local_1305_10 cmp #2 ;; @@bb34 306
; bne _local_1305_30   ;branch if NOT multi-color 1 ;; @@bb34 306
; ;; @@bb34 306
;_local_1305_20 lda fg_mc1  ;get correct packed colors for multicolor mode. ;; @@bb34 306
;25$ and #$0f ;; @@bb34 306
; sta z_p_temp_1 ;; @@bb34 306
; lda (grapnt),y ;; @@bb34 306
; and #$f0 ;; @@bb34 306
; ora z_p_temp_1 ;; @@bb34 306
; sta (grapnt),y ;; @@bb34 306
; rts ;; @@bb34 306
; ;; @@bb34 306
;_local_1305_30 bcs 40$   ;branch if multicolor 2 ;; @@bb34 306
; ;; @@bb34 306
; lda fg_bg  ;here for foreground. get packed colors. ;; @@bb34 306
; and #$f0 ;; @@bb34 306
; sta z_p_temp_1 ;; @@bb34 306
; lda (grapnt),y  ;do foreground ;; @@bb34 306
; and #$0f ;; @@bb34 306
; ora z_p_temp_1 ;; @@bb34 306
; sta (grapnt),y ;; @@bb34 306
; rts ;; @@bb34 306
; ;; @@bb34 306
;40$ lda grapnt+1  ;do multicolor 2 ;; @@bb34 306
; and #3 ;; @@bb34 306
; ora #>color_ram_hi ;set up to point to high color area ;; @@bb34 306
; sta grapnt+1 ;; @@bb34 306
; ;; @@bb34 306
; lda #0   ;put i/o in map ;; @@bb34 306
; sta mmu_config_reg ;; @@bb34 306
; ;; @@bb34 306
; sei ;; @@bb34 306
; lda _6510_data_reg ;; @@bb34 306
; pha ;; @@bb34 306
; and #%11111110  ;point cpu at correct nybble bank ;; @@bb34 306
; sta _6510_data_reg ;; @@bb34 306
; lda multicolor_2 ;; @@bb34 306
; sta (grapnt),y ;; @@bb34 306
; pla ;; @@bb34 306
; sta _6510_data_reg ;; @@bb34 306
; cli ;; @@bb34 306
; rts ;; @@bb34 306
; ;; @@bb34 306
; ;; @@bb34 306
; ;; @@bb34 306
;graphic_ldtb1   ;_ldtb1 adjusted for an org at color_ram_lo ;; @@bb34 306
;99$=color_ram_lo ;; @@bb34 306
;1$=color_ram_lo+40*1 ;; @@bb34 306
;2$=color_ram_lo+40*2 ;; @@bb34 306
;3$=color_ram_lo+40*3 ;; @@bb34 306
;4$=color_ram_lo+40*4 ;; @@bb34 306
;5$=color_ram_lo+40*5 ;; @@bb34 306
;6$=color_ram_lo+40*6 ;; @@bb34 306
;7$=color_ram_lo+40*7 ;; @@bb34 306
;8$=color_ram_lo+40*8 ;; @@bb34 306
;9$=color_ram_lo+40*9 ;; @@bb34 306
;_local_1305_10=color_ram_lo+40*10 ;; @@bb34 306
;11$=color_ram_lo+40*11 ;; @@bb34 306
;12$=color_ram_lo+40*12 ;; @@bb34 306
;13$=color_ram_lo+40*13 ;; @@bb34 306
;14$=color_ram_lo+40*14 ;; @@bb34 306
;15$=color_ram_lo+40*15 ;; @@bb34 306
;16$=color_ram_lo+40*16 ;; @@bb34 306
;17$=color_ram_lo+40*17 ;; @@bb34 306
;18$=color_ram_lo+40*18 ;; @@bb34 306
;19$=color_ram_lo+40*19 ;; @@bb34 306
;_local_1305_20=color_ram_lo+40*20 ;; @@bb34 306
;21$=color_ram_lo+40*21 ;; @@bb34 306
;22$=color_ram_lo+40*22 ;; @@bb34 306
;23$=color_ram_lo+40*23 ;; @@bb34 306
;24$=color_ram_lo+40*24 ;; @@bb34 306
; ;; @@bb34 306
; .byte >99$,>1$,>2$,>3$,>4$,>5$,>6$,>7$,>8$,>9$,>_local_1305_10 ;; @@bb34 306
; .byte >11$,>12$,>13$,>14$,>15$,>16$,>17$,>18$,>19$ ;; @@bb34 306
; .byte >_local_1305_20,>21$,>22$,>23$,>24$ ;; @@bb34 306
 ;; @@bb34 306
; .page ;; @@bb34 306
;****************************************************************** ;; @@bb34 306
;  getpos - get address in graphic bit map into grapnt ;; @@bb34 306
;      x = bit offset into byte specified (0-7) ;; @@bb34 306
;      y = offset to byte within 8x8 character cell ;; @@bb34 306
;      a = bit mask to the bit (or bits if multicolor mode) ;; @@bb34 306
;****************************************************************** ;; @@bb34 306
; ;; @@bb34 306
;getpos jsr divpos      ;get xpos/ypos to column/row position ;; @@bb34 306
; bcs grprts      ;abort if position too large ;; @@bb34 306
; ;; @@bb34 306
;getps1 tya  ;get addr for row (X) and col (Y) in grapnt ;; @@bb34 306
; clc ;; @@bb34 306
; adc _ldtb2,x ;add column position to low byte offset ;; @@bb34 306
; sta grapnt ;; @@bb34 306
; lda _ldtb1,x ;get high byte screen address ;; @@bb34 306
; adc #0  ;add any carry ;; @@bb34 306
; asl grapnt ;; @@bb34 306
; rol a ;; @@bb34 306
; asl grapnt ;mult by 8 to get offset into 8k area ;; @@bb34 306
; rol a ;; @@bb34 306
; asl grapnt ;; @@bb34 306
; rol a ;; @@bb34 306
; sta grapnt+1 ;; @@bb34 306
; ;; @@bb34 306
; lda ypos ;; @@bb34 306
; and #07 ;; @@bb34 306
; tay  ;get byte offset into 8x8 char cell ;; @@bb34 306
; lda xpos ;; @@bb34 306
; bit _graphm ;; @@bb34 306
; php ;; @@bb34 306
; bpl grpos3 ;skip if not multicolor mode ;; @@bb34 306
; asl a  ;shift x-pos for multicolor mode ;; @@bb34 306
; ;; @@bb34 306
;grpos3 and #07 ;; @@bb34 306
; tax ;; @@bb34 306
; lda rbits,x ;get bit mask ;; @@bb34 306
; plp ;; @@bb34 306
; bpl grprts ;done if not multicolor mode ;; @@bb34 306
; inx ;; @@bb34 306
; ora rbits,x ;mask for 2 bits if multicolor mode ;; @@bb34 306
;grprts rts ;; @@bb34 306
; ;; @@bb34 306
;rbits .byte   $80,$40,$20,$10,$08,$04,$02,$01 ;; @@bb34 306
 ;; @@bb34 306
; .page ;; @@bb34 306
;************************************************************** ;; @@bb34 306
;  divpos  --  convert xpos to column number ;; @@bb34 306
;  convert ypos to row number ;; @@bb34 306
;  return carry set if either above limits ;; @@bb34 306
;************************************************************** ;; @@bb34 306
; ;; @@bb34 306
;divpos lda xpos+1 ;; @@bb34 306
; lsr a ;; @@bb34 306
; bne _local_1305_20       ;out of bounds if greater than 1 ;; @@bb34 306
; lda xpos ;; @@bb34 306
; ror a ;; @@bb34 306
; lsr a  ;get column position = xpos/8 ;; @@bb34 306
; bit _graphm ;; @@bb34 306
; bmi _local_1305_10  ;skip if multicolor mode ;; @@bb34 306
; lsr a  ;divide by 8 if a hires or text mode ;; @@bb34 306
;_local_1305_10 tay ;; @@bb34 306
; cpy #llen ;; @@bb34 306
; bcs _local_1305_20  ;error exit if out of bounds ;; @@bb34 306
; lda ypos+1 ;; @@bb34 306
; bne _local_1305_20  ;out of bounds error if not = 0 ;; @@bb34 306
; lda ypos ;; @@bb34 306
; lsr a ;; @@bb34 306
; lsr a  ;get row number = ypos/8 ;; @@bb34 306
; lsr a ;; @@bb34 306
; tax ;; @@bb34 306
; cmp #nlines ;compare to max number of rows ;; @@bb34 306
; rts  ;carry clr if okay ;; @@bb34 306
;_local_1305_20 sec ;; @@bb34 306
; rts ;; @@bb34 306
 ;; @@bb34 306
; .page ;; @@bb34 306
;*************************************************************** ;; @@bb34 306
;   SCALXY  - Scale the x & y coordinates found in vwork+x ;; @@bb34 306
;*************************************************************** ;; @@bb34 306
; ;; @@bb34 306
;scalxy lda scalem ;; @@bb34 306
; beq sclrts      ;do nothing if scaling off ;; @@bb34 306
; ;; @@bb34 306
; lda scale_x ;; @@bb34 306
; ldy scale_x+1 ;; @@bb34 306
; jsr doscal      ;scale in the x-direction ;; @@bb34 306
; ;; @@bb34 306
; lda scale_y ;; @@bb34 306
; ldy scale_y+1 ;scale in the y direction ;; @@bb34 306
; ;; @@bb34 306
;doscal jsr twobyt ;multiply * coordinate ;; @@bb34 306
; sta vwork,x ;; @@bb34 306
; tya ;; @@bb34 306
; inx  ;store back into original position ;; @@bb34 306
; sta vwork,x ;; @@bb34 306
; inx ;; @@bb34 306
;sclrts ;; @@bb34 306
; rts ;; @@bb34 306
 ;; @@bb34 306
;.end ;; @@bb34 306
; .page ;; @@bb34 306
;GRAPHICS9.SRC ;; @@bb34 306
;*************************************************************** ;; @@bb34 306
;   DOTWO  - Add      two 2-byte values if carry clear ;; @@bb34 306
;  Subtract two 2-byte values if carry set ;; @@bb34 306
;*************************************************************** ;; @@bb34 306
 ;; @@bb34 306
dotwo2                                                     ;; @@bb34 307
                 bcc addtw2                               ; go do addition ;; @@bb34 307
                 bcs subtw2                               ; go do subtraction ;; @@bb36 307
dotwo                                                      ;; @@bb38 307
                 bcs subtwo                               ; go do subtraction ;; @@bb38 307
 ;; @@bb3a 307
;*************************************************************** ;; @@bb3a 307
;  ADDTWO  - Add vwork+y and vwork+x  Result in y/a ;; @@bb3a 307
;*************************************************************** ;; @@bb3a 307
 ;; @@bb3a 307
addtwo                                                     ;; @@bb3a 307
                 jsr settwo                               ; put vwrok+y into y/a ;; @@bb3a 307
 ;; @@bb3d 307
addtw2                                                    ; enter here to add y/a to vwork+x ;; @@bb3d 307
                 clc                                       ;; @@bb3d 307
                 adc vwork,x                               ;; @@bb3e 307
                 pha                                       ;; @@bb41 307
                 tya                                       ;; @@bb42 307
                 adc vwork+1,x                             ;; @@bb43 307
                 tay                                       ;; @@bb46 307
                 pla                                       ;; @@bb47 307
                 rts                                       ;; @@bb48 307
 ;; @@bb49 307
; .page ;; @@bb49 307
;**************************************************************** ;; @@bb49 307
;  SUBTWO  - Subtract vwork+y - vwork+x Result in y/a ;; @@bb49 307
;**************************************************************** ;; @@bb49 307
 ;; @@bb49 307
subtwo                                                     ;; @@bb49 307
                 jsr settwo                               ; move vwork+y into y/a ;; @@bb49 307
 ;; @@bb4c 307
subtw2                                                    ; enter here with 1st value in y/a ;; @@bb4c 307
                 sec                                       ;; @@bb4c 307
                 sbc vwork,x                               ;; @@bb4d 307
                 sta tempf1                                ;; @@bb50 307
                 tya                                       ;; @@bb52 307
                 sbc vwork+1,x                             ;; @@bb53 307
                 tay                                       ;; @@bb56 307
                 php                                       ;; @@bb57 307
                 lda tempf1                                ;; @@bb58 307
                 plp                                       ;; @@bb5a 307
                 rts                                       ;; @@bb5b 307
 ;; @@bb5c 307
 ;; @@bb5c 307
subtwo_savram                                              ;; @@bb5c 307
                 lda savram,y                             ; load value into y,a ;; @@bb5c 307
                 pha                                       ;; @@bb5f 307
                 lda savram+1,y                            ;; @@bb60 307
                 tay                                       ;; @@bb63 307
                 pla                                       ;; @@bb64 307
                 sec                                       ;; @@bb65 307
                 sbc savram,x                              ;; @@bb66 307
                 sta tempf1                                ;; @@bb69 307
                 tya                                       ;; @@bb6b 307
                 sbc savram+1,x                            ;; @@bb6c 307
                 tay                                       ;; @@bb6f 307
                 php                                       ;; @@bb70 307
                 lda tempf1                                ;; @@bb71 307
                 plp                                       ;; @@bb73 307
                 rts                                       ;; @@bb74 307
 ;; @@bb75 307
; .page ;; @@bb75 307
;************************************************************ ;; @@bb75 307
;  SETTWO  - Move value in vwork+y into y/a ;; @@bb75 307
;************************************************************ ;; @@bb75 307
 ;; @@bb75 307
settwo                                                     ;; @@bb75 307
                 lda vwork,y                               ;; @@bb75 307
                 pha                                       ;; @@bb78 307
                 lda vwork+1,y                             ;; @@bb79 307
                 tay                                       ;; @@bb7c 307
                 pla                                       ;; @@bb7d 307
                 rts                                       ;; @@bb7e 307
 ;; @@bb7f 307
;****************************************************************** ;; @@bb7f 307
;  ABSTWO  - Get absolute value of vwork+y - vwork+x ;; @@bb7f 307
;  Result in y/a  -  carry === vwork+y >= vwork+x ;; @@bb7f 307
;****************************************************************** ;; @@bb7f 307
 ;; @@bb7f 307
abstwo                                                    ; movspr_to [910809] ;; @@bb7f 307
                 jsr subtwo                               ; subtract vwork+y - vwork+x ;; @@bb7f 307
abstw2                                                    ; entrance with vwork+y in y/a ;; @@bb82 307
                 bpl absrts                               ; done if result is positive ;; @@bb82 307
invert           php                                       ;; @@bb84 307
                 clc                                       ;; @@bb85 307
                 eor #$ff                                 ; invert low byte result and add 1 ;; @@bb86 307
                 adc #1                                    ;; @@bb88 307
                 pha                                       ;; @@bb8a 307
                 tya                                       ;; @@bb8b 307
                 eor #$ff                                 ; invert high byte result ;; @@bb8c 307
                 adc #0                                   ; add back any carry ;; @@bb8e 307
                 tay                                       ;; @@bb90 307
                 pla                                       ;; @@bb91 307
                 plp                                       ;; @@bb92 307
absrts           rts                                       ;; @@bb93 307
 ;; @@bb94 307
; .page ;; @@bb94 307
;**************************************************************** ;; @@bb94 307
;  TWOBYT  - Multiply 2 byte fraction in y/a times 2 bytes ;; @@bb94 307
;  Integer found in vwork+x-reg.  Result = y/a ;; @@bb94 307
;**************************************************************** ;; @@bb94 307
 ;; @@bb94 307
twobyt                                                     ;; @@bb94 307
                 sty vtemp1                               ; save fraction ;; @@bb94 307
                 sta vtemp2                                ;; @@bb97 307
                 lda vwork,x                               ;; @@bb9a 307
                 ldy vwork+1,x                             ;; @@bb9d 307
                 php                                      ; save sign of integer ;; @@bba0 307
                 jsr abstw2                               ; absolute value ;; @@bba1 307
                 sta vwork,x                               ;; @@bba4 307
                 tya                                       ;; @@bba7 307
                 sta vwork+1,x                             ;; @@bba8 307
                 lda #0                                    ;; @@bbab 307
                 sta vtemp3                               ; initialize result to zero ;; @@bbad 307
 ;; @@bbb0 307
                 ldy #16                                  ; initialize count ;; @@bbb0 307
_local_1306_10   lsr vtemp1                                ;; @@bbb2 307
                 ror vtemp2                                ;; @@bbb5 307
                 bcc _local_1306_20                       ; skip if no bit set ;; @@bbb8 307
                 clc                                       ;; @@bbba 307
                 adc vwork,x                              ; add integer low byte ;; @@bbbb 307
                 pha                                       ;; @@bbbe 307
                 lda vtemp3                                ;; @@bbbf 307
                 adc vwork+1,x                            ; add integer high byte to total ;; @@bbc2 307
                 sta vtemp3                                ;; @@bbc5 307
                 pla                                       ;; @@bbc8 307
 ;; @@bbc9 307
_local_1306_20   lsr vtemp3                               ; divide by 2 ;; @@bbc9 307
                 ror                                       ;; @@bbcc 307
                 dey                                       ;; @@bbcd 307
                 bne _local_1306_10                       ; loop 16 times - test all bits in 2 bytes ;; @@bbce 307
 ;; @@bbd0 307
                 adc #0                                   ; add back round factor ;; @@bbd0 307
                 ldy vtemp3                                ;; @@bbd2 307
                 bcc _local_1306_30                        ;; @@bbd5 307
                 iny                                       ;; @@bbd7 307
_local_1306_30   plp                                      ; pop sign ;; @@bbd8 307
                 bra abstw2                               ; return with signed product in y/a ;; @@bbd9 307
 ;; @@bbdb 307
; .page ;; @@bbdb 307
;****************************************************************** ;; @@bbdb 307
;  dstpos  -  move xdest/ydest to xpos/ypos ;; @@bbdb 307
;****************************************************************** ;; @@bbdb 307
; ;; @@bbdb 307
;dstpos ;; @@bbdb 307
; ldy #0 ;; @@bbdb 307
; jsr dstmov ;; @@bbdb 307
; ldy #2 ;; @@bbdb 307
;dstmov ;; @@bbdb 307
; lda xdest,y ;; @@bbdb 307
; sta xpos,y ;; @@bbdb 307
; lda xdest+1,y ;; @@bbdb 307
; sta xpos+1,y ;; @@bbdb 307
; rts ;; @@bbdb 307
 ;; @@bbdb 307
;.end ;; @@bbdb 307
; .page ;; @@bbdb 307
;GRAPHICS10.SRC ;; @@bbdb 307
;************************************************************ ;; @@bbdb 307
;   incolr  --  get color selection parameter into colsel ;; @@bbdb 307
;************************************************************ ;; @@bbdb 307
; ;; @@bbdb 307
;incolr ;; @@bbdb 307
; ldx #1   ;get an optional 1 byte val, def=fg(1) ;; @@bbdb 307
; jsr chrgot ;; @@bbdb 307
;incol1 ;; @@bbdb 307
; beq incol2       ;eol, use default ;; @@bbdb 307
; cmp #',' ;; @@bbdb 307
; beq incol2       ;just ',', use default ;; @@bbdb 307
; jsr getbyt ;; @@bbdb 307
; cpx #4   ;must be 0-3 ;; @@bbdb 307
; bcs illval       ;..else illegal value ;; @@bbdb 307
; cpx #2 ;; @@bbdb 307
; bit _graphm       ;if hires, must be 0 or 1 ;; @@bbdb 307
; bmi incol2 ;; @@bbdb 307
; bcs illval ;; @@bbdb 307
;incol2 ;; @@bbdb 307
; stx colsel ;; @@bbdb 307
; rts ;; @@bbdb 307
; ;; @@bbdb 307
;illval ;; @@bbdb 307
; jmp fcerr  ;illegal value ;; @@bbdb 307
 ;; @@bbdb 307
; .page ;; @@bbdb 307
;****************************************************************** ;; @@bbdb 307
;  INCORD  ---  Get X,Y coordinate from input stream into vwork+x ;; @@bbdb 307
; ;; @@bbdb 307
;  Coordinate may have any of the forms: ;; @@bbdb 307
;    x,y  = absolute xpos & absolute ypos ;; @@bbdb 307
; +/-x,y  = relative xpos & absolute ypos ;; @@bbdb 307
;    x,+/-y = absolute xpos & relative ypos ;; @@bbdb 307
; +/-x,+/-y = relative xpos & relative ypos ;; @@bbdb 307
;    x;y  = x-distance at an angle y ;; @@bbdb 307
; ;; @@bbdb 307
;  Relative and angle distances are relative to current x,ypos. ;; @@bbdb 307
;  Values are scaled to current mode parameters if required. ;; @@bbdb 307
;****************************************************************** ;; @@bbdb 307
 ;; @@bbdb 307
 ;; @@bbdb 307
incor2                                                    ; enter here for optional argument ;; @@bbdb 308
                 jsr chrgot                               ; end of line? ;; @@bbdb 308
                 beq _local_1307_10                       ; yes, use defaults ;; @@bbde 308
                 jsr chkcom                                ;; @@bbe0 308
                 cmp #','                                 ; is there really an arg? ;; @@bbe3 308
                 bne incord                               ; yes, let'er rip ;; @@bbe5 308
 ;; @@bbe7 308
_local_1307_10   ldy #0                                   ; set default pos = current pos ;; @@bbe7 308
_local_1307_20   lda xpos,y                                ;; @@bbe9 308
                 sta vwork,x                               ;; @@bbec 308
                 inx                                       ;; @@bbef 308
                 iny                                       ;; @@bbf0 308
                 cpy #4                                    ;; @@bbf1 308
                 bcc _local_1307_20                        ;; @@bbf3 308
                 rts                                       ;; @@bbf5 308
 ;; @@bbf6 308
; .page ;; @@bbf6 308
;incor3    ;enter here for non-optional arg preceded by a comma ;; @@bbf6 308
; jsr chkcom ;; @@bbf6 308
incord                                                     ;; @@bbf6 309
                 stx vtemp4                               ; save offset to destination ;; @@bbf6 309
                 jsr cordsb                               ; get 2-byte x-parameter ;; @@bbf9 309
                 jsr chrgot                                ;; @@bbfc 309
                 cmp #','                                  ;; @@bbff 309
                 beq docord                               ; skip ahead if have comma ;; @@bc01 309
 ;; @@bc03 309
                 cmp #';'                                 ; check for semi-colon ;; @@bc03 309
                 +lbne snerr                              ; missing angle param- show syntax message ;; @@bc05 309
                 jsr chrget       ;skip over '            ; ' ;; @@bc08 309
                 jsr getwrd                               ; get 2-byte angle in a,y ;; @@bc0b 309
                 sta z_p_temp_1                           ; swap a,y ;; @@bc0e 309
                 tya                                       ;; @@bc10 309
                 ldy z_p_temp_1                            ;; @@bc11 309
                 jsr gtang1                               ; get sine & cosine values for the angle ;; @@bc13 309
                 ldx vtemp4                                ;; @@bc16 309
                 lda vwork,x                               ;; @@bc19 309
                 sta vwork+2,x                            ; move length to y-parameter ;; @@bc1c 309
                 lda vwork+1,x                             ;; @@bc1f 309
                 sta vwork+3,x                             ;; @@bc22 309
; jsr scalxy       ;scale the values ;; @@bc25 309
                 lda #$0e                                  ;; @@bc25 309
                 sta vtemp5                                ;; @@bc27 309
                 clc                                       ;; @@bc2a 309
                 ldx vtemp4                                ;; @@bc2b 309
 ;; @@bc2e 309
_local_1308_10   jsr angmlt                               ; multiply length * angle ;; @@bc2e 309
                 sta vwork,x                              ; save angle result ;; @@bc31 309
                 tya                                       ;; @@bc34 309
                 sta vwork+1,x                             ;; @@bc35 309
                 ldy #xpos-vwork                           ;; @@bc38 309
                 lsr vtemp5                                ;; @@bc3a 309
                 bcc _local_1308_20                        ;; @@bc3d 309
                 ldy #ypos-vwork                           ;; @@bc3f 309
 ;; @@bc41 309
_local_1308_20   jsr dotwo                                ; add/subtract value to current position ;; @@bc41 309
                 sta vwork,x                               ;; @@bc44 309
                 tya                                      ; save result in destination ;; @@bc47 309
                 sta vwork+1,x                             ;; @@bc48 309
                 inx                                       ;; @@bc4b 309
                 inx                                       ;; @@bc4c 309
                 lsr vtemp5                                ;; @@bc4d 309
                 bne _local_1308_10                       ; do y-coordinate ;; @@bc50 309
                 clc                                       ;; @@bc52 309
                 rts                                       ;; @@bc53 309
 ;; @@bc54 309
; .page ;; @@bc54 309
docord           jsr chrget                               ; skip over comma ;; @@bc54 310
                 inc vtemp4                               ; point to y-destination ;; @@bc57 310
                 inc vtemp4                                ;; @@bc5a 310
                 jsr cordsb                               ; get y-paramter ;; @@bc5d 310
; ldx vtemp4 ;; @@bc60 310
; dex ;; @@bc60 310
; dex ;; @@bc60 310
; jsr scalxy       ;scale the values ;; @@bc60 310
                 ldy #ypos-vwork                           ;; @@bc60 310
                 ldx vtemp4                                ;; @@bc62 310
                 inx                                       ;; @@bc65 310
                 inx                                       ;; @@bc66 310
 ;; @@bc67 310
docor1           dex                                       ;; @@bc67 310
                 dex                                       ;; @@bc68 310
                 lsr vtemp5                                ;; @@bc69 310
                 bcc docor2                               ; skip if not relative ;; @@bc6c 310
                 jsr addtwo                               ; add to current position ;; @@bc6e 310
                 sta vwork,x                               ;; @@bc71 310
                 tya                                       ;; @@bc74 310
                 sta vwork+1,x                             ;; @@bc75 310
 ;; @@bc78 310
docor2           ldy #xpos-vwork                           ;; @@bc78 310
                 cpx vtemp4                                ;; @@bc7a 310
                 beq docor1                               ; loop to do x-coordinate ;; @@bc7d 310
                 clc                                       ;; @@bc7f 310
                 rts                                       ;; @@bc80 310
 ;; @@bc81 310
; ;; @@bc81 310
; CORDSB -- Get the next 2-byte parameter ;; @@bc81 310
; ;; @@bc81 310
 ;; @@bc81 310
cordsb           jsr chrgot                               ; read character ;; @@bc81 310
                 cmp #plus_token                          ; check if relative - plus sign ;; @@bc84 310
                 beq _local_1309_10                       ; skip if yes ;; @@bc86 310
                 cmp #minus_token                          ;; @@bc88 310
                 beq _local_1309_10                       ; skip if relative - minus sign ;; @@bc8a 310
                 clc                                      ; .c=1 if relative coord, .c=0 if absolute ;; @@bc8c 310
_local_1309_10   rol vtemp5                               ; save coord type for later ;; @@bc8d 310
                 jsr frmnum                                ;; @@bc90 310
                 jsr getsad                               ; get signed 2 byte coordinate (y,a), do rts ;; @@bc93 310
                 ldx vtemp4                                ;; @@bc96 310
                 sta vwork+1,x                            ; save 2-byte parameter ;; @@bc99 310
                 tya                                       ;; @@bc9c 310
                 sta vwork,x                               ;; @@bc9d 310
                 rts                                       ;; @@bca0 310
 ;; @@bca1 310
;.end ;; @@bca1 310
; .page ;; @@bca1 310
;GRAPHICS11.SRC ;; @@bca1 310
 ;; @@bca1 310
;  ANGVAL  -- Table of angle values on 10 degree boundaries ;; @@bca1 310
;  Values based as fraction of 65536 ;; @@bca1 310
 ;; @@bca1 310
angval                                                     ;; @@bca1 311
                 !text $00,$00                            ; sine 00 degrees -  .0000 ;; @@bca1 311
                 !text $2c,$71                            ; sine 10 degrees -  .1736 ;; @@bca3 311
                 !text $57,$8d                            ; sine 20 degrees -  .3420 ;; @@bca5 311
                 !text $80,$00                            ; sine 30 degrees -  .5000 ;; @@bca7 311
                 !text $a4,$8f                            ; sine 40 degrees -  .6428 ;; @@bca9 311
                 !text $c4,$19                            ; sine 50 degrees -  .7660 ;; @@bcab 311
                 !text $dd,$b2                            ; sine 60 degrees -  .8660 ;; @@bcad 311
                 !text $f0,$90                            ; sine 70 degrees -  .9397 ;; @@bcaf 311
                 !text $fc,$1c                            ; sine 80 degrees -  .9848 ;; @@bcb1 311
                 !text $ff,$ff                            ; sine 90 degrees - 1.0000 ;; @@bcb3 311
 ;; @@bcb5 311
;  INCVAL  -- Table of incremental values between 10 degrees ;; @@bcb5 311
;  Values based on fraction of 65536 ;; @@bcb5 311
 ;; @@bcb5 311
incval                                                     ;; @@bcb5 311
                 !text $04,$72                            ; 01 - 09 degrees -  .01739 ;; @@bcb5 311
                 !text $04,$50                            ; 11 - 19 degrees -  .01692 ;; @@bcb7 311
                 !text $04,$0b                            ; 21 - 29 degrees -  .01592 ;; @@bcb9 311
                 !text $03,$a8                            ; 31 - 39 degrees -  .01443 ;; @@bcbb 311
                 !text $03,$28                            ; 41 - 49 degrees -  .01252 ;; @@bcbd 311
                 !text $02,$90                            ; 51 - 59 degrees -  .01023 ;; @@bcbf 311
                 !text $01,$e3                            ; 61 - 69 degrees -  .00762 ;; @@bcc1 311
                 !text $01,$28                            ; 71 - 79 degrees -  .00477 ;; @@bcc3 311
                 !text $00,$63                            ; 81 - 89 degrees -  .00179 ;; @@bcc5 311
 ;; @@bcc7 311
;.end ;; @@bcc7 311
; .page ;; @@bcc7 311
; .subttl  EDIT Mode ;; @@bcc7 311
 ;; @@bcc7 311
; Edit mode is simply a poor man's word processor.  Text is entered normally ;; @@bcc7 311
; as if the user were typing in a program, but tokenization is turned off. ;; @@bcc7 311
; This affects only that text which follows a line number.  CRUNCH and QPLOP ;; @@bcc7 311
; test for this mode, and deal with the text accordingly.  RUN, GOTO, etc. ;; @@bcc7 311
; test for this mode and error-out if it's enabled.  LOADing a text file ;; @@bcc7 311
; will automatically add line numbers, SAVEing a text file will remove them. ;; @@bcc7 311
; ;; @@bcc7 311
; Syntax:  EDIT < ON | OFF > ;; @@bcc7 311
; ;; @@bcc7 311
; F. Bowen        [910620] ;; @@bcc7 311
 ;; @@bcc7 311
edit             jsr errind                               ; direct mode only command ;; @@bcc7 311
                 cmp #on_token                             ;; @@bcca 311
                 bne _local_1310_10                        ;; @@bccc 311
                 lda #%00010000                           ; EDIT ON ;; @@bcce 311
                 bra _local_1310_30                       ; (this kills trace mode, too) ;; @@bcd0 311
 ;; @@bcd2 311
_local_1310_10   jsr chkesc                               ; [910930] ;; @@bcd2 311
; cmp #esc_command_token ;; @@bcd5 311
; bne _local_1310_20 ;; @@bcd5 311
; jsr chrget ;; @@bcd5 311
                 cmp #off_token                            ;; @@bcd5 311
_local_1310_20   +lbne snerr                               ;; @@bcd7 311
                 lda #0                                   ; EDIT OFF ;; @@bcda 311
_local_1310_30   sta runmod                                ;; @@bcdc 311
                 jmp chrget                               ; exit ;; @@bcde 311
 ;; @@bce1 311
 ;; @@bce1 311
edit_crunch                                               ; Edit mode only, find end of plain text in input buffer ;; @@bce1 312
                 phw txtptr                               ; save current position in input buffer ;; @@bce1 312
                 jsr rem                                  ; find the end of the line ;; @@bce4 312
                 ldx txtptr                                ;; @@bce7 312
                 pla                                      ; restore buffer pointer ;; @@bce9 312
                 sta txtptr+1                              ;; @@bcea 312
                 pla                                       ;; @@bcec 312
                 sta txtptr                                ;; @@bced 312
                 sec                                      ; compute length of line ;; @@bcef 312
                 txa                                       ;; @@bcf0 312
                 sbc txtptr                                ;; @@bcf1 312
                 tay                                       ;; @@bcf3 312
                 iny                                       ;; @@bcf4 312
                 rts                                      ; done ;; @@bcf5 312
 ;; @@bcf6 312
 ;; @@bcf6 312
edit_p1line                                               ; Edit mode only, list a line of plain text ;; @@bcf6 312
                 jsr linprt                               ; print line number in (a,x) ;; @@bcf6 312
                 lda #' '                                 ; print a space ;; @@bcf9 312
 ;; @@bcfb 312
                 ldy #3                                   ; start printing at text following line number ;; @@bcfb 312
_local_1311_10   jsr outch                                ; print character ;; @@bcfd 312
                 iny                                       ;; @@bd00 312
                 bbr5 helper,_local_1311_20               ; if called from FIND/CHANGE check for highlighting ;; @@bd01 312
                 jsr helpsb                                ;; @@bd04 312
_local_1311_20   jsr indlow                               ; get next character ;; @@bd07 312
                 bne _local_1311_10                       ; loop until eol ;; @@bd0a 312
                 rts                                      ; done ;; @@bd0c 312
 ;; @@bd0d 312
 ;; @@bd0d 312
;.end ;; @@bd0d 312
; .page ;; @@bd0d 312
; EDIT LOAD/SAVE  Load or Save a plain text SEQ file in memory ;; @@bd0d 312
 ;; @@bd0d 312
edit_load                                                 ; Called by DLOAD/DVERIFY when in EDIT mode ;; @@bd0d 313
                 ldz #1                                    ;; @@bd0d 313
                 jsr open_SEQ_file                        ; Open the file just like TYPE: filename [,U#] [,D#] ;; @@bd0f 313
                 jsr Check_DS                             ; check current disk error message ;; @@bd12 313
                 ldy #0                                    ;; @@bd15 313
                 lda #dsdesc+1                             ;; @@bd17 313
                 jsr lda_far_ram1                         ; lda (dsdesc+1),y peek at first character ;; @@bd19 313
                 cmp #'2'                                  ;; @@bd1c 313
                 +lbcs _local_1312_30                     ; exit if error ;; @@bd1e 313
                 jsr Clear_DS                             ; else zap 'ok' message so user gets fresh one ;; @@bd21 313
                 ldx dosla                                 ;; @@bd24 313
                 jsr _chkin                               ; get input channel ;; @@bd27 313
                 +lbcs _local_1312_30                     ; error ;; @@bd2a 313
 ;; @@bd2d 313
                 bbs0 verck,_local_1312_1                  ;; @@bd2d 313
                 jsr _primm                                ;; @@bd30 313
                 !text cr,"LOADING",0                      ;; @@bd33 313
                 bra _local_1312_2                         ;; @@bd3c 313
_local_1312_1    jsr _primm                                ;; @@bd3e 313
                 !text cr,"VERIFYING",0                    ;; @@bd41 313
 ;; @@bd4c 313
_local_1312_2    lda #<1000                               ; default starting line # ;; @@bd4c 313
                 ldx #>1000                                ;; @@bd4e 313
                 sta linnum                                ;; @@bd50 313
                 stx linnum+1                              ;; @@bd52 313
 ;; @@bd54 313
                 lda txttab                               ; load address ;; @@bd54 313
                 ldx txttab+1                              ;; @@bd56 313
                 sta index                                 ;; @@bd58 313
                 stx index+1                               ;; @@bd5a 313
 ;; @@bd5c 313
_local_1312_10   ldy #0                                   ; Input one line of text ;; @@bd5c 313
                 jsr _stop                                ; check stop key ;; @@bd5e 313
                 beq _local_1312_28                       ; exit if down ;; @@bd61 313
                 jsr _readst                              ; check channel status ;; @@bd63 313
                 bne _local_1312_28                       ; exit if eof or error ;; @@bd66 313
 ;; @@bd68 313
                 bbr0 verck,_local_1312_15                 ;; @@bd68 313
                 ldy #3                                    ;; @@bd6b 313
                 bra _local_1312_20                       ; skip ahead if verify op ;; @@bd6d 313
 ;; @@bd6f 313
_local_1312_15   lda #1                                   ; install fake line links for this line ;; @@bd6f 313
                 jsr sta_far_in1                           ;; @@bd71 313
                 iny                                      ; 1 ;; @@bd74 313
                 jsr sta_far_in1                           ;; @@bd75 313
                 iny                                      ; 2 ;; @@bd78 313
                 lda linnum                               ; install line number for this line ;; @@bd79 313
                 jsr sta_far_in1                           ;; @@bd7b 313
                 iny                                      ; 3 ;; @@bd7e 313
                 lda linnum+1                              ;; @@bd7f 313
                 jsr sta_far_in1                           ;; @@bd81 313
                 clc                                       ;; @@bd84 313
                 lda linnum                               ; generate next line number ;; @@bd85 313
                 adc #10                                   ;; @@bd87 313
                 sta linnum                                ;; @@bd89 313
                 bcc _local_1312_20                        ;; @@bd8b 313
                 inc linnum+1                              ;; @@bd8d 313
 ;; @@bd8f 313
; .page ;; @@bd8f 313
_local_1312_20   iny                                      ; bump buffer pointer ;; @@bd8f 313
                 cpy #buflen                              ; check buffer (160 max. input buffer size to edit) ;; @@bd90 313
                 beq _local_1312_25                       ; split long lines into two???? ;; @@bd92 313
                 jsr _basin                               ; read file data ;; @@bd94 313
                 beq _local_1312_25                       ; CR or null terminates line ;; @@bd97 313
                 cmp #cr                                   ;; @@bd99 313
                 beq _local_1312_25                        ;; @@bd9b 313
; cmp #$20  ;adjust invisible characters less than space ;; @@bd9d 313
; bcc _local_1312_21   ; ????make them appear in reverse field, but note ;; @@bd9d 313
; ora #$80  ; that these lines can't be edited without losing them. ;; @@bd9d 313
 ;; @@bd9d 313
_local_1312_21   bbr0 verck,_local_1312_22                 ;; @@bd9d 313
                 jsr indcmp_in1                           ; Compare to memory ;; @@bda0 313
                 beq _local_1312_20                       ; ok ;; @@bda3 313
                 jsr list_exit                             ;; @@bda5 313
                 ldx #ervfy                               ; verify error ;; @@bda8 313
                 +lbra error                               ;; @@bdaa 313
 ;; @@bdad 313
_local_1312_22   jsr sta_far_in1                          ; Load into memory ;; @@bdad 313
                 bra _local_1312_20                       ; loop until eol or error (kernel returns CR in case of error) ;; @@bdb0 313
 ;; @@bdb2 313
_local_1312_25   bbs0 verck,_local_1312_26                 ;; @@bdb2 313
                 lda #0                                    ;; @@bdb5 313
                 jsr sta_far_in1                          ; terminate line with null (replaces CR) ;; @@bdb7 313
_local_1312_26   iny                                       ;; @@bdba 313
                 tya                                       ;; @@bdbb 313
                 clc                                       ;; @@bdbc 313
                 adc index                                 ;; @@bdbd 313
                 sta index                                 ;; @@bdbf 313
                 bcc _local_1312_27                        ;; @@bdc1 313
                 inc index+1                               ;; @@bdc3 313
_local_1312_27   lda index+1                               ;; @@bdc5 313
                 cmp max_mem_0+1                          ; out of memory???? ;; @@bdc7 313
                 bcc _local_1312_10                       ; no, continue until eof ;; @@bdca 313
                 bsr edit_load_done                       ; yes, patch things up best we can ;; @@bdcc 313
                 jsr list_exit                            ; close disk ;; @@bdcf 313
                 +lbra omerr                              ; report error & exit ;; @@bdd2 313
 ;; @@bdd5 313
_local_1312_28   bbs0 verck,_local_1312_30                 ;; @@bdd5 313
                 jsr edit_load_done                       ; EOF: terminate memory with a pair of nulls ;; @@bdd8 313
_local_1312_30   +lbra list_exit                          ; release channel, close file, etc. ;; @@bddb 313
 ;; @@bdde 313
; bbr0 verck,40$ ;; @@bdde 313
; jsr verify_ok  ;if Verify, report 'ok' ;; @@bdde 313
;40$ lda #0   ;exit directly to main???? ;; @@bdde 313
; bra end ;; @@bdde 313
; .page ;; @@bdde 313
edit_load_done                                             ;; @@bdde 314
                 lda #0                                   ; EOF: terminate memory with a pair of nulls ;; @@bdde 314
                 tay                                       ;; @@bde0 314
                 jsr sta_far_in1                           ;; @@bde1 314
                 iny                                       ;; @@bde4 314
                 jsr sta_far_in1                           ;; @@bde5 314
                 inw index                                 ;; @@bde8 314
                 inw index                                 ;; @@bdea 314
                 ldx index                                ; set top ;; @@bdec 314
                 ldy index+1                               ;; @@bdee 314
                 stx text_top                              ;; @@bdf0 314
                 sty text_top+1                            ;; @@bdf2 314
                 +lbra link_program                       ; relink & RTS ;; @@bdf4 314
 ;; @@bdf7 314
; .page ;; @@bdf7 314
edit_save                                                  ;; @@bdf7 314
                 lda #$e6                                 ; parse:  filename [,U#] [,D#] ;; @@bdf7 314
                 jsr dosprs                               ; (like dopen:      0 0 0 *  * 0 0 1 ) ;; @@bdf9 314
                 jsr chk1                                 ; check parameters ;; @@bdfc 314
                 jsr find_la                              ; find an available LA ;; @@bdff 314
                 jsr find_sa                              ; find an available SA ;; @@be02 314
                 ldy #fsavseq                              ;; @@be05 314
                 ldx #8                                    ;; @@be07 314
                 jsr open_file                            ; open the file ;; @@be09 314
                 +lbcs list_err                           ; exit if error ;; @@be0c 314
                 ldx dosla                                 ;; @@be0f 314
                 jsr _chkout                              ; get output channel ;; @@be12 314
                 bcs _local_1313_30                       ; error ;; @@be15 314
 ;; @@be17 314
                 lda txttab                               ; save address ;; @@be17 314
                 ldx txttab+1                              ;; @@be19 314
                 sta index                                 ;; @@be1b 314
                 stx index+1                               ;; @@be1d 314
 ;; @@be1f 314
_local_1313_10   jsr _stop                                ; check stop key ;; @@be1f 314
                 beq _local_1313_30                       ; exit if down ;; @@be22 314
                 jsr _readst                              ; check channel status ;; @@be24 314
                 bne _local_1313_30                       ; exit if eof or error???? ;; @@be27 314
 ;; @@be29 314
                 ldy #3                                   ; save a line, starting past links & line# ;; @@be29 314
_local_1313_20   iny                                      ; bump buffer pointer ;; @@be2b 314
; cpy #buflen  ;check buffer (160 max. input buffer size to edit) ;; @@be2c 314
; beq ??$   ; split long lines into two???? ;; @@be2c 314
                 jsr indin1                                ;; @@be2c 314
                 tax                                      ; save character for eol check ;; @@be2f 314
                 bne _local_1313_21                        ;; @@be30 314
                 lda #cr                                  ; eol: substitute CR ???? allow some other terminator ;; @@be32 314
_local_1313_21   jsr _bsout                               ; write file data ;; @@be34 314
                 txa                                       ;; @@be37 314
                 bne _local_1313_20                       ; loop until eol ;; @@be38 314
 ;; @@be3a 314
                 iny                                      ; advance text index to start of next line ;; @@be3a 314
                 tya                                       ;; @@be3b 314
                 clc                                       ;; @@be3c 314
                 adc index                                 ;; @@be3d 314
                 sta index                                 ;; @@be3f 314
                 bcc _local_1313_26                        ;; @@be41 314
                 inc index+1                               ;; @@be43 314
 ;; @@be45 314
_local_1313_26   ldy #0                                   ; check for EOF: a pair of null links ;; @@be45 314
                 jsr indin1                                ;; @@be47 314
                 bne _local_1313_10                        ;; @@be4a 314
                 iny                                       ;; @@be4c 314
                 jsr indin1                                ;; @@be4d 314
                 bne _local_1313_10                       ; loop until end of text ;; @@be50 314
 ;; @@be52 314
_local_1313_30   +lbra list_exit                          ; release channel, close file, exit ;; @@be52 314
 ;; @@be55 314
;.end ;; @@be55 314
; .page ;; @@be55 314
; .subttl  ETC. ;; @@be55 314
Sound_CLR                                                  ;; @@be55 315
                 jsr chkeos                               ; eat CLR token, check eos   [910717] new ;; @@be55 315
Sound_CLR_1                                                ;; @@be58 315
                 php                                       ;; @@be58 315
                 sei                                       ;; @@be59 315
; jsr go_slow  ;      [910716] 4567R7A ;; @@be5a 315
                 lda #0                                    ;; @@be5a 315
                 ldx #24-1                                 ;; @@be5c 315
_local_1314_40   sta sid1,x                               ; initialize SID chips ;; @@be5e 315
                 sta sid2,x                                ;; @@be61 315
                 dex                                       ;; @@be64 315
                 bpl _local_1314_40                        ;; @@be65 315
 ;; @@be67 315
                 sta filters1+2                           ; set filters off ;; @@be67 315
                 sta filters2+2                            ;; @@be6a 315
 ;; @@be6d 315
                 lda #8                                   ; set default volume ;; @@be6d 315
                 sta filters1+3                            ;; @@be6f 315
                 sta filters2+3                           ; [910612] ;; @@be72 315
; sta filters+4  ;why?      [910612] ;; @@be75 315
                 sta sid1+24                               ;; @@be75 315
                 sta sid2+24                               ;; @@be78 315
 ;; @@be7b 315
; jsr go_fast  ;      [910716] 4567R7A ;; @@be7b 315
 ;; @@be7b 315
                 bit _pal_ntsc                            ; determine if PAL or NTSC system  [910724] ;; @@be7b 315
                 bmi _local_1314_1                        ; ...branch if PAL ;; @@be7e 315
                 lda #<beats_ntsc/4                       ; set beat to quarter note (4/4 time = .5 sec) ;; @@be80 315
                 ldy #>beats_ntsc/4                        ;; @@be82 315
                 bra _local_1314_2                         ;; @@be84 315
_local_1314_1    lda #<beats_pal/4                         ;; @@be86 315
                 ldy #>beats_pal/4                         ;; @@be88 315
_local_1314_2    sta ntime                                 ;; @@be8a 315
                 sty ntime+1                               ;; @@be8d 315
 ;; @@be90 315
                 lda #4                                   ; set default octave ;; @@be90 315
                 sta octave                                ;; @@be92 315
                 lda #12                                  ; set default tempo    [910220] ;; @@be95 315
                 sta tempo_rate                           ; 12 makes whole note in 4/4 time last 2 seconds ;; @@be97 315
 ;; @@be9a 315
                 ldy #30-1                                ; initialize music tables ;; @@be9a 315
_local_1314_10   lda atkmus,y                              ;; @@be9c 315
                 sta atktab,y                              ;; @@be9f 315
                 dey                                       ;; @@bea2 315
                 bpl _local_1314_10                        ;; @@bea3 315
 ;; @@bea5 315
                 ldx #10-1                                ; initialize pulse widths ;; @@bea5 315
_local_1314_20   lda pwhmus,x                              ;; @@bea7 315
                 sta pulshi,x                              ;; @@beaa 315
                 dex                                       ;; @@bead 315
                 bpl _local_1314_20                        ;; @@beae 315
 ;; @@beb0 315
                 txa                                      ; $ff ;; @@beb0 315
                 ldx #6-1                                 ; stereo SIDs   (save space) [911119] ;; @@beb1 315
                 ldy #1                                    ;; @@beb3 315
_local_1314_25   sta sound_time_hi,x                      ; turn all SOUND counters off ;; @@beb5 315
                 sta voices,y                             ; turn all PLAY counters off ;; @@beb8 315
                 iny                                       ;; @@bebb 315
                 iny                                       ;; @@bebc 315
                 dex                                       ;; @@bebd 315
                 bpl _local_1314_25                        ;; @@bebe 315
 ;; @@bec0 315
                 ldy #6-1                                 ; set default envelope (piano) for all voices (6) ;; @@bec0 315
                 sty voice                                 ;; @@bec2 315
_local_1314_30   ldx #0                                    ;; @@bec5 315
                 jsr set_envelope_1                        ;; @@bec7 315
                 dec voice                                 ;; @@beca 315
                 bpl _local_1314_30                        ;; @@becd 315
                 inc voice                                ; set default voice (0) ;; @@becf 315
 ;; @@bed2 315
                 plp                                       ;; @@bed2 315
                 rts                                       ;; @@bed3 315
 ;; @@bed4 315
; .page ;; @@bed4 315
Sprite_CLR                                                 ;; @@bed4 316
                 jsr chkeos                               ; eat CLR token, check eos   [910717] new ;; @@bed4 316
Sprite_CLR_1                                               ;; @@bed7 316
                 php                                       ;; @@bed7 316
                 sei                                       ;; @@bed8 316
                 lda #0                                    ;; @@bed9 316
                 sta vic+21                               ; Turn off all sprites ;; @@bedb 316
                 sta vic+23                               ; Unexpand them     [910828] ;; @@bede 316
                 sta vic+27                               ; Sprite priority ;; @@bee1 316
                 sta vic+28                               ; Hires sprites ;; @@bee4 316
                 sta vic+29                                ;; @@bee7 316
 ;; @@beea 316
                 ldx #init_as_0                           ; Init sprite tables ;; @@beea 316
_local_1315_40   sta sprite_data,x                         ;; @@beec 316
                 dex                                       ;; @@beef 316
                 bpl _local_1315_40                        ;; @@bef0 316
 ;; @@bef2 316
                 lda #sprite_base/64+7                    ; Set up sprite pointers ;; @@bef2 316
                 ldy #7                                    ;; @@bef4 316
_local_1315_10   bbr7 _mode,_local_1315_20                 ;; @@bef6 316
                 sta sprite_ptrs_40,y                     ; 40 col screen ;; @@bef9 316
                 bra _local_1315_30                        ;; @@befc 316
_local_1315_20   sta sprite_ptrs_80,y                     ; 80 col screen ;; @@befe 316
_local_1315_30   dec                                       ;; @@bf01 316
                 dey                                       ;; @@bf02 316
                 bpl _local_1315_10                        ;; @@bf03 316
 ;; @@bf05 316
                 plp                                       ;; @@bf05 316
; rts ;; @@bf06 316
 ;; @@bf06 316
;.end ;; @@bf06 316
; .page ;; @@bf06 316
; .subttl BASIC NMI Handler ;; @@bf06 316
 ;; @@bf06 316
basic_nmi                                                 ; removed [910826] ;; @@bf06 317
; lda nmi_wrap_flag ;filter out wrapped NMI calls   [910523] audio ;; @@bf06 317
; beq 1$   ; it's ok ;; @@bf06 317
; rts   ; exit- we're already handling one interrupt ;; @@bf06 317
; ;; @@bf06 317
;1$ inc nmi_wrap_flag ;shut the door to NMI ;; @@bf06 317
; ;; @@bf06 317
;basic_nmi_end ;; @@bf06 317
; dec nmi_wrap_flag ;open the door to NMI ;; @@bf06 317
                 rts                                       ;; @@bf06 317
 ;; @@bf07 317
; .ifgt *-$c000 ;; @@bf07 317
; .messg ***ROM OVERFLOW: $C000 ;; @@bf07 317
; .endif ;; @@bf07 317
;.end ;; @@bf07 317
; .page ;; @@bf07 317
; .subttl C65 BASIC Jump Table ;; @@bf07 317
 ;; @@bf07 317
                 * = $7f00                                 ;; @@bf07 317
 ;; @@7f00 317
 ;; @@7f00 317
; Format Conversions     [6] ;; @@7f00 317
 ;; @@7f00 317
                 +lbra ayint                              ; convert floating point to integer ;; @@7f00 317
                 +lbra givayf                             ; convert integer to floating point ;; @@7f03 317
                 +lbra fout                               ; convert floating point to PETSCII string ;; @@7f06 317
                 +lbra val_1                              ; convert PETSCII string to floating point ;; @@7f09 317
                 +lbra getadr                             ; convert floating point to an address ;; @@7f0c 317
                 +lbra floatc                             ; convert address to floating point ;; @@7f0f 317
 ;; @@7f12 317
; Math Functions     [24] ;; @@7f12 317
 ;; @@7f12 317
                 +lbra fsub                               ; MEM - FACC ;; @@7f12 317
                 +lbra fsubt                              ; ARG - FACC ;; @@7f15 317
                 +lbra fadd                               ; MEM + FACC ;; @@7f18 317
                 +lbra faddt_c65                          ; ARG - FACC      [910402] ;; @@7f1b 317
                 +lbra fmult                              ; MEM * FACC ;; @@7f1e 317
                 +lbra fmultt_c65                         ; ARG * FACC      [910402] ;; @@7f21 317
                 +lbra fdiv                               ; MEM / FACC ;; @@7f24 317
                 +lbra fdivt_c65                          ; ARG / FACC      [910402] ;; @@7f27 317
                 +lbra log                                ; compute natural log of FACC ;; @@7f2a 317
                 +lbra int                                ; perform BASIC INT() on FACC ;; @@7f2d 317
                 +lbra sqr                                ; compute square root of FACC ;; @@7f30 317
                 +lbra negop                              ; negate FACC ;; @@7f33 317
                 +lbra fpwr                               ; raise ARG to the MEM power ;; @@7f36 317
                 +lbra fpwrt                              ; raise ARG to the FACC power ;; @@7f39 317
                 +lbra exp                                ; compute EXP of FACC ;; @@7f3c 317
                 +lbra cos                                ; compute COS of FACC ;; @@7f3f 317
                 +lbra sin                                ; compute SIN of FACC ;; @@7f42 317
                 +lbra tan                                ; compute TAN of FACC ;; @@7f45 317
                 +lbra atn                                ; compute ATN of FACC ;; @@7f48 317
                 +lbra round                              ; round FACC ;; @@7f4b 317
                 +lbra abs                                ; absolute value of FACC ;; @@7f4e 317
                 +lbra sign                               ; test sign of FACC ;; @@7f51 317
                 +lbra fcomp                              ; compare FACC with MEM ;; @@7f54 317
                 +lbra rnd_0                              ; generate random floating point number ;; @@7f57 317
 ;; @@7f5a 317
; Movement      [22] ;; @@7f5a 317
 ;; @@7f5a 317
                 +lbra conupk                             ; move RAM MEM to ARG ;; @@7f5a 317
                 +lbra romupk                             ; move ROM MEM to ARG ;; @@7f5d 317
                 +lbra movfrm                             ; move RAM MEM to FACC ;; @@7f60 317
                 +lbra movfm                              ; move ROM MEM to FACC ;; @@7f63 317
                 +lbra movmf                              ; move FACC to MEM ;; @@7f66 317
                 +lbra movfa                              ; move ARG to FACC ;; @@7f69 317
                 +lbra movaf                              ; move FACC to ARG ;; @@7f6c 317
 ;; @@7f6f 317
; bra optab ;????not executable ;; @@7f6f 317
; bra drawln ;; @@7f6f 317
; bra gplot ;; @@7f6f 317
; bra cirsub ;; @@7f6f 317
                 +lbra run                                 ;; @@7f6f 317
                 +lbra runc                                ;; @@7f72 317
                 +lbra clearc                             ; [910410] ;; @@7f75 317
                 +lbra new                                 ;; @@7f78 317
                 +lbra link_program                        ;; @@7f7b 317
                 +lbra crunch                              ;; @@7f7e 317
                 +lbra FindLine                            ;; @@7f81 317
                 +lbra newstt                              ;; @@7f84 317
                 +lbra eval                                ;; @@7f87 317
                 +lbra frmevl                              ;; @@7f8a 317
                 +lbra run_a_program                       ;; @@7f8d 317
                 +lbra setexc                              ;; @@7f90 317
                 +lbra linget                              ;; @@7f93 317
                 +lbra garba2                              ;; @@7f96 317
                 +lbra execute_a_line                      ;; @@7f99 317
 ;; @@7f9c 317
; Temporaries for C65 development (???? used by graphics) [12] ;; @@7f9c 317
 ;; @@7f9c 317
                 +lbra chrget                              ;; @@7f9c 317
                 +lbra chrgot                              ;; @@7f9f 317
                 +lbra chkcom                              ;; @@7fa2 317
                 +lbra frmnum                              ;; @@7fa5 317
                 +lbra getadr                              ;; @@7fa8 317
                 +lbra getnum                              ;; @@7fab 317
                 +lbra getbyt                              ;; @@7fae 317
                 +lbra plsv                                ;; @@7fb1 317
 ;; @@7fb4 317
                 +lbra lda_far_ram0                       ; lda (.x),y from BASIC text bank [910716] ;; @@7fb4 317
                 +lbra lda_far_ram1                       ; lda (.x),y from BASIC variable bank [910716] ;; @@7fb7 317
                 +lbra sta_far_ram0                       ; sta (.x),y to   BASIC text bank [910716] ;; @@7fba 317
                 +lbra sta_far_ram1                       ; sta (.x),y to   BASIC variable bank [910716] ;; @@7fbd 317
 ;; @@7fc0 317
; .page ;; @@7fc0 317
; Graphic Kernel Call. (Temporary for C65 development ????) ;; @@7fc0 317
; ;; @@7fc0 317
;  syntax:  GRAPHIC command# [,args] ;; @@7fc0 317
; ;; @@7fc0 317
; Basically this is a modified C64-type SYS command, minus the address. ;; @@7fc0 317
; In the final C65 system, this will represent the ML interface, not the ;; @@7fc0 317
; BASIC 10.0 interface which is implemented here in the development system. ;; @@7fc0 317
 ;; @@7fc0 317
 ;; @@7fc0 317
graphic                                                    ;; @@7fc0 317
                 cmp #clr_token                           ; GRAPHIC CLR (graphic system initialize) ;; @@7fc0 317
                 bne _local_1316_10                       ; no ;; @@7fc2 317
                 jsr chrget                               ; yes advance past token ;; @@7fc4 317
                 jmp ($8000)                              ; go initialize graphic kernel ;; @@7fc7 317
 ;; @@7fca 317
_local_1316_10                                             ;; @@7fca 317
; tax ;; @@7fca 317
; bmi snerr  ;Syntax error if any other secondary token ;; @@7fca 317
; ;; @@7fca 317
; ;; @@7fca 317
                 jmp (graphic_vector)                     ; Else, call the Graphics Kernel's Parser... ;; @@7fca 317
; ;; @@7fcd 317
; ;; @@7fcd 317
graphic_kernel                                            ; ...via indirect ;; @@7fcd 318
                 jmp ($8002)                               ;; @@7fcd 318
 ;; @@7fd0 318
; .page ;; @@7fd0 318
; C65 Graphic Kernel Jump Table      [910826] ;; @@7fd0 318
; ;; @@7fd0 318
; 8000 init   ;sets up graphic vars ;; @@7fd0 318
; 8002 parser   ;GRAPHIC ML Parser???? ;; @@7fd0 318
; ;; @@7fd0 318
; 8004 kg65.start-1  ;0 commands ;; @@7fd0 318
; 8006 kg65.screendef-1 ;1 ;; @@7fd0 318
; 8008 kg65.screenopen-1 ;2 ;; @@7fd0 318
; 800a kg65.screenclose-1 ;3 ;; @@7fd0 318
; 800c kg65.screenclear-1 ;4 ;; @@7fd0 318
; 800e kg65.screen-1  ;5 ;; @@7fd0 318
; 8010 kg65.setpen-1  ;6 ;; @@7fd0 318
; 8012 kg65.setpalette-1 ;7 ;; @@7fd0 318
; 8014 kg65.setdmode-1  ;8 ;; @@7fd0 318
; 8016 kg65.setdpat-1  ;9 ;; @@7fd0 318
; 8018 kg65.line-1  ;10 ;; @@7fd0 318
; 801a kg65.box-1  ;11 ;; @@7fd0 318
; 801c kg65.circle-1  ;12 ;; @@7fd0 318
; 801e kg65.polygon-1  ;13 ;; @@7fd0 318
; 8020 kg65.ellipse-1  ;14 ;; @@7fd0 318
; 8022 kg65.viewpclr-1  ;15 ;; @@7fd0 318
; 8024 kg65.copy-1  ;16 ;; @@7fd0 318
; 8026 kg65.cut-1  ;17 ;; @@7fd0 318
; 8028 kg65.paste-1  ;18 ;; @@7fd0 318
; 802a kg65.load-1  ;19 ;; @@7fd0 318
; 802c kg65.char-1  ;20 ;; @@7fd0 318
; 802e kg65.paint-1  ;21 ;; @@7fd0 318
; 8030 kg65.viewpdef-1  ;22 ;; @@7fd0 318
; 8032 kg65.f.pixel-1  ;23 ;; @@7fd0 318
; 8034 kg65.f.rpalette-1 ;24 ;; @@7fd0 318
; 8036 kg65.f.index2color-1 ;25 ;; @@7fd0 318
; 8038 kg65.f.rgraphic  ;26 ;; @@7fd0 318
 ;; @@7fd0 318
; .ifgt *-$8000 ;; @@7fd0 318
; .messg ***ROM OVERFLOW: $8000 ;; @@7fd0 318
; .endif ;; @@7fd0 318
; .end ;; @@7fd0 318
