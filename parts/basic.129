dimrts rts 
 
 .page 
; Integer arithmetic routines. 
; 
; Two byte unsigned integer multiply. 
; This is for multiply dimensioned arrays. 
; (a,b)=(curtol)*(5&6,x). 
 
umult 
 sty index 
 jsr indlow_ram1 
 sta addend ;low, then high 
 dey 
 jsr indlow_ram1 ;put (5&6,lowtr) in faster memory 
 
umultd sta addend+1 
 lda #16 
 sta deccnt 
 ldx #0  ;clear the accs 
 ldy #0  ;result initially zero 
 
umultc txa 
 asl a  ;multiply by two 
 tax 
 tya 
 rol a 
 tay 
 bcs omerr ;to much! 
 asl curtol 
 rol curtol+1 
 bcc umlcnt ;nothing in this position to multiply 
 clc 
 txa 
 adc addend 
 tax 
 tya 
 adc addend+1 
 tay 
 bcs omerr ;man, just too much! 
 
umlcnt dec deccnt ;done? 
 bne umultc ;keep it up 
 rts  ;yes, all done 
 
 
fmaptr lda count 
 asl a 
 adc #5  ;point to entries. ((c) cleared by asl) 
 adc lowtr 
 ldy lowtr+1 
 bcc 1$ 
 iny 
1$ sta arypnt 
 sty arypnt+1 
 rts 
 
;.end 
 .page 
 .subttl  TIME functions 
 
; TI$="hh:mm:ss.t" Allows optional colons to delimit parameters and 
;   allows input to be abbrieviated (eg., TI$="h:mm" or 
;   even TI$=""), defaulting to "00" for unspecified 
;   parameters.  24-hour clock (00:00:00.0 to 23:59:59.9). 
;   901010 F.Bowen 
 
Set_TI_String 
 jsr frefac  ;we won't need it 
 sta count  ;save length 
 
 ldy #0   ;our pointer into TI$ assignment 
 sty time  ;default time to zero, in case it's not fully specified 
 sty time+1 
 sty time+2 
 sty time+3 
 
 ldx #3   ;parameter pointer (3=hr,2=min,1=sec,0=tenths) 
10$ jsr GetTimeDigit ;get first digit, convert to BCD 
 bcs 20$   ; colon or eos 
 sta time,x 
 jsr GetTimeDigit ;get second digit, convert to BCD 
 bcs 20$   ; colon or eos 
 
 asl time,x  ;move first digit to msd 
 asl time,x 
 asl time,x 
 asl time,x 
 ora time,x  ;combine with second digit 
 sta time,x  ;now we have a time element of packed BCD 
 
20$ lda time,x 
 cmp MaxTimeValues,x ;  check for parameter too big 
 bcs fcerr  ; hr>23, min>59, sec>59, tenths>9 
 
 dex   ;  check if done 
 bmi 30$   ; yes- all parameters accounted for 
 cpy count 
 bcs 40$   ; yes- end of string 
 
 jsr indin1_ram1  ;  check for optional colon (or period)   [910103] 
 cmp #':' 
 beq 25$ 
 cmp #'.' 
 bne 10$   ; not there 
25$ iny   ; it's there- skip over it 
 
 bra 10$   ;loop until done 
 
 
30$ cpy count  ;done 
 bcc errlen  ; error if string too long 
 
40$ ldz time  ;tenths  0-9 
 lda time+1  ;seconds 0-59 
 ldx time+2  ;minutes 0-59 
 ldy time+3  ;hours  0-23 
 jmp _SetTime  ;Go set time & exit 
 
 .page 
; Get an ASCII digit, make sure it's in range 0-9 or a colon. 
; if no digit to get, default to '0' 
; 
; exit with .c=0 if okay  (.A contains BCD) 
;    .c=1 if colon or eos (.A invalid) 
 
GetTimeDigit 
 lda #0   ;default to '0' 
 cpy count 
 bcs 10$   ;exit if at end of string (carry set) 
 
 jsr indin1_ram1  ;else get a character from string 
 iny   ;point to next character 
 cmp #'.'  ;       [910103] 
 beq 10$   ; terminator (period) (carry set) 
 cmp #'0'  ;check character, only 0-9 allowed 
 bcc fcerr  ; too small 
 cmp #':' 
 bcc 10$   ; just right  (carry clear) 
 bne fcerr  ; too big 
    ; falls through if colon (carry set) 
 
10$ and #$0f  ;make BCD 
 rts 
 
 
 
MaxTimeValues 
 .byte  $10,$60,$60,$24 ;t,s,m,h in packed BCD 
 
 .page 
; x$=TI$  Return a string of the form "hh:mm:ss.t", including colons. 
 
Get_TI_String 
 jsr ReadSystemClock ;get time as packed BCD 
 
 lda #10   ;get string space for 10 characters 
 jsr strspa 
 tay   ; length 
 dey   ; index 
 
 lda time  ;build TI$ string in 'fbuffr' 
 ora #'0'  ; (build string backwards, from last chr to first) 
 ldx #dsctmp+1 
 jsr sta_far_ram1 ; put tenths (special case- only 1 digit) 
 dey 
 lda #'.' 
 jsr sta_far_ram1 ; put period (special case)   [910103] 
 dey 
 ldx #1 
 bra 20$ 
 
10$ phx   ;element pointer (1=secs, 2=mins, 3=hrs) 
 ldx #dsctmp+1 
 lda #':' 
 jsr sta_far_ram1 ; put colon 
 dey 
 plx 
 
20$ lda time,x 
 taz 
 and #$0f  ; do lsd first, since we're working backwards 
 ora #'0' 
 phx 
 ldx #dsctmp+1 
 jsr sta_far_ram1 ;  put lsd 
 dey 
 tza   ; then do msd 
 lsr a 
 lsr a 
 lsr a 
 lsr a 
 ora #'0' 
 jsr sta_far_ram1 ;  put msd 
 plx 
 inx   ; next packed element 
 dey 
 bpl 10$   ;loop until done 
 
 lda #10   ;length 
 jsr mvdone  ;update frespc ???? 
 bra putnew  ;make descriptor in dsctmp real 
 
 .page 
; TI. Convert 24-hour TOD into tenths of seconds.  901010 F.Bowen 
 
Get_TI 
 jsr ReadSystemClock ;glance at the clock, get time as h:m:s:t 
 stz faclo  ;init accumulator with tenths (0-9, so nothing to convert) 
 ldz #0 
 stz facmo 
 stz facmoh 
 
 ldx #3   ;convert time (BCD) to tenths of seconds (binary) since midnight 
10$ jsr TimeMultiply 
 clc 
 adc faclo 
 sta faclo 
 lda product+1 
 adc facmo 
 sta facmo 
 lda product+2 
 adc facmoh 
 sta facmoh  ; (can't overflow since 23:59:59:9 -> 863999 ($0D2EFF) 
 dex 
 bne 10$   ;next factor 
 
 lda #0   ;float value in FAC 
 sta facho  ; zero msb, facov, facsgn 
 ldx #160  ; set facov for time 
 sec   ; normal fac 
 bra floatb  ; do it 
 
 
 
ReadSystemClock 
 jsr _ReadTime  ;get packed BCD, y=hrs, x=min, a=sec, z=tenths 
    ; (assumes system clock was set properly!) 
 stz time  ; tenths  0-9 
 sta time+1  ; seconds  0-59 
 stx time+2  ; minutes  0-59 
 sty time+3  ; hours  0-59 
 rts 
 
 .page 
; Unsigned Integer Multiply: Time * Factor  -> Tenths_of_Seconds 
;     A   *  (B,C)  ->      (D,E,F) 
 
TimeMultiply 
 lda time,x  ;convert packed BCD to binary 
 and #$0f 
 sta facho 
 lda time,x  ; 10x = 8x + 2x 
 and #$f0 
 lsr a   ;  msd x 8 
 sta time,x 
 lsr a 
 lsr a   ;  msd x 2 
 clc 
 adc facho  ;  lsd 
 adc time,x 
 sta time,x  ;  can't overflow ($99->153) 
 
 txa   ;make a word pointer from byte pointer 
 asl a 
 tay 
 lda TimeFactor-2,y ;multiplicand = TimeFactor,y  (2 bytes) 
 sta multiplicand ;multiplier = Time,x x (1 byte) 
 lda TimeFactor-1,y ;                              ----------- 
 sta multiplicand+1 
 lda #0   ;product lo   (3 bytes) 
 sta product+1  ;  mid 
 sta product+2  ;  hi 
 
 ldy #16   ;16-bit multiplicand 
10$ asl a 
 row product+1 
 row multiplicand ;multiplier * multiplicand -> product 
 bcc 20$ 
 clc 
 adc time,x 
 bcc 20$ 
 inw product+1  ;(does no error check, since using time factors 
20$ dey   ; in ROM and maximum time multiplier of 59 there 
 bne 10$   ; is no danger of overflow) 
 
; sta product 
 rts   ;(.X is preserved) 
 
 
TimeFactor 
 .word 10  ;tenths per second  (max    59*10 =    590 ($0024E) 
 .word 600  ; per minute  (max   59*600 =  35400 ($08A48) 
 .word 36000  ; per hour    (max 23*36000 = 828000 ($CA260) 
 
 .page 
 .subttl  SLEEP 
 
;******************************************************************************* 
;* 
;* SLEEP Command - Postpone all activity for a specified number of seconds 
;* 
;* Syntax:  SLEEP n 
;* 
;* Where n is the number of seconds to remain inactive, 
;* expressed as a positive value < 65536. 
;* 
;******************************************************************************* 
 