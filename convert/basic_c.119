ds_rts           rts                                      

; .page
is_numeric                                                
                 bbr7 intflg,is_floating                  ; branch if not an integer
                 ldy #0                                   
                 jsr indfmo                               ; fetch high
                 tax                                      
                 iny                                      
                 jsr indfmo                               ; fetch low
                 tay                                      ; put low in y
                 txa                                      ; get high in a
                 +lbra givayf                             ; float and return


; Screen out TI, ST, ER, and EL, and assign values to them.  First test
; if the pointer points to "ROM" zero.  If not, it can't be any of the above.

is_floating                                               
                 lda facmo+1                              
                 cmp #>zero                               
                 bne gomovf                               ; not TI, etc.
                 lda facmo                                
                 cmp #<zero                               
                 bne gomovf                               ; not TI, etc.

; .page
; The pointer does point to the ROM zero.  Now it is necessary to
; examine the actual variable name case by case.

                 cpx #'T'                                 ; TI?
                 bne qstatv                               ; no
                 cpy #'I'                                 
                 bne gomovf                               ; no, and it can't be ST either
                 +lbeq Get_TI                             


qstatv           cpx #'S'                                 ; ST?
                 bne qdsav                                ; no, go test DS
                 cpy #'T'                                 
                 bne gomovf                               
                 jsr _readst                              ; (???? system bank for rs232 st)
                 +lbra float                              


qdsav            cpx #'D'                                 ; DS?
                 bne qerlin                               ; no, go test ER & EL
                 cpy #'S'                                 
                 bne gomovf                               

; Get disk status - make the first two characters of DS$ string into a number.

                 jsr Check_DS                             ; get a DS$ string if one doesn't exist already
                 ldy #0                                   
                 lda #dsdesc+1                            
                 jsr lda_far_ram1                         ; lda (dsdesc+1),y
                 and #$0f                                 
                 asl                                      
                 sta garbfl                               
                 asl                                      
                 asl                                      
                 adc garbfl                               
                 sta garbfl                               
                 iny                                      
                 lda #dsdesc+1                            
                 jsr lda_far_ram1                         ; lda (dsdesc+1),y
                 and #$0f                                 
                 adc garbfl                               
                 +lbra float                              


qerlin           cpx #'E'                                 ; ER or EL?
                 bne gomovf                               
                 cpy #'R'                                 
                 beq qnumer                               
                 cpy #'L'                                 
                 bne gomovf                               

                 lda errlin+1                             ; want EL (last error line #)
                 ldy errlin                               
                 +lbra nosflt                             

qnumer           lda errnum                               ; want ER (number of last error)
                 +lbra float                              

; .page
gomovf           lda facmo                                
                 ldy facmo+1                              

movfrm           sta index1                               ; move value from RAM
                 sty index1+1                             

                 ldy #0                                   
                 jsr indin1_ram1                          
                 sta facexp                               
                 sty facov                                

                 iny                                      ; (1)
                 jsr indin1_ram1                          
                 sta facsgn                               
                 ora #$80                                 
                 sta facho                                

                 iny                                      ; (2)
                 jsr indin1_ram1                          
                 sta facmoh                               

                 iny                                      ; (3)
                 jsr indin1_ram1                          
                 sta facmo                                

                 iny                                      ; (4)
                 jsr indin1_ram1                          
                 sta faclo                                
                 rts                                      

;.end
; .page
; .subttl Variable Search

;  Read the variable name at the current text position and put a pointer
;  to its value in VARPNT.   TXTPTR points to the terminating character.
;  Note that evaluating subscripts in a variable name can cause recursive
;  calls to PTRGET, so all values must be stored on the stack.

ptrget           ldx #0                                   
                 jsr chrgot                               
ptrgt1           stx dimflg                               ; store flag away
ptrgt2           sta varnam                               
                 jsr chrgot                               ; get current character
                 jsr isletc                               ; check for a letter
                 +lbcc snerr                              ; not a letter

                 ldx #0                                   ; assume no second character
                 stx valtyp                               ; default is numeric
                 stx intflg                               ; assume floating
                 jsr chrget                               ; get following character
                 bcc _local_1118_10                       ; branch if numeric
                 jsr isletc                               ; is it alpha?
                 bcc _local_1118_30                       ; no, no second character. branch
_local_1118_10   tax                                      ; issec. save second character of name

_local_1118_20   jsr chrget                               ; skip over remainder of name. we only care about 2 chars.
                 bcc _local_1118_20                       ; ..eat numbers,
                 jsr isletc                               
                 bcs _local_1118_20                       ; ..and alphas, too!

_local_1118_30   cmp #'$'                                 ; nosec. is this a string?
                 bne _local_1118_40                       ; if not, VALTYP = 0
                 lda #$ff                                 
                 sta valtyp                               ; ..else, flag 'string'
                 bra _local_1118_50                       

_local_1118_40   cmp #'%'                                 ; notstr. isn't string. is it integer?
                 bne _local_1118_60                       ; branch if not
                 lda subflg                               
; bne snerr ; syntax error if integers disabled
                 +lbne chkerr                             ; integers disallowed- type mismatch error  [910114]
                 lda #$80                                 ; flag integer by turning on both high bits
                 sta intflg                               
                 tsb varnam                               

_local_1118_50   txa                                      ; turnon. turn on msb of second character
                 ora #$80                                 
                 tax                                      
                 jsr chrget                               ; get character after $ or %

_local_1118_60   stx varnam+1                             ; strnam. store away second character
                 sec                                      
                 ora subflg                               ; add flag whether to allow arrays
                 sbc #'('                                 
                 +lbeq is_array                           ; note: won't match if SUBFLG set

                 ldy #0                                   
                 sty subflg                               ; allow subscripts again
                 lda vartab                               ; place to start search
                 ldx vartab+1                             

_local_1118_70   stx lowtr+1                              ; stxfnd.
_local_1118_80   sta lowtr                                
                 cpx arytab+1                             ; at end of table yet?
                 bne _local_1118_90                       
                 cmp arytab                               
                 beq notfns                               ; yes, we couldn't find it

_local_1118_90   jsr indlow_ram1                          ; lda (lowtr),y
                 cmp varnam                               ; compare high orders
                 bne _local_1118_100                      
                 iny                                      
                 jsr indlow_ram1                          
                 cmp varnam+1                             ; and the low part?
                 +lbeq finptr                             ; !!that's it!!

                 dey                                      
_local_1118_100  clc                                      
                 lda lowtr                                
                 adc #7                                   ; makes no difference among types
                 bcc _local_1118_80                       
                 inx                                      
                 bra _local_1118_70                       ; branch always




; Test for a letter: (c)=0 not a letter
;   (c)=1 a letter

